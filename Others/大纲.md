# 关于登录、比赛与回合进行

登录 → 加载存档/新建存档 → 下一回合

一个 User 底下有多个 Save，一个 Save 底下有多个 League

## 表结构

### Save

- time：世界时间（精确到日）

- List[League]

- user_id

- Calendar：一张总日程表（记录一些通用事项，如转会期、球员刷新期等）

### League

- List[Club]

- ~~一张日程表~~
- 上游联赛 id
- 下游联赛 id

### Calendar

作为 Save 的一个字段存放，一对多

- save_id
- date：日期
- event_str：以字符串格式存放的事件（可以用 "," 来分割）

在程序中，以字典结构呈现：`Dict{Date : List[event_str]}`，预计有 365 个键

### message 表

作为 Save 的一个字段存放，一对多

- type：标记通知的类型
- json_str：用来存放关键参数（本质上是个 json，实际以字符串形式保存）
- time：创建日期（游戏时间）
- is_read：是否被玩家阅读
    - 创建时默认为 false，在（check 操作中）返回给前端后更改为 true

## 回合行进

客户端发送请求（请求体带上回合数 `turn`），服务端 API `/next-turn` 接收到请求，日期 +1，然后进行一个总体的 check

API 主要作用

- 推动游戏运行
- 返回通知数量（便于前端）

### check 内容

在 Calendar 表中找到本日事项，并分别完成

- 事项的检查与处理再封装一层
    - 其中包含对该类事项的检查、事项触发的游戏行为、将事项保存到数据库

读取 `Calendar` 数据库，统计 `is_read` 状态为 `false` 的事项**数量**返回给服务，并且全部改为 `false`

（小细节）前端在请求事项列表 `/events` 时，可以根据储存的全局变量“未读事项数量”（由 check API 返回）来将事项染红

### 事项

#### 玩家与 AI 的比赛日

应该最后一个执行

- 调用 `gamePvE` 启动模块

- 返回一个信号，提醒前端应该转到 `/gamePvE` 界面进行比赛

AI 之间的比赛日

转会期

随机球员生成日

AI 教练优化战术日

特殊提示日

事件预告

### 通知内容

考虑将通知全文返回，还是将一些关键参数返回，而在客户端进行具体语句的构建（倾向于全文返回，即在**后端**构建整个通知文字）

注意，返回通知时，如果需要在前端界面做可点击式语句（链接），还需要返回语句的访问 url（高级内容，以后再说）

通知内容需要存放到数据库中。

（进阶）在前端 sidebar 上显示最新更新的通知气泡，需要后端

## gamePvE

### GamePvE

一个临时表，专门记录比赛中途的实时数据变化

为了删除方便，可以设置级联删除，例：

```python
class Child(Base):
    __tablename__ = "children"

    id = Column(Integer, primary_key=True)
    parent_id = Column(Integer, ForeignKey("parents.id", ondelete='CASCADE'))

class Parent(Base):
    __tablename__ = "parents"

    id = Column(Integer, primary_key=True)
    child = relationship(Child, backref="parent", passive_deletes=True)
```

#### 字段

- club1_id
- club2_id
- turns：回合数
- teams：List[TeamPvE]
- script：比赛解说

#### TeamPvE

- team_id
- score
- players：List[PlayerPvE]
- 以下是球队的比赛数据
- attempts
- wing_cross
- wing_cross_success
- under_cutting
- under_cutting_success
- pull_back
- pull_back_success
- middle_attack
- middle_attack_success
- counter_attack
- counter_attack_success

#### PlayerPvE

- player_id
- location：初始位置
- realtime_location：实时位置
- realtime_stamina：实时体力
- 以下是球员比赛数据
- original_stamina：初始体力值
- actions：动作数
- goals
- assists
- shots
- dribbles
- dribble_success
- passess
- pass_success
- tackles
- tackle_success
- aerials
- aerial_success
- saves
- save_success
- final_rating

关于球员属性的提取，建议根据 player_id 直接在 Player 表里拿，PvE表的原则是：只存比赛的临时数据

### 激活模块

激活条件：在事项检查中，认定本日有玩家与 AI 的比赛后，读取 `Calendar` 中两队 `id`，传进启动函数中，至此完成激活动作

创建一个临时数据库 `GamePvE`，仅传入两个 `club_id` 即可

### 初始化模块

初始化条件：玩家选好战术和球员，点击比赛开始后，创建两队数据的子表，即完成初始化动作

读取战术和球员信息，继续完善构建 `GamePvE`

返回数据

### 战术回合模块

战术进攻条件：前端发出“进行新的战术回合”请求后，后端 API `/game-pve/next-turn` 调用此模块

创建球队和球员对象，将 `GamePvE` 内容读入对象中

根据球权决定哪一队发起进攻

进行**战术进攻**

结束战术进攻，更新球权、比分、球员体力等等变化

返回更新后的数据

### 换人模块

换人条件：前端发出换人请求后，后端 API `game-pve/substitution` 调用此模块

接受一个换人信息参数，形如：

```json
[
    {"replace":player1_id,"replaced":player2_id},
    {"replace":player3_id,"replaced":player4_id},
    ...
]
```

在数据库中，将两人的位置信息做替换即可

记得根据换人名额做检查

最后返回换人是否成功的标志

## 日程表的生成

日程表应该在赛季开始前生成

