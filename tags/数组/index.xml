<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>数组 - 标签 - 伤心肠粉的酱油碟子</title><link>https://trouvaille0198.github.io/Notes/tags/%E6%95%B0%E7%BB%84/</link><description>数组 - 标签 - 伤心肠粉的酱油碟子</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 10 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trouvaille0198.github.io/Notes/tags/%E6%95%B0%E7%BB%84/" rel="self" type="application/rss+xml"/><item><title>349. 两个数组的交集</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/349.-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</link><pubDate>Thu, 10 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/349.-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</guid><description>349. 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 1 2 输入：num</description></item><item><title>384. 打乱数组</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</link><pubDate>Tue, 08 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/</guid><description>384. 打乱数组 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对</description></item><item><title>54. 螺旋矩阵</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid><description>54. 螺旋矩阵 mid 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 1 2 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,</description></item><item><title>283. 移动零</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</guid><description>283. 移动零 easy 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组</description></item><item><title>367. 有效的完全平方数</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid><description>367. 有效的完全平方数 easy 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 进阶：不要 使用任何内置的库函数，如 sqrt 。 示例</description></item><item><title>69. x 的平方根</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/</guid><description><![CDATA[69. x 的 平方根 easy 二分法 不多 bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func mySqrt(x int) int { low, high := 0, x for low &lt;= high { mid := low + (high-low)&gt;&gt;1 if mid*mid &lt; x { if (mid+1)*(mid+1) &gt; x { // 找到最后一个小于]]></description></item><item><title>977. 有序数组的平方</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid><description>977. 有序数组的平方 easy 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1 2 3 4 输入：</description></item><item><title>209. 长度最小的子数组</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link><pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid><description>209. 长度最小的子数组 mid 给定一个含有 n 个正整数的数组和一个正整数 target 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr]，并返回其长</description></item><item><title>59. 螺旋矩阵 II</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/</link><pubDate>Sat, 26 Feb 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/</guid><description>59. 螺旋矩阵 II mid 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 1 &amp;lt;= n &amp;lt;= 20 模拟 就恩写；注意边界条</description></item><item><title>560. 和为 K 的子数组</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</link><pubDate>Thu, 24 Feb 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</guid><description>560. 和为 K 的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。 示例 1： 1 2 输入：nums = [1,1,1], k = 2 输出：2</description></item></channel></rss>