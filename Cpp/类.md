[TOC]



# 基本语法

## 基本形式

```c++
	class 类名
	{
	public:
	    //行为或属性
	protected:
	    //行为或属性
	private:
	    //行为或属性
	};
```

大括号内为类体，装成员函数、数据成员

例

```c++
	class Point
	{
	public:
	    void setPoint(int x, int y);
	    void printPoint();
	private:
	    int xPos;
	    int yPos;
	};
```

## 定义

- 类成员

  类可以没有成员，也可以定义多个成员。成员可以是数据、函数或类型别名。所有的成员都必须在类的内部声明

- 数据成员

  变量、数组、常量、对象、对象数组

  对象称为组合成员

- 成员函数

  成员函数必须在类内部声明，可以在类内部定义，也可以在类外部定义。如果在类内部定义，就默认是内联函数

  分类：

  1. 特殊函数

  ​	   构造函数（浅/深拷贝构造函数）、析构函数、常函数/只读函数、静态函数、虚函数、纯虚函数、赋值函数

  2. 一般函数

## 对类的实例化

- 创建对象

  ```c++
  	Test test1, test2(3), test3(3, 4);
  	Test tArray[10];
  	Test *tPtr = &test1;
  	Test &tRef = test1;
  ```

- 动态地为其分配内存

  ```c++
  	Test *p;
  	p = new Test;
  	delete p;
  	//对象数组
  	p = new Test[5];
  	delete[] p;
  	//堆对象调用函数
  	p->Show();
  ```

## 定义函数体

```c++
	//在类内部定义函数体
	class 类名
	{
	     返回类型   函数名(形参列表)
	     {
	              //函数体
	     }
	};
	 
	//在类外部定义函数体
	class 类名
	{
	     返回类型   函数名(形参列表);
	};
	
	返回类型 类名::函数名(形参列表)
	{ 
	         //函数体
	} 
```

## 调用类的成员

- 一般调用

```c++
	Test test1;
    test1.Sum();
```

- 引用调用

```c++
   Test test1, &r = test1;
   r.Sum();
```

- 开辟内存调用

```c++
	Test *p;
	p = new Test;
    p->Sum();
```

- 使用无名对象调用（语句结束，自动析构）

```c++
	test2.Test();
	test2=Test(1,2);
```

- 指针调用

```c++
	Test test1(3, 4), *p = &test1;
	test1.Sum();
	p->Sum();
	(*p).Sum();
    (p[0]).Sum();
```

## this指针常量

成员函数（除了静态函数）具有一个附加的隐含形参（表现为`Test *const this`），即 this指针，它由编译器隐含地定义。成员函数的函数体可以显式使用 this 指针

## 常函数

- 特点

  1. 可以使用数据成员，不能进行修改，对函数的功能有更明确的限定；

  2. 常对象只能调用常函数，不能调用普通函数；

  3. 常函数的this指针是const CStu*.

- 格式

  `void fun() const {}`

- 例

  `int Geta() const { return a; }`

# 构造函数

## 特征

1. 函数名与类名相同
2. 一般有形参表
3. 构造函数是一种特殊的成员函数，不需要人为调用，而是在对象建立的时候自动被执行

例

```c++
	class Test
	{
	public:
	    Test ();
	    Test (int x,int y);
	private:
	    int a,b;
	};
	
	Test::Test()
	{
	 
	}
	
	Test::Test(int x,int y)
	{
	    a=x;
	    b=y;
	}
	//在主函数中调用
	Test test1(3,4);
```

1. `Test ()`为无参构造函数或**默认构造函数**，写这个函数的好处是当你在创建对象的时候并不想立即对它初始化，而是在后续的工作中再进行赋初值，即：`Test test1;`

   部分IDE会自动生成一个默认构造函数

2. `Test(int x,int y)`完成了初始化工作，它有两个形参，分别给数据成员a，b进行初始化，定义对象的时候传入了 3和4，则 a和b 被初始化为 3 和 4 

3. 成员初始化表

   用来赋初值，可在构造函数的形参中赋初值

   - 在类内

     ```c++
     	Test (int x,int y):a(x),b(y) {}
     ```

   - 在类外

     ```c++
     	Test::Test(int x,int y):a(x),b(y)
     	{
     		//…
     	}
     ```

   - 在含有组合成员的类里，构造函数、拷贝构造函数都需要用成员初始化表

4. 构造函数可以重载，也可以带默认参数

   ```c++
   	Test (int x = 0,int y = 0):a(x),b(y) {}
   	Test test(3);
   ```

   一旦指定了 x = 0，就必须指定 y 的值

   所以这样是错误的：`Test (int x = 0,int y):a(x),b(y) {}`

   在类内，默认值写在()中

   在类外，默认值写在{}中，声明写，定义不写

## 分类

### 默认构造函数

无实参

`Point() {}`

### 一般构造函数

`Point(int x = 0, int y = 0) : xPos(x), yPos(y) {}`

### 拷贝构造函数

`Point(const Point &N) {}`

用一个已经生成的对象来初始化另一个同类的对象

可以用成员初始化表

- 格式

  ```c++
  	类名 (const 类名& obj)
  	{
  		//函数体
  	}
  ```

- 例

  ```c++
  	Test (const Test& t):a(t.a),b(t.b) {}
  ```

  ```C++
  	Test(const Test &t) 
  	{
  		this->a = t.a;
  		this->b = t.b;
      }
  ```

  如果不定义复制构造函数，以上对象也可以这样进行初始化，原因就是系统也会自己生成一个复制构造函数

- 在主函数内调用

  ```c++
  	Point p1(3, 4);
  	Point p2 = p1;
      Point p2(p1);
  ```

### 转换构造函数

带一个实参的构造函数，它可以实现数据量类型的隐式转换和强制转换

```c++
Point(int x)
{
	xPos = x;
	yPos = 1;
}        //在类内，能把x这个int数据转换成一个对象
			
Point p1 = 4;
Point p2(8);

```

可以用成员初始化表

### 深拷贝构造函数

- 浅拷贝

  默认拷贝构造函数可以完成对象的数据成员简单的复制,这也称为浅拷贝

  浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间

- 深拷贝

  深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝

  经深拷贝后的指针是指向两个不同地址的指针

- 例

  - 只占有栈空间的类，可以用默认的浅拷贝函数

    ```c++
    	class Test1
    	{
    	private:
    			int p;
    	public:
    			Test(int x)
    			{
    			    this->p = x;
    			}
    		 	//浅拷贝
    			Test(const Test1 &a)
    			{  
    			    this->p = a.p;
    			}
     };
    ```

  - 占有堆空间（指针）的类，使用深拷贝函数

    ```c++
    	class Test2
    	{
    	private:
    			int *p;
    	public:
    			Test2(int x)
    			{
    			    this->p = new int(x);
    			}
    			 //深拷贝
    			Test2(const Test2 &a)
    			{
    			    this->p = new int(*a.p);
    			}
    	};
    
    ```

  总而言之，浅拷贝会把指针变量的地址复制; 深拷贝会重新开辟内存空间

# 析构函数

- 作用

  析构函数在类里起了一个“清理”的作用，比如类中有需要动态开辟内存的成员，而在程序结束之后我们需要释放内存，这时只要将释放内存的语句写在析构函数中，而系统在程序运行结束之后会自动执行析构函数，进行内存的释放以及对象的销毁

  先构造的后析构

- 格式

  1. 默认的析构函数

     `~Test(){};`

  2. 占用堆空间的类的析构函数

     ```C++
     	~Test()
     	{
     		if (p != NULL)
     	    delete p;
         }
     ```

# 赋值运算符函数

- 格式

  `类名 &operator=(const 类名 &source_arg)`

- 例

  ```c++
  	class Test
  	{
  	private:
  	    int *p;
  	public:
  	    Test(int x)
  	    {
  	        this->p = new int(x);
  	    }
  	
  	    void Show() const { cout << *p << endl; }
  	
  	    Test(const Test &a)
  	    {
  	        this->p = new int(*a.p);
  	    }
  	
  	    ~Test()
  	    {
  	        if (p != NULL)
  	            delete p;
  	    }
  	
  	    Test &operator=(const Test &a)
  	    {
  	        if (&a != this) //防止自我赋值而丢失资源
  	        {
  	            if (p != NULL)
  	                delete p;            //主动释放原资源
  	            this->p = new int(*a.p); //申请资源
  	        }
  	        return *this; //返回赋值结果
  	    }
  	};
  ```

- 要点

  1. 如果对象在声明的同时马上进行初始化操作，则称之为拷贝运算

  2. 如果对象在声明之后，再进行赋值运算，称之为赋值运算

  3. 在类外定义

     `Test &Test::operator=(const Test &N)`

# 类模板

- 例

  ```c++
  	template <class T1, class T2, class T3>
  	class Student
  	{
  	public:
  	    Student(T1 name, T2 age, T3 score)
  	    {
  	        //.........
  	    }
  	    T1 m_Name;
  	    T2 m_Age;
  	    T3 m_Score;
  	};
  	//主函数中声明对象
  	Student<string,int,float>s("Tom",18,85.5);
  ```

- 类的函数模板

  如果在类外定义，类外要写上函数模板的形式，类内声明时不用

  ```c++
  	template <class T1, class T2>
  	Student<T1, T2>::Student(T1 name, T2 age) : m_name(mName), m_age(mAge) {}
  ```

## 大大大大大例子

```c++
#ifndef VECTOR_H
#define VECTOR_H
#include <bits/stdc++.h>
using namespace std;
template <typename T>
class Vector
{
public:
    Vector(T *coor = NULL, int len = 0);
    Vector(const Vector<T> &N);
    ~Vector();
    Vector &operator=(const Vector<T> &N);
    /*功能函数*/
    void Show() const;
    T GetLen() const;
    void Resize(int num);
    /*双目运算符重载*/
    template <typename TYPE>
    friend Vector<TYPE> operator+(const Vector<TYPE> &v1, const Vector<TYPE> &v2);
    template <typename TYPE>
    friend Vector<TYPE> operator-(const Vector<TYPE> &v1, const Vector<TYPE> &v2);
    template <typename TYPE>
    friend Vector<TYPE> operator*(const TYPE &a, const Vector<TYPE> &v1);
    template <typename TYPE>
    friend Vector<TYPE> operator*(const Vector<TYPE> &v1, const TYPE &a);
    Vector<T> &operator+=(const Vector<T> &v1);
    Vector<T> &operator-=(const Vector<T> &v1);
    /*单目运算符重载*/
    Vector<T> &operator++();   //前置++
    Vector<T> &operator--();   //前置--
    Vector<T> operator++(int); //后置++
    Vector<T> operator--(int); //后置--
    /*关系运算符重载*/
    bool operator==(const Vector<T> &v1);
    bool operator!=(const Vector<T> &v1);
    T &operator[](int index) const; //下标运算符
    /*IO流操作运算符重载*/
    template <typename TYPE>
    friend istream &operator>>(istream &in, Vector<TYPE> &v1);
    template <typename TYPE>
    friend ostream &operator<<(ostream &out, const Vector<TYPE> &v1);

private:
    T *m_coor;
    int m_len;
};

template <typename T>
Vector<T>::Vector(T *coor, int len)
{
    //int len = sizeof(coor) / sizeof(coor[0]); //不可行，辣鸡C++
    m_len = len;
    m_coor = new T[len];
    for (int i = 0; i < m_len; i++)
    {
        m_coor[i] = coor[i];
    }
}

template <typename T>
Vector<T>::Vector(const Vector<T> &N)
{
    /*     m_len = N.m_len;
    m_coor = new int[m_len];
    for (int i = 0; i < m_len; i++)
    {
        m_coor[i] = N.m_coor[i];
    } */

    m_len = 0;
    m_coor = NULL;
    *this = N;
}

template <typename T>
Vector<T>::~Vector()
{
    m_len = 0;
    if (m_coor != NULL)
        delete[] m_coor;
}

template <typename T>
Vector<T> &Vector<T>::operator=(const Vector<T> &N)
{
    m_len = N.m_len;
    m_coor = new int[m_len];
    for (int i = 0; i < m_len; i++)
    {
        m_coor[i] = N.m_coor[i];
    }
    return *this;
}

template <typename T>
void Vector<T>::Show() const
{
    cout << "The coordinates of this " << m_len << "-dimensional vector are: (";
    for (int i = 0; i < m_len - 1; i++)
    {
        cout << m_coor[i] << ", ";
    }
    cout << m_coor[m_len - 1] << ")" << endl;
}

template <typename T>
T Vector<T>::GetLen() const
{
    return m_len;
}

template <typename T>
void Vector<T>::Resize(int num)
{
    if (num < 0)
    {
        T *temp = m_coor;
        //delete[] m_coor; //不可delete，下同
        m_coor = new T[m_len + num];
        for (int i = 0; i < m_len + num; i++)
        {
            m_coor[i] = temp[i];
        }
        //delete[] temp; //此处delete，待证，下同
        m_len += num;
    }
    else if (num > 0)
    {
        T *temp = m_coor;
        m_coor = new T[m_len + num];
        for (int i = 0; i < m_len + num; i++)
        {
            m_coor[i] = (i < m_len) ? temp[i] : 0;
        }
        //delete[] temp;
        m_len += num;
    }
    else
        return;
}

template <typename T>
Vector<T> operator+(const Vector<T> &v1, const Vector<T> &v2)
{
    Vector<T> result(v1);
    if (v1.m_len != v2.m_len)
        return result;

    for (int i = 0; i < result.m_len; i++)
    {
        result[i] += v2[i];
    }
    return result;
}

template <typename T>
Vector<T> operator-(const Vector<T> &v1, const Vector<T> &v2)
{
    Vector<T> result(v1);
    if (v1.m_len != v2.m_len)
        return result;

    for (int i = 0; i < result.m_len; i++)
    {
        result[i] -= v2[i];
    }
    return result;
}

template <typename T>
Vector<T> operator*(const T &a, const Vector<T> &v1)
{
    Vector<T> result(v1);

    for (int i = 0; i < v1.m_len; i++)
    {
        result.m_coor[i] = a * v1.m_coor[i];
    }
    return result;
}

template <typename T>
Vector<T> operator*(const Vector<T> &v1, const T &a)
{
    return a * v1;
}

template <typename T>
Vector<T> &Vector<T>::operator+=(const Vector<T> &v1)
{
    return *this = *this + v1;
}

template <typename T>
Vector<T> &Vector<T>::operator-=(const Vector<T> &v1)
{
    return *this = *this - v1;
}

template <typename T>
Vector<T> &Vector<T>::operator++()
{
    for (int i = 0; i < m_len; i++)
    {
        m_coor[i]++;
    }
    return *this;
}

template <typename T>
Vector<T> &Vector<T>::operator--()
{
    for (int i = 0; i < m_len; i++)
    {
        m_coor[i]--;
    }
    return *this;
}

template <typename T>
Vector<T> Vector<T>::operator++(int)
{
    Vector<T> result(*this); //拷贝构造
    ++(*this);               //利用前置运算符重载函数
    return *this;
}

template <typename T>
Vector<T> Vector<T>::operator--(int)
{
    Vector<T> result(*this); //拷贝构造
    --(*this);               //利用前置运算符重载函数
    return *this;
}

template <typename T>
bool Vector<T>::operator==(const Vector<T> &v1)
{
    if (m_len != v1.m_len)
        return false;
    else
    {
        int count = 0;
        for (int i = 0; i < m_len; i++)
        {
            if (m_coor[i] == v1.m_coor[i])
                count++;
        }
        if (count == m_len)
            return true;
        else
            return false;
    }
}

template <typename T>
bool Vector<T>::operator!=(const Vector<T> &v1)
{
    return !(*this == v1);
}

template <typename T>
T &Vector<T>::operator[](int index) const
{
    return m_coor[index];
}

template <typename T>
istream &operator>>(istream &in, Vector<T> &v1)
{
    cout << "Please input the dimension of the vector being create: ";
    cin >> v1.m_len;
    cout << endl
         << "input the coordinates: ";
    for (int i = 0; i < v1.m_len; i++)
    {
        cin >> v1[i];
    }
    return in;
}

template <typename T>
ostream &operator<<(ostream &out, const Vector<T> &v1)
{
    cout << "(";
    for (int i = 0; i < v1.m_len - 1; i++)
    {
        cout << v1[i] << ", ";
    }
    cout << v1[v1.m_len - 1] << ")";
    return out;
}

#endif
```

# 静态成员

## 静态数据成员

- 定义

  在一个类中，如果将一个数据成员申明为static，这种成员就被称为静态数据成员。与一般数据成员不同的是，无论建立多少个类的对象，都只有一个静态数据成员拷贝

- 创建、定义及初始化

  - 格式

    - 创建

      `static 数据类型 变量名`

    - 定义及初始化

      `(Type className::VarName = value)`

      `数据类型 类名::静态数据成员名 = value;`

      `数据类型 类名::静态数据成员名(value);`

- 例

  ```c++
  	class Test
  	{
  	private:
  		int m_num;
  		static int m_count;  //创建静态数据成员
  	public:
  		Test(int num = 0)
  		{
  			m_num = num;
  			m_count++;
  		}
  	};
  	int Test::m_count = 0;  //定义及初始化静态数据成员，类的静态成员变量需要在类外分配内存空间
  	int Test::m_count(0);  //第二种方法
  ```

- 访问

  - 格式

    1. 对象名.静态数据成员名
    2. 类名::静态数据成员名

  - 例

    ```c++
    	Test t1(1);
    	int a;
    	a = Test::m_count; //公有的静态成员才能这样被访问
    	a = t1.m_count;
    ```

- 说明

  1. 静态数据成员的生命期不依赖于任何对象，为程序的生命周期

  2. 静态数据成员需要在类外单独分配空间，

  3. 静态数据成员在程序内部位于全局数据区

  4. 静态数据成员属于类，而不像普通的数据成员那样属于某个对象，因此我们可以用“类名::”这样的形式访问静态数据成员

  5. 静态数据成员在该类的任何对象创建之前就已经存在。因此，公有的静态数据成员可以在对象定义之前就被访问

## 静态成员函数

- 格式

  `static 返回类型 静态成员函数名（形参列表）;`

  例

  ```c++
  	static int getCount()
  	{
  		return m_count;
  	}
  ```

- 调用

  - 格式
    1. 对象名.静态成员函数名
    2. 类名::静态成员函数名
  - 例

  ```c++
  	Test::getCount;
  	t1.getCount;
  ```

- 说明

  1. 静态成员函数属于整个类所有，没有this指针

  2. 静态成员函数只能直接访问静态成员变量和静态成员函数

  3. 静态成员函数可以定义成内嵌的，也可以在内外定义，在类外定义时，前面不需要加static

  4. 使用静态成员函数的一个原因就是可以用它在建立任何对象之前处理静态数据成员

  5. 译系统将静态成员函数限定为内部连接，也就是说，与现行的文件相连接的文件中的同名函数不会与该函数发生冲突，维护了该函数的安全性，这是使用静态成员函数的另外一个原因

# 友元

- 概念

  C++提供了友元机制，允许一个类将其非公有成员的访问权限授予指定的函数或类。友元的声明只能在类定义的内部，因此，访问类非公有成员除了自身成员，还有友元

  友元的作用在于提高程式的运行效率，但是，他破坏了类的封装性和隐藏性，使得非成员函数能够访问类的私有成员

## 友元函数

- 格式

  在类中使用friend关键字来添加友元函数

  `friend 类型 函数名(形式参数);`

  例

  ```c++
  	//类内
  	friend int getSumNum(Test t1,Test t2);
  	//类外
  	int getSumNum(Test t1,Test t2)
  	{
  		int result=t1.m_num+t2.m_num;
  		return result;
  	}
  ```

- 说明

  1. 友元函数是能够访问类中私有成员的非成员函数

  2. 友元函数在类内声明，类外定义，定义和使用时不需加作用域和类名，与普通函数无异。

  3. 一个函数可以是多个类的友元函数，只需要在各个类中分别声明

## 友元类

- 概念

  声明一个类是另一个类的友元

- 格式

  在类内声明

  `friend class 类名;`

  例

  ```c++
  	class Test
  	{
  		friend class X;   //X是Test的友元类，X可以访问Test的任意成员
  	private:
  		int m_num;
  	public:
  		Test(int num = 0)
  		{
  		    m_num = num;
  		}
  	};
  ```

- 说明

  1. 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明

  2. 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元

# 强制类型转换

- 例

  ```c++
  	class Student
  	{
  	public:
  		string name;
  		int age;
  	};
  	
  	//在成员函数中
  	operator int() const
  	{
  		return age;
  	}
  		
  	operator string() const
  	{
  		return name;
      }
  		
  	//在主函数中使用
  	int age1 = (int)stu1;
  	string name1 = (string)stu2;
  
  ```

  