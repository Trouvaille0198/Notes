# 算法设计与分析

## 认识

### 基本概念

**算法**

- 有穷规则的集合；计算序列
- 特点
    - 输入（零个或多个）
    - 输出（至少一个）
    - 确定性
    - 有限性（执行次数、执行时间）
    - 可行性

**程序**：数据结构 + 算法

### P 问题与 NP 问题

**P 问题**：Polynomial Problem，多项式时间复杂度内能解的问题

**NP 问题**：Non-deterministic Polynomial Problem，**非确定性**多项式时间能解的问题，可以在多项式时间复杂度内对猜测进行验证

**NPC 问题**：NP-Complete，多项式时间内可转化为任意 NP 问题，可视为代表性 NP 问题

P 问题是确定计算模式下的易解问题，NP 问题是非确定性计算模式下的易验证问题，$P \subseteq NP$

### 算法渐进复杂性

理解：取 T(n) 高阶为渐进表达式

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132329296.png" alt="image-20210909132329296" style="zoom:50%;" />

### 增长的阶

用增长的阶来衡量算法复杂度

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132341701.png" alt="image-20210909132341701" style="zoom:50%;" />

g(n) 比 f(n) 结构要简单，可以近似代表 f(n)

#### 符号意义

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132441135.png" alt="image-20210909132441135" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132514428.png" alt="image-20210909132514428" style="zoom:50%;" />

#### 复杂性阶的理解举例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909134231473.png" alt="image-20210909134231473" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909134300379.png" alt="image-20210909134300379" style="zoom:50%;" />

#### 理解

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141813886.png" alt="image-20210909141813886" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141415681.png" alt="image-20210909141415681" style="zoom: 33%;" />

#### 各记号在等式和不等式中的意义

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141735965.png" alt="image-20210909141735965" style="zoom: 33%;" />

#### 性质

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141843286.png" alt="image-20210909141843286" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141856607.png" alt="image-20210909141856607" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141928128.png" alt="image-20210909141928128" style="zoom:33%;" />

## 递归

### 定义

•	递归算法：一个直接或间接地调用自身的算法
•	递归函数：使用函数自身给出定义的函数
•	递归方程：对于递归算法，一般可把时间代价表示为一个递归方程
•	解递归方程最常用的方法是进行递归扩展

### 例

初始条件与递归方程是递归函数的两个要素

#### 例 1

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130246852.png" alt="image-20210914130246852" style="zoom: 33%;" />

#### Ackerman

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130327267.png" alt="image-20210914130327267" style="zoom: 33%;" />

#### 排列问题 Perm()

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130645860.png" alt="image-20210914130645860" style="zoom:33%;" />

#### 整数划分问题

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130826534.png" alt="image-20210914130826534" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130854067.png" alt="image-20210914130854067" style="zoom:33%;" />

#### hanoi 汉诺塔问题

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130932836.png" alt="image-20210914130932836" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130947107.png" alt="image-20210914130947107" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130956383.png" alt="image-20210914130956383" style="zoom:33%;" />

### 原理

也就是递归调用工作栈

递归程序逐层调用需要分配存储空间，一旦某一层被启用，就要为之开辟新的空间。而当一层执行完毕，释放相应空间掉，退到上一层。

- 递归程序逐层调用需要记录调用/返回地址（函数指针）及相关输入，返回参数。
- 递归程序逐层调用及返回时需要建立控制转移机制。

### 递归程序代价

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914131136872.png" alt="image-20210914131136872" style="zoom:33%;" />

## 分治

### 定义

- **基本思想**
    - 将问题分解成若干子问题，然后求解子问题。
    - 子问题较原问题更容易些，由此得出原问题的解，就是所谓的“**分而治之**”的意思。
    - 分治策略可以递归进行，即子问题仍然可以用分治策略来处理，但最后的问题要非常基本而简单。

- **步骤**
    - 把问题分解为 k 个**性质相同**、但规模较小的子问题，并求解这些子问题。
    - 逐步合并子问题的解，直到获得原问题的解
- **算法构架**
    - <img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914132047694.png" alt="image-20210914132047694" style="zoom:50%;" />
    - <img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914132325235.png" alt="image-20210914132325235" style="zoom: 50%;" />

### 代价分析

（复杂度的推导必考）

==递归式==

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914140519132.png" alt="image-20210914140519132" style="zoom:50%;" />

- 参数
    - m：子问题总数量
    - k：需要求解的子问题数量（一般小于等于 m）
    - n：单个子问题的规模
    - f(n)：merge 的时间复杂度

推导式

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133027722.png" alt="image-20210914133027722" style="zoom: 50%;" />

==又可写成==
$$
T(N)=
\begin{cases}
\ O(N^{log_ba}),\ a>b^k \\
\ O(N^klogN),\ a=b^k \\
\ O(N^k),\ a<b^k \\
\end{cases}\\ \\
之于 \ T(N)=aT(N/b)+N^k
$$

==推导==

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918124716010.png" alt="image-20210918124716010" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918124727349.png" alt="image-20210918124727349" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918132243595.png" alt="image-20210918132243595" style="zoom:50%;" />

### 二分搜索技术

给定已按升序**排好序**的 n 个元素 a[0:n-1]，现要在这 n 个元素中找出一特定元素 x

#### 基本思想

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133242984.png" alt="image-20210914133242984" style="zoom:33%;" />

#### 算法实现

![image-20210914133312170](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133312170.png)

#### 复杂性

做时间复杂度的推导必考
$$
T(n)=T(n/2)+1
$$


<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133555521.png" alt="image-20210914133555521" style="zoom:33%;" />

### 大整数的乘法

设计一个有效的算法，可以进行两个 n 位大整数的乘法运算

#### 小学生算法

一位位乘

复杂度为 O(n^2^)

#### 一种毫无进步的分治

![image-20210914135309496](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914135309496.png)

#### 另一种分治

![image-20210914142652819](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142652819.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142743233.png" alt="image-20210914142743233" style="zoom:40%;" />

### strassen 矩阵乘法

暂且考虑方阵相乘

#### 传统方法

![image-20210918131627947](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131627947.png)



#### 垃圾的分治方法

![image-20210918131736390](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131736390.png)

#### 好分治

![image-20210918131812017](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131812017.png)

![image-20210918131824600](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131824600.png)

### 棋盘覆盖

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918134456210.png" alt="image-20210918134456210" style="zoom: 33%;" />



#### 基本思想

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918135558538.png" alt="image-20210918135558538" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918135708174.png" alt="image-20210918135708174" style="zoom:33%;" />

#### 算法实现

```python
def chess_board(tr:int, tc:int, dr:int, dc:int, size:int):
    """
    棋盘覆盖问题
    param tr: 棋盘起始行坐标
    param tc: 棋盘起始列坐标
    param dr: 特殊方格的行号
    param dc: 特殊方格的列号
    param size:
    """
    if size==1:
        return
    t=
    s=size/2 # 分割棋盘
    if dr<tr+s and dc<tc+s
```

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918135756445.png" alt="image-20210918135756445" style="zoom:40%;" />

#### 复杂性

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918140021496.png" alt="image-20210918140021496" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918140032888.png" alt="image-20210918140032888" style="zoom:33%;" />

### 合并排序

就是归并排序

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918141728529.png" alt="image-20210918141728529" style="zoom: 33%;" />

#### 基本思想

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918141813181.png" alt="image-20210918141813181" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918141823072.png" alt="image-20210918141823072" style="zoom:33%;" />

#### 递归算法

##### 实现

![image-20210918142034783](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142034783.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142939870.png" alt="image-20210918142939870" style="zoom: 33%;" />

##### 复杂性

![](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png)

#### 非递归的分治算法

非递归：自底向上

递归：自顶向下

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143041362.png" alt="image-20210918143041362" style="zoom: 33%;" />

##### 实现

![image-20210918142549068](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142549068.png)

![image-20210918143559704](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143559704.png)

##### 复杂性

（长为 n/2）

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143708276.png" alt="image-20210918143708276" style="zoom:33%;" />

#### 复杂性

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143749827.png" alt="image-20210918143749827" style="zoom:33%;" />

### 快速排序

设基准 -> 划分子列 -> 递归

#### 算法实现

```mermaid
graph LR
	start[开始]-->con1{"i < j?"}
	con1 -- NO --> recurve["结束一次快排"]
    con1 -- YES --> con2{"Elem[i] > Elem[j]?"}
    con2 -- YES --> exchange["i,j 值互换"]
	exchange ---> pivot{"基准位置?"}
	con2 -- NO -->pivot
	pivot -- "前" --> j["j--"]
	pivot -- "后" --> i["i++"]
	i --> finish["下次循环"]
	j --> finish
	
	finish --> con1
```

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923133023063.png" alt="image-20210923133023063" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923133043429.png" alt="image-20210923133043429" style="zoom:35%;" />

#### 复杂度

![image-20210923135538263](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923135538263.png)

### 线性时间选择

![image-20210923141552761](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141552761.png)

一个结论：一般的选择问题可以在 O(n) 时间内得到解决 

#### 模仿快排的、很拉的分治算法

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141859889.png" alt="image-20210923141859889" style="zoom: 33%;" />

使用到类似于快排的算法

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923142034552.png" alt="image-20210923142034552" style="zoom: 50%;" />

#### 改进的分治

思想：选择一个有用的基准值，让每一次递归都有效，能大概剔除 n/4 的规模

![image-20210923143236828](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143236828.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143302958.png" alt="image-20210923143302958" style="zoom:33%;" />

![image-20210923143328281](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143328281.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143617933.png" alt="image-20210923143617933" style="zoom: 40%;" />

### 最接近点对问题

![image-20210927132532247](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132532247.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132702653.png" alt="image-20210927132702653" style="zoom:40%;" />

#### 一维

![image-20210927132910859](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132910859.png)

#### 二维

分治

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927134200280.png" alt="image-20210927134200280" style="zoom:50%;" />

推广到二维

![image-20210927141019693](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141019693.png)

![image-20210927140304921](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927140304921.png)

![image-20210927141206939](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141206939.png)

![image-20210927141241174](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141241174.png)

#### 算法

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141353325.png" alt="image-20210927141353325" style="zoom:50%;" />

第四部中的 X 与 Y 只要排一次序就行

#### 复杂度

![image-20210927142019431](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142019431.png)

### 循环赛程表问题

![image-20210927142731078](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142731078.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143104868.png" alt="image-20210927143104868" style="zoom: 33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143125161.png" alt="image-20210927143125161" style="zoom: 33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143143263.png" alt="image-20210927143143263" style="zoom:33%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143154432.png" alt="image-20210927143154432" style="zoom:33%;" />

## 动态规划

### 定义

最优子结构性质

重叠子问题性质

**基本思想**

- 将问题分解成若干子问题，然后求解子问题。
- 子问题不是互相独立的
