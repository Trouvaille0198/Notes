## 捋一捋

考试：3.8.6.7章

3.8 重点

### 第三章

存储器

- 主存的技术指标：存储容量...
- 算存储容量
  - 256 字节，4 字节一字；若按字寻址，地址为六位
- SRAM、DRAM：给规格，找地址、数据引脚个数

DRAM 的刷新：定义、原因、分类、操作
- 分散、集中式刷新的差异

存储器容量扩展
- 看习题
- 字扩展、位扩展、字位扩展弄清楚
- ROM 用 OE，RAM 有 WE
- CS 端的译码方案；Y 引脚会空
- 芯片地址位数（芯片中所含的存储个数 4 即 16 个）与 CPU 地址位数（决定 CPU 能访问的最大存储空间 A0-A7即2^8^）不一样

并行存储器
- 多模块交叉存储器
  - 连续存取 m 字所耗费的时间，例 5，习题 8
  - 定量分析

Cache
- 局部性原理
- 命中率、效率、平均访问时间等等计算公式，例 6
- 映射，三种弄清楚
  - 直接映射的映射关系，公式
  - 直接映射、组相联映射的地址格式，总位数、三个字段（tag 字段只存在于主存地址）
  - 给一个主存地址，求其在 Cache 中的地址
  - LFU 和 LRU 的区别
  - 写操作策略，三种原理、优缺点

虚存
- 三种管理机制、各自的优缺点
  - 页式管理访问数据、页面的过程
    - 内页表、外页表
  - 段式管理
    - 段表、页表
    - 与页式管理的区别、优缺点
  - 段页式管理
- 虚存的替换
  - FIFO，LRU

### 第八章

信息交换方式四类

程序查询方式大概过程

程序中断方式
- 程序接口的四个触发器
- 单级中断、多级中断概念（一维、二维）
- 中断请求寄存器

DMA 方式

- 特点
- 传送方式
- 原理
- 控制器类型
  - 选择型、多路型
- 传输完了才中断，用来报告

### 第六章
总线概念、特性、带宽

适配器的功能

总线接口
- 信息传送方式
  - 串行：拆卸和装配的概念
- p193 例 2
- 
仲裁
- 分类：集中（三种原理、优缺点）和分布（知道原理即可）

总线的定时
- 同步、异步

### 第七章
磁盘
- 所有指标概念
- 数据传送时间！

显示设备

- 各种指标

# 一、概论

## 1.1 分类

- 数字计算机
  - 专用计算机
  - 通用计算机
- 模拟计算机

## 1.2 发展简史

### 1.2.1 五代变化

1. 电子管计算机（1946—1957年）：数据处理
2. 晶体管计算机（1958—1964年）：工业控制
3. 中小规模集成电路计算机（1965—1971年）：小型计算机
4. 大规模和超大规模集成电路计算机（1972—1990年）：微型计算机
5. 巨大规模集成电路计算机（1991年开始）：单片机

### 1.2.2 性能指标

1. 吞吐量

   表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S）。

2. 响应时间

   表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（10-6S）、纳秒（10-9S）。

3. 利用率

   给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。

4. 处理机字长

   指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。字长越长，表示计算的精度越高

5. 总线宽度

   CPU中运算器与存储器之间进行互连的内部总线二进制位数。

6. 存储器容量

   存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。

7. 存储器带宽

   存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。

8. 主频/时钟周期

   CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz（兆赫兹）、GHz（吉赫兹）。例如Pentium系列机为60MHz～266MHz，而Pentium 4升至3.6GHz。

9. CPU时钟周期（T）

   主频的倒数，即T=1/f，度量单位是微秒、纳秒。

10. CPU执行时间

    CPU执行一段程序所占用的CPU时间。CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周长

11. CPI

    每条指令周期数，即执行一条指令所需的平均时钟周期数。 CPI ＝ 执行程序所需的CPU时钟周期数/该程序包含的指令条数

12. MIPS

    每秒百万条指令数。MIPS = 指令条数/程序执行时间Te × 10的6次方 = 时钟频率/CPI × 10的6次方。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。

13. MFLOPS

    每秒百万次浮点操作次数。MFLOPS = 程序中的浮点操作数/程序执行时间Te × 10的6次方。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。

14. TFLOPS

    每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。

## 1.3 硬件

- 控制器：人的大脑的操作控制功能
- 运算器：人的大脑的计算功能
- 存储器：人的大脑记忆功能
- 输入设备：交互接口，笔
- 输出设备：交互接口，纸

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201201091549465.png" alt="image-20201201091549465" style="zoom:67%;" />

### 1.3.1 运算器

- 算术运算和逻辑运算

- 在计算机中参与运算的数是二进制的

- 运算器的长度一般是8、16、32或64位

### 1.3.2 存储器

- 存储数据和程序（指令）

- 容量（存储单元、存储单元地址、容量单位）

- 分类内存（ROM、RAM）、外存

- 存储器单位：
  ​	$1KB ＝ 2^{10}B \\ 1MB ＝ 2^{20}B \\ 1GB ＝ 2^{30}B \\ 1TB ＝ 2^{40}B $

### 1.3.3 控制器

- 指令和程序：指令的形式（操作和地址码、存储程序的概念、指令中程序和数据的存放、指令系统）

- 指令和数据存储
- 控制器的基本任务：按照一定的顺序一条接着一条取指令、指令译码、执行指令。取指周期和执行周期

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201201092140398.png" alt="image-20201201092140398" style="zoom:67%;" />

### 1.3.4 适配器与I/O设备

- 输入设备：把人们所熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式

- 输出设备：把计算机处理的结果变换为人或其他机器设备所能接收和识别的信息形式

- 适配器：它使得被连接的外围设备通过系统总线与主机进行联系，以便使主机和外围设备并行协调地工作

- 总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路

![image-20210219153820024](http://image.trouvaille0198.top/image-20210219153820024.png)

## 1.4 软件

### 1.4.1 分类

- 系统软件
  - 各种服务性程序，如诊断程序、排错程序、练习程序等
  - 语言程序，如汇编程序、编译程序、解释程序等
  - 操作系统
  - 数据库管理系统
- 应用软件

### 1.4.2 发展演变

- 编程语言的发展
  - 手编程序：机器语言程序，手工编译二进制码
  - 汇编程序：符号语言程序，汇编程序汇编
  - 高级程序：算法语言/高级语言，机器编译程序/解释程序

- 系统软件的发展
  - 手编程序：机器语言程序，手工编译二进制码
  - 汇编程序：符号语言程序，汇编程序汇编
  - 高级程序：算法语言/高级语言，机器编译程序/解释程序

## 1.5 多级计算机系统

- 微程序设计级，这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。

- 一般机器级，也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。

- 操作系统级，它由操作系统程序实现。这些操作系统由机器指令和广义指令组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。

- 汇编语言级，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。

- 高级语言级，它是面向用户的，为方便用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行

  ![image-20201201102315894](https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201201102315894.png)

# 二、运算方法和运算器

![QQ图片20210224195322](http://image.trouvaille0198.top/QQ%E5%9B%BE%E7%89%8720210224195322.jpg)

![image-20210322160454764](http://image.trouvaille0198.top/image-20210322160454764.png)

## 2.1 定点加法、减法运算

### 2.1.1 补码加法

$$
[x+y]_补=[x]_补+[y]_补
$$

**符号位运算丢进位**

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208081840627.png" alt="image-20201208081840627" style="zoom: 50%;" />

### 2.1.2 补码减法

减法变成加法来做

-y 的补码 = y的补码所有位取反 +1
$$
[x]_补 - [y]_补 = [x]_补 + [-y]_补 \\ [-y]_补 = -[y]补 + 2^{-n} （弱智方法，直接求-y的补码即可）
$$

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208081922975.png" alt="image-20201208081922975" style="zoom:60%;" />

### 2.1.3 溢出

#### 1）概念

可能产生溢出的情况 

- 两正数加，变负数，正溢（大于机器所能表示的最大数）

- 两负数加，变正数，负溢（小于机器所能表示的最小数） 
   <img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208082100759.png" alt="image-20201208082100759" style="zoom:67%;" />
   <img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208082115380.png" alt="image-20201208082115380" style="zoom:45%;" />

<img src="http://image.trouvaille0198.top/image-20210311163220227.png" alt="image-20210311163220227" style="zoom:67%;" />

#### 2）检测方法

1. 双符号位法（变形补码） 

   00为正，11为负，有下表

| $S_{f1}$ | $S_{f2}$ | 判断 |
| -------- | -------- | ---- |
| 0        | 0        | 正数 |
| 0        | 1        | 正溢 |
| 1        | 0        | 负溢 |
| 1        | 1        | 负数 |

​	$S_{f1},S_{f2}$为结果的双符号，关系为异或

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208084831460.png" alt="image-20201208084831460" style="zoom:50%;" />

2. 单符号位法

| $C_f$ | $C_0$ | 判断 |
| ----- | ----- | ---- |
| 0     | 0     | 正数 |
| 0     | 1     | 正溢 |
| 1     | 0     | 负溢 |
| 1     | 1     | 负数 |

​	其中$C_f$为符号位产生的进位，$C_0$为最高有效位产生的进位

## 2.2 定点乘法、除法运算

### 2.2.1 原码并行乘法

1. 一般都用原码算

2. 用绝对值算，且计算时不带符号位

3. 原码阵列，结果是原码；补码阵列，结果变为补码

#### 1）不带符号位的阵列乘法器

<img src="http://image.trouvaille0198.top/image-20210311183721399.png" alt="image-20210311183721399" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210311183651284.png" alt="image-20210311183651284" style="zoom: 50%;" />

#### 2）带符号的阵列乘法器

<img src="http://image.trouvaille0198.top/image-20210311183820062.png" alt="image-20210311183820062" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210311183840700.png" alt="image-20210311183840700" style="zoom:50%;" />

### 2.2.2 定点除法

一般都用补码算

- 人工除法时，人可以比较被除数（余数）和除数的大小来确定商1（够减）或商0（不够减）

- 机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下运算。这种方法叫恢复余数法，控制比较复杂。

- 不恢复余数法（**加减交替法**）
    - 余数为正，商1，下次除数右移做减法；
    - 余数为负，商0，下次除数右移做加法。
    - 控制简单，有规律

#### 1）手工方案

<img src="http://image.trouvaille0198.top/image-20210311183959476.png" alt="image-20210311183959476" style="zoom:50%;" />

#### 2）不恢复余数法

<img src="http://image.trouvaille0198.top/image-20210311184317034.png" alt="image-20210311184317034" style="zoom: 50%;" />

<img src="http://image.trouvaille0198.top/image-20210322160758503.png" alt="image-20210322160758503" style="zoom:150%;" />

## 2.3 浮点加法，减法运算

### 2.3.1 运算步骤 

1. 0 操作数检查；
2. 比较阶码并完成对阶（小阶向大阶对齐）；
3. 尾数加减运算；
4. 结果规格化；（尾数右移一位，阶码加一）
5. 舍入处理   

### 2.3.2 要点

1. 用补码表示阶码和尾数

2. 加减后溢出不是真正的溢出，规格化后才是真正的溢出

### 2.3.3 例

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201215091355202.png" alt="image-20201215091355202" style="zoom: 67%;" />

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201215091411948.png" alt="image-20201215091411948" style="zoom:50%;" />

### 2.3.3 舍入处理（对阶和向右规格化时）

- 就近舍入（0舍1入）：类似”四舍五入”，丢弃的最高位为1，进1
- 朝0舍入：截尾
- 朝$+\infty$舍入：正数多余位不全为”0”，进1；负数，截尾
- 朝$-\infty$舍入：负数多余位不全为”0”，进1；正数，截尾

### 2.3.4 溢出判断和处理

- 阶码上溢，一般将其认为是$+\infty$和$-\infty$ 。
- 阶码下溢，则数值为0

## 2.4 浮点乘法，除法运算
![image-20210312155130405](http://image.trouvaille0198.top/image-20210312155130405.png)
### 2.4.1 运算步骤

1. 操作数检查
2. 阶码加减操作
3. 尾数乘除操作
4. 结果规格化和舍入处理

## 2.5 IEEE754 标准

以32位为例

<img src="http://image.trouvaille0198.top/image-20210311104125763.png" alt="image-20210311104125763" style="zoom: 80%;" />
$$
x=(-1)^S\times(1.M)\times2^{E-127}
$$

- 基数 R=2，基数固定，采用隐含方式来表示它。

- S：数的符号位，1位，在最高位，“0”表示正数，“1”表示负数。

- M：尾数， 23位，在低位部分，采用纯小数表示。

- E：是阶码，8位，采用移码表示。移码比较大小方便。

- 尾数域最左位(最高有效位)总是1， 故这一位经常不予存储，而认为隐藏在小数点的左边。

- 采用这种方式时，将浮点数的指数真值 e 变成阶码 E 时，应将指数 e 加上一个固定的偏移值127(01111111)，即 ==E=e+127==。

<img src="http://image.trouvaille0198.top/image-20210309083106189.png" alt="image-20210309083106189" style="zoom: 45%;" />



<img src="http://image.trouvaille0198.top/image-20210311104414727.png" alt="image-20210311104414727" style="zoom: 40%;" />

## 2.6 机器码

<img src="http://image.trouvaille0198.top/image-20210311145151428.png" alt="image-20210311145151428" style="zoom:67%;" />

## 2.7 总线

机器内部各部份数据传送频繁,可以把寄存器间的数据传送通路加以归并,组成总线结构。

### 2.7.1 总线分类

- 所处位置
    - 内部总线（CPU内）
    - 外部总线（系统总线）
- 逻辑结构
    - 单向传送总线
    - 双向传送总线

### 2.7.2 定点运算器的组成

- 单总线结构的运算器

    - 在同一时间只能有一个操作数在总线上

    - 操作速度慢
    - 控制电路简单

- 双总线结构的运算器

    - 不能直接把输出加到总线

- 三总线结构的运算器

<img src="http://image.trouvaille0198.top/image-20210311190145600.png" alt="image-20210311190145600" style="zoom: 50%;" />

## 2.8 流水线

### 2.8.1 原理

<img src="http://image.trouvaille0198.top/image-20210312230044043.png" alt="image-20210312230044043" style="zoom: 67%;" />

<img src="http://image.trouvaille0198.top/image-20210312230030588.png" alt="image-20210312230030588" style="zoom:80%;" />

<img src="http://image.trouvaille0198.top/image-20210312230105914.png" alt="image-20210312230105914" style="zoom:80%;" />

# 三、存储器

## 3.1 存储器概述

### 3.1.1 存储器的分类

存储位元 (二进制代码位) -> 存储单元 -> 存储器

（了解）

- 按存储介质分类
    - 磁表面
    - 半导体存储器

- 按存取方式分类
    - 随机 (访问数据的时间与数据在存储器中的位置无关)
    - 顺序存取（磁带）

- 按读写功能分类
    - RAM：随机存储器，双极型/MOS
    - ROM：只读存储器，MROM/PROM/EPROM/EEPROM

- 按信息的可保存性分类
    - 永久性
    - 非永久性

- 按存储器系统中的作用分类
    - 主/辅/缓/控

### 3.1.2 存储器的分级

<img src="http://image.trouvaille0198.top/image-20210603124736855.png" alt="image-20210603124736855" style="zoom:50%;" />

cache -> 主存 -> 辅存

速度变慢，容量变大

- **高速缓冲存储器**

    简称 cache，它是计算机系统中的一个高速小容量半导体存储器。

- **主存储器**

    简称主存，是计算机系统的主要存储器，用来存放计算机运行期间的大量程序和数据。能和 cache 交换数据和指令

- **外存储器**

    简称外存，它是大容量辅助存储器。

### 3.1.3 主存储器的技术指标

（重要）

- **字存储单元**：存放一个**机器字**的存储单元，相应的单元地址叫字地址。

    一个字存储单元通常由多个存储单元组成

    字地址指这个字首个字节的地址

    字与字节没有明确关系

- 字节存储单元：存放一个字节的单元，相应的地址称为字节地址。

    一个字节存储单元通常由一个存储单元组成（如果存储单元占 8 位的话）

- **存储容量**：指一个存储器中可以容纳的存储单元总数。存储容量越大，能存储的信息就越多。

- **存取时间**：又称存储器访问时间：指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。通常取写操作时间等于读操作时间，故称为存储器存取时间。

    速度性指标

- **存储周期**：指连续启动两次读操作所需间隔的最小时间。通常，存储周期略大于存取时间，其时间单位为 ns。

    速度性指标

- **存储器带宽**：单位时间里存储器所存取的信息量，通常以位/秒或字节/秒做度量单位。

    速度性指标

- 按字节寻址/编址/访问：一字节（Byte）一地址

- 按字寻址/编址/访问：一（机器）字一地址

    - 例：
        - 1M × 8 位：$2^{20}$ 个存储单元（及其存储容量），每个存储单元占 8 位，存储单元地址共 20 位，相当于 1MB

## 3.2 SRAM 存储器

静态读写存储器，存储速度快，容量较小

### 3.2.1 基本的静态存储元阵列

- 存储位元
    - 如图存储位元总数为 $64\times 4=256$
- 三组信号线
    - 地址线
        - 如图六条地址线指定了存储器容量是 $2^6=64$ 个存储单元
    - 数据线
        - 如图四条数据线指定了存储器的字长为 4 位
    - 控制线
        - 高电平读，低电平写

<img src="http://image.trouvaille0198.top/12344.png" alt="12344" style="zoom:67%;" />

### 3.2.2 基本的 SRAM 逻辑结构

SRAM 芯大多采用双译码方式，以便组织更大的存储容量。采用了二级译码：将地址分成 x 向、y 向两部分

图示

- 15 位地址，8 位存储单元，即 32KB
- 8 位行地址，7 位列地址展开阵列
    - 采用双译码的方式（减少选择线的数目）
    - A0~A7 为行地址译码线
    - A8~A14 为列地址译码线
- 存储阵列的厚度即代表位数（8 位）
    - 通常把各个字的同一个字的同一位集成在一个芯片（32K×1）中
    - 32K 位排成 256×128 的矩阵
    - 8 个片子就可以构成 32KB

<img src="http://image.trouvaille0198.top/497582.png" alt="497582" style="zoom:80%;" />

- 读与写的互锁逻辑

 控制信号中 CS 是片选信号，CS 有效时（低电平），门 G1、G2 均被打开。OE 为读出使能信号，OE有效时（低电平），门 G2 开启，当写命令WE = 1时（高电平），门 G1 关闭，存储器进行读操作。写操作时，WE = 0，门 G1 开启，门 G2 关闭。注意，门 G1 和 G2 是互锁的，一个开启时另一个必定关闭，这样保证了读时不写，写时不读。

## 3.3 DRAM 存储器

动态读写存储器，存储速度慢，容量较大

### 3.3.1 DRAM芯片的逻辑结构

图示：1M × 4 位 DRAM

- 分时传送地址码
    - 若地址总线宽度为 10 位，先传送地址码 A0～A9，由行选通信号 RAS 打入到**行地址锁存器**
    - 然后传送地址码 A10～A19，由列选通信号 CRS 打入到**列地址锁存器**
- 增加了刷新计数器和相应的控制电路
    - DRAM 读出后必须刷新，而未读写的存储元也要定期刷新，而且要按行刷新
    - 所以刷新计数器的长度等于行地址锁存器
    - 刷新操作与读/写操作是交替进行的，所以通过 2 选 1 多路开关来提供刷新行地址或正常读/写的行地址。

<img src="http://image.trouvaille0198.top/2463472472.png" alt="2463472472" style="zoom:80%;" />

### 3.3.3 刷新周期

#### 1）刷新周期

DRAM 存储位元是基于电容器上的电荷量存储，这个电荷量随着时间和温度而减少，因此必须定期地刷新，以保持它们原来记忆的正确信息

#### 2）刷新方式

- **集中式刷新**
    - DRAM 的所有行在每一个刷新周期中都被刷新。
    - 例如刷新周期为 8ms 的内存来说，所有行的集中式刷新必须每隔8ms进行一次。为此将 8ms 时间分为两部分
        - 前一段时间进行正常的读/写操作
        - 后一段时间（8ms 至正常读/写周期时间）做为集中刷新操作时间。

- **分散式刷新**
    - 每一行的刷新插入到正常的读/写周期之中。
        - 例如上图所示的 DRAM 有 1024 行，如果刷新周期为 8ms，则每一行必须每隔 8ms÷1024=7.8us 进行一次。

### 3.3.4 存储器容量的扩充

#### 1）字长位数扩展（位扩展）

1k × 4 位 -> 1k × 16 位 ，4片

（位扩展，横向）

 给定的芯片字长位数较短，不满足设计要求的存储器字长，此时需要用多片给定芯片扩展字长位数。

特点

- 地址线公用
- 控制线公用（所有芯片的片选信号、读信号、写信号拼在一起）公用       

- 数据线单独分开连接

所需芯片数 d = 设计要求的存储器容量/选择芯片存储器容量

<img src="http://image.trouvaille0198.top/image-20210401140916346.png" alt="image-20210401140916346" style="zoom: 50%;" />

#### 2）字存储容量扩展（字扩展）

1k × 4 位 -> 4k × 4 位 ，4片

（字扩展，纵向）

给定的芯片存储容量较小（字数少），不满足设计要求的总存储容量，此时需要用多片给定芯片来扩展字数

特点

- 地址总线和数据总线公用，后面的地址总线来选择芯片，前面的地址总线选择此芯片的地址

- 控制总线中 R/W 公用，使能端 EN 不能共用

- 它由地址总线的高位段译码来决定片选信号。

<img src="http://image.trouvaille0198.top/image-20210401141634557.png" alt="image-20210401141634557" style="zoom:50%;" />

#### 3）字位扩展

1k × 4 位 -> 4k × 16 位 ，16 片

## 3.4 并行存储器

为了提高 CPU 和主存之间的数据传输率，除了主存采用更高速的技术来缩短读出时间外，还可以采用并行技术的存储器

### 3.4.1 双端口存储器

空间并行

#### 1）逻辑结构

同一个存储器具有两组相互独立的**读写控制电路**

R/W：读写

OE：输出使能

CE：片选

A：11位地址线

I/O：16位数据线

<img src="http://image.trouvaille0198.top/image-20210408122817887.png" alt="image-20210408122817887" style="zoom: 67%;" />

#### 2）无冲突读写控制

当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突

![image-20210408123632430](http://image.trouvaille0198.top/image-20210408123632430.png)

#### 3）有冲突读写控制

当两个端口同时存取存储器同一存储单元时，便发生读写冲突

为解决此问题，特设置了 BUSY 标志。在这种情况下，片上的判断逻辑可以决定对哪个端口优先进行读写操作，而对另一个被延迟的端口置 BUSY 标志 (BUSY 变为低电平)，即暂时关闭此端口。

判断方式自学

### 3.4.2 多模块交叉存储器

时间并行，多个存储体来存储数据

#### 1）存储器的模块化组织

一个由若干个模块组成的主存储器是线性编址的。

这些地址在各模块中如何安排，有两种方式：一种是顺序方式，一种是交叉方式 

<img src="http://image.trouvaille0198.top/image-20210408124309690.png" alt="image-20210408124309690" style="zoom: 50%;" />

- 顺序方式

    [例] M0－M3 共四个模块，则每个模块8个字

    顺序方式： 

    ​				    M0：0—7

    ​          		  M1：8－15

    ​        		    M2：16－23

    ​       		     M3：24－31

    5位地址组织如下： X X    X X X

    高位选模块，低位选块内地址

    特点：某个模块进行存取时，其他模块不工作，优点是某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。缺点是各模块串行工作，存储器的带宽受到了限制。

- 交叉方式

    [例] M0－M3 共四个模块，则每个模块 8 个字

    交叉方式：

    ​			      M0：0，4,...除以4余数为0

    ​		          M1：1，5,...除以4余数为1

    ​		          M2：2，6,...除以4余数为2

    ​				  M3：3，7,...除以4余数为3

    5位地址组织如下： X X X     X X

    高位选块内地址，低位选模块

    特点：连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。优点是对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。缺点是不易扩展。

#### 2）基本结构

右图为四模块交叉存储器结构框图。主存被分成 4 个相互独立、容量相同的模块 M0，M1，M2，M3，每个模块都有自己的读写控制电路、地址寄存器和数据寄存器，各自以等同的方式与 CPU 传送信息。在理想情况下，如果程序段或数据块都是连续地在主存中存取，那么将大大提高主存的访问速度

<img src="http://image.trouvaille0198.top/image-20210408125546603.png" alt="image-20210408125546603" style="zoom:80%;" />

#### 3）定量分析

通常在一个存储器周期内，n 个存储体必须分时启动，则各个存储体的启动间隔为 $t=T/n$（n为交叉存取度）

整个存储器的存取速度有望提高 n 倍
$$
t_{顺序}=xT \\ t_{交叉}=T+(x-1)t=T(\frac{x+n-1}{n})
$$
<img src="http://image.trouvaille0198.top/image-20210408132215307.png" alt="image-20210408132215307" style="zoom:67%;" />

例：设存储器容量为 32 字，字长 64 位，模块数 m = 4，分别用顺序方式和交叉方式进行组织。存储周期 T = 200ns，数据总线宽度为 64 位，总线传送周期 = 50ns。若连续读出 4 个字，问顺序存储器和交叉存储器的带宽（单位时间内的传输量）各是多少?

解：顺序存储器和交叉存储器连续读出 m = 4 个字的信息总量都是：

​		 q = 64b×4 = 256b

​		顺序存储器和交叉存储器连续读出 4 个字所需的时间分别是：

​		t2 = mT = 4×200ns = 800ns = 8×10-7s

​		t1 = T + (m - 1) = 200ns + 350ns = 350ns = 35×10-7s

​		顺序存储器和交叉存储器的带宽分别是：

​		W2=q/t2=256b÷(8×10-7)s=320Mb/s

​		W1=q/t1=256b÷(35×10-7)s=730Mb/s

## 3.5 Cache 存储器

### 3.5.1 Cache 基本原理

#### 1）功能

**提高存储器反应速度**，解决 CPU 和主存之间的速度不匹配问题

- 一般采用高速的 SRAM 构成。

- CPU 和主存之间的速度差别很大，采用两级或多级 Cache 系统

- 早期的一级 Cache 在 CPU 内，二级在主板上

- 现在的 CPU 内带 L1 Cache 和 L2 Cache

- 全由硬件调度，对用户透明

<img src="http://image.trouvaille0198.top/image-20210408141702866.png" alt="image-20210408141702866" style="zoom:67%;" />

#### 2）基本原理

- 主存与 Cache 以**块**为单位进行数据交换（依据空间复杂性）

- CPU 则以**字** (存储单元) 为单位访问 Cache，依据地址判断此字当前是否在 Cache 中
    - 若是，直接传
    - 否则，CPU 去主存找此字，同时主存把此字送到 Cache 中（依据时间复杂性）

地址映射

替换策略

写一致性

性能评价

<img src="http://image.trouvaille0198.top/image-20210408141747675.png" alt="image-20210408141747675" style="zoom: 50%;" />

#### 3）命中率

从 CPU 来看，增加一个 cache 的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。为了达到这个目的，在所有的存储器访问中由 cache 满足 CPU 需要的部分应占很高的比例，即 cache 的命中率应接近于 1。由于程序访问的局部性（**局部性原理**），实现这个目标是可能的

#### 4）命中率公式

$$
命中率： h=\frac{N_c}{N_c+N_m} \\
Cache的平均访问时间： t_a=ht_c+(1-h)t_m \\
访问效率： e=\frac{t_c}{t_a}=\frac{1}{r+(1-r)h} \\
主存慢于Cache的倍率： r=\frac{t_m}{t_c}
$$



例：CPU 执行一段程序时，cache 完成存取的次数为 1900 次，主存完成存取的次数为 100 次，已知 cache 存取周期为 50ns，主存存取周期为 250ns，求 cache / 主存系统的效率和平均访问时间。 

解：
$$
h=N_c/(N_c+N_m)=1900/(1900+100)=0.95 \\ 
r=t_m/t_c=250ns/50ns=5 \\
e=1/(r+(1-r)h)=1/(5+(1-5)×0.95)=83.3\% \\
t_a=t_c/e=50ns/0.833=60ns \\
$$

### 3.5.2 主存与 Cache 的地址映射

映射的本质：主存块号变成 cache 行号

无论选择哪种映射方式，都要把主存和 cache 划分为同样大小的“块”。

选择哪种映射方式，要考虑：

- 硬件是否容易实现

- 地址变换的速度是否快

- 主存空间的利用率是否高

- 主存装入一块时，发生冲突的概率

#### 1）全相联的映射方式

**主存中的块可以放入到 cache 的任意一行**

- 将地址分为两部分——**块号和字**（块内地址），在内存块（随机）写入 Cache 时，同时写入块号（**标记**）；

- 字即块内地址，即目标在块内的地址；主存中的块内地址即 cache 中的行内地址

- CPU 给出访问地址后，也将地址分为两部分（块号和字），比较块号与 Cache 表中的标记进行比较，相同表示命中，访问相应单元；如果没有命中访问内存，CPU 直接访问内存，并将被访问内存的相对应块写入 Cache。

- 转换公式

    - 主存地址长度＝(s + w) 位
    - 寻址单元数＝2^s+w^ 个字或字节

    - 块大小＝行大小＝2^w^ 个字或字节

    - 主存的块数＝2^s^

    - 标记大小＝s 位

    - cache 的行数＝不由地址格式确定

- 特点：

    优点：冲突概率小，Cache 的利用高。（只有当 cache 全满时才会发生冲突）

    缺点：比较器难实现，需要一个访问速度很快代价高的相联存储器

- 应用场合：

    适用于小容量的 Cache

<img src="http://image.trouvaille0198.top/a1.png" style="zoom: 67%;" />

#### 2）直接映射方式

**主存中的块只能放入到 cache 的固定一行**

- 映射方法（一对多）
    - **i = j mod m**
    - 主存第 j 块内容拷贝到 Cache 的 i 行
    - m 表示 cache 的行数
    - 一般 i 和 m 都是 2^N^ 级
- **地址：标记 + 行号 + 块内地址**
- [例] cache 容量 16 字，主存容量 256 字，则地址 2，18，34…..242 等都存放在 cache 的地址 2 内，如果第一次 2 在 cache 中，下次访问 34 内容，则不管 cache 其他位置的内容访问情况，都会引起 2 块内容的替换
- 基本原理
    - 利用行号选择相应行；
    - 把行标记与 CPU 访问地址进行比较，相同表示命中，访问 Cache；
    - 如果没有命中，访问内存，并将相应块写入 Cache
- 转换公式
    - 主存地址长度＝ (s+w) 位
    - 寻址单元数＝2^s+w^ 个字或字节
    - 块大小＝行大小＝2^w^ 个字或字节
    - 主存的块数＝2^s^
    - cache 的行数＝m＝2^r^
    - 标记大小＝(s-r) 位

- 特点

    优点：比较电路少 m 倍线路，所以硬件实现简单，Cache 地址为主存地址的低几位，不需变换。

    缺点：冲突概率高（抖动）

- 应用场合

    适合大容量 Cache

<img src="http://image.trouvaille0198.top/a3.png" style="zoom:70%;" />

#### 3）组相联映射方式

**前两者的组合，cache 中以若干行为一组，组之间直接映射，组内全相联**

- Cache 分组，**组间采用直接映射方式，组内采用全相联的映射方式**

- Cache 分组 U，组内容量 V

- 映射方法（一对多）
    - **q = j mod u**	
    - 主存第 j 块内容拷贝到 Cache 的第 q 组中的某行
    - u 表示组数；q 表示组号，j 表示块号
- **地址 = （表示行的）标记 + 组号 + 块内地址**

- 地址变换
    - 设主存地址 x，看是不是在 cache 中，先 y = x mod u，则在 y 组中一次查找
- 分析
    - v=1，则为直接相联映射方式
    - u=1，则为全相联映射方式
    - v 的取值一般比较小， 一般是 2 的幂，称之为 v 路组相联 cache.
- 转换公式
    - 主存地址长度＝(s+w) 位
    - 寻址单元数＝2^s+w^ 个字或字节
    - 块大小＝行大小＝2^w^ 个字或字节
    - 主存的块数＝2^s^
    - 每组的行数＝k
    - 组数 v＝2^d^
    - cache 的行数＝kv
    - 标记大小＝(s-d) 位
- n 路组相联：一个组有 n 行

<img src="http://image.trouvaille0198.top/a2.png" style="zoom: 70%;" />

#### 4）例

<img src="http://image.trouvaille0198.top/image-20210415140629870.png" alt="image-20210415140629870" style="zoom: 50%;" />

<img src="http://image.trouvaille0198.top/image-20210415140650706.png" alt="image-20210415140650706" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210415143127801.png" alt="image-20210415143127801" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210415143137255.png" alt="image-20210415143137255" style="zoom:50%;" />

### 3.5.3 替换策略

- **LFU**（最不经常使用 ）：被访问 / 命中的行计数器增加 1。始终拿走值最小的行，不能反映近期 cache 的访问情况，

- **LRU**（近期最少使用） ：被访问的行计数器置 0，其他的计数器增加1，始终拿走值最大的行，符合 cache 的工作原理

- 随机替换：随便找个位置而已

### 3.5.4 写操作策略

由于 cache 的内容只是主存部分内容的拷贝，它应当与主存内容保持一致。而 CPU 对 cache 的写入更改了 cache 的内容。如何与主存内容保持一致，可选用如下三种写操作策略。

- 写回法：只写 Cache；换出时，对行的修改位进行判断，决定是写回还是舍掉。 

- 全写法（写直达法）：写命中时，Cache 与内存一起写 

- 写一次法：与写回法一致，但是第一次 Cache 命中时采用全写法。(第一次一起写，之后写 cache)

## 3.6 虚拟存储器

### 3.6.1 概念

- 虚地址：用户编制程序时使用的地址称为**虚地址**或**逻辑地址**，其对应的存储空间称为虚存空间或逻辑地址空间；

- 实地址：而计算机物理内存的访问地址则称为**实地址**或**物理地址**，其对应的存储空间称为**物理存储空间**或**主存空间**。

- 再定位：程序进行虚地址到实地址转换的过程称为程序的**再定位**（虚实转换），在访问 cache 之前就已经完成

#### 1）虚存的访问过程

- 虚存空间的用户程序按照虚地址编程并存放在辅存中。
- 程序运行时，由地址变换机构依据当时分配给该程序的实地址空间把程序的一部分调入实存。
- 每次访存时，首先判断**该虚地址所对应的部分是否在实存中**：
    - 若是，则进行地址转换并用实地址访问主存；
    - 否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。
- 由此可见，每个程序的虚地址空间可以远大于实地址空间，也可以远小于实地址空间。
    - 前一种情况以提高存储容量为目的，后一种情况则以地址变换为目的。
    - 后者通常出现在多用户或多任务系统中：实存空间较大，而单个任务并不需要很大的地址空间，较小的虚存空间则可以缩短指令中地址字段的长度。

<img src="http://image.trouvaille0198.top/image-20210422131552285.png" alt="image-20210422131552285" style="zoom:50%;" />

#### 2）cache 与虚存的异同

- 从虚存的概念可以看出，主存辅存的访问机制与 cache 主存的访问机制是类似的。这是由 cache 存储器、主存和辅存构成的三级存储体系中的两个层次。
- cache 和主存之间以及主存和辅存之间分别有辅助硬件和辅助软硬件负责地址变换与管理，以便各级存储器能够组成有机的三级存储体系。cache 和主存构成了系统的内存，而主存和辅存依靠辅助软硬件的支持构成了虚拟存储器。

-    在三级存储体系中，cache 主存和主存辅存这两个存储层次有许多**相同点**；
    1. **出发点相同** 二者都是为了提高存储系统的性能价格比而构造的分层存储体系，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。
    2. **原理相同** 都是利用了程序运行时的局部性原理把最近常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器。

- 但 cache 主存和主存辅存这两个存储层次也有许多**不同**之处：
    3. **侧重点不同** cache 主要解决主存与CPU的速度差异问题；而就性能价格比的提高而言，虚存主要是解决存储容量问题，另外还包括存储管理、主存分配和存储保护等方面。
    4. **数据通路不同** CPU 与 cache 和主存之间均有直接访问通路，cache 不命中时可直接访问主存；而虚存所依赖的辅存与 CPU 之间不存在直接的数据通路，当主存不命中时只能通过调页解决，CPU 最终还是要访问主存。
    5. **透明性不同** cache 的管理完全由硬件完成，对系统程序员和应用程序员均透明；而虚存管理由软件（操作系统）和硬件共同完成，由于软件的介入，虚存对实现存储管理的系统程序员不透明，而只对应用程序员透明（段式和段页式管理对应用程序员“半透明”）。
    6. **未命中时的损失不同** 由于主存的存取时间是 cache 的存取时间的 5～10 倍，而主存的存取速度通常比辅存的存取速度快上千倍，故主存未命中时系统的性能损失要远大于 cache 未命中时的损失。

#### 3）虚存机制要解决的关键问题

1. 调度问题决定哪些程序和数据应被调入主存。 
2. 地址映射问题在访问主存时把虚地址变为主存物理地址（这一过程称为内地址变换）；在访问辅存时把虚地址变成辅存的物理地址（这一过程称为外地址变换），以便换页。此外还要解决主存分配、存储保护与程序再定位等问题。
3. 替换问题决定哪些程序和数据应被调出主存。 
4. 更新问题确保主存与辅存的一致性。 

在操作系统的控制下，硬件和系统软件为用户解决了上述问题，从而使应用程序的编程大大简化。

### 3.6.2 页式虚拟存储器

#### 1）页 

虚地址空间被分成**等长大小的页**，称为**逻辑页**；

主存空间也被分成**同样大小的页**，称为**物理页**

虚地址分为两个字段：高字段为**逻辑页号**，低字段为**页内地址**（偏移量）；

- 虚页号由逻辑空间的大小决定（单位为页的个数），页内地址由页的大小决定

实存地址也分两个字段：高字段为**物理页号**，低字段为**页内地址**。

- 两者的页内地址相同，唯一需要转换的是虚页号到实页号

- 通过**页表**可以把虚地址（逻辑地址）转换成物理地址。

#### 2）页表

页表中对应每一个**虚存页面**有一个**表项**，表项的内容包含该虚存页面所在的主存页面的地址（**物理页号**），以及指示该逻辑页是否已调入主存的**有效**位。

地址变换时，用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接，就构成完整的物理地址。现代的中央处理机通常有专门的硬件支持地址变换。

每个进程所需的页数并不固定，所以页表的长度是可变的，因此通常的实现方法是把页表的基地址保存在寄存器中（**页表基址 R**），而页表本身则放在主存中。

由于虚存地址空间可以很大，因而每个进程的页表有可能非常长。例如，如果一个进程的虚地址空间为2G字节，每页的大小为512字节，则总的虚页数为 2^31^/2^9^=2^22^。

<img src="http://image.trouvaille0198.top/image-20210422132725324.png" alt="image-20210422132725324" style="zoom: 67%;" />

为了节省页表本身占用的主存空间，一些系统把页表存储在虚存中（**快表**，TLB，转换后援缓冲器），全硬件实现，容量小，是页表（此时称慢表）的子集，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存。

<img src="http://image.trouvaille0198.top/image-20210422135845562.png" alt="image-20210422135845562" style="zoom: 67%;" />

页表和快表同时查找！

另一些系统采用**二级页表**结构。每个进程有一个页目录表，其中的每个表项指向一个页表。

在页表长度较大的系统中，还可以采用反向页表实现物理页号到逻辑页号的反向映射。页表中对应每一个物理页号有一个表项，表项的内容包含该物理页所对应的逻辑页号。访存时，通过逻辑页号在反向页表中逐一查找。如果找到匹配的页，则用表项中的物理页号取代逻辑页号；如果没有匹配表项，则说明该页不在主存中。这种方式的优点是页表所占空间大大缩小，但代价是需要对反向页表进行检索，查表的时间很长。有些系统通过散列（哈希）表加以改进

**内页表和外页表**

页表是虚地址到主存物理地址的变换表，通常称为内页表。与内页表对应的还有外页表，用于虚地址与辅存地址之间的变换。当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。

![image-20210422135944175](http://image.trouvaille0198.top/image-20210422135944175.png)

### 3.6.3 段式虚拟存储器

#### 1）段和段表

段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。

虚地址由**段号**和**段内地址（偏移量）**组成。虚地址到实主存地址的变换通过**段表**实现。

每个**表项**至少包含下面三个字段：

1. 有效位：指明该段是否已经调入实存。
2. 段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。 
3. 段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。

段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。

<img src="http://image.trouvaille0198.top/image-20210422140841856.png" alt="image-20210422140841856" style="zoom: 67%;" />

#### 2）特点

- 优点
    - 段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序**共享**。
    - 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。

- 缺点
    - 因为段的长度不固定，主存空间分配比较麻烦
    - 容易在段间留下许多外碎片，造成存储空间利用率降低
    - 由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。

### 3.6.4 段页式虚拟存储器

实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页，程序按页进行调入和调出操作，但可按段进行编程、保护和共享

一般情况下由一张段表，其中有好多页表

虚地址：基号 + 段号 + 页号 + 页内地址

实地址：物理页号 + 页内地址

<img src="http://image.trouvaille0198.top/image-20210422142550704.png" alt="image-20210422142550704" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210422142602662.png" alt="image-20210422142602662" style="zoom:50%;" />

### 3.6.5 虚存的替换算法

当从辅存调页至主存而主存已满时，也需要进行主存页面的替换。虚拟存储器的替换算法与cache的替换算法类似，有 FIFO 算法、LRU 算法、LFU 算法等。

虚拟存储器的替换算法与 cache 的替换算法不同的是： 

1. cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。
2. 虚存缺页对系统性能的影响比 cache 未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。
3. 虚存页面替换的选择余地很大，属于一个进程的页面都可替换。

<img src="http://image.trouvaille0198.top/image-20210422142747470.png" alt="image-20210422142747470" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210422142756955.png" alt="image-20210422142756955" style="zoom:50%;" />

# 四、指令系统

## 4.1 指令系统的发展与性能要求

### 4.1.1 指令系统的发展

#### 1）分类

- 微指令：微程序级的命令，它属于硬件；

- 宏指令：由若干条机器指令组成的软件指令，它属于软件；

- 机器指令：介于微指令与宏指令之间，通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作

本章所讨论的指令，是机器指令

按作用分：

**数据传送指令、算术运算指令、逻辑运算指令、程序控制指令**

#### 2）发展情况

- 复杂指令系统计算机，简称 CISC。
    - 如此庞大的指令系统不但使计算机的研制周期变长，难以保证正确性，不易调试维护，而且由于采用了大量使用频率很低的复杂指令而造成硬件资源浪费。

- 精简指令系统计算机：简称 RISC
    - 人们提出了便于 VLSI 技术实现的精简指令系统计算机。

### 4.1.2 指令系统性能要求

- **完备性：**完备性是指用汇编语言编写各种程序时，指令系统直接提供的指令足够使用，而不必用软件来实现。

- **有效性：**有效性是指利用该指令系统所编写的程序能够高效率地运行。

- **规整性：**规整性包括指令系统的对称性、匀齐性、指令格式和数据格式的一致性。
    - 对称性是指：在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式
    - 匀齐性是指：一种操作性质的指令可以支持各种数据类型
    - 指令格式和数据格式的一致性是指：指令长度和数据长度有一定的关系，以方便处理和存取。
- **兼容性：**系列机各机种之间具有相同的基本结构和共同的基本指令集，因而指令系统是兼容的，即各机种上基本软件可以通用。

## 4.2 指令格式

![image-20210313140042554](http://image.trouvaille0198.top/image-20210313140042554.png)

### 4.2.1 操作码

指令的操作码OP表示该指令应进行什么性质的操作。不同的指令用操作码字段的不同编码来表示，每一种编码代表一种指令。

组成操作码字段的位数一般取决于计算机指令系统的规模

### 4.2.2 地址码

<img src="http://image.trouvaille0198.top/image-20210313140556330.png" alt="image-20210313140556330" style="zoom:80%;" />

#### 1）三地址指令

功能描述
- (A1) op (A2)→A3

这种格式虽然省去了一个地址，但指令长度仍比较长，所以只在字长较长的大、中型机中使用，而小型、微型机中很少使用

#### 2）二地址指令

- 功能描述
    - (A1) op (A2)→A1
- 说明
    - 二地址指令在计算机中得到了广泛的应用，
    - 注意：指令执行之后，A1 中原存的内容已经被新的运算结果替换了

- 二地址地址根据操作数的物理位置分为：
    - SS  存储器-存储器类型
    - RS  寄存器-存储器类型
    - RR  寄存器-寄存器类型

#### 3）一地址指令

- 功能描述
    - (AC) op (A1) → A1
- 说明
    - 单操作数运算指令，如“+1”、“-1”、“求反”
    - 指令中给出一个源操作数的地址
    - 另一个操作数地址是隐含的

#### 4）零地址指令

“停机”、“空操作”、“清除”等控制类指令

<img src="http://image.trouvaille0198.top/image-20210322171915747.png" alt="image-20210322171915747" style="zoom:80%;" />

## 4.3 指令字长度

### 4.3.1 概念

- 指令字长度（一个指令字包含二进制代码的位数）

- 机器字长：计算机能直接处理的二进制数据的位数。
- 分类
    - 单字长指令：指令字长等于一个机器字长
    - 半字长指令：指令字长等于半个机器字长
    - 双字长指令：指令字长等于两个机器字长

### 4.3.2 理解

- **多字长指令**的优缺点

    - 优点：提供足够的地址位来解决访问内存任何单元的寻址问题 ；

    - 缺点：必须两次或多次访问内存以取出一整条指令，降低了 CPU 的运算速度，又占用了更多的存储空间

- **等长指令**

    - 各种指令字长度是相等的，指令字结构简单，且指令字长度是不变的 ；

- **非等长指令**

    - 各种指令字长度随指令功能而异，结构灵活，能充分利用指令长度，但指令的控制较复杂

 ### 4.3.3 指令助记符

- 用3～4个英文字母来表示操作码，一般为英文缩写
- 不同的计算机系统，规定不一样
- 必须用汇编语言翻译成二进制代码

### 4.3.4 指令格式举例

<img src="http://image.trouvaille0198.top/image-20210313153644062.png" alt="image-20210313153644062" style="zoom:67%;" />

## 4.4 指令和数据的寻址方式

### 4.4.1 指令的寻址方式

- 顺序寻址方式
    - PC + 1

- 跳跃寻址方式

<img src="C:\Users\Tyeah\AppData\Roaming\Typora\typora-user-images\image-20210313154155455.png" alt="image-20210313154155455" style="zoom:67%;" />

### 4.4.2 操作数基本寻址方式

形成操作数**有效地址**的方法，称为操作数的寻址方式

<img src="http://image.trouvaille0198.top/image-20210313154314344.png" alt="image-20210313154314344" style="zoom:67%;" />

形式地址 + 寻址方式特征位

- 形式地址 A , 也称偏移量， 它是指令字结构中给定的地址量。 

- 寻址方式特征位， 此处由间址位和变址位组成。 
- 如果这条指令无间址和变址的要求， 那么形式地址就是操作数的有效地址。 如果指令中指明要变址或间址变换， 那么形式地址就不是操作数的有效地址， 而要经过指定方式的变换， 才能形成有效地址。 因此， 寻址过程就是把操作数的形式地址， 变换为操作数的有效地址的过程

![image-20210313154636585](http://image.trouvaille0198.top/image-20210313154636585.png)

<img src="http://image.trouvaille0198.top/image-20210313154658369.png" alt="image-20210313154658369" style="zoom:80%;" />

#### 1）隐含寻址

指令中隐含着操作数的地址

如单地址指令的某些运算，隐含了累加器 AC 作为源和目的寄存器

#### 2）立即寻址

指令的地址字段不操作数地址，而是操作数本身

也就是不用寻址

指令格式：操作码 OP  操作数 A

#### 3）直接寻址

指令中地址码字段给出的地址 A 就是操作数的有效地址 EA (Effective Address)、

**EA＝A**

<img src="http://image.trouvaille0198.top/image-20210313160650656.png" alt="image-20210313160650656" style="zoom:67%;" />

#### 4）间接寻址

指令的地址码部分给出的地址 A 是操作数地址的地址

**EA＝(A)**

<img src="http://image.trouvaille0198.top/image-20210313160951264.png" alt="image-20210313160951264" style="zoom:67%;" />

#### 5）寄存器寻址

在指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中

**EA = R**

<img src="http://image.trouvaille0198.top/image-20210313162422634.png" alt="image-20210313162422634" style="zoom:67%;" />

优点

1. 由于寄存器在CPU的内部，指令在执行时从寄存器中取操作数比访问主存要快得多；

2. 由于寄存器的数量较少，因此寄存器编号所占位数也较少，从而可以有效减少指令的地址码字段的长度。

#### 6）寄存器间接寻址

为了克服间接寻址中多次访存的缺点，可采用寄存器间接寻址，即将操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，然后在指令的地址码部分给出该通用寄存器的编号

**EA = (R)**

<img src="http://image.trouvaille0198.top/image-20210313162559938.png" alt="image-20210313162559938" style="zoom:67%;" />

这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数，因此指令执行速度较前述的间接寻址方式要快，也是目前在计算机中使用较为广泛的一种寻址方式

#### 7）偏移寻址

偏移寻址要求指令中有两个地址字段，至少有一个是显示的

- 必定显示的形式地址 A （一般是一个偏移量 D）
- 一个隐含的引用（一般是一个专用寄存器）

**EA = A + (R)**

##### 1. 相对寻址

由程序计数器 PC 提供基准地址（隐含引用），而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址

**EA＝D + (PC)**

<img src="http://image.trouvaille0198.top/image-20210313163115499.png" alt="image-20210313163115499" style="zoom:67%;" />

##### 2. 基址寻址

专用寄存器是一个基址寄存器，可以显示可以隐式

基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址

**EA = D + (R)**

<img src="http://image.trouvaille0198.top/image-20210313163219858.png" alt="image-20210313163219858" style="zoom: 80%;" />

##### 3. 变址寻址

变址寻址就是将指令的地址码部分给出的基准地址 A 与变址寄存器 R 中的内容相加，以形成操作数的有效地址。

**EA = A + R**

<img src="http://image.trouvaille0198.top/image-20210313163842841.png" alt="image-20210313163842841" style="zoom: 80%;" />

#### 8）段寻址方式

存储空间划分为多段

<img src="http://image.trouvaille0198.top/image-20210313164024231.png" alt="image-20210313164024231" style="zoom:80%;" />

#### 9）堆栈寻址

以先进后出原理存储数据

### 4.4.3 寻址方式举例

<img src="http://image.trouvaille0198.top/image-20210313164917780.png" alt="image-20210313164917780" style="zoom: 80%;" />

![image-20210313164931546](http://image.trouvaille0198.top/image-20210313164931546.png)

![image-20210320150116083](http://image.trouvaille0198.top/image-20210320150116083.png)

![image-20210320145606857](http://image.trouvaille0198.top/image-20210320145606857.png)

# 五、中央处理器

## 5.1 CPU的功能和组成

### 5.1.1 CPU的功能

<img src="http://image.trouvaille0198.top/image-20210313170054923.png" alt="image-20210313170054923" style="zoom:80%;" />

指令控制（程序的顺序控制）

操作控制（一条指令有若干操作信号实现）

时间控制（指令各个操作实施时间的定时）

数据加工（算术运算和逻辑运算）

### 5.1.2 CPU的基本组成

![图片1](http://image.trouvaille0198.top/%E5%9B%BE%E7%89%871.png)

中央处理器 CPU = 运算器 + cache + 控制器 

#### 1）运算器

- ALU 
- 通用寄存器：R0～R3
- 暂存器：DR
- 状态字寄存器：PSW

#### 2）cache 

- 指令 cache：PC，IBUS

- 数据 cache：AR，DBUS

#### 3）控制器

- 程序计数器、指令寄存器、数据缓冲器、地址寄存器、时序发生器、指令译码器、总线（数据通路）
    - 程序计数器 PC (Programming Counter)
        - 用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址。
        - 顺序执行时，每执行一条指令，PC的值应加1
        - 要改变程序执行顺序的情况时，一般由转移类指令将转移目标地址送往 PC ，可实现程序的转移
    - 指令寄存器 IR (Instruction Register)  
        - 指令寄存器用来存放从存储器中取出的待执行的指令。
        - 在执行该指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能。

### 5.1.3 CPU 中的主要寄存器

数据缓冲寄存器(DR)

- 中转站

- 补偿速度差别

- 指令寄存器 (IR)

- 程序计数器 (PC)

- 数据地址寄存器 (AR)

- 通用寄存器 (R0～R3)

- 状态字寄存器 (PSW)

## 5.2 指令周期

### 5.2.1 指令周期的基本概念

**指令周期**：取出一条指令并执行这条指令的时间

**CPU 周期**：又称机器周期，用从内存中读取一个指令字的最短时间来规定 CPU 周期

​					换句话说，就是以主存的工作周期 (存取周期) 为基础来规定 CPU 周期

​					通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作

​					一个 CPU 周期中，包含若干个节拍脉冲（T 周期）

​					CPU 周期通常定义为机器主频的倒数

<img src="http://image.trouvaille0198.top/image-20210313173359110.png" alt="image-20210313173359110" style="zoom:80%;" />

### 5.2.2 MOV 指令的指令周期

两个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313173851190.png" alt="image-20210313173851190" style="zoom: 80%;" />

#### 1）取指周期

程序计数器PC中装入第一条指令地址101（八进制）；

PC的内容被放到指令地址总线ABUS（I）上，对指存进行译码，并启动读命令；

从101号地址读出的MOV指令通过指令总线IBUS装入指令寄存器IR；

程序计数器内容加1，变成102，为取下一条指令做好准备；

指令寄存器中的操作码（OP）被译码；

CPU识别出是MOV指令，至此，取指周期即告结束

<img src="http://image.trouvaille0198.top/image-20210313174137437.png" alt="image-20210313174137437" style="zoom: 80%;" />

#### 2）执行周期

操作控制器（OC）送出控制信号到通用寄存器，选择R1（10）作源寄存器，选择R0作目标寄存器；

OC送出控制信号到ALU，指定ALU做传送操作；

OC送出控制信号，打开ALU输出三态门，将ALU输出送到数据总线DBUS上。注意，任何时候DBUS上只能有一个数据。

OC送出控制信号，将DBUS上的数据打入到数据缓冲寄存器DR（10）；

OC送出控制信号，将DR中的数据10打入到目标寄存器R0，R0的内容由00变为10。至此，MOV指令执行结束。

<img src="http://image.trouvaille0198.top/image-20210313174237168.png" alt="image-20210313174237168" style="zoom:80%;" />

### 5.2.3 LAD 指令的指令周期

三个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313174621752.png" alt="image-20210313174621752"  />

#### 1）取指周期

与 MOV 指令一样，以下皆同

#### 2）执行周期

操作控制器OC发出控制命令打开IR输出三态门，将指令中的直接地址码6放到数据总线DBUS上；

OC发出操作命令，将地址码6装入数存地址寄存器AR；

OC发出读命令，将数存6号单元中的数100读出到DBUS上；

OC发出命令，将DBUS上的数据100装入缓冲寄存器DR；

OC发出命令，将DR中的数100装入通用寄存器R1，原来R1中的数10被冲掉。至此，LAD指令执行周期结束。

![image-20210313174907814](http://image.trouvaille0198.top/image-20210313174907814.png)

### 5.2.4 ADD 指令的指令周期

两个 CPU 周期

#### 1）执行周期

操作控制器OC送出控制命令到通用寄存器，选择R1做源寄存器，R2做目标寄存器；

OC送出控制命令到ALU，指定ALU做R1（100）和R2（20）的加法操作；

OC送出控制命令，打开ALU输出三态门，运算结果120放到DBUS上；

OC送出控制命令，将DBUS上数据打入缓冲寄存器DR；ALU产生的进位信号保存状态字寄存器在PSW中。

OC送出控制命令，将DR（120）装入R2，R2中原来的内容20被冲掉。至此ADD指令执行周期结束

<img src="http://image.trouvaille0198.top/image-20210313190818882.png" alt="image-20210313190818882" style="zoom:90%;" />

### 5.2.5 STO 指令的指令周期

三个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313191407824.png" alt="image-20210313191407824" style="zoom:80%;" />

#### 1）执行周期

注意：DBUS 为单总线结构，先送地址，后送数据

操作控制器OC送出操作命令到通用寄存器，选择（R3）=30做数据存储器的地址单元；

OC发出操作命令，打开通用寄存器输出三态门（不经ALU以节省时间），将地址30放到DBUS上；

OC发出操作命令，将地址30打入AR，并进行数存地址译码；

OC发出操作命令到通用寄存器，选择（R2）=120），作为数存的写入数据；

OC发出操作命令，打开通用寄存器输出三态门，将数据120放到DBUS上。

OC发出操作命令，将数据120写入数存30号单元，它原先的数据40被冲掉。至此，STO指令执行周期结束

<img src="http://image.trouvaille0198.top/image-20210313191508145.png" alt="image-20210313191508145" style="zoom:90%;" />

### 5.2.6 JMP 指令的指令周期

两个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313191651516.png" alt="image-20210313191651516" style="zoom: 80%;" />

#### 1）执行周期

OC 发生操作控制命令，打开指令寄存器 IR 的输出三态门，将IR中的地址码 101 发送到DBUS上；

OC 发出操作控制命令，将 DBUS 上的地址码 101 打入到程序计数器 PC 中，PC中的原先内容 106 被更换。于是下一条指令不是从 106 号单元取出，而是转移到 101 号单元取出。至此 JMP 指令执行周期结束

![image-20210313192020243](http://image.trouvaille0198.top/image-20210313192020243.png)

### 5.2.7 用方框图语言表示指令周期

#### 1）方法

- 指令系统设计（模型机的五指令系统）

- 方框——按 CPU 周期

- 方框内内容——数据通路操作或控制操作

- 菱形符号——判别或测试

- ~——公操作

- 前边所讲述的5种操作的框图描述

#### 2）例

![image-20210313192845282](http://image.trouvaille0198.top/image-20210313192845282.png)

## 5.3 时序产生器和控制方式

- 同步控制方式（指令的机器周期和时钟周期数不变）
    - 完全统一的机器周期执行各种不同的指令
    - 或采用不定长机器周期
    - 中央控制于局部控制的结合

- 异步控制方式
    - 每条指令需要多长时间就占多长时间

- 联合控制方式
    - 大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式
    - 或，机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用）

## 5.4 微程序控制器

微命令->微指令->微程序

一条机器指令对应着一个微程序

分清控制器，运算器，存储器，总线之间的边界

### 5.4.1 概念

**微命令**：控制部件向执行部件发出的各种控制命令叫作微命令，它是构成控制序列的最小单位

**微操作**：执行器接受微命令后所进行的操作

**微指令**：把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令

- 操作控制字段，又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。
    - 某位为1，表明发微指令
    - 微指令发出的控制信号都是节拍电位信号，持续时间为一个CPU周期
    - 微命令信号还要引入时间控制
- 顺序控制字段，又称微地址码字段，用以控制产生下一条要执行的微指令地址。

**微程序**：一系列微指令的有序集合就是微程序

- 一段微程序对应一条机器指令。
- 微地址 ：存放微指令的控制存储器的单元地址

<img src="http://image.trouvaille0198.top/image-20210313202842553.png" alt="image-20210313202842553" style="zoom:67%;" />

### 5.4.2 微程序控制原理

![image-20210313203405485](http://image.trouvaille0198.top/image-20210313203405485.png)

#### 1）控制存储器 (μCM)

这是微程序控制器的核心部件，用来存放微程序。其性能 (包括容量、速度、可靠性等) 与计算机的性能密切相关

机器运行时只读不写，工作时，读取一条微指令并运行，以此往复

#### 2）微指令寄存器 (μIR)

用来存放从 μCM 取出的正在执行的微指令

#### 3）地址转移逻辑

用来产生初始微地址和后继微地址，以保证微指令的连续执行

#### 4）微地址寄存器 (μMAR) 

它接受微地址形成部件送来的微地址，为下一步从μCM中读取微指令作准备。

### 5.4.3 微指令格式

- 水平型微指令：一次能定义并执行多个并行操作微命令的微指令
- 垂直型微指令：微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能

# 六、总线系统

## 6.1 总线的概念和结构形态

### 6.1.1 总线的基本概念

- 定义

    计算机的若干功能部件之间不可能采用全互联形式，因此就需要有**公共的信息通道**，即总线

- 分类

    - 内部总线：CPU 内部连接各寄存器及运算器部件之间的总线。
    - 系统总线：外部总线。CPU 和计算机系统中其他高速功能部件相互连接的总线。
    - I/O 总线：中低速 I/O 设备相互连接的总线

- 特性
    - 物理特性：物理连接方式
    - 功能特性：64 位 blabla
    - 电气特性：信号传递方向，有效电平范围
    - 时间特性：每根总线在什么时间有效
- 标准化
    - 总线标准，如 PCI、ISA 等
    - 简化系统设计
    - 简化系统结构，提高系统可靠性
    - 便于系统的扩充和更新
- **总线带宽**（重要）
  
    - 总线本身所能达到的最高传输速率，单位 MB/s          
    - 一次操作可以传输的数据位数
    - 如 S100 为 8 位，ISA 为 16 位，EISA 为 32 位，PCI-2 可达 64 位。
    - 总线宽度不会超过微处理器外部数据总线的宽度。

<img src="http://image.trouvaille0198.top/image-20210506141625030.png" alt="image-20210506141625030" style="zoom: 50%;" />

### 6.1.2 总线的连接方式

**适配器（接口）**：实现高速 CPU 与低速外设之间工作速度上的匹配和同步，并完成计算机和外设之间的所有数据传送和控制。

#### 1）单总线

使用一条单一的系统总线来连接 CPU、内存和 I/O 设备

- 结构特点

    在单总线结构中，要求连接到总线上的逻辑部件必须高速运行，以便在某些设备需要使用总线时，能迅速获得总线控制权

    而当不再使用总线时，能迅速放弃总线控制权。否则，由于一条总线由多种功能部件共用，可能导致很大的时间延迟

<img src="http://image.trouvaille0198.top/image-20210506142005749.png" alt="image-20210506142005749" style="zoom:50%;" />

#### 2）多总线

在 CPU、主存、I/O之间互联采用多条总线

高速的 CPU 总线：CPU 和 cache 之间采用

系统总线：主存连在其上

高速总线上可以连接高速 LAN（100Mb/s局域网）、视频接口、图形接口、SCSI 接口（支持本地磁盘驱动器和其他外设）、Firewire接口（支持大容量I/O设备）。高速总线通过扩充总线接口与扩充总线相连，扩充总线上可以连接串行方式工作的I/O设备。

通过桥 CPU 总线、系统总线和高速总线彼此相连。桥实质上是一种具有缓冲、转换、控制功能的逻辑电路。

多总线结构体现了高速、中速、低速设备连接到不同的总线上同时进行工作，以提高总线的效率和吞吐量，而且处理器结构的变化不影响高速总线。

<img src="http://image.trouvaille0198.top/image-20210506142019020.png" alt="image-20210506142019020" style="zoom: 67%;" />

### 6.1.3 总线的内部结构

地址线单向，数据线双向

#### 1）早期总线结构的不足之处

- CPU 是总线上惟一的主控者。即使后来增加了具有简单仲裁逻辑的 DMA 控制器以支持 DMA 传送，但仍不能满足多 CPU 环境的要求。

- 总线信号是 CPU 引脚信号的延伸，故总线结构紧密与 CPU 相关，通用性较差。

<img src="http://image.trouvaille0198.top/image-20210506142151011.png" alt="image-20210506142151011" style="zoom: 50%;" />



#### 2）构成

- 数据传送总线：地址线、数据线、控制线
- 仲裁总线：总线请求线、总线授权线
- 中断和同步总线：中断请求线、中断认可线
- 公用线：CP线、电源线、地线、复位线等

<img src="http://image.trouvaille0198.top/image-20210506142241452.png" alt="image-20210506142241452" style="zoom: 50%;" />

## 6.2 总线接口

### 6.2.1 信息传送方式

- 串行（先低后高）

- 并行

- 分时（复用：既传地址又传数据）

<img src="http://image.trouvaille0198.top/image-20210513124344949.png" alt="image-20210513124344949" style="zoom:50%;" />

#### 1）串行

使用一条传输线，采用脉冲传送。

低位在前，高位在后

主要优点是只需要一条传输线，这一点对长距离传输显得特别重要，不管传送的数据量有多少，只需要一条传输线，成本比较低廉。

缺点就是速度慢

#### 2）并行

每一数据位需要一条传输线，一般采用电位传送

#### 3）分时

总线复用或是共享总线的部件分时使用总线

####  4）拆卸和装配

拆卸：并的数据拆成一位位

装配：一位位传数据组装起来

### 6.2.2 总线接口的基本概念

接口是 CPU 和主存、外设之间通过总线进行连接的逻辑部件

<img src="http://image.trouvaille0198.top/image-20210513125100337.png" alt="image-20210513125100337" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210513125427604.png" alt="image-20210513125427604" style="zoom: 55%;" />

#### 1）接口功能

控制、缓冲、状态、转换（串并）、整理、程序中断

#### 2）分类

串行数据接口、并行数据接口

系统总线接口、外部设备接口

#### 3）例

波特率：每秒传送 bit 位数，一般用于串行

<img src="http://image.trouvaille0198.top/image-20210513125208881.png" alt="image-20210513125208881" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210513125216516.png" alt="image-20210513125216516" style="zoom:50%;" />



## 6.3 总线的仲裁

一次总线操作：一主多从。多个 CPU 和 IO 模块竞争控制权，产生仲裁

为了解决多个功能模块争用总线的问题，必须设置总线仲裁部件

### 6.3.1 集中式仲裁

总线请求信号线 BR，总线授权/响应信号线 BG，busy 标志 BS

<img src="http://image.trouvaille0198.top/image-20210513133116213.png" alt="image-20210513133116213" style="zoom: 67%;" />

#### 1）链式查询方式

越近的优先级越高

- 优点
    - 线少
    - 易扩充
- 缺点
    - 是对询问链的电路故障很敏感
    - 优先级固定

#### 2）计数器定时查询方式

查询时，计数器开始计数，直到计数值与设备地址匹配	

计数器从 0 开始同菊花链，从中止点开始优先级相等

- 特点
    - 灵活

#### 3）独立请求方式

n 条 BR 和 n 条 BG，排队电路根据优先次序决定响应

- 特点
    - 速度快

### 6.3.2 分布式仲裁

每个主方都有仲裁号和仲裁器。仲裁总线上号最大的胜出，否则自动撤出。

<img src="http://image.trouvaille0198.top/image-20210513133136487.png" alt="image-20210513133136487" style="zoom: 67%;" />

<img src="http://image.trouvaille0198.top/image-20210513135700067.png" alt="image-20210513135700067" style="zoom: 33%;" />

<img src="http://image.trouvaille0198.top/image-20210513135713515.png" alt="image-20210513135713515" style="zoom: 50%;" />

## 6.4 总线的定时和数据传送模式

**总线传输信息步骤**：请求总线、总线仲裁、寻址、信息传送、状态返回

### 6.4.1 总线定时

#### 1）同步定时

事件出现由总线时钟信号确定。适用于总线长度短、存取时间相近的情况

<img src="http://image.trouvaille0198.top/image-20210513140649774.png" alt="image-20210513140649774" style="zoom:50%;" />

#### 2）异步定时

允许将快速和慢速的设备都连一起。不需要时钟信号，应答式。周期长度可变，但总线复杂成本高。

<img src="http://image.trouvaille0198.top/image-20210513140729820.png" alt="image-20210513140729820" style="zoom:50%;" />

### 6.4.2 总线数据传送模式

- 读、写操作：读操作两次竞争总线。
- 块传送操作：猝发式传送，连续读（写）四倍字长。
- 写后读、读修改写操作：用于校验和保护共享资源。
- 广播、广集操作：广播多从进行写操作；广集多从读进行逻辑与或检测中断。

# 七、外围设备

外围设备的功能是在计算机和其他机器之间，以及计算机与用户之间提供联系

## 7.1 外围设备概述

<img src="http://image.trouvaille0198.top/image-20210520121906110.png" alt="image-20210520121906110" style="zoom:50%;" />

**基本组成**：存储介质，驱动装置，控制电路

分类：输入设备、输出设备、外存设备、数据通信设备、过程控制设备

CPU主存 —> IO —> 外围设备控制器 —> 外围设备

外围设备在设备控制器下工作，而设备控制器通过IO接口与主机连接

## 7.2 磁盘存储设备（磁盘、磁带）

**优点**：存储容量大，位价格低；记录介质可以重复使用；记录信息长久保存不丢失，可以脱机；非破坏性读出。

**缺点**：存取速度慢，机械结构复杂，对工作环境要求高

### 7.2.1 概念

记录面：盘片上下两面

磁道：记录面上同心圆（外 0 里 n）

扇区：记录一段定长信息，直接寻址的最小单位

<img src="http://image.trouvaille0198.top/image-20210520121839761.png" alt="image-20210520121839761" style="zoom:50%;" />

### 7.2.2 技术指标

存储密度

- **道密度**：半径方向上单位长度磁道数（道/英寸）
- **位密度**：磁道单位长度上能记录的二进制位数（位/英寸）（一个磁道存储的二进制位数/此磁道的周长）
- **面密度**：位密度*道密度（位/英寸²）

存储容量：一个磁盘存储器所能存储的字节总数

- 格式化容量 < 非格式化容量

**平均存取时间**

- 发出读写命令后，磁头从某一起始位置移动至新的记录位置，到开始从盘片表面读出或写入信息加上传送数据所需要的时间

- 找道时间 ：磁头定位到磁道上的时间（磁头动）
- 等待时间：找扇区所需的时间（磁头等，盘片转）
- 数据传送时间
    - $T_a=T_s+1/2r+b/rN$ 
    - r 为转速，b 为传送字节数，N 为每道字节数

数据传输率： $Dr=nN=D位⋅v线$

- 磁盘旋转速度为 n 转/秒，每条磁道容量为 N 个字节

<img src="http://image.trouvaille0198.top/image-20210520123155334.png" alt="image-20210520123155334" style="zoom: 33%;" />

<img src="http://image.trouvaille0198.top/image-20210520123225079.png" alt="image-20210520123225079" style="zoom:50%;" />

## 7.6 显示设备

显示设备：以可见光的形式传递和处理信息的设备

分辨率：显示器能表示的像素个数，水平 × 垂直

灰度级：黑白显示器中所显示的像素点的亮暗差别

刷新：为了使人眼看到稳定的图像显示，电子束重复扫描屏幕的过程。

刷新存储器（视频存储器）容量：M = rC

- C=log2 灰度级数 记得转化为 B

提高刷存的方式：使用高速 DRAM，多体交叉，提升总线宽度，端口分离。

# 八、输入输出系统

主机与外设的传输原理

输入：外设送到主机

输出：主机送到外设

## 8.1 外围设备的定时方式和信息交换方式

### 8.1.1 外围设备的速度分级

外设种类繁多，存在以下几种情况：

- 不同种类的外设数据传输速率差别很大

- 同一种设备在不同时刻传输速率也可能不同

高速的 CPU 与速度参差不齐的外设怎样在时间上同步呢？

- 解决办法时在 CPU 和外设之间数据传送时加以定时。

外设的分级

- 速度极慢或简单的外设
    - 机械开关、显示二极管
    - CPU 只需要接受或者发送数据即可

- 慢速或者中速的设备
    - 可以采用异步定时的方式

- 高速外设
    - 采用同步定时方式，成组数据传输

### 8.1.2 信息交换方式

<img src="http://image.trouvaille0198.top/image-20210603134735262.png" alt="image-20210603134735262" style="zoom:50%;" />

- **程序查询方式**

    CPU 保持对外设的监听状态

- **程序中断方式**

    外设传送数据时向 CPU 汇报

- **DMA 方式**（直接内存访问）

    外设传送成组的数据，不需要向 CPU 汇报；传输完成后再汇报，将总线控制权还给 CPU

- **通道方式**

    使用专门的 I/O 处理器来协助 CPU 工作

<img src="http://image.trouvaille0198.top/image-20210429122346870.png" alt="image-20210429122346870" style="zoom:50%;" />

## 8.2 程序查询方式

又叫程序控制 I/O 方式

### 8.2.1 步骤

1. 先向 I/O 设备发出命令字，请求进行数据传送
2. 从 I/O 接口读入状态字
3. 检查状态字中的标志，看看数据交换是否可以进行
4. （等）假如这个设备没有准备就绪，则第 (2)、第 (3) 步重复进行，一直到这个设备准备好交换数据，发出准备就绪信号 “Ready” 为止

5. CPU 从 I/O 接口的数据缓冲寄存器输入数据，或者将数据从 CPU 输出至接口的数据缓冲寄存器。与此同时， CPU 将接口中的状态标志复位

<img src="http://image.trouvaille0198.top/image-20210429124731884.png" alt="image-20210429124731884" style="zoom: 80%;" />

轮询

### 8.2.2 设备编址

#### 1）统一编址

I/O 设备与内存单元联合在一起编排地址

不需要专门的 I/O 指令组

#### 2）单独编址

I/O 设备地址与内存地址单独分开

I/O 设备要有专门的指令组

![image-20210429124203454](http://image.trouvaille0198.top/image-20210429124203454.png)



### 8.2.3 程序查询接口

- **设备选择电路**

    根据设备地址码选择外设

- **数据缓冲寄存器**

    缓冲数据

- **设备状态标志**

    标志设备的工作状态

## 8.3 程序中断方式

### 8.3.1 中断的基本概念

中断（Interrupt）是指 CPU 暂时中止现行程序，转去处理**随机**发生的紧急事件，处理完后自动返回原程序的功能和技术。

中断系统是计机实现中断功能的软硬件总称。

一般在 CPU 中设置中断机构，在外设接口中设置中断控制器，在软件上设置相应的中断服务程序

<img src="http://image.trouvaille0198.top/image-20210429125052957.png" alt="image-20210429125052957" style="zoom:80%;" />

中断处理过程注意几个问题：

- **响应中断时机：**外界中断请求是**随机**的，但 CPU 只有在当前指令执行完毕后，才转至公操作 

- **断点保护问题**（PC，寄存器内容和状态的保存） 

- **原子操作**：开中断和关中断问题。 
    - 将中断屏蔽触发器置为 1，即关闭中断，不接收中断请求

- 中断是由**软硬件结合**起来实现的

- 中断分为**内中断**（**异常**）和**外中断**

![image-20210429125147275](http://image.trouvaille0198.top/image-20210429125147275.png)

### 8.3.2 程序中断方式的基本I/O接口

<img src="http://image.trouvaille0198.top/image-20210429125243845.png" alt="image-20210429125243845" style="zoom: 80%;" />

① 表示由程序启动外设，将该外设接口的**“忙”标志 BS** 置 “1”，**“准备就绪”标志 RD** 清 “0”；

② 表示接口向外设发出启动信号；

③ 表示数据由外设传送到接口的缓冲寄存器；

④ 表示当设备动作结束或缓冲寄存器数据填满时，设备向接口送出一控制信号，将数据“准备就绪”标志 RD 置 “1”；

⑤ 表示**允许中断标志 EI** 为 “1” 时，接口向 CPU 发出中断请求信号；

⑥ 表示在一条指令执行末尾 CPU 检查中断请求线，将中断请求线的请求信号接收到**“中断请求”标志 IR**；

⑦ 表示如果**“中断屏蔽”标志 IM** 为 “0” 时，CPU 在一条指令执行结束后受理外设的中断请求，向外设发出响应中断信号并关闭中断；

⑧ 表示转向该设备的中断服务程序入口；

⑨ 表示在中断服务程序通过输入指令把接口中数据缓冲寄存器的数据读至 CPU 中的寄存器；

⑩ 表示 CPU 发出控制信号 C 将接口中的 BS 和 RD 标志复位

### 8.3.3 单级中断

有优先级，但不能嵌套

<img src="http://image.trouvaille0198.top/image-20210429134300322.png" alt="image-20210429134300322" style="zoom: 67%;" />

- 概念
    - 所有中断源属于同一级，离 CPU 越近，优先级越高。

- 中断源的识别：**串行排队链法**
    - IR1，IR2，IR3 为中断请求信号
    - IS1，IS2，IS3 为中断选中信号
    - INTI 为中断排队输入
    - INTO 为中断排队输出
    - INTA？
    
- 中断向量的产生
    - 当 CPU 响应中断时，由硬件直接产生一个固定的地址 (即向量地址)
    - 由向量地址指出每个中断源设备的中断服务程序入口，便于跳转，这种方法通常称为向量中断。

<img src="http://image.trouvaille0198.top/image-20210429134351160.png" alt="image-20210429134351160" style="zoom:80%;" />

（好图，看 👆）

### 8.3.4 多级中断（重要）

#### 1）概念

- 每级有一个中断优先权

- 一维多级中断和二维多级中断

- 说明：
    - 一个系统有 n 级中断，则 CPU 中有 n 个 IR，n 个 IM
        - 某级中断被响应后，则关闭本级和低于本级的 IM，开放更高级的 IM。
    - 多级中断可以嵌套，但同一级的中断不允许嵌套
    - 中断响应时，确定哪一级中断和中断源采用硬件实现。采用了独立请求方式和链式查询方式相结合的方式。
    - 使用多级堆栈保存现场（包括 IM）
    - 中断屏蔽触发器合在一起，组成了中断屏蔽寄存器

![image-20210429135903783](http://image.trouvaille0198.top/image-20210429135903783.png)

#### 2）多级中断源的识别

- 中断优先排队电路

- 中断向量产生电路

![image-20210429135954200](http://image.trouvaille0198.top/image-20210429135954200.png)

#### 3）例

<img src="http://image.trouvaille0198.top/image-20210429141825471.png" alt="image-20210429141825471" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210429141806985.png" alt="image-20210429141806985" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210506125301122.png" alt="image-20210506125301122" style="zoom:150%;" />

==分析==

- 中断**处理**次序 / 优先级：在软件（中段处理程序）中设置
- 中断**响应**优先级：在硬件中设置

### 8.3.5 中断控制器（了解）

#### 1）定义

![image-20210506130856935](http://image.trouvaille0198.top/image-20210506130856935.png)

**8259 中断控制器**是一个集成电路芯片，它将中断接口与优先级判断等功能汇集于一身，常用于微型机系统

- 8 位中断请求寄存器 (IR) 接受 8 个外部设备送来的中断请求，每一位对应一个设备。

- 中断请求寄存器的各位送入优先权判断器，根据中断屏蔽寄存器 (IM) 各位的状态来决定最高优先级的中断请求，并将各位的状态送入中断状态寄存器 IS。IS 保存着判优结果。由控制逻辑向 CPU 发出中断请求信号 INT，并接受 CPU 的中断响应信号 INTA。

- 数据缓冲器用于保存CPU内部总线与系统数据总线之间进行传送的数据。

- 读/写逻辑决定数据传送的方向，其中 IOR 为读控制，IOW 为写控制，CS 为设备选择，A0 为 I/O 端口识别。

#### 2）优先级选择方式

1. 完全嵌套方式

    是一种固定优先级方式，连至IR0的设备优先级最高，IR7的优先级最低。这种固定优先级方式对级别低的中断不利，在有些情况下最低级别的中断请求可能一直不能被处理。

2. 轮换优先级方式 A

    每个级别的中断保证有机会被处理，将给定的中断级别处理完后，立即把它放到最低级别的位置上去。

3. 轮换优先级方式 B

    要求CPU可在任何时间规定最优优先级，然后顺序地规定其他IR线上的优先级。

4. 查询方式

    由CPU访问8259的中断状态寄存器，一个状态字能表示出正在请求中断的最高优先级IR线，并能表示出中断请求是否有效。

## 8.4 DMA 方式

高速外设，同步定时，以数据块为单位进行批量传输

### 8.4.1 基本概念

**直接存储器访问（Direct Memory Address）**是为了在主存储器与 I/O 设备间高速交换批量数据而设置的。

- 基本思想

    通过硬件控制实现主存与 I/O 设备间的直接数据传送，在**传送过程中**无需 CPU 的干预。数据传送是在 **DMA 控制器**控制下进行的

- 优点

    速度快，有利于发挥 CPU 的效率。

### 8.4.2 DMA 传送方式

<img src="http://image.trouvaille0198.top/image-20210506131519994.png" alt="image-20210506131519994" style="zoom:67%;" />

#### 1）停止 CPU 访问内存

（在 DMA 访内过程中，CPU 不能同时访内）

主机响应 DMA 请求后，让出存储总线，直到一组数据传送完毕后，DMA 控制器才把总线控制权交还给 CPU

采用这种工作方式的 I/O 设备，在其接口中一般设置有小容量存储器

I/O 设备先与小容量存储器交换数据，然后由小容量存储器与主机交换数据

这样可减少 DMA 传送占用存储总线的时间，也即减少了 CPU 暂停工作的时间

- 优点

    控制简单，它适用于数据传输率很高的设备进行成组传送。

- 缺点

    在 DMA 控制器访内阶段，内存的效能没有充分发挥，相当一部分内存工作周期是空闲的。这是因为，外围设备传送两个数据之间的间隔一般总是大于内存存储周期，即使高速 I/O 设备也是如此（故许多空闲的存储周期不能被 CPU 利用）

#### 2）周期挪用方式

也叫周期窃取方式，CPU 没有完全放弃对主存的访问

DMA 控制器与主存储器之间传送一个数据，占用（窃取）一个 CPU 周期，即 CPU 暂停工作一个周期，然后继续执行程序

一次 DMA 传输（挪用）没办法将整个数据块传输完

#### 3）DMA 与 CPU 交替访内

又称透明的 DMA 传输方式

如果 CPU 的工作周期比内存存取周期长很多，可以采用该种方法

总线控制权的转移速度快，DMA 效率高。

### 8.4.3 基本的 DMA 原理

#### 1）DMA 基本构成

![image-20210506132122468](http://image.trouvaille0198.top/image-20210506132122468.png)

1. **内存地址计数器** 

    用于**存放内存中要交换的数据的地址**

    在DMA传送前，须通过程序将数据在内存中的起始位置(首地址)送到内存地址计数器。

    而当DMA传送时，每交换一次数据，将地址计数器加“1”，从而以增量方式给出内存中要交换的一批数据的地址。

2. **字计数器**

    用于**记录传送数据块的长度**(多少字数)。其内容也是在数据传送之前由程序预置，交换的字数通常以补码形式表示。

    在 DMA 传送时，每传送一个字，字计数器就加“1” ，

    当计数器溢出即最高位产生进位时，表示这批数据传送完毕，于是引起DMA控制器向CPU发中断信号

3. **数据缓冲寄存器**

    用于**暂存每次传送的数据**(一个字)。

    当输入时，由设备(如磁盘)送往数据缓冲寄存器，再由缓冲寄存器通过数据总线送到内存。

    反之，输出时，由内存通过数据总线送到数据缓冲寄存器，然后再送到设备。

4. **“DMA 请求” 标志** 

    每当设备准备好一个数据字后给出一个控制信号，使 “DMA 请求” 标志置 “1”。

    该标志置位后向“控制/状态”逻辑发出DMA请求，后者又向CPU发出总线使用权的请求(HOLD)，CPU 响应此请求后发回响应信号HLDA，“控制/状态”逻辑接收此信号后发出DMA响应信号，使“DMA请求”标志复位，为交换下一个字做好准备。

5. **“控制/状态” 逻辑**

    由控制和时序电路以及状态标志等组成，用于修改内存地址计数器和字计数器，指定传送类型(输入或输出)，并对 “DMA 请求” 信号和 CPU 响应信号进行协调和同步。

6. **中断机构**

    当字计数器溢出时 (全 0)，意味着一组数据交换完毕，由溢出信号触发中断机构，**向 CPU 提出中断报告**

    这里的中断与上一节介绍的 I/O 中断所采用的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一组数据传送结束。因此它们是 I/O 系统中不同的中断事件

#### 2）DMA 数据传送过程

![](http://image.trouvaille0198.top/123.png)

当外设有 DMA 请求时，通常 CPU 在本机器周期结束后，响应 DMA 请求

<img src="http://image.trouvaille0198.top/image-20210506134807469.png" alt="image-20210506134807469" style="zoom:67%;" />

### 8.4.4 选择型和多路型 DMA 控制器

#### 1）选择型

一段时间内只能为一个设备服务

![image-20210506134954053](http://image.trouvaille0198.top/image-20210506134954053.png)

#### 2）多路型

![image-20210506135017211](http://image.trouvaille0198.top/image-20210506135017211.png)

**例** 下图中假设有磁盘、磁带、打印机三个设备同时工作。磁盘以 30μs 的间隔向控制器发 DMA 请求，磁带以 45μs 的间隔发 DMA 请求，打印机以 150μs 间隔发 DMA 请求。根据传输速率，磁盘优先权最高，磁带次之，打印机最低，图中假设DMA控制器每完成一次 DMA 传送所需的时间是 5μs。若采用多路型 DMA 控制器，请画出 DMA 控制器服务三个设备的工作时间图。

<img src="http://image.trouvaille0198.top/image-20210506140937308.png" alt="image-20210506140937308" style="zoom: 67%;" /> 

