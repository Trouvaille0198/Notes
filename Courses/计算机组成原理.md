# 一、概论

## 1.1 分类

- 数字计算机
  - 专用计算机
  - 通用计算机
- 模拟计算机

## 1.2 发展简史

### 1.2.1 五代变化

1. 电子管计算机（1946—1957年）：数据处理
2. 晶体管计算机（1958—1964年）：工业控制
3. 中小规模集成电路计算机（1965—1971年）：小型计算机
4. 大规模和超大规模集成电路计算机（1972—1990年）：微型计算机
5. 巨大规模集成电路计算机（1991年开始）：单片机

### 1.2.2 性能指标

1. 吞吐量

   表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S）。

2. 响应时间

   表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（10-6S）、纳秒（10-9S）。

3. 利用率

   给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。

4. 处理机字长

   指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。字长越长，表示计算的精度越高

5. 总线宽度

   CPU中运算器与存储器之间进行互连的内部总线二进制位数。

6. 存储器容量

   存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。

7. 存储器带宽

   存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。

8. 主频/时钟周期

   CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz（兆赫兹）、GHz（吉赫兹）。例如Pentium系列机为60MHz～266MHz，而Pentium 4升至3.6GHz。

9. CPU时钟周期（T）

   主频的倒数，即T=1/f，度量单位是微秒、纳秒。

10. CPU执行时间

    CPU执行一段程序所占用的CPU时间。CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周长

11. CPI

    每条指令周期数，即执行一条指令所需的平均时钟周期数。 CPI ＝ 执行程序所需的CPU时钟周期数/该程序包含的指令条数

12. MIPS

    每秒百万条指令数。MIPS = 指令条数/程序执行时间Te × 10的6次方 = 时钟频率/CPI × 10的6次方。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。

13. MFLOPS

    每秒百万次浮点操作次数。MFLOPS = 程序中的浮点操作数/程序执行时间Te × 10的6次方。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。

14. TFLOPS

    每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。

## 1.3 硬件

- 控制器：人的大脑的操作控制功能
- 运算器：人的大脑的计算功能
- 存储器：人的大脑记忆功能
- 输入设备：交互接口，笔
- 输出设备：交互接口，纸

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201201091549465.png" alt="image-20201201091549465" style="zoom:67%;" />

### 1.3.1 运算器

- 算术运算和逻辑运算

- 在计算机中参与运算的数是二进制的

- 运算器的长度一般是8、16、32或64位

### 1.3.2 存储器

- 存储数据和程序（指令）

- 容量（存储单元、存储单元地址、容量单位）

- 分类内存（ROM、RAM）、外存

- 存储器单位：
  ​	$1KB ＝ 2^{10}B \\ 1MB ＝ 2^{20}B \\ 1GB ＝ 2^{30}B \\ 1TB ＝ 2^{40}B $

### 1.3.3 控制器

- 指令和程序：指令的形式（操作和地址码、存储程序的概念、指令中程序和数据的存放、指令系统）

- 指令和数据存储
- 控制器的基本任务：按照一定的顺序一条接着一条取指令、指令译码、执行指令。取指周期和执行周期

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201201092140398.png" alt="image-20201201092140398" style="zoom:67%;" />

### 1.3.4 适配器与I/O设备

- 输入设备：把人们所熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式

- 输出设备：把计算机处理的结果变换为人或其他机器设备所能接收和识别的信息形式

- 适配器：它使得被连接的外围设备通过系统总线与主机进行联系，以便使主机和外围设备并行协调地工作

- 总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路

![image-20210219153820024](http://image.trouvaille0198.top/image-20210219153820024.png)

## 1.4 软件

### 1.4.1 分类

- 系统软件
  - 各种服务性程序，如诊断程序、排错程序、练习程序等
  - 语言程序，如汇编程序、编译程序、解释程序等
  - 操作系统
  - 数据库管理系统
- 应用软件

### 1.4.2 发展演变

- 编程语言的发展
  - 手编程序：机器语言程序，手工编译二进制码
  - 汇编程序：符号语言程序，汇编程序汇编
  - 高级程序：算法语言/高级语言，机器编译程序/解释程序

- 系统软件的发展
  - 手编程序：机器语言程序，手工编译二进制码
  - 汇编程序：符号语言程序，汇编程序汇编
  - 高级程序：算法语言/高级语言，机器编译程序/解释程序

## 1.5 多级计算机系统

- 微程序设计级，这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。

- 一般机器级，也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。

- 操作系统级，它由操作系统程序实现。这些操作系统由机器指令和广义指令组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。

- 汇编语言级，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。

- 高级语言级，它是面向用户的，为方便用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行

  ![image-20201201102315894](https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201201102315894.png)

# 二、运算方法和运算器

![QQ图片20210224195322](http://image.trouvaille0198.top/QQ%E5%9B%BE%E7%89%8720210224195322.jpg)

## 2.1 定点加法、减法运算

### 2.1.1 补码加法

$$
[x+y]_补=[x]_补+[y]_补
$$

**符号位运算丢进位**

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208081840627.png" alt="image-20201208081840627" style="zoom: 50%;" />

### 2.1.2 补码减法

减法变成加法来做

-y 的补码 = y的补码所有位取反 +1
$$
[x]_补 - [y]_补 = [x]_补 + [-y]_补 \\ [-y]_补 = -[y]补 + 2^{-n} （弱智方法，直接求-y的补码即可）
$$

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208081922975.png" alt="image-20201208081922975" style="zoom:60%;" />

### 2.1.3 溢出

#### 1）概念

可能产生溢出的情况 

- 两正数加，变负数，正溢（大于机器所能表示的最大数）

- 两负数加，变正数，负溢（小于机器所能表示的最小数） 
   <img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208082100759.png" alt="image-20201208082100759" style="zoom:67%;" />
   <img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208082115380.png" alt="image-20201208082115380" style="zoom:45%;" />

<img src="http://image.trouvaille0198.top/image-20210311163220227.png" alt="image-20210311163220227" style="zoom:67%;" />

#### 2）检测方法

1. 双符号位法（变形补码） 

   00为正，11为负，有下表

| $S_{f1}$ | $S_{f2}$ | 判断 |
| -------- | -------- | ---- |
| 0        | 0        | 正数 |
| 0        | 1        | 正溢 |
| 1        | 0        | 负溢 |
| 1        | 1        | 负数 |

​	$S_{f1},S_{f2}$为结果的双符号，关系为异或

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208084831460.png" alt="image-20201208084831460" style="zoom:50%;" />

2. 单符号位法

| $C_f$ | $C_0$ | 判断 |
| ----- | ----- | ---- |
| 0     | 0     | 正数 |
| 0     | 1     | 正溢 |
| 1     | 0     | 负溢 |
| 1     | 1     | 负数 |

​	其中$C_f$为符号位产生的进位，$C_0$为最高有效位产生

## 2.2 定点乘法、除法运算

### 2.2.1 原码并行乘法

1. 一般都用原码算

2. 用绝对值算，且计算时不带符号位

3. 原码阵列，结果是原码；补码阵列，结果变为补码

#### 1）不带符号位的阵列乘法器

<img src="http://image.trouvaille0198.top/image-20210311183721399.png" alt="image-20210311183721399" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210311183651284.png" alt="image-20210311183651284" style="zoom: 50%;" />

#### 2）带符号的阵列乘法器

<img src="http://image.trouvaille0198.top/image-20210311183820062.png" alt="image-20210311183820062" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210311183840700.png" alt="image-20210311183840700" style="zoom:50%;" />

### 2.2.2 定点除法

一般都用补码算

- 人工除法时，人可以比较被除数（余数）和除数的大小来确定商1（够减）或商0（不够减）

- 机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下运算。这种方法叫恢复余数法，控制比较复杂。

- 不恢复余数法（**加减交替法**）
    - 余数为正，商1，下次除数右移做减法；
    - 余数为负，商0，下次除数右移做加法。
    - 控制简单，有规律

#### 1）手工方案

<img src="http://image.trouvaille0198.top/image-20210311183959476.png" alt="image-20210311183959476" style="zoom:50%;" />

#### 2）不恢复余数法

<img src="http://image.trouvaille0198.top/image-20210311184317034.png" alt="image-20210311184317034" style="zoom: 50%;" />

## 2.3 浮点加法，减法运算

### 2.3.1 运算步骤 

1. 0 操作数检查；
2. 比较阶码并完成对阶（小阶向大阶对齐）；
3. 尾数加减运算；
4. 结果规格化；（尾数右移一位，阶码加一）
5. 舍入处理   

### 2.3.2 要点

1. 用补码表示阶码和尾数

2. 加减后溢出不是真正的溢出，规格化后才是真正的溢出

### 2.3.3 例

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201215091355202.png" alt="image-20201215091355202" style="zoom: 67%;" />

<img src="https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201215091411948.png" alt="image-20201215091411948" style="zoom:50%;" />

### 2.3.3 舍入处理（对阶和向右规格化时）

- 就近舍入（0舍1入）：类似”四舍五入”，丢弃的最高位为1，进1
- 朝0舍入：截尾
- 朝$+\infty$舍入：正数多余位不全为”0”，进1；负数，截尾
- 朝$-\infty$舍入：负数多余位不全为”0”，进1；正数，截尾

### 2.3.4 溢出判断和处理

- 阶码上溢，一般将其认为是$+\infty$和$-\infty$ 。
- 阶码下溢，则数值为0

## 2.4 浮点乘法，除法运算
![image-20210312155130405](http://image.trouvaille0198.top/image-20210312155130405.png)
### 2.4.1 运算步骤

1. 操作数检查
2. 阶码加减操作
3. 尾数乘除操作
4. 结果规格化和舍入处理

## 2.5 IEEE754 标准

以32位为例

<img src="http://image.trouvaille0198.top/image-20210311104125763.png" alt="image-20210311104125763" style="zoom: 80%;" />
$$
x=(-1)^S\times(1.M)\times2^{E-127}
$$

- 基数 R=2，基数固定，采用隐含方式来表示它。

- S：数的符号位，1位，在最高位，“0”表示正数，“1”表示负数。

- M：尾数， 23位，在低位部分，采用纯小数表示。

- E：是阶码，8位，采用移码表示。移码比较大小方便。

- 尾数域最左位(最高有效位)总是1， 故这一位经常不予存储，而认为隐藏在小数点的左边。

- 采用这种方式时，将浮点数的指数真值 e 变成阶码 E 时，应将指数 e 加上一个固定的偏移值127(01111111)，即 ==E=e+127==。

<img src="http://image.trouvaille0198.top/image-20210309083106189.png" alt="image-20210309083106189" style="zoom: 45%;" />



<img src="http://image.trouvaille0198.top/image-20210311104414727.png" alt="image-20210311104414727" style="zoom: 40%;" />

## 2.6 机器码

<img src="http://image.trouvaille0198.top/image-20210311145151428.png" alt="image-20210311145151428" style="zoom:67%;" />

## 2.7 总线

机器内部各部份数据传送频繁,可以把寄存器间的数据传送通路加以归并,组成总线结构。

### 2.7.1 总线分类

- 所处位置
    - 内部总线（CPU内）
    - 外部总线（系统总线）
- 逻辑结构
    - 单向传送总线
    - 双向传送总线



### 2.7.2 定点运算器的组成

- 单总线结构的运算器

    - 在同一时间只能有一个操作数在总线上

    - 操作速度慢
    - 控制电路简单

- 双总线结构的运算器

    - 不能直接把输出加到总线

- 三总线结构的运算器

<img src="http://image.trouvaille0198.top/image-20210311190145600.png" alt="image-20210311190145600" style="zoom: 50%;" />

## 2.8 流水线

### 2.8.1 原理

<img src="http://image.trouvaille0198.top/image-20210312230044043.png" alt="image-20210312230044043" style="zoom: 67%;" />

<img src="http://image.trouvaille0198.top/image-20210312230030588.png" alt="image-20210312230030588" style="zoom:80%;" />

<img src="http://image.trouvaille0198.top/image-20210312230105914.png" alt="image-20210312230105914" style="zoom:80%;" />

# 三、存储器 （不考）

## 3.1 概述

### 3.1.1 分类

- 按存储介质分类：磁表面/半导体存储器

- 按存取方式分类：随机/顺序存取（磁带）

- 按读写功能分类：ROM，RAM
  - RAM：双极型/MOS
  - ROM：MROM/PROM/EPROM/EEPROM

- 按信息的可保存性分类：永久性和非永久性的

- 按存储器系统中的作用分类：主/辅/缓/控

### 3.1.2 分级

- **高速缓冲存储器**简称cache，它是计算机系统中的一个高速小容量半导体存储器。

- **主存储器**简称主存，是计算机系统的主要存储器，用来存放计算机运行期间的大量程序和数据。

- **外存储器**简称外存，它是大容量辅助存储器

![image-20201208081536803](https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201208081536803.png)

### 3.1.3 主存储器的技术指标

- 字存储单元

  存放一个机器字的存储单元，相应的单元地址叫字地址。

- 字节存储单元

  存放一个字节的单元，相应的地址称为字节地址。

- 存储容量

  指一个存储器中可以容纳的存储单元总数。存储容量越大，能存储的信息就越多。

- 存取时间又称存储器访问时间

  指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。通常取写操作时间等于读操作时间，故称为存储器存取时间。

- 存储周期

  指连续启动两次读操作所需间隔的最小时间。通常，存储周期略大于存取时间，其时间单位为ns。

- 存储器带宽

  单位时间里存储器所存取的信息量，通常以位/秒或字节/秒做度量单位

## 3.2 SRAM存储器

## 3.3 DRAM存储器

## 3.4 只读存储器和闪速存储器

## 3.5 并行存储器

## 3.6 Cache存储器

## 3.7 虚拟存储器

## 3.8 奔腾系列机的虚存组织

# 四、指令系统

## 4.1 指令系统的发展与性能要求

### 4.1.1 指令系统的发展

#### 1）分类

- 微指令：微程序级的命令，它属于硬件；

- 宏指令：由若干条机器指令组成的软件指令，它属于软件；

- 机器指令：介于微指令与宏指令之间，通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作

本章所讨论的指令，是机器指令

#### 2）发展情况

- 复杂指令系统计算机，简称 CISC。
    - 如此庞大的指令系统不但使计算机的研制周期变长，难以保证正确性，不易调试维护，而且由于采用了大量使用频率很低的复杂指令而造成硬件资源浪费。

- 精简指令系统计算机：简称 RISC
    - 人们提出了便于 VLSI 技术实现的精简指令系统计算机。

### 4.1.2 指令系统性能要求

- **完备性：**完备性是指用汇编语言编写各种程序时，指令系统直接提供的指令足够使用，而不必用软件来实现。

- **有效性：**有效性是指利用该指令系统所编写的程序能够高效率地运行。

- **规整性：**规整性包括指令系统的对称性、匀齐性、指令格式和数据格式的一致性。
    - 对称性是指：在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式
    - 匀齐性是指：一种操作性质的指令可以支持各种数据类型
    - 指令格式和数据格式的一致性是指：指令长度和数据长度有一定的关系，以方便处理和存取。
- **兼容性：**系列机各机种之间具有相同的基本结构和共同的基本指令集，因而指令系统是兼容的，即各机种上基本软件可以通用。

## 4.2 指令格式

![image-20210313140042554](http://image.trouvaille0198.top/image-20210313140042554.png)

### 4.2.1 操作码

指令的操作码OP表示该指令应进行什么性质的操作。不同的指令用操作码字段的不同编码来表示，每一种编码代表一种指令。

组成操作码字段的位数一般取决于计算机指令系统的规模

### 4.2.2 地址码

<img src="http://image.trouvaille0198.top/image-20210313140556330.png" alt="image-20210313140556330" style="zoom:80%;" />

#### 1）三地址指令

功能描述
- (A1) op (A2)→A3

这种格式虽然省去了一个地址，但指令长度仍比较长，所以只在字长较长的大、中型机中使用，而小型、微型机中很少使用

#### 2）二地址指令

- 功能描述
    - (A1) op (A2)→A1
- 说明
    - 二地址指令在计算机中得到了广泛的应用，
    - 注意：指令执行之后，A1 中原存的内容已经被新的运算结果替换了

- 二地址地址根据操作数的物理位置分为：
    - SS  存储器-存储器类型
    - RS  寄存器-存储器类型
    - RR  寄存器-寄存器类型

#### 3）一地址指令

- 功能描述
    - (AC) op (A1) → A1
- 说明
    - 单操作数运算指令，如“+1”、“-1”、“求反”
    - 指令中给出一个源操作数的地址
    - 另一个操作数地址是隐含的

#### 4）零地址指令

“停机”、“空操作”、“清除”等控制类指令

## 4.3 指令字长度

### 4.3.1 概念

- 指令字长度（一个指令字包含二进制代码的位数）

- 机器字长：计算机能直接处理的二进制数据的位数。
- 分类
    - 单字长指令：指令字长等于一个机器字长
    - 半字长指令：指令字长等于半个机器字长
    - 双字长指令：指令字长等于两个机器字长

### 4.3.2 理解

- **多字长指令**的优缺点

    - 优点：提供足够的地址位来解决访问内存任何单元的寻址问题 ；

    - 缺点：必须两次或多次访问内存以取出一整条指令，降低了 CPU 的运算速度，又占用了更多的存储空间

- **等长指令**

    - 各种指令字长度是相等的，指令字结构简单，且指令字长度是不变的 ；

- **非等长指令**

    - 各种指令字长度随指令功能而异，结构灵活，能充分利用指令长度，但指令的控制较复杂

 ### 4.3.3 指令助记符

- 用3～4个英文字母来表示操作码，一般为英文缩写
- 不同的计算机系统，规定不一样
- 必须用汇编语言翻译成二进制代码

### 4.3.4 指令格式举例

<img src="http://image.trouvaille0198.top/image-20210313153644062.png" alt="image-20210313153644062" style="zoom:67%;" />

## 4.4 指令和数据的寻址方式

### 4.4.1 指令的寻址方式

- 顺序寻址方式
    - PC + 1

- 跳跃寻址方式

<img src="C:\Users\Tyeah\AppData\Roaming\Typora\typora-user-images\image-20210313154155455.png" alt="image-20210313154155455" style="zoom:67%;" />

### 4.4.2 操作数基本寻址方式

形成操作数**有效地址**的方法，称为操作数的寻址方式

<img src="http://image.trouvaille0198.top/image-20210313154314344.png" alt="image-20210313154314344" style="zoom:67%;" />

形式地址 + 寻址方式特征位

- 形式地址 A , 也称偏移量， 它是指令字结构中给定的地址量。 

- 寻址方式特征位， 此处由间址位和变址位组成。 
- 如果这条指令无间址和变址的要求， 那么形式地址就是操作数的有效地址。 如果指令中指明要变址或间址变换， 那么形式地址就不是操作数的有效地址， 而要经过指定方式的变换， 才能形成有效地址。 因此， 寻址过程就是把操作数的形式地址， 变换为操作数的有效地址的过程

![image-20210313154636585](http://image.trouvaille0198.top/image-20210313154636585.png)

<img src="http://image.trouvaille0198.top/image-20210313154658369.png" alt="image-20210313154658369" style="zoom:80%;" />

#### 1）隐含寻址

指令中隐含着操作数的地址

如单地址指令的某些运算，隐含了累加器 AC 作为源和目的寄存器

#### 2）立即寻址

指令的地址字段不操作数地址，而是操作数本身

也就是不用寻址

指令格式：操作码 OP  操作数 A

#### 3）直接寻址

指令中地址码字段给出的地址 A 就是操作数的有效地址 EA (Effective Address)、

**EA＝A**

<img src="http://image.trouvaille0198.top/image-20210313160650656.png" alt="image-20210313160650656" style="zoom:67%;" />

#### 4）间接寻址

指令的地址码部分给出的地址 A 是操作数地址的地址

**EA＝(A)**

<img src="http://image.trouvaille0198.top/image-20210313160951264.png" alt="image-20210313160951264" style="zoom:67%;" />

#### 5）寄存器寻址

在指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中

**EA = R**

<img src="http://image.trouvaille0198.top/image-20210313162422634.png" alt="image-20210313162422634" style="zoom:67%;" />

优点

1. 由于寄存器在CPU的内部，指令在执行时从寄存器中取操作数比访问主存要快得多；

2. 由于寄存器的数量较少，因此寄存器编号所占位数也较少，从而可以有效减少指令的地址码字段的长度。

#### 6）寄存器间接寻址

为了克服间接寻址中多次访存的缺点，可采用寄存器间接寻址，即将操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，然后在指令的地址码部分给出该通用寄存器的编号

**EA = (R)**

<img src="http://image.trouvaille0198.top/image-20210313162559938.png" alt="image-20210313162559938" style="zoom:67%;" />

这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数，因此指令执行速度较前述的间接寻址方式要快，也是目前在计算机中使用较为广泛的一种寻址方式

#### 7）偏移寻址

偏移寻址要求指令中有两个地址字段，至少有一个是显示的

- 必定显示的形式地址 A （一般是一个偏移量 D）
- 一个隐含的引用（一般是一个专用寄存器）

**EA = A + (R)**

##### 1. 相对寻址

由程序计数器 PC 提供基准地址（隐含引用），而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址

**EA＝D + (PC)**

<img src="http://image.trouvaille0198.top/image-20210313163115499.png" alt="image-20210313163115499" style="zoom:67%;" />

##### 2. 基址寻址

专用寄存器是一个基址寄存器，可以显示可以隐式

基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址

**EA = D + (R)**

<img src="http://image.trouvaille0198.top/image-20210313163219858.png" alt="image-20210313163219858" style="zoom: 80%;" />

##### 3. 变址寻址

变址寻址就是将指令的地址码部分给出的基准地址 A 与变址寄存器 R 中的内容相加，以形成操作数的有效地址。

**EA = A + R**

<img src="http://image.trouvaille0198.top/image-20210313163842841.png" alt="image-20210313163842841" style="zoom: 80%;" />

#### 8）段寻址方式

存储空间划分为多段

<img src="http://image.trouvaille0198.top/image-20210313164024231.png" alt="image-20210313164024231" style="zoom:80%;" />

#### 9）堆栈寻址

以先进后出原理存储数据

### 4.4.3 寻址方式举例

<img src="http://image.trouvaille0198.top/image-20210313164917780.png" alt="image-20210313164917780" style="zoom: 80%;" />

![image-20210313164931546](http://image.trouvaille0198.top/image-20210313164931546.png)

![image-20210320150116083](http://image.trouvaille0198.top/image-20210320150116083.png)

![image-20210320145606857](http://image.trouvaille0198.top/image-20210320145606857.png)

# 五、中央处理器

## 5.1 CPU的功能和组成

### 5.1.1 CPU的功能

<img src="http://image.trouvaille0198.top/image-20210313170054923.png" alt="image-20210313170054923" style="zoom:80%;" />

指令控制（程序的顺序控制）

操作控制（一条指令有若干操作信号实现）

时间控制（指令各个操作实施时间的定时）

数据加工（算术运算和逻辑运算）

### 5.1.2 CPU的基本组成

![图片1](http://image.trouvaille0198.top/%E5%9B%BE%E7%89%871.png)

中央处理器 CPU = 运算器 + cache + 控制器 

#### 1）运算器

- ALU 
- 通用寄存器：R0～R3
- 暂存器：DR
- 状态字寄存器：PSW

#### 2）cache 

- 指令 cache：PC，IBUS

- 数据 cache：AR，DBUS

#### 3）控制器

- 程序计数器、指令寄存器、数据缓冲器、地址寄存器、通用寄存器、状态寄存器、时序发生器、指令译码器、总线（数据通路）
    - 程序计数器 PC (Programming Counter)
        - 用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址。
        - 顺序执行时，每执行一条指令，PC的值应加1
        - 要改变程序执行顺序的情况时，一般由转移类指令将转移目标地址送往 PC ，可实现程序的转移
    - 指令寄存器 IR (Instruction Register)  
        - 指令寄存器用来存放从存储器中取出的待执行的指令。
        - 在执行该指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能。

### 5.1.3 CPU 中的主要寄存器

数据缓冲寄存器(DR)

- 中转站

- 补偿速度差别

- 指令寄存器 (IR)

- 程序计数器 (PC)

- 数据地址寄存器 (AR)

- 通用寄存器 (R0～R3)

- 状态字寄存器 (PSW)

## 5.2 指令周期

### 5.2.1 指令周期的基本概念

**指令周期**：取出一条指令并执行这条指令的时间

**CPU 周期**：又称时钟周期或机器周期，用从内存中读取一个指令字的最短时间来规定 CPU 周期

​					换句话说，就是以主存的工作周期 (存取周期) 为基础来规定 CPU 周期

​					通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作

​					一个 CPU 周期中，包含若干个节拍脉冲（T 周期）

​					CPU 周期通常定义为机器主频的倒数

<img src="http://image.trouvaille0198.top/image-20210313173359110.png" alt="image-20210313173359110" style="zoom:80%;" />

### 5.2.2 MOV 指令的指令周期

两个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313173851190.png" alt="image-20210313173851190" style="zoom: 80%;" />

#### 1）取指周期

程序计数器PC中装入第一条指令地址101（八进制）；

PC的内容被放到指令地址总线ABUS（I）上，对指存进行译码，并启动读命令；

从101号地址读出的MOV指令通过指令总线IBUS装入指令寄存器IR；

程序计数器内容加1，变成102，为取下一条指令做好准备；

指令寄存器中的操作码（OP）被译码；

CPU识别出是MOV指令，至此，取指周期即告结束

<img src="http://image.trouvaille0198.top/image-20210313174137437.png" alt="image-20210313174137437" style="zoom: 80%;" />

#### 2）执行周期

操作控制器（OC）送出控制信号到通用寄存器，选择R1（10）作源寄存器，选择R0作目标寄存器；

OC送出控制信号到ALU，指定ALU做传送操作；

OC送出控制信号，打开ALU输出三态门，将ALU输出送到数据总线DBUS上。注意，任何时候DBUS上只能有一个数据。

OC送出控制信号，将DBUS上的数据打入到数据缓冲寄存器DR（10）；

OC送出控制信号，将DR中的数据10打入到目标寄存器R0，R0的内容由00变为10。至此，MOV指令执行结束。

<img src="http://image.trouvaille0198.top/image-20210313174237168.png" alt="image-20210313174237168" style="zoom:80%;" />

### 5.2.3 LAD 指令的指令周期

三个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313174621752.png" alt="image-20210313174621752"  />

#### 1）取指周期

与 MOV 指令一样，以下皆同

#### 2）执行周期

操作控制器OC发出控制命令打开IR输出三态门，将指令中的直接地址码6放到数据总线DBUS上；

OC发出操作命令，将地址码6装入数存地址寄存器AR；

OC发出读命令，将数存6号单元中的数100读出到DBUS上；

OC发出命令，将DBUS上的数据100装入缓冲寄存器DR；

OC发出命令，将DR中的数100装入通用寄存器R1，原来R1中的数10被冲掉。至此，LAD指令执行周期结束。

![image-20210313174907814](http://image.trouvaille0198.top/image-20210313174907814.png)

### 5.2.4 ADD 指令的指令周期

两个 CPU 周期

#### 1）执行周期

操作控制器OC送出控制命令到通用寄存器，选择R1做源寄存器，R2做目标寄存器；

OC送出控制命令到ALU，指定ALU做R1（100）和R2（20）的加法操作；

OC送出控制命令，打开ALU输出三态门，运算结果120放到DBUS上；

OC送出控制命令，将DBUS上数据打入缓冲寄存器DR；ALU产生的进位信号保存状态字寄存器在PSW中。

OC送出控制命令，将DR（120）装入R2，R2中原来的内容20被冲掉。至此ADD指令执行周期结束

<img src="http://image.trouvaille0198.top/image-20210313190818882.png" alt="image-20210313190818882" style="zoom:90%;" />

### 5.2.5 STO 指令的指令周期

三个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313191407824.png" alt="image-20210313191407824" style="zoom:80%;" />

#### 1）执行周期

注意：DBUS 为单总线结构，先送地址，后送数据

操作控制器OC送出操作命令到通用寄存器，选择（R3）=30做数据存储器的地址单元；

OC发出操作命令，打开通用寄存器输出三态门（不经ALU以节省时间），将地址30放到DBUS上；

OC发出操作命令，将地址30打入AR，并进行数存地址译码；

OC发出操作命令到通用寄存器，选择（R2）=120），作为数存的写入数据；

OC发出操作命令，打开通用寄存器输出三态门，将数据120放到DBUS上。

OC发出操作命令，将数据120写入数存30号单元，它原先的数据40被冲掉。至此，STO指令执行周期结束

<img src="http://image.trouvaille0198.top/image-20210313191508145.png" alt="image-20210313191508145" style="zoom:90%;" />

### 5.2.6 JMP 指令的指令周期

两个 CPU 周期

<img src="http://image.trouvaille0198.top/image-20210313191651516.png" alt="image-20210313191651516" style="zoom: 80%;" />

#### 1）执行周期

OC 发生操作控制命令，打开指令寄存器 IR 的输出三态门，将IR中的地址码 101 发送到DBUS上；

OC 发出操作控制命令，将 DBUS 上的地址码 101 打入到程序计数器 PC 中，PC中的原先内容 106 被更换。于是下一条指令不是从 106 号单元取出，而是转移到 101 号单元取出。至此 JMP 指令执行周期结束

![image-20210313192020243](http://image.trouvaille0198.top/image-20210313192020243.png)

### 5.2.7 用方框图语言表示指令周期

#### 1）方法

- 指令系统设计（模型机的五指令系统）

- 方框——按 CPU 周期

- 方框内内容——数据通路操作或控制操作

- 菱形符号——判别或测试

- ~——公操作

- 前边所讲述的5种操作的框图描述

#### 2）例

![image-20210313192845282](http://image.trouvaille0198.top/image-20210313192845282.png)

## 5.3 时序产生器和控制方式

- 同步控制方式（指令的机器周期和时钟周期数不变）
    - 完全统一的机器周期执行各种不同的指令
    - 或采用不定长机器周期
    - 中央控制于局部控制的结合

- 异步控制方式
    - 每条指令需要多长时间就占多长时间

- 联合控制方式
    - 大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式
    - 或，机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用）

## 5.4 微程序控制器

微命令->微指令->微程序

一条机器指令对应着一个微程序

分清控制器，运算器，存储器，总线之间的边界

### 5.4.1 概念

**微命令**：控制部件向执行部件发出的各种控制命令叫作微命令，它是构成控制序列的最小单位

**微操作**：执行器接受微命令后所进行的操作

**微指令**：把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令

- 操作控制字段，又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。
    - 某位为1，表明发微指令
    - 微指令发出的控制信号都是节拍电位信号，持续时间为一个CPU周期
    - 微命令信号还要引入时间控制
- 顺序控制字段，又称微地址码字段，用以控制产生下一条要执行的微指令地址。

**微程序**：一系列微指令的有序集合就是微程序

- 一段微程序对应一条机器指令。
- 微地址 ：存放微指令的控制存储器的单元地址

<img src="http://image.trouvaille0198.top/image-20210313202842553.png" alt="image-20210313202842553" style="zoom:67%;" />

### 5.4.2 微程序控制原理

![image-20210313203405485](http://image.trouvaille0198.top/image-20210313203405485.png)

#### 1）控制存储器 (μCM)

这是微程序控制器的核心部件，用来存放微程序。其性能 (包括容量、速度、可靠性等) 与计算机的性能密切相关

机器运行时只读不写，工作时，读取一条微指令并运行，以此往复

#### 2）微指令寄存器 (μIR)

用来存放从 μCM 取出的正在执行的微指令

#### 3）地址转移逻辑

用来产生初始微地址和后继微地址，以保证微指令的连续执行

#### 4）微地址寄存器 (μMAR) 

它接受微地址形成部件送来的微地址，为下一步从μCM中读取微指令作准备。