# 存储器

## 存储器概述

### 存储器的分类

存储位元 (二进制代码位) -> 存储单元 -> 存储器

（了解）

- 按存储介质分类
    - 磁表面
    - 半导体存储器

- 按存取方式分类
    - 随机 (访问数据的时间与数据在存储器中的位置无关)
    - 顺序存取（磁带）

- 按读写功能分类
    - RAM：随机存储器，双极型/MOS
    - ROM：只读存储器，MROM/PROM/EPROM/EEPROM

- 按信息的可保存性分类
    - 永久性
    - 非永久性

- 按存储器系统中的作用分类
    - 主/辅/缓/控

### 存储器的分级

<img src="http://image.trouvaille0198.top/image-20210603124736855.png" alt="image-20210603124736855" style="zoom:50%;" />

cache -> 主存 -> 辅存

速度变慢，容量变大

- **高速缓冲存储器**

    简称 cache，它是计算机系统中的一个高速小容量半导体存储器。

- **主存储器**

    简称主存，是计算机系统的主要存储器，用来存放计算机运行期间的大量程序和数据。能和 cache 交换数据和指令

- **外存储器**

    简称外存，它是大容量辅助存储器。

### 主存储器的技术指标

（重要）

- **字存储单元**：存放一个**机器字**的存储单元，相应的单元地址叫字地址。

    一个字存储单元通常由多个存储单元组成

    字地址指这个字首个字节的地址

    字与字节没有明确关系

- 字节存储单元：存放一个字节的单元，相应的地址称为字节地址。

    一个字节存储单元通常由一个存储单元组成（如果存储单元占 8 位的话）

- **存储容量**：指一个存储器中可以容纳的存储单元总数。存储容量越大，能存储的信息就越多。

- **存取时间**：又称存储器访问时间：指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。通常取写操作时间等于读操作时间，故称为存储器存取时间。

    速度性指标

- **存储周期**：指连续启动两次读操作所需间隔的最小时间。通常，存储周期略大于存取时间，其时间单位为 ns。

    速度性指标

- **存储器带宽**：单位时间里存储器所存取的信息量，通常以位/秒或字节/秒做度量单位。

    速度性指标

- 按字节寻址/编址/访问：一字节（Byte）一地址

- 按字寻址/编址/访问：一（机器）字一地址

    - 例：
        - 1M × 8 位：$$2^{20}$$ 个存储单元（及其存储容量），每个存储单元占 8 位，存储单元地址共 20 位，相当于 1MB

## SRAM 存储器

静态读写存储器，存储速度快，容量较小

### 基本的静态存储元阵列

- 存储位元
    - 如图存储位元总数为 $$64\times 4=256$$
- 三组信号线
    - 地址线
        - 如图六条地址线指定了存储器容量是 $$2^6=64$$ 个存储单元
    - 数据线
        - 如图四条数据线指定了存储器的字长为 4 位
    - 控制线
        - 高电平读，低电平写

<img src="http://image.trouvaille0198.top/12344.png" alt="12344" style="zoom:67%;" />

### 基本的 SRAM 逻辑结构

SRAM 芯大多采用双译码方式，以便组织更大的存储容量。采用了二级译码：将地址分成 x 向、y 向两部分

图示

- 15 位地址，8 位存储单元，即 32KB
- 8 位行地址，7 位列地址展开阵列
    - 采用双译码的方式（减少选择线的数目）
    - A0~A7 为行地址译码线
    - A8~A14 为列地址译码线
- 存储阵列的厚度即代表位数（8 位）
    - 通常把各个字的同一个字的同一位集成在一个芯片（32K×1）中
    - 32K 位排成 256×128 的矩阵
    - 8 个片子就可以构成 32KB

<img src="http://image.trouvaille0198.top/497582.png" alt="497582" style="zoom:80%;" />

- 读与写的互锁逻辑

 控制信号中 CS 是片选信号，CS 有效时（低电平），门 G1、G2 均被打开。OE 为读出使能信号，OE有效时（低电平），门 G2 开启，当写命令WE = 1时（高电平），门 G1 关闭，存储器进行读操作。写操作时，WE = 0，门 G1 开启，门 G2 关闭。注意，门 G1 和 G2 是互锁的，一个开启时另一个必定关闭，这样保证了读时不写，写时不读。

## DRAM 存储器

动态读写存储器，存储速度慢，容量较大

### DRAM芯片的逻辑结构

图示：1M × 4 位 DRAM

- 分时传送地址码
    - 若地址总线宽度为 10 位，先传送地址码 A0～A9，由行选通信号 RAS 打入到**行地址锁存器**
    - 然后传送地址码 A10～A19，由列选通信号 CRS 打入到**列地址锁存器**
- 增加了刷新计数器和相应的控制电路
    - DRAM 读出后必须刷新，而未读写的存储元也要定期刷新，而且要按行刷新
    - 所以刷新计数器的长度等于行地址锁存器
    - 刷新操作与读/写操作是交替进行的，所以通过 2 选 1 多路开关来提供刷新行地址或正常读/写的行地址。

<img src="http://image.trouvaille0198.top/2463472472.png" alt="2463472472" style="zoom:80%;" />

### 刷新周期

#### 刷新周期

DRAM 存储位元是基于电容器上的电荷量存储，这个电荷量随着时间和温度而减少，因此必须定期地刷新，以保持它们原来记忆的正确信息

#### 刷新方式

- **集中式刷新**
    - DRAM 的所有行在每一个刷新周期中都被刷新。
    - 例如刷新周期为 8ms 的内存来说，所有行的集中式刷新必须每隔8ms进行一次。为此将 8ms 时间分为两部分
        - 前一段时间进行正常的读/写操作
        - 后一段时间（8ms 至正常读/写周期时间）做为集中刷新操作时间。

- **分散式刷新**
    - 每一行的刷新插入到正常的读/写周期之中。
        - 例如上图所示的 DRAM 有 1024 行，如果刷新周期为 8ms，则每一行必须每隔 8ms÷1024=7.8us 进行一次。

### 存储器容量的扩充

#### 字长位数扩展（位扩展）

1k × 4 位 -> 1k × 16 位 ，4片

（位扩展，横向）

 给定的芯片字长位数较短，不满足设计要求的存储器字长，此时需要用多片给定芯片扩展字长位数。

特点

- 地址线公用
- 控制线公用（所有芯片的片选信号、读信号、写信号拼在一起）公用       

- 数据线单独分开连接

所需芯片数 d = 设计要求的存储器容量/选择芯片存储器容量

<img src="http://image.trouvaille0198.top/image-20210401140916346.png" alt="image-20210401140916346" style="zoom: 50%;" />

#### 字存储容量扩展（字扩展）

1k × 4 位 -> 4k × 4 位 ，4片

（字扩展，纵向）

给定的芯片存储容量较小（字数少），不满足设计要求的总存储容量，此时需要用多片给定芯片来扩展字数

特点

- 地址总线和数据总线公用，后面的地址总线来选择芯片，前面的地址总线选择此芯片的地址

- 控制总线中 R/W 公用，使能端 EN 不能共用

- 它由地址总线的高位段译码来决定片选信号。

<img src="http://image.trouvaille0198.top/image-20210401141634557.png" alt="image-20210401141634557" style="zoom:50%;" />

#### 字位扩展

1k × 4 位 -> 4k × 16 位 ，16 片

## 并行存储器

为了提高 CPU 和主存之间的数据传输率，除了主存采用更高速的技术来缩短读出时间外，还可以采用并行技术的存储器

### 双端口存储器

空间并行

#### 逻辑结构

同一个存储器具有两组相互独立的**读写控制电路**

R/W：读写

OE：输出使能

CE：片选

A：11位地址线

I/O：16位数据线

<img src="http://image.trouvaille0198.top/image-20210408122817887.png" alt="image-20210408122817887" style="zoom: 67%;" />

#### 无冲突读写控制

当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突

![image-20210408123632430](http://image.trouvaille0198.top/image-20210408123632430.png)

#### 有冲突读写控制

当两个端口同时存取存储器同一存储单元时，便发生读写冲突

为解决此问题，特设置了 BUSY 标志。在这种情况下，片上的判断逻辑可以决定对哪个端口优先进行读写操作，而对另一个被延迟的端口置 BUSY 标志 (BUSY 变为低电平)，即暂时关闭此端口。

判断方式自学

### 多模块交叉存储器

时间并行，多个存储体来存储数据

#### 存储器的模块化组织

一个由若干个模块组成的主存储器是线性编址的。

这些地址在各模块中如何安排，有两种方式：一种是顺序方式，一种是交叉方式 

<img src="http://image.trouvaille0198.top/image-20210408124309690.png" alt="image-20210408124309690" style="zoom: 50%;" />

- 顺序方式

    [例] M0－M3 共四个模块，则每个模块8个字

    顺序方式： 

    ​				    M0：0—7

    ​          		  M1：8－15

    ​        		    M2：16－23

    ​       		     M3：24－31

    5位地址组织如下： X X    X X X

    高位选模块，低位选块内地址

    特点：某个模块进行存取时，其他模块不工作，优点是某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。缺点是各模块串行工作，存储器的带宽受到了限制。

- 交叉方式

    [例] M0－M3 共四个模块，则每个模块 8 个字

    交叉方式：

    ​			      M0：0，4,...除以4余数为0

    ​		          M1：1，5,...除以4余数为1

    ​		          M2：2，6,...除以4余数为2

    ​				  M3：3，7,...除以4余数为3

    5位地址组织如下： X X X     X X

    高位选块内地址，低位选模块

    特点：连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。优点是对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。缺点是不易扩展。

#### 基本结构

右图为四模块交叉存储器结构框图。主存被分成 4 个相互独立、容量相同的模块 M0，M1，M2，M3，每个模块都有自己的读写控制电路、地址寄存器和数据寄存器，各自以等同的方式与 CPU 传送信息。在理想情况下，如果程序段或数据块都是连续地在主存中存取，那么将大大提高主存的访问速度

<img src="http://image.trouvaille0198.top/image-20210408125546603.png" alt="image-20210408125546603" style="zoom:80%;" />

#### 定量分析

通常在一个存储器周期内，n 个存储体必须分时启动，则各个存储体的启动间隔为 $$t=T/n$$（n为交叉存取度）

整个存储器的存取速度有望提高 n 倍
$$
t_{顺序}=xT \\ t_{交叉}=T+(x-1)t=T(\frac{x+n-1}{n})
$$
<img src="http://image.trouvaille0198.top/image-20210408132215307.png" alt="image-20210408132215307" style="zoom:67%;" />

例：设存储器容量为 32 字，字长 64 位，模块数 m = 4，分别用顺序方式和交叉方式进行组织。存储周期 T = 200ns，数据总线宽度为 64 位，总线传送周期 = 50ns。若连续读出 4 个字，问顺序存储器和交叉存储器的带宽（单位时间内的传输量）各是多少?

解：顺序存储器和交叉存储器连续读出 m = 4 个字的信息总量都是：

​		 q = 64b×4 = 256b

​		顺序存储器和交叉存储器连续读出 4 个字所需的时间分别是：

​		t2 = mT = 4×200ns = 800ns = 8×10-7s

​		t1 = T + (m - 1) = 200ns + 350ns = 350ns = 35×10-7s

​		顺序存储器和交叉存储器的带宽分别是：

​		W2=q/t2=256b÷(8×10-7)s=320Mb/s

​		W1=q/t1=256b÷(35×10-7)s=730Mb/s

## Cache 存储器

### Cache 基本原理

#### 功能

**提高存储器反应速度**，解决 CPU 和主存之间的速度不匹配问题

- 一般采用高速的 SRAM 构成。

- CPU 和主存之间的速度差别很大，采用两级或多级 Cache 系统

- 早期的一级 Cache 在 CPU 内，二级在主板上

- 现在的 CPU 内带 L1 Cache 和 L2 Cache

- 全由硬件调度，对用户透明

<img src="http://image.trouvaille0198.top/image-20210408141702866.png" alt="image-20210408141702866" style="zoom:67%;" />

#### 基本原理

- 主存与 Cache 以**块**为单位进行数据交换（依据空间复杂性）

- CPU 则以**字** (存储单元) 为单位访问 Cache，依据地址判断此字当前是否在 Cache 中
    - 若是，直接传
    - 否则，CPU 去主存找此字，同时主存把此字送到 Cache 中（依据时间复杂性）

地址映射

替换策略

写一致性

性能评价

<img src="http://image.trouvaille0198.top/image-20210408141747675.png" alt="image-20210408141747675" style="zoom: 50%;" />

#### 命中率

从 CPU 来看，增加一个 cache 的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。为了达到这个目的，在所有的存储器访问中由 cache 满足 CPU 需要的部分应占很高的比例，即 cache 的命中率应接近于 1。由于程序访问的局部性（**局部性原理**），实现这个目标是可能的

#### 命中率公式

$$
命中率： h=\frac{N_c}{N_c+N_m} \\
Cache的平均访问时间： t_a=ht_c+(1-h)t_m \\
访问效率： e=\frac{t_c}{t_a}=\frac{1}{r+(1-r)h} \\
主存慢于Cache的倍率： r=\frac{t_m}{t_c}
$$



例：CPU 执行一段程序时，cache 完成存取的次数为 1900 次，主存完成存取的次数为 100 次，已知 cache 存取周期为 50ns，主存存取周期为 250ns，求 cache / 主存系统的效率和平均访问时间。 

解：
$$
h=N_c/(N_c+N_m)=1900/(1900+100)=0.95 \\ 
r=t_m/t_c=250ns/50ns=5 \\
e=1/(r+(1-r)h)=1/(5+(1-5)×0.95)=83.3\% \\
t_a=t_c/e=50ns/0.833=60ns \\
$$

### 主存与 Cache 的地址映射

映射的本质：主存块号变成 cache 行号

无论选择哪种映射方式，都要把主存和 cache 划分为同样大小的“块”。

选择哪种映射方式，要考虑：

- 硬件是否容易实现

- 地址变换的速度是否快

- 主存空间的利用率是否高

- 主存装入一块时，发生冲突的概率

#### 全相联的映射方式

**主存中的块可以放入到 cache 的任意一行**

- 将地址分为两部分——**块号和字**（块内地址），在内存块（随机）写入 Cache 时，同时写入块号（**标记**）；

- 字即块内地址，即目标在块内的地址；主存中的块内地址即 cache 中的行内地址

- CPU 给出访问地址后，也将地址分为两部分（块号和字），比较块号与 Cache 表中的标记进行比较，相同表示命中，访问相应单元；如果没有命中访问内存，CPU 直接访问内存，并将被访问内存的相对应块写入 Cache。

- 转换公式

    - 主存地址长度＝(s + w) 位
    - 寻址单元数＝2^s+w^ 个字或字节

    - 块大小＝行大小＝2^w^ 个字或字节

    - 主存的块数＝2^s^

    - 标记大小＝s 位

    - cache 的行数＝不由地址格式确定

- 特点：

    优点：冲突概率小，Cache 的利用高。（只有当 cache 全满时才会发生冲突）

    缺点：比较器难实现，需要一个访问速度很快代价高的相联存储器

- 应用场合：

    适用于小容量的 Cache

<img src="http://image.trouvaille0198.top/a1.png" style="zoom: 67%;" />

#### 直接映射方式

**主存中的块只能放入到 cache 的固定一行**

- 映射方法（一对多）

    - **i = j mod m**
    - 主存第 j 块内容拷贝到 Cache 的 i 行
    - m 表示 cache 的行数
    - 一般 i 和 m 都是 2^N^ 级

- **地址：标记 + 行号 + 块内地址**

- [例] cache 容量 16 字，主存容量 256 字，则地址 2，18，34…..242 等都存放在 cache 的地址 2 内，如果第一次 2 在 cache 中，下次访问 34 内容，则不管 cache 其他位置的内容访问情况，都会引起 2 块内容的替换

- 基本原理

    - 利用行号选择相应行；
    - 把行标记与 CPU 访问地址进行比较，相同表示命中，访问 Cache；
    - 如果没有命中，访问内存，并将相应块写入 Cache

- 转换公式

    - 主存地址长度＝ (s+w) 位
    - 寻址单元数＝2^s+w^ 个字或字节
    - 块大小＝行大小＝2^w^ 个字或字节
    - 主存的块数＝2^s^
    - cache 的行数＝m＝2^r^
    - 标记大小＝(s-r) 位

- 特点

    优点：比较电路少 m 倍线路，所以硬件实现简单，Cache 地址为主存地址的低几位，不需变换。

    缺点：冲突概率高（抖动）

- 应用场合

    适合大容量 Cache

<img src="http://image.trouvaille0198.top/a3.png" style="zoom:70%;" />

#### 组相联映射方式

**前两者的组合，cache 中以若干行为一组，组之间直接映射，组内全相联**

- Cache 分组，**组间采用直接映射方式，组内采用全相联的映射方式**

- Cache 分组 U，组内容量 V

- 映射方法（一对多）
    - **q = j mod u**	
    - 主存第 j 块内容拷贝到 Cache 的第 q 组中的某行
    - u 表示组数；q 表示组号，j 表示块号
- **地址 = （表示行的）标记 + 组号 + 块内地址**

- 地址变换
    - 设主存地址 x，看是不是在 cache 中，先 y = x mod u，则在 y 组中一次查找
- 分析
    - v=1，则为直接相联映射方式
    - u=1，则为全相联映射方式
    - v 的取值一般比较小， 一般是 2 的幂，称之为 v 路组相联 cache.
- 转换公式
    - 主存地址长度＝(s+w) 位
    - 寻址单元数＝2^s+w^ 个字或字节
    - 块大小＝行大小＝2^w^ 个字或字节
    - 主存的块数＝2^s^
    - 每组的行数＝k
    - 组数 v＝2^d^
    - cache 的行数＝kv
    - 标记大小＝(s-d) 位
- n 路组相联：一个组有 n 行

<img src="http://image.trouvaille0198.top/a2.png" style="zoom: 70%;" />

#### 例

<img src="http://image.trouvaille0198.top/image-20210415140629870.png" alt="image-20210415140629870" style="zoom: 50%;" />

<img src="http://image.trouvaille0198.top/image-20210415140650706.png" alt="image-20210415140650706" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210415143127801.png" alt="image-20210415143127801" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210415143137255.png" alt="image-20210415143137255" style="zoom:50%;" />

### 替换策略

- **LFU**（最不经常使用 ）：被访问 / 命中的行计数器增加 1。始终拿走值最小的行，不能反映近期 cache 的访问情况，

- **LRU**（近期最少使用） ：被访问的行计数器置 0，其他的计数器增加1，始终拿走值最大的行，符合 cache 的工作原理

- 随机替换：随便找个位置而已

### 写操作策略

由于 cache 的内容只是主存部分内容的拷贝，它应当与主存内容保持一致。而 CPU 对 cache 的写入更改了 cache 的内容。如何与主存内容保持一致，可选用如下三种写操作策略。

- 写回法：只写 Cache；换出时，对行的修改位进行判断，决定是写回还是舍掉。 

- 全写法（写直达法）：写命中时，Cache 与内存一起写 

- 写一次法：与写回法一致，但是第一次 Cache 命中时采用全写法。(第一次一起写，之后写 cache)

## 虚拟存储器

### 概念

- 虚地址：用户编制程序时使用的地址称为**虚地址**或**逻辑地址**，其对应的存储空间称为虚存空间或逻辑地址空间；

- 实地址：而计算机物理内存的访问地址则称为**实地址**或**物理地址**，其对应的存储空间称为**物理存储空间**或**主存空间**。

- 再定位：程序进行虚地址到实地址转换的过程称为程序的**再定位**（虚实转换），在访问 cache 之前就已经完成

#### 虚存的访问过程

- 虚存空间的用户程序按照虚地址编程并存放在辅存中。
- 程序运行时，由地址变换机构依据当时分配给该程序的实地址空间把程序的一部分调入实存。
- 每次访存时，首先判断**该虚地址所对应的部分是否在实存中**：
    - 若是，则进行地址转换并用实地址访问主存；
    - 否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。
- 由此可见，每个程序的虚地址空间可以远大于实地址空间，也可以远小于实地址空间。
    - 前一种情况以提高存储容量为目的，后一种情况则以地址变换为目的。
    - 后者通常出现在多用户或多任务系统中：实存空间较大，而单个任务并不需要很大的地址空间，较小的虚存空间则可以缩短指令中地址字段的长度。

<img src="http://image.trouvaille0198.top/image-20210422131552285.png" alt="image-20210422131552285" style="zoom:50%;" />

#### cache 与虚存的异同

- 从虚存的概念可以看出，主存辅存的访问机制与 cache 主存的访问机制是类似的。这是由 cache 存储器、主存和辅存构成的三级存储体系中的两个层次。
- cache 和主存之间以及主存和辅存之间分别有辅助硬件和辅助软硬件负责地址变换与管理，以便各级存储器能够组成有机的三级存储体系。cache 和主存构成了系统的内存，而主存和辅存依靠辅助软硬件的支持构成了虚拟存储器。

- 在三级存储体系中，cache 主存和主存辅存这两个存储层次有许多**相同点**；
    1. **出发点相同** 二者都是为了提高存储系统的性能价格比而构造的分层存储体系，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。
    2. **原理相同** 都是利用了程序运行时的局部性原理把最近常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器。

- 但 cache 主存和主存辅存这两个存储层次也有许多**不同**之处：
    3. **侧重点不同** cache 主要解决主存与CPU的速度差异问题；而就性能价格比的提高而言，虚存主要是解决存储容量问题，另外还包括存储管理、主存分配和存储保护等方面。
    4. **数据通路不同** CPU 与 cache 和主存之间均有直接访问通路，cache 不命中时可直接访问主存；而虚存所依赖的辅存与 CPU 之间不存在直接的数据通路，当主存不命中时只能通过调页解决，CPU 最终还是要访问主存。
    5. **透明性不同** cache 的管理完全由硬件完成，对系统程序员和应用程序员均透明；而虚存管理由软件（操作系统）和硬件共同完成，由于软件的介入，虚存对实现存储管理的系统程序员不透明，而只对应用程序员透明（段式和段页式管理对应用程序员“半透明”）。
    6. **未命中时的损失不同** 由于主存的存取时间是 cache 的存取时间的 5～10 倍，而主存的存取速度通常比辅存的存取速度快上千倍，故主存未命中时系统的性能损失要远大于 cache 未命中时的损失。

#### 虚存机制要解决的关键问题

1. 调度问题决定哪些程序和数据应被调入主存。 
2. 地址映射问题在访问主存时把虚地址变为主存物理地址（这一过程称为内地址变换）；在访问辅存时把虚地址变成辅存的物理地址（这一过程称为外地址变换），以便换页。此外还要解决主存分配、存储保护与程序再定位等问题。
3. 替换问题决定哪些程序和数据应被调出主存。 
4. 更新问题确保主存与辅存的一致性。 

在操作系统的控制下，硬件和系统软件为用户解决了上述问题，从而使应用程序的编程大大简化。

### 页式虚拟存储器

#### 页 

虚地址空间被分成**等长大小的页**，称为**逻辑页**；

主存空间也被分成**同样大小的页**，称为**物理页**

虚地址分为两个字段：高字段为**逻辑页号**，低字段为**页内地址**（偏移量）；

- 虚页号由逻辑空间的大小决定（单位为页的个数），页内地址由页的大小决定

实存地址也分两个字段：高字段为**物理页号**，低字段为**页内地址**。

- 两者的页内地址相同，唯一需要转换的是虚页号到实页号

- 通过**页表**可以把虚地址（逻辑地址）转换成物理地址。

#### 页表

页表中对应每一个**虚存页面**有一个**表项**，表项的内容包含该虚存页面所在的主存页面的地址（**物理页号**），以及指示该逻辑页是否已调入主存的**有效**位。

地址变换时，用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接，就构成完整的物理地址。现代的中央处理机通常有专门的硬件支持地址变换。

每个进程所需的页数并不固定，所以页表的长度是可变的，因此通常的实现方法是把页表的基地址保存在寄存器中（**页表基址 R**），而页表本身则放在主存中。

由于虚存地址空间可以很大，因而每个进程的页表有可能非常长。例如，如果一个进程的虚地址空间为2G字节，每页的大小为512字节，则总的虚页数为 2^31^/2^9^=2^22^。

<img src="http://image.trouvaille0198.top/image-20210422132725324.png" alt="image-20210422132725324" style="zoom: 67%;" />

为了节省页表本身占用的主存空间，一些系统把页表存储在虚存中（**快表**，TLB，转换后援缓冲器），全硬件实现，容量小，是页表（此时称慢表）的子集，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存。

<img src="http://image.trouvaille0198.top/image-20210422135845562.png" alt="image-20210422135845562" style="zoom: 67%;" />

页表和快表同时查找！

另一些系统采用**二级页表**结构。每个进程有一个页目录表，其中的每个表项指向一个页表。

在页表长度较大的系统中，还可以采用反向页表实现物理页号到逻辑页号的反向映射。页表中对应每一个物理页号有一个表项，表项的内容包含该物理页所对应的逻辑页号。访存时，通过逻辑页号在反向页表中逐一查找。如果找到匹配的页，则用表项中的物理页号取代逻辑页号；如果没有匹配表项，则说明该页不在主存中。这种方式的优点是页表所占空间大大缩小，但代价是需要对反向页表进行检索，查表的时间很长。有些系统通过散列（哈希）表加以改进

**内页表和外页表**

页表是虚地址到主存物理地址的变换表，通常称为内页表。与内页表对应的还有外页表，用于虚地址与辅存地址之间的变换。当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。

![image-20210422135944175](http://image.trouvaille0198.top/image-20210422135944175.png)

### 段式虚拟存储器

#### 段和段表

段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。

虚地址由**段号**和**段内地址（偏移量）**组成。虚地址到实主存地址的变换通过**段表**实现。

每个**表项**至少包含下面三个字段：

1. 有效位：指明该段是否已经调入实存。
2. 段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。 
3. 段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。

段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。

<img src="http://image.trouvaille0198.top/image-20210422140841856.png" alt="image-20210422140841856" style="zoom: 67%;" />

#### 特点

- 优点
    - 段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序**共享**。
    - 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。

- 缺点
    - 因为段的长度不固定，主存空间分配比较麻烦
    - 容易在段间留下许多外碎片，造成存储空间利用率降低
    - 由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。

### 段页式虚拟存储器

实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页，程序按页进行调入和调出操作，但可按段进行编程、保护和共享

一般情况下由一张段表，其中有好多页表

虚地址：基号 + 段号 + 页号 + 页内地址

实地址：物理页号 + 页内地址

<img src="http://image.trouvaille0198.top/image-20210422142550704.png" alt="image-20210422142550704" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210422142602662.png" alt="image-20210422142602662" style="zoom:50%;" />

### 虚存的替换算法

当从辅存调页至主存而主存已满时，也需要进行主存页面的替换。虚拟存储器的替换算法与cache的替换算法类似，有 FIFO 算法、LRU 算法、LFU 算法等。

虚拟存储器的替换算法与 cache 的替换算法不同的是： 

1. cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。
2. 虚存缺页对系统性能的影响比 cache 未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。
3. 虚存页面替换的选择余地很大，属于一个进程的页面都可替换。

<img src="http://image.trouvaille0198.top/image-20210422142747470.png" alt="image-20210422142747470" style="zoom:50%;" />

<img src="http://image.trouvaille0198.top/image-20210422142756955.png" alt="image-20210422142756955" style="zoom:50%;" />

# 