# 操作系统

## 操作系统引论

### 操作系统概念

#### 定义

计算机系统中的一个系统软件，是程序模块的集合

（有效、合理、方便）

#### 目标

- 方便性
- 有效性：提高系统资源利用率、提高系统吞吐量
- 可扩充性
- 开放性：软硬件兼容

#### 作用

##### 作为用户与硬件之间的接口

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909110517642.png" alt="image-20210909110517642" style="zoom:50%;" />

##### 计算机系统资源的管理者

硬件资源

软件资源

##### 实现了对计算机资源的抽象

覆盖了一系列软件（I/O 操作命令、文件管理等）后成为虚机器

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909111006452.png" alt="image-20210909111006452" style="zoom: 50%;" />

#### 推动 OS 发展的动力

- 不断提高计算机资源利用率
- 方便用户
- 器件的不断更新与迭代
- 计算机体系结构的不断发展
- 不断提出新的应用需求

### 操作系统的发展过程

- 人工操作
- 脱机 / 假脱机（SPOOLing）方式
- 单道批处理

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909114014453.png" alt="image-20210909114014453" style="zoom: 33%;" />

#### **多道批处理**

(并发)

利用 A 程序的 I/O 操作而暂停执行 CPU 空挡时间，调度 B 程序运行

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909114004983.png" alt="image-20210909114004983" style="zoom: 33%;" />

##### **特点**

- 资源利用率高
- 系统吞吐量大
- 平均周转时间长（需要排队依次进行处理）
- 无交互能力（修改和调试程序不方便）

##### **需要解决的问题**

- 处理机争用问题
- 内存分配和保护问题
- I/O 设备分配问题
- 文件的组织和管理问题
- 作业管理问题
- 用户与系统的接口问题

#### **分时系统**

- 人机交互、共享主机

    ![image-20210910102358257](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210910102358257.png)

- 时间片（time slice）：一段很短的时间，用来切割 CPU

#### 实时系统

（Real time system）

计算机对所接收到的信号做出及时或实时的反应

#### 微机操作系统

##### 单用户单任务操作系统

MS-DOS

##### 单用户多任务操作系统

Windows XP

##### 多用户多任务操作系统

UNIX，Linux

### 操作系统的基本特性

#### 并发

（Concurrence）多时间在同一时间段内发生

##### 引入进程（Process）

未引入进程系统：计算和 I/O 顺序执行

引入进程系统：为计算程序和 I/O 程序分别建立一个进程，两个进程可并发进行

##### 线程（Threads）

比进程更小的单位 

#### 共享

（Sharing）系统中的资源可供内存中多个并发执行的进程（线程）**共同使用**

- 互斥共享（音频设备、打印机）
- 同时访问（磁盘文件、可重入代码）

#### 虚拟

（Virtual）把一个物理实体变为若干个逻辑上的对应物

如

- CPU：每个进程的虚处理机
- 存储器：每个进程占有的地址空间（指令+数据+堆栈）
- 方法
    - 时分复用
    - 空分复用:对存储空间的管理

#### 异步

（Asynchronism）

也称不确定性 / 随机，指进程的执行顺序和执行时间的不确定性

### 操作系统的主要功能

- 资源管理
    - 处理机管理（硬件）
    - 存储器管理（硬件）
    - 设备管理（硬件）
    - 文件管理（软件）
- 用户接口
    - 命令接口
    - 图形接口
    - 程序接口

#### 处理机管理功能

- 进程控制：创建、撤销、状态迁移

- 进程同步：互斥访问临界资源

- 进程通信：进程合作

    ![image-20210910110604428](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210910110604428.png)

- 调度
    - 作业调度：按照算法为作业分配资源
    - 进程调度：按照算法先后执行进程

#### 存储器管理功能

- 内存分配
    - 为每道程序分配内存空间
    - 提高存储器利用率，减少内存碎片
    - 满足正在运行的程序数据动态增长的需要
    - 分类
        - 静态分配
        - 动态分配
- 内存保护
    - 确保程序互不干扰
    - 不允许用户访问操作系统的程序与数据
    - 不允许用户转到非共享的其他用户程序

- 地址映射

- 内存扩充
    - 虚存技术
    - 功能
        - 请求调入
        - 置换

#### 设备管理功能

完成用户提出的 I/O 请求，并分配设备

提高 I/O 利用率

- 缓冲管理
    - 在 I/O 设备和 CPU 中之间引入缓冲
- 设备分配
- 设备处理
- 虚拟设备

#### 文件管理功能

- 文件存储空间的管理

- 目录管理

- 文件的读/写管理和保护

#### 用户接口

命令接口

#### 程序接口

由一组==系统调用==构成，它长得蛮像个库函数（API）

##### 系统调用

**系统调用**是操作系统提供给编程人员的唯一接口，它使 CPU 状态**从用户态陷入内核态**

##### 内核

**内核**是一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作

它驻留内核空间，运行于和心态，具有访问硬件设备和内存的全部权限，可以执行特权指令。

它是对操作系统核心功能的抽象概念

##### 处理过程

用户使用系统调用（此时用户程序挂起），导致操作系统功能执行（此时从用户态陷入内核态），并返回用户请求的服务，用户程序恢复现场。

##### 用户态

（user mode）非特权状态、目态

在此状态下，执行的代码被硬件限定，不能进行某些操作

##### 核心态

特权状态、管态

核心态是操作系统内核所运行的模式，运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。

#### 现代操作系统的新功能

blabla

### 操作系统结构设计

#### 传统 OS 结构

##### 无结构操作系统

##### 模块化结构 OS

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916105916360.png" alt="image-20210916105916360" style="zoom: 40%;" />

- **模块独立性**
    - 内聚性
    - 耦合度

##### 分层式结构 OS

#### 客户 / 服务器模式

（Client / Server Model）

#### 面向对象的程序设计

#### 微内核 OS 结构

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916111002429.png" alt="image-20210916111002429" style="zoom:50%;" />

- 基于客户服务器模式
- 机制与策略分离
- 面向对象技术

##### 微内核

- 能实现现代 OS 最基本核心功能的小型内核

- 包含
    - 与硬件处理紧密相关的部分
    - 一些较基本的功能
    - 客户与服务器间的通信

- 如
    - 进程管理
    - 低级存储器管理
    - 中断和陷入管理

##### 优点

- 提高系统可扩展性
- 提高系统可靠性
- 提高可移植性
- 提供了对分布式系统的支持
- 融入了面向对象技术

##### 存在的问题

系统在用户态与内核态多次切换（上下文切换频繁）

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916111205827.png" alt="image-20210916111205827" style="zoom:50%;" />

## 进程的描述与控制

### 前驱图和程序执行

#### 前驱图

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916113103298.png" alt="image-20210916113103298" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916113049918.png" alt="image-20210916113049918" style="zoom:50%;" />

#### 顺序执行

##### 前驱图

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916113230038.png" alt="image-20210916113230038" style="zoom:40%;" />

##### 特征

- 顺序性

- 封闭性：程序运行时独占全部资源

- 可再现性

#### 并发执行

允许多道程序共享资源，次序不确定

##### 前驱图

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210916113252245.png" alt="image-20210916113252245" style="zoom:50%;" />

##### 特征

- 间断性：程序共享系统资源，程序之间会有**相互制约**的关系，出现 “执行——暂停——执行” 的间断性活动规律

- 失去封闭性：程序共享系统资源

- 不可再现性：失去封闭性，导致了不可再现性

### 进程的描述

（Process）

#### 进程的定义和特征

##### 进程定义

**描述性定义**

计算机中的所有程序（软件），按照某种顺序运行，这种运行的**过程**叫做进程

（一个活动，有程序输入、输出和状态）

**典型定义**

![image-20210923104214178](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923104214178.png)

进程是**进程实体**的运行过程，是系统进行资源分配和调度的一个独立单位

进程是 CPU 抽象的结果

**进程实体**

进程在计算机系统中的**映像**

它包括

- **进程控制块**：（Process Control Block，PCB）系统为了控制进程而设计的数据结构
    - 进程描述信息
    - 进程控制信息
    - ...
- **程序段**
- **相关数据段**
- **管理用户的用户堆栈和系统堆栈**：可归类到数据段中

##### 进程特征

- **动态性**：“由创建而产生，由调度而执行，由撤销而消亡”，它有一定的生命期
- **并发性**：多个进程实体同存于内存中，且能在一段时间内同时运行；引入进程实体的目的就是并发执行
- **独立性**：进程实体能够独立运行、获取资源、接受调度
- **异步性**：进程按**各自独立**的、**不可预知**的速度向前推进

##### 进程与程序的不同

- 进程是动态的，程序是静态的
- 进程是暂时的，程序时永恒的
- **进程包含程序、数据和PCB**
- 进程可以包含多个程序，同一程序可以对应多个进程

#### 进程的基本状态及转换

##### 进程的三种基本状态

- **就绪状态**（Ready）
    - 进程被分配到除 CPU 以外的所有必要资源
    - 按一定的策略可被排成就绪队列
- **执行状态**（Running）
    - 占用 CPU 运行
    - 执行态进程数小于等于 CPU 数
- **阻塞状态**（Block）
    - 暂时无法继续执行
    - 可以排成一个阻塞队列

##### 三种基本状态的转换

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923110245560.png" alt="image-20210923110245560" style="zoom:50%;" />

##### 创建状态和终止状态

- 创建状态
    - 创建进程的过程
    - 进程刚建立，还未进入就绪队列

- 终止状态
    - 终止进程的过程

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923111929644.png" alt="image-20210923111929644" style="zoom:50%;" />

#### 挂起状态和进程状态的转换

##### 定义

挂起状态（Suspend）：进程从内存转到外存（进入静止状态，不可接受调度）

执行的进程暂停、就绪的进程不调度

##### 引入挂起状态的原因

- 终端用户的请求
- 父进程请求
- 负荷调节的需要
- 操作系统的需要

##### 引入挂起原语操作后的状态转换

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923113602578.png" alt="image-20210923113602578" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923112854057.png" alt="image-20210923112854057" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923113100483.png" alt="image-20210923113100483" style="zoom:50%;" />

#### 进程管理中的数据结构 (PCB)

##### PCB 的作用

- 作为独立运行基本单位的标志
- 实现间断性运行的方式
- 提供进程管理需要的信息
- 提供进程调度所需要的信息 
- 实现与其它进程通信

##### PCB 中的信息

- 进程控制符（编号）
- 处理机状态（寄存器信息，计数器）
- 进程调度信息（进程状态和优先级）
- 进程控制信息（资源清单）

##### PCB 组织方式

**线性结构 / 方式**

将所有的 PCB 都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中

**链接结构**

把相同状态进程的 PCB 分别通过 PCB 中的链接字链接成一个队列，这样就可以形成就绪队列、若干个阻塞队列和空白队列等

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923114036634.png" alt="image-20210923114036634" style="zoom:40%;" />

**索引结构**

系统根据所有进程状态的不同，建立几张索引表

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923114025089.png" alt="image-20210923114025089" style="zoom:50%;" />

### 进程控制

#### 操作系统内核

1. **支撑功能**
    - 中断处理
    - 时钟管理（时间片）
    - **原语**操作（由若干条指令组成，在执行过程中不允许被中断）
2. **资源管理功能**
    - 进程管理
    - 存储器管理
    - 设备管理

#### 进程的创建

##### 进程的层次结构

父进程 - 子进程 - 孙进程

##### 进程图

用于描述进程间关系的一棵有向树。图中的结点代表进程。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/20201122104213.png" alt="image-20201122104213788" style="zoom:50%;" />

##### 引起创建进程的事件

1. 用户登录
2. 作业调度
3. 提供服务
4. 应用请求

##### 进程的创建

- 申请空白 PCB
- 为新进程分配其运行所需的资源
- 初始化进程控制块 PCB
- 将新进程插入就绪列

#### 进程的终止

- 正常结束
- 异常结束
- 外界干预

##### 进程终止过程

1. 根据被终止进程的标识符，从 PCB 集合中**检索**出该进程的 PCB，从中读出该进程的状态
2. 若被终止进程正处于执行状态，应立即**终止**该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度
3. 若该进程还有子孙进程，还应将**子孙进程也终止**
4. 将被终止进程所有全部资源或者**归还**给其父进程，或归还给系统
5. 将被终止进程从所在**队列**中**移出**

#### 进程的阻塞与唤醒

##### 引起进程的阻塞与唤醒的事件

- 向系统请求共享资源失败
- 等待某种操作的完成
- 新数据尚未到达
- 等待新任务的到达

##### 进程阻塞过程

1. 进程使用阻塞原语 block 自己

2. 停止运行并进入阻塞队列

3. 调度程序重新调度

- 阻塞原语：block

- 阻塞是进程**自身**的一种**主动**行为。

##### 进程唤醒过程

调用唤醒原语 wakeup，将等待该事件的进程唤醒。

1. 将进程从阻塞队列移出，
2. 将PCB改为就绪，
3. 加入就绪队列。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     

##### 进程的挂起

挂起原语：suspend

1. 检查进程状态，

2. 改为对应的静止状态，

3. 复制 PCB 到指定内存区域以备查看。

4. 指引重新调度

##### 进程的激活

挂起原语：active

1. 将进程从外村调入内存，检查状态，改为对应就绪/阻塞状态。

2. 如果有抢占机制比较是否抢占。

### 进程同步

#### 基本概念

进程同步机制的主要任务：对多个相关进程在执行次序中进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性。

##### **两种形式的制约关系**

直接实现**同步**，间接实现**互斥**

- **间接相互制约关系**

    多个程序在并发执行时，由于**共享系统资源**致使这些执行程序之间形成相互制约的关系。

- **直接相互制约关系**

    源于进程之间的合作关系，前趋图

##### **临界资源**

（Critical Resource）

系统中一次**只允许一个进程使用**的资源

诸进程间应采取互斥方式，实现对临界资源的共享。

##### **临界区**

（Critical Section）

进程中访问临界资源的**代码段**

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210930110843978.png" alt="image-20210930110843978" style="zoom:40%;" />

```c
while(TRUE)
{
	进入区
	临界区
	退出区
	剩余区
}
```

##### **同步机制应遵循的问题**

- **空闲让进**：无其他进程处于临界区时，允许一个进程进入临界区
- **忙则等待**：已有进程进入临界区时，其他进程必须等待
- **有限等待**：在有限时间内能进入自己的临界区，以免陷入“死等”状态；保证有限时间内进入临界区
- **让权等待**：进程不能进入临界区时应立即**释放处理机**（避免死等资源，即忙等待 Busy waiting）

#### **硬件同步机制**

##### **关中断**

禁止中断发生，不适用于多 CPU

在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。

##### **Test-and-Set 指令实现互斥**

疯狂测试 lock，如果开门了就锁门后访问

```c
boolean TS(boolean *lock)
{
	boolean old;
	old = *lock;
	*lock = TRUE;
	return old;
}
  
do{
	…
	while TS(&lock)
	critical section;
	lock = FALSE;
	remainder section;
}while(TRUE)
```

##### **利用 Swap 指令实现进程互斥**

疯狂交换 key 和 lock，如果 key 变 true了访问

```c
void swap(boolean *a, boolean *b)
{
	boolean temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
  
do{
	key = TRUE;
	do{
		swap(&lock,&key);
	}while(key!=FALSE)
	临界区操作;
	lock = FALSE;
	…
}while(TRUE)
```

#### **信号量机制**

重要！

##### **整型信号量**

- 信号量定义为一个整型量 S

- 两个原子操作 `wait(S)` 和 `signal(S)` 被分别称为 P、V 操作。

```c
// 只要信号量小于等于0就不断进行测试（忙等），其实是未遵循让权等待的
wait(S){
    // 探测
	while(S<=0);
	S--;
}
  
signal(S){
    // 释放
	S++;
}
```

##### **记录型信号量**

解决忙等问题

![image-20211009103219127](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009103219127.png)

```c
typedef struct{
	int value;
	struct process_control_block *list;
}semaphore
  
wait(semaphore *S)
{
	S->value--;
	if(S->value<0) 
        block(S->list);
}
signal(semaphore *S)
// 释放一个单位资源
{
	S->value++;
	if(S->value<=0) wakeup(S->list);
}
```

- value：代表资源数目的整型变量
- list：一个进程链表指针，用于链接上述所有等待进程。
- S->value：表示资源数量
    - S->value 大于等于 0：表示系统中可用资源数
    - S->value 小于 0：表示已阻塞进程数
    - S->value 初始值为 1：表示互斥信号量（临界资源只有一个）
    - S->list：记录阻塞进程信息

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210930112406182.png" alt="image-20210930112406182" style="zoom:40%;" />

##### **AND 型信号量**

解决死锁问题

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210930112649045.png" alt="image-20210930112649045" style="zoom:40%;" />

将进程在整个运行过程中需要的所有资源，**一次性全部分配给进程**，待进程使用完后再一起释放，只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。

##### **信号量集**

解决多份资源问题

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210930112919775.png" alt="image-20210930112919775" style="zoom:40%;" />

进程对信号量 S~i~ 是该资源的分配下限值 t~i~，要求 S~i~≥t~i~，否则不予分配。一旦允许分配，进程对该资源的需求值为 d~i~，即表示资源占用量，进行 S~i~=S~i~-d~i~ 操作。

*特殊情况*

- Swait(S,d,d)：只有一个信号量 S，允许每次申请 d 个资源，当少于 d 时，不予分配
- Swait(S,1,1)：一般的记录型信号量 (S>1) 或互斥信号量 (S=1)
- Swait(S,1,0)：S≥1，允许多个进程进入某特定区；S=0，将阻止任何进程进入特定区

#### 信号量应用

##### **利用信号量实现进程互斥**

两个信号量互斥

1. 设mutex为**互斥信号量**，其初值为**1**，取值范围为(-1,0,1)。当mutex=1时，表示两个进程皆未进入需要互斥的临界区；当mutex=0时，表示有一个进程进入临界区运行，另外一个必须等待，挂入**阻塞队列**；当mutex=-1时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。

2. **代码描述**

    ```c
    semaphore mutex=1;
    PA(){
    	while(1){
    		wait(mutex);
    		临界区
    		signal(mutex);
    		剩余区
    	}
    }
    ```

##### **利用信号量实现前趋关系**

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009103629277.png" alt="image-20211009103629277" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009103546729.png" alt="image-20211009103546729" style="zoom:50%;" />



#### 管程机制（自学）

面向对象的封装

代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，称之为管程。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009104409327.png" alt="image-20211009104409327" style="zoom:50%;" />

**组成**

- 管程的名称
- 局部于管程的共享数据结构说明
- 对该数据结构进行操作的一组过程
- 对局部于管程的共享数据设置初始值的语句

**管程和进程的不同**

- 进程定义的是私有数据结构 PCB，管程定义的是公共数据结构
- 进程是由顺序程序执行有关操作，管程进行同步操作和初始化操作
- 进程的设置目的在于实现系统的并发性，管程的设置目的则是解决共享资源互斥使用问题
- 进程为主动工作方式，管程为被动工作方式
- 进程具有动态性，管程是操作系统中的一个资源管理模块，供进程调用

### 经典进程的同步问题

#### **生产者-消费者问题**

生产者-消费者问题是相互合作的进程关系的一种抽象

##### 记录型信号量

循环队列

P 操作互换会引起死锁；V 操作互换不影响

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009110207257.png" alt="image-20211009110207257" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009110312917.png" alt="image-20211009110312917" style="zoom:40%;" />

##### AND 信号量

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009112057216.png" alt="image-20211009112057216" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009112111746.png" alt="image-20211009112111746" style="zoom:40%;" />

#### 哲学家进餐问题

![image-20211009112324618](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009112324618.png)

##### 记录型信号量

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009112813645.png" alt="image-20211009112813645" style="zoom:50%;" />

避免死锁的方法

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009112803159.png" alt="image-20211009112803159" style="zoom:50%;" />

#### 读者-写者问题

写者进程与所有其他读者进程互斥

写者进程互斥

##### 记录型信号量

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009112942528.png" alt="image-20211009112942528" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009113048924.png" alt="image-20211009113048924" style="zoom:40%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009113101612.png" alt="image-20211009113101612" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009113117755.png" alt="image-20211009113117755" style="zoom:50%;" />

##### 信号量集机制

![image-20211014101541249](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211014101541249.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211014101552723.png" alt="image-20211014101552723" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211014101606204.png" alt="image-20211014101606204" style="zoom:50%;" />

### 进程通信

进程通信就是进程之间的信息交换，用于同步和互斥。

#### 概念

**低级进程通信**（信号量）

- 效率低
- 通信对用户不透明
- P/V 操作称为低级通信原语

**高级进程通信**

- 进程通信 IPC（Inter Process Communication）

- 使用方便
- 高效地传送大量数据

#### **进程通信的类型**

##### 共享存储器系统（Shared-Memory System）

共享数据结构或存储区

- 基于共享数据的通信方式（**数据结构**）
- 基于共享存储区的通信方式（**内存**）

##### **管道通信系统**

所谓 “管道”，指用于连接一个读进程和一个写进程以实现它们之间通信的一个**共享文件**

写进程 —> 管道文件 —> 读进程

- 以文件为传输介质
- 以字符流方式读写

##### 消息传递系统（Message Passing System）

以格式化的消息（message）为单位

- 实现方式
    - 程序员利用系统提供的一组通信命令（原语）进行通信

- 直接通信方式（原语操作）
- 间接通信方式（通过共享中间实体（邮箱））

##### 客户-服务器系统（Client-Server System）

- 套接字：分基于文件型和基于网络型
- 远程方法调用和远程文件调用

#### **消息传递通信的实现方式**

##### 直接消息传递系统

发送进程利用 OS 所提供的发送命令（原语），直接把消息发送给目标进程。

1. 直接通信原语

    - 对称寻址方式

        `send(receiver,message);`

        `receive(sender,message);`

    - 非对称寻址方式

        `send(P,message);`

        `receive(id,message);`

2. 消息的格式

3. 进程的同步方式

4. 通信链路

##### 信箱通信

1. 信箱的结构
    - 信箱头：用于存放有关信箱的描述信息
    - 信箱体：由若干个可以存放消息（或消息头）的信箱格组成，信箱格的数目已经每格的大小是在创建信箱时确定的
2. 信箱通信原语
    - 邮箱的创建和撤销
    - 消息的发送和接收
3. 信箱的类型
    - 私用邮箱
    - 公用邮箱
    - 共享邮箱

### 线程的基本概念

#### 线程的引入

引入线程是为了**减少程序在并发执行时所付出的时空开销，使 OS 具有更好的并发性**

进程是**可拥有资源的独立单位**和**可独立调度和分派的基本单位**，但是它不应同时拥有上述两点特质

线程：资源共享、调度独立

#### **线程与进程的比较**

- **调度的基本单位**

    进程是能独立运行的基本单位，在每次被调度时，都需要进行上下文切换，开销较大；

    线程切换仅需保存和设置少量寄存器内容，切换代价远低于进程

- **并发性**

    都可以并发执行

- **拥有资源**

    进程可以拥有资源，并作为系统中拥有资源的一个基本单位；

    **线程并不拥有系统资源**，而是仅有一点必不可少的、能保证独立运行的资源；线程仅拥有隶属进程的资源

- **独立性**

    进程间地址空间和资源互相独立；

    线程间共享地址空间和资源

- **系统开销**

    进程需要切换上下文；

    线程没什么资源，开销小

- **支持多处理机系统**

    进程必须在单处理机上运行；

    单进程中的多线程可分配到不同处理机上执行

#### 线程的实现

- **内核支持线程**（KST, Kernel Supported Threads）：内核创建，能够并发，用户切换线程需要陷入
- **用户级线程**（ULT, User Level Threads）：用户创建，切换不需要陷入，但阻塞后无法调度
- 组合模式：两者结合相互利用

（线程的实现、线程的创建与终止……）

## 处理机调度与死锁

### 处理机调度的层次和调度算法的目标

调度的实质是一种资源分配，处理机调度是对处理机资源进行分配

**作业**：作业是任务实体，进程是完成任务的执行实体

**周转时间**：从作业提交给用户开始，到作业完成为止的时间间隔（等待时间与运行时间之和）

系统性能：平均作业周转时间

带权周转时间：$W_i=\frac{T_i}{T{ki}}$（T~ki~ 为运行时间）

响应时间：交互式进程从提交一个请求到接受到相应的时间间隔

#### **处理机调度的层次**

作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度

- **高级调度**（作业调度 / 长程调度）

    - 启动、进入系统时
    - 决定外存上后备队列的哪几个作业调入内存

    - 调度对象是作业，主要用于多道批处理系统中。

- **中级调度**（内存调度 / 平衡调度）

    - 挂起 / 唤醒，做内外存的对换

    - 主要目的是提高内存利用率和系统吞吐量。

- **低级调度**（进程 / 线程调度）

    - 决定就绪队列中的哪个进程获得处理机

    - 调度对象是进程（内核级线程），基本调度
    - 在多道批处理、分时和实时三种类型的 OS 中，都必须配置这级调度。

#### **处理机调度算法目标**

##### 处理机调度算法的共同目标

- **资源利用率**
    -  \($CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$\)
- **公平性**
- 诸进程都获得合理的 CPU 时间，不会发生**进程饥饿**现象
- **平衡性**
- CPU 都能经常处于忙碌状态；系统资源的平衡性
- **策略强制执行**
    - 如安全策略

##### **批处理系统的目标**

- **平均周期时间短**
- **周转时间**：从作业被提交给系统开始，到作业完成为止的这段时间间隔，包括作业在外存后备队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在CPU上执行的时间，以及进程等待I/O操作完成的时间。
    - 平均周转时间最短，有效提高系统资源利用率，可使大部分用户满意。
- 平均周转时间：$ (T=\frac{1}{n}[\sum_{i=1}^{n}{T_i}])$ 平均带权周转时间： $(W=\frac{1}{n}\sum_{i=1}^{n}{\frac{T_i}{T_s}})$ 作业周转时间$T$，系统为其服务时间$T_s$
- **系统吞吐量高**
    - **吞吐量**：在单位时间内系统所完成的作业数
- **处理机利用率高**

##### **分时系统的目标**

- **响应时间快**
- 响应时间：从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔。
- **均衡性**
    - 均衡性：系统响应时间的快慢应与用户所请求服务的复杂性相适应。

##### **实时系统的目标**

- **截止时间的保证**
- 截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间
- **可预测性**

### 作业与作业调度

#### 概念

**进程**：程序段 + 数据 + PCB

**作业**（Job）：包含程序、数据、作业说明书。

**作业步**：完成作业的每一个加工步骤。

**作业控制块**（JCB Job Control Block）：是作业在系统中存在的标志。

#### **作业运行的三个阶段和三种状态**

输入、后备、执行、完成

1. 收容阶段（后备状态）：建立 JCB 进入后备队列
2. 运行阶段（运行状态）：分配资源、运行
3. 完成阶段（完成状态）：完成

#### **作业调度的主要任务**

1. 接纳多少个作业（允许多少个作业同时在内存中运行）
2. 接纳哪些作业（取决于所采用的调度算法）

#### **先来先服务 FCFS 调度算法**

（First  Coming First Serverd）

作业调度 √，进程调度 √

系统按照**作业到达的先后顺序**来进行调度，优先考虑**等待时间最长**的作业。

有利于长作业(进程)，不利于短作业(进程)

有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业

#### **短作业优先 SJF 调度算法**

作业调度 √，进程调度 √

以**作业长短**来计算优先级，作业越短，优先级越高。作业的长短是以作业所要求的**运行时间**来衡量的。

*缺点*：

- 必须预知作业的运行时间
- 对长作业非常不利
- 人-机无法交互
- 未考虑作业的紧迫程度

#### **优先级调度PSA算法**

作业调度√，进程调度√

基于作业的**紧迫度**，由**外部**赋予作业相应的优先级。

#### **高响应比优先调度HRRN算法**

进程都到之后开始计算优先权。

**动态优先级** \(优先权=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}=响应比R_p\)

- 作业等待时间相同，服务时间越短，优先级越高
- 要求服务时间相同，等待时间越长，优先级越高
- 厂作业优先级可以随等待时间的增加而提高

缺点：每次调度都需计算

### 进程调度

**进程调度的任务**

- 保存处理机的现场信息
- 按某种算法选取进程
- 把处理器分配给进程

**进程调度机制**

- 排队器
- 分派器
- 上下文切换器

**进程调度方式**

- 非抢占方式：一旦分配给某进程，就一直让它运行下去。
    - 正在执行的进程运行完毕，或因发生某时间而使其无法再继续运行
    - 正在执行中的进程因提出I/O请求而暂停执行
    - 进程通信或同步过程中，执行了某种原语操作
- 抢占方式：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程
    - 优先权原则
    - 短进程优先原则
    - 时间片原则

**轮转调度RR算法**

- 一个时间片尚未用完，正在允许的进程便已完成
- 在一个时间片用完时，计时器中断处理程序被激活，若进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。

**多级反馈队列调度算法**

- 设置多个就绪队列（优先级逐个降低，时间片逐个增大）
- 每个队列都采用FCFS算法（新进程进入，加入第一队列末尾，若未在时间片内完成，则到第二队列末尾）
- 按队列优先级调度

**调度算法的性能**

- 终端型用户
- 短批处理作业用户
- 长批处理作业用户

### 死锁概述

死锁产生原因：**多个进程对资源的争夺**

- 竞争不可抢占性资源引起死锁
- 竞争可消耗资源引起死锁
- 进程推进顺序不当引起死锁

如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是**死锁**的。

产生死锁的**必要条件**：

- 互斥条件
- 请求和保持条件
- 不可抢占条件
- 循环等待条件

**处理死锁**的方法：

- 预防死锁
- 避免死锁
- 检测死锁
- 解除死锁

**预防死锁**

破坏四个必要条件之一，其中互斥不能破坏。

- 破坏“请求和保持”条件：进程在中间不会请求新的资源
- 破坏“不可抢占”条件：不可抢占→可抢占，影响进程执行效率
- 破坏“循环等待”条件：规定每个进程必须按序号递增的顺序请求资源

**避免死锁**

*安全状态*：系统能按某种进程推进顺序（$P_1,P_2,…,P_n$）为每个进程$P_i$分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。

==**银行家算法避免死锁**==

四个数据结构：

- **可利用资源向量Available**

- **最大需求矩阵Max**

- **分配矩阵Allocation**

- **需求矩阵Need**

    $Need[i,j]=Max[i,j]-Allocation[i,j]$

**银行家算法**：

1. $Request_i[j]≤Need[i,j]$，便转向步骤2；否则认为出错。

2. $Request_i[j]≤Available[j]$，便转向步骤3；否则表示尚无足够资源，$P_i$须等待。

3. 系统试探着把资源分配给进程$P_i$，并修改下面数据结构中的数值：

    $Available[j]=Available[j]-Request_i[j];$

    $Allocation[i,j]=Allocation[i,j]+Request_i[j];$

    $Need[i,j]=Need[i,j]-Request_i[j];$

4. 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态，若安全才正式将资源分配 给进程$P_i$，否则作废，恢复原来的资源分配状态。

**安全性算法**：

1. 设置两个向量：

    - 工作向量Work，表示系统可提供给进程继续运行所需的各类资源数目，$Work=Available$
    - Finish，表示系统是否有足够的资源分配给进程，使之运行完成。开始时$Finish[i]=false$；当有足够资源分配给进程时，$Finish[i]=true$

2. 从进程集合中找到一个能满足下述条件的进程

    - $Finish[i]=false$
    - $Need[i,j]≤Work[j]$

    若找到，执行步骤3，否则执行4

3. 当进程$P_i$获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行：

    $Work[j]=Work[j]+Allocation[i,j];$

    $Finish[i]=true;$

    go to step 2

4. 如果所有进程的Finish[i]=true都满足，则表示系统处于安全状态。

### 死锁的检测与解除

**资源分配图**

S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。

**解除死锁**

- 抢占资源
- 终止（或撤销）进程
