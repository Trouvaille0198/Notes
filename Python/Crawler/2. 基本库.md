# 一、urllib

## 1. 模块介绍

1. request：它是最基本的HTTP请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入URL以及额外的参数，就可以模拟实现这个过程了。

2. error：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。

3. parse：一个工具模块，提供了许多URL处理方法，比如拆分、解析、合并等。

4. robotparser：主要是用来识别网站的robots.txt文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少

## 2. 发送请求

使用urllib.equest模块，我们可以方便地实现请求的发送并得到响应

### 2.1 urlopen()

``` python
	import urllib.request
	response = urllib.request.urlopen("https://www.python.org")
    print(response.read().decode('utf-8'))
```

输出：网页源代码

#### 2.1.1 利用type()方法输出响应的类型

``` python
	print(type(response))
```

输出：`<class 'http.client.HTTPResponse'>`

可以发现，它是一个HTTPResposne类型的对象。它主要包含read()、readinto()、getheader(name)、getheaders()、fileno()等方法，msg、version、status、reason、debuglevel、closed等属性

#### 2.1.2调用方法和属性

```python
print(response.status)
print(response.getheaders())
print(response.getheader('Server'))
```

输出：响应的状态码，响应的头信息，响应头中的Server值

``` markdown
200
 [('Server', 'nginx'), ('Content-Type', 'text/html; charset=utf-8')……('Strict-Transport-Security', 'max-age=63072000; includeSubDomains')]
 nginx
```

#### 2.1.3 urlopen()函数的API

`urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None)`

1. data参数

   - 如果传递了这个参数，则它的请求方式就不再是GET方式，而是POST方式

   - 如果它是字节流编码格式（bytes类型），则需要通过bytes()方法转化

   - 例

     ``` python
     import urllib.parse
     import urllib.request
     data = bytes(urllib.parse.urlencode({'name': 'germey'}), encoding='utf-8')
     response = urllib.request.urlopen('https://httpbin.org/post', data=data)
     print(response.read().decode('utf-8'))
     ```

     第一个参数需要是str类型，需要用urllib.parse模块里的urlencode()方法来将参数字典转化为字符串

     第二个参数指定编码格式，这里指定为utf8

     输出：

     ``` markdown
     		{
     		  "args": {},
     		  "data": "",
     		  "files": {},
     		  "form": {
     			    "name": "germey"
     				  },
     		  "headers": {
     	      		"Accept-Encoding": "identity",
     		  		"Content-Length": "11",
     				"Content-Type": "application/x-www-form-urlencoded",
     				"Host": "httpbin.org",
     				"User-Agent": "Python-urllib/3.7",
     				"X-Amzn-Trace-Id": "Root=1-5f96de5b-6805a3ac7b7b4b151a11fdc6"
     					},
     			"json": null,
     			"origin": "59.79.2.148",
     			"url": "https://httpbin.org/post"
               }
     ```

2. timeout参数

   用于设置超时时间，单位为秒，意思就是如果请求超出了设置的这个时间，还没有得到响应，就会抛出异常。如果不指定该参数，就会使用全局默认时间。它支持HTTP、HTTPS、FTP请求。

   - 例一

     ``` python
     import urllib.request
     response = urllib.request.urlopen('https://httpbin.org/get', timeout=0.1)
     print(response.read())
     ```

     程序1秒过后，服务器依然没有响应，于是抛出了URLError异常。该异常属于urllib.error模块，错误原因是超时

   - 例二

     可以通过设置这个超时时间来控制一个网页如果长时间未响应，就跳过它的抓取。这可以利用try except语句来实现

     ``` python
     import urllib.request
     import socket
     import urllib.error
     try:
     	response = urllib.request.urlopen('http://httpbin.org/get', timeout=0.1)
     except urllib.error.URLError as e:
     	if isinstance(e.reason, socket.timeout):
     		print('TIME OUT')
     ```

     这里我们请求了<http://httpbin.org/get>测试链接，设置超时时间是0.1秒，然后捕获了URLError异常，接着判断异常是socket.timeout类型（意思就是超时异常），从而得出它确实是因为超时而报错，打印输出了TIME OUT

3. 其他参数
   - context参数，它必须是ssl.SSLContext类型，用来指定SSL设置。
   - cafile和capath这两个参数分别指定CA证书和它的路径，这个在请求HTTPS链接时会有用。
   - cadefault参数现在已经弃用了，其默认值为False

### 2.2 Request

如果请求中需要加入Headers等信息，就可以利用更强大的Request类来构建

``` python
import urllib.request
request = urllib.request.Request('https://python.org')
response = urllib.request.urlopen(request)
print(response.read().decode('utf-8'))
```

我们依然是用urlopen()方法来发送这个请求，只不过这次该方法的参数不再是URL，而是一个Request类型的对象。通过构造这个数据结构，一方面我们可以将请求独立成一个对象，另一方面可更加丰富和灵活地配置参数

#### 2.2.1 使用参数来构造Request

`class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None)`

1. url用于请求URL，这是必传参数，其他都是可选参数

2. data如果要传，必须传bytes（字节流）类型。如果它是字典，可以先用urllib.parse模块里的urlencode()编码

3. headers是一个字典，它就是请求头，可以在构造请求时通过headers参数直接构造，也可以通过调用请求实例的add_header()方法添加

   添加请求头最常用的用法就是通过修改User-Agent来伪装浏览器，默认的User-Agent是Python-urllib，我们可以通过修改它来伪装浏览器。比如要伪装火狐浏览器，你可以把它设置为`Mozilla/5.0 (X11; U; Linux i686) Gecko/20071127 Firefox/2.0.0.11`

4. origin_req_host指的是请求方的host名称或者IP地址。

5. unverifiable表示这个请求是否是无法验证的，默认是False，意思就是说用户有足够权限来选择接收这个请求的结果。

   例如，我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时unverifiable的值就是True。

6. method是一个字符串，用来指示请求使用的方法，比如GET、POST和PUT等

   例

   ```python
   from urllib import request, parse
   url = 'https://httpbin.org/post'
   headers = {
   	'User-Agent': 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)',
   	'Host': 'httpbin.org'
   }
   dict = {'name': 'germey'}
   data = bytes(parse.urlencode(dict), encoding='utf-8')
   req = request.Request(url=url, data=data, headers=headers, method='POST')
   response = request.urlopen(req)
   print(response.read().decode('utf-8'))
   ```

   其中url即请求URL，headers中指定了User-Agent和Host，参数data用urlencode()和bytes()方法转成字节流。另外，指定了请求方式为POST

   输出

   ```markdown
   		{
   			"args": {},
   			"data": "",
   			"files": {},
   			"form": {
   					"name": "germey"
   			        },
   			"headers": {
   				 "Accept-Encoding": "identity",
   				 "Content-Length": "11",
   				 "Content-Type": "application/x-www-form-urlencoded",
   				 "Host": "httpbin.org",
   				 "User-Agent": "Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)",
   				 "X-Amzn-Trace-Id": "Root=1-5f96e6c8-0c429d0c205ce45b3365653e"
   			           },
   			"json": null,
   			"origin": "59.79.2.148",
   			"url": "https://httpbin.org/post"
   		}
   
   ```

   另外，headers也可以用add_header()方法来添加

   ```python
   	req = request.Request(url=url, data=data, method='POST')
   	req.add_header('User-Agent', 'Mozilla/4.0 (compatible; MISE 5.5; Windows NT)')
   ```

### 2.3 高级操作

1. 对于一些更高级的操作（比如Cookies处理、代理设置等），需要使用更强大的工具Handler来实现。我们可以把Handler理解为各种处理器，有专门处理登录验证的，有处理Cookies的，有处理代理设置的。利用它们，我们几乎可以做到HTTP请求中所有的事情

2. 另一个比较重要的类就是`OpenerDirector`（Opener）`urlopen()`实际上就是urllib为我们提供的一个Opener。之前使用的Request和urlopen()相当于类库为你封装好了极其常用的请求方法，利用它们可以完成基本的请求。Opener可以使用`open()`方法，返回的类型和`urlopen()`如出一辙。可以利用Handler来构建Opener。

## 3. 处理异常

`urllib`的`error`模块定义了由request模块产生的异常。如果出现了问题，`request`模块便会抛出`error`模块中定义的异常

### 3.1 URLError

它具有一个属性reason，即返回错误的原因

```python
	from urllib import request, error
	try:
		response = request.urlopen('https://cuiqingcai.com/404')
	except error.URLError as e:
    	print(e.reason)
```

打开一个不存在的页面，捕获了URLError这个异常

输出：`Not Found`

### 3.2 HTTPError

它是`URLError`的子类，专门用来处理HTTP请求错误

- 属性
  - code：返回HTTP状态码，比如404表示网页不存在，500表示服务器内部错误等。
  - reason：同父类一样，用于返回错误的原因。
  - headers：返回请求头

- 例

  ```python
  from urllib import request, error
  try:
  	response = request.urlopen('https://cuiqingcai.com/404')
  except error.HTTPError as e:
  	print(e.reason, e.code, e.headers, sep='\n')
  ```

  输出

  ```markdown
  	Not Found
  	404
  	Server: nginx/1.4.6 (Ubuntu)
  	Date: Wed, 03 Aug 2016 08:54:22 GMT
  	Content-Type: text/html; charset=UTF-8
  	Transfer-Encoding: chunked
  	Connection: close
  	X-Powered-By: PHP/5.5.9-1ubuntu4.14
  	Vary: Cookie
  	Expires: Wed, 11 Jan 1984 05:00:00 GMT
  	Cache-Control: no-cache, must-revalidate, max-age=0
  	Pragma: no-cache
  	Link: <http://cuiqingcai.com/wp-json/>; rel="https://api.w.org/"
  ```

  捕获了`HTTPError`异常，输出了reason、code和headers属性

- 因为`URLError`是`HTTPError`的父类，所以可以先选择捕获子类的错误，再去捕获父类的错误

  所以上述代码更好的写法如下

  ```python
  from urllib import request, error
  try:
  	response = request.urlopen('https://cuiqingcai.com/404')
  except error.HTTPError as e:
  	print(e.reason, e.code, e.headers, sep='\n')
  except error.URLError as e:
  	print(e.reason)
  else:
  	print('Request Successfully')
  ```

  这样就可以做到先捕获`HTTPError`，获取它的错误状态码、原因、headers等信息。如果不是`HTTPError`异常，就会捕获`URLError`异常，输出错误原因。最后，用`else`来处理正常的逻辑。这是一个较好的异常处理写法

- reason属性返回的不一定是字符串，也可能是一个对象

  ```python
  	import socket
  	import urllib.request
  	import urllib.error
  	try:
  		response = urllib.request.urlopen('https://www.baidu.com', timeout=0.01)
  	except urllib.error.URLError as e:
  		print(type(e.reason))
  		if isinstance(e.reason, socket.timeout):
  			print('TIME OUT')
  ```

  这里我们直接设置超时时间来强制抛出timeout异常。

  输出

  ```markdown
   <class 'socket.timeout'>
   TIME OUT
  ```

可以发现，`reason`属性的结果是`socket.timeout`类。所以，这里我们可以用`isinstance()`方法来判断它的类型，作出更详细的异常判断