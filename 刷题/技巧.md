# 技巧

## array

### 双指针

计算过程仅与**两端点相关**的称为双指针。

- 快慢指针：都从头开始，遍历条件不同，所以速度不同

- 头尾指针：一个从头，一个从尾；二分法就是一种头尾指针

### 滑动窗口

计算过程与**两端点表示的区间相关**的称为滑动窗口。

滑动窗口本身并不是解决问题的一种方法（或者说算法），它其实就是**问题本身**。

滑动窗口一定是**同向移动**的。

### 二分

二分搜索有 4 大基础变种题：

1. 查找**第一个**值等于给定值的元素
2. 查找**最后一个**值等于给定值的元素
3. 查找**第一个大于等于**给定值的元素
4. 查找**最后一个小于等于**给定值的元素

```go
package leetcode

// 二分查找第一个与 target 相等的元素，时间复杂度 O(logn)
func searchFirstEqualElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + (high - low) >> 1 // or (low + high) >> 1
		if nums[mid] > target {
			high = mid - 1
		} else if nums[mid] < target {
			low = mid + 1
		} else {
			if (mid == 0) || (nums[mid-1] != target) { 
                // 找到第一个与 target 相等的元素
				return mid
			}
			high = mid - 1
		}
	}
	return -1
}

// 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn)
func searchLastEqualElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] > target {
			high = mid - 1
		} else if nums[mid] < target {
			low = mid + 1
		} else {
			if (mid == len(nums)-1) || (nums[mid+1] != target) { 
                // 找到最后一个与 target 相等的元素
				return mid
			}
			low = mid + 1
		}
	}
	return -1
}

// 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn)
func searchFirstGreaterElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] >= target {
			if (mid == 0) || (nums[mid-1] < target) { 
                // 找到第一个大于等于 target 的元素
				return mid
			}
			high = mid - 1
		} else {
			low = mid + 1
		}
	}
	return -1
}

// 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn)
func searchLastLessElement(nums []int, target int) int {
	low, high := 0, len(nums)-1
	for low <= high {
		mid := low + ((high - low) >> 1)
		if nums[mid] <= target {
			if (mid == len(nums)-1) || (nums[mid+1] > target) { 
                // 找到最后一个小于等于 target 的元素
				return mid
			}
			low = mid + 1
		} else {
			high = mid - 1
		}
	}
	return -1
}
```

## 树

### 二叉树的遍历

#### 先序遍历

最简单

1. 初始头节点入栈
2. 每次从栈中取一个节点，打印之，再把它的右节点、左节点先后入栈

#### 后序遍历

跟先序很像，相当于反着的先序

区别：

- 从栈中取出的节点放进一个数组中；最后在数组中输出

- 入栈顺序是先右后左

#### 中序遍历

相对难一点
