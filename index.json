[{"categories":["专业课"],"content":"操作系统二 判断 20*1 单选 20*1 填空 20*1 简答、综合 两个答题各有三个小题 共 4 存储器管理 40% 文件管理（含实验，命令 + 系统调用部分） 35% 命令在上学期实验里，也要看 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:0:0","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"第四章 存储器管理 （内存分配：分配和去配，地址映射：抽象和映射，内存保护：隔离和共享，内存扩充：存储扩充） 1、3、5 重要，2、4 自学 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:0","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"存储器的层次结构 多结构的存储器系统 存储器的六层结构 CPU 寄存器 主存储器：高速缓存、主存储器、磁盘缓存（内存中，不是个独立的设备） 辅存储器：固定磁盘、可移动磁盘 可执行存储器：寄存器、主存储器 辅存属于设备管理和文件管理范畴 主存储器与寄存器 主存储器：保存进程运行时的程序和数据 寄存器：存放处理运行时的数据 高速缓存与磁盘缓存 高速缓存：备份主存中较常用的数据，减少处理机对主存的访问次数 磁盘缓存：暂时存放频繁使用的一部分磁盘数据和信息，以减少访问磁盘的次数 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:1","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"程序的装入和链接 自学 程序在系统中运行，需要先装入内存，然后经过以下过程： 编译：由编译程序编译形成若干个目标模块 链接：将模块与库函数链接在一起，形成完整的装入模块 装入：由装入程序将装入模块装入内存 程序的链接 静态链接方式 在程序运行前完整链接。需要拷贝全部模块。 在外存完成链接 需要解决的问题 对每个模块相对地址进行修改 变换外部调用符号 装入时动态链接 边装入边链接 便于修改和更新（修改模块时不需要重新打开装入模块） 便于实现模块的共享（时分复用） 在内存完成链接 运行时动态链接 Run-time Dynamic Linking 对某些模块的链接推迟到执行时链接 链接实际运行用到的模块，节省内存 程序的装入 术语 逻辑地址：装入程序的地址都是从 0 开始 物理地址：主存中一系列存储信息的物理单元的地址 重定位：逻辑地址（相对地址）到物理地址（绝对地址）的映射 绝对装入方式 (Absolute Loading Mode) 程序编译后直接产生物理地址 适用单道系统 可重定位装入方式 也叫静态重定位 Relocation Loading Mode 装入时根据内存情况对指令地址和数据地址进行相应偏移 地址变换在装入时一次完成，此后不再改变；无需硬件支持 属于静态重定位 动态运行时装入方式 Dynamic Run-time Loading 装入内存后仍然是逻辑地址，地址转换推迟到执行时进行 绝对地址的转换有硬件支持（重定位寄存器） 能保证进程的可移动性 需要重定位寄存器；支持程序在内存中浮动；不要求占用连续空间 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:2","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"连续分配存储管理方式 单一连续分配 为一个用户程序分配一个连续的内存空间 用于单用户、单任务的操作系统中。 将内存划分为 系统区 用户区 用户区内存由一道程序独占 适合绝对装入方式 固定分区分配 将用户内存划分多个分区，每个分区一道程序独占 划分分区的方法 分区大小相等 分区大小不相等 内存分配 将分区按大小排队（一般由小到大），建立分区使用表（起址、大小、状态） 程序装入时，由内存分配程序检索分区使用表，找到符合要求的分区，并进行标记 特点 使用分区说明表标识分区分配状态 适合静态重定位装入方式 会造成内碎片（属于某程序但未被使用的碎片） 动态分区分配 根据进程实际需要动态地分配内存 会存在外碎片（不属于任何程序的碎片） 分配中的数据结构 空闲分区表：序号、起址、大小 空闲分区链表：双向链表，状态信息、分区大小、指针 步骤 从空闲分区表中找一个足以容纳改作业的空闲区 若这个分区比较大，则一分为二 一部分分配给作业，另一部分仍作为空闲区留在表内 分区分配操作 分配内存 回收内存 碎片问题 不修改程序即可进行紧凑，需要硬件支持 紧凑：通过移动内存中作业的位置，把多个小分区拼成大分区的方法 动态重定位及其分区分配算法 以下三节为连续分配存储管理方式的分配算法 基于顺序搜索的动态分区分配算法 ☆ 首次适应 (first fit, FF) 空闲分区按起址递增次序排列，从头开始直至找到第一个满足要求的空闲分区 内存低端会留下小的空闲区，高端有大的空闲区 优点：算法简单，保留高地址大空闲区 缺点：外碎片，查找效率低 循环首次适应 (下次适应，next fit, NF) 从上次分配的位置之后开始查找 优点：减少查找开销，空闲分区分布均匀 缺点：缺乏大空闲分区 最佳适应 (best fit, BF) 搜索整个序列，找到适合条件的最小的分区进行分配 优点：保留大空闲分区 缺点：留下大量难以利用的外碎片；查找效率低 最坏适应 (worst fit, WF) 空闲分区按大小从大到小的次序排列，最前面的最大的空闲分区就是找到的分区 优点：分割后空闲块仍为较大空块，剩余空间最大化；不会出现太小的外碎片 缺点：缺乏大空闲分区，一段时间后就不能满足对于较大空闲区的分配要求 基于索引搜索的动态分区分配算法 快速适应 (quick fit) 步骤 空闲分区按容量大小进行分类 对于每一类具有相同容量的所有空闲空间分区，单独设立一个空闲分区链表 系统中存在多个空闲分区链表 在内存中设立一张管理索引表 每个表项对应一种空闲分区类型 记录了空闲分区链表的表头指针 优点 查找效率高，O(1) 保留大分区 无外碎片 缺点 归还时算法复杂，系统开销大 仍有一定空间浪费 伙伴系统 ☆ buddy system 将内存按 2 的幂次划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配快。适用离散分配方式 分配原则：比一半大，又占不满整块；否则一分为二 步骤 对不连续的空闲分区，按分区大小进行分类。对具有相同大小的所有空闲分区，单独设立一个空闲分区双向链表，即会存在 k 个空闲分区链表 分配时 设需分配长度为 n，找 2^i^ 分区链的分区，使 2^i-1^ \u003c n \u003c 2^i^ 若无，找 2^i+1^ 且把它均分两块，称为伙伴；一个加入 2^i^ 分区链，一个分配 回收时，若已存在 2^i^ 空闲分区，则将其于伙伴合并为 2^i+1^ 分区，….. $$ buddy_k(x)= \\begin{cases} \\ x+2^k \\ (if \\ x \\ MOD \\ 2^{k+1}=0) \\\\ x-2^k \\ (if \\ x \\ MOD \\ 2^{k+1}=2^k) \\end{cases} $$ 优点 查找效率高 能保留大的分区 其性能取决于查找空闲分区的位置和分割、合并的时间。 时间上不及快速适应算法，但空闲分区的使用率高 哈希算法 实现快速查找 unordered_map\u003c分区大小, 空闲分区链表\u003e 利用哈希快速查找的优点，以及空闲分区在可利用空闲区表中的分布规律，建立哈希函数。 构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表。 分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，找到对应的空闲分区表。 优点：查找快速 动态可重定位分区分配算法 不重要 空闲分区总和大于需求但无法找到单一连续可用区间时，进行紧凑 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:3","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"对换技术 贮存不足的存储管理技术有：移动（紧凑）、对换、覆盖 对换 (swapping)：将内存中不能运行的进程或暂时不用的程序和数据换出到外存上，以便腾出足够的内存空间，再把具备运行条件的进程和数据换入内存，也称交换。 对换是改善内存利用率的有效措施，实际上就是被挂起 对换类型 整体对换：即处理机低级调度（进程调度），上下文切换，以进程为单位 页面（分段）对换：按页或段进行对换，是请求分页、请求分段存储管理的基础 对换空间的管理 外存的划分：文件区、对换区 管理方式：空闲分区表、空闲分区链 分配算法：首次适应法、循环首次适应法、最佳适应法 进程的换入换出 换出 选择处于阻塞状态且优先级最低的进程 将该进程的程序和数据传送到磁盘的对换区上 回收内存空间，修改该进程的 PCB 换入 定时查看进程状态，选择就绪的换出进程 将处于就绪态的，换出时间最久的进程换入内存 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:4","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"分页存储管理方式 连续分配方式的不足，促使人们产生了离散分配的管理思想。从而引入了“分页”分配管理的管理方式。分为：基本分页（纯分页）和支持虚存管理的请求分页管理 连续内存分配方式：单一连续分配、固定分区分配、动态分区分配、动态可重定位分区分配 离散内存分配方式：分页存储管理方式、分段存储管理方式、段页式存储管理方式 页面与物理块（页框） 分页存储管理器将逻辑地址按页分割，将物理地址按块分割； 页面和物理块 页面 将一个进程的逻辑地址空间分成若干个大小相等的区域，称为页面或页，并加以编号，从 0 开始；页内地址从 0 开始编址 页的大小一般为 2 的整数次幂 页面大小 过小，减小内存碎片；同时页表过长，降低页面换进换出的效率 过大，可以减少页表长度，提高页面换进换出效率；页面碎片增多 物理块 将内存的物理空间分成若干个块 在为进程分配内存时，以块为单位，将进程的若干个页装入不相邻的物理块中。（会产生页内碎片） 地址结构 将逻辑地址分为：页号 P | 位移量 W（位移量即页内偏移地址） 已知逻辑地址和页面大小，求其页号和页内地址 页表 分页系统中，将进程的每一页离散地址存储在内存的任一物理块中；系统为每个进程设立一张页表。页表实现从页号到物理块号的映射 页表存放在内存中 页表并没有页号项，因为它是递增的，不需要记录 页表的表项有：物理块号（表现为指向页框的指针）和存取控制字段 每一个表目称为页描述子 地址变换机构 基本的地址变换机构 页表设置一个页表寄存器（PTR），存放页表在内存中的始址和页表的长度 过程：逻辑地址分割后产生页号和偏移量，通过页表寄存器中页表长度判断是否越界中断，如无中断则通过页表始址查询页表得到物理块号，结合偏移量得到物理地址 每次存 / 取要两次访问内存（访问页表、访问内存找到物理地址） 页号 * 页表项长度 + 页表始址 TODO：转二进制获取地址 具有快表的地址变换机构 联想寄存器 / 快表：一个具有并行查询能力的特殊高速缓冲寄存器 过程：先查快表再查页表 内存访问的有效时间 设访问内存时间为 t ，快表查询时间为 λ ，命中率为 a ： 不使用快表：$EAT=t+tEAT=t+t=2t$ 使用快表： $EAT=aλ+(1−a)(λ+t)+tEAT=aλ+(1−a)(λ+t)+t$ 两级和多级页表 多级页表直将需要的页表调入内存 不同被调入的页表离散存储在内存空间中 外层页表偏移页号指向内层页表地址，最后指向内存空间 反置页表 存进程标识和页号，以物理块号为下标的顺序表 逻辑地址：PID + 页号 + 页内偏移 现代计算机系统允许一个进程逻辑地址空间远大于分配的内存空间。此时采用物理块号向页号反向查表更能节省页表的占用空间。在整个反置页表检索进程标识符和页号，找到匹配的页表项则将该项的物理块号（即下标）和页偏移地址合并作为物理地址。如果查不到，则表明该页号缺页，需要检索外部页表，并进行调页。 例 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:5","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"分段存储管理方式 程序按照逻辑关系天然地划分为段 引入 分页的意义 使内存的离散分配成为可能，提高内存利用率 分段的意义 方便编程：每个段始址为 0，转移直观 信息共享：段可以包含完整逻辑，方便共享 信息保护：段整体作为保护对象 动态增长：数据段的动态增加 动态链接：分段是动态链接的前提 分段基本原理 分段：分段地址划分决定了段的最大个数和每个段的最大内存长度（参考子网划分） 段表：记录段长和基址（在内存中的起始地址） 地址变换机构：同分页地址变换机构 分页和分段的区别 页是信息的物理单位，对用户透明；段是信息的逻辑单位，满足用户需要 页的大小由系统决定；段的大小由信息性质划分 分页的用户程序地址空间是一维的；分段的用户程序地址空间有两维 信息共享 分段易于实现程序和数据的共享 不同进程需要共享一个段（可重入代码），只需要相同基址即可 段页式存储管理方式 基本原理 将用户程序分为若干个段，再把每个段分成若干个页 逻辑地址：段号 | 段内页号 | 页内地址 段表：存放页表大小和页表始址 地址变换过程 段页式存储管理方式中，访问一条指令或数据需要访问三次内存 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:6","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"本章结构 存储器管理： 连续分配方式： 单一连续分配 分区式分配 固定分区分配 动态分区分配 基于顺序搜索的动态分区分配：FF、NF、BF、WF 基于索引搜索的动态分区分配：QF、Buddy、Hash 动态可重定位分区分配 离散分配方式：虚拟的必要条件 分页存储管理 基本分页存储管理 请求分页存储管理（虚拟存储器） 分段存储管理 基本分段存储管理 请求分段存储管理（虚拟存储器） 段页式存储管理 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:1:7","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"第五章 虚拟存储器 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:0","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"虚拟存储器概述 虚存容量由主存辅存的容量之和确定 局部性原理 局部性原理是虚拟内存有效性的前提 时间局部性（短时间多次访问同一处） 空间局部性（短时间访问临近地址） 传统存储器的特征 一次性：作业一次性全部装入内存 驻留性：作业完整驻留在内存 虚存技术以 cpu 时间和外存空间换取昂贵的内存空间 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:1","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"虚拟存储器的定义和特征 定义：具有请求调入和置换功能，能从逻辑上对内存容量扩充的存储器系统 特征 多次性：一个作业的程序和数据允许多次调入内存 对换性：允许作业的程序和数据在运行时被换进换出 虚拟性：能从逻辑上扩充内存容量 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:2","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"请求分页存储管理方式 硬件支持 请求分页的页表机制 页表项除了物理块号外，添加状态位、访问字段、修改位和外存地址 缺页中断机构 （特殊的中断响应机构） 每当要访问的页面不在内存中时，就会产生一个缺页中断，请求系统将之调入内存 与一般中断的区别 缺页中断发生在指令执行期并立即响应。普通中断在微操作内不响应 执行一条指令可能发生多次缺页中断 (copy A to B 最高可达六次) 地址变换机构 添加缺页中断、页面写入或置换的过程 请求分页中的内存分配 最小物理块数确定 保证进程正常运行所需的最小物理块数，与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式 取决于一次指令最多发生的缺页中断数 内存分配策略 分配策略：固定分配和可变分配 置换策略：全局置换和局部置换 固定分配局部置换：进程内存大小固定，置换被分配的页 可变分配全局置换：缺页即获得新的页面，直至内存占满开始置换 可变分配局部置换：置换被分配的页，若缺页太多增加内存大小 物理块分配算法 平均分配：进程平均分配内存 按比例分配：进程按需求占比分配 优先权分配：考虑紧迫程度（可分配内存分两部分，一部分按比例、，一部分按优先级） 页面调入策略：何时调入、何处调入、调入过程、缺页率 影响缺页率的因素：页面大小、进程分配物理块数、页面置换算法、程序固有特性 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:3","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"页面置换算法 ☆ 最佳置换算法 OPT 置换了 6 次，缺页了 9 次 先进先出置换 FIFO 总是淘汰最先进入内存的页面；建立替换指针始终指向最老的页面 现象：页框数越多，缺页次数反而增加 最近最久未使用 LRU Least Rencently Used 移位寄存器值最小的被替换 硬件支持 寄存器 具有最小值的寄存器所对应的页面，就是最近最久未使用的页面 栈 最少使用 LFU 移位寄存器 pop_count 最小的被替换 最近未使用 NRU（简单 CLOCK 置换） 置换最近未使用的页面 页表设置访问位，指针连成循环链表 改进 CLOCK 置换 页表设置访问位、修改位；访问位优先权高 页面缓冲算法 PBA Page Buffering Algorithm，是对 FIFO 的发展 影响请求分页存储管理的因素：页面置换算法，磁盘写回频率，内存读入频率 系统保留一片空闲物理块用以降低经常缺页的进程的缺页率： 空闲页面链表：将进程换下的未修改页面暂存。减少读入频率 修改页面链表：将进程换下的修改页面暂存。减少读入频率；成批写入，减少写回频率 访问内存的有效时间： 设访问/更新快表时间 λ，访问内存需要时间 t ，缺页中断时间 ε 页面在快表中： EAT=λ+tEAT=λ+t 查快表==\u003e访内存查值 页面在页表中： EAT=λ+t+λ+tEAT=λ+t+λ+t 查快表==\u003e访内存查页表==\u003e更新快表==\u003e访内存查值 缺页：EAT=λ+t+ε+λ+tEAT=λ+t+ε+λ+t 快表==\u003e页表==\u003e中断==\u003e更新快表==\u003e内存 设命中率 a，缺页率 f ，则平均访问时间： EAT=a(λ+t)+(1−a)((1−f)(2λ+2t)+f(2λ+2t+ε))=(2−a)(λ+t)+εf(1−a)EAT=a(λ+t)+(1−a)((1−f)(2λ+2t)+f(2λ+2t+ε))=(2−a)(λ+t)+εf(1−a) 2，1，0，2 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:4","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"抖动和工作集 多道程序度与抖动 抖动：在请求分页存储管理中，反复出现从主存中刚换出一页根据请求马上又换入的现象，调用页面时间甚至比程序实际运行的时间还多 表现：随着进程数增多，处理机利用率先增大后减小 产生原因：系统中运行进程太多，分配给每一个进程的物理块太少，进程内存分配无法满足正常运行的基本需求 工作集 工作集：某段时间间隔 $\\Delta$ 里进程实际要访问的页面集合 记录工作集，置换不在工作集内的页面，过去某时段内作为其将来时段的近似 预防抖动的办法 局部置换 不允许进程扩展页数，将抖动限制在一些进程上（效果差） 引入工作集算法 比较各进程工作集大小和实际得到的内存，再决定是否增加进程 L = S 准则 使缺页平均间隔 = 调页平均时间 挂起 选择进程暂停 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:5","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"请求分段存储管理方式 请求分段中的硬件支持 请求段表机制 段名、段长、段基址 存取方式：控制读写执行，实行逻辑保护 访问字段：访问频繁程度 修改位：是否被修改 存在位：是否在内存中 增补位：该段是否在运行中发生了动态增长 外存始址：盘块号 缺段中断机构 地址变换机构 分段的共享与保护 共享 段表中增加进程计数 count（参考 shared_ptr） 每个进程存取控制字段独立 每个进程使用自己的段号访问 共享：count++，增加表项；回收：count–，删除表项 保护 越界检查：检查段长 存取控制检查：检查读写执行权限 环保护机构：为段设置编号，高编号不允许调用低编号的段 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:2:6","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"第六章 输入输出系统 概念考核 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:0","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"IO 系统的功能、模型、接口 IO 系统：用于管理诸如打印机扫描仪等 IO 设备，和诸如磁盘驱动器等存储设备 IO 系统的基本功能 方便用户使用（隐藏性） 隐藏物理设备细节：IO 设备是怎么进行读写的 与设备的无关性：允许用户和 OS 适应不同的 IO 设备，即插即用 提高 CPU 和 IO 设备利用率（效率） 提高 CPU 和 IO 设备利用率：设备间的独立性 ==\u003e CPU-IO 并行、IO-IO 并行 控制 IO 设备：独立进行 IO 而无需 CPU 干预，向上层提供统一接口 方便用户共享，保证系统有条不紊运行（正确性） 确保对设备的正确共享：对独占设备（打印机）和共享设备（磁盘）的管理 错误处理：处理电气偶然性错误 IO 系统的层次结构 用户层软件：属于应用程序 向用户提供交互接口、库函数 产生 IO 请求、格式化 IO、Spooling 设备独立性软件：属于 IO 系统 实现用户程序和设备驱动程序的统一接口、设备命名保护分配释放、分配存储空间 映射、保护、分块、缓冲、分配 设备驱动程序：属于 IO 系统 具体实现系统对设备发出的操作指令，驱动 IO 设备工作 设置设备寄存器、检查设备状态 将上层发来的 IO 请求转化为对 IO 设备的具体命令和参数 中断处理程序：属于 IO 系统 用于保护被中断进程的 CPU 环境，在处理完毕后进行恢复 IO 系统最底层，直接与硬件交互 设备控制器：属于硬件 执行 IO 操作 IO 系统接口 位于用户层软件和设备独立性软件之间 块设备接口：为磁盘等以块为基本单位提供数据传输的接口 流设备接口：为字符设备提供数据传输的接口 网络接口：为网络通信提供数据传输的接口 软硬件接口（RW/HW 接口）：位于中断处理控制器和设备控制器之间 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:1","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"设备控制器和 IO 设备 IO 设备：执行 IO 操作的机械部分（IO 设备） + 控制 IO 的电子部件（IO 设备控制器） IO 设备类型 按信息交换的单位分类 块设备（有结构、可寻址） 字符设备（无结构、不可寻址） 网络设备 按资源分配角度分类（共享属性） 独占设备（打印机） 共享设备（磁盘） 虚拟设备（将独占变成共享） 按使用特性分类 存储设备 IO 设备（输入设备、输出设备、交互设备） 按传输速率分类 低速设备 中速设备（打印机） 高速设备 IO 设备与设备控制器的接口 数据信号线：外部数据 ==\u003e 转换器 ==\u003e 缓冲器 ==\u003e 数据信号线 ==\u003e 设备控制器 控制信号线：规定设备即将执行的操作 状态信号线：设备在读、在写、或准备完成 设备控制器 功能 接收和识别命令（控制寄存器接受并译码） CPU、设备控制器与 IO 设备之间的数据交换 识别和报告设备状态（状态寄存器） 地址识别（地址译码器） 数据缓冲和差错控制 组成 设备控制器与处理机的接口 设备控制器与设备的接口 IO 逻辑 内存映像 IO 内存地址和设备寄存器地址合并编址，简化设备控制器地址识别 IO 通道 一种只具备 IO 处理能力的特殊处理机，减轻 CPU 负担 通道类型 字节多路通道：多个设备以字节为单位轮转。适合低速设备 数组选择通道：一次只允许一个设备工作。适合高速设备 数组多路通道：两者结合 IO 通道的瓶颈问题 由于通道昂贵，独占性且数量较少，造成其为系统吞吐量的瓶颈。 解决方法：复联增加设备到主机间的通路而不增加通道 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:2","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"中断处理程序和中断机构 中断简介 中断是 CPU 对 IO 设备发来的中断信号的一种响应 中断是设备管理的基础： 外中断：CPU 暂停正在执行的程序，而执行 IO 设备的中断处理程序，事后恢复 内中断（陷入）：计算故障、非法指令等，来源为 CPU 内部 中断向量表：为每种设备配备中断处理程序，将程序入口地址存放在中断向量表中 中断优先级：多中断源处理方式：屏蔽中断、嵌套中断 对多中断源的处理方式 屏蔽（禁止）中断 嵌套中断 中断处理程序 进行上下文切换、对中断信号源测试、读取设备状态、修改进程状态 中断过程： 测定是否有未响应中断信号 保护被中断进程的 CPU 环境 查询中断向量表，转入相应的设备处理程序 进行中断处理 恢复 CPU 现场 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:3","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"设备驱动程序 主要任务：抽象 接收上层发来的抽象 IO 请求并转化为具体请求发送给设备控制器进行数据传送 检查 IO 请求合法性，了解 IO 设备状态，传递操作参数 对空闲的 IO 设备发出 IO 命令，或将请求挂在等待队列中 相应设备控制器的中断请求，并根据类型处理 对 IO 设备的处理方式： （轮询）程序 IO 方式：CPU 不断查询 IO 状态直至设备空闲允许 IO 中断驱动 IO 方式：设备控制器完成一字符 IO 后发送中断请求（CPU、IO 并行） DMA 方式：一批连续数据块全部传送结束时才中断 CPU IO 通道方式：控制多台设备与内存数据交换，完全接管 CPU ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:4","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"设备独立性软件 设备独立性：应用程序中所用的设备，不局限于使用具体某个物理设备 主要任务：实现 OS 的物理设备独立性，可适应性和可扩展性 提供设备驱动程序的统一接口 缓冲管理：单缓冲、双缓冲、循环缓冲、公用缓冲池 差错控制：重试暂时性错误、记录永久性错误 对独立设备的分配和回收 独立于设备的逻辑数据块 设备分配中的数据结构： 设备控制表 DCT：类似PCB理解，记录设备基本信息和当前状态 控制器控制表 COCT：记录设备控制器的基本信息和当前状态 通道控制表 CHCT：记录通道的基本信息和当前状态 系统设置表 SDT：记录系统中所有设备类型和 DCT 入口等信息 设备分配考虑的因素： 设备固有属性：独占、共享、虚拟（独占设备改造成可共享的虚拟设备） 设备分配算法：FCFS、高优先级优先 安全性问题：可能造成死锁 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:5","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"用户层的 IO 软件 系统调用和库函数： 系统调用：应用程序取得 OS 任何服务的唯一途径，汇编级 库函数：对系统调用的进一步封装 假脱机系统 Spooling： 多道程序系统使用若干个进程接管 IO 设备的 IO，使用磁盘进行数据暂存 输入输出井：磁盘上开辟的区域，用于接收和传输数据 输入输出缓冲区：内存上开辟的区域，用于缓冲 CPU 和磁盘速度差异 输入输出进程：管理 IO 设备、缓冲区和输入输出井的数据流动 井管理程序：井的创建和取消 Spooling 特点： 提高了 IO 速度：使用磁盘缓解了 CPU 和低速 IO 设备的速度差异 独占设备改造为共享设备：多个进程共享独占设备（如打印机） 实现了虚拟设备功能：多个进程认为独占了设备 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:6","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"缓冲区管理 缓冲区：用内存或硬件组成的小的存储区域 缓和 CPU 和 IO 设备速度不匹配的矛盾 减少 CPU 中断频率 解决数据粒度不匹配问题 提高 CPU 和 IO 设备之间的并行性 缓冲区管理：组织好缓冲区，并提供获得和释放缓冲区的手段 单缓冲区：缓冲区被填满后需要被取用才能继续填写 双缓冲区：第二块缓冲区填满后才被阻塞；或同时允许 I、O 操作 环形缓冲区：n 缓冲区，采用队列的数组存储形式 缓冲池：缓冲池公用缓冲区以减少不同 IO 进程对内存的浪费 缓冲池组成：空白缓冲队列 emq、输入队列 inq、输出队列 outq 缓冲区工作方式：hin 收容输入、sin 提取输出、hout 收容输出、sout 提取输出 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:7","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"磁盘存储器的性能和调度 数据的组织格式： 盘片 ≠ 盘面：1 磁盘片有 1-2 个磁盘面 磁道 = 柱面：传统磁盘中内磁道存储密度高 扇区 = 盘块：一条磁道由若干扇区组成 磁盘类型：固定磁头磁盘（快），移动磁头磁盘（慢） 磁盘访问时间 磁盘访问时间 = 寻道时间 + 旋转延迟时间 + 平均访问时间 寻道时间： $T_s=m×n+s$（将磁头定位到目标磁道所需的时间） （平均）旋转延迟时间： $T_τ=\\frac{1}{2r}$（将磁头定位到目标扇区所需的时间） 传输时间： $T_t=\\frac{b}{rN}$（读取一个扇区的时间） 平均访问时间： $T_a=T_s+T_τ+T_t$ $r$：转速，转/分 $b$：每次读/写的字节数 $N$：一条磁道上的字节数 $s$：启动磁头臂的时间（固定） $m\\times n$：跨越一个磁道的耗时 × 磁道数 磁盘调度算法 先来先服务 FCFS 效果很差，未优化，平均寻道时间长 最短寻道时间优先 SSTF 要求访问的磁道离当前磁头所在磁道最近 产生饥饿现象 扫描算法（电梯调度）SCAN 磁头由外而内扫描再由内而外扫描 循环扫描 CSCAN 一直同向扫描，避免极端情况等待时间过长 NStepSCAN N 个队列间 FCFS，队列内 SCAN。解决高密度磁盘磁壁粘着现象（磁臂停留在某处不动） FSCAN N=2 的 NStepSCAN，当前队列和新增需求队列 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:3:8","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"第七章 文件管理 前三节重要 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:4:0","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"文件和文件系统 文件系统：操作系统中与管理文件有关的软件和数据。 数据的组成部分：数据项、记录、文件 数据项：最低级的数据组织方式 基本数据项：用于描述一个对象的某种属性 组合数据项：基本数据项的组合 记录：一组相关数据项的组合，用于描述对象的某方面属性 文件：文件系统最大的数据单位，描述一个对象集 有结构文件：记录项的集合 无结构文件：字符流 文件属性：类型、长度、物理位置、建立时间 文件名和扩展名 文件类型： 用途（系统、用户） 数据形式（源、目标、可执行） 存取属性（只执行、只读、读写） 组织方式（普通、目录、特殊） 文件系统的层次结构 对象及其属性（底层）：管理文件及其物理地址 对对象操纵和管理的软件集合（中间层）：管理存储，权限，共享，逻辑==\u003e物理转化 文件系统的接口（最高层）：向用户提供命令接口和程序接口 文件操作 基本文件操作 创建：分配外存空间，父目录创建目录项，目录项记录文件名和外存地址等属性 删除：删除父目录下对应目录项，回收外存空间 读：根据文件名查找目录得到外存位置 写：根据文件名查找目录得到外存位置 设置文件读写位置：文件目录项中存有读写指针 打开和关闭操作 避免在多次读写时重复检索目录 打开：将文件的属性从外存拷贝到内存的文件打开表表项中，并将编号返回用户 关闭：把文件从文件打开表表目中删除 其他文件操作 修改文件属性：改变文件名、拥有者、权限，查询文件状态等 目录操作：创建目录，删除目录，更改工作目录 实现文件共享，对文件进行系统操作 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:4:1","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"文件的逻辑结构 文件的逻辑结构：区别于文件的物理结构，是从用户角度出发所观察到的文件组织形式。文件的逻辑结构管理的是记录。 按结构分类 有结构文件（记录式文件）：定长记录、不定长记录（记录长度而非文件长度） 无结构文件（流式文件）：长度以字节为单位 按组织方式分类 在用户看来，文件是什么结构 顺序文件：按某种顺序排列保存；定长随机访问 不定长查找一条记录平均检索 $\\frac{N}{2}$ 次，适合定长文件 索引文件：针对不定长记录建立索引表，以根据索引进行折半查找，索引速度快，适合索引文件 索引本身是个定长的顺序文件 一级索引 $\\sqrt{N}$ 组，每组 $\\sqrt{N}$ 条记录，平均查找次数为 $\\sqrt{N}$ 索引顺序文件：最常见，u 级顺序索引平均检索 u2N−−√uu2Nu 次 将记录分组，组间顺序，组内索引 直接文件、哈希文件 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:4:2","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"文件目录 文件目录：文件控制块的有序集合 目录文件：存放文件目录的文件 目录管理：实现按名存取、提高目录检索速度、文件共享、允许不同用户的文件重名 文件控制块 FCB 用于描述和控制文件的数据结构 基本信息：文件名、物理位置、逻辑结构、物理结构 存取控制信息：拥有者、核准用户、一般用户的读写执行权限 使用信息：建立日期、修改日期、打开状态、状态信息 索引节点 inode 减少目录文件占用的盘块数，加快检索 使用了 inode 后的文件目录只存储文件名和 inode 编号（指向索引节点的指针），通过 inode 编号可以在 inode 区找到具体的文件信息 磁盘索引节点和内存索引节点 目录结构 重点是多级目录结构 单级目录结构 整个文件系统就一张目录表，每个文件占一项 两级目录结构 主目录 MFD 记录每个用户文件目录 UFD 的信息 树形目录结构 主目录为根目录，数据为树叶，目录项可能是数据文件的 FCB 或目录文件的 FCB 路径名：从根目录到目标文件的路径 当前目录：工作目录 相对路径：从当前目录到目标文件的路径 绝对路径：从根目录到目标文件的路径 目录操作：创建、删除（空/非空）、改变当前目录、移动目录、链接、查找 目录查询技术 线性检索法：在每个文件目录中顺序查找目录项 **Hash **方法：文件名变换为文件目录的索引值 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:4:3","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"文件共享 文件共享：允许多个用户（进程）共享同一份文件而只保留一份副本。 基于DAG的文件共享：拷贝文件的物理地址（拷贝FCB） 硬链接：文件目录存同一份inode编号，inode进行链接计数。删除一份不会消失 软链接（符号链接）：建立LINK文件储存被共享文件路径 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:4:4","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"文件保护 保护域 访问矩阵 访问控制表 访问权限表 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:4:5","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"磁盘存储器管理 第八章 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:5:0","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"外存的组织方式 外存的组织方式：决定了文件的物理结构 连续组织方式 （连续）每个文件分配一片连续的盘块 文件目录项存储第一个盘块和长度 优点：便于顺序访问，速度快，支持定长记录文件随机存取 缺点：盘块连续，预知文件大小，增删记录慢，不能动态增长，需要紧凑 链接组织方式 （离散）将文件存储到离散的盘块中 隐式链接 每个盘块存储下一个盘块的指针 文件目录项存储第一个盘块和最后一个盘块的指针 优点：离散存储，便于顺序访问 缺点：随机存取效率低，必须顺序存取，不支持随机查找 改进：多个连续盘块形成一个簇，减少指针开销并提高检索速度 显式链接 在内存中建长度为物理块数的 FAT 表，表项存放下一盘块指针，而凡是某个文件的起始盘块号都存放在文件 FCB 的“物理地址字段”中 优点：查找记录在内存中进行，大量减少磁盘访问，检索速度快 缺点：FAT 很大，占用内存空间，仍然不支持随机存储 FAT 与 NTFS 的概念 优点：消除外碎片，支持文件动态增长，适合增删改 缺点：只适合顺序存储，可靠性差，读取时寻道次数多，额外存储空间开销大 为了地址转换的方便，FAT 表项的大小通常取半个字节的整数倍 MS-DOS 采用此方法 索引组织方式 （离散）为每个文件分配索引块（一盘块），顺序存储全部盘块号（相当于一个索引表） 单级索引组织：索引块顺序存储各盘块号，文件容量较小 最大文件大小计算：一个盘块块能存储的最大盘号数 × 一个盘块的大小 多级索引组织：一级索引块存储二级索引盘块号，小容量文件浪费存储空间 增量索引式组织 混合索引，全面照顾大中小型文件（考大题） 索引结点有 13 个地址项 直接地址 10 个 一次间址、二次间址、三次间址各 1 个 UNIX 使用此种方式 ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:5:1","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":["专业课"],"content":"文件存储空间管理 任何文件组织方式都必须要为文件分配盘块，需要知道磁盘中哪些盘块是可供分配的。 空闲表法 （连续）存第一块空闲盘号和盘块数 ==\u003e 4.3 空闲链表法 空闲盘块链：（离散）将空闲盘块组成链表，效率很低 空闲盘区链：（连续）将连续的盘块组成盘区，记录块首地址、盘块数、双向链表 位示图法 使用 1bit 标识盘块使用情况，本质是一个二维数组 成组链接法 https://blog.csdn.net/qq_45744501/article/details/116953538 （大型系统）内存常驻空闲盘块号栈（记录栈和栈顶指针，栈内存空闲盘块号）。分配到最后一个时取出栈底盘块中的有用信息替换栈后再分配；回收满了则将栈信息存入当前回收的盘块并将当前回收盘块作为新栈底。 8.3 提高磁盘 IO 速度的途径 8.4 提高磁盘可靠性的技术 8.5 数据一致性控制 （事务） ","date":"2022-02-03","objectID":"/Notes/posts/courses/operating-system/operatingsystem2/:5:2","tags":["OS"],"title":"操作系统（2）","uri":"/Notes/posts/courses/operating-system/operatingsystem2/"},{"categories":null,"content":"基本知识 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"概念 seaborn 是基于 matplotlib 的图形可视化 python 包。它提供了一种高度交互式界面，便于用户能够做出各种有吸引力的统计图表。 Seaborn 是在 matplotlib 的基础上进行了更高级的 API 封装，从而使得作图更加容易，在大多数情况下使用 seaborn 能做出很具有吸引力的图，而使用 matplotlib 就能制作具有更多特色的图。应该把 Seaborn 视为 matplotlib 的补充，而不是替代物。同时它能高度兼容 numpy 与 pandas 数据结构以及 scipy 与 statsmodels 等统计模式 import seaborn as sns ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"层级 API Seaborn 中的 API 分为 Figure-level 和 Axes-level 两种 Axes-level 的函数可以实现与 Matplotlib 更灵活和紧密的结合，而 Figure-level 则更像是「懒人函数」，适合于快速应用 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"声明样式 sns.set() ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"参数 context 控制着默认的画幅大小，分别有 {paper, notebook, talk, poster} 四个值。 其中，poster \u003e talk \u003e notebook \u003e paper。 style 控制默认样式，分别有 {darkgrid, whitegrid, dark, white, ticks} palette 预设的调色板。分别有 {deep, muted, bright, pastel, dark, colorblind} 等 font 用于设置字体 font_scale ：设置字体大小 color_codes： 不使用调色板而采用先前的 'r' 等色彩缩写。 默认参数 sns.set(context='notebook', style='darkgrid', palette='deep', font='sans-serif', font_scale=1, color_codes=False, rc=None) ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"通用参数 sns.图名(x=‘X轴 列名’, y=‘Y轴 列名’, data=原始数据df对象) sns.图名(x=np.array, y=np.array[, …]) 数据必须以长格式的 DataFrame 传入，同时变量通过x, y及其他参数指定。 x, y：data 中的变量名 data：长格式的 DataFrame，每列是一个变量，每行是一个观察值。 hue： data 中的名称，可选 将会产生具有不同颜色的元素的变量进行分组 palette：色盘名，列表，或者字典，可选 用于 hue 变量的不同级别的颜色 size：data 中的名称，可选 将会产生具有不同尺寸的元素的变量进行分组 style：data中的名称，可选 将会产生具有不同风格的元素的变量进行分组 row, col：data 中的变量名，可选 确定网格的分面的类别变量 col_wrap：int，可选 以此宽度“包裹”列变量，以便列分面跨越多行。与 row 分面不兼容 color：控制颜色 bins：条形图的条数 palette：颜色列表 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"保存 ax = sns.distplot(x) # 画图 # fig = ax.get_figure() # 获取图片 fig.savefig(path, dpi = 400) # 保存图片 关联图 （Relational plots） 关联图用于呈现数据之间的关系，主要有散点图和条形图 2 种样式 两个连续型变量之间的关系 关联性分析 介绍 relplot 绘制关系图 scatterplot 多维度分析散点图 lineplot 多维度分析线形图 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"函数 seaborn.relplot(kind='scatter') kind 参数选择要使用的基础轴级函数： 散点图 scatterplot()：通过 kind=\"scatter\" 访问；默认为此 折线图 lineplot()：通过 kind=\"line\" 访问 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"例 以鸢尾花数据集为例 sns.relplot(x='sepal_length',y='sepal_width',data=iris,hue='species') # 默认散点图 sns.relplot(kind='line',x='sepal_length',y='sepal_width',data=iris,hue='species') # 折线图 类别图 （categorical plots） 类别图呈现单个数据与类别之间的关系 针对一个离散型变量与一个连续型变量之间的关系 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"函数 seaborn.catplot( kind='strip') 类别图的 Figure-level 接口是 catplot。而 catplot 实际上是如下 Axes-level 绘图 API 的集合： 分类散点图 stripplot()：(kind=\"strip\") swarmplot()：(kind=\"swarm\") 分类分布图 boxplot()：(kind=\"box\") boxenplot()：(kind=\"boxen\") violinplot() (kind=\"violin\") 分类估计图 pointplot()： (kind=\"point\") barplot()：(kind=\"bar\") countplot()：(kind=\"count\") ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"参数说明 hue= 参数可以给图像引入另一个维度。如果一个数据集有多个类别，hue= 参数就可以让数据点有更好的区分 计数条形图只传入一个分类参数 jitter：表示抖动的程度(仅沿类別轴)。当很多数据点重叠时，可以指定抖动的数量或者设为True使用默认值。 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"例 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"散点图 sns.catplot(x=\"sepal_length\", y=\"species\", data=iris) kind=\"swarm\" 可以让散点按照 beeswarm 的方式防止重叠，可以更好地观测数据分布 sns.catplot(x=\"sepal_length\", y=\"species\", kind=\"swarm\", data=iris) ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:10:1","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"分布图 箱线图 sns.catplot(x=\"sepal_length\", y=\"species\", kind=\"box\", data=iris) 增强箱线图 sns.catplot(x=\"sepal_length\", y=\"species\", kind=\"boxen\", data=iris) 小提琴图 sns.catplot(x=\"sepal_length\", y=\"species\", kind=\"violin\", data=iris) ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:10:2","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"估计图 点线图 sns.catplot(x=\"sepal_length\", y=\"species\", kind=\"point\", data=iris) 条形图 sns.catplot(x=\"sepal_length\", y=\"species\", kind=\"bar\", data=iris) 计数条形图 只传入一个分类参数 sns.catplot(x=\"species\", kind=\"count\", data=iris) 分布图 （Distribution plots） 分布图主要是用于可视化变量的分布情况，一般分为单变量分布和多变量分布。当然这里的多变量多指二元变量，更多的变量无法绘制出直观的可视化图形 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:10:3","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"displot() 单变量分布 sns.displot(x, kind=hist, data) 该方法将会绘制直方图，拟合核密度估计图，或二者兼有 该方法主要做单变量分布，但同样可以传入 y 参数 可以引入 hue 进行分类 直方图 histplot()：通过 kind='hist' 访问 核密度估计图 kdeplot()：通过 kind='kde' 访问 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"参数说明 bins：用于控制条形的数量。 kdeplot 中： multiple：{“layer”, “stack”, “fill”} Method for drawing multiple elements when semantic mapping creates subsets. Only relevant with univariate data ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:11:1","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"例 sns.displot(x=iris[\"sepal_length\"],kind='kde',data=iris) # 核密度估计图 sns.displot(x=iris[\"sepal_length\"],kind='hist',data=iris,hue='species') # 直方图 sns.displot(x=iris[\"sepal_length\"],kde=True,data=iris) # 直方图加核密度估计图 sns.displot(x=iris[\"sepal_length\"],kind='kde',hue='species',data=iris) # 分类的核密度估计图 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:11:2","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"jointplot() 双变量分布 sns.jointplot(x, y, data) 该方法绘制二元变量之间的关系，它并不是一个 Figure-level 接口，但其支持 kind= 参数指定绘制出不同样式的分布图，默认为 scatter kind：{‘scatter’, ‘kde’, ‘hist’, ‘reg’,’hex’} 例 sns.jointplot(x=\"sepal_length\", y=\"sepal_width\", data=iris,hue=\"species\") # 散点对比图 sns.jointplot(x=\"sepal_length\", y=\"sepal_width\", data=iris, kind=\"kde\",hue=\"species\") # 核密度估计对比图 sns.jointplot(x=\"sepal_length\", y=\"sepal_width\", data=iris, kind=\"hex\") # 六边形计数图 sns.jointplot(x=\"sepal_length\", y=\"sepal_width\", data=iris, kind=\"reg\") # 回归拟合图 sns.jointplot(x=\"sepal_length\", y=\"sepal_width\", data=iris, kind=\"hist\",hue=\"species\") # 直方对比图 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:12:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"pairplot() 两两对比分布 sns.pairplot(data) 该方法支持一次性将数据集中的特征变量两两对比绘图。默认情况下，对角线上是单变量分布图，而其他则是二元变量分布图 例 sns.pairplot(iris,hue=\"species\") 回归图 （Regression plots） ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:13:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"regplot 线性回归 sns.regplot(x, y, data) 使用该方法绘制回归图时，只需要指定自变量和因变量即可，它会自动完成线性回归拟合 无hue参数 例 sns.regplot(x=\"petal_length\", y=\"petal_width\", data=iris) ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:14:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"lmplot 分类回归 sns.lmplot(x, y, hue, data) 该方法支持引入第三维度进行对比，也就是可以用hue参数 例 sns.lmplot(x=\"sepal_length\", y=\"sepal_width\", hue=\"species\", data=iris) 矩阵图 （Matrix plots） ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:15:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"heatmap() 热力图 sns.heatmap(data) 必须传入二维数组类型的 data 例 sns.heatmap(np.random.rand(10, 10)) ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:16:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":null,"content":"clustermap() 分层聚类热图 seaborn.clustermap(data) data：2D array-like 例 iris.pop(\"species\") sns.clustermap(iris) 技巧 设置颜色 ","date":"0001-01-01","objectID":"/Notes/posts/python/dataanalysis/seaborn/:17:0","tags":null,"title":"","uri":"/Notes/posts/python/dataanalysis/seaborn/"},{"categories":["Python"],"content":"sklearn ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:0:0","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"特征工程 (Feature Engineering) 特征工程是使用专业背景知识和技巧处理数据**，**使得特征能在机器学习算法上发挥更好的作用的过程 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:1:0","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"数据集 scikit-learn 提供了一些标准数据集 from sklearn import datasets 小规模 load_*() datasets.load_*() 获取小规模数据集，数据包含在datasets里 data1 = datasets.load_iris() data2 = datasets.load_boston() 大规模 fetch_*() datasets.fetch_*(data_home, subset) 获取大规模数据集，需要从网络上下载 data_home：数据集下载的目录，默认是 ~/scikit_learn_data/ subset：选择要加载的数据集。’train’或者’test’，‘all’，可选 返回值 load 和 fetch 返回的数据类型为 datasets.base.Bunch (字典继承) data：特征数据数组，是二维 numpy.ndarray 数组 *target：*标签数组，是 n_samples 的一维 numpy.ndarray 数组 DESCR：数据描述 feature_names：特征名,新闻数据，手写数字、回归数据集没有 target_names：标签名 from sklearn.datasets import load_iris # 获取鸢尾花数据集 iris = load_iris() print(\"鸢尾花数据集的返回值：\\n\", iris) # 将所有参数全部返回，返回值是一个继承自字典的Bench print(\"鸢尾花的特征值:\\n\", iris.data) print(\"鸢尾花的目标值：\\n\", iris.target) print(\"鸢尾花特征的名字：\\n\", iris.feature_names) print(\"鸢尾花目标值的名字：\\n\", iris.target_names) print(\"鸢尾花的描述：\\n\", iris.DESCR) # 同样可以写作诸如iris['data']的格式 输出 鸢尾花的特征值: [[5.1 3.5 1.4 0.2] [4.9 3. 1.4 0.2] [4.7 3.2 1.3 0.2] [4.6 3.1 1.5 0.2] ... [6.3 2.5 5. 1.9] [6.5 3. 5.2 2. ] [6.2 3.4 5.4 2.3] [5.9 3. 5.1 1.8]] 鸢尾花的目标值： [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2] 鸢尾花特征的名字： ['sepal length (cm)', 'sepal width (cm)', 'petal length (cm)', 'petal width (cm)'] 鸢尾花目标值的名字： ['setosa' 'versicolor' 'virginica'] 鸢尾花的描述： .. _iris_dataset: Iris plants dataset -------------------- **Data Set Characteristics:** :Number of Instances: 150 (50 in each of three classes) ... - Many, many more ... ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:1:1","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"数据集划分 简单划分 train_test_split from sklearn.model_selection import train_test_split train_test_split ( arrays, *options ) x：数据集的特征值 y：数据集的标签值 test_size：测试集的大小，一般为 float random_state：随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。 返回：测试集特征值，测试集标签，训练集特征值，训练集标签（默认随机取） x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=22) K 折交叉验证 （KFold Cross Validation） from sklearn.model_selection import KFold KFold ( n_splits=5, *, shuffle=False, random_state=None ) 返回 k 折对象 参数 n_splits：K 子集个数，int, default=5 shuffle：是否要洗牌（打乱数据），bool, default=False random_state：int or RandomState instance, default=None 方法 get_n_splits([X, y, groups])：返回迭代次数，Returns the number of splitting iterations in the cross-validator split(X)：生成器，返回训练和测试集的索引值，Generate indices to split data into training and test set. from sklearn.model_selection import KFold from sklearn import datasets # 数据集导入 iris = datasets.load_iris() x = iris.data y = iris.target # KFold kf = KFold(n_splits=5) # 输出划分数 print(kf.get_n_splits(x)) # 划分数据集 for train_index, test_index in kf.split(x): print(\"TRAIN:\", train_index, \"\\nTEST:\", test_index) x_train, x_test = x[train_index], x[test_index] y_train, y_test = y[train_index], y[test_index] 输出 5 TRAIN: [ 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149] TEST: [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29] TRAIN: [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149] TEST: [30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59] TRAIN: [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149] TEST: [60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89] TRAIN: [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149] TEST: [ 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119] TRAIN: [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119] TEST: [120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149] ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:1:2","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"特征抽取 （feature extraction） 将任意数据（如文本或图像）转换为可用于机器学习的数字特征 import sklearn.feature_extraction 字典特征提取 DictVectorizer 它是一个转换器，应用时需要进行实例化 API sklearn.feature_extraction.DictVectorizer(sparse=True,…) DictVectorizer.fit_transform(X) X：字典或者包含字典的迭代器 返回 sparse 矩阵或 array 数组 DictVectorizer.inverse_transform(X) X：array 数组或者 sparse 矩阵 返回转换之前数据格式 DictVectorizer.get_feature_names() 返回类别名称 例 流程分析 实例化类 DictVectorizer 调用 fit_transform 方法输入数据并转换（注意返回格式） from sklearn.feature_extraction import DictVectorizer data = [{'city': '北京','temperature':100}, {'city': '上海','temperature':60}, {'city': '深圳','temperature':30}] # 1、实例化一个转换器类 transfer = DictVectorizer(sparse=False)# 拒绝返回稀疏矩阵 # 2、调用fit_transform data = transfer.fit_transform(data) print(\"返回的结果:\\n\", data) print(\"特征名字：\\n\", transfer.get_feature_names()) 输出 返回的结果: [[ 0. 1. 0. 100.] [ 1. 0. 0. 60.] [ 0. 0. 1. 30.]] 特征名字： ['city=上海', 'city=北京', 'city=深圳', 'temperature'] 若返回稀疏矩阵，改sparse=True 返回的结果: (0, 1) 1.0 (0, 3) 100.0 (1, 0) 1.0 (1, 3) 60.0 (2, 2) 1.0 (2, 3) 30.0 特征名字： ['city=上海', 'city=北京', 'city=深圳', 'temperature'] 这个处理数据的技巧叫做 one-hot 编码 文本词频特征提取 text.CountVectorizer 对文本数据进行词频特征值化 它是一个转换器，应用时需要进行实例化 API CountVectorizer(stop_words=[]) CountVectorizer.fit_transform(X) X：文本或者包含文本字符串的可迭代对象 返回 sparse 矩阵 CountVectorizer.inverse_transform(X) X：array 数组或者 sparse 矩阵 返回转换之前数据格 CountVectorizer.get_feature_names() 返回值单词列表 例 流程分析 实例化类 CountVectorizer 调用 fit_transform 方法输入数据并转换 （注意返回格式，利用 toarray() 进行 sparse 矩阵转换 array 数组） from sklearn.feature_extraction.text import CountVectorizer data = [\"life is short,i like like python\", \"life is too long,i dislike python\"] # 1、实例化一个转换器类 transfer = CountVectorizer() # 2、调用fit_transform data = transfer.fit_transform(data) print(\"文本特征抽取的结果：\\n\", data.toarray()) print(\"返回特征名字：\\n\", transfer.get_feature_names()) 输出（因为没有 sparse 参数，若要转换成二维数组形式，需要利用 toarray()） 文本特征抽取的结果： [[0 1 1 2 0 1 1 0] [1 1 1 0 1 1 0 1]] 返回特征名字： ['dislike', 'is', 'life', 'like', 'long', 'python', 'short', 'too'] 若直接返回稀疏矩阵 文本特征抽取的结果： (0, 2) 1 (0, 1) 1 (0, 6) 1 (0, 3) 2 (0, 5) 1 (1, 2) 1 (1, 1) 1 (1, 5) 1 (1, 7) 1 (1, 4) 1 (1, 0) 1 返回特征名字： ['dislike', 'is', 'life', 'like', 'long', 'python', 'short', 'too'] 中文处理 使用 jieba 分词库 jieba.cut() 返回词语组成的生成器 分析 准备句子，利用jieba.cut进行分词 实例化CountVectorizer 将分词结果变成字符串当作fit_transform的输入值 from sklearn.feature_extraction.text import CountVectorizer import jieba def cut_word(text): # 用结巴对中文字符串进行分词 text = \" \".join(list(jieba.cut(text))) return text data = [\"一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。\", \"我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。\", \"如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。\"] # 将原始数据转换成分好词的形式 text_list = [] for sent in data: text_list.append(cut_word(sent)) print(text_list) # 1、实例化一个转换器类 transfer = CountVectorizer() # 2、调用fit_transform data = transfer.fit_transform(text_list) print(\"文本特征抽取的结果：\\n\", data.toarray()) print(\"返回特征名字：\\n\", transfer.get_feature_names()) 输出 ['一种 还是 一种 今天 很 残酷 ， 明天 更 残酷 ， 后天 很 美好 ， 但 绝对 大部分 是 死 在 明天 晚上 ， 所以 每个 人 不要 放弃 今天 。', '我们 看到 的 从 很 远 星系 来 的 光是在 几百万年 之前 发出 的 ， 这样 当 我们 看到 宇宙 时 ， 我们 是 在 看 它 的 过去 。', '如果 只用 一种 方式 了解 某样 事物 ， 你 就 不会 真正 了解 它 。 了解 事物 真正 含义 的 秘密 取决于 如何 将 其 与 我们 所 了解 的 事物 相 联系 。'] 文本特征抽取的结果： [[2 0 1 0 0 0 2 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 2 0 1 0 2 1 0 0 0 1 1 0 0 1 0] [0 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0 0 1 3 0 0 0 0 1 0 0 0 0 2 0 0 0 0 0 1 0 1] [1 1 0 0 4 3 0 0 0 0 1 1 0 1 0 1 1 0 1 0 0 1 0 0 0 1 0 0 0 2 1 0 0 1 0 0 0]] 返回特征名字： ['一种', '不会', '不要', '之前', '了解', '事物', '今天', '光是在', '几百万年', '发出', '取决于', '只用', '后天', '含义', '大部分', '如何', '如果', '宇宙', '我们', '所以', '放弃', '方式', '明天', '星系', '晚上', '某样', '残酷', '每个', '看到', '真正', '秘密', '绝对', '美好', '联系', '过去', '还是', '这样'] Tf-idf 文本特征提取 text.TfidfVectorizer TF-IDF 的主要思想是：如果某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现，则认为此词或者短语具有很好的类别区分能力，适合用来分类。 TF-IDF 作用：用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。 公式 词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率 逆向文档频率（inverse document frequency，idf）是一个词语普遍重要性的度量。由总文件数目除以包含该词语之文件的数目，再将得到的商取以 10 为底的对数得到 $$ tfidf_{i,j}=tf_{i,j}\\times idf_i $$ 假如一篇文件的总词语数是 100 个，而词语\"非常\"出现了 5 次，那么\"非常","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:1:3","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"特征预处理 （feature preprocessing） 通过一些转换函数将特征数据转换成更加适合算法模型的特征数据过程 数据的无量纲处理：使不同规格的数据转换到同一规格 归一化 标准化 特征的单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级**，**容易影响（支配）目标结果，使得一些算法无法学习到其它的特征，所以要进行归一化/标准化。 import sklearn.preprocessing 归一化 通过对原始数据进行变换把数据映射到（默认为）[0,1] 之间 公式 $$ X’=\\cfrac{x-min}{max-min}\\ X’’=X’*(mx-mi)+mi $$ 作用于每一列，max 为一列的最大值，min 为一列的最小值，X’’为最终结果，mx，mi分别为指定区间值，默认mx为1，mi为0 API MinMaxScaler (feature_range=(0,1)… ) MinMaxScalar.fit_transform(X) X：numpy array格式的数据 [n_samples,n_features] 返回值：转换后的形状相同的array 例 以下为数据实例 实例化 MinMaxScalar 通过 fit_transform 转换 from sklearn.preprocessing import MinMaxScaler import pandas as pd path = \"../Data/Dating.txt\" data = pd.read_csv(path) # 1、实例化一个转换器类 transfer = MinMaxScaler(feature_range=(0, 1)) # 默认 MIN=0, MAX=1 # 2、调用fit_transform data = transfer.fit_transform(data[['milage','Liters','Consumtime']]) # 需要传numpy array格式, 返回array print(\"最小值最大值归一化处理的结果：\\n\", data) 输出 最小值最大值归一化处理的结果： [[0.43582641 0.58819286 0.53237967] [0. 0.48794044 1. ] [0.19067405 0. 0.43571351] [1. 1. 0.19139157] [0.3933518 0.01947089 0. ]] 注意最大值最小值是变化的，另外，最大值与最小值非常容易受异常点影响，所以这种方法鲁棒性较差，只适合传统精确小数据场景 标准化 通过对原始数据进行变换把数据变换到均值为 0，标准差为 1 的范围内 优势 对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变 对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小 公式 $$ X’=\\cfrac{x-mean}{\\sigma} $$ 作用于每一列，mean 为平均值，σ 为标准差 API StandardScaler( ) StandardScaler.fit_transform(X) X：numpy array 格式的数据 [n_samples, n_features] 返回值：转换后的形状相同的 array StandardScaler.mean_ 返回值：每一列特征的平均值 StandardScaler.var_ 返回值：每一列特征的方差 例 同样对 2.4.1 的数据进行处理 实例化 StandardScaler 通过 fit_transform 转换 import pandas as pd from sklearn.preprocessing import StandardScaler data = pd.read_csv(path) # 1、实例化一个转换器类 transfer = StandardScaler() # 值都在0附近,所以有负数是正常的 # 2、调用fit_transform data = transfer.fit_transform(data[['milage','Liters','Consumtime']]) print(\"标准化的结果:\\n\", data) print(\"每一列特征的平均值：\\n\", transfer.mean_) print(\"每一列特征的方差：\\n\", transfer.var_) 输出 标准化的结果: [[ 0.0947602 0.44990013 0.29573441] [-1.20166916 0.18312874 1.67200507] [-0.63448132 -1.11527928 0.01123265] [ 1.77297701 1.54571769 -0.70784025] [-0.03158673 -1.06346729 -1.27113187]] 每一列特征的平均值： [3.8988000e+04 6.3478996e+00 7.9924800e-01] 每一列特征的方差： [4.15683072e+08 1.93505309e+01 2.73652475e-01] ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:1:4","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"特征降维 （Feature Dimension Reduce） 降维是指在某些限定条件下，降低随机变量（特征）个数，得到一组“不相关”主变量的过程 两种方式 特征选择 主成分分析（可以理解一种特征提取的方式） 特征选择 import sklearn.feature_selection 数据中包含冗余或无关变量（或称特征、属性、指标等），旨在从原有特征中找出主要特征 方法 过滤式（Filter）：主要探究特征本身特点、特征与特征和目标值之间关联 方差选择法：低方差特征过滤 相关系数 嵌入式（Embedded）：算法自动选择特征（特征与目标值之间的关联） 决策树：信息熵、信息增益 正则化：L1、L2 深度学习：卷积等 低方差特征过滤 删除低方差的一些特征 API VarianceThreshold(threshold = 0.0) Variance.fit_transform(X) X：numpy array 格式的数据 [n_samples, n_features] 返回值：训练集差异低于 threshold 的特征将被删除。默认值是保留所有非零方差特征，即删除所有样本中具有相同值的特征。 例 处理以下例子 分析 初始化 VarianceThreshold ，指定阀值方差 调用 fit_transform from sklearn.feature_selection import VarianceThreshold import pandas as pd path=\"../Data/Dating.txt\" data = pd.read_csv(path) # 1、实例化一个转换器类 transfer = VarianceThreshold(threshold=1) # 2、调用fit_transform data = transfer.fit_transform(data.iloc[:, 0:-1]) print(\"删除低方差特征的结果：\\n\", data) print(\"形状：\\n\", data.shape) 输出 删除低方差特征的结果： [[4.0920000e+04 8.3269760e+00] [1.4488000e+04 7.1534690e+00] [2.6052000e+04 1.4418710e+00] [7.5136000e+04 1.3147394e+01] [3.8344000e+04 1.6697880e+00]] 形状： (5, 2) 相关系数 去除相关特征（correlated feature）的影响 使用 Scipy 实现 from scipy.stats import pearsonr 原理 皮尔逊相关系数（Pearson Correlation Coefficient）：反映变量之间相关关系密切程度的统计指标 $$ r=\\cfrac{n\\sum xy=\\sum x\\sum y}{\\sqrt{n\\sum x^2 -(\\sum x)^2}\\sqrt{n\\sum y^2-(\\sum y)^2}} $$ 相关系数的值介于–1与+1之间，即–1≤ r ≤+1。其性质如下： 当r \u003e 0时，表示两变量正相关，r \u003c 0时，两变量为负相关 当|r|=1时，表示两变量为完全相关，当 r=0 时，表示两变量间无相关关系 当0\u003c|r|\u003c1时，表示两变量存在一定程度的相关。且|r|越接近1，两变量间线性关系越密切；|r|越接近于0，表示两变量的线性相关越弱 一般可按三级划分：|r|\u003c0.4为低度相关；0.4≤|r|\u003c0.7为显著性相关；0.7≤|r|\u003c1为高度线性相关 API pearsonr(X, Y) X：numpy array 格式的数据 Y：numpy array 格式的数据 返回值 r：相关系数 [-1，1] 之间 p-value：p值（p值越小，表示相关系数越显著，一般p值在500个样本以上时有较高的可靠性） 如果相关性高可用以下方法: 选取其中一个特征 两个特征加权求和 主成分分析（高维数据变低维，舍弃原由数据，创造新数据，如：压缩数据维数，降低原数据复杂度，损失少了信息） 例 两两特征之间进行相关性计算 from scipy.stats import pearsonr import pandas as pd path=\"../Data/Dating.txt\" data = pd.read_csv(path) # 皮尔逊相关系数范围[-1,1], 如果大于0就是正相关(越接近1就越相关), 反之亦然 r = pearsonr(data[\"milage\"], data[\"Liters\"]) print(\"milage和Liters的相关系数为:\\n\", r) r = pearsonr(data[\"milage\"], data[\"Consumtime\"]) print(\"milage和Liters的相关系数为:\\n\", r) 输出 milage和Liters的相关系数为: (0.660861943290103, 0.2246299034335304) milage和Liters的相关系数为: (-0.6406267138718624, 0.2441916485876286) 主成分分析 （PCA）将数据分解为较低维数空间 from sklearn.decomposition import PCA 概念 定义：高维数据转化为低维数据的过程，在此过程中可能会舍弃原有数据、创造新的变量 作用：是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息 应用：回归分析或者聚类分析当中 API PCA(n_components=None) 参数：n_components 小数：表示保留百分之多少的信息 整数：减少到多少特征 PCA.fit_transform(X) X：numpy array 格式的数据 [n_samples,n_features] 返回值：转换后指定维度的 array 例 from sklearn.decomposition import PCA data = [[2, 8, 4, 5], [3, 8, 5, 5], [10, 5, 1, 0]] # 3*4矩阵 包含四个特征 transfer = PCA(n_components=3) # 为整数就是转为多少个特征 保留的至少都比原特征值少一个 data_new = transfer.fit_transform(data) print(\"(主成分分析)PCA降维:\\n\", data_new) 输出 (主成分分析)PCA降维: [[-3.57495904e+00 -6.64748145e-01 1.07947657e-16] [-3.17447323e+00 6.91574499e-01 1.07947657e-16] [ 6.74943227e+00 -2.68263539e-02 1.07947657e-16]] 若 n_components 设为 0.95 (主成分分析)PCA降维: [[-3.57495904] [-3.17447323] [ 6.74943227]] ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:1:5","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"转换器和估计器 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:2:0","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"转换器 （transformer） 特征工程的接口称之为转换器；转换器是特征工程的父类 调用步骤 实例化 (实例化的是一个转换器类(Transformer)) 调用fit_transform(对于文档建立分类词频矩阵，不能同时调用) 转换器调用形式 fit_transform() fit() 按公式计算 transform() 进行最终的转换 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:2:1","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"估计器 （estimator） 估计器实现了算法的API，估计器是算法的父类 用于分类的估计器： sklearn.neighbors k-近邻算法 sklearn.naive_bayes 贝叶斯 sklearn.linear_model.LogisticRegression 逻辑回归 sklearn.tree 决策树与随机森林 用于回归的估计器： sklearn.linear_model.LinearRegression 线性回归 sklearn.linear_model.Ridge 岭回归 用于无监督学习的估计器 sklearn.cluster.KMeans 聚类 调用步骤 实例化估计器类estimator 进行训练，一旦调用完毕，意味着模型生成 estimator.fit(x_train, y_train) 模型评估 直接比对真实值和预测值 y_predict = estimator.predict(x_test) y_test == y_predict 计算准确率 accuracy = estimator.score(x_test, y_test) ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:2:2","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"模型选择与调优 from sklearn.model_selection import GridSearchCV 概念 交叉验证 （cross validation） 将拿到的训练数据，分为训练和验证集 超参数搜索-网格搜索 （Grid Search） 通常情况下，有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数。但是手动过程繁杂，所以需要对模型预设几种超参数组合。每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。 API GridSearchCV(estimator, param_grid=None,cv=None) 对估计器的指定参数值进行详尽搜索 参数 estimator：估计器对象 param_grid：估计器参数 (dict){“n_neighbors”:[1,3,5]} cv：指定几折交叉验证 方法 fit：输入训练数据 score：准确率 结果分析： best_params_：在交叉验证中验证的最好超参数 best_score_：在交叉验证中验证的最好结果 best_estimator_：最好的参数模型 cv_results_：每次交叉验证后的验证集准确率结果和训练集准确率结果 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:2:3","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"分类的评估方法 分类评估报告 API from sklearn.metrics import classification_report classification_report(y_true, y_pred, labels=[], target_names=None ) y_true：真实目标值 y_pred：估计器预测目标值 labels：指定类别对应的数字 target_names：目标类别名称 return：每个类别精确率与召回率 ROC 曲线与 AUC 指标 from sklearn.metrics import roc_auc_score AUC 只能用来评价二分类 AUC 非常适合评价样本不平衡中的分类器性能 TPR 与 FPR TPR = TP / (TP + FN) 所有真实类别为1的样本中，预测类别为1的比例 即为召回率（查全率） FPR = FP / (FP + FN) 所有真实类别为0的样本中，预测类别为1的比例 ROC 曲线 ROC 曲线的横轴就是 FPRate，纵轴就是 TPRate，当二者相等时，表示的意义则是：对于不论真实类别是 1 还是 0 的样本，分类器预测为 1 的概率是相等的，此时 AUC 为 0.5 AUC 指标 AUC 的概率意义是随机取一对正负样本，正样本得分大于负样本的概率 AUC 的最小值为 0.5，最大值为 1，取值越高越好 AUC=1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。 0.5\u003cAUC\u003c1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。 最终AUC的范围在 [0.5, 1] 之间，并且越接近1越好 API roc_auc_score(y_true, y_score) 计算 ROC 曲线面积，即 AUC 值 y_true：每个样本的真实类别，必须为 0 (反例), 1 (正例)标记 y_score：每个样本预测的概率值 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:2:4","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"模型保存和加载 import joblib 保存：joblib.dump( estimator, ‘XXX.pkl’ ) 加载：estimator = joblib.load( ‘XXX.pkl’ ) 例 import joblib def store_model(estimator, name): joblib.dump(estimator, \"../../models/\"+name) return \"SUCCESS\" def load_model(name): model = joblib.load(\"../../models/\"+name) return model ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:2:5","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"分类 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:3:0","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"KNN 算法 根据邻居，判断类别 from sklearn.neighbors import KNeighborsClassifier （K Nearest Neighbor）即K - 近邻算法 如果一个样本在特征空间中的 k 个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。 优点： 简单，易于理解，易于实现，无需训练 缺点： 懒惰算法，对测试样本分类时的计算量大，内存开销大 必须指定 K 值，K 值选择不当则分类精度不能保证 使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试 API KNeighborsClassifier(n_neighbors=5,algorithm=‘auto’) n_neighbors：int，可选（默认= 5），使用的邻居数 algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法，不同实现方式影响效率 ‘ball_tree’ 将会使用 BallTree ‘kd_tree’ 将使用 KDTree ‘auto’ 将尝试根据传递给fit方法的值来决定最合适的算法 例 from sklearn.neighbors import KNeighborsClassifier from sklearn.preprocessing import StandardScaler from sklearn.model_selection import train_test_split, GridSearchCV from sklearn import datasets import numpy as np import pandas as pd # 数据集导入 iris = datasets.load_iris() # 数据集划分 x_train, x_test, y_train, y_test = train_test_split( iris.data, iris.target, random_state=43) # 标准化 transfer_std = StandardScaler() x_train_std = transfer_std.fit_transform(x_train) x_test_std = transfer_std.transform(x_test) # 测试集不要用fit, 因为要保持和训练集处理方式一致 # KNN estimator_knn = KNeighborsClassifier(n_neighbors=3) # 调优 param_dict = {\"n_neighbors\": [1, 3, 5, 7, 9, 11]} estimator_knn = GridSearchCV( estimator_knn, param_grid=param_dict, cv=10) # 10折 # 训练模型 estimator_knn.fit(x_train_std, y_train) y_pred = estimator_knn.predict(x_test_std) print(\"预测值为:\", y_pred, \"\\n真实值为:\", y_test, \"\\n比较结果为:\", y_test == y_pred) print(\"准确率为：\\n\", estimator_knn.score(x_test_std, y_test)) print(\"最佳参数:\\n\", estimator_knn.best_params_) print(\"最佳结果:\\n\", estimator_knn.best_score_) print(\"最佳估计器:\\n\", estimator_knn.best_estimator_) print(\"交叉验证结果:\\n\", estimator_knn.cv_results_) 输出 预测值为: [0 0 2 1 2 0 2 1 1 1 0 1 2 0 1 1 0 0 2 2 0 0 0 1 2 2 0 1 0 0 1 0 1 1 2 2 1 2] 真实值为: [0 0 2 1 2 0 2 1 1 1 0 1 2 0 1 1 0 0 2 2 0 0 0 2 2 2 0 1 0 0 1 0 1 1 2 2 1 2] 比较结果为: [ True True True True True True True True True True True True True True True True True True True True True True True False True True True True True True True True True True True True True True] 准确率为： 0.9736842105263158 最佳参数: {'n_neighbors': 1} 最佳结果: 0.9469696969696969 最佳估计器: KNeighborsClassifier(n_neighbors=1) 交叉验证结果: {'mean_fit_time': array([0.00029657, 0.00039995, 0.00039968, 0.00049977, 0.00029998, 0.00040131]), 'std_fit_time': array([0.00045309, 0.00048983, 0.00048951, 0.00049977, 0.00045822, 0.0004915 ]), 'mean_score_time': array([0.00089977, 0.00080023, 0.00110025, 0.00080018, 0.00079889, 0.00080283]), 'std_score_time': array([0.00029992, 0.0004004 , 0.00030082, 0.00040009, 0.00039965, 0.00040154]), 'param_n_neighbors': masked_array(data=[1, 3, 5, 7, 9, 11], mask=[False, False, False, False, False, False], fill_value='?', dtype=object), 'params': [{'n_neighbors': 1}, {'n_neighbors': 3}, {'n_neighbors': 5}, {'n_neighbors': 7}, {'n_neighbors': 9}, {'n_neighbors': 11}], 'split0_test_score': array([0.91666667, 0.91666667, 0.91666667, 0.91666667, 0.91666667, 0.91666667]), 'split1_test_score': array([0.91666667, 0.91666667, 0.83333333, 0.91666667, 0.91666667, 0.91666667]), 'split2_test_score': array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.90909091, 1. ]), 'split3_test_score': array([0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.90909091, 0.81818182]), 'split4_test_score': array([1., 1., 1., 1., 1., 1.]), 'split5_test_score': array([0.90909091, 0.90909091, 1. , 1. , 1. , 1. ]), 'split6_test_score': array([1., 1., 1., 1., 1., 1.]), 'split7_test_score': array([0.90909091, 0.81818182, 0.81818182, 0.81818182, 0.81818182, 0.81818182]), 'split8_test_score': array([1., 1., 1., 1., 1., 1.]), 'split9_test_score': array([1. , 0.90909091, 1. , 1. , 1. , 0.90909091]), 'mean_test_score': array([0.9469697 , 0.92878788, 0.93863636, 0.9469697 , 0.9469697 , 0.93787879]), 'std_test_score': array([0.04338734, 0.05412294, 0.06830376, 0.05945884, 0.05945884, 0.07048305]), 'rank_test_score': array([1, 6, 4, 1, 1, 5])} ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:3:1","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"朴素贝叶斯算法 （Naive Bayes） 相互独立的特征 + 贝叶斯公式 from sklearn.naive_bayes import MultinomialNB 朴素：特征与特征之间是相互独立的 朴素贝叶斯算法经常用于文本分类, 因为文章转换成机器学习算法识别的数据是以单词为特征的 优点： 朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。 对缺失数据不太敏感，算法也比较简单，常用于文本分类。 分类准确度高，速度快 缺点： 由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好 原理 贝叶斯公式 以文本分类为例 $$ P(C|F_1,F_2,\\ldots)=\\cfrac{P(F_1,F_2,\\ldots|C)P(C)}{P(F_1,F_2,\\ldots)} $$ $P(C)$：每个文档类别的概率(某文档类别数／总文档数量) $P(W│C)$：给定类别下特征（被预测文档中出现的词）的概率 $W$ 为给定文档的特征值（频数统计） 计算方法：$P(F_1│C)=N_i/N$ （训练文档中去计算） $N_i$：该 $F_1$ 词在 $C$ 类别所有文档中出现的次数 $N$：所属类别 $C$ 下的文档的文本总和 $P(F_1,F_2,\\ldots)$ 预测文档中每个词的概率 拉普拉斯平滑系数 目的：防止计算出的分类概率为0 $$ P(F_1|C)=\\cfrac{N_i+\\alpha}{N+\\alpha m} $$ $\\alpha$：预先指定的系数，默认为 1 $m$：训练文档中特征词的种类数 # 因为样本数量不够，会出现特征词不在一类文本中出现的情况 P(娱乐|影院,支付宝,云计算) = 𝑃(影院,支付宝,云计算|娱乐)∗P(娱乐)=(56/121)∗(15/121)∗(0/121)∗(60/90) = 0 # 此时需要实用到拉普拉斯平滑系数 P(娱乐|影院,支付宝,云计算) =P(影院,支付宝,云计算|娱乐)P(娱乐)=(56+1/121+4)(15+1/121+4)(0+1/121+1*4)(60/90) = 0.00002 API MultinomialNB(alpha = 1.0) alpha：拉普拉斯平滑系数 例：20类新闻分类 分析 划分数据集 tfidf 进行的特征抽取 朴素贝叶斯预测 from sklearn.datasets import fetch_20newsgroups, load_files from sklearn.model_selection import train_test_split from sklearn.feature_extraction.text import TfidfVectorizer from sklearn.naive_bayes import MultinomialNB import pandas as pd data = fetch_20newsgroups(subset=\"all\") x_train, x_test, y_train, y_test = \\ train_test_split(data.data, data.target, test_size=0.2, random_state=22) # 文本分类 transfer = TfidfVectorizer() x_train = transfer.fit_transform(x_train) x_test = transfer.transform(x_test) # 朴素贝叶斯 estimator = MultinomialNB() estimator.fit(x_train, y_train) y_predict = estimator.predict(x_test) print(\"预测值为:\", y_predict, \"\\n真实值为:\", y_test, \"\\n比较结果为:\", y_test == y_predict) score = estimator.score(x_test, y_test) print(\"准确率为: \", score) 输出 预测值为: [15 13 16 ... 13 2 13] 真实值为: [15 13 16 ... 13 2 13] 比较结果为: [ True True True ... True True True] 准确率为: 0.8511936339522547 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:3:2","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"决策树 （Decision Tree） from sklearn.tree import DecisionTreeClassifier if - else 根据特征的信息熵筛选 原理 信息熵 $$ H(X)=-\\sum\\limits_{i=1}^n P(x_i)log_bP(x_i) $$ 条件信息熵 $$ H(D|A)=\\sum\\limits_{i=1}^n \\cfrac{|D_i|}{|D|}H(D_i) $$ 信息增益 决策树的划分依据之一 特征 $A$ 对训练数据集 $D$ 的信息增益 $g(D,A)$,定义为集合 D 的信息熵 $H(D)$ 与特征 $A$ 给定条件下 $D$ 的信息条件熵 $H(D|A)$ 之差 $$ g(D,A)=H(D)=H(D|A) $$ 三种算法实现 ID3 信息增益 最大的准则 C4.5 信息增益比 最大的准则 CART 分类树: 基尼系数 最小的准则 在sklearn中可以选择划分的默认原则 优势：划分更加细致（从后面例子的树显示来理解） API DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None) 决策树分类器 criterion：默认是 ’gini’ 系数，也可以选择信息增益的熵 ’entropy’ max_depth：树的深度大小 random_state：随机数种子 保存树的结构 from sklearn.tree import export_graphviz export_graphviz() 该函数能够导出 DOT 格式 tree.export_graphviz(estimator, out_file=path, feature_names) 例 from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier, export_graphviz iris = datasets.load_iris() x_train, x_test, y_train, y_test = train_test_split( iris.data, iris.target, random_state=22) # 决策树训练 estimator = DecisionTreeClassifier(criterion=\"entropy\") estimator.fit(x_train, y_train) # 生成树文件 export_graphviz(estimator, out_file=\"tree.dot\", feature_names=iris.feature_names) y_pred = estimator.predict(x_test) print(\"预测值为:\", y_pred, \"\\n真实值为:\", y_test, \"\\n比较结果为:\", y_test == y_pred) score = estimator.score(x_test, y_test) print(\"准确率为: \", score) 输出 预测值为: [0 2 1 2 1 1 1 1 1 0 2 1 2 2 0 2 1 1 1 1 0 2 0 1 2 0 2 2 2 1 0 0 1 1 1 0 0 0] 真实值为: [0 2 1 2 1 1 1 2 1 0 2 1 2 2 0 2 1 1 2 1 0 2 0 1 2 0 2 2 2 2 0 0 1 1 1 0 0 0] 比较结果为: [ True True True True True True True False True True True True True True True True True True False True True True True True True True True True True False True True True True True True True True] 准确率为: 0.9210526315789473 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:3:3","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"随机森林 from sklearn.ensemble import RandomForestClassifier 随机森林是一个包含多个决策树的分类器，并且其输出的类别是由个别树输出的类别的众数而定。 原理 学习算法根据下列算法而建造每棵树 用 N 来表示 样本个数，M 表示特征数目。 1、有放回地抽样（bootstrap），一次随机选出一个样本，重复 N 次 2、随机选出 m 个特征, m «M，建立决策树 API RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2) 随机森林分类器 n_estimators：integer，optional（default = 10）森林里的树木数量 120,200,300,500,800,1200 criteria：string，可选（default =“gini”）分割特征的测量方法 max_depth：integer 或 None，可选（默认=无）树的最大深度 5,8,15,25,30 max_features=“auto”：每个决策树的最大特征数量 If “auto”, then max_features=sqrt(n_features). If “sqrt”, then max_features=sqrt(n_features) (same as “auto”). If “log2”, then max_features=log2(n_features). If None, then max_features=n_features. bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样 min_samples_split：节点划分最少样本数 min_samples_leaf：叶子节点的最小样本数 超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf 例 from sklearn import datasets from sklearn.model_selection import train_test_split from sklearn.ensemble import RandomForestClassifier from sklearn.model_selection import GridSearchCV iris = datasets.load_iris() # 数据集划分 x_train, x_test, y_train, y_test = train_test_split( iris.data, iris.target, random_state=22) # RandomForest estimator_rf = RandomForestClassifier() # 超参调优 param_dict = {\"n_estimators\": [120,200,300,500,800,1200], \"max_depth\": [5, 8, 15, 25, 30]} estimator_rf = GridSearchCV(estimator_rf, param_grid=param_dict,cv=5) # 训练 estimator_rf.fit(x_train,y_train) y_pred = estimator_rf.predict(x_test) # 输出结果 print(\"预测值为:\", y_pred, \"\\n真实值为:\", y_test, \"\\n比较结果为:\", y_test == y_pred) print(\"准确率为：\\n\", estimator_rf.score(x_test, y_test)) print(\"最佳参数:\\n\", estimator_rf.best_params_) print(\"最佳结果:\\n\", estimator_rf.best_score_) print(\"最佳估计器:\\n\", estimator_rf.best_estimator_) print(\"交叉验证结果:\\n\", estimator_rf.cv_results_) 输出 预测值为: [0 2 1 2 1 1 1 1 1 0 2 1 2 2 0 2 1 1 1 1 0 2 0 1 2 0 2 2 2 1 0 0 1 1 1 0 0 0] 真实值为: [0 2 1 2 1 1 1 2 1 0 2 1 2 2 0 2 1 1 2 1 0 2 0 1 2 0 2 2 2 2 0 0 1 1 1 0 0 0] 比较结果为: [ True True True True True True True False True True True True True True True True True True False True True True True True True True True True True False True True True True True True True True] 准确率为： 0.9210526315789473 最佳参数: {'max_depth': 5, 'n_estimators': 120} 最佳结果: 0.9553571428571429 最佳估计器: RandomForestClassifier(bootstrap=True, class_weight=None, criterion='gini', max_depth=5, max_features='auto', max_leaf_nodes=None, min_impurity_decrease=0.0, min_impurity_split=None, min_samples_leaf=1, min_samples_split=2, min_weight_fraction_leaf=0.0, n_estimators=120, n_jobs=1, oob_score=False, random_state=None, verbose=0, warm_start=False) 交叉验证结果: {'mean_fit_time': array([0.32009826, 0.57197742, ......., 0., 0., 0., 0.])} ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:3:4","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"逻辑回归 （Logistic Regression） from sklearn.linear_model import LogisticRegression 逻辑回归是机器学习中的一种分类模型，逻辑回归是一种分类算法，虽然名字中带有回归，但是它与回归之间有一定的联系。 原理 输入 逻辑回归的输入就是一个线性回归的结果。 $$ h(w)=w_1x_1+w_2x_2+w_3x_3\\ldots+b $$ 激活函数 sigmoid 函数 $$ g(\\theta^Tx)=\\frac{1}{1+e^{-\\theta^Tx}} $$ 分析 回归的结果输入到 sigmoid 函数当中 输出结果：[0, 1] 区间中的一个概率值，默认为 0.5 为阈值 逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为 1 (正例),另外的一个类别会标记为 0 (反例)。（方便损失计算） 损失函数 逻辑回归的损失，称之为对数似然损失 $$ cost(h_\\theta(x),y)=\\sum\\limits_{i=1}^m-y_ilog(h_\\theta(x))-(1-y_i)log(1-h_\\theta(x)) $$ 优化 同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，提升原本属于 1 类别的概率，降低原本是 0 类别的概率。 API LogisticRegression(solver=‘liblinear’, penalty=‘l2’, C = 1.0) solver：优化求解方式（默认开源的 liblinear 库实现，内部使用了坐标轴下降法来迭代优化损失函数） sag：根据数据集自动选择，随机平均梯度下降 penalty：正则化的种类 C：正则化力度 LogisticRegression 方法相当于 SGDClassifier(loss=\"log\", penalty=\" \"), SGDClassifier 实现了一个普通的随机梯度下降学习，也支持平均随机梯度下降法（ASGD），可以通过设置 average=True。而使用 LogisticRegression (实现了 SAG) 例 案例：癌症分类预测-良／恶性乳腺癌肿瘤预测 数据描述 （1）699条样本，共11列数据，第一列用语检索的id，后9列分别是与肿瘤 相关的医学特征，最后一列表示肿瘤类型的数值。 （2）包含16个缺失值，用 ”?” 标出。 分析 缺失值处理 标准化处理 逻辑回归预测 初始化 from sklearn.linear_model import LogisticRegression, SGDClassifier from sklearn.model_selection import train_test_split import pandas as pd import numpy as np from sklearn.preprocessing import StandardScaler from sklearn.metrics import classification_report, roc_auc_score, roc_curve import matplotlib.pyplot as plt # 文件读取 column_name = ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape', 'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin', 'Normal Nucleoli', 'Mitoses', 'Class'] original_data = pd.read_csv('../Data/breast-cancer-wisconsin.data',names=column_name) original_data.head() # 缺失值处理 # 第一步先替换 ? 为 nan data = original_data.replace(to_replace=\"?\", value=np.nan) data.dropna(inplace=True) print(\"检测是否还有缺失值(全为false表示没有缺失值)\") # 检测是否还有缺失值 print(data.isnull().any()) # 第三步 筛选特征值和目标值 x = data.iloc[:, 1:-1] # 表示每一行数据都要, 从第一列到倒数第二列的column字段也要 y = data[\"Class\"] x_train, x_test, y_train, y_test = train_test_split(x, y) 输出 检测是否还有缺失值(全为false表示没有缺失值) Sample code number False Clump Thickness False Uniformity of Cell Size False Uniformity of Cell Shape False Marginal Adhesion False Single Epithelial Cell Size False Bare Nuclei False Bland Chromatin False Normal Nucleoli False Mitoses False Class False 训练 # 第四步: 开始特征工程 transfer = StandardScaler() x_train = transfer.fit_transform(x_train) x_test = transfer.transform(x_test) # 第五步, 预估器流程 estimator = LogisticRegression() # 默认参数 estimator.fit(x_train, y_train) print(\"逻辑回归_权重系数为: \", estimator.coef_) print(\"逻辑回归_偏置为:\", estimator.intercept_) # 第六步, 模型评估 y_predict = estimator.predict(x_test) print(\"逻辑回归_预测结果\", y_predict) print(\"逻辑回归_预测结果对比:\", y_test == y_predict) score = estimator.score(x_test, y_test) print(\"准确率为:\", score) # 2是良性的 4是恶性的 \"\"\" 但是实际上这个预测结果不是我们想要的, 以上只能说明预测的正确与否, 而事实上, 我们需要一种评估方式来显示我们对恶性breast的预测成功率, 也就是召回率 同时可以查看F1-score的稳健性 (召回率和精确率看笔记和截图) 所以下面换一种评估方法 \"\"\" 输出 逻辑回归_权重系数为: [[1.20895973 0.34430535 0.93605533 0.50117234 0.22296947 1.22295345 0.81648447 0.64096012 0.71930684]] 逻辑回归_偏置为: [-0.9875554] 逻辑回归_预测结果 [2 4 2 2 4 4 2 2 4 2 2 2 4 4 4 2 2 4 4 4 4 2 4 4 4 2 2 4 2 2 4 2 4 4 4 2 4 2 2 2 2 4 4 2 4 2 2 2 2 4 2 2 2 4 4 2 4 2 2 2 2 2 2 4 4 4 2 2 2 2 2 4 2 2 2 2 4 2 2 2 2 2 2 2 2 4 2 2 4 2 2 2 4 2 4 2 2 2 2 2 2 2 2 2 4 4 2 2 4 4 2 2 2 4 2 4 2 2 4 4 2 2 2 2 4 2 2 2 4 2 2 2 2 2 4 2 4 2 4 2 2 4 2 2 2 4 4 4 2 2 2 2 4 4 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 4 2] 逻辑回归_预测结果对比: 541 True 288 True 395 True 409 True 568 True ... 442 True 51 False 370 True 304 True 363 True Name: Class, Length: 171, dtype: bool 准确率为: 0.9766081871345029 查看精确率，召回率，F1-score Score = classification_report(y_test, y_predict, labels=[2, 4], target_names=[\"良性\", \"恶性\"]) print(\"查看精确率,召回率,F1-score\\n\", Score) # support表示样本量 输出 查看精确率,召回率,F1-score precision recall f1-score support 良性 0.98 0.98 0.98 114 恶性 0.96 0.96 0.96 57 accuracy 0.98 171 macro avg 0.97 0.97 0.97 171 weighted avg 0.98 0.98 0.98 171 查看 ROC 曲线和 AUC 指标 \"\"\"","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:3:5","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"回归 （Regression） 小规模数据： LinearRegression(不能解决拟合问题) 岭回归 大规模数据：SGDRegressor ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:4:0","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"线性回归 from sklearn.linear_model import LinearRegression, SGDRegressor （Linear Regression） 线性回归 (Linear regression) 是利用回归方程(函数)对一个或多个自变量(特征值)和因变量(目标值)之间关系进行建模的一种分析方式 API 正规方程 正规方程的优化方法，不能解决拟合问题，一次性求解，针对小数据 LinearRegression(fit_intercept=True) fit_intercept：是否计算偏置 属性 LinearRegression.coef_：权重系数（回归系数） LinearRegression.intercept_：偏置 梯度下降 其实是随机梯度下降 SGDRegressor(loss=“squared_loss”, fit_intercept=True, learning_rate =‘invscaling’, eta0=0.01) SGDRegressor类实现了随机梯度下降学习，它支持不同的 loss 函数和正则化惩罚项来拟合线性回归模型。 loss：损失类型 loss=”squared_loss”: 普通最小二乘法 fit_intercept：是否计算偏置 learning_rate：string, optional 学习率填充，对于一个常数值的学习率来说，可以使用 learning_rate=’constant’ ，并使用 eta0 来指定学习率。 ‘constant’：eta = eta0 ‘optimal’：eta = 1.0 / (alpha * (t + t0)) [default] ‘invscaling’：eta = eta0 / pow(t, power_t=0.25) max_iter：迭代次数 属性 SGDRegressor.coef_：回归系数 SGDRegressor.intercept_：偏置 对比 梯度下降 正规方程 需要选择学习率 不需要 需要迭代求解 一次运算得出 特征数量较大可以使用 需要计算方程，时间复杂度高 O(n3) 回归性能评估 均方误差 MSE from sklearn.metrics import mean_squared_error 均方误差（Mean Squared Error）MSE 评价机制 mean_squared_error(y_test, y_pred) 均方误差回归损失 y_test：真实值 y_pred：预测值 return：浮点数结果 平均绝对误差 MAE from sklearn.metrics import mean_absolute_error mean_absolute_error(y_test, y_pred) 平均绝对误差回归损失 y_test：真实值 y_pred：预测值 return：浮点数结果 例 初始化 from sklearn.linear_model import LinearRegression, SGDRegressor from sklearn.datasets import load_boston from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.metrics import mean_squared_error # 均方误差 boston_data = load_boston() print(\"特征数量为:(样本数,特征数)\", boston_data.data.shape) x_train, x_test, y_train, y_test = train_test_split(boston_data.data, boston_data.target, random_state=22) # 标准化 transfer = StandardScaler() x_train = transfer.fit_transform(x_train) x_test = transfer.transform(x_test) 正规方程 estimator = LinearRegression() estimator.fit(x_train, y_train) print(\"正规方程_权重系数为: \", estimator.coef_) print(\"正规方程_偏置为:\", estimator.intercept_) y_predict = estimator.predict(x_test) error = mean_squared_error(y_test, y_predict) print(\"正规方程_房价预测:\", y_predict) print(\"正规方程_均分误差:\", error) 输出 正规方程_权重系数为: [-0.64817766 1.14673408 -0.05949444 0.74216553 -1.95515269 2.70902585 -0.07737374 -3.29889391 2.50267196 -1.85679269 -1.75044624 0.87341624 -3.91336869] 正规方程_偏置为: 22.62137203166228 正规方程_房价预测: [28.22944896 31.5122308 21.11612841 32.6663189 20.0023467 19.07315705 21.09772798 19.61400153 19.61907059 32.87611987 20.97911561 27.52898011 15.54701758 19.78630176 ...... 15.17700342 3.81620663 29.18194848 20.68544417 22.32934783 28.01568563 28.58237108] 正规方程_均分误差: 20.627513763095386 梯度下降 estimator = SGDRegressor(learning_rate=\"constant\", eta0=0.01, max_iter=10000) # estimator = SGDRegressor(penalty='l2', loss=\"squared_loss\") # 这样设置就相当于岭回归, 但是建议用Ridge方法 estimator.fit(x_train, y_train) print(\"梯度下降_权重系数为: \", estimator.coef_) print(\"梯度下降_偏置为:\", estimator.intercept_) y_predict = estimator.predict(x_test) error = mean_squared_error(y_test, y_predict) print(\"梯度下降_房价预测:\", y_predict) print(\"梯度下降_均分误差:\", error) 输出 梯度下降_权重系数为: [-0.63057536 1.10395195 0.0426204 1.11219718 -1.91486635 2.72806163 -0.05021542 -3.52443232 2.47863671 -1.62374879 -1.9093765 1.08972091 -4.48569927] 梯度下降_偏置为: [22.36660176] 梯度下降_房价预测: [28.44139247 31.71808756 20.86031611 34.1638423 19.35660167 19.18397968 20.97064914 18.87641833 18.87914517 ...... 14.57654182 2.54082058 29.38973401 20.80732646 21.65598607 27.85659704 29.41864109] 梯度下降_均分误差: 20.997365545229272 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:4:1","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"岭回归 （Ridge Regression） from sklearn.linear_model import Ridge, RidgeCV 岭回归，其实也是一种线性回归。只不过在算法建立回归方程时候，加上正则化的限制，从而达到解决过拟合的效果 原理 正则化类别 L2 正则化 作用：可以使得其中一些 W 的都很小，都接近于 0，削弱某个特征的影响 优点：越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象 Ridge 回归 L1正则化 作用：可以使得其中一些W的值直接为0，删除这个特征的影响 LASSO 回归 线性回归的损失函数用最小二乘法，等价于当预测值与真实值的误差满足正态分布时的极大似然估计；岭回归的损失函数，是最小二乘法+L2范数，等价于当预测值与真实值的误差满足正态分布，且权重值也满足正态分布（先验分布）时的最大后验估计；LASSO的损失函数，是最小二乘法+L1范数，等价于等价于当预测值与真实值的误差满足正态分布，且且权重值满足拉普拉斯分布（先验分布）时的最大后验估计 API 常规岭回归 Ridge(alpha=1.0, fit_intercept=True,solver=“auto”, normalize=False) 具有 L2 正则化的线性回归 alpha：正则化力度，也叫 λ，即惩罚项系数 λ取值：0~1 1~10 solver：会根据数据自动选择优化方法 sag：如果数据集、特征都比较大，选择该随机梯度下降优化 normalize：数据是否进行标准化 normalize=False：可以在 fit 之前调用 preprocessing.StandardScaler 标准化数据 属性 Ridge.coef_：回归权重 Ridge.intercept_：回归偏置 Ridge 方法相当于 SGDRegressor(penalty='l2', loss=\"squared_loss\"), 只不过 SGDRegressor 实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG) 交叉验证岭回归 RidgeCV(_BaseRidgeCV, RegressorMixin) 具有 L2 正则化的线性回归，可以进行交叉验证 alphas：alpha 列表 cv：交叉验证次数 coef_：回归系数 例 from sklearn.linear_model import Ridge, RidgeCV from sklearn.datasets import load_boston from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.metrics import mean_squared_error # 均方误差 boston_data = load_boston() x_train, x_test, y_train, y_test = train_test_split(boston_data.data, boston_data.target, random_state=22) # 标准化 transfer = StandardScaler() x_train = transfer.fit_transform(x_train) x_test = transfer.transform(x_test) # 岭回归 estimator = Ridge(max_iter=10000, alpha=0.5) # 岭回归 # estimator = RidgeCV(alphas=[0.1, 0.2, 0.3, 0.5]) # 加了交叉验证的岭回归 estimator.fit(x_train, y_train) print(\"岭回归_权重系数为: \", estimator.coef_) print(\"岭回归_偏置为:\", estimator.intercept_) y_predict = estimator.predict(x_test) error = mean_squared_error(y_test, y_predict) print(\"岭回归_房价预测:\", y_predict) print(\"岭回归_均分误差:\", error) 输出 岭回归_权重系数为: [-0.64193209 1.13369189 -0.07675643 0.74427624 -1.93681163 2.71424838 -0.08171268 -3.27871121 2.45697934 -1.81200596 -1.74659067 0.87272606 -3.90544403] 岭回归_偏置为: 22.62137203166228 岭回归_房价预测: [28.22536271 31.50554479 21.13191715 32.65799504 20.02127243 19.07245621 21.10832868 19.61646071 ......15.19441045 3.81755887 29.1743764 20.68219692 22.33163756 28.01411044 28.55668351] 岭回归_均分误差: 20.641771606180914 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:4:2","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"聚类 from sklearn.cluster import KMeans K-means（K 均值聚类） 特点：采用迭代式算法，直观易懂并且非常实用 缺点：容易收敛到局部最优解(多次聚类) ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:5:0","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"聚类步骤 随机设置 K 个特征空间内的点作为初始的聚类中心 对于其他每个点计算到 K 个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别 接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值） 如果计算得出的新中心点与原中心点一样，那么结束，否则重新进行第二步过程 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:5:1","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"API KMeans(n_clusters=8, init=‘k-means++’…) n_clusters：开始的聚类中心数量 init：初始化方法，默认为’k-means ++’ KMeans.labels_：默认标记的类型，可以和真实值比较（不是值比较） ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:5:2","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"轮廓系数 from sklearn.metrics import silhouette_score 轮廓系数作为 Kmeans 的性能评估指标 公式 $$ sc_i=\\cfrac{b_i-a_i}{max(b_i,a_i)} $$ 注：对于每个点 $i$ 为已聚类数据中的样本 ，$b_i$ 为 $i$ 到其它族群的所有样本的距离最小值，$a_i$ 为 $i$ 到本身簇的距离平均值。最终计算出所有的样本点的轮廓系数平均值 轮廓系数值分析 分析过程（以一个蓝1点为例） 计算出蓝1离本身族群所有点的距离的平均值$a_i$ 蓝1到其它两个族群的距离计算出平均值红平均，绿平均，取最小的那个距离作为$b_i$ 根据公式：极端值考虑：如果$b_i »a_i$，那么公式结果趋近于1；如果$a_i»\u003eb_i$，那么公式结果趋近于-1 结论：如果$b_i»a_i$，趋近于1，效果好， $b_i«a_i$，趋近于-1，效果不好。轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优 API silhouette_score(X, labels)：计算所有样本的平均轮廓系数 X：特征值 labels：被聚类标记的目标值（聚类结果） ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:5:3","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":["Python"],"content":"例 分析 降维之后的数据 k-means聚类 聚类结果显示 用户聚类结果评估 import numpy as np import matplotlib.pyplot as plt %matplotlib inline from sklearn.datasets.samples_generator import make_blobs # X为样本特征，Y为样本簇类别， 共1000个样本，每个样本2个特征，共4个簇，簇中心在[-1,-1], [0,0],[1,1], [2,2]， 簇方差分别为[0.4, 0.2, 0.2] X, y = make_blobs(n_samples=1000, n_features=2, centers=[[-1,-1], [0,0], [1,1], [2,2]], cluster_std=[0.4, 0.2, 0.2, 0.2]) plt.scatter(X[:, 0], X[:, 1], marker='o') plt.show() 案例样本 from sklearn.cluster import KMeans #y_pred = KMeans(n_clusters=4).fit_predict(X) estimator = KMeans(n_clusters=4, init='k-means++') estimator.fit(X) y_pred = estimator.predict(X) plt.scatter(X[:, 0], X[:, 1], c=y_pred) plt.show() from sklearn.metrics import silhouette_score score = silhouette_score(X, y_pred) print(\"模型轮廓系数为(1 最好, -1 最差):\", score) 输出 模型轮廓系数为(1 最好, -1 最差): 0.6634549555891298 ","date":"2021-10-23","objectID":"/Notes/posts/python/machinelearning/sklearn/:5:4","tags":["Python","ml"],"title":"sklearn","uri":"/Notes/posts/python/machinelearning/sklearn/"},{"categories":null,"content":"功能模块设计 代码结构 assets：静态文件，如人名库、国家名库 core：数据库与ORM框架的相关配置 crud：使用对象关系映射模型构建的原子性数据库操作集合 game_configs：游戏的参数配置和算法权重配置文件 如头像生成概率、能力值的地域修正、联赛和俱乐部的初始数据、各个职责能力值的计算公式、token生成密钥等 logs：日志文件 models：ORM模型定义 负责与对象关系映射模型与数据库的交互转换 modules：游戏运行的核心模块集合 computed_data_app：数据对象的计算属性统计模块，负责将数据库中的初始数据构建为成体系的结构化数据，便于展示给用户 game_app：比赛逻辑模块 AI 之间的比赛逻辑和人机比赛逻辑 数十种动作对抗的函数定义 五种进攻战术的脚本 比赛实时数据的记录 两种球员挑选算法 根据对手特性调整战术比重的算法 generate_app：生成联赛、俱乐部、球、日程表的工厂类模块 next_turn_app：推动游戏行进的消息转发模块，负责接受前端请求调用相应的功能 transfer_app：球员市场转会模块 AI 间的球员交易、玩家和 AI 俱乐部间的球员交易 球员合同谈判过程模拟 routers：提供 API，负责前后端的通信和数据交换 schemas：数据交换格式的规范化模块，定义了每个数据实体的数据类型 utils：工具模块 date：日期生成和计算工具 dependencies 与 token_validator：用户鉴权工具 logger：日志记录类 utils：提供常用的工具函数，如时间序列生成算法、随机数生成算法等 ","date":"0001-01-01","objectID":"/Notes/posts/test/:1:0","tags":null,"title":"","uri":"/Notes/posts/test/"},{"categories":["刷题"],"content":"1047. 删除字符串中的所有相邻重复项 easy 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：\"abbaca\" 输出：\"ca\" 解释：例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 ","date":"2022-04-06","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/1047.-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/:0:0","tags":["算法","字符串","栈"],"title":"1047. 删除字符串中的所有相邻重复项","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/1047.-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"categories":["刷题"],"content":"栈！ 每次入栈时，判断待入栈字母与栈顶字母是否相同，是的话就一并消除 func removeDuplicates(s string) string { if len(s) == 0 { return \"\" } stack := make([]byte, 0) for i := 0; i \u003c len(s); i++ { if len(stack) != 0 \u0026\u0026 s[i] == stack[len(stack)-1] { // 待入栈的字母与栈顶字母相同 stack = stack[:len(stack)-1] } else { stack = append(stack, s[i]) } } return string(stack) } ","date":"2022-04-06","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/1047.-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/:1:0","tags":["算法","字符串","栈"],"title":"1047. 删除字符串中的所有相邻重复项","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/1047.-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"categories":["刷题"],"content":"150. 逆波兰表达式求值 mid 根据逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。 注意 两个整数之间的除法只保留整数部分。 可以保证给定的逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。 示例 1： 输入：tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9 示例 2： 输入：tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"] 输出：6 解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6 ","date":"2022-04-06","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/150.-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/:0:0","tags":["算法","数组","栈"],"title":"150. 逆波兰表达式求值","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/150.-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"categories":["刷题"],"content":"栈 后缀表达式嘛，其实逆波兰表达式相当于是二叉树中的后序遍历 func evalRPN(tokens []string) int { stack := make([]int, 0) for i := 0; i \u003c len(tokens); i++ { switch tokens[i] { case \"+\": a := stack[len(stack)-1] b := stack[len(stack)-2] stack = stack[:len(stack)-2] stack = append(stack, b+a) case \"-\": a := stack[len(stack)-1] b := stack[len(stack)-2] stack = stack[:len(stack)-2] stack = append(stack, b-a) case \"*\": a := stack[len(stack)-1] b := stack[len(stack)-2] stack = stack[:len(stack)-2] stack = append(stack, b*a) case \"/\": a := stack[len(stack)-1] b := stack[len(stack)-2] stack = stack[:len(stack)-2] stack = append(stack, b/a) default: num, _ := strconv.Atoi(tokens[i]) stack = append(stack, num) } } return stack[0] } ","date":"2022-04-06","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/150.-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/:1:0","tags":["算法","数组","栈"],"title":"150. 逆波兰表达式求值","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/150.-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/"},{"categories":["刷题"],"content":"239. 滑动窗口最大值 hard 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 ","date":"2022-04-06","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/239.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/:0:0","tags":["算法","数组","单调队列"],"title":"239. 滑动窗口最大值","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/239.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["刷题"],"content":"单调队列 队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队里里的元素数值是由大到小的。也就是维护一个从队头到队尾递减的单调队列 设计单调队列的时候，pop，和push操作要保持如下规则： pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作 push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止 保持如上规则，每次窗口移动的时候，只要问que.front()就可以返回当前窗口的最大值。 type queue struct { Q []int } func (q *queue) back() int { return q.Q[len(q.Q)-1] } func (q *queue) front() int { return q.Q[0] } func (q *queue) len() int { return len(q.Q) } func (q *queue) push(num int) { for q.len() != 0 \u0026\u0026 num \u003e q.back() { q.Q = q.Q[:q.len()-1] } q.Q = append(q.Q, num) } func (q *queue) pop(num int) { if q.len() != 0 \u0026\u0026 num == q.front() { q.Q = q.Q[1:] } } func maxSlidingWindow(nums []int, k int) []int { result := make([]int, 0) q := \u0026queue{Q: make([]int, 0)} // 从队头到队尾递减的单调队列 for i := 0; i \u003c k; i++ { q.push(nums[i]) } result = append(result, q.front()) i, j := 1, k for j \u003c len(nums) { q.pop(nums[i-1]) q.push(nums[j]) result = append(result, q.front()) i++ j++ } return result } ","date":"2022-04-06","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/239.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/:1:0","tags":["算法","数组","单调队列"],"title":"239. 滑动窗口最大值","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/239.-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/"},{"categories":["Golang"],"content":"Docker 摘自：https://yeasy.gitbook.io/docker_practice/ ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:0:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"什么是 Docker 摘自：https://zhuanlan.zhihu.com/p/187505981 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"容器技术 vs 虚拟机 和一个单纯的应用程序相比，操作系统是一个很重而且很笨的程序 操作系统运行起来是需要占用很多资源的，刚装好的系统还什么都没有部署，单纯的操作系统其磁盘占用至少几十 G 起步，内存要几个 G 起步。 假设我有一台机器，16G 内存，需要部署三个应用，那么使用虚拟机技术可以这样划分： 在这台机器上开启三个虚拟机，每个虚拟机上部署一个应用，其中 VM1 占用 2G 内存，VM2 占用 1G 内存，VM3 占用了 4G 内存。 我们可以看到虚拟本身就占据了总共 7G 内存，因此我们没有办法划分出更多虚拟机从而部署更多的应用程序，可是我们部署的是应用程序，要用的也是应用程序而不是操作系统。 如果有一种技术可以让我们避免把内存浪费在“无用”的操作系统上岂不是太香？这是问题一，主要原因在于操作系统太重了。 还有另一个问题，那就是启动时间问题，我们知道操作系统重启是非常慢的，因为操作系统要从头到尾把该检测的都检测了该加载的都加载上，这个过程非常缓慢，动辄数分钟，因此操作系统还是太笨了。 那么有没有一种技术可以让我们获得虚拟机的好处又能克服这些缺点从而一举实现鱼和熊掌的兼得呢？ 答案是肯定的，这就是容器技术。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"什么是容器 容器一词的英文是 container，其实 container 还有集装箱的意思，而容器和集装箱在概念上是很相似的。 现代软件开发的一大目的就是隔离，应用程序在运行时相互独立互不干扰，这种隔离实现起来是很不容易的，其中一种解决方案就是上面提到的虚拟机技术，通过将应用程序部署在不同的虚拟机中从而实现隔离。 但是虚拟机技术有上述提到的各种缺点，那么容器技术又怎么样呢？ 与虚拟机通过操作系统实现隔离不同，容器技术 只隔离应用程序的运行时环境 容器之间可以共享同一个操作系统 这里的运行时环境指的是程序运行依赖的各种库以及配置。 从图中我们可以看到容器更加的轻量级且占用的资源更少，与操作系统动辄几 G 的内存占用相比，容器技术只需数 M 空间，因此我们可以在同样规格的硬件上大量部署容器，这是虚拟机所不能比拟的，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动，容器技术为打包服务栈提供了一种更加高效的方式，So cool。 那么我们该怎么使用容器呢？这就要讲到 docker 了。 注意，容器是一种通用技术，docker 只是其中的一种实现。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"什么是 docker docker 是一个用 Go 语言实现的开源项目，可以让我们方便的创建和使用容器，docker 将程序以及程序所有的依赖都打包到 docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器。 就好比集装箱，容器所处的操作系统环境就好比货船或港口，程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系。 因此我们可以看到 docker 可以屏蔽环境差异，也就是说，只要你的程序打包到了 docker 中，那么无论运行在什么环境下程序的行为都是一致的，程序员再也无法施展表演才华了，不会再有 “在我的环境上可以运行”，真正实现 “build once, run everywhere”。 此外 docker 的另一个好处就是快速部署，这是当前互联网公司最常见的一个应用场景，一个原因在于容器启动速度非常快，另一个原因在于只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:3","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"如何使用 docker docker 中有这样几个概念： dockerfile image container 实际上你可以简单的把 dockerfile 理解为源代码 image 理解为可执行程序 container 就是运行起来的进程 docker 就是 “编译器”。 官方文档的术语解释： A Dockerfile is simply a text-based script of instructions that is used to create a container image. A container is a sandboxed process on your machine that is isolated from all other processes on the host machine. 因此我们只需要在 dockerfile 中指定需要哪些程序、依赖什么样的配置，之后把 dockerfile 交给“编译器” docker 进行“编译”，也就是 docker build 命令，生成的可执行程序就是 image，之后就可以运行这个 image 了，这就是 docker run 命令，image运行起来后就是 docker container。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:4","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"docker 是如何工作的 实际上 docker 使用了常见的 CS 架构，也就是 client-server 模式，docker client 负责处理用户输入的各种命令，比如 docker build、docker run，真正工作的其实是 server，也就是 docker demon 值得注意的是，docker client 和 docker demon 可以运行在同一台机器上。 接下来我们用几个命令来讲解一下 docker 的工作流程： docker build 当我们写完 dockerfile 交给 docker “编译” 时使用这个命令，那么 client 在接收到请求后转发给 docker daemon，接着 docker daemon 根据 dockerfile 创建出“可执行程序” image。 docker run 有了“可执行程序” image 后就可以运行程序了，接下来使用命令 docker run，docker daemon 接收到该命令后找到具体的 image，然后加载到内存开始执行，image 执行起来就是所谓的 container。 docker pull 其实 docker build 和 docker run 是两个最核心的命令，会用这两个命令基本上 docker 就可以用起来了，剩下的就是一些补充。 那么 docker pull 是什么意思呢？ 我们之前说过，docker 中 image 的概念就类似于“可执行程序”，我们可以从哪里下载到别人写好的应用程序呢？很简单，就是 Docker Hub，docker 官方的“应用商店”，你可以在这里下载到别人编写好的 image，这样你就不用自己编写 dockerfile 了。 docker registry 可以用来存放各种 image，公共的可以供任何人下载 image 的仓库就是 docker Hub。那么该怎么从 Docker Hub 中下载 image 呢，就是这里的 docker pull 命令了。 因此，这个命令的实现也很简单，那就是用户通过 docker client 发送命令，docker daemon 接收到命令后向 docker registry 发送 image 下载请求，下载后存放在本地，这样我们就可以使用 image 了。 最后，让我们来看一下 docker 的底层实现。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:5","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"docker 的底层实现 docker 基于 Linux 内核提供这样几项功能实现的： NameSpace 我们知道 Linux 中的 PID、IPC、网络等资源是全局的，而 NameSpace 机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的 NameSpace，各个 NameSpace 下的资源互不干扰，这就使得每个 NameSpace 看上去就像一个独立的操作系统一样，但是只有 NameSpace 是不够。 Control groups 虽然有了 NameSpace 技术可以实现资源隔离，但进程还是可以不受控的访问系统资源，比如 CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker 采用 control groups 技术（也就是 cgroup），有了 cgroup 就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些 CPU 上运行等等。 有了这两项技术，容器看起来就真的像是独立的操作系统了。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:1:6","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"安装 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:2:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"Ubuntu 使用 APT 安装 由于 apt 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。 $ sudo apt-get update $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 $ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 官方源 # $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 然后，我们需要向 sources.list 中添加 Docker 软件源 $ echo \\ \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \\ $(lsb_release -cs)stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null # 官方源 # $ echo \\ # \"deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ # $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。 更新 apt 软件包缓存，并安装 docker-ce： $ sudo apt-get update $ sudo apt-get install docker-ce docker-ce-cli containerd.io 启动 Docker $ sudo systemctl enable docker $ sudo systemctl start docker 测试 $ docker run --rm hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world b8dfde127a29: Pull complete Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24 Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ 若能正常输出以上信息，则说明安装成功。 建立 docker 用户组 默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。 建立 docker 组： $ sudo groupadd docker 将当前用户加入 docker 组： $ sudo usermod -aG docker $USER ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:2:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"使用镜像 Docker 镜像 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 不包含 任何动态数据，其内容在构建之后也不会被改变。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:3:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"获取镜像 docker pull 从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为： $ docker pull [选项] 仓库名[:标签] # 更具体地 $ docker pull [选项] [Docker Registry 地址[:端口号]]仓库名[:标签] 具体的选项可以通过 docker pull --help 命令看到，这里我们说一下镜像名称的格式。 Docker 镜像仓库地址：地址的格式一般是 \u003c域名/IP\u003e[:端口号]。 默认地址是 Docker Hub (docker.io) 仓库名：两段式名称，即 \u003c用户名\u003e/\u003c软件名\u003e。 对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。 例 $ docker pull ubuntu:18.04 # 更具体地 $ docker pull docker.io/library/ubuntu:18.04 上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （docker.io）获取镜像。镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。 下载过程： 18.04: Pulling from library/ubuntu 92dc2a97ff99: Pull complete be13a9d27eb8: Pull complete c8299583700a: Pull complete Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26 Status: Downloaded newer image for ubuntu:18.04 docker.io/library/ubuntu:18.04 从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。 下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。 试运行 以上面的 ubuntu:18.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。 $ docker run -it --rm ubuntu:18.04 bash -it：这是两个参数 -i：交互式操作 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 --rm：这个参数是说容器退出后随之将其删除。 默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。 我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 --rm 可以避免浪费空间。 ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:3:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"列出镜像 docker image ls 要想列出已经下载下来的镜像，可以使用 docker image ls 命令。 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB mongo 3.2 fe9198c04d62 5 days ago 342 MB \u003cnone\u003e \u003cnone\u003e 00285df0df87 5 days ago 342 MB ubuntu 18.04 329ed837d508 3 days ago 63.3MB ubuntu bionic 329ed837d508 3 days ago 63.3MB 列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。 镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:bionic 拥有相同的 ID，因为它们对应的是同一个镜像。 镜像体积 如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:18.04 镜像大小，在这里是 63.3MB，但是在 Docker Hub 显示的却是 25.47 MB。 这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。 而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。 另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。 你可以通过 docker system df 命令来便捷的查看镜像、容器、数据卷所占用的空间。 $ docker system df TYPE TOTAL ACTIVE SIZE RECLAIMABLE Images 24 0 1.992GB 1.992GB (100%) Containers 1 0 62.82MB 62.82MB (100%) Local Volumes 9 0 652.2MB 652.2MB (100%) Build Cache 0B 0B 虚悬镜像 上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 \u003cnone\u003e。 \u003cnone\u003e \u003cnone\u003e 00285df0df87 5 days ago 342 MB 这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 \u003cnone\u003e。 除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 \u003cnone\u003e 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像： $ docker image ls -f dangling=true REPOSITORY TAG IMAGE ID CREATED SIZE \u003cnone\u003e \u003cnone\u003e 00285df0df87 5 days ago 342 MB 一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。 $ docker image prune 中间层镜像 为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。 $ docker image ls -a 这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。 这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。 实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。 列出部分镜像 不加任何参数的情况下，docker image ls 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。 根据仓库名列出镜像 $ docker image ls ubuntu REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 329ed837d508 3 days ago 63.3MB ubuntu bionic 329ed837d508 3 days ago 63.3MB 列出特定的某个镜像，也就是说指定仓库名和标签 $ docker image ls ubuntu:18.04 REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 329ed837d508 3 days ago 63.3MB 除此以外，docker image ls 还支持强大的过滤器参数 --filter，或者简写 -f。 之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令： $ docker image ls -f since=mongo:3.2 REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB 想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。 此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。 $ docker image ls -f label=com.example.version=0.1 ... ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:3:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"删除本地镜像 docker image rm 如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为： $ docker image rm [选项] \u003c镜像1\u003e [\u003c镜像2\u003e ...] 用 ID、镜像名、摘要删除镜像 其中，\u003c镜像\u003e 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。 比如我们有这么一些镜像： $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE centos latest 0584b3d2cf6d 3 weeks ago 196.5 MB redis alpine 501ad78535f0 3 weeks ago 21.03 MB docker latest cf693ec9b5c7 3 weeks ago 105.1 MB nginx latest e43d811ce2f4 5 weeks ago 181.5 MB 我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。 docker image ls 默认列出的就已经是短 ID 了，一般取前 3 个字符以上，只要足够区分于别的镜像就可以了。 比如这里，如果我们要删除 redis:alpine 镜像，可以执行： $ docker image rm 501 我们也可以用镜像名，也就是 \u003c仓库名\u003e:\u003c标签\u003e，来删除镜像。 $ docker image rm centos 当然，更精确的是使用 镜像摘要 删除镜像。 Untagged 和 Deleted 如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。 因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。 因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。 当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。 镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。**直到没有任何层依赖当前层时，才会真实的删除当前层。**这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的原因。 除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。 用 docker image ls 命令来配合 像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。 比如，我们需要删除所有仓库名为 redis 的镜像： $ docker image rm $(docker image ls -q redis) 或者删除所有在 mongo:3.2 之前的镜像： $ docker image rm $(docker image ls -q -f before=mongo:3.2) ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:3:3","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"操作容器 镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。 容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。 这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。 按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者 绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。 数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:4:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"启动 启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（exited）的容器重新启动。 因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。 新建并启动 docker run 所需要的命令主要为 docker run。 例如，下面的命令输出一个 “Hello World”，之后终止容器。 $ docker run ubuntu:18.04 /bin/echo 'Hello world' Hello world 这跟在本地直接执行 /bin/echo 'hello world' 几乎感觉不出任何区别。 下面的命令则启动一个 bash 终端，允许用户进行交互。 $ docker run -t -i ubuntu:18.04 /bin/bash root@af8bae53bdd3:/# 其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。 当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括： 检查本地是否存在指定的镜像，不存在就从 registry 下载 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去 从地址池配置一个 ip 地址给容器 执行用户指定的应用程序 执行完毕后容器被终止 容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。 root@ba267838cc1b:/# ps PID TTY TIME CMD 1 ? 00:00:00 bash 11 ? 00:00:00 ps 可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。 守护态运行 -d 更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。 下面举两个例子来说明一下。 如果不使用 -d 参数运行容器。 $ docker run ubuntu:18.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" hello world hello world hello world hello world 容器会把输出的结果 (STDOUT) 打印到宿主机上面 如果使用了 -d 参数运行容器。 $ docker run -d ubuntu:18.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\" 77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a 此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面 (输出结果可以用 docker logs 查看)。 注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。 使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 77b2dc01fe0f ubuntu:18.04 /bin/sh -c 'while tr 2 minutes ago Up 1 minute agitated_wright 要获取容器的输出信息，可以通过 docker container logs 命令。 $ docker container logs [container ID or NAMES] hello world hello world hello world . . . ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:4:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"终止 docker container stop 可以使用 docker container stop 来终止一个运行中的容器。 此外，当 Docker 容器中指定的应用终结时，容器也自动终止。 例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。 终止状态的容器可以用 docker container ls -a 命令看到。例如 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ba267838cc1b ubuntu:18.04 \"/bin/bash\" 30 minutes ago Exited (0) About a minute ago trusting_newton 处于终止状态的容器，可以通过 docker container start 命令来重新启动。 此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:4:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"进入容器 在使用 -d 参数时，容器启动后会进入后台。 某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。 docker attach 下面示例如何使用 docker attach 命令。 $ docker run -dit ubuntu 243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 243c32535da7 ubuntu:latest \"/bin/bash\" 18 seconds ago Up 17 seconds nostalgic_hypatia $ docker attach 243c root@243c32535da7:/# 注意： 如果从这个 stdin 中 exit，会导致容器的停止。 docker exec docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。 只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。 当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。 $ docker run -dit ubuntu 69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 69d137adef7a ubuntu:latest \"/bin/bash\" 18 seconds ago Up 17 seconds zealous_swirles $ docker exec -i 69d1 bash ls bin boot dev ... $ docker exec -it 69d1 bash root@69d137adef7a:/# 如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:4:3","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"导出和导入 导出容器 docker export 如果要导出本地某个容器，可以使用 docker export 命令。 $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7691a814370e ubuntu:18.04 \"/bin/bash\" 36 hours ago Exited (0) 21 hours ago test $ docker export 7691a814370e \u003e ubuntu.tar 这样将导出容器快照到本地文件。 导入容器快照 docker import 可以使用 docker import 从容器快照文件中再导入为镜像，例如 $ cat ubuntu.tar | docker import - test/ubuntu:v1.0 $ docker image ls REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE test/ubuntu v1.0 9d37a6082e97 About a minute ago 171.3 MB 此外，也可以通过指定 URL 或者某个目录来导入，例如 $ docker import http://example.com/exampleimage.tgz example/imagerepo 用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。 这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。 此外，从容器快照文件导入时可以重新指定标签等元数据信息。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:4:4","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"删除 删除容器 docker container rm 可以使用 docker container rm 来删除一个处于终止状态的容器。例如 $ docker container rm trusting_newton trusting_newton 如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。 清理所有处于终止状态的容器 用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。 $ docker container prune ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:4:5","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"访问仓库 镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。 一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 \u003c仓库名\u003e:\u003c标签\u003e 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 仓库（Repository）是集中存放镜像的地方。 一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 docker.io/ubuntu 来说，docker.io 是注册服务器地址，ubuntu 是仓库名。 大部分时候，并不需要严格区分这两者的概念。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:5:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"Docker Hub 目前 Docker 官方维护了一个公共仓库 Docker Hub，其中已经包括了数量超过 2,650,000 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。 登录 docker login 可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。 你可以通过 docker logout 退出登录。 拉取镜像 docker pull 你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。 例如以 centos 为关键词进行搜索： $ docker search centos NAME DESCRIPTION STARS OFFICIAL AUTOMATED centos The official build of CentOS. 6449 [OK] ansible/centos7-ansible Ansible on Centos7 132 [OK] consol/centos-xfce-vnc Centos container with … 126 [OK] jdeathe/centos-ssh OpenSSH / Supervisor … 117 [OK] centos/systemd systemd enabled base container. 96 [OK] 可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（OFFICIAL）、是否自动构建 （AUTOMATED）。 根据是否是官方提供，可将镜像分为两类。 一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。 还有一种类型，比如 ansible/centos7-ansible 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 ansible 用户。 另外，在查找的时候通过 --filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像。 下载官方 centos 镜像到本地。 $ docker pull centos Using default tag: latest latest: Pulling from library/centos 7a0437f04f83: Pull complete Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1 Status: Downloaded newer image for centos:latest docker.io/library/centos:latest 推送镜像 docker push 用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。 以下命令中的 username 请替换为你的 Docker 账号用户名。 $ docker tag ubuntu:18.04 username/ubuntu:18.04 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu 18.04 275d79972a86 6 days ago 94.6MB username/ubuntu 18.04 275d79972a86 6 days ago 94.6MB $ docker push username/ubuntu:18.04 $ docker search username NAME DESCRIPTION STARS OFFICIAL AUTOMATED username/ubuntu ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:5:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"数据管理 这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式： 数据卷（Volumes） 挂载主机目录 (Bind mounts) 实际上，Docker 提供了三种不同的方式用于将宿主的数据挂载到容器中：volumes，bind mounts，tmpfs volumes。当你不知道该选择哪种方式时，记住，volumes 总是正确的选择。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:6:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"数据卷 volumn 数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性： 数据卷 可以在容器之间共享和重用 对 数据卷 的修改会立马生效 对 数据卷 的更新，不会影响镜像 数据卷 默认会一直存在，即使容器被删除 注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。 创建一个数据卷 $ docker volume create my-vol 查看所有的 数据卷 $ docker volume ls DRIVER VOLUME NAME local my-vol 在主机里使用以下命令可以查看指定 数据卷 的信息 $ docker volume inspect my-vol [ { \"Driver\": \"local\", \"Labels\": {}, \"Mountpoint\": \"/var/lib/docker/volumes/my-vol/_data\", \"Name\": \"my-vol\", \"Options\": {}, \"Scope\": \"local\" } ] 启动一个挂载数据卷的容器 在用 docker run 命令的时候，使用 --mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。 下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /usr/share/nginx/html 目录。 $ docker run -d -P \\ --name web \\ # -v my-vol:/usr/share/nginx/html \\ --mount source=my-vol,target=/usr/share/nginx/html \\ nginx:alpine 查看数据卷的具体信息 在主机里使用以下命令可以查看 web 容器的信息 $ docker inspect web 数据卷 信息在 “Mounts” Key 下面 \"Mounts\": [ { \"Type\": \"volume\", \"Name\": \"my-vol\", \"Source\": \"/var/lib/docker/volumes/my-vol/_data\", \"Destination\": \"/usr/share/nginx/html\", \"Driver\": \"local\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"\" } ], 删除数据卷 $ docker volume rm my-vol 数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。 如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。 无主的数据卷可能会占据很多空间，要清理请使用以下命令 $ docker volume prune ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:6:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"挂载主机目录 bind mount 挂载一个主机目录作为数据卷 使用 --mount 标记可以指定挂载一个本地主机的目录到容器中去。 $ docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html \\ nginx:alpine 上面的命令加载主机的 /src/webapp 目录到容器的 /usr/share/nginx/html目录。 这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 --mount 参数时如果本地目录不存在，Docker 会报错。 Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。 $ docker run -d -P \\ --name web \\ # -v /src/webapp:/usr/share/nginx/html:ro \\ --mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly \\ nginx:alpine 加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /usr/share/nginx/html 目录新建文件，会显示如下错误 /usr/share/nginx/html # touch new.txt touch: new.txt: Read-only file system 查看数据卷的具体信息 在主机里使用以下命令可以查看 web 容器的信息 $ docker inspect web 挂载主机目录 的配置信息在 “Mounts” Key 下面 \"Mounts\": [ { \"Type\": \"bind\", \"Source\": \"/src/webapp\", \"Destination\": \"/usr/share/nginx/html\", \"Mode\": \"\", \"RW\": true, \"Propagation\": \"rprivate\" } ], 挂载一个本地主机文件作为数据卷 --mount 标记也可以从主机挂载单个文件到容器中 $ docker run --rm -it \\ # -v $HOME/.bash_history:/root/.bash_history \\ --mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \\ ubuntu:18.04 \\ bash root@2affd44b4667:/# history 1 ls 2 diskutil list 这样就可以记录在容器输入过的命令了。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:6:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"volume 和 bind 的区别 volume：如果 volume 是空的而 container 中的目录有内容，那么 docker 会将 container 目录中的内容拷贝到 volume 中，但是如果 volume 中已经有内容，则会将 container 中的目录覆盖。 bind mount :不管 host 目录是否有值，都会覆盖 container 映射的目录 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:6:3","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"使用网络 Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:7:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"外部访问容器 容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。 当使用 -P 标记时，Docker 会随机映射一个端口到内部容器开放的网络端口。 使用 docker container ls 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。 $ docker run -d -P nginx:alpine $ docker container ls -l CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES fae320d08268 nginx:alpine \"/docker-entrypoint.…\" 24 seconds ago Up 20 seconds 0.0.0.0:32768-\u003e80/tcp bold_mcnulty 同样的，可以通过 docker logs 命令来查看访问记录。 $ docker logs fa 172.17.0.1 - - [25/Aug/2020:08:34:04 +0000] \"GET / HTTP/1.1\" 200 612 \"-\" \"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0\" \"-\" -p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。 支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。 映射所有接口地址 使用 hostPort:containerPort 格式本地的 80 端口映射到容器的 80 端口，可以执行 $ docker run -d -p 80:80 nginx:alpine 此时默认会绑定本地所有接口上的所有地址。 映射到指定地址的指定端口 可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1 $ docker run -d -p 127.0.0.1:80:80 nginx:alpine 映射到指定地址的任意端口 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。 $ docker run -d -p 127.0.0.1::80 nginx:alpine 还可以使用 udp 标记来指定 udp 端口 $ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine 查看映射端口配置 docker port 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址 $ docker port fa 80 0.0.0.0:32768 注意： 容器有自己的内部网络和 ip 地址（使用 docker inspect 查看，Docker 还可以有一个可变的网络配置。） -p 标记可以多次使用来绑定多个端口 例如 $ docker run -d \\ -p 80:80 \\ -p 443:443 \\ nginx:alpine ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:7:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"容器互联 如果你之前有 Docker 使用经验，你可能已经习惯了使用 --link 参数来使容器互联。 随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 --link 参数。 新建网络 docker network create 下面先创建一个新的 Docker 网络。 $ docker network create -d bridge my-net -d 参数指定 Docker 网络类型，有 bridge 和 overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。 连接容器 运行一个容器并连接到新建的 my-net 网络 $ docker run -it --rm --name busybox1 --network my-net busybox sh 打开新的终端，再运行一个容器并加入到 my-net 网络 $ docker run -it --rm --name busybox2 --network my-net busybox sh 再打开一个新的终端查看容器信息 $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES b47060aca56b busybox \"sh\" 11 minutes ago Up 11 minutes busybox2 8720575823ec busybox \"sh\" 16 minutes ago Up 16 minutes busybox1 下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。 在 busybox1 容器输入以下命令 / # ping busybox2 PING busybox2 (172.19.0.3): 56 data bytes 64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms 64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms 用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。 同理在 busybox2 容器执行 ping busybox1，也会成功连接到。 / # ping busybox1 PING busybox1 (172.19.0.2): 56 data bytes 64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms 64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms 这样，busybox1 容器和 busybox2 容器建立了互联关系。 Docker Compose 如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:7:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"常用命令 https://zhuanlan.zhihu.com/p/150951927#:~:text=Docker%20%28%E4%B8%80%29-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%201%201.%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A%20docker%20images%202%202.%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A,5.%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%9A%20docker%20restart%20mysql01%2010%206.%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:8:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"使用 Dockerfile 定制镜像 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么一些无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。 Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。 还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。 在一个空白目录中，建立一个文本文件，并命名为 Dockerfile： $ mkdir mynginx $ cd mynginx $ touch Dockerfile 其内容为： FROM nginx RUN echo '\u003ch1\u003eHello, Docker!\u003c/h1\u003e' \u003e /usr/share/nginx/html/index.html 这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:9:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"FROM 指定基础镜像 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。 在 Docker Hub 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。 如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。 除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。 FROMscratch... 如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。 不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:9:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"RUN 执行命令 RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种： shell 格式：RUN \u003c命令\u003e，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。 exec 格式：RUN [\"可执行文件\", \"参数1\", \"参数2\"]，这更像是函数调用中的格式。 既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样： FROMdebian:stretchRUN apt-get updateRUN apt-get install -y gcc libc6-dev make wgetRUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\"RUN mkdir -p /usr/src/redisRUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1RUN make -C /usr/src/redisRUN make -C /usr/src/redis install 之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。 而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。 Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。 上面的 Dockerfile 正确的写法应该是这样： FROMdebian:stretchRUN set -x; buildDeps='gcc libc6-dev make wget' \\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get install -y $buildDeps \\ \u0026\u0026 wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ \u0026\u0026 mkdir -p /usr/src/redis \\ \u0026\u0026 tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ \u0026\u0026 make -C /usr/src/redis \\ \u0026\u0026 make -C /usr/src/redis install \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* \\ \u0026\u0026 rm redis.tar.gz \\ \u0026\u0026 rm -r /usr/src/redis \\ \u0026\u0026 apt-get purge -y --auto-remove $buildDeps 首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 \u0026\u0026 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。 并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \\ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。 此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。 很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:9:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"构建镜像 好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。 在 Dockerfile 文件所在目录执行： $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB Step 1 : FROM nginx ---\u003e e43d811ce2f4 Step 2 : RUN echo '\u003ch1\u003eHello, Docker!\u003c/h1\u003e' \u003e /usr/share/nginx/html/index.html ---\u003e Running in 9cdc27646c7b ---\u003e 44aa4490ce2c Removing intermediate container 9cdc27646c7b Successfully built 44aa4490ce2c 从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。 这里我们使用了 docker build 命令进行镜像构建。其格式为： docker build [选项] \u003c上下文路径/URL/-\u003e 在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:9:3","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"镜像构建上下文（Context） 如果注意，会看到 docker build 命令最后有一个 .。 . 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 上下文路径。那么什么是上下文呢？ 首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。 如果在 Dockerfile 中这么写： COPY ./package.json /app/ 这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。 因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。 如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程： $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB ... 理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。 一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。 这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。 当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:9:4","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"其它 docker build 的用法 直接用 Git repo 进行构建 或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建： # $env:DOCKER_BUILDKIT=0 # export DOCKER_BUILDKIT=0 $ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world Step 1/3 : FROM scratch ---\u003e Step 2/3 : COPY hello / ---\u003e ac779757d46e Step 3/3 : CMD [\"/hello\"] ---\u003e Running in d2a513a760ed Removing intermediate container d2a513a760ed ---\u003e 038ad4142d2b Successfully built 038ad4142d2b 这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 /amd64/hello-world/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。 用给定的 tar 压缩包构建 $ docker build http://server/context.tar.gz 如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。 从标准输入中读取 Dockerfile 进行构建 $ docker build - \u003c Dockerfile 或 $ cat Dockerfile | docker build - 如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。 从标准输入中读取上下文压缩包进行构建 $ docker build - \u003c context.tar.gz 如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:9:5","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"Dockerfile 指令详解 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"COPY 复制文件 格式： COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] \u003c源路径\u003e... \u003c目标路径\u003e COPY [--chown=\u003cuser\u003e:\u003cgroup\u003e] [\"\u003c源路径1\u003e\",... \"\u003c目标路径\u003e\"] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 \u003c源路径\u003e 的文件/目录复制到新的一层的镜像内的 \u003c目标路径\u003e 位置。比如： COPY package.json /usr/src/app/ \u003c源路径\u003e 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如： COPY hom* /mydir/COPY hom?.txt /mydir/ \u003c目标路径\u003e 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 在使用该指令的时候还可以加上 --chown=\u003cuser\u003e:\u003cgroup\u003e 选项来改变文件的所属用户及所属组。 COPY --chown=55:mygroup files* /mydir/COPY --chown=bin files* /mydir/COPY --chown=1 files* /mydir/COPY --chown=10:11 files* /mydir/ 如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将文件夹中的内容复制到目标路径。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"ADD 更高级的复制文件 ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 \u003c源路径\u003e 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 \u003c目标路径\u003e 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 如果 \u003c源路径\u003e 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 \u003c目标路径\u003e 去。 在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中： FROM scratch ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz / ... 但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。 在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。 另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。 因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。 在使用该指令的时候还可以加上 --chown=\u003cuser\u003e:\u003cgroup\u003e 选项来改变文件的所属用户及所属组。 ADD --chown=55:mygroup files* /mydir/ADD --chown=bin files* /mydir/ADD --chown=1 files* /mydir/ADD --chown=10:11 files* /mydir/ ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"CMD 容器启动命令 指定容器启动程序及参数 CMD 指令的格式和 RUN 相似，也是两种格式： shell 格式：CMD \u003c命令\u003e exec 格式：CMD [\"可执行文件\", \"参数1\", \"参数2\"...] 参数列表格式：CMD [\"参数1\", \"参数2\"...]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。 之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 \"，而不要使用单引号。 如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： CMD echo $HOME 在实际执行中，会将其变更为： CMD [ \"sh\", \"-c\", \"echo $HOME\" ] 这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。 提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。 Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。 一些初学者将 CMD 写为： CMD service nginx start 然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。 对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。 而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ \"sh\", \"-c\", \"service nginx start\"]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。 正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如： CMD [\"nginx\", \"-g\", \"daemon off;\"] ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:3","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"ENTRYPOINT 入口点 ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 --entrypoint 来指定。 当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： \u003cENTRYPOINT\u003e \"\u003cCMD\u003e\" 那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 \u003cENTRYPOINT\u003e \"\u003cCMD\u003e\" 有什么好处么？让我们来看几个场景。 场景一：让镜像变成像命令一样使用 假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： FROMubuntu:18.04RUN apt-get update \\ \u0026\u0026 apt-get install -y curl \\ \u0026\u0026 rm -rf /var/lib/apt/lists/*CMD [ \"curl\", \"-s\", \"http://myip.ipip.net\" ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行： $ docker run myip 当前 IP：61.148.226.66 来自：北京市 联通 嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ $ docker run myip -i docker: Error response from daemon: invalid header field value \"oci runtime error: container_linux.go:247: starting container process caused \\\"exec: \\\\\\\"-i\\\\\\\": executable file not found in $PATH\\\"\\n\". 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://myip.ipip.net 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： $ docker run myip curl -s http://myip.ipip.net -i 这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像： FROM ubuntu:18.04 RUN apt-get update \\ \u0026\u0026 apt-get install -y curl \\ \u0026\u0026 rm -rf /var/lib/apt/lists/* ENTRYPOINT [ \"curl\", \"-s\", \"http://myip.ipip.net\" ] 这次我们再来尝试直接使用 docker run myip -i： $ docker run myip 当前 IP：61.148.226.66 来自：北京市 联通 $ docker run myip -i HTTP/1.1 200 OK Server: nginx/1.8.0 Date: Tue, 22 Nov 2016 05:12:40 GMT Content-Type: text/html; charset=UTF-8 Vary: Accept-Encoding X-Powered-By: PHP/5.6.24-1~dotdeb+7.1 X-Cache: MISS from cache-2 X-Cache-Lookup: MISS from cache-2:80 X-Cache: MISS from proxy-2_6 Transfer-Encoding: chunked Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006 Connection: keep-alive 当前 IP：61.148.226.66 来自：北京市 联通 可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景二：应用运行前的准备工作 启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 \u003cCMD\u003e）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： FROM alpine:3.4 ... RUN addgroup -S redis \u0026\u0026 adduser -S -G redis redis ... ENTRYPOINT [\"docker-entrypoint.sh\"] EXPOSE 6379 CMD [ \"redis-server\" ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。 #!/bin/sh ... # allow the container to be started with `--user` if [ \"$1\" = 'redis-server' -a \"$(id -u)\" = '0' ]; then find . \\! -user redis -exec chown redis '{}' + exec gosu redis \"$0\" \"$@\" fi exec \"$@\" 该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如： $ docker run -it redis id uid=0(root) gid=0(root) groups=0(root) ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:4","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"ENV 设置环境变量 格式有两种： ENV \u003ckey\u003e \u003cvalue\u003e ENV \u003ckey1\u003e=\u003cvalue1\u003e \u003ckey2\u003e=\u003cvalue2\u003e... 这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。 ENV VERSION=1.0 DEBUG=on \\ NAME=\"Happy Feet\" 这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。 定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码： ENV NODE_VERSION 7.2.0RUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\ \u0026\u0026 curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" \\ \u0026\u0026 gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \\ \u0026\u0026 grep \" node-v$NODE_VERSION-linux-x64.tar.xz\\$\" SHASUMS256.txt | sha256sum -c - \\ \u0026\u0026 tar -xJf \"node-v$NODE_VERSION-linux-x64.tar.xz\" -C /usr/local --strip-components=1 \\ \u0026\u0026 rm \"node-v$NODE_VERSION-linux-x64.tar.xz\" SHASUMS256.txt.asc SHASUMS256.txt \\ \u0026\u0026 ln -s /usr/local/bin/node /usr/local/bin/nodejs 在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。 下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。 可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:5","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"ARG 构建参数 格式：ARG \u003c参数名\u003e[=\u003c默认值\u003e] 构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 --build-arg \u003c参数名\u003e=\u003c值\u003e 来覆盖。 灵活的使用 ARG 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。 ARG 指令有生效范围，如果在 FROM 指令之前指定，那么只能用于 FROM 指令中。 ARG DOCKER_USERNAME=library FROM${DOCKER_USERNAME}/alpineRUN set -x ; echo ${DOCKER_USERNAME} 使用上述 Dockerfile 会发现无法输出 ${DOCKER_USERNAME} 变量的值，要想正常输出，你必须在 FROM 之后再次指定 ARG # 只在 FROM 中生效ARG DOCKER_USERNAME=library FROM${DOCKER_USERNAME}/alpine# 要想在 FROM 之后使用，必须再次指定ARG DOCKER_USERNAME=library RUN set -x ; echo ${DOCKER_USERNAME} 对于多阶段构建，尤其要注意这个问题 # 这个变量在每个 FROM 中都生效ARG DOCKER_USERNAME=library FROM${DOCKER_USERNAME}/alpineRUN set -x ; echo 1FROM${DOCKER_USERNAME}/alpineRUN set -x ; echo 2 对于上述 Dockerfile 两个 FROM 指令都可以使用 ${DOCKER_USERNAME}，对于在各个阶段中使用的变量都必须在每个阶段分别指定 ARG DOCKER_USERNAME=library FROM${DOCKER_USERNAME}/alpine# 在FROM 之后使用变量，必须在每个阶段分别指定ARG DOCKER_USERNAME=library RUN set -x ; echo ${DOCKER_USERNAME}FROM${DOCKER_USERNAME}/alpine# 在FROM 之后使用变量，必须在每个阶段分别指定ARG DOCKER_USERNAME=library RUN set -x ; echo ${DOCKER_USERNAME} ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:6","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"VOLUME 定义匿名卷 格式为： VOLUME [\"\u003c路径1\u003e\", \"\u003c路径2\u003e\"...] VOLUME \u003c路径\u003e 之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷 (volume) 中；为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。 VOLUME/data 这里的 /data 目录就会在容器运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如： $ docker run -d -v mydata:/data xxxx 在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:7","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"EXPOSE 暴露端口 格式为 EXPOSE \u003c端口1\u003e [\u003c端口2\u003e...]。 EXPOSE 指令是声明容器运行时提供服务的端口，这只是一个声明，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。 在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 应该将 EXPOSE 和在运行时使用 -p \u003c宿主端口\u003e:\u003c容器端口\u003e 区分开来。 -p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问 而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:8","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"WORKDIR 指定工作目录 格式为 WORKDIR \u003c工作目录路径\u003e。 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。 之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误： RUN cd /appRUN echo \"hello\" \u003e world.txt 如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。 原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。 之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。 因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。 WORKDIR/appRUN echo \"hello\" \u003e world.txt 如果你的 WORKDIR 指令使用的相对路径，那么所切换的路径与之前的 WORKDIR 有关 WORKDIR/aWORKDIRbWORKDIRcRUN pwd RUN pwd 的工作目录为 /a/b/c。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:9","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"USER 指定当前用户 格式：USER \u003c用户名\u003e[:\u003c用户组\u003e] USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。 注意，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。 RUN groupadd -r redis \u0026\u0026 useradd -r -g redis redisUSERredisRUN [ \"redis-server\" ] 如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。 # 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis \u0026\u0026 useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64\" \\ \u0026\u0026 chmod +x /usr/local/bin/gosu \\ \u0026\u0026 gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ \"exec\", \"gosu\", \"redis\", \"redis-server\" ] ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:10","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"HEALTHCHECK 健康检查 格式： HEALTHCHECK [选项] CMD \u003c命令\u003e：设置检查容器健康状况的命令 HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。 在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。 而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。 当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 HEALTHCHECK 支持下列选项： --interval=\u003c间隔\u003e：两次健康检查的间隔，默认为 30 秒； --timeout=\u003c时长\u003e：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒； --retries=\u003c次数\u003e：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。 假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写： FROMnginxRUN apt-get update \u0026\u0026 apt-get install -y curl \u0026\u0026 rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \\ CMD curl -fs http://localhost/ || exit 1 这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。 使用 docker build 来构建这个镜像： $ docker build -t myweb:v1 . 构建好了后，我们启动一个容器： $ docker run -d --name web -p 80:80 myweb:v1 当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)： $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 \"nginx -g 'daemon off\" 3 seconds ago Up 2 seconds (health: starting) 80/tcp, 443/tcp web 在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)： $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 03e28eb00bd0 myweb:v1 \"nginx -g 'daemon off\" 18 seconds ago Up 16 seconds (healthy) 80/tcp, 443/tcp web 如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。 为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。 $ docker inspect --format '{{json .State.Health}}' web | python -m json.tool { \"FailingStreak\": 0, \"Log\": [ { \"End\": \"2016-11-25T14:35:37.940957051Z\", \"ExitCode\": 0, \"Output\": \"\u003c!DOCTYPE html\u003e\\n\u003chtml\u003e\\n\u003chead\u003e\\n\u003ctitle\u003eWelcome to nginx!\u003c/title\u003e\\n\u003cstyle\u003e\\n body {\\n width: 35em;\\n margin: 0 auto;\\n font-family: Tahoma, Verdana, Arial, sans-serif;\\n }\\n\u003c/style\u003e\\n\u003c/head\u003e\\n\u003cbody\u003e\\n\u003ch1\u003eWelcome to nginx!\u003c/h1\u003e\\n\u003cp\u003eIf you see this page, the nginx web server is successfully installed and\\nworking. Further configuration is required.\u003c/p\u003e\\n\\n\u003cp\u003eFor online documentation and support please refer to\\n\u003ca href=\\\"http://nginx.org/\\\"\u003enginx.org\u003c/a\u003e.\u003cbr/\u003e\\nCommercial support is available at\\n\u003ca href=\\\"http://nginx.com/\\\"\u003enginx.com\u003c/a\u003e.\u003c/p\u003e\\n\\n\u003cp\u003e\u003cem\u003eThank you for using nginx.\u003c/em\u003e\u003c/p\u003e\\n\u003c/body\u003e\\n\u003c/html\u003e\\n\", \"Start\": \"2016-11-25T14:35:37.780192565Z\" } ], \"Status\": \"healthy\" } ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:11","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"ONBUILD 为他人作嫁衣裳 格式：ONBUILD \u003c其它指令\u003e。 ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。 Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。 假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile： FROMnode:slimRUN mkdir /appWORKDIR/appCOPY ./package.json /appRUN [ \"npm\", \"install\" ]COPY . /app/CMD [ \"npm\", \"start\" ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为： FROMnode:slimRUN mkdir /appWORKDIR/appCMD [ \"npm\", \"start\" ] 这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为： FROMmy-nodeCOPY ./package.json /appRUN [ \"npm\", \"install\" ]COPY . /app/ 基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。 那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前 4 条指令的变化问题，而后面三条指令的变化则完全没办法处理。 ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile: FROMnode:slimRUN mkdir /appWORKDIR/appONBUILD COPY ./package.json /appONBUILD RUN [ \"npm\", \"install\" ]ONBUILD COPY . /app/CMD [ \"npm\", \"start\" ] 这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地： FROMmy-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:12","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"LABEL 为镜像添加元数据 LABEL 指令用来给镜像以键值对的形式添加一些元数据（metadata）。 LABEL \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e \u003ckey\u003e=\u003cvalue\u003e ... 我们还可以用一些标签来申明镜像的作者、文档地址等： LABEL org.opencontainers.image.authors=\"yeasy\"LABEL org.opencontainers.image.documentation=\"https://yeasy.gitbooks.io\" 具体可以参考 https://github.com/opencontainers/image-spec/blob/master/annotations.md ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:13","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"SHELL 指令 格式：SHELL [\"executable\", \"parameters\"] SHELL 指令可以指定 RUN ENTRYPOINT CMD 指令的 shell，Linux 中默认为 [\"/bin/sh\", \"-c\"] SHELL [\"/bin/sh\", \"-c\"]RUN lll ; lsSHELL [\"/bin/sh\", \"-cex\"]RUN lll ; ls 两个 RUN 运行同一命令，第二个 RUN 运行的命令会打印出每条命令并当遇到错误时退出。 当 ENTRYPOINT CMD 以 shell 格式指定时，SHELL 指令所指定的 shell 也会成为这两个指令的 shell SHELL [\"/bin/sh\", \"-cex\"]# /bin/sh -cex \"nginx\"ENTRYPOINT nginx SHELL [\"/bin/sh\", \"-cex\"]# /bin/sh -cex \"nginx\"CMD nginx ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:10:14","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"Dockerfile 多阶段构建 ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:11:0","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"之前的做法 在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式： 全部放入一个 Dockerfile 一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题： 镜像层次多，镜像体积较大，部署时间变长 源代码存在泄露的风险 例如，编写 app.go 文件，该程序输出 Hello World! package main import \"fmt\" func main(){ fmt.Printf(\"Hello World!\"); } 编写 Dockerfile.one 文件 FROMgolang:alpineRUN apk --no-cache add git ca-certificatesWORKDIR/go/src/github.com/go/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \\ \u0026\u0026 CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \\ \u0026\u0026 cp /go/src/github.com/go/helloworld/app /rootWORKDIR/root/CMD [\"./app\"] 构建镜像 $ docker build -t go/helloworld:1 -f Dockerfile.one . 分散到多个 Dockerfile 另一种方式，就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。 例如，编写 Dockerfile.build 文件 FROMgolang:alpineRUN apk --no-cache add gitWORKDIR/go/src/github.com/go/helloworldCOPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \\ \u0026\u0026 CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . 编写 Dockerfile.copy 文件 FROMalpine:latestRUN apk --no-cache add ca-certificatesWORKDIR/root/COPY app .CMD [\"./app\"] 新建 build.sh #!/bin/sh echo Building go/helloworld:build docker build -t go/helloworld:build . -f Dockerfile.build docker create --name extract go/helloworld:build docker cp extract:/go/src/github.com/go/helloworld/app ./app docker rm -f extract echo Building go/helloworld:2 docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy rm ./app 现在运行脚本即可构建镜像 $ chmod +x build.sh $ ./build.sh 对比两种方式生成的镜像大小 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE go/helloworld 2 f7cf3465432c 22 seconds ago 6.47MB go/helloworld 1 f55d3e16affc 2 minutes ago 295MB ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:11:1","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Golang"],"content":"使用多阶段构建 为解决以上问题，Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile： 例如，编写 Dockerfile 文件 FROMgolang:alpine as builderRUN apk --no-cache add gitWORKDIR/go/src/github.com/go/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROMalpine:latest as prodRUN apk --no-cache add ca-certificatesWORKDIR/root/COPY --from=0 /go/src/github.com/go/helloworld/app .CMD [\"./app\"] 构建镜像 $ docker build -t go/helloworld:3 . 对比三个镜像大小 $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE go/helloworld 3 d6911ed9c846 7 seconds ago 6.47MB go/helloworld 2 f7cf3465432c 22 seconds ago 6.47MB go/helloworld 1 f55d3e16affc 2 minutes ago 295MB 很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。 只构建某一阶段的镜像 我们可以使用 as 来为某一阶段命名，例如 FROMgolang:alpine as builder 例如当我们只想构建 builder 阶段的镜像时，增加 --target=builder 参数即可 $ docker build --target builder -t username/imagename:tag . 构建时从其他镜像复制文件 上面例子中我们使用 COPY --from=0 /go/src/github.com/go/helloworld/app . 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。 $ COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf ","date":"2022-03-07","objectID":"/Notes/posts/golang/docker/:11:2","tags":[],"title":"Docker","uri":"/Notes/posts/golang/docker/"},{"categories":["Python"],"content":"pandas ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:0:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"分类与创建 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:1:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"Series Series 是一种类似于以为NumPy数组的对象，它由一组数据（各种NumPy数据类型）和与之相关的一组数据标签（即索引）组成的。可以用index和values分别规定索引和值。如果不规定索引，会自动创建 0 到 N-1 索引。 Series是1维的数据，拥有的索引，一般以竖行形式输出 创建 Series可以方便的通过list，array还有dict来构建 pd.Series() import numpy as np import pandas as pd mylist = list('abc') myarr = np.arange(3) mydict = dict(zip(mylist, myarr)) ser1 = pd.Series(mylist) #使用列表创建 ser2 = pd.Series(myarr) #使用数组创建 ser3 = pd.Series(mydict) #使用字典创建 print(ser1,'\\n') print(ser2,'\\n') print(ser3,'\\n') 输出 0 a 1 b 2 c dtype: object 0 0 1 1 2 2 dtype: int32 a 0 b 1 c 2 dtype: int64 在构建Series的时候，指定index来代替默认的0~n数字式索引 ser4 = pd.Series([100, 200, 150], index=['apple', 'banana', 'peach']) print(ser4) apple 100 banana 200 peach 150 dtype: int64 访问 下标方式访问 ser4['banana'] index方式访问 ser4[1] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:1:1","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"DataFrame DataFrame是一种表格型结构，含有一组有序的列，每一列可以是不同的数据类型。既有行索引，又有列索引从具有索引标签的字典数据创建 data = {'animal': ['cat', 'cat', 'snake', 'dog', 'dog', 'cat', 'snake', 'cat', 'dog', 'dog'], 'age': [2.5, 3, 0.5, np.nan, 5, 2, 4.5, np.nan, 7, 3], 'visits': [1, 3, 2, 3, 2, 3, 1, 1, 2, 1], 'priority': ['yes', 'yes', 'no', 'yes', 'no', 'no', 'no', 'yes', 'no', 'no']} labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'] df = pd.DataFrame(data,index = labels) df 输出 从 numpy 数组创建 df2 = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), columns=['a', 'b', 'c']) df2 输出 df = pd.DataFrame(np.arange(9).reshape(3, 3), index = [ \"Mon\", \"Tue\", \"Wed\"], columns=['store1', 'store2', 'store3']) df 输出 通过其他DataFrame来创建 df3 = df2[[\"a\",\"b\",\"c\"]].copy() df3 输出 从csv文件创建 df = pd.read_csv('path') df = pd.read_csv('test.csv', encoding='gbk', sep=';') #分隔符为“；”，编码格式为gbk 用Series创建 s_1 = pd.Series(data['animal']) s_2 = pd.Series(data['age']) s_3 = pd.Series(data['visits']) s_4 = pd.Series(data['priority']) df = pd.DataFrame([s_1,s_2,s_3,s_4]) df 输出 这玩意可以看做是多个Series的组合。DataFrame的不同列可以是不同的数据类型,如果以Series数组来创建DataFrame，每个Series将成为一行，而不是一列 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:1:2","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"审视 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:2:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"访问 以下图为例 col，index为列号和行号 colName，indexName为具体值 df[colName] 根据列名，并以 Series 的形式返回列 若列名为默认的数字时，colName 可以被视为 col（其中就col可以表示为列表形式和切片形式） df['a'] #取a列 df.a #也可 df[['b','e','f']] #取b,e,f列 输出 特殊情况下，df[colName] 可以接收行名称或者行数，但必须是切片 df[0:1] # 第1行 df[0:3] # 前3行 df['5':'5'] # 行名称为5的行 df['5':'7'] # 行名称为5的行至行名称为7的行 df[colName][indexName] 更精准的访问（几列几行） 若列名为默认的数字时，colName可以被视为col（其中就col可以表示为列表形式和切片形式） df['c']['B'] 输出 0.5 df.iloc[index, col] 其中index，col可以表示为列表形式和切片形式，当只传入一个参数时，该参数默认为index df.iloc[0:1] # 取第0行数据，较为规范 df.iloc[0] # 硬要这样俺也没办法 df.iloc[:,[2]] # 取第2列数据 df.iloc[0:3,2:6] # 取0到2行，2到5列数据 df.iloc[[0,3],[2,3,7]] # 取0和3行，2、3、7列相交数据 输出 df.loc[indexName,colName] df.iloc只能选取数据表里实际有的行和列，而df.loc可以选取没有的行和列，赋值后就可以添加新行或者列 df.loc[:,'c'] #选取c列 df.loc[['A','C'],['c','e','f']] #选取A,C列，c,e,f行相交数据 df.loc[df['c']=='snake'] #选取c列中内容为snake的行数据 输出 df.ix[in,co] ix是loc和iloc的混合，既能按索引标签提取，也能按位置进行数 据提取 筛选 df.loc[df.index[[1,3]], ['d','f']] #筛选出索引为1，3行的d，f列 df[df['d'] \u003e 3] #筛选d（列名）值大于3的行 df[df['d'].isnull()] #筛选d（列名）值为空的行 df['A'].isin(['cat']) #筛选A列中含有cat的行 #输出 a True b True c False d False e False f True g False h True i False j False Name: A, dtype: bool df.query() 以下表为例 A B C 0 1 10 2 1 2 8 2 2 3 6 2 3 4 4 2 4 5 2 2 df = pd.DataFrame({ 'A': range(1,6), 'B': range(10, 0, -2), 'C': 2 }) df.query('B == 2') # 查询B列中数值为2的行记录 df[df.A \u003c df.B] # 查询A列数值小于B列的行记录 df.query('A \u003c B') df[df.B == df['C C']] # 查询B列数值和C C列相等的行记录 输出 A B C 4 5 2 2 A B C 0 1 10 2 1 2 8 2 2 3 6 2 A B C 4 5 2 2 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:2:1","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"查看 查看行数、列数 df.shape 输出 (4, 10) 查看整体信息 使用info函数查看数据表的整体信息，包括数据维度、列名称、数据格式和所占空间等信息 df.info() 输出 \u003cclass 'pandas.core.frame.DataFrame'\u003e Index: 4 entries, A to D Data columns (total 10 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 a 4 non-null object 1 b 4 non-null object 2 c 4 non-null object 3 d 3 non-null object 4 e 4 non-null object 5 f 4 non-null object 6 g 4 non-null object 7 h 3 non-null object 8 i 4 non-null object 9 j 4 non-null object dtypes: object(10) memory usage: 352.0+ bytes 查看数据格式 使用dtypes函数来返回数据格式 df.dtypes #查看数据表各列格式 df['B'].dtype #查看单列格式 输出 a object b object c object d object e object f object g object h object i object j object dtype: object dtype('O') 查看缺失值 df.isnull() # 检查数据空值 df['h'].isnull() # 检查特定列空值 df.isnull().sum() # 查看各列的缺失值个数 df.isnull().any() # 查看各列是否有缺失值 df.isnan() #判断nan值 输出 A False B True C False D False Name: h, dtype: bool 查看唯一值 df['a'].unique() #查看a列中的唯一值 输出 array(['cat', 2.5, 1, 'yes'], dtype=object) 查看数据表数值 df.values 输出 array([['cat', 'cat', 'snake', 'dog', 'dog', 'cat', 'snake', 'cat', 'dog', 'dog'], [2.5, 3.0, 0.5, nan, 5.0, 2.0, 4.5, nan, 7.0, 3.0], [1, 3, 2, 3, 2, 3, 1, 1, 2, 1], ['yes', 'yes', 'no', 'yes', 'no', 'no', 'no', 'yes', 'no', 'no']], dtype=object) 查看行、列名称 返回 Index 对象 df.columns #查看列名称 df.index #查看行名称 输出 Index(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], dtype='object') Index(['A', 'B', 'C', 'D'], dtype='object') 查看前后n行数据 df.head(5) df.tail(3) 显示全部数据 # 设置行不限制数量 pd.set_option('display.max_rows',None) # 设置列不限制数量 pd.set_option('display.max_columns',None) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:2:2","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"统计 以下图为例 对数据的统计汇总 只会统计数值型数据 df.describe() 输出 排序 df.sort_values df.sort_values(by=['C']) #按特定列的值升序排序 df.sort_values(by=['B'],ascending=False) #降序排序 df.sort_values(by=['B', 'C'], ascending=[False, True]) #先按B降序，再按C升序 输出 df.sort_index 按索引排序 axis：0（跨行），1（跨列） ascending：0（降序），1（升序） df.sort_index(axis=0，ascending=1) #按索引列升序排序，需要默认的索引值 输出（此处index设置为了’A’） 统计函数 返回 Series max()、min() # 使用统计函数：0 代表列求结果， 1 代表行求统计结果 data.max(0) open 34.99 high 36.35 close 35.21 low 34.01 volume 501915.41 price_change 3.03 p_change 10.03 turnover 12.56 my_price_change 3.41 dtype: float64 std()、var() # 方差 data.var(0) open 1.545255e+01 high 1.662665e+01 close 1.554572e+01 low 1.437902e+01 volume 5.458124e+09 price_change 8.072595e-01 p_change 1.664394e+01 turnover 4.323800e+00 my_price_change 6.409037e-01 dtype: float64 # 标准差 data.std(0) open 3.930973 high 4.077578 close 3.942806 low 3.791968 volume 73879.119354 price_change 0.898476 p_change 4.079698 turnover 2.079375 my_price_change 0.800565 dtype: float64 median() df = pd.DataFrame({'COL1' : [2,3,4,5,4,2], 'COL2' : [0,1,2,3,4,2]}) df.median() COL1 3.5 COL2 2.0 dtype: float64 idxmax()、idxmin() 求索引位置 # 求出最大值的位置 data.idxmax(axis=0) open 2015-06-15 high 2015-06-10 close 2015-06-12 low 2015-06-12 volume 2017-10-26 price_change 2015-06-09 p_change 2015-08-28 turnover 2017-10-26 my_price_change 2015-07-10 dtype: object # 求出最小值的位置 data.idxmin(axis=0) open 2015-03-02 high 2015-03-02 close 2015-09-02 low 2015-03-02 volume 2016-07-06 price_change 2015-06-15 p_change 2015-09-01 turnover 2016-07-06 my_price_change 2015-06-15 dtype: object 其他 df.corr() #返回列与列之间的相关系数 df.count() #返回每一列中的非空值的个数 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:2:3","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"预处理 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:3:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"数据清理 所有函数，均返回 DataFrame 副本，不赋值不会生效 以下图为例 缺失值处理 dropna(axis=, how=)：丢弃NaN数据 axis：0(按行丢弃)，1(按列丢弃) how：‘any’(只要含有NaN数据就丢弃)，‘all’(所有数据都为NaN时丢弃) fillna(value=)：将NaN值都设置为value的值 df.dropna(how='any') #删除数据表中含有空值的行 df.fillna(value=0) #使用数字0填充数据表中空值 df['B'].fillna(df['B'].mean()) #使用price均值对NA进行填充 输出 清理空格 df['city']=df['city'].map(str.strip) #清除city字段中的字符空格 大小写转换 df['A'].str.upper() #city列大小写转换 输出 更改数据格式 df['C'].astype('int') 输出 a 1 b 3 c 2 d 3 e 2 f 3 g 1 h 1 i 2 j 1 Name: C, dtype: int32 更改行列名称 df.rename(columns={'A': 'Name','C':'Age'}) #更改列名称 df.rename(index={'e': 'eee'}) #更改行名称 df.columns = ['animal','age','visits','priority'] #传入列表以改变列名称 df.index = [...] #传入列表以改变行名称 输出 重复值处理 df.duplicated() # 返回一个布尔型的Series,显示各行是否有重复行 df.duplicated().any() # 返回bool，查看是否有重复值 df.duplicated('k1') # 检查各行的k1列是否重复 df.duplicated(['k1','k2']) # 检查各行的k1，k2列是否重复 df.drop_duplicates() #保留第一个值，返回副本 df.drop_duplicates(keep='last') #保留最后一个值，返回副本 df.drop_duplicates(keep=False) #删除所有重复值，返回副本 df.drop_duplicates('k1') #删除第一列重复值，返回副本 df.drop_duplicates(['k1','k2']) #删除全部列重复值，返回副本 df.drop_duplicates(inplace=True) #就地修改 数值修改及替换 df['D'].replace('yes', 'true') 输出 a true b true c no d true e no f no g no h true i no j no Name: D, dtype: object 设置索引列 df_inner.set_index('A') 输出 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:3:1","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"数据表合并 以下两张图为例 .merge() 参数 on：列名，join用来对齐的那一列的名字，用到这个参数的时候一定要保证左表和右表用来对齐的那一列都有相同的列名 how：数据融合的方法 sort：根据dataframe合并的keys按字典顺序排序，默认是，如果置false可以提高表现 df_inner=pd.merge(df1,df2,how='inner') #以小表为准 df_outer=pd.merge(df1,df2,how='outer') #以大表为准 df_left=pd.merge(df1,df2,how='left') #以左表为准，这里等同于inner_df df_right=pd.merge(df1,df2,how='right') #以右表为准,这里等同于outer_df 输出 .concat() 第一个参数：需要合并的矩阵 axis：合并维度，0：按行合并，1：按列合并，默认为0 join：处理非公有 列/行 的方式，inner：去除非公有的 列/行，outer：对非公有的 列/行 进行NaN值填充然后合并 ignore_index：是否重排行索引，若重排，行索引为顺序。默认为0 pd.concat([df1, df2], join='outer', ignore_index=True) #按行合并，重排行索引 pd.concat([df1, df2], axis=1, join='inner') #按列合并 输出 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:3:2","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"数据分组 分类汇总 df_inner.groupby('city').count() #对所有列进行计数汇总 df_inner.groupby('city')['id'].count() #对特定的ID列进行计数汇总 df_inner.groupby(['city','pay'])['id'].count() #对两个字段进行汇总计数 df_inner.groupby('city')['price'].agg([len,np.sum, np.mean]) #对city字段进行汇总并计算price的合计和均值 输出 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:3:3","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"数据增删 更多：https://www.cnblogs.com/guxh/p/9420610.html 删除行列 df1.drop(['0','1']) #按行名删除（如果有的话） df1.drop(df1.index[0:2]) #按行号删除 df.drop(['id','date'],axis=1) #按列名删除 df.drop(df.columns[0:2],axis=1) #按列号删除 del df['id'] #删除列（就地删除） 增加行 想增加一行，行名称为‘a’，内容为[16, 17, 18, 19] df.loc['a'] = [16, 17, 18, 19] df.at['a'] = [16, 17, 18, 19] df.set_value('a', df.columns, [16, 17, 18, 19], takeable=False) # warning，set_value会被取消 df.loc[len(df)] = [16, 17, 18, 19]#简单地逐行添加内容 #.append() s = pd.Series([16, 17, 18, 19], index=df.columns, name='5') #添加有name的Series df.append(s) #赋值以生效 增加列 般涉及到增加列项时，经常会对现有的数据进行遍历运算，获得新增列项的值 #遍历DataFrame获取序列的方法 s = [a + c for a, c in zip(df['A'], df['C'])] # 通过遍历获取序列 s = [row['A'] + row['C'] for i, row in df.iterrows()] # 通过iterrows()获取序列，s为list s = df.apply(lambda row: row['A'] + row['C'], axis=1) # 通过apply获取序列，s为Series s = df['A'] + df['C'] # 通过Series矢量相加获取序列 s = df['A'].values + df['C'].values # 通过Numpy矢量相加获取序列 #通过df[]或者df.loc添加序列 df.loc[:, 'E'] = s df['E'] = s #.insert()可以指定插入位置，和插入列名称 df.insert(0, 'E', s) #在第0列插入s，命名为E #.concat() s = pd.Series([16, 17, 18, 19], name='E', index=df.index) df = pd.concat([df, s], axis=1) #简单地逐列添加内容 df[len(df)] = [16, 17, 18, 19] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:3:4","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"数据运算 算术运算 add(other) data['A'].add(1) sub(other) data['A'].sub(2) 逻辑运算 更多被运用到数据筛选中 符号 data[\"A\"] \u003e 2 # 返回Series data[data[\"A\"] \u003e 2].head() # 返回DataFrame副本 data[(data[\"A\"] \u003e 1) \u0026 (data[\"A\"] \u003c 3)] # 多个逻辑判断 函数 query(expr) expr：查询字符串 data.query(\"A\u003c3 \u0026 A\u003e1\") # 返回DataFrame副本 isin(values) 可以指定值进行一个判断，从而进行筛选操作 data[data[\"A\"].isin([1, 2])] # 返回DataFrame副本 自定义运算 apply( func, axis=0 )：定义一个对列，最大值-最小值的函数 func：自定义函数 axis=0：默认是列，axis=1为行进行运算 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:3:5","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"导入与到导出 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:4:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"导入数据 path：文件路径 sep：分隔符，默认用\",“隔开 usecols：指定读取的列名 可以使用 index_col=[0] 参数指定默认索引 pd.read_csv(filename) #从CSV文件导入数据 pd.read_table(filename) #从限定分隔符的文本文件导入数据 pd.read_excel(filename) #从Excel文件导入数据 pd.read_sql(query, connection_object) #从SQL表/库导入数据 pd.read_json(json_string) #从JSON格式的字符串导入数据 pd.read_html(url) #解析URL、字符串或者HTML文件，抽取其中的tables表格 pd.read_clipboard() #从你的粘贴板获取内容，并传给read_table() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:4:1","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"导出数据 path：文件路径 sep：分隔符，默认用”,“隔开 columns：选择需要的列索引 header ：boolean or list of string, default True，是否写入列索引 index：是否写入行索引 mode：‘w’：重写, ‘a’ 追加 df.to_csv(filename) #导出数据到CSV文件 df.to_excel(filename) #导出数据到Excel文件 df.to_sql(table_name, connection_object) #导出数据到SQL表 df.to_json(filename) #以Json格式导出数据到文本文件 转换成 json 格式通常用 df.to_json(filename, orient='records', force_ascii=False) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:4:2","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"例 取出索引为 [3, 4, 8] 行的 animal 和 age 列 df.loc[df.index[[3, 4, 8]], ['animal', 'age']] 取出 age 值缺失的行 df[df['age'].isnull()] 计算每个不同种类 animal 的 age 的平均数 df.groupby('animal')['age'].mean() 计算 df 中每个种类 animal 的数量 df['animal'].value_counts() 将priority列中的yes, no替换为布尔值True, False df['priority'] = df['priority'].map({'yes': True, 'no': False}) 求哪一列的和最小 df.sum().idxmin() 去除 Unnamed:0 列 pd.read_csv(path, index_col=0) # or pd.to_csv(path, index=False) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:5:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"预览 DataFrame 一个独立的支持库，pandas_profiling，可以快速预览数据集。 import pandas_profiling as pp pp.ProfileReport(df) 这个函数支持任意 DataFrame，并生成交互式 HTML 数据报告： 第一部分是纵览数据集，还会列出数据一些可能存在的问题； 第二部分汇总每列数据，点击 toggle details 查看更多信息； 第三部分显示列之间的关联热力图； 第四部分显示数据集的前几条数据。 profile.to_file(\"your_report.html\") 保存 html 文件 profile = pp.ProfileReport(data) profile.to_file(\"output_file.html\") ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/pandas/:6:0","tags":["Python","数据分析"],"title":"pandas","uri":"/Notes/posts/python/dataanalysis/pandas/"},{"categories":["Python"],"content":"基础语法 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:0:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"认识 强类型语言：解释器会根据赋值或运算来自动推断变量类型 动态类型语言：变量类型可以随时变化，是为 “状态机” ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:1:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"对象模型 对象：python 中处理的每样 “东西” 都是对象 内置对象：可直接使用 如数字、字符串、列表、del 等； 非内置对象：需要导入模块才能使用 如 sin(x)，random() 等。 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:1:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"内存管理 python 采用基于值的管理方式 在 Python 中，即使是简单的赋值语句 a = 1，也只是将变量标识符 a 引用向对象 1 基于值的内存管理：小整数、短字符串等对象都被 Python 缓存，多个变量值相等时，可能会有相同的 id 在 a = b 中，建立的是 a 对 b 的引用。 使用 a is b 来判断 a 和 b 是否引用同一对象，a is b 是 id(a) == id(b) 的充分非必要条件 解释器会跟踪所有值，没有变量指向的自动删除，但自动内存管理不保证及时释放内存 使用 del(a) 主动释放一个变量，但如果对象还被引用不会导致对象被消除 形如 a.append(a) 会造成引用环，对垃圾回收会造成一定困难 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:1:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"操作符 \u003e\u003e\u003e [1,2,3] * 3 [1,2,3,1,2,3,1,2,3] \u003e\u003e\u003e '1' * 5 '11111' \u003e\u003e 3 * 'a' 'aaa' \u003e\u003e\u003e [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:1:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"浅拷贝与深拷贝 浅拷贝出来的是一个独立的对象，但它的子对象还是原对象中的子对象 深拷贝会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。 列表的切片是浅拷贝，是对原列表的引用。当列表含列表元素时，会产生问题 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:1:4","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"选择结构 格式 if \u003ccondition1\u003e: \u003cstatement1\u003e elif \u003c condition2\u003e: \u003cstatement2\u003e elif \u003c condition3\u003e: \u003cstatement3\u003e else: \u003cstatement4\u003e 注意冒号和缩进 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:2:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"循环结构 循环后可以跟 else 语句，当循环正常结束时执行，不正常结束就不执行 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:3:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"for 循环 格式 for \u003c variable\u003e in \u003c sequence \u003e: \u003cstatements\u003e else: \u003cstatements\u003e 特殊语句 break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行 continue 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环 迭代 如果给定一个 list 或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。在Python中，迭代是通过for … in来完成的。Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items() \u003e\u003e\u003e d = {'a': 1, 'b': 2, 'c': 3} \u003e\u003e\u003e for key in d: ... print(key) ... a c b 由于字符串也是可迭代对象，因此，也可以作用于for循环 \u003e\u003e\u003e for ch in 'ABC': ... print(ch) ... A B C 如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断 \u003e\u003e\u003e from collections import Iterable \u003e\u003e\u003e isinstance('abc', Iterable) # str是否可迭代 True \u003e\u003e\u003e isinstance([1,2,3], Iterable) # list是否可迭代 True \u003e\u003e\u003e isinstance(123, Iterable) # 整数是否可迭代 False 迭代时，产生的是临时变量，修改此临时变量不会影响本身迭代对象里对应元素的值 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:3:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"while 循环 while \u003ccondition\u003e: \u003cstatements\u003e ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:3:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"循环的 else 语句 循环自然结束，就执行 else 中的语句，如果遇到 break，则不执行 else 中的语句 for \u003c variable\u003e in \u003c sequence \u003e: \u003cstatements\u003e else: \u003cstatements\u003e # or while \u003cconditions\u003e: \u003cstatements\u003e else: \u003cstatements\u003e ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:3:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"函数 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:4:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"定义 def 函数名（参数列表）: 函数体 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:4:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"参数 默认参数 必选参数在前，默认参数在后，否则 Python 的解释器会报错 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数 可变参数 传入的参数个数可变 传列表、元组 def calc(numbers): calc([1, 2, 3]) calc((1, 3, 5, 7)) 用*号 def calc(*numbers) calc(1, 2) *numbers 表示把 number 这个 list 的所有元素作为可变参数传进去。这种写法相当有用，而且很常见 关键字参数 键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict def func(name, age, **kw) extra = {'city': 'Beijing', 'job': 'Engineer'} func('Jack', 24, city=extra['city'], job=extra['job']) func('Jack', 24, **extra) **extra 表示把 extra 这个 dict 的所有 key-value 用关键字参数传入到函数的 **kw 参数 补充 *args 是可变参数，args 接收的是一个 tuple **kwargs 是关键字参数，kwargs 接收的是一个 dict ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:4:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"装饰器 功能：在不改变原函数结构的基础上为原函数增添新功能 def timer(func): def wrapper(*args): start=time.time() a=func(*args) end=time.time() print(\"time taken:\",end-start) return a return wrapper def add(a,b): return a+b def sub(a,b): return a-b add=timer(add) sub=timer(sub) print(add(1,2)) print(sub(1,2)) @timer def add(a,b): return a+b @timer def sub(a,b): return a-b print(add(1,2)) print(sub(1,2)) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:4:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"lambda 表达式 声明临时用的匿名函数 \u003e\u003e\u003e f=lambda x,y,z:x+y+z \u003e\u003e\u003e print f(1,2,3) 6 def pow(x): return x**2 list(map(pow, a)) # or def pow(x): return x**2 list(map(lambda x:pow(x), a)) # or list(map(lambda x:x**2,a)) 列表 列表赋值，实质上指向同一块内存 要创建指向不同内存的列表，使用切片 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:4:4","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"基本语句 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"声明列表 例 favorate_singers = ['Mika','Jay Chou','Bruno Mars','Ed Sheeran'] ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"添加列表元素 在列表末尾添加元素 list.append(value) 在列表中插入元素 list.insert(index，value) 在列表末尾合并另一个列表 list_a.extend(list_b) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"删除列表元素 知晓索引并将其删除 del list[index] 删除元素并将其弹出 list.pop([index]) # 括号内为空，则弹出最后一个元素；返回弹出的元素值 根据值删除元素 list.remove(value) # 只删除第一个指定的值，要删除多个相同值需使用循环 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"组织列表 按照首字母顺序排序列表(永久性） list.sort() # 反向排序：列表名.sort(reverse=True) 按照首字母顺序排序列表(临时性) sorted(list) 倒着排序列表(永久性) list.reverse() # 恢复的办法，再来一次 reverse() 倒着排序列表(临时性) reversed(list) # 返回迭代器 确定列表的长度 len(list) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:4","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"操作列表 遍历列表 L=[1,2,3,4,5] for i in range(len(L)): L[i]+=10 print(L) #等效于 L=[] for i in range(1,6): L.append(i+10) print(L) 列表解析 L=[1,2,3,4,5] L=[x+10 for x in L] #result:[11,12,13,14,15] 创建切片 参数 [start_index: stop_index: step] ： start_index是切片的起始位置索引，不提供时默认从头 stop_index是切片的结束位置（**不包括**）索引，不提供时默认至尾,可为负 step为步长，可以不提供，默认值是1 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:5","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"复制列表/创建列表副本 用切片复制 List2 = List1[:] ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:6","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"检查元素是否在列表中 List = [a,b,c,d,e] if a in List if a not in List ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:7","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"其他函数 list.index(value) 返回值为 value 的首个元素的下标 list.count(value) 返回值为 value 的元素在列表中出现的个数 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:5:8","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"性质 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:6:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"序列对象的内存机制 序列对象在内存中的起始地址是不变的，修改序列中的值不会影响到整个序列的起始地址。（有点像链表） \u003e\u003e\u003e a=[1,2,3] \u003e\u003e\u003e id(a) 2790016530624 \u003e\u003e\u003e a[0]=4 \u003e\u003e\u003e id(a) 2790016530624 \u003e\u003e\u003e a=[4,5,6] \u003e\u003e\u003e id(a) 2790016530560 \u003e\u003e\u003e b=a \u003e\u003e\u003e id(a)==id(b) True 使用 extend() 不会改变地址 使用乘法运算相当于创建了一个新列表，改变了地址 使用乘法复制了列表中的列表元素时，实质上是创建了其引用，非常危险 \u003e\u003e\u003e a = [[0] * 2] * 3 \u003e\u003e\u003e a [[0, 0], [0, 0], [0, 0]] \u003e\u003e\u003e a[0][0]=2 \u003e\u003e\u003e a [[2, 0], [2, 0], [2, 0]] 列表直接赋值是深拷贝，修改其一，另一也会变；而切片是浅拷贝，可以放心使用 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:6:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"列表表达式 \u003e\u003e\u003e [v**2 if v%2==0 else v+1 for v in [2,3,4,-1] if v\u003e0] [4, 4, 16] ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:6:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"元组 概念：不可变的列表，用圆括号来标识（tuple） 元组可以作为字典的键，而列表不能 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:7:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"定义元组 例 tup1 = ('physics', 'chemistry', 1997, 2000) tup2 = (1, 2, 3, 4, 5 ) tup3 = \"a\", \"b\", \"c\", \"d\" ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:7:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"注意 元组本身不可改变，但是可以给元组变量赋值 元组中只包含一个元素时，需要在元素后面添加逗号 tup1 = (50, ) 可以对元组进行连接组合 tup1 = tup2 = ('abc', 'xyz') tup3 = tup1 + tup2 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:7:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"序列解包 可以使用元组进行序列解包 \u003e\u003e\u003e a,b,c=1,2,3 \u003e\u003e\u003e print(a,b,c) 1 2 3 \u003e\u003e\u003e *range(4),4 (0, 1, 2, 3, 4) \u003e\u003e\u003e [*range(4),4] [0, 1, 2, 3, 4] \u003e\u003e\u003e {'x':1, **{'y':2}} {'x': 1, 'y': 2} ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:7:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"生成器 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:8:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"定义 在 Python 中，一边循环一边计算的机制，称为生成器（generator） 生成器是一个特殊的程序，可以被用作控制循环的迭代行为，python 中生成器是迭代器的一种，使用 yield 返回值函数，每次调用 yield 会暂停，而可以使用 next()  函数和 send() 函数恢复生成器 生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，生成器一次只能产生一个值，这样消耗的内存数量将大大减小，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:8:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"创建 把一个列表生成式的 [] 中括号改为 () 小括号 l = [x*x for x in range(10)] g = (x*x for x in range(10)) 直接打印g的结果 \u003cgenerator object \u003cgenexpr\u003e at 0x000002A4CBF9EBA0\u003e 打印值 如果要一个个打印出来，可以通过 next() 函数获得 generator 的下一个返回值 print(next(g)) print(next(g)) print(next(g)) 计算出最后一个元素，没有更多的元素时，会抛出 StopIteration 的错误 或使用 for 循环 for i in g: print(i) 构建函数 如果一个函数定义中包含 yield 关键字，那么这个函数就不再是一个普通函数，而是一个 generator def generator(max): x = 1 while x \u003c= max: yield x**2 x += 1 return 'done' g = generator(4) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:8:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"技巧 索引数从 0 开始 将索引指定为 -1，可以返回最后一个列表元素 负数索引返回离列表末尾相应距离的元素，如 print(list[-3:]) 即打印 list 的最后三个元素 在 if 语句和 while 语句中，将列表名用在条件表达式中时，列表包含至少一个元素，则返回 True；列表为空返回 False 关于切片 元组（tuple）也是一种 list，唯一区别是 tuple 不可变。因此，tuple 也可以用切片操作，只是操作的结果仍是 tuple \u003e\u003e\u003e (0, 1, 2, 3, 4, 5)[:3] (0, 1, 2) 字符串’xxx’也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串 \u003e\u003e\u003e 'ABCDEFG'[:3] 'ABC' \u003e\u003e\u003e 'ABCDEFG'[::2] 'ACEG' 运用列表生成式 要生成[1x1, 2x2, 3x3, …, 10x10] [x * x for x in range(1, 11)] 筛选出仅偶数的平方 [x * x for x in range(1, 11) if x % 2 == 0] 生成全排列 [m + n for m in 'ABC' for n in 'XYZ'] 列出当前目录下的所有文件和目录名 \u003e\u003e\u003e import os # 导入os模块 \u003e\u003e\u003e [d for d in os.listdir('.')] # os.listdir可以列出文件和目录 ['.emacs.d', '.ssh', '.Trash', 'Adlm', 'Applications', 'Desktop', 'Documents', 'Downloads', 'Library', 'Movies', 'Music', 'Pictures', 'Public', 'VirtualBox VMs', 'Workspace', 'XCode'] 把一个list中所有的字符串变成小写 \u003e\u003e\u003e L = ['Hello', 'World', 'IBM', 'Apple'] \u003e\u003e\u003e [s.lower() for s in L] ['hello', 'world', 'ibm', 'apple'] 字典 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:9:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"基本语句 声明字典 alien_0 = {'color':'green','points':5} #字典是一系列键-值对 访问字典中的值 print(alien_0['points']) 添加键-值对 alien_0 ['x_position']=10 alien_0 ['y_position']=25 修改字典中的值 alien_0['color'] = 'yellow' 删除键-值对 del alien_0['color'] 遍历字典 遍历键-值对 for key,value in alien_0.items(): print(key+':'+value+'\\n') #返回顺序与储存顺序无关 遍历键 for key in alien_0.keys(): #当要遍历所有键时，可去\".keys()\" 遍历值 for value in alien_0.values(): 有顺序地遍历 使用 sorted() 函数，如： for key in sorted(alien_0.keys()): 合并遍历中的重复项 使用 set() 函数，如： for value in set(alien_0.values()): ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:10:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"集合 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:11:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"定义 集合（set）是一个无序的不重复元素序列 set 和 dict 类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 set 中，没有重复的 key ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:11:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"基本操作 初始化 s1 = set('cheershopa') s2 = set([1, 2, 3, 34, 15, 25, 35, 45, 75]) #传列表 添加值 s.add(8) 删除值 s.remove(8) 交集、并集 s1 \u0026 s2 s1 | s2 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:11:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"嵌套 定义：列表中嵌套字典，字典中嵌套列表，字典中嵌套字典 在列表中存储字典 aliens=[] for new_alien in range(30): new_alien={'color':'green','speed':'slow'} aliens.append(new_alien) 在字典中存储列表 favorate_languages={ 'Trouvaille':['C++'], 'Nick':['Python'], 'Leo':['Java','Python'], 'Seamus':['Javascript','C++','Ruby'] } for x,y in favorate_languages.items( ): if len(y)\u003e=2: print(x+\"'s favorate are\") for Y in y: print(Y) else: print(x+\"'s favorate is\") for Y in y: print(Y) 在字典中存储字典 users={ 'Trouvaille':{ 'gender':'male', 'location':'Hangzhou' }, 'Ketchup_Lover':{ 'gender':'male', 'location':'Shanghai' } } for x,y in users.items(): print(x+':') print(\"\\t\"+y['gender']+' , '+y['location']) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:11:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"相关函数 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:12:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"get() 说明：返回指定键的值，如果值不在字典中返回默认值None 语法 dict.get(key, default=None) 参数 key – 字典中要查找的键 default – 如果指定键的值不存在时，返回该默认值 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:12:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"len() 说明：计算字典元素个数，即键的总数。 语法 len(dict) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:12:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"其他技巧 通常习惯声明一个空字典以便添加键-值对 字典通常储存一个对象的多种信息，也可以储存多个对象的同一种信息 利用字典来完成列表中的词频统计 # 举例： a = [1, 2, 3, 1, 1, 2] dict = {} for key in a: dict[key] = dict.get(key, 0) + 1 # 字典的get函数可以查询键的值，0代表默认值,每出现一次加1 print (dict) 输出结果： \u003e\u003e\u003e{1: 3, 2: 2, 3: 1} 字典推导式 \u003e\u003e\u003e {i:str(i) for i in range(10)} {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5', 6: '6', 7: '7', 8: '8', 9: '9'} 类 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:13:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"基本语句 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:14:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"创建类 class Restaurant(): def __init__(self, name, type): self.name = name self.type = type self.customer_number = 0 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:14:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"创建方法 def describe_rest(self): print(\"The restaurant's name is \" + self.name.title()) print(\"The restaurant's type is \" + self.type.title()) def open_rest(self): print(\"This restaurant is opening\") ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:14:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"使用类和实例 rest1 = Restaurant('KFC', 'snack bar') ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:14:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"调用方法 rest1.describe_rest() rest1.open_rest() ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:14:4","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"继承 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:15:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"子类 class IceCreamStand(Restaurant): def __init__(self,name,type): super().__init__(name,type) #super()用来继承父类的属性 #父类也称超类(superclass) self.flavours=['strawberry','chocolate','milk','matcha'] #为子类定义的属性 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:15:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"给子类定义方法 def describe_flavour(self): print(\"There're several kinds of flavours which are\",end=' ') for flavour in self.flavours: print(flavour,end=' ') ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:15:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"使用子类和实例 rest2=IceCreamStand('Dairy Queen','Ice Cream Stand') rest2.describe_rest() rest2.describe_flavour() ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:15:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"导入 假若有 Car 类, ElectricCar 类于 car.py 模块中 导入单个类 from car import Car 导入多个类 from car import Car, ElectricCar 导入整个模块 import car #需用句点表示法 导入模块中的所有类 from car import * 必要时，也允许从一个模块中导入另一个模块来构建子类 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:16:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"关于 if __name__ == '__main__' 这是个 Python 的语法，__name__ 属性显示当前模块名 当模块被直接运行时 __name__ 属性为 main ，作为模块被导入时为模块名 这句话的意思就是，当模块被直接运行时，以下代码块将被运行，当模块是被导入时，代码块不被运行。 可以用作测试，也可以用作模板 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:16:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"私有成员与公有成员 python 并没有对私有成员提供严格的访问保护机制。 私有属性：\"__\" 开头 主函数中访问：对象名._类名__value 保护成员：\"_\" 开头 不能被作为包导入 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:17:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"特殊方法 __new__：构造函数 __init__：初始化函数 __del__：析构函数 __add__、__sub__：加减运算符 __str__、__repr__：转字符串，后者将不可见字符转译 __call__：被函数调用 __len__：字面意思 __bool__：字面意思 __lt__ __gt__、__le__、__ge__、__eq__、__ne__：\u003c \u003e \u003c= \u003e= == !=运算符重载 __contians__：in，返回布尔值 __getitem__：下标访问或迭代器访问 __setitem__：下标修改或迭代器修改 __dict__：使用一个字典对对象中成员的值进行修改，一般不需要重载 文件 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:18:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"读取文件 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:19:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"全部读取 使用.read() with open(filename) as file_object: contents = file_object.read() #使用.read()读取文件的全部内容 print(contents.rstrip()) #使用.rstrip()来剥除.read()造成的末尾空字符串 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:19:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"逐行读取 遍历 with open(filename) as file_object: for line in file_object: print(line.rstrip()) #使用.rstrip()来剥除文件每行末尾的换行符 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:19:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"创建一个包含文件各行内容的列表 使用 .readlines() with open(filename) as file_object: lines = file_object.readlines() #使用.readlines() 从文件中读取每一行并存储到一个列表中 for line in lines: print(line.strip()) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:19:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"使用文件内容并将文件的空格全部移除 with open(filename) as file_object: lines=file_object.readlines() pi_string='' for line in lines: pi_string+=line.strip() #使用.strip()将每行空格全部除去 print(pi_string) print(pi_string[:10] + '...') print(len(pi_string)) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:19:4","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"写入文件 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:20:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"写入空文件 filename = 'text_files\\programming.txt' with open(filename, 'w') as file_object: file_object.write('Heya!\\n') #write()不会自动添加换行符，需手动添加 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:20:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"附加到文件 filename = 'text_files\\programming.txt' with open(filename, 'a') as file_object: #'a'表示以附加模式打开文件 file_object.write('Greeting!\\n') ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:20:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"其他打开方式 r：以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb：以二进制只读方式打开一个文件。文件指针将会放在文件的开头。 r+：以读写方式打开一个文件。文件指针将会放在文件的开头。 rb+：以二进制读写方式打开一个文件。文件指针将会放在文件的开头。 w：以写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 wb：以二进制写入方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 w+：以读写方式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 wb+：以二进制读写格式打开一个文件。如果该文件已存在，则将其覆盖。如果该文件不存在，则创建新文件。 a：以追加方式打开一个文件。如果该文件已存在，文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。 ab：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，则创建新文件来写入。 a+：以读写方式打开一个文件。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，则创建新文件来读写。 ab+：以二进制追加方式打开一个文件。如果该文件已存在，则文件指针将会放在文件结尾。如果该文件不存在，则创建新文件用于读写。 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:21:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"用 json 处理数据 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:22:0","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"json 格式 对象：它在 JavaScript 中是使用花括号 {} 包裹起来的内容，数据结构为 {key1：value1, key2：value2, ...} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。 数组：数组在 JavaScript 中是方括号 [] 包裹起来的内容，数据结构为 [\"java\", \"javascript\", \"vb\", ...] 的索引结构。在 JavaScript 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引用得多。同样，值的类型可以是任意类型。 一个 JSON 对象可以写为如下形式： [{ \"name\": \"Bob\", \"gender\": \"male\", \"birthday\": \"1992-10-18\" }, { \"name\": \"Selina\", \"gender\": \"female\", \"birthday\": \"1995-10-18\" }] 值得注意的是，JSON 的数据需要用双引号来包围，不能使用单引号 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:22:1","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"导入模块 import json json 库提供的主要功能也是字典与 json 的相互转换 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:22:2","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"存储数据 filename = 'name.json' with open(filename, 'w') as f_obj: json.dump(name, f_obj) #name为要储存的数据 ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:22:3","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"读取数据 使用json.load() 返回字典对象 filename = 'name.json' with open(filename) as f_obj: name = json.load(f_obj) #将json中的数据读到name中 使用 load 方法将字符串转为 JSON 对象。如果最外层是中括号，那最终的类型是列表类型 数据转换表 JSON Python object dict array list string str number (int) int number (real) float true True false False null None 其他特点 当 JSON 数据中有重复键名, 则后面的键值会覆盖前面的、 json.loads 方法默认会将 JSON 字符串中的 NaN, Infinity, -Infinity 转化为 Python 中的 float(’nan’), float(‘inf’) 和 float(’-inf’) ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:22:4","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["Python"],"content":"输出数据 调用 dumps 方法将 JSON 对象转化为字符串 import json data = [{ 'name': 'Bob', 'gender': 'male', 'birthday': '1992-10-18' }] with open('data.json', 'w') as file: file.write(json.dumps(data)) 利用 dumps 方法，我们可以将 JSON 对象转为字符串，然后再调用文件的 write 方法写入文本 如果想保存 JSON 的格式，可以再加一个参数 indent，代表缩进字符个数 with open('data.json', 'w') as file: file.write(json.dumps(data, indent=2)) 为了输出中文，还需要指定参数 ensure_ascii 为 False，另外还要规定文件输出的编码 with open('data.json', 'w', encoding='utf-8') as file: file.write(json.dumps(data, indent=2, ensure_ascii=False)) 异常处理 技巧 生成依赖文件 requirement.txt：使用 pipreqs pipreqs ./ 去除分隔符，将一段字符串转化为词语列表 punctuation = r\"\"\"!\"#$%\u0026'()*+,-./:;\u003c=\u003e?@[\\]^_`{|}~“”？，！【】（）、。：；’‘……￥·\"\"\" dicts = {i: ' ' for i in punctuation} punc_table = str.maketrans(dicts) 矩阵转置 获取当前路径 from pathlib import Path current_path = Path.cwd() ","date":"2021-12-22","objectID":"/Notes/posts/python/basicgrammar/:22:5","tags":["Python"],"title":"Python 基础语法","uri":"/Notes/posts/python/basicgrammar/"},{"categories":["专业课"],"content":"数据结构 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:0:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 数据元素（Data Element）：数据的基本单位 数据项（Data Item）：用来描述数据元素，是数据的最小单位 数据对象：具有相同性质的数据元素集合 数据结构（Data Structure） = 数据对象 + 结构 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:1:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"构成 逻辑结构 集合 线性结构 树形结构 图形结构（网状结构） 物理结构（存储结构） 顺序存储：将逻辑上相邻的元素存储在物理位置上也相邻的存储单元中 链式存储 索引存储 散列存储（哈希存储） 数据运算 运算描述针对逻辑结构，运算实现针对存储结构 算法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:2:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"特质 有穷性：必须执行有限次运算来实现 确定性：对于同意输入只能得到相同输出 有效性：含义明确，规定严格 输入性：可以有零个或多个输入 输出性：可以由一个或多个输出 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:3:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"描述 自然语言（Natural Language） 流程图（FlowChart） 类程序设计语言（Similar-programming Language） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:4:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"评估 正确性（Correctness） 可用性（Usability） 可读性（Readability） 健壮性（Robustness） 效率（Efficiency）：时间代价+空间代价，需要用算法分析（Analytic Method）进行评估 可移植性（Mobility） 可测试性（Testability） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:5:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"复杂度 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:6:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"时间复杂度 （Time Complexity） 时间开销 $$T(n)$$ 与问题规模 $$n$$ 之间的关系 方法 频度统计法：确定 $$O(f(n))$$ 渐进时间复杂度：知晓级数即可 依赖于数据的算法：采用平均复杂度 常见的时间复杂度 常对幂指阶 $$O(1)\u003cO(\\log_2n)\u003cO(n)\u003cO(n\\log_2n)\u003cO(n^2)\u003cO(n^3)\u003cO(2^n)\u003cO(n!)\u003cO(n^n)$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:6:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"空间复杂度 （Space Complexity） 空间开销（内存开销）$$S(n)$$与问题规模$$n$$之间的关系 原地工作：算法所需内存空间为常量，即$$S(n)=O(1)$$ 递归调用的空间复杂度=递归调用的深度 线性表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:6:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 n 个相同类型数据元素的有限序列，记为 $$L=(a_1,a_2,\\ldots,a_n)$$ L 称为表名，n 称为表长，$$a_i$$：第 i 个称为位序，$$a_1$$ 称为首元素，$$a_n$$ 称为末元素 除首元素，其他元素拥有一个直接前驱；除末元素，其他元素拥有一个直接后继 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:7:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"基本操作 初始化 InitList(\u0026L) 求长度 Length(L) 取指定元素的值 GetElem(i, \u0026e) 元素定位 Locate(\u0026e) 修改指定元素的值 SetElem(i, \u0026e) 插入 ListInsert(\u0026L,i,e) 删除 ListDelete(\u0026L,i,\u0026e) 判断是否是空表 Empty(L) 表清空 Clear() ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:8:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"顺序表（Sequential List） 顺序表是用顺序存储的方式来实现的线性表 若用静态数组，表长一旦确定便不可更改，建议使用动态数组 特点 随机访问，在 $$O(1)$$ 时间内找到第i个元素 存储密度高（=1），每个结点只存储数据元素，不记录相对关系，节省空间 因为设置了最大容量，空间会有富余，较为浪费 扩展容量不方便 插入、删除操作不方便，需要移动大量元素 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:9:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"类模板定义 第$$i$$个元素的数组索引为 $$i-1$$ template \u003cclass T\u003e class SeqList { protected: static const int DEFAULT_SIZE = 100; int _length; int _maxlen; T *_data; public: SeqList(int maxlen = DEFAULT_SIZE); //建立空表 SeqList(T *a, int length, int maxlen = DEFAULT_SIZE); //根据数组创建新表 SeqList(const SeqList\u003cT\u003e \u0026sa); //拷贝构造函数 virtual ~SeqList(); //析构函数 SeqList\u003cT\u003e \u0026operator=(const SeqList\u003cT\u003e \u0026sa); //赋值运算符重载 void ClearList(); //清空顺序表，暂时不知道有啥用 int GetLength() const; //返回长度 bool IsEmpty() const; //判空 bool IsFull() const; //判满 void DisplayList() const; //遍历显示顺序表 int LocateElem(const T \u0026e) const; //元素定位，返回指定元素位置 T GetElem(int i) const; //查找元素，返回查找的元素 void SetElem(int i, const T \u0026e); //修改i位置的元素值 void InsertElem(int i, const T \u0026e); //在i位置插入新元素 void InsertElem(const T \u0026e); //在末尾插入新元素 void DeleteElemByIndex(int i); //删除i位置的元素 void DeleteElemByValue(const T \u0026e); //删除指定元素 }; ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:9:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"具体实现 构造函数 template \u003cclass T\u003e SeqList\u003cT\u003e::SeqList(int maxlen) : _length(0), _maxlen(maxlen) { _data = new T[_maxlen]; //申请存储空间 } template \u003cclass T\u003e SeqList\u003cT\u003e::SeqList(T *a, int length, int maxlen) : _length(length), _maxlen(maxlen) { _data = new T[maxlen]; for (int i = 0; i \u003c length; i++) _data[i] = a[i]; } 插入元素 template \u003cclass T\u003e void SeqList\u003cT\u003e::InsertElem(int i, const T \u0026e) { if (IsFull()) { cout \u003c\u003c \"线性表已满,不可添加新元素!\" \u003c\u003c endl; return; } if (i \u003c 1 || i \u003e _length) { cout \u003c\u003c \"位置不合理！\" \u003c\u003c endl; return; } else { for (int j = _length; j \u003e= i; j--) //i后的元素向后移动一格 { _data[j] = _data[j - 1]; } _data[i - 1] = e; _length++; //总长+1 } } 删除元素 template \u003cclass T\u003e void SeqList\u003cT\u003e::DeleteElemByIndex(int i) { if (IsEmpty()) { cout \u003c\u003c \"线性表已空,不可删除元素!\" \u003c\u003c endl; return; } if (i \u003c 1 || i \u003e _length) { cout \u003c\u003c \"位置不合理！\" \u003c\u003c endl; return; } for (int j = i - 1; j \u003c _length - 1; j++) { _data[j] = _data[j + 1]; } _length--; } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:9:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"复杂度分析 在任意位置插入、删除一个数据元素：$$O(n)$$ 定位、遍历、构造函数、重载赋值：$$O(n)$$ 其他函数：$$O(1)$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:9:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"链表 （Linked List） 采用链接存储方式存储的线性表称为线性链表（Linked List），信息域 + 指针域 特点 不要求连续空间，逻辑上相邻的元素，物理上不用相邻 顺序访问，下标无助于访存 插入、删除元素无需大量移动 易于动态扩展 存储密度 \u003e1 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:10:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"单链表 一个结点由两个域组成，data域存放数据元素，next域存放指向下一结点的指针 一般多用带有头结点的单链表（第一个结点为空） 欲得知已知结点的前结点，需要顺序访问；欲得知已知结点的后结点，仅需使用next指针 结点类模板定义 template \u003cclass ElemType\u003e struct Node { // 数据成员: ElemType data; // 数据域 Node\u003cElemType\u003e *next; // 指针域 // 构造函数: Node(); // 无参数的构造函数 Node(ElemType e, Node\u003cElemType\u003e *link = NULL); // 已知数数据元素值和指针建立结构 } 结点实现 // 结点类的实现部分 template \u003cclass ElemType\u003e Node\u003cElemType\u003e::Node() // 操作结果：构造指针域为空的结点 { next = NULL; } template \u003cclass ElemType\u003e Node\u003cElemType\u003e::Node(ElemType e, Node\u003cElemType\u003e *link) // 操作结果：构造一个数据域为e和指针域为link的结点 { data = e; next = link; } 链表类模板定义 template \u003cclass ElemType\u003e class LinkList { protected: // 单链表的数据成员 Node\u003cElemType\u003e *head; // 头结点指针 int length; // 单链表长度 public: // 单链表的函数成员 LinkList(); // 无参数的构造函数 LinkList(ElemType v[], int n); // 有参数的构造函数 virtual ~LinkList(); // 析构函数 int GetLength() const; // 求单链表长度 bool IsEmpty() const; // 判断单链表是否为空 void Clear(); // 将单链表清空 void Traverse(void (*Visit)(const ElemType \u0026)) const; // 遍历单链表 int LocateElem(const ElemType \u0026e) const; // 元素定位 Status GetElem(int position, ElemType \u0026e) const; // 求指定位置的元素 Status SetElem(int position, const ElemType \u0026e); // 设置指定位置的元素值 Status DeleteElem(int position, ElemType \u0026e); // 删除元素 Status InsertElem(int position, const ElemType \u0026e); // 在制定位置插入元素 Status InsertElem(const ElemType \u0026e); // 在表尾插入元素 LinkList(const LinkList\u003cElemType\u003e \u0026la); // 复制构造函数 LinkList\u003cElemType\u003e \u0026operator=(const LinkList\u003cElemType\u003e \u0026la); // 重载赋值运算 } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:10:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"双向循环链表 （Double Circular List） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:10:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"静态链表 （Static List） 用数组方式存储数据，但数据间关系模拟链式存储，适用于不支持指针的语言。 栈、队列和递归 栈和队列都是受限的线性表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:10:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"栈 （Stack） 限制存取位置的顺序表，只可在表尾位置插入和删除，所谓后进先出（Last In First Out, LIFO）允许插入删除的一端称为栈顶（top），不允许的一端称为栈底（bottom）。 基本操作 初始化 求长度 取栈顶元素 进栈（push，也叫压入） 出栈（pop，也叫弹出） 判断是否为空栈清空栈 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:11:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"顺序栈 类模板定义 template \u003cclass T\u003e class SeqStack { protected: static const int DEFAULT_SIZE = 100; int _top; //_top从0开始 int _maxlen; T *_data; public: SeqStack(int maxlen = DEFAULT_SIZE); //建立空栈 SeqStack(const SeqStack\u003cT\u003e \u0026sa); //拷贝构造函数 virtual ~SeqStack(); //析构函数 SeqStack\u003cT\u003e \u0026operator=(const SeqStack\u003cT\u003e \u0026sa); //赋值运算符重载 void ClearStack(); //清空顺序表 int GetLength() const; //返回长度 bool IsFull() const; //判满 bool IsEmpty() const; //判空 void DisplayStack() const; //遍历显示顺序表 void PushElem(const T \u0026e); //入栈 T TopElem(); //取栈顶元素 void PopElem(); //出栈 }; 具体定义 template \u003cclass T\u003e void SeqStack\u003cT\u003e::PushElem(const T \u0026e) //入栈 { if (IsFull()) cout \u003c\u003c \"顺序栈已满！\" \u003c\u003c endl; else _data[++_top] = e; } template \u003cclass T\u003e T SeqStack\u003cT\u003e::TopElem() //取栈顶元素 { if (IsEmpty()) { cout \u003c\u003c \"顺序栈已空，无法取出栈顶元素！\" \u003c\u003c endl; //return NULL; } else { return _data[_top]; } } template \u003cclass T\u003e void SeqStack\u003cT\u003e::PopElem() //出栈 { if (IsEmpty()) { cout \u003c\u003c \"顺序栈已空，无法继续出栈！\" \u003c\u003c endl; return; } else { _top--; } } 共享存储空间的双顺序栈 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:11:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"链式栈 与顺序栈相比，链式栈对于同时使用多个栈的情况下可以共享存储 用不带头结点的的单链表示链式栈，且头指针表示 top，指向栈顶 类模板定义 template \u003cclass T\u003e class LinkStack { protected: //不设头结点，_top为第一个节点 Node\u003cT\u003e *_top; public: LinkStack(); virtual ~LinkStack(); LinkStack(const LinkStack\u003cT\u003e \u0026la); LinkStack\u003cT\u003e \u0026operator=(const LinkStack\u003cT\u003e \u0026la); void ClearStack(); bool IsEmpty() const; int GetLength() const; void DisplayStack() const; void PushElem(const T \u0026e); T TopElem(); void PopElem(); }; 具体实现 template \u003cclass T\u003e void LinkStack\u003cT\u003e::PushElem(const T \u0026e) //入栈 { Node\u003cT\u003e *p = new Node\u003cT\u003e(e, _top); if (p == NULL) cout \u003c\u003c \"动态内存耗尽！\" \u003c\u003c endl; else _top = p; } template \u003cclass T\u003e T LinkStack\u003cT\u003e::TopElem() //取栈顶元素 { if (IsEmpty()) cout \u003c\u003c \"链式栈已空\" \u003c\u003c endl; else return _top-\u003edata; } template \u003cclass T\u003e void LinkStack\u003cT\u003e::PopElem() //出栈 { if (IsEmpty()) cout \u003c\u003c \"链式栈已空，无法出栈！\" \u003c\u003c endl; else { Node\u003cT\u003e *p = _top; //取旧栈顶 _top = _top-\u003enext; //_top指向新栈顶 delete p; //释放旧栈顶空间 } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:11:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"队列 （Queue） 队列允许在表的一端插入元素，在另一端删除元素，所谓先进先出（First In First Out, FIFO）。允许插入的一端称为队尾（rear），允许删除的一端称为队头（front）。 操作 初始化 求长度 取队头元素 进队 出队 判空 清空队列 约定：front 指向队头元素，rear 指向队尾元素后一个位置 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:12:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"循环队列 为了避免假溢出问题，把顺序队列所使用的存储空间构造成一个逻辑上首尾相连的循环队列，称为循环队列。 假溢出问题的解决方法（主要是判空判满的问题） 少用一个存储空间，队满即 (rear + 1) % maxlen == front 不设rear，改设length，队空 length == 0；队满 length == maxlen 新增数据成员flag，队空 flag == 0；队满 flag == maxlen 顺序队列类模板定义 template \u003cclass T\u003e class SeqQueue { protected: static const int DEFAULT_SIZE = 100; int _front; int _rear; int _maxlen; //包含被闲置的那一个存储空间，真实供存储的最大值为_maxlen-1 T *_data; public: SeqQueue(int maxlen = DEFAULT_SIZE); virtual ~SeqQueue(); SeqQueue(const SeqQueue\u003cT\u003e \u0026q); SeqQueue\u003cT\u003e \u0026operator=(const SeqQueue\u003cT\u003e \u0026q); int GetLength() const; bool IsEmpty() const; bool IsFull() const; void ClearQueue(); void DisplayQueue() const; void EnterQueue(const T \u0026e); //入队 T GetFront() const; //取队头 void DeleteQueue(); //出队 }; 具体定义 template \u003cclass T\u003e int SeqQueue\u003cT\u003e::GetLength() const //当 rear \u003e front 时，长度为 rear-front;当 rear \u003c front 时，长度为(QueueSize-front)+rear { return (_rear - _front + _maxlen) % _maxlen; } template \u003cclass T\u003e bool SeqQueue\u003cT\u003e::IsEmpty() const { return _rear == _front; } template \u003cclass T\u003e bool SeqQueue\u003cT\u003e::IsFull() const { return (_rear + 1) % _maxlen == _front; } template \u003cclass T\u003e void SeqQueue\u003cT\u003e::ClearQueue() //清空队列，不需要清空存储的元素 { _rear = _front = 0; } template \u003cclass T\u003e void SeqQueue\u003cT\u003e::DisplayQueue() const { if (IsEmpty()) cout \u003c\u003c \"队列中无元素！\" \u003c\u003c endl; else { cout \u003c\u003c \"从对头到队尾，队列元素依次为：\"; for (int i = _front; i != _rear - 1; i = (i + 1) % _maxlen) { cout \u003c\u003c _data[i] \u003c\u003c \", \"; } cout \u003c\u003c _data[_rear - 1] \u003c\u003c endl; } } template \u003cclass T\u003e void SeqQueue\u003cT\u003e::EnterQueue(const T \u0026e) //入队 { if (IsFull()) cout \u003c\u003c \"队列已满，无法继续添加元素！\" \u003c\u003c endl; else { _data[_rear] = e; _rear = (_rear + 1) % _maxlen; } } template \u003cclass T\u003e void SeqQueue\u003cT\u003e::DeleteQueue() //出队 { if (IsEmpty()) cout \u003c\u003c \"队列为空，无法出队！\" \u003c\u003c endl; else { _front = (_front + 1) % _maxlen; } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:12:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"链式队列 链式队列完全避免了假溢出的问题。 类模板定义 _front 是空的头指针，其下一个元素是队头元素；_rear 指向队尾元素 初始化时，_rear 等于 _front template \u003cclass T\u003e class LinkQueue //带头结点 { protected: Node\u003cT\u003e *_front, *_rear; public: LinkQueue(); virtual ~LinkQueue(); LinkQueue(const LinkQueue\u003cT\u003e \u0026q); LinkQueue\u003cT\u003e \u0026operator=(const LinkQueue\u003cT\u003e \u0026q); void ClearQueue(); int GetLength() const; bool IsEmpty() const; void DisplayQueue() const; void EnterQueue(const T \u0026e); T GetFront() const; void DeleteQueue(); }; 具体定义 template \u003cclass T\u003e void LinkQueue\u003cT\u003e::EnterQueue(const T \u0026e) { Node\u003cT\u003e *p = new Node\u003cT\u003e(e); if (p) //判断系统空间是否足够 { _rear-\u003enext = p; _rear = _rear-\u003enext; } else { cout \u003c\u003c \"系统空间不足，无法入队！\" \u003c\u003c endl; } } template \u003cclass T\u003e T LinkQueue\u003cT\u003e::GetFront() const { return _front-\u003enext-\u003edata; } template \u003cclass T\u003e void LinkQueue\u003cT\u003e::DeleteQueue() { if (IsEmpty()) { cout \u003c\u003c \"链队列已空，无法出队！\" \u003c\u003c endl; } else { Node\u003cT\u003e *p = _front-\u003enext; _front-\u003enext = p-\u003enext; if (_rear == p) _rear = _front; delete p; } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:12:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"递归 （Recursion） 若一个对象部分地包含自己，或用它自己给自己定义，则此对象是递归的。 若一个过程直接或间接地调用自己，则此过程是递归的过程 对任意一个递归，需要有出口和同一形式 步骤 保留调用信息（返回地址和实参信息） 分配调用过程所需的数据空间 将控制转到被调用的子过程 特点 不节省时间，也不节省空间 容易根据定义进行编程 结构清晰，便于阅读 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:13:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"递归转换为非递归 原因 递归的时间效率通常比较差 有些计算机语言不支持递归 方法 对于尾递归和单项递归，可用循环结构的算法替代。 自己用栈来模拟系统运行时的栈（工作记录），保存有关信息。 尾递归和单项递归的消除 尾递归：递归调用语句只有一个，且在函数最后。（如阶乘） 单项递归：所有递归调用彼此间参数无关（不套娃），且均在函数最后。（如斐波那契数列） 用栈模拟系统运行时的栈 串、数组和广义表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:13:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"字符串 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:14:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 $$ s=“a_0a_1\\ldots a_{n-1}” $$ 空格符也是字符，空格串不是空串 当串采用顺序存储时，存储串的数组名指出了串在内存中的首地址 C++中存储串的末尾会添加一个结束标识符NULL（编码值为0） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:14:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"模式匹配 （Pattern Matching） 设 ob 为主串，pat 为模式串，查找 pat 在 ob 的匹配位置的操作称为模式匹配 Brute-Force 算法 从主串首字符开始依次匹配，若匹配失败，从第二个字符位开始匹配，以此类推。它是一种带回溯的算法。 int BF_find(const string \u0026ob, const string \u0026pat, const int p = 0) //查找pat在ob中从位置p开始子串 { int i = p, j = 0; while (i \u003c ob.length() \u0026\u0026 j \u003c pat.length() \u0026\u0026 pat.length() - j \u003c= ob.length() - i) { if (ob[i] == pat[j])//匹配成功，继续匹配下个字符 { i++; j++; } else //匹配失败 { i = i - j + 1; //i退回到上趟匹配的下个字符位置 j = 0; //j从头开始 } } if (j \u003e= pat.length()) return i - j; else { return -1; } } 时间复杂度（最坏）：$$O(m\\sdot n)$$ KMP 算法 int KMP(const string \u0026ob, const string \u0026pat, const int start = 0) { int *next = new int[pat.length()]; GetNext(pat, next); int i = start, j = 0; while ((j == -1) || (ob[i] != '\\0' \u0026\u0026 pat[j] != '\\0')) { if (j == -1 || ob[i] == pat[j]) { i++; //继续对下一个字符比较 j++; //模式串向右滑动 } else j = next[j]; //寻找新的匹配字符位置，模式串尽可能向右滑动 } delete[] next; if (pat[j] == '\\0') return (i - j); //匹配成功返回下标 else return -1; //匹配失败返回-1 } void GetNext(const string \u0026pat, int *next) //p[k]表示前缀，p[j]表示后缀 { int j = 0, k = -1; next[0] = -1; //设next[0]的初始值为-1 while (pat[j] != '\\0') { if (k == -1 || pat[j] == pat[k]) { j++; k++; //j,k向后走 next[j] = k; //记录到此索引前字符串真子串的长度 } else k = next[k]; //寻求新的匹配字符 } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:14:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"数组 数组将线性关系进行扩展（一维变多维） 数据类型受限 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:15:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"稀疏矩阵 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:16:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"矩阵的压缩存储 对称矩阵 （$$a_{ij} == a_{ji}$$）：记录三角及对角线 三对角矩阵（除主对角线及其相邻两条斜线，其余元素均为0）：行列号插值不为1的为0 稀疏矩阵 （大部分元素为0的矩阵） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:16:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"三元组 用（行、列、值）来记录稀疏矩阵中的非零元素 template \u003cclass T\u003e struct Triple { int _row, _col; T _value; Triple(){}; Triple(int row, int col, T value) : _row(row), _col(col), _value(value){}; }; ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:16:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"三元组顺序表 类模板定义 template \u003cclass T\u003e class TriSparseMatrix //三元组顺序表实现 { protected: static const int DEFAULT_SIZE = 100; Triple\u003cT\u003e *_data; //存储三元组的数组 int _maxLen; //非零元素最大个数 int _rows, _cols, _num; //行数、列数、非零元素个数 public: TriSparseMatrix(int rows = DEFAULT_SIZE, int cols = DEFAULT_SIZE, int maxLen = DEFAULT_SIZE); ~TriSparseMatrix(); TriSparseMatrix(const TriSparseMatrix\u003cT\u003e \u0026copy); TriSparseMatrix\u003cT\u003e \u0026operator=(const TriSparseMatrix\u003cT\u003e \u0026copy); TriSparseMatrix\u003cT\u003e operator+(const TriSparseMatrix\u003cT\u003e \u0026copy); int GetRows() const { return _rows; } int GetCols() const { return _cols; } int GetNum() const { return _num; } void SetElem(int row, int col, const T \u0026v); T GetElem(int row, int col); void Display(); void SimpleTranspose(TriSparseMatrix\u003cT\u003e \u0026e); //简单转置 void FastTranspose(TriSparseMatrix\u003cT\u003e \u0026e); //快速转置 }; 具体定义 template \u003cclass T\u003e void TriSparseMatrix\u003cT\u003e::SetElem(int row, int col, const T \u0026v) //三种情况：非零变零，零变非零，非零变非零 { if (v == 0) //若设置非零值为零 { int i; for (i = 0; i \u003c _num; i++) //找到要设零的非零值 { if (_data[i]._row == row \u0026\u0026 _data[i]._col == col) { //_data[i] = 0; break; } } if (i != _num) //说明确实设置了非零数为零 { for (int j = i; j \u003c _num - 1; j++) { _data[j] = _data[j + 1]; } _num--; //非零值个数-1 } } else { Triple\u003cT\u003e e(row, col, v); int i; for (i = 0; i \u003c _num; i++) { if (_data[i]._row == row \u0026\u0026 _data[i]._col == col) //修改非零值 { _data[i] = e; break; } } if (i == _num) //设置零值为非零值 _data[_num++] = e; } } template \u003cclass T\u003e TriSparseMatrix\u003cT\u003e TriSparseMatrix\u003cT\u003e::operator+(const TriSparseMatrix\u003cT\u003e \u0026e) { TriSparseMatrix\u003cT\u003e result(_rows, _cols, DEFAULT_SIZE); //result._num = 0; if (_rows != e._rows || _cols != e._cols) { cout \u003c\u003c \"两矩阵行列数不等，无法进行加法运算！\" \u003c\u003c endl; exit(1); } int i = 0; //控制左值，即this int j = 0; //控制右值，即e T value; //存放临时的非零值值 while (i \u003c _num \u0026\u0026 j \u003c e._num) //直到一个矩阵的非零元素被遍历完 { if (_data[i]._row == e._data[j]._row) //行号相等时 { if (_data[i]._col == e._data[j]._col) //行列号都相等时 { value = _data[i]._value + e._data[j]._value; if (value != 0) { result.SetElem(_data[i]._row, _data[i]._col, value); } i++; j++; } else if (_data[i]._col \u003e e._data[j]._col) //行号相等，左值列号\u003e右值列号 { result.SetElem(e._data[j]._row, e._data[j]._col, e._data[j]._value); //将右值（即列较小值）添加到新矩阵中 j++; } else //行号相等，左值列号\u003c右值列号 { result.SetElem(_data[i]._row, _data[i]._col, _data[i]._value); //将左值（即列较小值）添加到新矩阵中 i++; } } else if (_data[i]._row \u003e e._data[j]._row) //左值行号\u003e右值行号时 { result.SetElem(e._data[j]._row, e._data[j]._col, e._data[j]._value); //将右值（即行较小值）添加到新矩阵中 j++; } else //左值行号\u003c右值行号时 { result.SetElem(_data[i]._row, _data[i]._col, _data[i]._value); //将左值（即行较小值）添加到新矩阵中 i++; } } while (i \u003c _num) //若左值中有剩余元素 { result.SetElem(_data[i]._row, _data[i]._col, _data[i]._value); i++; } while (j \u003c e._num) //若右值中有剩余元素 { result.SetElem(e._data[j]._row, e._data[j]._col, e._data[j]._value); j++; } return result; } template \u003cclass T\u003e void TriSparseMatrix\u003cT\u003e::SimpleTranspose(TriSparseMatrix\u003cT\u003e \u0026e) //简单转置，时间复杂度O(_rows*_cols) { e._rows = _rows; e._cols = _cols; e._num = 0; e._maxLen = _maxLen; delete[] e._data; e._data = new Triple\u003cT\u003e[_maxLen]; for (int col = 0; col \u003c _cols; col++) //对整个矩阵的列进行遍历 { for (int i = 0; i \u003c _num; i++) //对_data进行遍历 { if (col == _data[i]._col) //若_data[i]中出现相应列，添加到e中 { e.SetElem(_data[i]._col, _data[i]._row, _data[i]._value); } } } //*this = e; } template \u003cclass T\u003e void TriSparseMatrix\u003cT\u003e::FastTranspose(TriSparseMatrix\u003cT\u003e \u0026e) //快速转置，时间复杂度O(_num) { e._rows = _rows; e._cols = _cols; e._num = _num; e._maxLen = _maxLen; delete[] e._data; e._data = new Triple\u003cT\u003e[_maxLen]; int *DataNumInCol = new int[_cols]; //存放原矩阵每一列非零个数 int *FirstDataIne = new int[_cols]; //存放每一列第一个非零元素在e中的索引位置 for (int i = 0; i \u003c _cols; i++) //赋初值为0 DataNumInCol[i] = 0; for (int i = 0; i \u003c _num; i++) //记录每列的非零元素个数 DataNumInCol[_data[i]._col]++; FirstDataIne[0] = 0; //零行第一个非零元素必在0位置 for (int i = 1; i \u003c _cols; i++) //当前列第一个元素的索引位置=上一列的索引位置+上一列的元素个数 FirstDataIne[i] = FirstDataIne[i - 1] + DataNumInCol[i - 1]; for (int i = 0; i \u003c _num; i++) { int j = FirstDataIne[_data[i]._col]; //j记录当前列的索引 e._data[j]._row = _data[i]._col; e._data[j]._col ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:16:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"三元组的十字链表 当非零元素经常变动时，不适合用顺序表。 十字链表由行链表和列链表组成（不带头结点的循环表），每个非零元素既处于行链表又处于列链表中 非零元素结点类模板 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:16:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"广义表 即列表（List），元素可以是一个数据也可以是一个表 $$ LS=(a_1,a_2,\\ldots,a_n) $$ 表头：$$a_1$$ 表尾：$$(a_2,a_3,\\ldots,a_n)$$ 深度：广义表中括号的深度；空表的深度为1 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:17:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"广义链表 要点： 带头结点 单元素深度为0，空表深度为一 几乎所有操作都是递归，因为广义表本身的定义即是递归的 求深度公式 结点类模板定义 链表类模板定义 数和森林 一个数据可能有多个直接前驱（或后继），需要用非线性数据结构去表示，本章讲解树形结构的定义与实现 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:17:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"树 (tree) ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 树$$T$$是一个包含$$n$$个数据元素的有限集合，每个数据元素用一个结点表示，且有 $$n=0$$时，$$T$$为空树 $$n\u003e0$$时，$$T$$有且只有一个根（root），根结点只有后继，没有前驱 $$n\u003e1$$时，根以外的其余结点又是$$m$$个互不受限的非空有限集，它们是根结点的子树（subtree） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"术语 结点（node）：每个数据元素及指向其子树根的分支 结点的度（degree of node）：一个结点的分支个数（子树数目） 终端结点（terminal tree）：度为 0 的结点，也叫叶子（leaf） 非终端结点（nonterminal tree）：度不为 0 的结点，也叫分支结点 树的度（degree of tree）：树的结点中最大的度 孩子（child）和双亲（parent）：结点 p 的子树称为p的孩子，p 是其子树的双亲 兄弟（sibling）：双亲相同的结点 祖先（ancestor）：从根结点到结点x所经分支上的所有结点是 x 的祖先 子孙（descendant）：以结点 p 为根的所有子树中的所有结点都是 p 的子孙 结点的层次（level）：根为第一层，根的孩子第二层，以此类推；树中任意结点的 level 是其双亲结点level+1 树的深度（depth）：树中结点的最大层次（根的层次），也叫高度（height） 堂兄弟：双亲在同一层的结点 有序树：树中结点 p 的子树都是有顺序的 无序树：树中结点 p 的子树没有顺序 森林（forest）：m 颗互不相交的的树的集合；对树中每个结点而言，其子树的集合即为森林（子树森林） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"存储结构 采用链式存储为佳，记录前驱和后继其中一个即可完成全部功能 双亲(数组)表示法 采用数组来存储，本质上是静态链表，所以不属于顺序存储 Data 域存储结点的数据信息 Parent 存储结点的双亲在数组中的序号。 实现求双亲操作很方便，但对于求某节点的孩子节点的操作需要查询整个数组，实现求兄弟的操作也比较困难。 孩子表示法 多重链表 链表中的每个结点包括一个数据域和多个指针域。数据域存储树中结点的自身信息，每个指针指向该结点的一个孩子结点。 定长，浪费；不定长，难写 数组 + 单链表 一维数组顺序存储树中各节点的信息，并将各结点的孩子信息组成一个单链表。 双亲 - 孩子表示法 将各结点的孩子结点组成一个单链表，同时用一维数组顺序存储树中的各节点，数组元素包括结点的自身信息、双亲结点在数组中的序号以及该结点的孩子结点链表的头指针。 有些麻烦 孩子 - 兄弟表示法 二重链表表示法 查找某结点的孩子结点比较方便，如果在每一个结点中增加一个指向双亲的指针，就可以方便地找到各结点的祖先。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"树、森林和二叉树的转换 树转化为二叉树 把树当作有序树看待：约定树中每一个结点的孩子结点按从左到右的次序顺序编号。 操作 连线：树中所有相邻兄弟结点之间加一条线 删线：对树中的每一个结点，只保留它与第一个孩子结点之间的连线，删去它与其他孩子结点之间的连线。 美化：以树的根结点为轴心，将这棵树顺时针转动 45 度使其层次分明。 性质 左孩子表示自己的第一个孩子；右孩子表示自己的下一个兄弟 树作这样的转化所构成的二叉树是唯一的。 树转化成的二叉树，其根结点无右子树。 森林转化为二叉树 森林转化成的二叉树，其根结点有右子树。 依次将森林中每棵树转化成相应的二叉树。 从第二棵二叉树开始，依次把当前的二叉树作为前一棵二叉树根结点的右子树，此时所得到的二叉树就是由森林转化得到的二叉树。 二叉树转化为森林 连线：若结点 p 是其双亲结点F的左孩子，则把从结点 p 延沿右分支所找到的所有结点和结点 F 用线连起来。 删线：删除二叉树中所有结点和其右孩子结点之间的连线。 美化：整理，使结构层次分明。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"树的遍历 指按照某种顺序访问树中的每个结点，并使每个结点被访问一次且只被访问一次。 树的先根遍历 若树为空，遍历结束。否则， 访问根结点； 按照从左到右的顺序先根遍历根结点的每一棵子树。 与二叉树先序遍历结果序列相同。 ABEFKLCGDHIMNJ 树的后根遍历 若树为空，遍历结束。否则， 按照从左到右的顺序后根遍历根结点的每一棵子树； 访问根结点。 与二叉树中序遍历结果序列相同。 EKLFBGCHMNIJDA 树的层次遍历 又称为树的广度遍历。从树的第一层（根结点）开始，自上至下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。 借助队列，结构按下述步骤层序遍历树： 初始化队列，并将根结点入队。 当队列非空时，取出队头结点p，转步骤3）；如果队列为空，则结束遍历。 访问取出的结点p；如果结点p有孩子，则依次将它们入队列。 重复步骤2）、3），直到队列为空。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:5","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"森林的遍历 森林的先根遍历 若森林为空，返回；否则， 访问森林中第一棵树的根结点； 先根遍历第一棵树的根结点的子树森林； 先根遍历除第一棵外其他树组成的森林。 与二叉树先序遍历结果序列相同。 ABCDEFGHI 森林的中根遍历 若森林为空，返回；否则， 中根遍历第一棵树的根结点的子树森林； 访问森林中第一棵树的根结点； 中根遍历除第一棵外其他树组成的森林。 与二叉树中序遍历结果序列相同。 BCDAFEHIG 森林的后根遍历 若森林为空，返回；否则， 后根遍历第一棵树的根结点的子树森林； 后根遍历除第一棵外其他树组成的森林； 访问森林中第一棵树的根结点。 与二叉树后序遍历结果序列相同。 DCBFIHGEA ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:18:6","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"二叉树 （Binary Tree） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:19:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 二叉树是特殊的有序树，每个结点的度最多为2 非空时，有根结点BT，余下的结点最多被组成两颗互不相交的、分别被称为BT的左子树（left subtree）和右子树（right subtree）的二叉树 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:19:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"性质 n 个结点，分支数为 n-1 n 个叶子节点，有 n-1 个度为 2 的节点 n 个结点，其高度范围为 $$[\\lceil log_2(n+1\\rceil,n]$$ 高度为 h ，其节点数范围为 $$[h,2^h-1]$$ 完全二叉树时，找 i 的子节点：$$2i+1 \\ 与 \\ 2i+2$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:19:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"遍历 （Traversing Binary Tree, TBT） 定义：按某种顺序访问每个结点，并使每个结点只被访问一次 方法：规定$$L,D,R$$为访问左子树，根，右子树，有：（规定先左再右） $$DLR$$：先序遍历 $$LDR$$：中序遍历 $$LRD$$：后序遍历 先序+中序（or 后序+中序）的遍历结果可以反向推导出二叉树 先序遍历 template \u003cclass T\u003e void BinaryTree\u003cT\u003e::PreOrder(BinTreeNode\u003cT\u003e *\u0026root) { if (root != NULL) { cout \u003c\u003c root-\u003e_data \u003c\u003c \" \"; PreOrder(root-\u003e_leftChild); PreOrder(root-\u003e_rightChild); } } template \u003cclass T\u003e void BinaryTree\u003cT\u003e::PreOrder_NoRecurve(BinTreeNode\u003cT\u003e *\u0026root) //DLR 节点不为空时即打印 { if (root == NULL) return; LinkStack\u003cBinTreeNode\u003cT\u003e *\u003e Stack; BinTreeNode\u003cT\u003e *p = root; while (!Stack.IsEmpty() || p != NULL) { if (p != NULL) { cout \u003c\u003c p-\u003e_data \u003c\u003c \" \"; //先打印父节点 Stack.PushElem(p); //父节点入栈 p = p-\u003e_leftChild; //转到左节点 } else { if (!Stack.IsEmpty()) { p = Stack.TopElem(); //回溯到父节点 Stack.PopElem(); //父节点出栈 p = p-\u003e_rightChild; //转到右节点 } else return; } } } 中序遍历 template \u003cclass T\u003e void BinaryTree\u003cT\u003e::InOrder(BinTreeNode\u003cT\u003e *\u0026root) { if (root != NULL) { InOrder(root-\u003e_leftChild); cout \u003c\u003c root-\u003e_data \u003c\u003c \" \"; InOrder(root-\u003e_rightChild); } } template \u003cclass T\u003e void BinaryTree\u003cT\u003e::InOrder_NoRecurve(BinTreeNode\u003cT\u003e *\u0026root) // LDR 左节点为空时访问（或 即将转到右节点时访问） { if (root == NULL) return; LinkStack\u003cBinTreeNode\u003cT\u003e *\u003e Stack; BinTreeNode\u003cT\u003e *p = root; while (!Stack.IsEmpty() || p != NULL) { if (p != NULL) { Stack.PushElem(p); //入栈 p = p-\u003e_leftChild; //转到左节点 } else { if (!Stack.IsEmpty()) { p = Stack.TopElem(); Stack.PopElem(); //栈顶出栈 cout \u003c\u003c p-\u003e_data \u003c\u003c \" \"; //即将转到右节点时，打印栈顶 p = p-\u003e_rightChild; //转到右节点 } else return; } } } 后序遍历 template \u003cclass T\u003e void BinaryTree\u003cT\u003e::PostOrder(BinTreeNode\u003cT\u003e *\u0026root) { if (root != NULL) { PostOrder(root-\u003e_leftChild); PostOrder(root-\u003e_rightChild); cout \u003c\u003c root-\u003e_data \u003c\u003c \" \"; } } template \u003cclass T\u003e void BinaryTree\u003cT\u003e::PostOrder_NoRecurve(BinTreeNode\u003cT\u003e *\u0026root) //LRD 出栈时，需要判定左右节点遍历的完成情况 { if (_root == NULL) return; LinkStack\u003cBinTreeNode\u003cT\u003e *\u003e Stack; LinkStack\u003cint\u003e Tag; BinTreeNode\u003cT\u003e *p = root; //Stack.PushElem(p); //Tag.PushElem(0); while (!Stack.IsEmpty() || p != NULL) { if (p != NULL) { Stack.PushElem(p); Tag.PushElem(0); p = p-\u003e_leftChild; } else { while (!Stack.IsEmpty()) { if (Tag.TopElem() == 0) //此时左节点已经遍历完 { p = Stack.TopElem(); //预出栈 Tag.PopElem(); Tag.PushElem(1); //将Tag栈顶改为1，表示已经遍历完左节点 p = p-\u003e_rightChild; break; } else //此时右节点已经遍历完 { p = Stack.TopElem(); Stack.PopElem(); //真正出栈 Tag.PopElem(); cout \u003c\u003c p-\u003e_data \u003c\u003c \" \"; } } if (Stack.IsEmpty()) return; } } } 层序遍历 template \u003cclass T\u003e void BinaryTree\u003cT\u003e::LevelOrder(BinTreeNode\u003cT\u003e *\u0026root) //层序遍历 { LinkQueue\u003cBinTreeNode\u003cT\u003e *\u003e Queue; BinTreeNode\u003cT\u003e *p; if (root != NULL) Queue.EnterQueue(root); //若根非空，则入队 while (!Queue.IsEmpty()) { p = Queue.GetFront(); //取队头 Queue.DeleteQueue(); //出队 cout \u003c\u003c p-\u003e_data \u003c\u003c \" \"; //打印打印！ if (p-\u003e_leftChild != NULL) //若左节点非空，入队 { Queue.EnterQueue(p-\u003e_leftChild); } if (p-\u003e_rightChild != NULL) //若右节点非空，入队 { Queue.EnterQueue(p-\u003e_rightChild); } } } 遍历的用途 打印内容 知晓层数 统计结点 使非线性结构线性化 遍历的 C++ 写法 void PreOrder(BinTreeNode\u003cT\u003e *root); void PreOrder(BinTreeNode\u003cT\u003e *root) const; void PreOrder(const BinTreeNode\u003cT\u003e *root); void PreOrder(const BinTreeNode\u003cT\u003e *root) const; void PreOrder(BinTreeNode\u003cT\u003e *\u0026root); ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:19:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 类模板定义 template \u003cclass T\u003e class BinaryTree { protected: BinTreeNode\u003cT\u003e *_root; //二叉树根节点的指针 T _refValue; //创建二叉树时的结束标志 //辅助函数 /* 创建二叉树 */ void CreateBinTree_PreOrder(BinTreeNode\u003cT\u003e *\u0026root); //利用已知的二叉树的前序遍历创建二叉树 /* 遍历二叉树 */ void PreOrder(BinTreeNode\u003cT\u003e *\u0026root); //前序遍历 void InOrder(BinTreeNode\u003cT\u003e *\u0026root); //中序遍历 void PostOrder(BinTreeNode\u003cT\u003e *\u0026root); //后序遍历 void PreOrder_NoRecurve(BinTreeNode\u003cT\u003e *\u0026root); //前序遍历非递归 void InOrder_NoRecurve(BinTreeNode\u003cT\u003e *\u0026root); //中序遍历非递归 void PostOrder_NoRecurve(BinTreeNode\u003cT\u003e *\u0026root); //后序遍历非递归 void LevelOrder(BinTreeNode\u003cT\u003e *\u0026root); //层次遍历 /* 获取信息 */ int GetHeight(const BinTreeNode\u003cT\u003e *root) const; //求高度 int GetNodeNum(const BinTreeNode\u003cT\u003e *root) const; //求节点个数 BinTreeNode\u003cT\u003e *GetParent(BinTreeNode\u003cT\u003e *root, const BinTreeNode\u003cT\u003e *p) const; //求父节点 int GetmaxWidth(BinTreeNode\u003cT\u003e *root) const; //求最大宽度 int GetLeafNum(const BinTreeNode\u003cT\u003e *root) const; //求叶子节点数目 /* 其他 */ BinTreeNode\u003cT\u003e *CopyTree(const BinTreeNode\u003cT\u003e *originNode); //复制二叉树 void DestroyTree(BinTreeNode\u003cT\u003e *\u0026root); //删除二叉树 bool IsEqual(const BinTreeNode\u003cT\u003e *\u0026a, const BinTreeNode\u003cT\u003e *\u0026b) const; public: /* 构造与析构 */ BinaryTree() : _root(NULL){}; BinaryTree(T refValue) : _refValue(refValue) { _root = new BinTreeNode\u003cT\u003e; } //构造函数，指定结束标志refValue virtual ~BinaryTree() { DestroyTree(_root); }; BinaryTree(const BinaryTree\u003cT\u003e \u0026copy); /*运算符重载*/ BinaryTree\u003cT\u003e \u0026operator=(const BinaryTree\u003cT\u003e \u0026copy); bool operator==(BinaryTree\u003cT\u003e *s) { return (IsEqual(_root, s-\u003e_root)); } /* 创建二叉树 */ void CreateBinTree_PreOrder() { CreateBinTree_PreOrder(_root); } //用先序遍历结果创建二叉树 /* 遍历二叉树 */ void PreOrder() { PreOrder(_root); } void InOrder() { InOrder(_root); } void PostOrder() { PostOrder(_root); } void PreOrder_NoRecurve() { PreOrder(_root); } void InOrder_NoRecurve() { InOrder(_root); } void PostOrder_NoRecurve() { PostOrder(_root); } void LevelOrder() { LevelOrder(_root); } /* 获取信息 */ BinTreeNode\u003cT\u003e *GetRoot() const { return _root; } int GetHeight() const { return GetHeight(_root); } int GetNodeNum() const { return GetNodeNum(_root); } int GetmaxWidth() const { return GetmaxWidth(_root); } int GetLeafNum() const { return GetLeafNum(_root); } BinTreeNode\u003cT\u003e *GetParent(const BinTreeNode\u003cT\u003e *p) const { return (_root == NULL || _root == p) ? NULL : GetParent(_root, p); } BinTreeNode\u003cT\u003e *GetLeftChild(const BinTreeNode\u003cT\u003e *p) const { return (p == NULL) ? NULL : p-\u003e_leftChild; } BinTreeNode\u003cT\u003e *GetRightChild(const BinTreeNode\u003cT\u003e *p) const { return (p == NULL) ? NULL : p-\u003e_rightChild; } BinTreeNode\u003cT\u003e *GetLeftSibling(const BinTreeNode\u003cT\u003e *p) const; BinTreeNode\u003cT\u003e *GetRightSibling(const BinTreeNode\u003cT\u003e *p) const; /* 其他 */ BinTreeNode\u003cT\u003e *CopyTree() { CopyTree(_root); } void DestroyTree() { DestroyTree(_root); } bool IsEmpty() const { return (_root == NULL) ? true : false; } void InsertLeftChild(BinTreeNode\u003cT\u003e *\u0026p, const T \u0026data); void InsertRightChild(BinTreeNode\u003cT\u003e *\u0026p, const T \u0026data); T GetElem(BinTreeNode\u003cT\u003e *p) const { return p-\u003e_data; } void SetElem(BinTreeNode\u003cT\u003e *p, T data) { p-\u003e_data = data; } }; 具体定义 template \u003cclass T\u003e void BinaryTree\u003cT\u003e::DestroyTree(BinTreeNode\u003cT\u003e *\u0026root) //销毁二叉树，递归进行。先删左子树再删右子树，最后删自己 { if (root != NULL) { DestroyTree(root-\u003e_leftChild); DestroyTree(root-\u003e_rightChild); delete root; root = NULL; } } template \u003cclass T\u003e BinTreeNode\u003cT\u003e *BinaryTree\u003cT\u003e::CopyTree(const BinTreeNode\u003cT\u003e *originNode) //复制二叉树，返回一个指针，给出一个以originNode为根复制的二叉树的副本 { if (originNode == NULL) { return NULL; } BinTreeNode\u003cT\u003e *p = new BinTreeNode\u003cT\u003e; p-\u003e_data = originNode-\u003e_data; p-\u003e_leftChild = CopyTree(originNode-\u003e_leftChild); p-\u003e_rightChild = CopyTree(originNode-\u003e_rightChild); return p; } template \u003cclass T\u003e bool BinaryTree\u003cT\u003e::IsEqual(const BinTreeNode\u003cT\u003e *\u0026a, const BinTreeNode\u003cT\u003e *\u0026b) const { if (a == NULL \u0026\u0026 b == NULL) { return true; } if (a != NULL \u0026\u0026 b != NULL \u0026\u0026 a-\u003e_data == b-\u003e_data \u0026\u0026 IsEqual(a-\u003e_leftChild, b-\u003e_leftChild) \u0026\u0026 IsEqual(a-\u003e_rightChild, b-\u003e_rightChild)) { return true; } else { return false; } } template \u003cclass T\u003e int BinaryTree\u003cT\u003e::GetNodeNum(const BinTreeNode\u003cT\u003e *","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:19:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"线索二叉树 (Threaded Binary Tree) 利用结点的空链，记录遍历的前驱和后继 规定 结点左指针为空，记前驱；结点右指针为空，记后继 为了区分指针指的式孩子还是线索关系，加标记，为0记录孩子，为1记录线索 添加一个数据域为空的头结点，左指针指向根结点，标记0；右指针记录遍历时第一个访问的结点，标记1 leftChild leftTag data rightTag rightChild 左孩子或前驱 0或1 数据域 0或1 右孩子或后继 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:20:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"查找结点的前驱和后继算法 中序线索二叉树 查找p的前驱：查左线索；若无左线索，结点的前驱是遍历左子树时访问的最后一个结点。 查找p的后继：查右线索；若无右线索，结点的后继是遍历右子树时访问的第一个结点。 先序线索二叉树 查找p的前驱：查左线索；若无左线索，结点的前驱是结点的双亲结点，或是先序遍历其双亲结点左子树时最后访问的结点。 查找p的后继：查右线索；若无右线索，结点的后继必为结点的左子树（若存在）或右子树根结点。 后序线索二叉树 查找p的前驱：查左线索；若无左线索，且无右线索时，结点的前驱是右子树根结点；若无左线索，但是有右线索时，结点的前驱是左子树根结点。 查找p的后继，这种查找比较复杂，分4类情况讨论： ​ 若p为二叉树的根结点，后继为空； ​ 若p为右子树根结点，后继为双亲结点； ​ 若p为左子树根结点，且无右兄弟，后继为双亲结点； ​ 若p为左子树根结点，且有右兄弟，后继为后序遍历双亲结点右子树时访问的第一个结点。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:20:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"堆 （Heap） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:21:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 在完全二叉树中任何非终端节点的关键字均不大于（或不小于）其左、右孩子结点的关键字 堆的本质是线性关系，但写成完全二叉树形式更为直观 称根节点为堆顶，称堆顶最小为小顶堆（最小堆）；堆顶最大为大顶堆（最大堆） 使用顺序存储来构建堆 向下调整 FilterDown ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:21:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"哈夫曼树 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:22:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"术语 路径（Path）：从根结点到某个结点经过的分支序列 （根到结点的）路径长度：路径中的分支数 树的路径长度（Path Length，PL）：从根结点到所有叶子结点的路径长度和 带权路径长度（WPL）：设一颗有n个带权值叶结点的二叉树，$$W_k$$为第k个叶结点的权值，$$L_k$$为第k个叶结点的路径长度 $$ WPL=\\sum\\limits_{k=1}^nW_k*L_k $$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:22:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 对于一组确定权值的结点，所构造出不同形态二叉树的带权路径长度并不相同。将其中具有最小带权路径长度的二叉树称为哈夫曼树（最优二叉树） 构造方法：取最小的两个结点构树（左小右大），重复 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:22:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"哈夫曼编码 哈夫曼编码是一种前缀码，解码时没有歧义，相比于等长编码可以节省空间 计算字母频率作为权值，构造哈夫曼树， 叶子结点具有哈夫曼编码 规定左子树为 0，右子树为 1，写出字母编码 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:22:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"等价类及其表示(并查集) 定义 指能够完成查找、合并功能的集合。 操作 Ufsets(n)：构造函数，将并查集中 n 个元素初始化为 n 个只有一个单元素的子集合。 Union(S1,S2)：把集合 S2 并入集合 S1 中。要求 S1 与 S2 互不相交，否则没有结果。 Find(d)：查找单元素 d 所在的集合，并返回该集合的名字。 效率问题 查找效率取决于树的高度 树的高度取决于合并操作 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:23:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"合并算法的改进 按照高度 高度高的作为根节点 绝对合理，但是高度难以求出 按照树中结点个数 节点个数多的作为根节点 压缩路径 / 折叠规则 也就是直接改进查找算法 设 j 是以 i 为根的树中的一个结点，则对于从 j 到根 i 的路径上的每一个结点 k，如果 k 的双亲不等于 i，则把 i 设置为 k 的双亲。 ​ 使用折叠规则完成一次查找，所需时间比 Find() 多，但是能改善树的性能，减少以后查找操作所需的时间。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:23:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"类模板定义 结点模板 template \u003cclass T\u003e class UFSetsNode { public: T _data; int _parent; }; 并查集模板 template \u003cclass T\u003e class UnionFindSets { protected: UFSetsNode\u003cT\u003e *_sets; int _size; int SimpleFind(T e) const; int CollapsingFind(T e) const; public: UnionFindSets(T *elems, int n); ~UnionFindSets(); T GetElem(int index) const; //求索引指向的元素 int GetIndex(T e) const; //求指定元素的索引 int Find(T e) const; //求指定元素所在等价根元素的索引 void Union(T a, T b); //合并两个等价类 void WeightedUnion(T a, T b); //合并两个等价类，结点多者作为结点少者的双亲 void DepthUnion(T a, T b); //合并两个等价类，深度大者作为深度小者的双亲 void Show() const; }; ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:23:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"具体定义 template \u003cclass T\u003e int UnionFindSets\u003cT\u003e::Find(T e) const { int index = GetIndex(e); if (index != -1) { while (_sets[index]._parent \u003e -1) //不断寻找e的双亲，直到找到根结点 index = _sets[index]._parent; return index; } else return -1; } template \u003cclass T\u003e void UnionFindSets\u003cT\u003e::Union(T a, T b) { //此时，根结点的_parent记录的是树的结点数 int ra = Find(a); int rb = Find(b); if (ra != -1 \u0026\u0026 rb != -1 \u0026\u0026 ra != rb) { _sets[ra]._parent += _sets[rb]._parent; //个数相加 _sets[rb]._parent = ra; //合并等价类，a作为b的双亲 } } template \u003cclass T\u003e void UnionFindSets\u003cT\u003e::WeightedUnion(T a, T b) { int ra = Find(a); int rb = Find(b); //此时，根结点的_parent记录的是树的结点数 if (ra != -1 \u0026\u0026 rb != -1 \u0026\u0026 ra != rb) { if (_sets[ra]._parent \u003c= _sets[rb]._parent) { _sets[ra]._parent += _sets[rb]._parent; _sets[rb]._parent = ra; } else { _sets[rb]._parent += _sets[ra]._parent; _sets[ra]._parent = rb; } } } template \u003cclass T\u003e void UnionFindSets\u003cT\u003e::DepthUnion(T a, T b) { int ra = Find(a); int rb = Find(b); //此时，根结点的_parent记录的是树的深度 if (ra != -1 \u0026\u0026 rb != -1 \u0026\u0026 ra != rb) { if (_sets[ra]._parent == _sets[rb]._parent) //若两棵树的深度相同，合并后的最小深度为原深度+1 { _sets[ra]._parent--; _sets[rb]._parent = ra; //合并等价类，a作为b的双亲 } else //若两棵树的深度不同，合并后的最小深度为较大者 { if (_sets[ra]._parent \u003c _sets[rb]._parent) _sets[rb]._parent = ra; else _sets[ra]._parent = rb; } } } 图 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:23:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"基本概念 数据结构中的图：不带自身环，关联边不能多于一条 $$ graph=(V,E) $$ 顶点 vertex 有向边又称为弧，有弧尾（始点）和弧头（终点） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:24:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"存储结构 思考：如何找到环？ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:25:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"邻接矩阵 概念 用一维数组 vertexes[] 存储顶点信息，二维数组 arcs[] 存储边信息 无向图的邻接矩阵 类模板定义 //图的邻接矩阵类 template \u003cclass ElemType, class WeightType\u003e class AdjMatrixGraph { protected: int _vexMaxNum, _arcNum; // 最大顶点数, 边数 int *_tag; // 标志数组 SeqList\u003cElemType\u003e _vertexes; // 顶点数组 int **_arcs; // 邻接矩阵, 二维数组 int _dirType; // 有向图或无向图 int _weightType; // 带权值或不带权值 WeightType _infinity; public: AdjMatrixGraph(int dirType = 0, int weightType = 0, int vexMaxNum = DEFAULT_SIZE, WeightType infinity = DEFAULT_INFINITY); //默认构造函数 AdjMatrixGraph(ElemType *es, int vexNum, int dirType = 0, int weightType = 0, int vexMaxNum = DEFAULT_SIZE, WeightType infinity = DEFAULT_INFINITY); //构造函数 ~AdjMatrixGraph(); void Clear(); bool IsEmpty(); int GetVexNum() const; // 求顶点个数 int GetArcNum() const; // 求边数 int GetOrder(ElemType vex) const; // 求顶点序号 ElemType GetElem(int index) const; // 求指定下标的顶点值 void SetElem(int index, ElemType vex); // 更新指定下标的顶点值 int GetFirstAdjVex(int v) const; // 求v的第一个邻接点的下标 int GetNextAdjVex(int v1, int v2) const; // 求v1相对于v2的下一个邻接点的下标 void InsertVex(const ElemType \u0026vex); // 插入顶点 void InsertArc(int v1, int v2, int weight = 1); // 插入边 void DeleteVex(const ElemType \u0026vex); // 删除顶点 void DeleteArc(int v1, int v2); // 删除边 WeightType GetWeight(int v1, int v2) const; // 求从顶点为v1到v2的边的权值 void SetWeight(int v1, int v2, WeightType w); // 设置从顶点为v1到v2的边的权值 int GetTag(int v) const; // 求顶点v的标志值 void SetTag(int v, int value); // 设置顶点v的标志值 void Display() const; // 打印图 void SetArcs(int **arcs, int vexNum); // 设置新的邻接矩阵 void Dijkstra(int v); // 迪杰斯特拉算法 int GetInDegree(int v) const; // 求v的入度 void TopSort() const; // 有向无权图的拓扑排序 void CriticalPath() const; // AOE网络的开始时间、关键路径 bool IsConnected(); // 判断图是否连通 void DFS(int v); // 深度优先搜索 void DFSHelp(int v); // 深度优先遍历, 无输出 void DFSTraverse(); // 深度优先遍历 void TearCycle(); // 破圈法, 求带权连通无向图的最小生成树 }; ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:25:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"邻接表 把邻接矩阵的每一行记为一个单链表，把竖着排列的边连接成为一个边链表 记录有向图的出度，使用逆邻接表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:25:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"邻接多重表 (Adjacency Multilist) 用来存储无向图 邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示 data：存储此顶点的数据； firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的节点 mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历； ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标； ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点； jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点； info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:25:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"十字链表 （Orthogonal List） 用来存储有向图 十字链表（即有向图的邻接多重表）可以看作是邻接表和逆邻接表的合体 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:25:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"遍历 思考：深度、广度分别有什么应用？ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:26:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"深度优先遍历 DFS （Depth First Search, DFS） 理论上，结果不唯一 步骤 访问节点 v，并标记其已访问 取 v 的第一个邻接顶点 w 判断 w 是存在 若是，继续 若否，返回 w 是否被访问 若是，取 v 的下下个邻接顶点，转到步骤 3 若否，访问 w，标记，转到步骤1 时间复杂度 邻接表：O(n+e) 邻接矩阵：O(n^2^) 实现 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:26:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"广度优先遍历 BFS （Breadth First Search, BFS） 步骤 访问节点 v，并标记其已访问，使 v 入队 队空时，返回；若队非空，继续 出队 v 取 v 的第一个邻接顶点 w 判断 w 是否存在 若存在，继续 若不存在，转步骤 3 判断 w 是否被访问 若被访问，继续 若未被访问，访问 w 并标记，使 w 入队，继续 取 v 的下下个邻接顶点覆盖 w，转步骤 5 时间复杂度 邻接表：O(n+e) 邻接矩阵：O(n^2^) ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:26:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"连通分量 遍历算法的应用 定义：非连通图中的极大连通子图 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:26:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"最小生成树 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:27:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"概念 生成树 定义：连通图的极小连通子图 特点 任意两顶点有且只有一条路径 n 个顶点的生成树具有 n-1 条边 生成树不唯一，n 个顶点的完全图有 $$n^{n-2}$$ 种生成树 不同遍历方法 / 不同顶点出发 / 不同存储结构，生成树不同 n 个顶点 n-1 条边也不一定是生成树 最小生成树 （minimum cost spanning tree, MST） 定义：连通网中，权值总和最小的生成树，全称最小代价生成树 性质：假设 N = (V, E) 是一个连通网，U 是顶点集 V的一个非空子集。若 (u, v) 是一条具有最小权值的边，其中u∈U， v∈V - U，则必存在一棵包含边（u，v）的最小生成树 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:27:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"克鲁斯卡尔算法 (Kruskal) 步骤 设 G = (V, E) 是具有 n 个顶点的连通网，T = (U，TE) 是其最小生成树。 选取权值最小的边（V~i~，V~j~），若边（V~i~，V~j~）加入到 TE 后形成回路 (环)，则舍弃该边，否则将该边加入到 TE 中。 重复 1，知道 TE 中含有 n-1 条边为止 实现 用最小堆来找最小边 用并查集来判断有无环 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:27:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"普利姆算法 (Prim) 基于 MST 性质、 步骤 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:27:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"最短路径 （Shortest Path） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:28:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"类别 单源点最短路径 给定网 G 和 V，求 V 到其他顶点的最短路径 多源点最短路径 给定网 G，求其中顶点到其他各顶点的最短路径 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:28:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"弧上权值非负的单源点最短路径 迪杰斯特拉算法（Dijkstra） 按路径长度递增的次序来产生最短路径；先求路径最短的一条，然后参照它进行刷新，求出长度次短的一条，以此类推，被求出长度的顶点放入集合 S 中，当 S 满，代表算法结束 引入 dist[]，存储 v 到 v~i~ 当前找到的最短路径长度；引入 path[]，存储 v~i~ 的直接前驱节点 只看初边 实现 template \u003cclass ElemType, class WeightType\u003e void AdjMatrixGraph\u003cElemType, WeightType\u003e::Dijkstra(int v) // 求索引为v的顶点的各个最短路径长度 { int _vexNum = _vertexes.GetLength(); WeightType min; WeightType dist[_vexNum]; // 存储当前找到的最短路径长度 int path[_vexNum]; // 存储目标顶点的直接前驱节点 for (int i = 0; i \u003c _vexNum; i++) { dist[i] = _arcs[v][i]; // 存入一条边的路径 SetTag(i, 0); // 用_tag表示已经找到最短路径的集合 if (i != v \u0026\u0026 dist[i] \u003c _infinity) // 若dist[i]存在, 添加前驱节点 path[i] = v; else path[i] = -1; } SetTag(v, 1); //自身已经在集合中 cout \u003c\u003c \"所选源点: \" \u003c\u003c GetElem(v) \u003c\u003c endl; int finalVex; // 已求出最短路径的顶点 int w; for (int i = 1; i \u003c _vexNum; i++) // 按递增序列求最短路径 { min = _infinity; finalVex = v; for (int j = 0; j \u003c _vexNum; j++) // 查询最小的最短路径, 找出finalVex { if (_tag[j] == 0 \u0026\u0026 dist[j] \u003c min) { finalVex = j; min = dist[j]; } } SetTag(finalVex, 1); for (int j = GetFirstAdjVex(finalVex); j != -1; j = GetNextAdjVex(finalVex, j)) // 从上一次找到的最短路径的顶点出发, 依次判断各顶点的最短路径能否更新 { if (_tag[j] == 0 \u0026\u0026 min + GetWeight(finalVex, j) \u003c dist[j]) { dist[j] = min + GetWeight(finalVex, j); path[j] = finalVex; } } } // 打印输出 for (int i = 0; i \u003c _vexNum; i++) { if (i == v) continue; string pathStr(1, GetElem(i)); for (int j = path[i]; j != -1; j = path[j]) { pathStr = string(1, GetElem(j)) + \" -\u003e \" + pathStr; } cout \u003c\u003c \"从顶点 \" \u003c\u003c GetElem(v) \u003c\u003c \" 到顶点 \" \u003c\u003c GetElem(i) \u003c\u003c \" 的最短路径为: \" \u003c\u003c pathStr \u003c\u003c \", 长度为: \" \u003c\u003c dist[i] \u003c\u003c endl; } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:28:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"弧上权值任意值的单源点最短路径 贝尔曼 - 福特算法 从原点依次经过其他顶点，来缩短到达顶点的最短路径长度。要求：途中不能有路径长度为负数的回路 递推公式 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:28:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"所有点之间的最短路径 重复迪杰斯特拉 以每一个点为原点，重复执行迪杰斯特拉算法；O(n^3^) 弗洛伊德（Floyd）算法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:28:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"活动网络 （Activity Network） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:29:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"用顶点表示活动的网络 概念 有向无环图（Directed acycline graph）：一个无环的有向图，简称 DAG 图 顶点表示活动的网络（Activity on vertices）：AOV 网络 拓扑排序：把 AOV 网络中各顶点按照他们相互之间的优先关系排列成一个线性序列的过程 在有向图中选一个没有前驱的顶点且输出之 从图中删除该顶点和所有以它为尾的弧 重复前两步，直到所有顶点均已输出 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:29:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"用边表示活动的网络 概念 边表示活动的网络（activity on edges）：简称 AOE 网络 边的值：此活动持续的时间 顶点表示事件（event），保证一个源点，一个汇点 关键路径：从源点到汇点，具有最大路径长度的路径 关键活动：关键路径上的所有活动 求事件（顶点）的最早开始时间 ve：从源点起，入边的值加上其弧尾的最早开始时间，取最大值（看入边，求最大） 求事件（顶点）的最晚开始时间 vl：从汇点起，弧头的最早开始时间减去出边的值，取最小值（看出边，求最小） 求活动（边）的最早开始时间 ee：弧尾的最早开始时间 求活动（边）的最晚开始时间 el：其弧头的最晚开始时间减去活动时间 查找 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:29:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"基本概念 数据表：数据的有限集合 关键字：字段、属性域；互不相同的关键字也成为主关键字 查找表：支持查找功能的数据表 静态查找表：表中元素固定不变 动态查找表：表中元素在插入和删除时会得到调整，当查找失败时，将给定值的数据元素插入数据表中 装载因子 / 装填因子：数据表的长度 m 与数据元素个数 n 的比值，$$\\alpha=n/m$$ 平均查找长度 ASL (Average Search Length)：n 个关键字，第 i 个元素被查找的概率 P~i~，查找第 i 个元素所需进行关键字的比较次数为 C~i~ $$ ASL=\\sum_{i=1}^nP_i\\times C_i $$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:30:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"顺序表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:31:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"顺序查找 一个一个去找 一般实现 template \u003cclass T\u003e int SqSearch(T elem[], int n, T key) { for (int i = 0; i \u003c n \u0026\u0026 elem[i] != key; i++) ; if (i \u003c n) return i; else return -1; } 监视哨实现 0 号元素不存内容时，while 中的索引 0 可以起到监视哨的作用 template \u003cclass T\u003e int SqSearch(T elem[], int n, T key) { elem[0] = key; int i = n; while (elem[i] != key) i--; return i; } 性能分析 $$ ASL=\\sum_{i=1}^n\\frac{1}{n}\\times i=\\frac{n-1}{2} $$ 优点：算法简单，适应面广，对表的结构或关键字是否有序没有要求 缺点：查找效率低 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:31:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"二分查找 （Binary Search） 按顺序方式存储 + 关键字排序 迭代实现 递归实现 性能分析 用二叉查找树来分析 $$ ASL=\\log_2(n+1)-1 $$ 优点：特别当 n 大时，效率高 缺点：只限于顺序存储结构，只适合做静态查找 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:31:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"分块查找 索引顺序表 主表 + 索引表 当完全索引表中的关键字分块有序存放，可以建立二级索引表 块与块之间有序，块内无序 分块查找 分两次查找 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:31:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"倒排表 （Inverted Index List） 经常搜索的关键字设次索引 链式倒排表 寻找时，求交集即可 表长不定，管理麻烦 单元素倒排表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:31:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"比较 要求 顺序查找 折半查找 分块查找 ASL 最大 最小 两者之间 表结构 有序表、无序表 有序表 分块有序表 存储结构 顺序存储、线性表 顺序存储 顺序存储、线性链表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:31:5","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"二叉排序树 BST（Binary Sort / Search Tree） 对于链式存储，使用二叉排序树（二叉搜索树），以适应动态查找的要求 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:32:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 要不是空树，要不符合以下性质 左子树节点关键字都小于根节点 右子树节点关键字都大于根节点 左右子树也是二叉排序树 特点：中序遍历结果有序 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:32:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"模板定义 template \u003cclass T\u003e class BinSortTree : public BinaryTree\u003cT\u003e { // 继承二叉树的根节点数据成员 public: BinSortTree(T refvalue) : BinaryTree\u003cT\u003e(refvalue){}; BinSortTree(T *a, int n); // 插入数组元素构建二叉排序树, 不用判断 ~BinSortTree() {} void Insert(const T \u0026x, BinTreeNode\u003cT\u003e *\u0026p); // 以p为根节点, 按大小插入元素 /*判定是否为二叉排序树*/ bool IsBST_Recursive(BinTreeNode\u003cT\u003e *r, T *pre, bool *result); // 递归方式判断是否为二叉排序树 bool IsBST_Recursive(); void DisplayLarger(BinTreeNode\u003cT\u003e *p, const T \u0026x); // 从大到小输出不小于x的元素 void DisplayLarger(const T \u0026x) { DisplayLarger(this-\u003e_root, x); cout \u003c\u003c endl; } bool Find_NoRecursive(BinTreeNode\u003cT\u003e *\u0026root, const T \u0026x); // 在以root为根的子树中查找x bool Find_NoRecursive(const T \u0026x) { return Find_NoRecursive(this-\u003e_root, x); } void Insert_NoRecursive(BinTreeNode\u003cT\u003e *\u0026root, const T \u0026x); // 在以root为根的子树中插入x void Insert_NoRecursive(const T \u0026x) { Insert_NoRecursive(this-\u003e_root, x); } bool SearchOrInsert(T \u0026x); }; ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:32:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"查找 步骤 从根开始将 x 与节点值进行比较 若 x 小，沿着左子树搜索 若 x 大，沿着右子树搜索 若与 x 相等，查找成功；若为空则查找失败 比较次数不大于 h + 1 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:32:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"性能分析 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:32:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"操作 插入 先搜索 BST 中有无该节点，无才插入 查找失败时插入 删除 被删节点为叶子，将双亲结点的相应指针置空 被删节点无右子树，拿左孩子顶替它的位置 被删节点无左子树，拿右孩子顶替它的位置 被删节点左右子树都有 左子树找最大 或者右子树找最小 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:32:5","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"平衡二叉树 AVL ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:33:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 或是空树，或是符合以下条件的二叉排序树 左右子树都是平衡二叉树。 左右子树的高度差值不超过 1 平衡因子（Balance factor，BF）：左右子树高度差，其绝对值不超过 1 其 ASL 可保持在 $$O(log_2n)$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:33:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"平衡旋转 LL 平衡旋转——右单旋转 左孩子的左子树失衡 顺时针旋转 RR 平衡旋转——左单旋转 右孩子的右子树失衡 逆时针旋转 LR 平衡旋转——先左后右双旋转 先逆时针再顺时针 左孩子的右子树失衡 RL 平衡旋转——先右后左双旋转 右孩子的左子树失衡 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:33:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"插入 思想 按二叉树的排序性质插入节点 若插入后产生失衡，继续步骤 3，否则结束 找到失衡的最小子树 判断平衡旋转类型，进行相应的平衡化处理 示例 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:33:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"删除 思想 定义布尔变量 isShorter 判断被删除结点的子树高度有没有被缩短 示例 删除结点 50 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:33:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"B- 树 二叉排序树适合在内存中组织较小的索引；若对于存放在外存中的较大的文件系统，使用 B- 树或 B+ 树做文件索引 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:34:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"动态的 m 路查找树 定义 或是空树，或满足以下条件 根节点最多有 m 棵树并具有结构 $$(n,p_0,k_1,p_1,k_2,p_2,\\cdots,k_n,p_n)$$。其中，$$p_i$$ 是指向子树的指针，$$k_i$$ 是数据元素的关键字；$$1\\le i\\le n\u003cm$$ $$k_i\u003ck_{i+1},i\\le i\u003cn$$ 在 $$p_i$$ 所指的子树中所有数据元素的关键字都大于 $$k_i$$，且小于 $$k_{i+1}$$，$$0\\le i\\le n$$ 在 $$p_n$$ 所指的子树中所有数据元素的关键字都大于 $$k_n$$，而子树 $$p_0$$ 中的所有数据元素的关键字均小于 $$k_1$$ $$p_i$$ 所指的子树也是 m 路查找树，$$0\\le i\\le n$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:34:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 一颗 m 阶的 B- 树是一种平衡的 m 路查找树，通常用于文件系统（外查找） 失败节点即叶子节点 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:34:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"插入 思路 插入指在结点中插入关键字 关键字数在 $$[\\lceil m/2 \\rceil-1,m-1]$$ 之间 若关键字超出 m-1，结点要分裂 插入是个递归的过程 示例 按照关键字 {35，26，74，60，49，17，41，53，29} 构建 3 阶 B-树 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:34:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"删除 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:34:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"B+ 树 定义 叶子结点包含了全部关键字及对应指针 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:34:5","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"散列表 基本思想：在存储地址和关键字之间构建一个确定的对应关系。不经过比较就能在一次存取中得到所查元素 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:35:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"定义 哈希函数：在存储地址和关键字之间构建一个确定的对应关系/函数 $$Addr(ai)=H(ki)$$ 哈希表/散列表 哈希存储/散列存储 哈希查找/散列查找 冲突 (collision)：$$key1\\neq key2,H(key1)=H(key2)$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:35:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"哈希函数 定义域：全部关键字 值域：0 到 m-1 之间 构造方法 不是重点 直接定址法 $$H(key)=a*key+b$$，无冲突，但是要求散列地址空间大小与关键字集合大小相同 数字分析法 除留余数法 随机数法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:35:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"处理冲突 开放地址法 当冲突发生时，形成一个探查序列，逐个探查，直到找出一个空位置 探查序列 线性探测再散列 d~i~=1,2,3,…,m-1 二次探测再散列 d~i~=1^2^,-1^2^,2^2^,-2^2^,…,k^2^,-k^2^ 伪随机探测再散列 d~i~=伪随机序列 双散列函数探查法 d~i~=iH~2~(key)[计算时间增加] 拉链法 将所有关键字为同义词的记录存储在一个单链表中，并用一维数组存放头指针 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:35:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"哈希查找 过程 分析 用 ASL 分析效率 装填因子：$$\\alpha=\\frac{表中填入的记录数}{哈希表长度}$$ 排序 原理和算法实现不一定对应 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:35:4","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"基础知识 排序（sorting） 关键字（key）：分主次关键字 排序表 排序的稳定性：两个相同值的关键字的相对位置在排序后是否发生变化 内部排序：待排的数据在内存上 排序的基本操作：比较次数、移动次数 趟：对所有数据进行一次操作 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:36:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"分组 按排序依据原则分组 插入排序 交换排序 选择排序 归并排序 基数排序（分配排序） 按排序所需工作量分组 简单的排序方法：$$T(n)=O(n^2)$$ 先进的排序方法：$$T(n)=O(log_n)$$ 基数排序：$$T(n)=O(d.n)$$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:36:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"排序的存储方式 顺序表、链表、类静态链表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:36:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"各种排序方法的选用 时间复杂度 空间复杂度 稳定性 算法结构鲁棒性 参加排序数据的规模 较少，采用简单的排序方法 直接插入排序，选择排序 较大，选用执行时间与 $$nlog_2n$$ 成正比的排序方法 快速排序，希尔排序，堆排序，归并排序 较大，且关键字位数少 基数排序 关键字的分布情况 分布平均、随机 快速排序（时间短）、堆排序（空间少），希尔排序（也可） 分组基本有序 冒泡排序、直接插入排序 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:36:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"交换排序 （Exchange Sort） 对两个数据比较，如果逆序，则两者交换位置 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:37:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"冒泡排序 两两相比，重复，每次循环只确定一个最大/小值 实现 顺序表实现 template \u003cclass T\u003e SeqList\u003cT\u003e BubbleSort(SeqList\u003cT\u003e list) { for (int i = 0; i \u003c list.GetLength - 1; i++) for (int j = 0; j \u003c list.GetLength() - 1 - i; j++) if (list.GetElem(i) \u003e list.GetElem(i + 1)) list.ExchangeElem(i, i + 1); } 分析 比较次数：$$\\sum\\limits_{i=1}^{n-1}(n-i)= n(n-1)/2$$ 移动次数：$$3\\sum\\limits_{i=1}^{n-1}(n-i)= 3n(n-1)/2$$ 平均时间复杂度：$$O(n^2)$$ 最好情况 $$O(n)$$，最坏情况 $$O(n^2)$$ 空间复杂度：$$S(n)=O(1)$$ 稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:37:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"快速排序 （quick sort） 任取某个元素作为基准，划分左右子表，再在左右子表中递归快排 实现 一般实现思路 选第一个作为基准 i，从最后一个开始比较，记为 j 发生逆序，i，j 上的元素互换 若一次比较后 基准在前，j –，与后面比； 基准在后，i ++，与前面比 对左右子表进行递归 graph LR start[开始]--\u003econ1{\"i \u003c j?\"} con1 -- NO --\u003e recurve[\"结束一次快排\"] con1 -- YES --\u003e con2{\"Elem[i] \u003e Elem[j]?\"} con2 -- YES --\u003e exchange[\"i,j 值互换\"] exchange ---\u003e pivot{\"基准位置?\"} con2 -- NO --\u003epivot pivot -- \"前\" --\u003e j[\"j--\"] pivot -- \"后\" --\u003e i[\"i++\"] i --\u003e finish[\"下次循环\"] j --\u003e finish finish --\u003e con1 顺序表实现 template \u003cclass T\u003e void QuickSortHelp(SeqList\u003cT\u003e \u0026list, int start, int end) { int i = start; // 基准 int j = end; // 从最后开始比较 bool pivotLocation = true; // true表示基准位置在前 while (i \u003c j) { if (list.GetElem(i) \u003e list.GetElem(j)) { list.ExchangeElem(i, j); pivotLocation = !pivotLocation; } if (pivotLocation) // 基准位置在前 j--; else // 基准位置在后 i++; } if (start \u003c i - 1) QuickSortHelp(list, start, i - 1); if (i + 1 \u003c end) QuickSortHelp(list, i + 1, end); } template \u003cclass T\u003e void QuickSort(SeqList\u003cT\u003e \u0026list) { QuickSortHelp(list, 0, list.GetLength() - 1); } 分析 比较次数：$$\\sum\\limits_{i=1}^{n-1}(n-i)= n(n-1)/2$$ 移动次数：$$3\\sum\\limits_{i=1}^{n-1}(n-i)= 3n(n-1)/2$$ 平均时间复杂度：$$O(nlog_2n)$$ 最好情况 $$O(nlog_2n)$$，最坏情况 $$O(n^2)$$ 空间复杂度 最坏情况 $$S(n)=O(n)$$ 一般情况 $$S(n)=O(nlog_2n)$$ 不稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:37:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"插入排序 （Insertion Sort） 每次把一个数据插入到已经排序的序列中 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:38:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"直接插入排序 （Straight Insertion Sort） 实现 线性表实现 template \u003cclass T\u003e void StraightInsertionSort(SeqList\u003cT\u003e \u0026list) { int j; for (int i = 1; i \u003c list.GetLength(); i++) // 遍历无序区 { T e = list.GetElem(i); // 取出无序区第一个元素 for (j = i - 1; j \u003e= 0 \u0026\u0026 list.GetElem(j) \u003e e; j--) list.SetElem(j + 1, list.GetElem(j)); // 将比e大的元素后移一位 list.SetElem(j + 1, e); //在j+1处插入e } } 分析 比较次数：$$\\sum\\limits_{i=1}^{n-1}i=n(n-1)/2\\approx n^2/2$$ 移动次数：$$\\sum\\limits_{i=1}^{n-1}i+2=(n+4)(n-1)/2\\approx n^2/2$$ 平均时间复杂度：$$O(n^2)$$ 最好情况 $$O(n)$$，最坏情况 $$O(n^2)$$ 初始数据表越接近有序，效率越高 空间复杂度：$$S(n)=O(1)$$ 稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:38:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"折半插入排序 （Binary Insertion Sort） 相对于直接插入排序，在插入时，折半插入排序不是一个个比，而是利用折半查找来寻找位置 只能用于顺序存储 实现 分析 比较次数减少了 时间复杂度、空间复杂度与直接插入排序相同 单纯的折半不能保证稳定性 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:38:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"希尔排序 （Shell Sort）又称缩小增量排序 先将待排关键字分为若干子列分别用直接插入法排序，再对全体关键字用直接插入排序 n 个元素，取长度 d \u003c n 作为间隔，分出 d 个子表，所有相距 d 的数据元素放在同一子表中，子表中进行直接插入排序；然后再缩小 d（如取 $$d=\\lceil d/2 \\rceil$$），重复迭代直到 d = 1 后，将所有数据一起来依一次直接插入排序 分析 不稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:38:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"选择排序 （Selection Sort） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:39:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"简单选择排序 （Simple selection sort） 在序列中首先找到最小元素放在首位，再在未排序序列（无序区）中寻找最小元素放在已排序序列（有序区）末尾，以此类推 实现 分析 相较于冒泡排序，移动次数减少 平均时间复杂度：$$O(n^2)$$ 最好情况 $$O(n^2)$$，最坏情况 $$O(n^2)$$ 空间复杂度：$$S(n)=O(1)$$ 不稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:39:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"锦标赛排序 （Tournament sort）又称树形选择排序 将 n 个元素两两分组，分别比较，得到 n/2 个优胜者，保留结果；对优胜者继续比较，以此类推。 分析 以空间换时间 比较次数：$$O(nlog_2n)$$ 时间复杂度：$$O(nlog_2n)$$ 空间复杂度： 不稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:39:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"堆排序 （Heap sort） 建堆，输出堆顶，调整堆，以此类推 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:39:3","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"归并排序 （Merge sort） 归并：将两个（二路归并）或两个以上的有序表合并成一个新的有序表 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:40:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"二路归并排序 一直两两归并，顺序存储时，另外开辟空间 实现 分析 以空间换时间 时间复杂度：$$O(nlog_2n)$$ 空间复杂度：$$O(n)$$ 稳定 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:40:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"递归归并 一分为二，左右递归 实现 分析 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:40:2","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"基数排序 （Radix sort）也叫桶排序 本质：多关键字排序 最高位优先法（Most significant digit first）MSD 最低位优先法（Least significant digit first）LSD 基数：关键字取值的种数 ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:41:0","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["专业课"],"content":"链式基数排序 用链表模拟队列 分析 时间复杂度 n 记录数，d 关键字位数，radix 关键字取值范围 $$O(d(n+radix))$$，即—— n 趟 * （n 次分配 + radix 次收集） ","date":"2021-11-25","objectID":"/Notes/posts/courses/datastructure/:41:1","tags":["数据结构","算法"],"title":"数据结构","uri":"/Notes/posts/courses/datastructure/"},{"categories":["Python"],"content":"进阶 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:0:0","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"杂知识点 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:1:0","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"什么是CPython GIL? GIL，Global Interpreter Lock，即全局解释器锁 引入 GIL 是因为 CPython 的内存管理并不是线程安全的 为了保护多线程下对 python 对象的访问，每个线程在执行过程中都需要先获取 GIL，保证同一时刻只有一个线程在执行代码 GIL 使得 python 的多线程不能充分发挥多核 CPU 的性能，对 CPU 密集型程序的影响较大 另一种解释 全局解释器锁 GIL，英文名称为 Global Interpreter Lock，它是解释器中一种线程同步的方式。 对于每一个解释器进程都具有一个 GIL ，它的直接作用是限制单个解释器进程中多线程的并行执行，使得即使在多核处理器上对于单个解释器进程来说，在同一时刻运行的线程仅限一个。 对于 Python 来讲，GIL 并不是它语言本身的特性，而是 CPython 解释器的实现特性。 Python 代码被编译后的字节码会在解释器中执行，在执行过程中，存在于 CPython 解释器中的 GIL 会致使在同一时刻只有一个线程可以执行字节码。 GIL 的存在引起的最直接的问题便是：在一个解释器进程中通过多线程的方式无法利用多核处理器来实现真正的并行。 因此，Python的多线程是伪多线程，无法利用多核资源，同一个时刻只有一个线程在真正的运行。 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:1:1","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"Python的内存管理 Python 有内存池机制，Pymalloc 机制，用于对内存的申请和释放管理。先来看一下为什么有内存池： 当创建大量消耗小内存的对象时，c 中频繁调用 new/malloc 会导致大量的内存碎片，致使效率降低。 内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。 查看源码，可以看到 Pymalloc 对于小的对象，Pymalloc 会在内存池中申请空间，一般是少于236kb，如果是大的对象，则直接调用 new/malloc 来申请新的内存空间。 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:1:2","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"python 垃圾回收机制 引用计数为主，标记清除和分代回收为辅 引用计数 引用计数机制是这样的： 当对象被创建，被引用，作为参数传递，存储到容器中，引用计数 +1 当对象离开作用域，引用指向别的对象，del，从容器中移除，引用计数 -1 当引用计数降为 0，python 就会自动回收该对象所在的内存空间， 但是引用计数无法解决循环引用的问题，所以引入了标记清除和分代回收机制 标记清除 标记清除主要是解决循环引用问题。 标记清除算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。 它分为两个阶段：第一阶段是标记阶段，GC 会把所有的 活动对象 打上标记，第二阶段是把那些没有标记的对象 非活动对象 进行回收。那么 GC 又是如何判断哪些是活动对象哪些是非活动对象的呢？ 对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。 分代回收 分代回收是一种以空间换时间的操作方式。 Python 将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python 将内存分为了 3“代”，分别为年轻代（第 0 代）、中年代（第 1 代）、老年代（第 2 代），他们对应的是 3 个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python 垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:1:3","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"async 和 await 的作用 async: 声明一个函数为异步函数，函数内只要有 await 就要声明为 async await: 搭配 asyncio.sleep() 时会切换协程，当切换回来后再继续执行下面的语句 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:1:4","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["Python"],"content":"OOP 相关 类变量和实例变量的区别？ 类变量由所有实例共享 实例变量由实例单独享有，不同实例之间不影响 当我们需要在一个类的不同实例之间共享变量的时候使用类变量 classmethod 和 staticmethod 区别？ 都可以通过 Class.method() 的方式使用 classmethod 第一个参数是 cls，可以引用类变量 staticmethod 使用起来和普通函数一样，只不过放在类里去组织 classmethod 是为了使用类变量，staticmethod 是代码组织的需要，完全可以放到类之外 class Person: Country = 'china' def __init__(self, name, age): self.name = name self.age = age def print_name(self): print(self.name) @classmethod def print_country(cls): print(cls.Country) @staticmethod def join_name(first_name, last_name): return print(last_name + first_name) a = Person(\"Bruce\", \"Lee\") a.print_country() a.print_name() a.join_name(\"Bruce\", \"Lee\") Person.print_country() Person.print_name(a) Person.join_name(\"Bruce\", \"Lee\") __new__ 和 __init__ 区别？ __new__ 是一个静态方法，而 __init__ 是一个实例方法. __new__ 方法会返回一个创建的实例，而 __init__ 什么都不返回. 只有在 __new__ 返回一个 cls 的实例时后面的 __init__ 才能被调用. 当创建一个新实例时调用 __new__，初始化一个实例时用 __init__. 我们可以做几个有趣的实验。 class Person: def __new__(cls, *args, **kwargs): print(\"in __new__\") instance = super().__new__(cls) return instance def __init__(self, name, age): print(\"in __init__\") self._name = name self._age = age p = Person(\"zhiyu\", 26) print(\"p:\", p) 这段程序输出为： in __new__ in __init__ p: \u003c__main__.Person object at 0x00000261FE562E50\u003e 可以看到先执行 new 方法创建对象，然后 init 进行初始化。假设将 new 方法中不返还该对象，会有什么结果了？ class Person: def __new__(cls, *args, **kwargs): print(\"in __new__\") instance = super().__new__(cls) #return instance def __init__(self, name, age): print(\"in __init__\") self._name = name self._age = age p = Person(\"zhiyu\", 26) print(\"p:\", p) 发现如果 new 没有返回实例化对象，init 就没法初始化了。 输出结果为： in __new__ p: None 什么是元类？ 元类 (meta class) 是创建类的类 元类允许我们控制类的生成，比如修改类的属性等 使用 type 来定义元类 元类最常见的一个使用场景就是 ORM 框架 ","date":"2022-04-02","objectID":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/:1:5","tags":["Python"],"title":"Python 进阶","uri":"/Notes/posts/python/%E8%BF%9B%E9%98%B6/"},{"categories":["刷题"],"content":"136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 输入: [2,2,1] 输出: 1 示例 2: 输入: [4,1,2,1,2] 输出: 4 ","date":"2022-03-30","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/136.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["算法"],"title":"136. 只出现一次的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/136.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"异或 异或运算满足交换律，a^b^a=a^a^b=b，因此 ans 相当于 nums[0]^nums[1]^nums[2]^nums[3]^nums[4]….. 然后再根据交换律把相等的合并到一块儿进行异或（结果为 0），然后再与只出现过一次的元素进行异或，这样最后的结果就是，只出现过一次的元素（0 ^ 任意值 = 任意值） func singleNumber(nums []int) int { res := nums[0] for i := 1; i \u003c len(nums); i++ { res ^= nums[i] } return res } ","date":"2022-03-30","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/136.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/:1:0","tags":["算法"],"title":"136. 只出现一次的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/136.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["前端"],"content":"CSS ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:0:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"基本知识 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:1:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"简介 层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现 HTML（标准通用标记语言的一个应用）或 XML（标准通用标记语言的一个子集）等文件样式的计算机语言 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:1:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"语法 选择器{声明} selector { property: value } /* Example */ div { font-size: 100px; color: red; } 选择器（Selector）：浏览器根据选择器决定哪些html元素受css样式的影响 属性（Property）：是你要改变的样式名 值（Value ）：将值分配给属性 注意 每个属性用；分开。 CSS注释以 /* 开始, 以 */ 结束 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:1:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"引入方式 优先级：内联样式 \u003e 内部样式 \u003e 外部样式 注意：如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式 内联样式表 Inline style，也叫行内式 在元素标签内部的style属性中设定CSS格式 \u003cdiv style=\"color: red; font-size: 12px;\"\u003e起飞\u003c/div\u003e 内部样式表 Internal style sheet，也叫嵌入式 将所有 CSS 代码抽取出来，单独放到一个 \u003cstyle\u003e 标签中 \u003cstyle\u003e div { border: 2px solid green; font-size: 100px; color: green; } \u003c/style\u003e 外部样式表 External style sheet，也叫链接式 样式单独写到 CSS 文件中，把文件引入到 HTML 页面中使用 建立步驟 新建一个后缀名为 .css 样式的文件，把 CSS 代码放入其中 用\u003clink\u003e标签引入文件 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"css文件路径\"\u003e ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:1:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"Emmet 语法 快速生成 HTML 语法 生成标签：写标签名，按 tab 生成多个相同标签：标签名 *num，按 tab 生成父子级标签：用 \u003e，如 ul\u003eli 生成兄弟级标签：用 +，如 div+p ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:1:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"选择器 ID 选择器 \u003e 类选择器 \u003e 标签选择器 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"标签选择器 也叫元素选择器，selector 为标签名 div { border: 1px solid blue; font-size: 10px; color: blue; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"类选择器 以一个点 “.” 号显示 任何标签都可以添加一个或多个 class 属性（类名间用空格分开），并且 class 属性是可以相同的 类选择器实现差异化选择不同标签 .class_name { border: 10px solid green; font-size: 30px; color: green; } 可以单独设置拥有 class 名的特定标签的样式 h1.black { color: #000000; } 上述规则仅将 class 属性设置为 black 的 \u003ch1\u003e 元素呈现为黑色 可以单独设置位于拥有 class 名的标签内部的标签的样式 .black h1 { color: #000000; } 在此示例中，当所有 \u003ch1\u003e 位于 id 属性设置为 black 的标签中时，这些标题将以黑色显示 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"id 选择器 以 “#” 来定义 任何标签都可以添加 id 属性，并且一个页面的 id 应该保持唯一性 只能调用一次，一般用于页面唯一性的元素上 #id_name { border: 5px solid red; font-size: 20px; color: red; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"通配符选择器 使用 “*” 定义，表示选取页面中所有的元素（标签） 不需要调用，作用于全局 * { border: 10px solid green; font-size: 30px; color: green; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"聚合选择器 可以将样式应用于许多选择器，只需用逗号分隔 h1, h2, h3 { color: #36C; font-weight: normal; letter-spacing: .4em; margin-bottom: 1em; text-transform: lowercase; } #content, #footer, #supplement { position: absolute; left: 510px; width: 200px; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:5","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"特定选择器 假设仅当样式规则位于特定元素内时，才希望将其应用于特定元素 如以下示例所示，样式规则仅在 \u003cem\u003e 元素位于 \u003cul\u003e 标签内时才适用 ul em { color: #000000; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:6","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"子元素选择器 body \u003e p { color: #000000; } \u003cbody\u003e 元素的直接 \u003cp\u003e 子元素将呈现为黑色 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:7","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"属性选择器 将样式应用于具有特定属性的 HTML 元素 input[type=\"text\"] { color: #000000; } 上述样式规则将匹配所有具有 type 属性值为 text 的输入元素 以下规则适用于属性选择器 p [lang] - 选择有 lang 属性的所有段落元素。 p [lang =\"fr\"] - 选择其 lang 属性的值为\" fr\"的所有段落元素。 p [lang~=\"fr\"] - 选择所有 lang 属性包含单词\" fr\"的段落元素。 p [lang|=\"en\"] - 选择其 lang 属性包含的值完全为\" en\"或以\"en-“开始的所有段落元素。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:8","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"选择器查询表 选择器 例子 例子描述 CSS .class .intro 选择 class=“intro” 的所有元素。 1 #id #firstname 选择 id=“firstname” 的所有元素。 1 * * 选择所有元素。 2 element p 选择所有 \u003cp\u003e 元素。 1 element, element div,p 选择所有 \u003cdiv\u003e 元素和所有 \u003cp\u003e 元素。 1 element element div p 选择 \u003cdiv\u003e 元素内部的所有 \u003cp\u003e 元素。 1 element \u003e element div\u003ep 选择父元素为 \u003cdiv\u003e 元素的所有 \u003cp\u003e 元素。 2 element + element div+p 选择紧接在 \u003cdiv\u003e 元素之后的所有 \u003cp\u003e 元素。 2 [attribute] [target] 选择带有 target 属性所有元素。 2 [attribute=value] [target=_blank] 选择 target=\"_blank” 的所有元素。 2 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素。 2 [attribute|=value] [lang|=en] 选择 lang 属性值以 “en” 开头并用“-”分隔的字符串的所有元素。 2 :link a:link 选择所有未被访问的链接。 1 :visited a:visited 选择所有已被访问的链接。 1 :active a:active 选择活动链接。 1 :hover a:hover 选择鼠标指针位于其上的链接。 1 :focus input:focus 选择获得焦点的 input 元素。 2 :first-letter p:first-letter 选择每个 \u003cp\u003e 元素的首字母。 1 :first-line p:first-line 选择每个 \u003cp\u003e 元素的首行。 1 :first-child p:first-child 选择属于父元素的第一个子元素的每个 \u003cp\u003e 元素。 2 :before p:before 在每个 \u003cp\u003e 元素的内容之前插入内容。 2 :after p:after 在每个 \u003cp\u003e 元素的内容之后插入内容。 2 :lang(language) p:lang(it) 选择带有以 “it” 开头的 lang 属性值的每个 \u003cp\u003e 元素。 2 element1~element2 p~ul 选择前面有 \u003cp\u003e 元素的每个 \u003cul\u003e 元素。 3 [attribute^=value] a[src^=“https”] 选择其 src 属性值以 “https” 开头的每个 \u003ca\u003e 元素。 3 [attribute$=value] a[src$=\".pdf\"] 选择其 src 属性以 “.pdf” 结尾的所有 \u003ca\u003e 元素。 3 [attribute*=value] a[src*=“abc”] 选择其 src 属性中包含 “abc” 子串的每个 \u003ca\u003e 元素。 3 :first-of-type p:first-of-type 匹配同类型(\u003cp\u003e)中的第一个同级兄弟(含自己) \u003cp\u003e 元素 3 :last-of-type p:last-of-type 匹配同类型(\u003cp\u003e)中的最后一个同级兄弟(含自己) \u003cp\u003e 元素 3 :only-of-type p:only-of-type 选择属于其父元素唯一的 \u003cp\u003e 元素。 3 :only-child p:only-child 选择属于其父元素的唯一子元素。 3 :nth-child(n) p:nth-child(2) 选择属于p的父元素的第二个子元素 3 :nth-last-child(n) p:nth-last-child(2) 同上，从最后一个子元素开始计数。 3 :nth-of-type(n) p:nth-of-type(2) 选择属于p的父元素第二个同类（这里是p）元素。 3 :nth-last-of-type(n) p:nth-last-of-type(2) 同上，但是从最后一个子元素开始计数。 3 :last-child p:last-child 选择属于其父元素最后一个子元素每个 \u003cp\u003e 元素。 3 :root :root 选择文档的根元素。 3 :empty p:empty 选择没有子元素的每个 \u003cp\u003e 元素（包括文本节点）。 3 :target #news:target 选择当前活动的 #news 元素。 3 :enabled input:enabled 选择每个启用的 \u003cinput\u003e 元素。 3 :disabled input:disabled 选择每个禁用的 \u003cinput\u003e 元素 3 :checked input:checked 选择每个被选中的 \u003cinput\u003e 元素。 3 :not(selector) :not(p) 选择非 \u003cp\u003e 元素的每个元素。 3 ::selection ::selection 选择被用户选取的元素部分。 3 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:2:9","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"字体属性 （Font） CSS 字体属性定义字体，加粗，大小，文字样式 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"字体 font-family font - family 属性指定一个元素的字体。 font-family 可以把多个字体名称作为一个\"回退\"系统来保存。如果浏览器不支持第一个字体，则会尝试下一个 p { font-family: \"Times New Roman\", Georgia, Serif; } 有两种类型的字体系列名称 family-name - 指定的系列名称：具体字体的名称，比如：“times”、“courier”、“arial” generic-family - 通常字体系列名称：比如：“serif”、“sans-serif”、“cursive”、“fantasy”、“monospace 注意 每个值用逗号分开 如果字体名称包含空格，它必须加上引号；在HTML中使用\"style\"属性时，必须使用单引号 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"大小 font-size font-size 属性用于设置字体大小 p { font-size: 18px; } 属性值 值 描述 xx-small x-small small medium large x-large xx-large 把字体的尺寸设置为不同的尺寸，从 xx-small 到 xx-large。默认值：medium。 smaller 把 font-size 设置为比父元素更小的尺寸。 larger 把 font-size 设置为比父元素更大的尺寸。 length 把 font-size 设置为一个固定的值。 % 把 font-size 设置为基于父元素的一个百分比值。 /* \u003cabsolute-size\u003e，绝对大小值 */ font-size: xx-small; font-size: x-small; font-size: small; font-size: medium; font-size: large; font-size: x-large; font-size: xx-large; /* \u003crelative-size\u003e，相对大小值 */ font-size: larger; font-size: smaller; /* \u003clength\u003e，长度值 */ font-size: 12px; font-size: 0.8em; /* \u003cpercentage\u003e，百分比值 */ font-size: 80%; 长度单位 绝对单位 1 in=2.54cm=25.4mm=72pt=6pc。 各种单位的含义： in：英寸Inches (1 英寸 = 2.54 厘米) cm：厘米Centimeters mm：毫米Millimeters pt：点Points，或者叫英镑 (1点 = 1/72英寸) pc：皮卡Picas (1 皮卡 = 12 点) 相对单位 px：像素 em：印刷单位相当于12个点 用 em 来设置字体大小 为了避免Internet Explorer 中无法调整文本的问题，许多开发者使用 em 单位代替像素。 em的尺寸单位由W3C建议。 1em和当前字体大小相等。在浏览器中默认的文字大小是16px，因此有px/16=em h1 { font-size: 2.5em; } /* 40px/16=2.5em */ h2 { font-size: 1.875em; } /* 30px/16=1.875em */ p { font-size: 0.875em; } /* 14px/16=0.875em */ 使用百分比和 EM 组合 在所有浏览器的解决方案中，设置 \u003cbody\u003e元素的默认字体大小的是百分比 body { font-size: 100%; } h1 { font-size: 2.5em; } h2 { font-size: 1.875em; } p { font-size: 0.875em; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"样式 font-style font-style属性指定文本的字体样式 p { font-style: italic; } 属性值 值 描述 normal 默认值。浏览器显示一个标准的字体样式。 italic 浏览器会显示一个斜体的字体样式。 oblique 浏览器会显示一个倾斜的字体样式。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"粗细 font-weight font-weight 属性设置文本的粗细 p.normal { font-weight: normal; } p.thick { font-weight: bold; } p.thicker { font-weight: 900; } 属性值 值 描述 normal 默认值。定义标准的字符。 bold 定义粗体字符。 bolder 定义更粗的字符。 lighter 定义更细的字符。 100 200 300 400 500 600 700 定义由细到粗的字符。400 等同于 normal，而 700 等同于 bold。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"小型大写字母字体 font-variant font-variant 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小 p { font-variant: small-caps; } 属性值 值 描述 normal 默认值。浏览器会显示一个标准的字体。 small-caps 浏览器会显示小型大写字母的字体。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:5","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"字体复合属性 font font 简写属性在一个声明中设置所有字体属性。 可设置的属性是（按顺序）： “font-style font-variant font-weight font-size/line-height font-family” font-size和font-family的值是必需的。如果缺少了其他值，默认值将被插入，如果有默认值的话 p.ex1 { font: 15px arial, sans-serif; } p.ex2 { font: italic bold 12px/30px Georgia, serif; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:3:6","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"文本 Text ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"颜色 color color属性指定文本的颜色 body { color: red; } h1 { color: #00ff00; } p { color: rgb(0, 0, 255); } 属性值 值 描述 实例 颜色名称 颜色的名称，比如red, blue, brown, lightseagreen等，不区分大小写。 color:red; 红色 color:black; 黑色 color:gray; 灰色 color:white; 白色 color:purple; 紫色 十六进制 十六进制符号 #RRGGBB 和 #RGB（比如 #ff0000）。”#\" 后跟 6 位或者 3 位十六进制字符（0-9, A-F）。 #f03 #F03 #ff0033 #FF0033 RGB 函数格式为 rgb(R,G,B)，取值可以是 0-255 的整数或百分比。 rgb(255,0,51) rgb(255, 0, 51) rgb(100%,0%,20%) rgb(100%, 0%, 20%) ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"对齐方式 text-align text-align属性指定元素文本的水平对齐方式。 h1 { text-align: center; } h2 { text-align: left; } h3 { text-align: right; } 属性值 值 描述 left 把文本排列到左边。默认值：由浏览器决定。 right 把文本排列到右边。 center 把文本排列到中间。 justify 实现两端对齐文本效果。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"修饰 text-decoration text-decoration 属性规定添加到文本的修饰，下划线、上划线、删除线等 h1.under { text-decoration: underline; } h1.over { text-decoration: overline; } p.line { text-decoration: line-through; } p.blink { text-decoration: blink; } a.none { text-decoration: none; } p.underover { text-decoration: underline overline; } h3 { text-decoration: underline wavy red; } text-decoration 属性是以下三种属性的简写： text-decoration-line text-decoration-color text-decoration-style 属性值 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 blink 定义闪烁的文本。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"首行文本缩进 text-indent text-indent 属性规定文本块中首行文本的缩进。 p { text-indent: 50px; } 属性值 值 描述 length 定义固定的缩进。默认值：0。 % 定义基于父元素宽度的百分比的缩进。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"控制大小写 text-transform text-transform 属性控制文本的大小写。 h1 { text-transform: uppercase; } h2 { text-transform: capitalize; } p { text-transform: lowercase; } 属性值 值 描述 none 默认。定义带有小写字母和大写字母的标准的文本。 capitalize 文本中的每个单词以大写字母开头。 uppercase 定义仅有大写字母。 lowercase 定义无大写字母，仅有小写字母。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:5","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"字符间距 letter-spacing letter-spacing 属性增加或减少字符间的空白（字符间距） h1 { letter-spacing: 2px; } h2 { letter-spacing: -3px; } 属性值 值 描述 normal 默认。规定字符间没有额外的空间。 length 定义字符间的固定空间（允许使用负值）。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:6","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"字间距 word-spacing word-spacing属性增加或减少字与字之间的空白。 p { word-spacing: 30px; } 属性值 值 描述 normal 默认。定义单词间的标准空间。 length 定义单词间的固定空间。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:7","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"行间距 line-height line-height 设置以百分比计的行高 p.small { line-height: 90%; } p.big { line-height: 200%; } 属性值 值 描述 normal 默认。设置合理的行间距。 number 设置数字，此数字会与当前的字体尺寸相乘来设置行间距。 length 设置固定的行间距。 % 基于当前字体尺寸的百分比行间距。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:8","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"文字阴影 text-shadow text-shadow 属性应用于阴影文本 h1 { text-shadow: 2px 2px #ff0000; } 语法 text-shadow: h-shadow v-shadow blur color; 值 描述 h-shadow 必需。水平阴影的位置。允许负值。 v-shadow 必需。垂直阴影的位置。允许负值。 blur 可选。模糊的距离。 color 可选。阴影的颜色。 \u003ch1 style=\"text-shadow:0 0 3px #FF0000;\"\u003eText-shadow with neon glow\u003c/h1\u003e Text-shadow with neon glow \u003ch1 style=\"text-shadow:2px 2px 8px #FF0000;\"\u003eText-shadow with neon glow\u003c/h1\u003e Text-shadow with neon glow \u003ch1 style=\"color:white; text-shadow:2px 2px 4px #000000;\"\u003eText-shadow with neon glow\u003c/h1\u003e Text-shadow with neon glow ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:4:9","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"背景 Backgrounds ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"颜色 background-color background-color属性设置一个元素的背景颜色。 元素的背景是元素的总大小，包括填充和边界（但不包括边距） body { background-color: yellow; } h1 { background-color: #00ff00; } p { background-color: rgb(255, 0, 255); } 属性值 值 描述 color 指定背景颜色。在CSS颜色值近可能的寻找一个颜色值的完整列表。 transparent 指定背景颜色应该是透明的。这是默认 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"图像 background-image background-image 属性设置一个元素的背景图像。 元素的背景是元素的总大小，包括填充和边界（但不包括边距）。 默认情况下，background-image放置在元素的左上角，并重复垂直和水平方向。 提示：请设置一种可用的背景颜色，这样的话，假如背景图像不可用，可以使用背景色带代替。 body { background-image: url('paper.gif'); background-color: #cccccc; } 属性 值 说明 url(‘URL’) 图像的URL none 无图像背景会显示。这是默认 linear-gradient() 创建一个线性渐变的 “图像”(从上到下) radial-gradient() 用径向渐变创建 “图像”。 (center to edges) repeating-linear-gradient() 创建重复的线性渐变 “图像”。 repeating-radial-gradient() 创建重复的径向渐变 “图像” ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"图像重复设置 background-repeat 设置如何平铺对象的 background-image 属性。 默认情况下，重复background-image的垂直和水平方向。 body { background-image: url('paper.gif'); background-repeat: repeat-y; } 属性 值 说明 repeat 背景图像将向垂直和水平方向重复。（默认） repeat-x 只有水平位置会重复背景图像 repeat-y 只有垂直位置会重复背景图像 no-repeat background-image不会重复，即显示图片原长 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"图像固定或滚动 background-attachment background-attachment设置背景图像是否固定或者随着页面的其余部分滚动。 body { background-image:url('smiley.gif'); background-repeat:no-repeat; background-attachment:fixed; } 属性值 值 描述 scroll 背景图片随着页面的滚动而滚动，这是默认的。 fixed 背景图片不会随着页面的滚动而滚动。 local 背景图片会随着元素内容的滚动而滚动。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"图像起始位置 background-position background-position属性设置背景图像的起始位置。 body { background-image: url('smiley.gif'); background-repeat: no-repeat; background-attachment: fixed; background-position: center; } 属性值 值 描述 left top， left center， left bottom， right top， right center， right bottom， center top， center center， center bottom 如果仅指定一个关键字，其他值将会是\"center\" x% y% 第一个值是水平位置，第二个值是垂直。左上角是0％0％。右下角是100％100％。如果仅指定了一个值，其他值将是50％。 。默认值为：0％0％ xpos ypos 第一个值是水平位置，第二个值是垂直。左上角是0。单位可以是像素（0px0px）或任何其他 CSS单位。如果仅指定了一个值，其他值将是50％。你可以混合使用％和positions ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:5","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"背景复合属性 背景缩写属性可以在一个声明中设置所有的背景属性。 可以设置的属性分别是：background-color、background-position、background-size、background-repeat、background-origin、background-clip、background-attachment 和 background-image。 各值之间用空格分隔，不分先后顺序。可以只有其中的某些值 background:bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit; 属性值 值 说明 CSS background-color 指定要使用的背景颜色 1 background-position 指定背景图像的位置 1 background-size 指定背景图片的大小 3 background-repeat 指定如何重复背景图像 1 background-origin 指定背景图像的定位区域 3 background-clip 指定背景图像的绘画区域 3 background-attachment 设置背景图像是否固定或者随着页面的其余部分滚动。 1 background-image 指定要使用的一个或多个背景图像 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:5:6","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"链接 链接的样式，可以用任何CSS属性（如颜色，字体，背景等） 特别的链接，可以有不同的样式，这取决于他们是什么状态 这四个链接状态是： a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 /* 未访问链接*/ a:link { color: #000000; } /* 已访问链接 */ a:visited { color: #00FF00; } /* 鼠标移动到链接上 */ a:hover { color: #FF00FF; } /* 鼠标点击时 */ a:active { color: #0000FF; } 规则 四种状态必须按照固定的顺序写，也就是所谓的“爱恨原则”（LoVe/HAte）： a:link 、a:visited 、a:hover 、a:active ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:6:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"列表 CSS 列表属性作用如下： 设置不同的列表项标记为有序列表 设置不同的列表项标记为无序列表 设置列表项标记为图像 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:7:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"图像替代 list-style-image list-style-image 属性使用图像来替换列表项的标记。 ul { list-style-image: url('sqpurple.gif'); } 属性值 值 描述 URL 图像的路径。 none 默认。无图形被显示。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:7:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"标记位置 list-style-position list-style-position 属性指示如何相对于对象的内容绘制列表项标记 ul { list-style-position: inside; } 属性值 值 描述 inside 列表项目标记放置在文本以内，且环绕文本根据标记对齐。 outside 默认值。保持标记位于文本的左侧。列表项目标记放置在文本以外，且环绕文本不根据标记对齐。 该列表的 list-style-position 的值是 \"inside\"： Earl Grey Tea - 一种黑颜色的茶 Jasmine Tea - 一种神奇的“全功能”茶 Honeybush Tea - 一种令人愉快的果味茶 该列表的 list-style-position 的值是 \"outside\"： Earl Grey Tea - 一种黑颜色的茶 Jasmine Tea - 一种神奇的“全功能”茶 Honeybush Tea - 一种令人愉快的果味茶 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:7:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"标记类型 list-style-type list-style-type 属性设置列表项标记的类型 ul.circle { list-style-type: circle } ul.square { list-style-type: square } ol.upper-roman { list-style-type: upper-roman } ol.lower-alpha { list-style-type: lower-alpha } 属性值 值 描述 none 无标记。 disc 默认。标记是实心圆。 circle 标记是空心圆。 square 标记是实心方块。 decimal 标记是数字。 decimal-leading-zero 0开头的数字标记。(01, 02, 03, 等。) lower-roman 小写罗马数字(i, ii, iii, iv, v, 等。) upper-roman 大写罗马数字(I, II, III, IV, V, 等。) lower-alpha 小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。) upper-alpha 大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。) lower-greek 小写希腊字母(alpha, beta, gamma, 等。) lower-latin 小写拉丁字母(a, b, c, d, e, 等。) upper-latin 大写拉丁字母(A, B, C, D, E, 等。) hebrew 传统的希伯来编号方式 armenian 传统的亚美尼亚编号方式 georgian 传统的乔治亚编号方式(an, ban, gan, 等。) cjk-ideographic 简单的表意数字 hiragana 标记是：a, i, u, e, o, ka, ki, 等。（日文平假名字符） katakana 标记是：A, I, U, E, O, KA, KI, 等。（日文片假名字符） hiragana-iroha 标记是：i, ro, ha, ni, ho, he, to, 等。（日文平假名序号） katakana-iroha 标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名序号） 无序列表实例: Coffee Tea Coca Cola Coffee Tea Coca Cola 有序列表实例: Coffee Tea Coca Cola Coffee Tea Coca Cola ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:7:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"列表复合属性 list-style list-style 简写属性在一个声明中设置所有的列表属性 可以设置的属性（按顺序）： list-style-type, list-style-position, list-style-image. 可以不设置其中的某个值，比如 “list-style:circle inside;” 也是允许的。未设置的属性会使用其默认值 ul { list-style: square url(\"sqpurple.gif\"); } 属性值 值 描述 list-style-type 设置列表项标记的类型 list-style-position 设置在何处放置列表项标记 list-style-image 使用图像来替换列表项的标记 initial 将这个属性设置为默认值 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:7:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"表格 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"边框属性 border table, th, td { border: 1px solid black; } 在上面的例子中的表格有双边框。这是因为表和 th/ td 元素有独立的边界。 为了显示一个表的单个边框，使用 border-collapse 属性。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:1","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"折叠边框 border-collapse border-collapse 属性设置表格的边框是否被折叠成一个单一的边框或隔开 table { border-collapse:collapse; } table,th, td { border: 1px solid black; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:2","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"表格宽度和高度 Width 和 height Width和height属性定义表格的宽度和高度。 下面的例子是设置 100％的宽度，50 像素的 th 元素的高度的表格 table { width:100%; } th { height:50px; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:3","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"表格文字对齐 text-align 和 vertical-align 表格中的文本对齐和垂直对齐属性。 text-align 属性设置水平对齐方式，向左，右，或中心 td { text-align:right; } 垂直对齐属性 vertical-align 设置垂直对齐，比如顶部，底部或中间 td { height:50px; vertical-align:bottom; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:4","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"表格填充 padding 如果在表的内容中控制空格之间的边框，应使用 td 和 th 元素的填充属性 padding td { padding:15px; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:5","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"表格颜色 color 下面的例子指定边框的颜色，和th元素的文本和背景颜色 table, td, th { border:1px solid green; } th { background-color:green; color:white; } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:8:6","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["前端"],"content":"position static（静态定位）：默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 relative（相对定位）：生成相对定位的元素，通过 top,bottom,left,right 的设置相对于其正常（原先本身）位置进行定位。可通过 z-index 进行层次分级。　 absolute（绝对定位）：生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过 z-index 进行层次分级。 fixed（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。可通过 z-index 进行层次分级。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/css/css/:9:0","tags":["CSS","前端","快速入门"],"title":"CSS","uri":"/Notes/posts/frontend/css/css/"},{"categories":["Golang"],"content":"Golang Go is an open source programming language supported by Google Easy to learn and get started with Built-in concurrency and a robust standard library Growing ecosystem of partners, communities, and tools ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:0:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"安装 下载地址：https://go.dev/dl/ 使用 Linux $ wget https://studygolang.com/dl/golang/go1.13.6.linux-amd64.tar.gz $ tar -zxvf go1.13.6.linux-amd64.tar.gz $ sudo mv go /usr/local/ $ go version go version go1.13.6 linux/amd64 从 Go 1.11 版本开始，Go 提供了 Go Modules 的机制，推荐设置以下环境变量，第三方包的下载将通过国内镜像，避免出现官方网址被屏蔽的问题。 $ go env -w GOPROXY=https://goproxy.cn,direct 或在 ~/.profile 中设置环境变量 export GOPROXY=https://goproxy.cn ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:1:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"基本结构 package main import \"fmt\" func main() { fmt.Println(\"Hello World!\") } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:2:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"运行 执行go run main.go 或 go run .，将会输出 $ go run . Hello World! go run main.go，其实是 2 步： go build main.go：编译成二进制可执行程序 ./main：执行该程序 如果强制启用了 Go Modules 机制，即环境变量中设置了 GO111MODULE=on，则需要先初始化模块 go mod init hello 否则会报错误：go: cannot find main module; see ‘go help modules’ 或者直接编译生成可执行文件 go build main.go # or go build -o hello.exe ./main.go # 指定可执行文件名 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:2:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"基本结构 package main：声明了 main.go 所在的包，Go 语言中使用包来组织代码。一般一个文件夹即一个包，包内可以暴露类型或方法供其他包使用。 import “fmt”：fmt 是 Go 语言的一个标准库/包，用来处理标准输入输出。 func main：main 函数是整个程序的入口，main 函数所在的包名也必须为 main。 fmt.Println(“Hello World!”)：调用 fmt 包的 Println 方法，打印出 “Hello World!” ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:2:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"一些命令 go build 这个命令主要用于编译代码。在包的编译过程中，若有必要，会同时编译与之相关联的包。 如果是普通应用包，执行后不会产生任何文件。如果你需要在 $GOPATH/pkg下生成相应的文件，那就得执行 go install。 如果是 main 包，执行后会在当前目录下生成一个可执行文件。如果你需要在 $GOPATH/bin 下生成相应的文件，需要执行 go install，或者使用 go build -o 路径/a.exe。 如果某个项目文件夹下有多个文件，而你只想编译某个文件，就可在go build之后加上文件名，例如go build a.go；go build 命令默认会编译当前目录下的所有go文件。 你也可以指定编译输出的文件名。 例如 go build -o hello.exe ./main.go go build 会忽略目录下以 “_” 或 “.” 开头的 go 文件。 如果你的源代码针对不同的操作系统需要不同的处理，那么你可以根据不同的操作系统后缀来命名文件。例如有一个读取数组的程序，它对于不同的操作系统可能有如下几个源文件： array_linux.go, array_darwin.go, array_windows.go, array_freebsd.go go build 的时候会选择性地编译以系统名结尾的文件（Linux、Darwin、Windows、Freebsd）。例如Linux 系统下面编译只会选择 array_linux.go 文件，其它系统命名后缀文件全部忽略。 参数 -o 指定输出的文件名，可以带上路径，例如 go build -o a/b/c -i 安装相应的包，编译+go install -a 更新全部已经是最新的包的，但是对标准包不适用 -n 把需要执行的编译命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -p n 指定可以并行可运行的编译数目，默认是CPU数目 -race 开启编译的时候自动检测数据竞争的情况，目前只支持64位的机器 -v 打印出来我们正在编译的包名 -work 打印出来编译时候的临时文件夹名称，并且如果已经存在的话就不要删除 -x 打印出来执行的命令，其实就是和-n的结果类似，只是这个会执行 -ccflags 'arg list' 传递参数给5c, 6c, 8c 调用 -compiler name 指定相应的编译器，gccgo还是gc -gccgoflags 'arg list' 传递参数给gccgo编译连接调用 -gcflags 'arg list' 传递参数给5g, 6g, 8g 调用 -installsuffix suffix 为了和默认的安装包区别开来，采用这个前缀来重新安装那些依赖的包，-race的时候默认已经是-installsuffix race,大家可以通过-n命令来验证 -ldflags 'flag list' 传递参数给 5l, 6l, 8l 调用 -tags 'tag list' 设置在编译的时候可以适配的那些 tag go clean 移除当前源码包和关联源码包里面编译生成的文件。这些文件包括 _obj/ 旧的object目录，由Makefiles遗留 _test/ 旧的test目录，由Makefiles遗留 _testmain.go 旧的gotest文件，由Makefiles遗留 test.out 旧的test记录，由Makefiles遗留 build.out 旧的test记录，由Makefiles遗留 *.[568ao] object文件，由Makefiles遗留 DIR(.exe) 由go build产生 DIR.test(.exe) 由go test -c产生 MAINFILE(.exe) 由go build MAINFILE.go产生 *.so 由 SWIG 产生 可以利用这个命令清除编译文件，然后 git 递交源码，在本机测试的时候这些编译文件都是和系统相关的，但是对于源码管理来说没必要。 $ go clean -i -n cd /Users/astaxie/develop/gopath/src/mathapp rm -f mathapp mathapp.exe mathapp.test mathapp.test.exe app app.exe rm -f /Users/astaxie/develop/gopath/bin/mathapp 参数 -i 清除关联的安装的包和可运行文件，也就是通过 go install 安装的文件 -n 把需要执行的清除命令打印出来，但是不执行，这样就可以很容易的知道底层是如何运行的 -r 循环的清除在 import 中引入的包 -x 打印出来执行的详细命令，其实就是 -n 打印的执行版本 go get 这个命令是用来动态获取远程代码包的，目前支持的有 BitBucket、GitHub、Google Code 和 Launchpad。 这个命令在内部实际上分成了两步操作 下载源码包 执行 go install 下载源码包的 go 工具会自动根据不同的域名调用不同的源码工具，对应关系如下： BitBucket (Mercurial Git) GitHub (Git) Google Code Project Hosting (Git, Mercurial, Subversion) Launchpad (Bazaar) 所以为了 go get 能正常工作，你必须确保安装了合适的源码管理工具，并同时把这些命令加入你的 PATH 中。 参数 -d 只下载不安装 -f 只有在你包含了 -u 参数的时候才有效，不让 -u 去验证 import 中的每一个都已经获取了，这对于本地fork 的包特别有用 -fix 在获取源码之后先运行 fix，然后再去做其他的事情 -t 同时也下载需要为运行测试所需要的包 -u 强制使用网络去更新包和它的依赖包 -v 显示执行的命令 go install 这个命令在内部实际上分成了两步操作：第一步是生成结果文件(可执行文件或者 .a 包)，第二步会把编译好的结果移到 $GOPATH/pkg 或者 $GOPATH/bin。 参数支持 go build 的编译参数。只要记住一个参数 -v 就好了，这个随时随地的可以查看底层的执行信息。 go test 执行这个命令，会自动读取源码目录下面名为 *_test.go 的文件，生成并运行测试用的可执行文件。 输出的信息类似 ok archive/tar 0.011s FAIL archive/zip 0.022s ok compress/gzip 0.033s ... 默认的情况下，不需要任何的参数，它会自动把你源码包下面所有 test 文件测试完毕 参数 -bench regexp 执行相应的 benchmarks，例如 -bench=. -cover 开启测试覆盖率 -run regexp 只运行 regexp 匹配的函数，例如 -run=Array 那么就执行包含有 Array 开头的函数 -v 显示测试的详细命令 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:2:3","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"项目 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:3:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"GOPATH go 命令依赖一个重要的环境变量：$GOPATH Windows 系统中环境变量的形式为 %GOPATH% GOPATH 允许多个目录，当有多个目录时，请注意分隔符，Windows 是分号，Linux 是冒号，当有多个 GOPATH 时，默认会将 go get 的内容放在第一个目录下 $GOPATH 目录有三个子目录： src 存放源代码（比如：.go .c .h .s等） pkg 编译后生成的文件（比如：.a） bin 编译后生成的可执行文件 GOPATH 下的 src 目录就是接下来开发程序的主要目录，所有的源码都是放在这个目录下面。一般情况下，一个文件夹就是一个项目 例如: $GOPATH/src/mymath 表示 mymath 是个应用包或者可执行应用（根据 package 是 main 还是其他来决定，main 的话就是可执行应用） 允许多级目录，例如在 src 下面新建了目录 $GOPATH/src/github.com/astaxie/beedb 那么这个包路径就是 “github.com/astaxie/beedb”，包名称是最后一个目录 beedb 文件结构举例 bin/ mathapp pkg/ 平台名/ 如：darwin_amd64、linux_amd64 mymath.a github.com/ astaxie/ beedb.a src/ mathapp main.go mymath/ sqrt.go github.com/ astaxie/ beedb/ beedb.go util.go 编写应用包例 cd $GOPATH/src mkdir mymath 新建文件 sqrt.go，内容如下 // $GOPATH/src/mymath/sqrt.go源码如下： package mymath func Sqrt(x float64) float64 { z := 0.0 for i := 0; i \u003c 1000; i++ { z -= (z*z - x) / (2 * x) } return z } 这样 sqrt 应用包目录和代码已经新建完毕 建议 package 的名称和目录名保持一致 编译安装应用包 在任意的目录执行 go install [pkg_name] 进入对应的应用包目录，然后执行 go install，即完成对应应用包的安装 在 pkg 目录可以看到安装好的应用包（.a 结尾） 编译程序 进入该应用目录，然后执行 go build，将在此目录下生成一个同名可执行文件 进入该目录，执行 go install，将在 $GOPATH/bin/ 下生成一个同名可执行文件 在命令行输入同名就能运行 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:3:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"Go Module 基本操作 初始化 go mod init [module 名称] 检测和清理依赖 go mod tidy 执行 go run XX.go 第一次执行时，go mod 会自动查找依赖自动下载 go module 安装 package 的原則是先拉最新的 release tag，若无tag则拉最新的commit go 会自动生成一个 go.sum 文件来记录 dependency tree 安装指定包 go get -v github.com/go-ego/gse@v0.60.0-rc4.2 检查可以升级的 package go list -m -u all 下载依赖文件 go mod download 更新依赖 go get -u 更新指定包依赖: go get -u github.com/go-ego/gse 指定版本: go get -u github/com/go-ego/gse@v0.60.0-rc4.2 替换无法直接获取的 pkg modules 可以通过在 go.mod 文件中使用 replace 指令替换成github上对应的库，比如： replace ( golang.org/x/crypto v0.0.0-20190313024323-a1f597ede03a =\u003e github.com/golang/crypto v0.0.0-20190313024323-a1f597ede03a ) 使用七牛的镜像源 go env -w GOPROXY=https://goproxy.cn ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:3:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"数据类型 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"变量 Variable Go 语言是静态类型的，变量声明时必须明确变量的类型。 Go 语言的类型在变量后面。 var a int // 如果没有赋值，默认为0 var a int = 1 // 声明时赋值 var a = 1 // 声明时赋值 var a = 1，因为 1 是 int 类型的，所以赋值时，a 自动被确定为 int 类型，所以类型名可以省略不写，这种方式还有一种更简单的表达： a := 1 msg := \"Hello World!\" := 只能用在函数内部；在函数外部使用则会无法编译通过，所以一般用 var 方式来定义全局变量。 _（下划线）是个特殊的变量名，任何赋予它的值都会被丢弃。在这个例子中，我们将值 35 赋予 b，并同时丢弃 34： _, b := 34, 35 Go 对于已声明但未使用的变量会在编译阶段报错 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"常量 常量可定义为数值、布尔值或字符串等类型 const constantName = value //如果需要，也可以明确指定常量的类型： const Pi float32 = 3.1415926 // example const Pi = 3.1415926 const i = 10000 const MaxThread = 10 const prefix = \"astaxie_\" Go 常量和一般程序语言不同的是，可以指定相当多的小数位数 (例如 200 位)， 若指定给 float32 自动缩短为 32bit，指定给 float64 自动缩短为 64bit ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"内置基本类型 Go 支持如下内置基本类型： 一种内置布尔类型：bool。 11 种内置整数类型：int8、uint8、int16、uint16、int32、uint32、int64、uint64、int、uint 和 uintptr。 两种内置浮点数类型：float32 和 float64。 两种内置复数类型：complex64 和 complex128。 一种内置字符串类型：string。 内置类型也称为预声明类型 除了 bool 和 string 类型，其它的 15 种内置基本类型都称为数值类型（整型、浮点数型和复数型）。 Go 中有两种内置类型别名（type alias）： byte 是 uint8的内置别名。 它们是同一个类型。 rune 是 int32的内置别名。 它们是同一个类型。 任一个类型的所有值的尺寸都是相同的，所以一个值的尺寸也常称为它的类型的尺寸。 uintptr、int 以及 uint 类型的值的尺寸依赖于具体编译器实现。 通常地，在 64 位的架构上，int 和 uint 类型的值是 64 位的； 在 32 位的架构上，它们是 32 位的。 编译器必须保证 uintptr 类型的值的尺寸能够存下任意一个内存地址。 一个 complex64 复数值的实部和虚部都是 float32 类型的值。 一个 complex128 复数值的实部和虚部都是 float64 类型的值。 复数的形式为 RE + IMi，其中 RE 是实数部分，IM 是虚数部分，而最后的 i 是虚数单位。下面是一个使用复数的例子： var c complex64 = 5+5i fmt.Printf(\"Value is: %v\", c) //output: (5+5i) 在内存中，所有的浮点数都使用 IEEE-754 格式存储。 从逻辑上说，一个字符串值表示一段文本。 在内存中，一个字符串存储为一个字节序列。 此字节序列体现了此字符串所表示的文本的 UTF-8 编码形式。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:3","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"字符串 //示例代码 var frenchHello string // 声明变量为字符串的一般方法 var emptyString string = \"\" // 声明了一个字符串变量，初始化为空字符串 func test() { no, yes, maybe := \"no\", \"yes\", \"maybe\" // 简短声明，同时声明多个变量 japaneseHello := \"Konichiwa\" // 同上 frenchHello = \"Bonjour\" // 常规赋值 } utf-8 在 Go 语言中，字符串使用 UTF8 编码 UTF8 的好处在于，如果基本是英文，每个字符占 1 byte，和 ASCII 编码是一样的，非常节省空间，如果是中文，一般占 3 字节。包含中文的字符串的处理方式与纯 ASCII 码构成的字符串有点区别。 package main import ( \"fmt\" \"reflect\" ) func main() { str1 := \"Golang\" str2 := \"Go语言\" fmt.Println(reflect.TypeOf(str2[2]).Kind()) // uint8 fmt.Println(str1[2], string(str1[2])) // 108 l fmt.Printf(\"%d %c\\n\", str2[2], str2[2]) // 232 è fmt.Println(\"len(str2)：\", len(str2)) // len(str2)： 8 } reflect.TypeOf().Kind() 可以知道某个变量的类型，我们可以看到，字符串是以 byte 数组形式保存的，类型是 uint8，占 1 个 byte，打印时需要用 string 进行类型转换，否则打印的是编码值。 因为字符串是以 byte 数组的形式存储的，所以，str2[2] 的值并不等于 语。str2 的长度 len(str2) 也不是 4，而是 8（ Go 占 2 byte，语言 占 6 byte）。 特性 使用 + 操作符来连接两个字符串： s := \"hello,\" m := \" world\" a := s + m fmt.Printf(\"%s\\n\", a) 修改字符串也可写为： s := \"hello\" s = \"c\" + s[1:] // 字符串虽不能更改，但可进行切片操作 fmt.Printf(\"%s\\n\", s) 使用反引号来声明多行字符串（没有字符转义） m := `hello world` 处理中文 正确的处理方式是将 string 转为 rune 数组 package main import ( \"fmt\" \"unicode/utf8\" ) func main() { var str = \"hello 你好\" //golang中string底层是通过byte数组实现的，座椅直接求len 实际是在按字节长度计算 所以一个汉字占3个字节算了3个长度 fmt.Println(\"len(str):\", len(str)) //以下两种都可以得到str的字符串长度 //golang中的unicode/utf8包提供了用utf-8获取长度的方法 fmt.Println(\"RuneCountInString:\", utf8.RuneCountInString(str)) //通过rune类型处理unicode字符 fmt.Println(\"rune:\", len([]rune(str))) } 转换成 []rune 类型后，字符串中的每个字符，无论占多少个字节都用 int32 来表示，因而可以正确处理中文。 byte 表示一个字节，可以表示英文字符等占用一个字节的字符，占用多于一个字节的字符就无法正确表示，例如占用 3 个字节的汉字 rune 表示一个字符，用来表示任何一个字符 修改字符串 在Go中字符串是不可变的，如果真的想要改： s := \"hello\" c := []byte(s) // 将字符串 s 转换为 []byte 类型 c[0] = 'c' s2 := string(c) // 再转换回 string 类型 fmt.Printf(\"%s\\n\", s2) // or s := \"hello\" s = \"c\" + s[1:] // 字符串虽不能更改，但可进行切片操作 fmt.Printf(\"%s\\n\", s) ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:4","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"错误类型 Go 内置有一个 error 类型，专门用来处理错误信息，Go 的 package 里面还专门有一个包 errors 来处理错误： err := errors.New(\"emit macho dwarf: elf header corrupted\") if err != nil { fmt.Print(err) } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:5","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"数据类型之间的转换 转换数据类型的方式很简单。 valueOfTypeB = typeB(valueOfTypeA) 例如： // 浮点数 a := 5.0 // 转换为int类型 b := int(a) Go允许在底层结构相同的两个类型之间互转。例如： // IT类型的底层是int类型 type IT int // a的类型为IT，底层是int var a IT = 5 // 将a(IT)转换为int，b现在是int类型 b := int(5) // 将b(int)转换为IT，c现在是IT类型 c := IT(b) 但注意： 不是所有数据类型都能转换的，例如字母格式的 string 类型 “abcd” 转换为 int 肯定会失败 低精度转换为高精度时是安全的，高精度的值转换为低精度时会丢失精度。例如 int32 转换为 int16，float32 转换为 int 这种简单的转换方式不能对 int(float) 和 string 进行互转，要跨大类型转换，可以使用 strconv 包提供的函数 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:6","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"数组 array var arr [n]type 声明数组 var arr [5]int // 一维 var arr2 [5][5]int // 二维 var arr = [5]int{1, 2, 3, 4, 5} // 声明时初始化 使用 := 声明 a := [3]int{1, 2, 3} b := [10]int{1, 2, 3} // 前三个元素初始化为1、2、3，其它默认为0 c := [...]int{4, 5, 6} // 可以省略长度而采用`...`的方式，Go会自动根据元素个数来计算长度 声明嵌套数组 // 声明了一个二维数组，该数组以两个数组作为元素，其中每个数组中又有4个int类型的元素 doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}} // 上面的声明可以简化，直接忽略内部的类型 easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}} 使用 [] 索引/修改数组 arr := [5]int{1, 2, 3, 4, 5} for i := 0; i \u003c len(arr); i++ { arr[i] += 100 } fmt.Println(arr) // [101 102 103 104 105] 由于长度也是数组类型的一部分，因此 [3]int 与 [4]int 是不同的类型，数组也就不能改变长度。 数组之间的赋值是值的赋值，即当把一个数组作为参数传入函数的时候，传入的其实是该数组的副本，而不是它的指针。要传指针得使用 slice ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:7","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"切片 slice 数组的长度不能改变，如果想拼接 2 个数组，或是获取子数组，需要使用切片 Go 和 Python 的切片在底层实现上完全不同 python 的切片产生的是新的对象，对新对象的成员的操作不影响旧对象； go 的切片产生的是旧对象一部分的引用，对其成员的操作会影响旧对象。 这其实也体现了脚本语言和编译语言的不同。虽然两个语言都有类似的切片操作；但是 python 主要目标是方便；go 主要目标却是快速（并弥补丢弃指针运算的缺陷） 性质 切片是数组的抽象。 切片使用数组作为底层结构。 切片包含三个组件 容量：slice 开始位置到数组的最后位置的长度，也叫最大长度 长度：slice 的长度 指向底层数组的指针：指向数组中 slice 指定的开始位置 切片可以随时进行扩展 slice 并不是真正意义上的动态数组，而是一个引用类型。slice 总是指向一个底层 array 声明 声明切片和 array 一样，只是不需要指定长度 // 普通声明 var fslice []int // 声明并初始化 slice := []byte {'a', 'b', 'c', 'd'} // 从一个数组或一个已经存在的slice中再次声明 var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'} a := ar[2:5] 或者使用 make() 创建切片 slice1 := make([]float32, 0) // 长度为0的切片 slice2 := make([]float32, 3, 5) // [0 0 0] 长度为3容量为5的切片 fmt.Println(len(slice2), cap(slice2)) // 3 5 从 Go1.2 开始 slice 支持三个参数的声明 var array [10]int slice := array[2:4] // 一般声明方法, cap=8 slice = array[2:4:7] //使用三个参数声明, cap=7-2 使用 使用切片： // 添加元素，切片容量可以根据需要自动扩展 slice2 = append(slice2, 1, 2, 3, 4) // [0, 0, 0, 1, 2, 3, 4] fmt.Println(len(slice2), cap(slice2)) // 7 12 // 子切片 [start, end) sub1 := slice2[3:] // [1 2 3 4] sub2 := slice2[:3] // [0 0 0] sub3 := slice2[1:4] // [0 0 1] // 合并切片 combined := append(sub1, sub2...) // [1, 2, 3, 4, 0, 0, 0] 声明切片时可以为切片设置容量大小，为切片预分配空间。 在实际使用的过程中，如果容量不够，切片容量会自动扩展。 sub2... 是切片解构的写法，将切片解构为 N 个独立的元素。 内置函数 len()：获取 slice 的长度 cap()：获取 slice 的最大容量 append()：向 slice 里面追加一个或者多个元素，然后返回一个和 slice 一样类型的 slice copy()：函数 copy 从源 slice 的 src 中复制元素到目标 dst，并且返回复制的元素的个数 append 函数会改变 slice 所引用的数组的内容，从而影响到引用同一数组的其它 slice。 但当 slice 中没有剩余空间（即 (cap-len) == 0）时，此时将动态分配新的数组空间。返回的 slice 数组指针将指向这个空间，而原数组的内容将保持不变；其它引用此数组的 slice 则不受影响。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:8","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"字典 / 键值对，map map 类似于 java 的 HashMap，Python 的字典 (dict)，是一种存储键值对 (Key-Value) 的数据结构。使用方式和其他语言几乎没有区别。 声明 // 仅声明，这种方式的声明需要在使用之前使用make初始化 var m0 map[string]int // 声明并用make初始化 m1 := make(map[string]int) // 声明时初始化 m2 := map[string]string{ \"Sam\": \"Male\", \"Alice\": \"Female\", } // 赋值/修改 m1[\"Tom\"] = 18 特性 map 是无序的，每次打印出来的 map 都会不一样，它不能通过 index 获取，而必须通过 key 获取 map 的长度不固定，和 slice 一样，也是一种引用类型 内置的 len 函数将返回 map 拥有的 key 的数量 map 和其他基本型别不同，它不是 thread-safe，在多个 go-routine 存取时，必须使用 mutex lock 机制 因为 map 也是一种引用类型，如果两个 map 同时指向一个底层，那么一个改变，另一个也相应的改变： m := make(map[string]string) m[\"Hello\"] = \"Bonjour\" m1 := m m1[\"Hello\"] = \"Salut\" // 现在m[\"hello\"]的值已经是Salut了 删除 // 初始化一个字典 rating := map[string]float32{\"C\":5, \"Go\":4.5, \"Python\":4.5, \"C++\":2 } // map有两个返回值，第二个返回值，如果不存在key，那么ok为false，如果存在ok为true csharpRating, ok := rating[\"C#\"] if ok { fmt.Println(\"C# is in the map and its rating is \", csharpRating) } else { fmt.Println(\"We have no rating associated with C# in the map\") } delete(rating, \"C\") // 删除key为C的元素 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:9","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"make, new 操作 make 用于内建类型（map、slice 和 channel）的内存分配。new 用于各种类型的内存分配。 内建函数 new 本质上说跟其它语言中的同名函数功能一样：new(T) 分配了零值填充的 T 类型的内存空间，并且返回其地址，即一个 *T 类型的值。用 Go 的术语说，它返回了一个指针，指向新分配的类型 T 的零值。 一言以蔽之：new 返回指针。 内建函数 make(T, args) 与 new(T) 有着不同的功能，make 只能创建 slice、map 和 channel，并且返回一个有初始值(非零)的 T 类型，而不是 *T。 本质来讲，导致这三个类型有所不同的原因是指向数据结构的引用在使用前必须被初始化。例如，一个 slice，是一个包含指向数据（内部 array）的指针、长度和容量的三项描述符；在这些项目被初始化之前，slice 为nil。对于 slice、map 和 channel 来说，make 初始化了内部的数据结构，填充适当的值。 一言以蔽之：make 返回初始化后的（非零）值。 下面这个图详细的解释了 new 和 make 之间的区别。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:10","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"零值 关于“零值”，所指并非是空值，而是一种“变量未填充前”的默认值，通常为 0。 此处罗列部分类型的“零值” int 0 int8 0 int32 0 int64 0 uint 0x0 rune 0 //rune的实际类型是 int32 byte 0x0 // byte的实际类型是 uint8 float32 0 //长度为 4 byte float64 0 //长度为 8 byte bool false string \"\" 布尔类型的零值（初始值）为 false，数值类型的零值为 0，字符串类型的零值为空字符串\"\"，而指针、切片、映射、通道、函数和接口的零值则是 nil。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:11","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"指针 pointer 指针即某个值的地址，类型定义时使用符号 *，对一个已经存在的变量，使用 \u0026 获取该变量的地址。 str := \"Golang\" var p *string = \u0026str // p 是指向 str 的指针 *p = \"Hello\" fmt.Println(str) // Hello 修改了 p，str 的值也发生了改变 一般来说，指针通常在函数传递参数，或者给某个类型定义新的方法时使用。 Go 语言中，参数是按值传递的，如果不使用指针，函数内部将会拷贝一份参数的副本，对参数的修改并不会影响到外部变量的值。如果参数使用指针，对参数的传递将会影响到外部变量。 例如： func add(num int) { num += 1 } func realAdd(num *int) { *num += 1 } func main() { num := 100 add(num) fmt.Println(num) // 100，num 没有变化 realAdd(\u0026num) fmt.Println(num) // 101，指针传递，num 被修改 } 传指针使得多个函数能操作同一个对象。 传指针比较轻量级 (8bytes),只是传内存地址，我们可以用指针传递体积大的结构体。如果用参数值传递的话, 在每次 copy 上面就会花费相对较多的系统开销（内存和时间）。所以当你要传递大的结构体的时候，用指针是一个明智的选择。 Go语言中 channel，slice，map 这三种类型的实现机制类似指针，所以可以直接传递，而不用取地址后传递指针。（注：若函数需改变 slice 的长度，则仍需要取地址传递指针） ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:12","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"位运算 符号 描述 运算规则 \u0026 与 两个位都为 1 时，结果才为 1 | 或 两个位都为 0 时，结果才为 0 ^ 异或 两个位相同为 0，相异为 1 ~ 取反 0 变 1，1 变 0 « 左移 各二进位全部左移若干位，高位丢弃，低位补 0 » 右移 各二进位全部右移若干位，对无符号数，高位补 0，有符号数，各编译器处理方法不一样，有的补符号位（算术右移），有的补 0（逻辑右移） 按位与 清零 如果想将一个单元清零，即使其全部二进制位为 0，只要与一个各位都为零的数值相与，结果为零。 取一个数的指定位 比如取数 X=1010 1110 的低 4 位，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即 Y=0000 1111，然后将 X 与 Y 进行按位与运算（X\u0026Y=0000 1110）即可得到 X 的指定位。 判断奇偶 只要根据最末位是 0 还是 1 来决定，为 0 就是偶数，为 1 就是奇数。 因此可以用 if ((a \u0026 1) == 0) 代替 if (a % 2 == 0) 来判断 a 是不是偶数。 按位或 常用来对一个数据的某些位设置为 1 比如将数 X=1010 1110 的低 4 位设置为 1，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即Y=0000 1111，然后将 X 与 Y 进行按位或运算（X|Y=1010 1111）即可得到。 异或 异或 1 来翻转指定位 比如将数 X=1010 1110 的低 4 位进行翻转，只需要另找一个数 Y，令 Y 的低 4 位为 1，其余位为 0，即Y=0000 1111，然后将 X 与 Y 进行异或运算（X^Y=1010 0001）即可得到。 与 0 相异或值不变 例如：1010 1110 ^ 0000 0000 = 1010 1110 交换两个数 void Swap(int \u0026a, int \u0026b){ if (a != b){ a ^= b; b ^= a; a ^= b; } } 取反 使一个数的最低位为零 使 a 的最低位为 0，可以表示为：a \u0026 ~1。~1 的值为 1111 1111 1111 1110，再按\"与\"运算，最低位一定为 0。 因为\" ~“运算符的优先级比算术运算符、关系运算符、逻辑运算符和其他运算符都高。 左移 每左移一位，相当于该数乘以 2 右移 每右移一位，相当于该数除以 2 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:4:13","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"流程控制 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:5:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"条件语句 if else age := 18 if age \u003c 18 { fmt.Printf(\"Kid\") } else { fmt.Printf(\"Adult\") } // 可以简写为： if age := 18; age \u003c 18 { fmt.Printf(\"Kid\") } else { fmt.Printf(\"Adult\") } 多个条件 if integer == 3 { fmt.Println(\"The integer is equal to 3\") } else if integer \u003c 3 { fmt.Println(\"The integer is less than 3\") } else { fmt.Println(\"The integer is greater than 3\") } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:5:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"goto Go 有 goto 语句——请明智地使用它。用 goto 跳转到必须在当前函数内定义的标签。例如假设这样一个循环： func myFunc() { i := 0 Here: //这行的第一个词，以冒号结束作为标签 println(i) i++ goto Here //跳转到Here去 } 标签名是大小写敏感的。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:5:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"switch type Gender int8 const ( MALE Gender = 1 FEMALE Gender = 2 ) gender := MALE switch gender { case FEMALE: fmt.Println(\"female\") case MALE: fmt.Println(\"male\") default: fmt.Println(\"unknown\") } // male 在这里，使用了type 关键字定义了一个新的类型 Gender。 使用 const 定义了 MALE 和 FEMALE 2 个常量，Go 语言中没有枚举 (enum) 的概念，一般可以用常量的方式来模拟枚举。 和其他语言不同的地方在于，Go 语言的 switch 不需要 break，匹配到某个 case，执行完该 case 定义的行为后，默认不会继续往下执行。如果需要继续往下执行，需要使用 fallthrough，例如： switch gender { case FEMALE: fmt.Println(\"female\") fallthrough case MALE: fmt.Println(\"male\") fallthrough default: fmt.Println(\"unknown\") } // 输出结果 // male // unknown 可以将很多值聚合在一个 case 里 i := 10 switch i { case 1: fmt.Println(\"i is equal to 1\") case 2, 3, 4: fmt.Println(\"i is equal to 2, 3 or 4\") case 10: fmt.Println(\"i is equal to 10\") default: fmt.Println(\"All I know is that i is an integer\") } A type switch compares types instead of values. You can use this to discover the type of an interface value. In this example, the variable t will have the type corresponding to its clause. whatAmI := func(i interface{}) { switch t := i.(type) { case bool: fmt.Println(\"I'm a bool\") case int: fmt.Println(\"I'm an int\") default: fmt.Printf(\"Don't know type %T\\n\", t) } } whatAmI(true) whatAmI(1) whatAmI(\"hey\") ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:5:3","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"for 循环 一个简单的累加的例子，break 和 continue 的用法与其他语言没有区别。 sum := 0 for i := 0; i \u003c 10; i++ { if sum \u003e 50 { break } sum += i } 当忽略 expression1 和 expression3 时，; 可以省略 sum := 1 for ; sum \u003c 1000; { sum += sum } // 冒号可以省略 sum := 1 for sum \u003c 1000 { sum += sum } break 和 continue 还可以跟着标号，用来跳到多重循环中的外层循环 对数组 (arr)、切片 (slice)、字典 (map) 可以使用 for range 遍历： nums := []int{10, 20, 30, 40} for i, num := range nums { fmt.Println(i, num) } // 0 10 // 1 20 // 2 30 // 3 40 m2 := map[string]string{ \"Sam\": \"Male\", \"Alice\": \"Female\", } for key, value := range m2 { fmt.Println(key, value) } // Sam Male // Alice Female ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:5:4","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"函数 functions ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"参数与返回值 一个典型的函数定义如下，使用关键字 func，参数可以有多个，返回值也支持有多个。特别地，package main 中的 func main() 约定为可执行程序的入口。 func funcName(param1 Type1, param2 Type2, ...) (return1 Type3, ...) { // body return value1, value2 } 例如，实现2个数的加法（一个返回值）和除法（多个返回值）： func add(num1 int, num2 int) int { return num1 + num2 } func div(num1 int, num2 int) (int, int) { return num1 / num2, num1 % num2 } func main() { quo, rem := div(100, 17) fmt.Println(quo, rem) // 5 15 fmt.Println(add(100, 17)) // 117 } 也可以给返回值命名，简化 return，例如 add 函数可以改写为 func add(num1 int, num2 int) (ans int) { ans = num1 + num2 return } 不建议这样做，虽然使得代码更加简洁了，但是会造成生成的文档可读性差 函数参数的类型默认为离它最近的类型 func max(a, b int) int { if a \u003e b { return a } return b } 上述代码中，max 函数有两个参数，它们的类型都是 int，那么第一个变量的类型就可以省略（即 a,b int, 而非 a int, b int) ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"变参 ... Go 函数支持变参。接受变参的函数是有着不定数量的参数的。为了做到这点，首先需要定义函数使其接受变参： func myfunc(arg ...int) {} arg ...int 告诉 Go 这个函数接受不定数量的参数。注意，这些参数的类型全部是 int。在函数体中，变量arg 是一个 int 的 slice： for _, n := range arg { fmt.Printf(\"And the number is: %d\\n\", n) } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"延迟语句 defer Go 语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个 defer 语句。 当函数执行到最后时，这些 defer 语句会按照逆序执行（栈），最后该函数返回。 即：先执行 defer，后返回 特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。 如下代码所示，我们一般写打开一个资源是这样操作的： func ReadWrite() bool { file.Open(\"file\") // 做一些工作 if failureX { file.Close() return false } if failureY { file.Close() return false } file.Close() return true } 我们看到上面有很多重复的代码，Go 的 defer 有效解决了这个问题。使用它后，不但代码量减少了很多，而且程序变得更优雅。在 defer 后指定的函数会在函数退出前调用。 func ReadWrite() bool { file.Open(\"file\") defer file.Close() if failureX { return false } if failureY { return false } return true } 如果有很多调用 defer，那么 defer 是采用后进先出模式，所以如下代码会输出4 3 2 1 0 for i := 0; i \u003c 5; i++ { defer fmt.Printf(\"%d \", i) } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:3","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"函数作为值、类型 在 Go 中函数也是一种变量，我们可以通过 type 来定义它，它的类型就是所有拥有相同的参数，相同的返回值的一种类型 type typeName func(input1 inputType1 , input2 inputType2 [, ...]) (result1 resultType1 [, ...]) 将函数作为类型后，可以把这个类型的函数当做值来传递 package main import \"fmt\" type testInt func(int) bool // 声明了一个函数类型 func isOdd(integer int) bool { if integer%2 == 0 { return false } return true } func isEven(integer int) bool { if integer%2 == 0 { return true } return false } // 声明的函数类型在这个地方当做了一个参数 func filter(slice []int, f testInt) []int { var result []int for _, value := range slice { if f(value) { result = append(result, value) } } return result } func main(){ slice := []int {1, 2, 3, 4, 5, 7} fmt.Println(\"slice = \", slice) odd := filter(slice, isOdd) // 函数当做值来传递了 fmt.Println(\"Odd elements of slice are: \", odd) even := filter(slice, isEven) // 函数当做值来传递了 fmt.Println(\"Even elements of slice are: \", even) } 函数当做值和类型在我们写一些通用接口的时候非常有用 上面例子中 testInt 类型是一个函数类型，然后两个 filter 函数的参数和返回值与 testInt 类型是一样的，但是我们可以实现很多种的逻辑，这样使得我们的程序变得非常的灵活。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:4","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"闭包 Closures Go supports anonymous functions, which can form closures. Anonymous functions are useful when you want to define a function inline without having to name it. package main import \"fmt\" func intSeq() func() int { i := 0 return func() int { i++ return i } } func main() { nextInt := intSeq() fmt.Println(nextInt()) fmt.Println(nextInt()) fmt.Println(nextInt()) newInts := intSeq() fmt.Println(newInts()) } /* output: * 1 * 2 * 3 * 1 This function intSeq returns another function, which we define anonymously in the body of intSeq. The returned function closes over the variable i to form a closure. We call intSeq, assigning the result (a function) to nextInt. This function value captures its own i value, which will be updated each time we call nextInt. ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:5","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"错误处理 error handling 如果函数实现过程中，如果出现不能处理的错误，可以返回给调用者处理。比如我们调用标准库函数os.Open读取文件，os.Open 有2个返回值，第一个是 *File，第二个是 error， 如果调用成功，error 的值是 nil，如果调用失败，例如文件不存在，我们可以通过 error 知道具体的错误信息。 import ( \"fmt\" \"os\" ) func main() { _, err := os.Open(\"filename.txt\") if err != nil { fmt.Println(err) } } // open filename.txt: no such file or directory 可以通过 errorw.New 返回自定义的错误 import ( \"errors\" \"fmt\" ) func hello(name string) error { if len(name) == 0 { return errors.New(\"error: name is null\") } fmt.Println(\"Hello,\", name) return nil } func main() { if err := hello(\"\"); err != nil { fmt.Println(err) } } // error: name is null panic 和 recover error 往往是能预知的错误，但是也可能出现一些不可预知的错误，例如数组越界，这种错误可能会导致程序非正常退出，在 Go 语言中称之为 panic。 Panic 它是一个内建函数，可以中断原有的控制流程，进入一个 panic 状态中。 当函数 F 调用 panic，函数的执行被中断，但是 F 中的延迟函数 defer 会正常执行，然后 F 返回到调用它的地方。 在调用的地方，F 的行为就像调用了 panic。这一过程继续向上，直到发生 panic 的 goroutine 中所有调用的函数返回，此时程序退出。 panic 可以直接调用 panic 产生。也可以由运行时错误产生，例如访问越界的数组。 Recover 它是一个内建的函数，可以让进入 panic 状态的 goroutine 恢复过来。 recover 仅在延迟函数 defer 中有效。 在正常的执行过程中，调用 recover 会返回 nil，并且没有其它任何效果。 如果当前的 goroutine 陷入 panic 状态，调用 recover 可以捕获到 panic 的输入值，并且恢复正常的执行。 例一：下面这个函数演示了如何在过程中使用 panic var user = os.Getenv(\"USER\") func init() { if user == \"\" { panic(\"no value for $USER\") } } 下面这个函数检查作为其参数的函数在执行时是否会产生 panic： func throwsPanic(f func()) (b bool) { defer func() { if x := recover(); x != nil { b = true } }() f() //执行函数f，如果f中出现了panic，那么就可以恢复回来 return } 例二：数组越界的情况 func get(index int) int { arr := [3]int{2, 3, 4} return arr[index] } func main() { fmt.Println(get(5)) fmt.Println(\"finished\") } $ go run . panic: runtime error: index out of range [5] with length 3 goroutine 1 [running]: exit status 2 使用 panic 和 recover 来捕获错误 func get(index int) (ret int) { defer func() { if r := recover(); r != nil { fmt.Println(\"Some error happened!\", r) ret = -1 } }() arr := [3]int{2, 3, 4} return arr[index] } func main() { fmt.Println(get(5)) fmt.Println(\"finished\") } $ go run . Some error happened! runtime error: index out of range [5] with length 3 -1 finished 在 get 函数中，使用 defer 定义了异常处理的函数，在协程退出前，会执行完 defer 挂载的任务。因此如果触发了 panic，控制权就交给了 defer。 在 defer 的处理逻辑中，使用 recover，使程序恢复正常，并且将返回值设置为 -1，在这里也可以不处理返回值，如果不处理返回值，返回值将被置为默认值 0。 应当在关键的时刻使用 panic 和 recover，而不能滥用 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:6","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"main 函数和 init 函数 Go 里面有两个保留的函数：init 函数（能够应用于所有的 package）和 main 函数（只能应用于 package main）。这两个函数在定义时不能有任何的参数和返回值。 每个 package 中的 init 函数都是可选的，但 package main 必须包含一个 main 函数。 虽然一个 package 里面可以写任意多个 init 函数，但无论是对于可读性还是以后的可维护性来说，建议只写一个 init 函数。 Go 程序会自动调用 init() 和 main()，你不需要在任何地方调用这两个函数。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:7","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"程序的初始化过程 程序的初始化和执行都起始于 main 包。如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。 有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到 fmt 包，但它只会被导入一次，因为没有必要导入多次）。 当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行 init 函数（如果有的话），依次类推。 等所有被导入的包都加载完毕了，就会开始对 main 包中的包级常量和变量进行初始化，然后执行 main 包中的 init 函数（如果存在的话），最后执行 main 函数。下图详细地解释了整个执行过程： ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:8","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"import 点操作 import( . \"fmt\" ) 点操作允许使用省略前缀的包名 别名操作 import( f \"fmt\" ) 别名操作允许使用别名来使用包 _ 操作 import ( \"database/sql\" _ \"github.com/ziutek/mymysql/godrv\" ) _ 操作引入了包，而不直接使用包里面的函数，而是调用了该包里面的 init 函数 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:6:9","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"结构体，方法和接口 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"结构体 struct package main import \"fmt\" // 声明一个新的类型 type person struct { name string age int } // 比较两个人的年龄，返回年龄大的那个人，并且返回年龄差 // struct也是传值的 func Older(p1, p2 person) (person, int) { if p1.age\u003ep2.age { // 比较p1和p2这两个人的年龄 return p1, p1.age-p2.age } return p2, p2.age-p1.age } func main() { // 赋值初始化 var tom person tom.name, tom.age = \"Tom\", 18 // 两个字段都写清楚的初始化 bob := person{age:25, name:\"Bob\"} // 按照struct定义顺序初始化值 paul := person{\"Paul\", 43} // 当然也可以通过new函数分配一个指针，此处P的类型为*person // P := new(person) tb_Older, tb_diff := Older(tom, bob) tp_Older, tp_diff := Older(tom, paul) bp_Older, bp_diff := Older(bob, paul) fmt.Printf(\"Of %s and %s, %s is older by %d years\\n\", tom.name, bob.name, tb_Older.name, tb_diff) fmt.Printf(\"Of %s and %s, %s is older by %d years\\n\", tom.name, paul.name, tp_Older.name, tp_diff) fmt.Printf(\"Of %s and %s, %s is older by %d years\\n\", bob.name, paul.name, bp_Older.name, bp_diff) } 匿名字段 Go 语言支持只提供类型，而不写字段名的方式，也就是匿名字段，或称为嵌入字段。 当匿名字段是一个 struct 的时候，那么这个 struct 所拥有的全部字段以及方法都被隐式地引入了当前定义的这个 struct package main import \"fmt\" type Human struct { name string age int weight int } type Student struct { Human // 匿名字段，那么默认Student就包含了Human的所有字段 speciality string } func main() { // 初始化一个学生 mark := Student{Human{\"Mark\", 25, 120}, \"Computer Science\"} // 访问相应的字段 fmt.Println(\"His name is \", mark.name) fmt.Println(\"His age is \", mark.age) fmt.Println(\"His weight is \", mark.weight) fmt.Println(\"His speciality is \", mark.speciality) // 修改对应的备注信息 mark.speciality = \"AI\" fmt.Println(\"Mark changed his speciality\") fmt.Println(\"His speciality is \", mark.speciality) // 修改其年龄信息 fmt.Println(\"Mark become old\") mark.age = 46 fmt.Println(\"His age is\", mark.age) // 修改其体重信息 fmt.Println(\"Mark is not an athlet anymore\") mark.weight += 60 fmt.Println(\"His weight is\", mark.weight) } 匿名字段能够实现字段的继承 student 还能访问 Human 这个字段作为字段名。 mark.Human = Human{\"Marcus\", 55, 220} mark.Human.age -= 1 不仅仅是 struct，所有的内置类型和自定义类型都可以作为匿名字段 package main import \"fmt\" type Skills []string type Human struct { name string age int weight int } type Student struct { Human // 匿名字段，struct Skills // 匿名字段，自定义的类型string slice int // 内置类型作为匿名字段 speciality string } func main() { // 初始化学生Jane jane := Student{Human:Human{\"Jane\", 35, 100}, speciality:\"Biology\"} // 访问相应的字段 fmt.Println(\"Her name is \", jane.name) fmt.Println(\"Her age is \", jane.age) fmt.Println(\"Her weight is \", jane.weight) fmt.Println(\"Her speciality is \", jane.speciality) // 修改其skill技能字段 jane.Skills = []string{\"anatomy\"} fmt.Println(\"Her skills are \", jane.Skills) fmt.Println(\"She acquired two new ones \") jane.Skills = append(jane.Skills, \"physics\", \"golang\") fmt.Println(\"Her skills now are \", jane.Skills) // 修改匿名内置类型字段 jane.int = 3 fmt.Println(\"Her preferred number is\", jane.int) } 当存在两个相同的字段时，最外层的优先访问，这就允许我们去重载通过匿名字段继承的一些字段 如果想要访问重载后对应匿名类型里面的字段，可以通过匿名字段名来访问。 package main import \"fmt\" type Human struct { name string age int phone string // Human类型拥有的字段 } type Employee struct { Human // 匿名字段Human speciality string phone string // 雇员的phone字段 } func main() { Bob := Employee{Human{\"Bob\", 34, \"777-444-XXXX\"}, \"Designer\", \"333-222\"} fmt.Println(\"Bob's work phone is:\", Bob.phone) // 如果我们要访问Human的phone字段 fmt.Println(\"Bob's personal phone is:\", Bob.Human.phone) } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"方法 methods func (r ReceiverType) funcName(parameters) (results) “A method is a function with an implicit first argument, called a receiver.” package main import ( \"fmt\" \"math\" ) type Rectangle struct { width, height float64 } type Circle struct { radius float64 } func (r Rectangle) area() float64 { return r.width * r.height } func (c Circle) area() float64 { return c.radius * c.radius * math.Pi } func main() { r1 := Rectangle{12, 2} r2 := Rectangle{9, 4} c1 := Circle{10} c2 := Circle{25} fmt.Println(\"Area of r1 is: \", r1.area()) fmt.Println(\"Area of r2 is: \", r2.area()) fmt.Println(\"Area of c1 is: \", c1.area()) fmt.Println(\"Area of c2 is: \", c2.area()) } method 可以定义在任何你自定义的类型、内置类型、struct 等各种类型上面。 package main import \"fmt\" const( WHITE = iota BLACK BLUE RED YELLOW ) type Color byte type Box struct { width, height, depth float64 color Color } type BoxList []Box //a slice of boxes func (b Box) Volume() float64 { return b.width * b.height * b.depth } func (b *Box) SetColor(c Color) { b.color = c } func (bl BoxList) BiggestColor() Color { v := 0.00 k := Color(WHITE) for _, b := range bl { if bv := b.Volume(); bv \u003e v { v = bv k = b.color } } return k } func (bl BoxList) PaintItBlack() { for i := range bl { bl[i].SetColor(BLACK) } } func (c Color) String() string { strings := []string {\"WHITE\", \"BLACK\", \"BLUE\", \"RED\", \"YELLOW\"} return strings[c] } func main() { boxes := BoxList { Box{4, 4, 4, RED}, Box{10, 10, 1, YELLOW}, Box{1, 1, 20, BLACK}, Box{10, 10, 1, BLUE}, Box{10, 30, 1, WHITE}, Box{20, 20, 20, YELLOW}, } fmt.Printf(\"We have %d boxes in our set\\n\", len(boxes)) fmt.Println(\"The volume of the first one is\", boxes[0].Volume(), \"cm³\") fmt.Println(\"The color of the last one is\",boxes[len(boxes)-1].color.String()) fmt.Println(\"The biggest one is\", boxes.BiggestColor().String()) fmt.Println(\"Let's paint them all black\") boxes.PaintItBlack() fmt.Println(\"The color of the second one is\", boxes[1].color.String()) fmt.Println(\"Obviously, now, the biggest one is\", boxes.BiggestColor().String()) } 值类型调用与指针类型调用 https://learnku.com/docs/effective-go/2020/method/6245 如果一个 method 的 receiver 是 *T，你可以在一个 T 类型的实例变量 V 上面调用这个 method，而不需要 \u0026V 去调用这个 method 如果一个 method 的 receiver 是 T，你可以在一个 *T 类型的变量 P 上面调用这个 method，而不需要 *P 去调用这个method 但是一切结果取决于 receiver 的类型 type Data struct { x int } // 值类型调用 func (u User) NotifyValue() { fmt.Printf(\"%v : %v \\n\", u.Name, u.Email) } // 指针类型调用 func (u *User) NotifyPointer() { fmt.Printf(\"%v : %v \\n\", u.Name, u.Email) } 当接受者不是一个指针时，方法操作对应接受者的值的副本——即使你使用了指针调用函数，但是函数的接受者是值类型，所以函数内部操作还是对副本的操作，而不是指针操作。 func main() { // 值类型调用方法 u1 := User{\"golang\", \"golang@golang.com\"} u1.NotifyValue() //正常 // 指针类型调用方法 u2 := User{\"go\", \"go@go.com\"} u3 := \u0026u2 // 可以简写成 u3 := \u0026User{\"go\", \"go@go.com\"} u3.NotifyValue() //当我们使用指针时，Go 调整和解引用指针使得调用可以被执行 } 同理，当接受者是指针时，即使用值类型调用那么函数内部也是对指针的操作 所以，是值调用还是指针调用，一切取决于接受者的类型 普通函数与方法的区别 对于普通函数，接收者为值类型时，不能将指针类型的数据直接传递，反之亦然。 对于方法（如 struct 的方法），接收者为值类型时，可以直接用指针类型的变量调用方法，反过来同样也可以。 method 继承 如果匿名字段实现了一个 method，那么包含这个匿名字段的 struct 也能调用该 method package main import \"fmt\" type Human struct { name string age int phone string } type Student struct { Human //匿名字段 school string } type Employee struct { Human //匿名字段 company string } //在human上面定义了一个method func (h *Human) SayHi() { fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone) } func main() { mark := Student{Human{\"Mark\", 25, \"222-222-YYYY\"}, \"MIT\"} sam := Employee{Human{\"Sam\", 45, \"111-888-XXXX\"}, \"Golang Inc\"} mark.SayHi() sam.SayHi() } method 重写 可以在Employee上面定义一个method，重写匿名字段的方法 //Employee的method重写Human的method func (e *Employee) SayHi() { fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name, e.company, e.phone) //Yes you can split into 2 lines here. } func main() { mark := Student{Human{\"Mark\", 25, \"222-222-YYYY\"}, \"MIT\"} sam := Employee{Human{\"Sam\", 45, \"111-888-XXXX\"}, \"Golang Inc\"} mark.SayHi() sam.SayHi() } interface 函数参数 interface 的变量可以持有任意实现该 interface 类型的对象，这给我们编写函数 (包括 method ) 提供了一些额外的思考，我们是不是可以通过定义 interface 参数，让函数接受各种类型的参数。 举个例子：fm","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"接口 interfaces 一般而言，接口定义了一组方法的集合，我们通过 interface 来定义对象的一组行为。 如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口 接口不能被实例化 一个类型可以实现多个接口。 type Human struct { name string age int phone string } type Student struct { Human //匿名字段Human school string loan float32 } type Employee struct { Human //匿名字段Human company string money float32 } //Human对象实现Sayhi方法 func (h *Human) SayHi() { fmt.Printf(\"Hi, I am %s you can call me on %s\\n\", h.name, h.phone) } // Human对象实现Sing方法 func (h *Human) Sing(lyrics string) { fmt.Println(\"La la, la la la, la la la la la...\", lyrics) } //Human对象实现Guzzle方法 func (h *Human) Guzzle(beerStein string) { fmt.Println(\"Guzzle Guzzle Guzzle...\", beerStein) } // Employee重载Human的Sayhi方法 func (e *Employee) SayHi() { fmt.Printf(\"Hi, I am %s, I work at %s. Call me on %s\\n\", e.name, e.company, e.phone) //此句可以分成多行 } //Student实现BorrowMoney方法 func (s *Student) BorrowMoney(amount float32) { s.loan += amount // (again and again and...) } //Employee实现SpendSalary方法 func (e *Employee) SpendSalary(amount float32) { e.money -= amount // More vodka please!!! Get me through the day! } // 定义interface type Men interface { SayHi() Sing(lyrics string) Guzzle(beerStein string) } type YoungChap interface { SayHi() Sing(song string) BorrowMoney(amount float32) } type ElderlyGent interface { SayHi() Sing(song string) SpendSalary(amount float32) } 任意的类型都实现了空 interface（我们这样定义：interface{})，也就是包含 0 个方法的 interface。 对象不需要显式地声明实现了哪一个接口，只需要直接实现该接口对应的方法即可。 如果我们定义了一个 interface 的变量，那么这个变量里面可以存实现这个 interface 的任意类型的对象 总而言之，interface 就是一组抽象方法的集合，它必须由其他非 interface 类型来实现，而不能自我实现； Go 通过 interface 实现了 duck-typing：“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子”。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:3","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"空接口 如果定义了一个没有任何方法的空接口，那么这个接口可以表示任意类型，有点类似于 C 语言的 void* 类型。 func main() { // 定义a为空接口 var a interface{} var i int = 5 s := \"Hello world\" // a可以存储任意类型的数值 a = i a = s m := make(map[string]interface{}) m[\"name\"] = \"Tom\" m[\"age\"] = 18 m[\"scores\"] = [3]int{98, 99, 85} fmt.Println(m) // map[age:18 name:Tom scores:[98 99 85]] } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:4","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"类型断言 类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。 value, ok := x.(T) x 表示一个接口的类型，T 表示一个具体的类型（也可为接口类型）。 package main import ( \"fmt\" ) func main() { var x interface{} x = 10 value, ok := x.(int) fmt.Print(value, \",\", ok) } 输出 10,true ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:5","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"泛型 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:7:6","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"并发编程 goroutine 不要通过共享来通信，而要通过通信来共享 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:8:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"sync Go 语言提供了 sync 和 channel 两种方式支持协程 (goroutine) 的并发。 例如我们希望并发下载 N 个资源，多个并发协程之间不需要通信，那么就可以使用 sync.WaitGroup，等待所有并发协程执行结束。 import ( \"fmt\" \"sync\" \"time\" ) var wg sync.WaitGroup func download(url string) { fmt.Println(\"start to download\", url) time.Sleep(time.Second) // 模拟耗时操作 wg.Done() } func main() { for i := 0; i \u003c 3; i++ { wg.Add(1) go download(\"a.com/\" + string(i+'0')) } wg.Wait() fmt.Println(\"Done!\") } wg.Add(1)：为 wg 添加一个计数，wg.Done()，减去一个计数。 go download()：启动新的协程并发执行 download 函数。 wg.Wait()：等待所有的协程执行结束。 $ time go run . start to download a.com/2 start to download a.com/0 start to download a.com/1 Done! real 0m1.563s 可以看到串行需要 3s 的下载操作，并发后，只需要 1s。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:8:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"channel var ch = make(chan string, 10) // 创建大小为 10 的缓冲信道 func download(url string) { fmt.Println(\"start to download\", url) time.Sleep(time.Second) ch \u003c- url // 将 url 发送给信道 } func main() { for i := 0; i \u003c 3; i++ { go download(\"a.com/\" + string(i+'0')) } for i := 0; i \u003c 3; i++ { msg := \u003c-ch // 等待信道返回消息。 fmt.Println(\"finish\", msg) } fmt.Println(\"Done!\") } 使用 channel 信道，可以在协程之间传递消息。阻塞等待并发协程返回消息。 $ time go run . start to download a.com/2 start to download a.com/0 start to download a.com/1 finish a.com/2 finish a.com/1 finish a.com/0 Done! real 0m1.528s ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:8:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"单元测试 (unit test) 假设我们希望测试 package main 下 calc.go 中的函数，要只需要新建 calc_test.go 文件，在 calc_test.go 中新建测试用例即可。 // calc.go package main func add(num1 int, num2 int) int { return num1 + num2 } // calc_test.go package main import \"testing\" func TestAdd(t *testing.T) { if ans := add(1, 2); ans != 3 { t.Error(\"add(1, 2) should be equal to 3\") } } 运行 go test，将自动运行当前 package 下的所有测试用例，如果需要查看详细的信息，可以添加-v参数。 $ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.040s ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:9:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"包 (Package) 和模块 (Modules) ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:10:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"Package 一般来说，一个文件夹可以作为 package，同一个 package 内部变量、类型、方法等定义可以相互看到。 比如我们新建一个文件 calc.go， main.go 平级，分别定义 add 和 main 方法。 // calc.go package main func add(num1 int, num2 int) int { return num1 + num2 } // main.go package main import \"fmt\" func main() { fmt.Println(add(3, 5)) // 8 } 运行 go run main.go，会报错，add 未定义： ./main.go:6:14: undefined: add 因为 go run main.go 仅编译 main.go 一个文件，所以命令需要换成 $ go run main.go calc.go 8 或 $ go run . 8 Go 语言也有 Public 和 Private 的概念，粒度是包。如果类型/接口/方法/函数/字段的首字母大写，则是 Public 的，对其他 package 可见，如果首字母小写，则是 Private 的，对其他 package 不可见。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:10:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"Modules Go Modules 是 Go 1.11 版本之后引入的，Go 1.11 之前使用 $GOPATH 机制。 Go Modules 可以算作是较为完善的包管理工具。同时支持代理，国内也能享受高速的第三方包镜像服务。 Go Modules 在 1.13 版本仍是可选使用的，环境变量 GO111MODULE 的值默认为 AUTO，强制使用 Go Modules 进行依赖管理，可以将 GO111MODULE 设置为 ON。 在一个空文件夹下，初始化一个 Module $ go mod init example go: creating new go.mod: module example 此时，在当前文件夹下生成了go.mod，这个文件记录当前模块的模块名以及所有依赖包的版本。 接着，我们在当前目录下新建文件 main.go，添加如下代码： package main import ( \"fmt\" \"rsc.io/quote\" ) func main() { fmt.Println(quote.Hello()) // Ahoy, world! } 运行 go run .，将会自动触发第三方包 rsc.io/quote的下载，具体的版本信息也记录在了go.mod中： module example go 1.13 require rsc.io/quote v3.1.0+incompatible 我们在当前目录，添加一个子 package calc，代码目录如下： demo/ |--calc/ |--calc.go |--main.go 在 calc.go 中写入 package calc func Add(num1 int, num2 int) int { return num1 + num2 } 在 package main 中如何使用 package cal 中的 Add 函数呢？import 模块名/子目录名 即可，修改后的 main 函数如下： package main import ( \"fmt\" \"example/calc\" \"rsc.io/quote\" ) func main() { fmt.Println(quote.Hello()) fmt.Println(calc.Add(10, 3)) } $ go run . Ahoy, world! 13 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:10:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"一些技巧和特性 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:0","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"零散的特性 Go 的相对路径是相对于执行命令时的目录 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:1","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"分组声明 在Go语言中，同时声明多个常量、变量，或者导入多个包时，可采用分组的方式进行声明。 例如下面的代码： import \"fmt\" import \"os\" const i = 100 const pi = 3.1415 const prefix = \"Go_\" var i int var pi float32 var prefix string 可以分组写成如下形式： import( \"fmt\" \"os\" ) const( i = 100 pi = 3.1415 prefix = \"Go_\" ) var( i int pi float32 prefix string ) ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:2","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"iota 枚举 Go 里面有一个关键字 iota，这个关键字用来声明 enum 的时候采用，它默认开始值是 0，const 中每增加一行加 1 package main import ( \"fmt\" ) const ( x = iota // x == 0 y = iota // y == 1 z = iota // z == 2 w // 常量声明省略值时，默认和之前一个值的字面相同。这里隐式地说w = iota，因此w == 3。其实上面y和z可同样不用\"= iota\" ) const v = iota // 每遇到一个const关键字，iota就会重置，此时v == 0 const ( h, i, j = iota, iota, iota //h=0,i=0,j=0 iota在同一行值相同 ) const ( a = iota // a=0 b = \"B\" c = iota //c=2 d, e, f = iota, iota, iota //d=3,e=3,f=3 g = iota //g = 4 ) func main() { fmt.Println(a, b, c, d, e, f, g, h, i, j, x, y, z, w, v) } 除非被显式设置为其它值或 iota，每个 const 分组的第一个常量被默认设置为它的 0 值，第二及后续的常量被默认设置为它前面那个常量的值，如果前面那个常量的值是 iota，则它也被设置为 iota。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:3","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"变量、函数命名原则 大写字母开头的变量是可导出的，也就是其它包可以读取的，是公有变量；小写字母开头的就是不可导出的，是私有变量。 大写字母开头的函数也是一样，相当于 class 中的带 public 关键词的公有函数；小写字母开头的就是有private 关键词的私有函数。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:4","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"切片中删除元素 Go语言并没有对删除切片元素提供专用的语法或者接口，需要使用切片本身的特性来删除元素，根据要删除元素的位置有三种情况，分别是从开头位置删除、从中间位置删除和从尾部删除，其中删除切片尾部的元素速度最快。 从开头位置删除 删除开头的元素可以直接移动数据指针： a = []int{1, 2, 3}a = a[1:] // 删除开头1个元素 a = a[N:] // 删除开头N个元素 也可以不移动数据指针，但是将后面的数据向开头移动，可以用 append() 原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）： a = []int{1, 2, 3}a = append(a[:0], a[1:]...) // 删除开头1个元素 a = append(a[:0], a[N:]...) // 删除开头N个元素 还可以用 copy() 函数来删除开头的元素： a = []int{1, 2, 3}a = a[:copy(a, a[1:])] // 删除开头1个元素 a = a[:copy(a, a[N:])] // 删除开头N个元素 从中间位置删除 对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用 append() 或 copy() 原地完成： a = []int{1, 2, 3, ...}a = append(a[:i], a[i+1:]...) // 删除中间1个元素 a = append(a[:i], a[i+N:]...) // 删除中间N个元素 a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素 a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素 从尾部删除 a = []int{1, 2, 3} a = a[:len(a)-1] // 删除尾部1个元素 a = a[:len(a)-N] // 删除尾部N个元素 删除开头的元素和删除尾部的元素都可以认为是删除中间元素操作的特殊情况，下面来看一个示例。 示例：删除切片指定位置的元素。 package main import \"fmt\" func main() { seq := []string{\"a\", \"b\", \"c\", \"d\", \"e\"} // 指定删除位置 index := 2 // 查看删除位置之前的元素和之后的元素 fmt.Println(seq[:index], seq[index+1:]) // 将删除点前后的元素连接起来 seq = append(seq[:index], seq[index+1:]...) fmt.Println(seq) } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:5","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"类型选择 switch 也可用于判断接口变量的动态类型。如 类型选择 通过圆括号中的关键字 type 使用类型断言语法。若 switch 在表达式中声明了一个变量，那么该变量的每个子句中都将有该变量对应的类型。在每一个 case 子句中，重复利用该变量名字也是惯常的做法，实际上这是在每一个 case 子句中，分别声明一个拥有相同名字，但类型不同的新变量。 var t interface{} t = functionOfSomeType() switch t := t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T 打印任何类型的 t case bool: fmt.Printf(\"boolean %t\\n\", t) // t 是 bool 类型 case int: fmt.Printf(\"integer %d\\n\", t) // t 是 int 类型 case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t 是 *bool 类型 case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t 是 *int 类型 } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:6","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"判断 map 中是否存在某键 if seconds, ok := timeZone[tz]; ok { return t } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:7","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"init 函数 每个源文件都可以通过定义自己的无参数 init 函数来设置一些必要的状态。 （其实每个文件都可以拥有多个 init 函数。）而它的结束就意味着初始化结束： 只有该包中的所有变量声明都通过它们的初始化器求值后 init 才会被调用， 而包中的变量只有在所有已导入的包都被初始化后才会被求值。 除了那些不能被表示成声明的初始化外，init 函数还常被用在程序真正开始执行前，检验或校正程序的状态。 func init() { if user == \"\" { log.Fatal(\"$USER not set\") } if home == \"\" { home = \"/home/\" + user } if gopath == \"\" { gopath = home + \"/go\" } // gopath 可通过命令行中的 --gopath 标记覆盖掉。 flag.StringVar(\u0026gopath, \"gopath\", gopath, \"override default GOPATH\") } ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:8","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"runtime.Caller() 报告当前 go 程调用栈所执行的函数的文件和行号信息 获取（调用处）上 n 个函数的信息，像一个栈 func Caller(skip int) (pc uintptr, file string, line int, ok bool) 参数 skip：要提升的堆栈帧数，0 当前函数，1 上一层函数 返回值 pc：函数指针 file：函数所在文件名目录 line：所在行号 ok：是否可以获取到信息 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:9","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"使用空白标识符进行接口检查 var _ json.Marshaler = (*RawMessage)(nil) 在此声明中，我们调用了一个 *RawMessage 转换并将其赋予了 Marshaler，以此来要求 *RawMessage 实现 Marshaler，这时其属性就会在编译时被检测。 若 json.Marshaler 接口被更改，此包将无法通过编译， 而我们则会注意到它需要更新。 在这种结构中出现空白标识符，即表示该声明的存在只是为了类型检查。 不过请不要为满足接口就将它用于任何类型。作为约定， 只有当代码中不存在静态类型转换时才能使用这种声明，毕竟这是种非常罕见的情况。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:10","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"make 和 new 的区别 make 的作用是初始化内置的数据结构，也就是我们在前面提到的切片、哈希表和 Channel new 的作用是根据传入的类型分配一片内存空间并返回指向这片内存空间的指针 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:11","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"解决 Go 的相对路径问题 获取当前可执行文件路径 将配置文件的相对路径与GetAppPath()的结果相拼接，可解决 go build main.go 的可执行文件跨目录执行的问题（如：go build ./src/gin-blog/main.go） import ( \"path/filepath\" \"os\" \"os/exec\" \"string\" ) func GetAppPath() string { file, _ := exec.LookPath(os.Args[0]) path, _ := filepath.Abs(file) index := strings.LastIndex(path, string(os.PathSeparator)) return path[:index] } 但是这种方式，对于 go run 依旧无效。因为 go run 执行时会将文件放到 /tmp/go-build... 目录下，编译并运行： Run compiles and runs the main package comprising the named Go source files. A Go source file is defined to be a file ending in a literal “.go” suffix. 通过传递参数指定路径，可解决 go run 的问题 package main import ( \"flag\" \"fmt\" ) func main() { var appPath string flag.StringVar(\u0026appPath, \"app-path\", \"app-path\") flag.Parse() fmt.Printf(\"App path: %s\", appPath) } go run main.go --app-path \"Your project address\" 增加 os.Getwd() 进行多层判断 参见 beego 读取 app.conf 的代码 该写法可兼容 go build 和在项目根目录执行 go run ，但是若跨目录执行 go run 就不行 配置全局系统变量 我们可以通过 os.Getenv 来获取系统全局变量，然后与相对路径进行拼接 1、 设置项目工作区 简单来说，就是设置项目（应用）的工作路径，然后与配置文件、日志文件等相对路径进行拼接，达到相对的绝对路径来保证路径一致 参见 gogs 读取 GOGS_WORK_DIR 进行拼接的代码 2、 利用系统自带变量 简单来说就是通过系统自带的全局变量，例如 $HOME 等，将配置文件存放在 $HOME/conf或/etc/conf 下 这样子就能更加固定的存放配置文件，不需要额外去设置一个环境变量 go test 在一些场景下也会遇到路径问题，因为go test只能够在当前目录执行，所以在执行测试用例的时候，你的执行目录已经是测试目录了 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:12","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"包装错误 使用 errors.Wrap errors.Wrap(err, \"additional message to a given error\") ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:13","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Golang"],"content":"不要忘记为 iota 指定一种类型 const ( _ = iota testvar // testvar 将是 int 类型 ) vs type myType int const ( _ myType = iota testvar // testvar 将是 myType 类型 ) 防止结构体字段用纯值方式初始化，添加 _ struct {} 字段： 当你的结构体要求强制给出所有参数才允许初始化时： type Point struct { X, Y float64 _ struct{} // to prevent unkeyed literals } 上例结构体的初始化，允许有 Point {X：1，Y：1} ，但是对于 Point {1,1} 则会出现编译错误： ./file.go:1:11: too few values in Point literal 当在你所有的结构体中添加了 _ struct{} 后，使用 go vet 命令进行检查，（原来声明的方式）就会提示没有足够的参数。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/basicgrammar/:11:14","tags":[],"title":"Go 基础语法","uri":"/Notes/posts/golang/basicgrammar/"},{"categories":["Python"],"content":"matplotlib from birthday import get_p import matplotlib.pyplot as plt import seaborn as sns sns.set() m = 2000 n = [i for i in range(100)] q = [get_p(m, i) for i in n] plt.plot(n, q) plt.xlabel(\"student number\") plt.ylabel(\"probability\") plt.legend() plt.savefig(fname='pic.png') plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:0:0","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"创建图片与子图 若不创建实例，一切对象名均使用plt！ ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:1:0","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"导入 import matplotlib.pyplot as plt ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:1:1","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"层次 Figure：面板(图)，matplotlib中的所有图像都是位于figure对象中，一个图像只能有一个figure对象。 Subplot：子图，figure对象下创建一个或多个subplot对象(即axes)用于绘制图像。 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:1:2","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"创建图片 fig = plt.figure() plt.figure()返回figure实例 一个空白的绘图窗口就会出现 重要参数 num：新图的编号，默认递增 figsize：宽度，高度，以英寸为单位 dpi：分辨率，整数 facecolor：背景颜色 edgecolor：边框颜色 frameon：若为False，则没有边框 clear：若为True，如果图的编号已存在则先清除 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:1:3","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"创建子图 .add_subplot() ax1 = fig.add_subplot(2, 2, 1) #将fig分割成2行3列，画出并返回序号1的子图 ax2 = fig.add_subplot(2, 2, 2) ax3 = fig.add_subplot(2, 2, 3) #注意，此时fig上只有3张子图，其他子图没有被初始化 fig.add_subplot(nrows, ncols, index)以图片作为对象，返回Axes实例 你可以直接在其他空白的子图上调用Axes对象的实例方法进行绘图 plt.subplots() 使用子图网格创建图片是非常常见的任务，所以matplotlib包含了一个便捷方法plt.subplots，它创建一个新的图片，然后返回包含了已生成子图对象的NumPy数组： fig, axes = plt.subplots(2, 3) API plt.subplots(nrows=1, ncols=1, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw) 返回 figure 实例和子图数组 参数 nrows，ncols：子图的行列数 sharex, sharey 设置为 True或者 ‘all’ 时，所有子图共享 x 轴或者 y 轴， 设置为 False or ‘none’ 时，所有子图的 x，y 轴均为独立， 设置为 ‘row’ 时，每一行的子图会共享 x 或者 y 轴， 设置为 ‘col’ 时，每一列的子图会共享 x 或者 y 轴。 squeeze：设置返回的子图对象的数组格式。 当为 False 时，不论返回的子图是只有一个还是只有一行，都会用二维数组格式返回他的对象。 当为 True时，如果子图只有一个，则返回的子图对象是标量形式，如果子图有（N×1）或（1×N）个，则返回的子图对象是一维数组，如果是（N×M）则返回二维数组。 subplot_kw：字典格式，传递给 add_subplot()，用于创建子图 gridspec_kw：字典格式，传递给GridSpec的构造函数，用于创建子图所摆放的网格。 **fig_kw ：所有其他关键字参数都传递给 figure()调用。 格式 #单行单列，按照一维数组来表示 ax = fig.subplots(2,1) # 2*1 ax[0].plot([1,2], [3,4]) # 第一个图 ax[1].plot([1,2], [3,4]) # 第二个图 #多行多列，按照二维数组来表示 ax = fig.subplots(2,2) # 2*2 ax[0,1].plot([1,2], [3,4]) # 第一个图 ax[0,1].plot([1,2], [3,4]) # 第二个图 ax[1,0].plot([1,2], [3,4]) # 第三个图 ax[1,1].plot([1,2], [3,4]) # 第四个图 数组axes可以像二维数组那样方便地进行索引，例如，axes[0，1] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:1:4","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"调整子图周围的间距 默认情况下，matplotlib会在子图的外部和子图之间留出一定的间距。这个间距都是相对于图的高度和宽度来指定的，所以如果你通过编程或手动使用GUI窗口来调整图的大小，那么图就会自动调整。 可以使用图对象上的plt.subplots_adjust方法更改间距 plt.subplots_adjust(wspace=1,hspace=0) API plt.subplots_adjust(left=None, bottom=None, right=None, top=None, wspace=None, hspace=None) 参数 left, right, bottom, top：子图所在区域的边界 当值大于1.0的时候子图会超出figure的边界从而显示不全；值不大于1.0的时候，子图会自动分布在一个矩形区域 要保证left \u003c right, bottom \u003c top，否则会报错 wspace, hspace：子图之间的横向间距、纵向间距分别与子图平均宽度、平均高度的比值，也就是图片的宽度和高度百分比 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:1:5","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"修饰 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:0","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"设置标题 设置图片标题 plt.suptitle('The Title',fontsize=14,color='purple') 若要直接在 figure 上操作 plt.title('The Title',fontsize=14,color='purple') #传figure的名字最好 fig.title('The Title',fontsize=14,color='purple') 常用参数 fontsize：设置字体大小，默认12， ['xx-small', 'x-small', 'small', ‘medium’, ‘large’, ’x-large’, ‘xx-large’] fontweight：设置字体粗细 [‘light’, ‘normal’, ‘medium’, ‘semibold’, ‘bold’, ‘heavy’, ‘black’] fontstyle：设置字体类型 [ ‘normal’, ‘italic’, ‘oblique’ ]；italic 斜体，oblique 倾斜 color：设置字体颜色 verticalalignment：设置水平对齐方式 [ ‘center’ , ‘top’ , ‘bottom’ ,’baseline’] horizontalalignment：设置垂直对齐方式 ['left', 'right', 'center'] rotation：旋转角度 [‘vertical’, ‘horizontal’] 也可以为数字 alpha：透明度，参数值0至1之间 backgroundcolor：标题背景颜色 bbox：给标题增加外框 ‘boxstyle’ ：方框外形 ‘facecolor’ ：(简写fc)背景颜色 ‘edgecolor’ ：(简写ec)边框线条颜色 ‘edgewidth’ ：边框线条大小 设置子图标题 ax1.set_title('graph1') 用Axe对象接受此函数 参数见2.1.1 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:1","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"轴操作 set方法允许批量设置绘图属性，如 props = { 'title': 'My first matplotlib plot', 'xlabel': 'Stages' } ax1.set(**props) 改变轴刻度 ax1.set_xticks([0,25,50,75,100]) ax1.set_yticks([10,20,30,40,50]) 若要直接在figure上操作 plt.xticks([0,25,50,75,100]) plt.yticks([10,20,30,40,50]) 添加轴标签 添加与刻度对应的标签 ax1.set_xticklabels(['one','two','three','four','five']) ax1.set_yticklabels(['a','b','c','d','e']) 添加单一轴标签 ax1.set_xlabel('stage') 参数见2.1.1 若要直接在figure上操作 plt.yticks([-2,-1.8,-1,1.22,3],['really bad','bad','normal','good','really ', 'good']) #或 plt.xlabel('x-year',fontsize=14) plt.ylabel('y-income',fontsize=14) 设置显示范围 plt.xlim(xmin, xmax) xmin：x轴上的最小值 xmax：x轴上的最大值 y轴亦如是 ax.get_lim() ax.set_lim() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:2","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"添加图例 .lengend()自动接受图像的label值，（label值在画图时传入） ax1.legend(loc=4) 常用参数 loc：设置图列位置，数字代表在第几象限 ['best','upper right','upper left', 'lower left','lower right', 'right', 'center left', 'center right', 'lower center','upper center','center'] fontsize：设置图例字体大小 int or float or {‘xx-small’, ‘x-small’, ‘small’, ‘medium’, ‘large’, ‘x-large’, ‘xx-large’} 设置图例边框及背景 frameon=False：去掉图例边框 edgecolor='blue'：设置图例边框颜色 facecolor='blue'：设置图例背景颜色,若无边框,参数无效 title：设置图例标题 markerfirst：如果为True（默认），则图例标记位于图例标签的左侧 ncol：设置图例分为n列展示 若要直接在figure上操作 plt.legend() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:3","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"添加注释 .text() plt.text(0.4,0.8,\"This is a text\",rotation=45) API .text(x,y,string,fontsize=15,verticalalignment=“top”,horizontalalignment=“right”) 参数 x,y：设置坐标值值 string：设置说明文字 其余详见2.1.1 .annotate() plt.annotate('Testing',xy=(0.4,0.6),fontsize=20,color='b') API .annotate(string, xy=(x,y) ,xytext=(l1,l2) ,… ) 参数 string：设置注释文本内容 xy：设置被注释的坐标点 xytext：设置注释文字的坐标位置 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:4","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"添加网格 plt.grid(linestyle=\"--\", alpha=0.5) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:5","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"绘制参考线 plt.axhline(y, c, ls, lw) #绘制平行于x轴的水平参考线 plt.axvline(x, c, ls, lw) #绘制平行于y轴的垂直参考线 y或x：水平参考线的出发点 c：参考线的线条颜色 ls：参考线的线条风格 lw：参考线的线条宽度 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:6","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"其他坐标轴设置 .axis() 参数 ‘equal’：x,y轴刻度等长 ‘off’：关闭坐标轴 [a, b, c, d]：设置x轴的范围为[a, b]，y轴的范围为[c, d] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:2:7","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"绘图 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:0","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"点图，线图 .plot(x,y) API #单条线： plot([x], y, [fmt], data=None, **kwargs) #多条线一起画 plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs) 参数 x,y：数据，x可选 fmt：定义基本属性 fmt = '[color][marker][line]' **kwargs label linestyle (ls) {''-', '--', '-.', ':', ' '} linewidth (lw)：线宽 color 可以用缩写、RGB、灰度字符串 character color ‘b’ blue ‘g’ green ‘r’ red ‘c’ cyan ‘m’ magenta ‘y’ yellow ‘k’ black ‘w’ white marker character description '.' point marker ',' pixel marker 'o' circle marker 'v' triangle_down marker '^' triangle_up marker '\u003c' triangle_left marker '\u003e' triangle_right marker '1' tri_down marker '2' tri_up marker '3' tri_left marker '4' tri_right marker 's' square marker 'p' pentagon marker '*' star marker 'h' hexagon1 marker 'H' hexagon2 marker '+' plus marker 'x' x marker 'D' diamond marker 'd' thin_diamond marker `' ‘` '_' hline marker alpha：透明值，接受0~1之间的浮点数 例 x = [1, 2, 3, 4] y = [5, 6, 4, 10] plt.plot(x, y, 'r.:', label = 'a',) plt.xlabel('this is x') plt.ylabel('this is y') plt.title('This is a demo') plt.legend() plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:1","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"散点图 .scatter(x,y) x = np.arange(10) y = np.random.randn(10) plt.scatter(x, y, color='red', marker='+') plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:2","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"气泡图 加入了第三个值 s 可以理解成普通散点，画的是二维，泡泡图体现了Z的大小 s：散点标记的大小 c：散点标记的颜色 cmap：将浮点数映射成颜色的颜色映射率 np.random.seed(19680801) N = 50 x = np.random.rand(N) y = np.random.rand(N) colors = np.random.rand(N) area = (30 * np.random.rand(N))**2 # to 15 point radii plt.scatter(x, y, s=area, c=colors, alpha=0.5) plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:3","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"柱状图 .bar(x, y) .barh(x, y) #横向柱状图 x：标示在x轴上的定性数据的类别 y：每种定性数据的类别的数量 align：每个柱状图的位置对齐方式 {'center', 'edge'}, optional, default: 'center'} A = ['A', 'B', 'C', 'D', 'E'] x = range(len(A)) y = [1984, 3514, 4566, 7812, 1392] x_ = [i+0.2 for i in x] y_ = [3154, 1571, 4566, 9858, 2689] # 2.创建画布 plt.figure(figsize=(8,6),dpi=100) # 3.绘制柱状图 plt.bar(x, y, width=0.2, label='1') plt.bar(x_,y_, width=0.2, label='2') # 显示图例 plt.legend() # 修改x轴刻度显示 plt.xticks([i+0.1 for i in x], A) # 添加网格显示 plt.grid(linestyle=\"--\", alpha=0.5) # 4.显示图像 plt.show() x = [1, 2, 3, 4, 5] y = [6, 10, 4, 5, 1] y1 = [2, 6, 3, 8, 5] plt.bar(x, y, align=\"center\", color=\"#66c2a5\", tick_label=[\"A\", \"B\", \"C\", \"D\", \"E\"], label=\"班级A\") plt.bar(x, y1, align=\"center\", bottom=y, color=\"#8da0cb\", label=\"班级B\") plt.xlabel(\"测试难度\") plt.ylabel(\"试卷份数\") plt.legend() plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:4","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"直方图 直方图用于表明数据分布情况，横轴是数据，纵轴是出现的次数（也就是频数） .hist(x) x：在x轴上绘制箱体的定量数据输入值 重要参数 x : arrays(一个或多个)，在x轴上绘制箱体的定量数据输入值 range : 设置显示范围（tuple or None, optional） bins：x轴的分段数，默认为10 histtype : 选择展示的类型,默认为bar {‘bar’, ‘barstacked’, ‘step’, ‘stepfilled’} align : 对齐方式 {‘left’, ‘mid’, ‘right’} orientation : 直方图方向 {‘horizontal’, ‘vertical’} log : boolean，log刻度 color：颜色设置 label：刻度标签 例 np.random.seed(19680801) n_bins = 10 x = np.random.randn(1000, 3) fig, axes = plt.subplots(nrows=2, ncols=2) ax0, ax1, ax2, ax3 = axes.flatten() colors = ['red', 'tan', 'lime'] ax0.hist(x, n_bins, density=True, histtype='bar', color=colors, label=colors) ax0.legend(prop={'size': 10}) ax0.set_title('bars with legend') ax1.hist(x, n_bins, density=True, histtype='barstacked') ax1.set_title('stacked bar') ax2.hist(x, histtype='barstacked', rwidth=0.9) ax3.hist(x[:, 0], rwidth=0.9) ax3.set_title('different sample sizes') fig.tight_layout() plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:5","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"饼图 饼图自动根据数据的百分比画饼 .pie(x) 重要参数 x: 定性数据的不同类别的百分比 explode:指定饼图某些部分的突出显示，即呈现爆炸式，传入元组，每个数据分别为0-1的浮点，表示分离的程度 sizes = [15, 30, 45, 10] explode = (0, 1, 0, 0) labels：为饼图添加标签说明，类似于图例说明 colors：指定饼图的填充色 autopct：设置百分比格式，如’%.1f%%‘为保留一位小数 shadow：是否添加饼图的阴影效果 pctdistance：设置百分比标签与圆心的距离 labeldistance：设置各扇形标签（图例）与圆心的距离； startangle：设置饼图的初始摆放角度, 180为水平； radius：设置饼图的半径大小； wedgeprops：设置饼图内外边界的属性，如边界线的粗细、颜色等, 如 wedgeprops = {'linewidth': 1.5, 'edgecolor':'green'} textprops：设置饼图中文本的属性，如字体大小、颜色等； center：指定饼图的中心点位置，默认为原点 例 labels = 'Frogs', 'Hogs', 'Dogs', 'Logs' sizes = [15, 30, 45, 10] explode = (0, 0.2, 0, 0) # only \"explode\" the 2nd slice (i.e. 'Hogs') fig1, (ax1, ax2) = plt.subplots(2) ax1.pie(sizes, labels=labels, autopct='%1.1f%%', shadow=True) ax1.axis('equal') ax2.pie(sizes, autopct='%1.2f%%', shadow=True, startangle=90, explode=explode, pctdistance=1.12) ax2.axis('equal') ax2.legend(labels=labels, loc='upper right') plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:6","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"箱型图 .boxplot(x) x：数据 vert：方向 x = np.random.randn(1000) plt.boxplot(x) plt.xticks([1], [\"随机数生成器AlphaRM\"]) plt.ylabel(\"随机数值\") plt.title(\"随机数生成器抗干扰能力的稳定性\") plt.grid(axis=\"y\", ls=\":\", lw=1, color=\"gray\", alpha=0.4) plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:7","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"棉棒图 绘制离散有序数据 .stem(x, y) x：制定棉棒的x轴基线上的位置 y：绘制棉棒的长度 linefmt：棉棒的样式 markerfmt*：棉棒末端的样式 basefmt*：指定基线的样式 import matplotlib.pyplot as plt import numpy as np a = np.linspace(0.5, 2*np.pi, 20) b = np.random.randn(20) plt.stem(a, b, linefmt=\"-.\", markerfmt=\"o\", basefmt=\"-\") plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:8","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"三维图 fig = plt.figure(5) ax=fig.add_subplot(1,1,1,projection='3d') #绘制三维图 x,y=np.mgrid[-2:2:20j,-2:2:20j] #获取x轴数据，y轴数据 z=x*np.exp(-x**2-y**2) #获取z轴数据 ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8) #绘制三维图表面 ax.set_xlabel('x-name') #x轴名称 ax.set_ylabel('y-name') #y轴名称 ax.set_zlabel('z-name') #z轴名称 plt.show() ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:3:9","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"其他 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:4:0","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"保存 .savefig(path, dpi, facecolor, edgecolor,bbox_inches) 参数 path：文件路径 dpi：分辨率 facelolor，edgecolor：子图之外的图形背景颜色，默认为‘w’ format：文件格式 'png','pdf','svg','ps',''eps'...... bbox_inches：要保存的图片范围，若传递'tight'，会去除图片周围空白部分 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:4:1","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"解决中文乱码问题 import matplotlib.pyplot as plt plt.rcParams['font.sans-serif'] = ['SimHei'] # 用来正常显示中文标签 plt.rcParams['axes.unicode_minus'] = False # 用来正常显示负号 # 或 import matplotlib as mpl mpl.rc(\"font\", family='MicroSoft YaHei', weight='bold') # 或 from matplotlib.font_manager import FontProperties myfont=FontProperties(fname=r'C:\\Windows\\Fonts\\simhei.ttf',size=14) sns.set(font=myfont.get_name()) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/matplotlib/:4:2","tags":["Python","数据分析"],"title":"matplotlib","uri":"/Notes/posts/python/dataanalysis/matplotlib/"},{"categories":["Python"],"content":"numpy ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:0:0","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"数组基础 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:0","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"属性 ndarray.ndim 数组的轴（维度）的个数。在Python世界中，维度的数量被称为rank（秩） ndarray.shape 数组的维度。这是一个整数的元组，表示每个维度中数组的大小。对于有 n 行和 m 列的矩阵，shape 将是 (n,m)。因此，shape 元组的长度就是rank或维度的个数 ndim。 ndarray.size 数组元素的总数。这等于 shape 的元素的乘积。 ndarray.dtype 一个描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外NumPy提供它自己的类型。例numpy.int32、numpy.int16和numpy.float64。 ndarray.itemsize 数组中每个元素的字节大小。例如，元素为 float64 类型的数组的 itemsize 为8（=64/8），而 complex32 类型的数组的 itemsize 为4（=32/8）。它等于 ndarray.dtype.itemsize 。 ndarray.data 该缓冲区包含数组的实际元素。通常，我们不需要使用此属性，因为我们将使用索引访问数组中的元素。 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:1","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"创建 概览 a = np.array([0, 1, 2, 3, 4]) b = np.array((0, 1, 2, 3, 4)) c = np.arange(5) d = np.linspace(0, 2*np.pi, 5) 用列表和元组创建数组 使用array函数 a = np.array([2,3,4]) b = np.array([(1.5,2,3), (4,5,6)]) \u003e\u003e\u003e array([2, 3, 4]) array([[1.5, 2. , 3. ], [4. , 5. , 6. ]]) 数组类型可以在创建时显示指定 c = np.array([[1, 2], [3, 4]], dtype=complex) \u003e\u003e\u003e array([[1.+0.j, 2.+0.j], [3.+0.j, 4.+0.j]]) 用占位符创建数组 a = np.zeros((3, 4)) b = np.ones((2, 3, 4), dtype=np.int16) # dtype can also be specified c = np.empty((2, 3)) # uninitialized, output may vary 输出 array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) array([[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]], dtype=int16) array([[1.5, 2. , 3. ], [4. , 5. , 6. ]]) 在一定范围内创建数组 使用 arange 函数 输入起始，终止，步长来创建数组 a = np.arange(10, 30, 5) b = np.arange(0, 2, 0.3) # it accepts float arguments \u003e\u003e\u003e array([10, 15, 20, 25]) array([0. , 0.3, 0.6, 0.9, 1.2, 1.5, 1.8]) 使用 linspace 函数 当arange与浮点参数一起使用时，由于有限的浮点精度，通常不可能预测所获得的元素的数量。出于这个原因，通常最好使用linspace函数来接收我们想要的元素数量的函数，而不是步长（step） a = np.linspace(0, 2, 9) # numbers from 0 to 2 \u003e\u003e\u003e array([0. , 0.25, 0.5 , 0.75, 1. , 1.25, 1.5 , 1.75, 2. ]) 创建二维数组 用 .reshape() 方法 创建一个共20个整数、4行5列的二维数组 a = np.arange(20).reshape(4, 5) \u003e\u003e\u003e array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]]) 随机创建 使用numpy.random.rand() numpy.random.rand(d0, d1, …, dn) rand函数根据给定维度生成[0,1)之间的数据，包含0，不包含1 dn表示每个维度 返回值为指定维度的array np.random.rand(4, 2) \u003e\u003e\u003e array([[0.98674795, 0.13286586], [0.29918216, 0.31617708], [0.11613039, 0.06952587], [0.854591 , 0.46243232]]) 使用numpy.random.randn() numpy.random.randn(d0, d1, …, dn) randn函数返回一个或一组样本，具有标准正态分布。 dn表格每个维度 返回值为指定维度的array 没有参数时，返回单个数据 np.random.randn(2, 4) \u003e\u003e\u003e array([[-1.00153189, 2.24079402, 1.60828566, -0.65998837], [ 1.98674251, -0.33065155, 0.48365328, 0.4008861 ]]) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:2","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"运算 基本运算符 乘积运算符*在NumPy数组中按元素进行运算。矩阵乘积可以使用@运算符或dot函数或方法执行 A = np.array([[1, 1], [0, 1]]) B = np.array([[2, 0], [3, 4]]) A*B \u003e\u003e\u003e array([[2, 0], [0, 4]]) A@B \u003e\u003e\u003e array([[5, 4], [3, 4]]) A.dot(B) \u003e\u003e\u003e array([[5, 4], [3, 4]]) 某些操作（例如+=和*=）会更直接更改被操作的矩阵数组而不会创建新矩阵数组 当使用不同类型的数组进行操作时，结果数组的类型对应于更一般或更精确的数组（称为向上转换的行为） 特殊运算符 # dot, sum, min, max, cumsum a = np.arange(10) print(a.sum()) # \u003e\u003e\u003e45 print(a.min()) # \u003e\u003e\u003e0 print(a.max()) # \u003e\u003e\u003e9 print(a.cumsum()) # \u003e\u003e\u003e[ 0 1 3 6 10 15 21 28 36 45] 通过指定axis（列）参数，可以沿数组的指定轴应用操作 b = np.arange(12).reshape(3, 4) b.sum(axis=0) # sum of each column \u003e\u003e\u003e array([12, 15, 18, 21]) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:3","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"通函数（ufunc） 数学函数合集 NumPy提供熟悉的数学函数，例如sin，cos和exp。在NumPy中，这些被称为“通函数”。在NumPy中，这些函数在数组上按元素进行运算，产生一个数组作为输出 A = np.arange(3) np.exp(A) # 以e为底的指数函数 \u003e\u003e\u003e array([1. , 2.71828183, 7.3890561 ]) np.sqrt(A) # 开平方根 \u003e\u003e\u003e array([0. , 1. , 1.41421356]) B = np.array([2., -1., 4.]) np.add(A, B) # 相加 \u003e\u003e\u003e array([2., 0., 6.]) x = np.array([[1, 2], [3, 4]]) y = np.array([[5, 6], [7, 8]]) # Matrix / matrix product; both produce the rank 2 array print(x.dot(y)) print(np.dot(x, y)) \u003e\u003e\u003e [[19 22] [43 50]] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:4","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"切片 一维数组 a = np.arange(10)**3 a \u003e\u003e\u003e array([ 0, 1, 8, 27, 64, 125, 216, 343, 512, 729], dtype=int32) a[2] \u003e\u003e\u003e 8 a[2:5] \u003e\u003e\u003e array([ 8, 27, 64], dtype=int32) a[:6:2] = -1000 # from start to position 6, exclusive, set every 2nd element to -1000 a \u003e\u003e\u003e array([-1000, 1, -1000, 27, -1000, 125, 216, 343, 512, 729], dtype=int32) a[::-1] # reversed a \u003e\u003e\u003e array([ 729, 512, 343, 216, 125, -1000, 27, -1000, 1, -1000], dtype=int32) 多维数组 多维的数组每个轴可以有一个索引。这些索引以逗号分隔的元组给出 a = np.array([[11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25], [26, 27, 28, 29, 30], [31, 32, 33, 34, 35]]) print(a[0, 1:4]) \u003e\u003e\u003e [12 13 14] print(a[1:4, 0]) \u003e\u003e\u003e [16 21 26] print(a[::2, ::2]) \u003e\u003e\u003e [[11 13 15] [21 23 25] [31 33 35]] print(a[:, 1]) \u003e\u003e\u003e [12 17 22 27 32] 三个点（ … ）表示产生完整索引元组所需的冒号。例如，如果 x 是rank为5的数组（即，它具有5个轴），则 x[1 , 2 , …] 相当于 x[1,2, : , : , :]， x[… , 3] 等效于 x[: , : , : , : ,3] x[4, … ,5, :] 等效于 x[4, : , : , 5, : ] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:5","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"调整数据 四舍五入 返回四舍五入后的值，可指定精度 np.around(a, decimals=0, out=None) a：输入数组 decimals：要舍入的小数位数。 默认值为0。 如果为负，整数将四舍五入到小数点左侧的位置 n = np.array([-0.746, 4.6, 9.4, 7.447, 10.455, 11.555]) np.around(n) \u003e\u003e\u003e [ -1. 5. 9. 7. 10. 12.] np.around(n, decimals=1) \u003e\u003e\u003e [ -0.7 4.6 9.4 7.4 10.5 11.6] np.around(n, decimals=-1) \u003e\u003e\u003e [ -0. 0. 10. 10. 10. 10.] 向下取整 返回不大于输入参数的最大整数 np.floor() n = np.array([-1.7, -2.5, -0.2, 0.6, 1.2, 2.7, 11]) np.floor(n) \u003e\u003e\u003e [ -2. -3. -1. 0. 1. 2. 11.] 向上取整 返回输入值的上限 np.ceil() n = np.array([-1.7, -2.5, -0.2, 0.6, 1.2, 2.7, 11]) np.ceil(n) \u003e\u003e\u003e [ -1. -2. -0. 1. 2. 3. 11.] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:1:6","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"索引进阶 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:2:0","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"花式索引 用想要检索的特定索引序列对数组进行索引。这反过来返回索引的元素的列表。 # Fancy indexing a = np.arange(0, 100, 10) indices = [1, 5, -1] b = a[indices] print(a) \u003e\u003e\u003e [ 0 10 20 30 40 50 60 70 80 90] print(b) \u003e\u003e\u003e [10 50 90] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:2:1","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"布尔屏蔽 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:2:2","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"Where 函数 只需要把条件传递给它，它就会返回一个使得条件为真的元素的列表。 返回索引（下标） # Where a = np.arange(0, 100, 10) b = np.where(a \u003c 50) c = np.where(a \u003e= 50)[0] print(b) \u003e\u003e\u003e (array([0, 1, 2, 3, 4]),) print(c) \u003e\u003e\u003e [5 6 7 8 9] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:2:3","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"形状操控 ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:3:0","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"改变数组的形状 a = np.array([[2, 8, 0, 6], [4, 5, 1, 1], [8, 9, 3, 6]]) 可以使用各种命令更改数组的形状。请注意，以下三个命令（除resize）都返回一个修改后的数组，但不会更改原始数组 a.ravel() # 展平数组 \u003e\u003e\u003e array([2, 8, 0, 6, 4, 5, 1, 1, 8, 9, 3, 6]) a.reshape(6,2) # 重塑数组行列 \u003e\u003e\u003e array([[2, 8], [0, 6], [4, 5], [1, 1], [8, 9], [3, 6]]) a.reshape(3,-1) # 如果在 reshape 操作中将 size 指定为-1，则会自动计算其他的 size 大小 \u003e\u003e\u003e array([[2, 8, 0, 6], [4, 5, 1, 1], [8, 9, 3, 6]]) a.T # 转置数组 \u003e\u003e\u003e array([[2, 4, 8], [8, 5, 9], [0, 1, 3], [6, 1, 6]]) a.resize((2,6)) #.resize()方法会修改数组本身 print(a) \u003e\u003e\u003e array([[2, 8, 0, 6, 4, 5], [1, 1, 8, 9, 3, 6]]) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:3:1","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"堆叠数组 几个数组可以沿不同的轴堆叠在一起 a = np.array([[8, 8], [0, 0]]) b = np.array([[1, 8], [0, 4]]) np.vstack((a, b)) # 垂直(按列顺序)把数组给堆叠起来 \u003e\u003e\u003e array([[8, 8], [0, 0], [1, 8], [0, 4]]) np.hstack((a, b)) # 水平(按列顺序)把数组给堆叠起来 \u003e\u003e\u003e array([[8, 8, 1, 8], [0, 0, 0, 4]]) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:3:2","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"拆分数组 使用hsplit，可以沿数组的水平轴拆分数组，方法是指定要返回的形状相等的数组的数量，或者指定应该在其之后进行分割的列 使用vsplit沿垂直轴分割 a = np.array([[9, 5, 6, 3, 6, 8, 0, 7, 9, 7, 2, 7], [1, 4, 9, 2, 2, 1, 0, 6, 2, 2, 4, 0]]) np.hsplit(a,3) # 平均分成三份 \u003e\u003e\u003e [array([[9, 5, 6, 3], [1, 4, 9, 2]]), array([[6, 8, 0, 7], [2, 1, 0, 6]]), array([[9, 7, 2, 7], [2, 2, 4, 0]])] np.hsplit(a,(3,4)) # 以第三列和第四列为界，分割数组 \u003e\u003e\u003e [array([[9, 5, 6], [1, 4, 9]]), array([[3], [2]]), array([[6, 8, 0, 7, 9, 7, 2, 7], [2, 1, 0, 6, 2, 2, 4, 0]])] ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:3:3","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["Python"],"content":"例 打印numpy的版本和配置说明 print(np.__version__) np.show_config() 如何找到任何一个数组的内存大小？ Z = np.zeros((10, 10)) print(\"%dbytes\" % (Z.size * Z.itemsize)) 如何从一维数组中提取满足指定条件的元素？ # Input arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) # Solution arr[arr % 2 == 1] \u003e\u003e\u003e array([1, 3, 5, 7, 9]) 找到数组[1,2,0,0,4,0]中非0元素的位置索引 nz = np.nonzero([1, 2, 0, 0, 4, 0]) print(nz) ","date":"2021-10-23","objectID":"/Notes/posts/python/dataanalysis/numpy/:4:0","tags":["Python","数据分析"],"title":"numpy","uri":"/Notes/posts/python/dataanalysis/numpy/"},{"categories":["数据库"],"content":"MySQL 学习笔记 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:0:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"登录和退出 MySQL 服务器 # 登录MySQL mysql -u [username] -p[password] # 远程连接 mysql -h [host] -P [port] -u [username] -p[password] # 退出MySQL数据库服务器 exit; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:1:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"基本语法 -- 显示所有数据库 showdatabases;-- 创建数据库 CREATEDATABASEtest;-- 切换数据库 usetest;-- 显示数据库中的所有表 showtables;-- 创建数据表 CREATETABLEpet(nameVARCHAR(20),ownerVARCHAR(20),speciesVARCHAR(20),sexCHAR(1),birthDATE,deathDATE);-- 查看数据表结构 -- describe pet; descpet;-- 查询表 SELECT*frompet;-- 插入数据 INSERTINTOpetVALUES('puffball','Diane','hamster','f','1990-03-30',NULL);-- 修改数据 UPDATEpetSETname='squirrel'whereowner='Diane';-- 删除数据 DELETEFROMpetwherename='squirrel';-- 删除表 DROPTABLEmyorder; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:2:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"建表约束 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:3:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"主键约束 -- 主键约束 -- 使某个字段不重复且不得为空，确保表内所有数据的唯一性。 CREATETABLEuser(idINTPRIMARYKEY,nameVARCHAR(20));-- 联合主键 -- 联合主键中的每个字段都不能为空，并且加起来不能和已设置的联合主键重复。 CREATETABLEuser(idINT,nameVARCHAR(20),passwordVARCHAR(20),PRIMARYKEY(id,name));-- 自增约束 -- 自增约束的主键由系统自动递增分配。 CREATETABLEuser(idINTPRIMARYKEYAUTO_INCREMENT,nameVARCHAR(20));-- 添加主键约束 -- 如果忘记设置主键，还可以通过SQL语句设置（两种方式）： ALTERTABLEuserADDPRIMARYKEY(id);ALTERTABLEuserMODIFYidINTPRIMARYKEY;-- 删除主键 ALTERTABLEuserdropPRIMARYKEY; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:3:1","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"唯一约束 -- 建表时创建唯一约束 CREATETABLEuser(idINT,nameVARCHAR(20),UNIQUE(name));-- 添加唯一约束 -- 如果建表时没有设置唯一约束，还可以通过SQL语句设置（两种方式）： ALTERTABLEuserADDUNIQUE(name);ALTERTABLEuserMODIFYnameVARCHAR(20)UNIQUE;-- 删除唯一约束 ALTERTABLEuserDROPINDEXname; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:3:2","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"非空约束 -- 建表时添加非空约束 -- 约束某个字段不能为空 CREATETABLEuser(idINT,nameVARCHAR(20)NOTNULL);-- 移除非空约束 ALTERTABLEuserMODIFYnameVARCHAR(20); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:3:3","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"默认约束 -- 建表时添加默认约束 -- 约束某个字段的默认值 CREATETABLEuser2(idINT,nameVARCHAR(20),ageINTDEFAULT10);-- 移除非空约束 ALTERTABLEuserMODIFYageINT; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:3:4","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"外键约束 -- 班级 CREATETABLEclasses(idINTPRIMARYKEY,nameVARCHAR(20));-- 学生表 CREATETABLEstudents(idINTPRIMARYKEY,nameVARCHAR(20),-- 这里的 class_id 要和 classes 中的 id 字段相关联 class_idINT,-- 表示 class_id 的值必须来自于 classes 中的 id 字段值 FOREIGNKEY(class_id)REFERENCESclasses(id));-- 1. 主表（父表）classes 中没有的数据值，在副表（子表）students 中，是不可以使用的； -- 2. 主表中的记录被副表引用时，主表不可以被删除。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:3:5","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"数据库的三大设计范式 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:4:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"1NF 所有字段值都是不可再分的原子值 只要字段值还可以继续拆分，就不满足第一范式。 范式设计得越详细，对某些实际操作可能会更好，但并非都有好处，需要对项目的实际情况进行设定。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:4:1","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"2NF 在满足第一范式的前提下，其他列都必须完全依赖于主键列。如果出现不完全依赖，只可能发生在联合主键的情况下： -- 订单表 CREATETABLEmyorder(product_idINT,customer_idINT,product_nameVARCHAR(20),customer_nameVARCHAR(20),PRIMARYKEY(product_id,customer_id)); 实际上，在这张订单表中，product_name 只依赖于 product_id ，customer_name 只依赖于 customer_id 。也就是说，product_name 和 customer_id 是没用关系的，customer_name 和 product_id 也是没有关系的。 这就不满足第二范式：其他列都必须完全依赖于主键列！ CREATETABLEmyorder(order_idINTPRIMARYKEY,product_idINT,customer_idINT);CREATETABLEproduct(idINTPRIMARYKEY,nameVARCHAR(20));CREATETABLEcustomer(idINTPRIMARYKEY,nameVARCHAR(20)); 拆分之后，myorder 表中的 product_id 和 customer_id 完全依赖于 order_id 主键，而 product 和 customer 表中的其他字段又完全依赖于主键。满足了第二范式的设计！ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:4:2","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"3NF 在满足第二范式的前提下，除了主键列之外，其他列之间不能有传递依赖关系。 CREATETABLEmyorder(order_idINTPRIMARYKEY,product_idINT,customer_idINT,customer_phoneVARCHAR(15)); 表中的 customer_phone 有可能依赖于 order_id 、 customer_id 两列，也就不满足了第三范式的设计：其他列之间不能有传递依赖关系。 CREATETABLEmyorder(order_idINTPRIMARYKEY,product_idINT,customer_idINT);CREATETABLEcustomer(idINTPRIMARYKEY,nameVARCHAR(20),phoneVARCHAR(15)); 修改后就不存在其他列之间的传递依赖关系，其他列都只依赖于主键列，满足了第三范式的设计！ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:4:3","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"查询练习 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"准备数据 -- 创建数据库 CREATEDATABASEselect_test;-- 切换数据库 USEselect_test;-- 创建学生表 CREATETABLEstudent(noVARCHAR(20)PRIMARYKEY,nameVARCHAR(20)NOTNULL,sexVARCHAR(10)NOTNULL,birthdayDATE,-- 生日 classVARCHAR(20)-- 所在班级 );-- 创建教师表 CREATETABLEteacher(noVARCHAR(20)PRIMARYKEY,nameVARCHAR(20)NOTNULL,sexVARCHAR(10)NOTNULL,birthdayDATE,professionVARCHAR(20)NOTNULL,-- 职称 departmentVARCHAR(20)NOTNULL-- 部门 );-- 创建课程表 CREATETABLEcourse(noVARCHAR(20)PRIMARYKEY,nameVARCHAR(20)NOTNULL,t_noVARCHAR(20)NOTNULL,-- 教师编号 -- 表示该 tno 来自于 teacher 表中的 no 字段值 FOREIGNKEY(t_no)REFERENCESteacher(no));-- 成绩表 CREATETABLEscore(s_noVARCHAR(20)NOTNULL,-- 学生编号 c_noVARCHAR(20)NOTNULL,-- 课程号 degreeDECIMAL,-- 成绩 -- 表示该 s_no, c_no 分别来自于 student, course 表中的 no 字段值 FOREIGNKEY(s_no)REFERENCESstudent(no),FOREIGNKEY(c_no)REFERENCEScourse(no),-- 设置 s_no, c_no 为联合主键 PRIMARYKEY(s_no,c_no));-- 查看所有表 SHOWTABLES;-- 添加学生表数据 INSERTINTOstudentVALUES('101','曾华','男','1977-09-01','95033');INSERTINTOstudentVALUES('102','匡明','男','1975-10-02','95031');INSERTINTOstudentVALUES('103','王丽','女','1976-01-23','95033');INSERTINTOstudentVALUES('104','李军','男','1976-02-20','95033');INSERTINTOstudentVALUES('105','王芳','女','1975-02-10','95031');INSERTINTOstudentVALUES('106','陆军','男','1974-06-03','95031');INSERTINTOstudentVALUES('107','王尼玛','男','1976-02-20','95033');INSERTINTOstudentVALUES('108','张全蛋','男','1975-02-10','95031');INSERTINTOstudentVALUES('109','赵铁柱','男','1974-06-03','95031');-- 添加教师表数据 INSERTINTOteacherVALUES('804','李诚','男','1958-12-02','副教授','计算机系');INSERTINTOteacherVALUES('856','张旭','男','1969-03-12','讲师','电子工程系');INSERTINTOteacherVALUES('825','王萍','女','1972-05-05','助教','计算机系');INSERTINTOteacherVALUES('831','刘冰','女','1977-08-14','助教','电子工程系');-- 添加课程表数据 INSERTINTOcourseVALUES('3-105','计算机导论','825');INSERTINTOcourseVALUES('3-245','操作系统','804');INSERTINTOcourseVALUES('6-166','数字电路','856');INSERTINTOcourseVALUES('9-888','高等数学','831');-- 添加添加成绩表数据 INSERTINTOscoreVALUES('103','3-105','92');INSERTINTOscoreVALUES('103','3-245','86');INSERTINTOscoreVALUES('103','6-166','85');INSERTINTOscoreVALUES('105','3-105','88');INSERTINTOscoreVALUES('105','3-245','75');INSERTINTOscoreVALUES('105','6-166','79');INSERTINTOscoreVALUES('109','3-105','76');INSERTINTOscoreVALUES('109','3-245','68');INSERTINTOscoreVALUES('109','6-166','81');-- 查看表结构 SELECT*FROMcourse;SELECT*FROMscore;SELECT*FROMstudent;SELECT*FROMteacher; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:1","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"1 到 10 -- 查询 student 表的所有行 SELECT*FROMstudent;-- 查询 student 表中的 name、sex 和 class 字段的所有行 SELECTname,sex,classFROMstudent;-- 查询 teacher 表中不重复的 department 列 -- department: 去重查询 SELECTDISTINCTdepartmentFROMteacher;-- 查询 score 表中成绩在60-80之间的所有行（区间查询和运算符查询） -- BETWEEN xx AND xx: 查询区间, AND 表示 \"并且\" SELECT*FROMscoreWHEREdegreeBETWEEN60AND80;SELECT*FROMscoreWHEREdegree\u003e60ANDdegree\u003c80;-- 查询 score 表中成绩为 85, 86 或 88 的行 -- IN: 查询规定中的多个值 SELECT*FROMscoreWHEREdegreeIN(85,86,88);-- 查询 student 表中 '95031' 班或性别为 '女' 的所有行 -- or: 表示或者关系 SELECT*FROMstudentWHEREclass='95031'orsex='女';-- 以 class 降序的方式查询 student 表的所有行 -- DESC: 降序，从高到低 -- ASC（默认）: 升序，从低到高 SELECT*FROMstudentORDERBYclassDESC;SELECT*FROMstudentORDERBYclassASC;-- 以 c_no 升序、degree 降序查询 score 表的所有行 SELECT*FROMscoreORDERBYc_noASC,degreeDESC;-- 查询 \"95031\" 班的学生人数 -- COUNT: 统计 SELECTCOUNT(*)FROMstudentWHEREclass='95031';-- 查询 score 表中的最高分的学生学号和课程编号（子查询或排序查询）。 -- (SELECT MAX(degree) FROM score): 子查询，算出最高分 SELECTs_no,c_noFROMscoreWHEREdegree=(SELECTMAX(degree)FROMscore);-- 排序查询 -- LIMIT r, n: 表示从第r行开始，查询n条数据 SELECTs_no,c_no,degreeFROMscoreORDERBYdegreeDESCLIMIT0,1; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:2","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"分组计算平均成绩 查询每门课的平均成绩。 -- AVG: 平均值 SELECTAVG(degree)FROMscoreWHEREc_no='3-105';SELECTAVG(degree)FROMscoreWHEREc_no='3-245';SELECTAVG(degree)FROMscoreWHEREc_no='6-166';-- GROUP BY: 分组查询 SELECTc_no,AVG(degree)FROMscoreGROUPBYc_no; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:3","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"分组条件与模糊查询 查询 score 表中至少有 2 名学生选修，并以 3 开头的课程的平均分数。 SELECT*FROMscore;-- c_no 课程编号 +------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-105|92||103|3-245|86||103|6-166|85||105|3-105|88||105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+ 分析表发现，至少有 2 名学生选修的课程是 3-105 、3-245 、6-166 ，以 3 开头的课程是 3-105 、3-245 。也就是说，我们要查询所有 3-105 和 3-245 的 degree 平均分。 -- 首先把 c_no, AVG(degree) 通过分组查询出来 SELECTc_no,AVG(degree)FROMscoreGROUPBYc_no+-------+-------------+|c_no|AVG(degree)|+-------+-------------+|3-105|85.3333||3-245|76.3333||6-166|81.6667|+-------+-------------+-- 再查询出至少有 2 名学生选修的课程 -- HAVING: 表示持有 HAVINGCOUNT(c_no)\u003e=2-- 并且是以 3 开头的课程 -- LIKE 表示模糊查询，\"%\" 是一个通配符，匹配 \"3\" 后面的任意字符。 ANDc_noLIKE'3%';-- 把前面的SQL语句拼接起来， -- 后面加上一个 COUNT(*)，表示将每个分组的个数也查询出来。 SELECTc_no,AVG(degree),COUNT(*)FROMscoreGROUPBYc_noHAVINGCOUNT(c_no)\u003e=2ANDc_noLIKE'3%';+-------+-------------+----------+|c_no|AVG(degree)|COUNT(*)|+-------+-------------+----------+|3-105|85.3333|3||3-245|76.3333|3|+-------+-------------+----------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:4","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"多表查询 - 1 查询所有学生的 name，以及该学生在 score 表中对应的 c_no 和 degree 。 SELECTno,nameFROMstudent;+-----+-----------+|no|name|+-----+-----------+|101|曾华||102|匡明||103|王丽||104|李军||105|王芳||106|陆军||107|王尼玛||108|张全蛋||109|赵铁柱|+-----+-----------+SELECTs_no,c_no,degreeFROMscore;+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-105|92||103|3-245|86||103|6-166|85||105|3-105|88||105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+ 通过分析可以发现，只要把 score 表中的 s_no 字段值替换成 student 表中对应的 name 字段值就可以了，如何做呢？ -- FROM...: 表示从 student, score 表中查询 -- WHERE 的条件表示为，只有在 student.no 和 score.s_no 相等时才显示出来。 SELECTname,c_no,degreeFROMstudent,scoreWHEREstudent.no=score.s_no;+-----------+-------+--------+|name|c_no|degree|+-----------+-------+--------+|王丽|3-105|92||王丽|3-245|86||王丽|6-166|85||王芳|3-105|88||王芳|3-245|75||王芳|6-166|79||赵铁柱|3-105|76||赵铁柱|3-245|68||赵铁柱|6-166|81|+-----------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:5","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"多表查询 - 2 查询所有学生的 no 、课程名称 ( course 表中的 name ) 和成绩 ( score 表中的 degree ) 列。 只有 score 关联学生的 no ，因此只要查询 score 表，就能找出所有和学生相关的 no 和 degree ： SELECTs_no,c_no,degreeFROMscore;+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-105|92||103|3-245|86||103|6-166|85||105|3-105|88||105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+ 然后查询 course 表： +-------+-----------------+|no|name|+-------+-----------------+|3-105|计算机导论||3-245|操作系统||6-166|数字电路||9-888|高等数学|+-------+-----------------+ 只要把 score 表中的 c_no 替换成 course 表中对应的 name 字段值就可以了。 -- 增加一个查询字段 name，分别从 score、course 这两个表中查询。 -- as 表示取一个该字段的别名。 SELECTs_no,nameasc_name,degreeFROMscore,courseWHEREscore.c_no=course.no;+------+-----------------+--------+|s_no|c_name|degree|+------+-----------------+--------+|103|计算机导论|92||105|计算机导论|88||109|计算机导论|76||103|操作系统|86||105|操作系统|75||109|操作系统|68||103|数字电路|85||105|数字电路|79||109|数字电路|81|+------+-----------------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:6","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"三表关联查询 查询所有学生的 name 、课程名 ( course 表中的 name ) 和 degree 。 只有 score 表中关联学生的学号和课堂号，我们只要围绕着 score 这张表查询就好了。 SELECT*FROMscore;+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-105|92||103|3-245|86||103|6-166|85||105|3-105|88||105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+ 只要把 s_no 和 c_no 替换成 student 和 srouse 表中对应的 name 字段值就好了。 首先把 s_no 替换成 student 表中的 name 字段： SELECTname,c_no,degreeFROMstudent,scoreWHEREstudent.no=score.s_no;+-----------+-------+--------+|name|c_no|degree|+-----------+-------+--------+|王丽|3-105|92||王丽|3-245|86||王丽|6-166|85||王芳|3-105|88||王芳|3-245|75||王芳|6-166|79||赵铁柱|3-105|76||赵铁柱|3-245|68||赵铁柱|6-166|81|+-----------+-------+--------+ 再把 c_no 替换成 course 表中的 name 字段： -- 课程表 SELECTno,nameFROMcourse;+-------+-----------------+|no|name|+-------+-----------------+|3-105|计算机导论||3-245|操作系统||6-166|数字电路||9-888|高等数学|+-------+-----------------+-- 由于字段名存在重复，使用 \"表名.字段名 as 别名\" 代替。 SELECTstudent.nameass_name,course.nameasc_name,degreeFROMstudent,score,courseWHEREstudent.NO=score.s_noANDscore.c_no=course.no; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:7","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询加分组求平均分 查询 95031 班学生每门课程的平均成绩。 在 score 表中根据 student 表的学生编号筛选出学生的课堂号和成绩： -- IN (..): 将筛选出的学生号当做 s_no 的条件查询 SELECTs_no,c_no,degreeFROMscoreWHEREs_noIN(SELECTnoFROMstudentWHEREclass='95031');+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|105|3-105|88||105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+ 这时只要将 c_no 分组一下就能得出 95031 班学生每门课的平均成绩： SELECTc_no,AVG(degree)FROMscoreWHEREs_noIN(SELECTnoFROMstudentWHEREclass='95031')GROUPBYc_no;+-------+-------------+|c_no|AVG(degree)|+-------+-------------+|3-105|82.0000||3-245|71.5000||6-166|80.0000|+-------+-------------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:8","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 1 查询在 3-105 课程中，所有成绩高于 109 号同学的记录。 首先筛选出课堂号为 3-105 ，在找出所有成绩高于 109 号同学的的行。 SELECT*FROMscoreWHEREc_no='3-105'ANDdegree\u003e(SELECTdegreeFROMscoreWHEREs_no='109'ANDc_no='3-105'); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:9","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 2 查询所有成绩高于 109 号同学的 3-105 课程成绩记录。 -- 不限制课程号，只要成绩大于109号同学的3-105课程成绩就可以。 SELECT*FROMscoreWHEREdegree\u003e(SELECTdegreeFROMscoreWHEREs_no='109'ANDc_no='3-105'); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:10","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"YEAR 函数与带 IN 关键字查询 查询所有和 101 、108 号学生同年出生的 no 、name 、birthday 列。 -- YEAR(..): 取出日期中的年份 SELECTno,name,birthdayFROMstudentWHEREYEAR(birthday)IN(SELECTYEAR(birthday)FROMstudentWHEREnoIN(101,108)); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:11","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"多层嵌套子查询 查询 '张旭' 教师任课的学生成绩表。 首先找到教师编号： SELECTNOFROMteacherWHERENAME='张旭' 通过 sourse 表找到该教师课程号： SELECTNOFROMcourseWHEREt_no=(SELECTNOFROMteacherWHERENAME='张旭'); 通过筛选出的课程号查询成绩表： SELECT*FROMscoreWHEREc_no=(SELECTnoFROMcourseWHEREt_no=(SELECTnoFROMteacherWHERENAME='张旭')); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:12","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"多表查询 查询某选修课程多于5个同学的教师姓名。 首先在 teacher 表中，根据 no 字段来判断该教师的同一门课程是否有至少5名学员选修： -- 查询 teacher 表 SELECTno,nameFROMteacher;+-----+--------+|no|name|+-----+--------+|804|李诚||825|王萍||831|刘冰||856|张旭|+-----+--------+SELECTnameFROMteacherWHEREnoIN(-- 在这里找到对应的条件 ); 查看和教师编号有有关的表的信息： SELECT*FROMcourse;-- t_no: 教师编号 +-------+-----------------+------+|no|name|t_no|+-------+-----------------+------+|3-105|计算机导论|825||3-245|操作系统|804||6-166|数字电路|856||9-888|高等数学|831|+-------+-----------------+------+ 我们已经找到和教师编号有关的字段就在 course 表中，但是还无法知道哪门课程至少有5名学生选修，所以还需要根据 score 表来查询： -- 在此之前向 score 插入一些数据，以便丰富查询条件。 INSERTINTOscoreVALUES('101','3-105','90');INSERTINTOscoreVALUES('102','3-105','91');INSERTINTOscoreVALUES('104','3-105','89');-- 查询 score 表 SELECT*FROMscore;+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|101|3-105|90||102|3-105|91||103|3-105|92||103|3-245|86||103|6-166|85||104|3-105|89||105|3-105|88||105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+-- 在 score 表中将 c_no 作为分组，并且限制 c_no 持有至少 5 条数据。 SELECTc_noFROMscoreGROUPBYc_noHAVINGCOUNT(*)\u003e5;+-------+|c_no|+-------+|3-105|+-------+ 根据筛选出来的课程号，找出在某课程中，拥有至少5名学员的教师编号： SELECTt_noFROMcourseWHEREnoIN(SELECTc_noFROMscoreGROUPBYc_noHAVINGCOUNT(*)\u003e5);+------+|t_no|+------+|825|+------+ 在 teacher 表中，根据筛选出来的教师编号找到教师姓名： SELECTnameFROMteacherWHEREnoIN(-- 最终条件 SELECTt_noFROMcourseWHEREnoIN(SELECTc_noFROMscoreGROUPBYc_noHAVINGCOUNT(*)\u003e5)); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:13","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 3 查询 “计算机系” 课程的成绩表。 思路是，先找出 course 表中所有 计算机系 课程的编号，然后根据这个编号查询 score 表。 -- 通过 teacher 表查询所有 `计算机系` 的教师编号 SELECTno,name,departmentFROMteacherWHEREdepartment='计算机系'+-----+--------+--------------+|no|name|department|+-----+--------+--------------+|804|李诚|计算机系||825|王萍|计算机系|+-----+--------+--------------+-- 通过 course 表查询该教师的课程编号 SELECTnoFROMcourseWHEREt_noIN(SELECTnoFROMteacherWHEREdepartment='计算机系');+-------+|no|+-------+|3-245||3-105|+-------+-- 根据筛选出来的课程号查询成绩表 SELECT*FROMscoreWHEREc_noIN(SELECTnoFROMcourseWHEREt_noIN(SELECTnoFROMteacherWHEREdepartment='计算机系'));+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-245|86||105|3-245|75||109|3-245|68||101|3-105|90||102|3-105|91||103|3-105|92||104|3-105|89||105|3-105|88||109|3-105|76|+------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:14","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"UNION 和 NOTIN 的使用 查询 计算机系 与 电子工程系 中的不同职称的教师。 -- NOT: 代表逻辑非 SELECT*FROMteacherWHEREdepartment='计算机系'ANDprofessionNOTIN(SELECTprofessionFROMteacherWHEREdepartment='电子工程系')-- 合并两个集 UNIONSELECT*FROMteacherWHEREdepartment='电子工程系'ANDprofessionNOTIN(SELECTprofessionFROMteacherWHEREdepartment='计算机系'); ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:15","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"ANY 表示至少一个 - DESC ( 降序 ) 查询课程 3-105 且成绩 至少 高于 3-245 的 score 表。 SELECT*FROMscoreWHEREc_no='3-105';+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|101|3-105|90||102|3-105|91||103|3-105|92||104|3-105|89||105|3-105|88||109|3-105|76|+------+-------+--------+SELECT*FROMscoreWHEREc_no='3-245';+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-245|86||105|3-245|75||109|3-245|68|+------+-------+--------+-- ANY: 符合SQL语句中的任意条件。 -- 也就是说，在 3-105 成绩中，只要有一个大于从 3-245 筛选出来的任意行就符合条件， -- 最后根据降序查询结果。 SELECT*FROMscoreWHEREc_no='3-105'ANDdegree\u003eANY(SELECTdegreeFROMscoreWHEREc_no='3-245')ORDERBYdegreeDESC;+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-105|92||102|3-105|91||101|3-105|90||104|3-105|89||105|3-105|88||109|3-105|76|+------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:16","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"表示所有的 ALL 查询课程 3-105 且成绩高于 3-245 的 score 表。 -- 只需对上一道题稍作修改。 -- ALL: 符合SQL语句中的所有条件。 -- 也就是说，在 3-105 每一行成绩中，都要大于从 3-245 筛选出来全部行才算符合条件。 SELECT*FROMscoreWHEREc_no='3-105'ANDdegree\u003eALL(SELECTdegreeFROMscoreWHEREc_no='3-245');+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|101|3-105|90||102|3-105|91||103|3-105|92||104|3-105|89||105|3-105|88|+------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:17","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"复制表的数据作为条件查询 查询某课程成绩比该课程平均成绩低的 score 表。 -- 查询平均分 SELECTc_no,AVG(degree)FROMscoreGROUPBYc_no;+-------+-------------+|c_no|AVG(degree)|+-------+-------------+|3-105|87.6667||3-245|76.3333||6-166|81.6667|+-------+-------------+-- 查询 score 表 SELECTdegreeFROMscore;+--------+|degree|+--------+|90||91||92||86||85||89||88||75||79||76||68||81|+--------+-- 将表 b 作用于表 a 中查询数据 -- score a (b): 将表声明为 a (b)， -- 如此就能用 a.c_no = b.c_no 作为条件执行查询了。 SELECT*FROMscoreaWHEREdegree\u003c((SELECTAVG(degree)FROMscorebWHEREa.c_no=b.c_no));+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|105|3-245|75||105|6-166|79||109|3-105|76||109|3-245|68||109|6-166|81|+------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:18","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 4 查询所有任课 ( 在 course 表里有课程 ) 教师的 name 和 department 。 SELECTname,departmentFROMteacherWHEREnoIN(SELECTt_noFROMcourse);+--------+-----------------+|name|department|+--------+-----------------+|李诚|计算机系||王萍|计算机系||刘冰|电子工程系||张旭|电子工程系|+--------+-----------------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:19","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"条件加组筛选 查询 student 表中至少有 2 名男生的 class 。 -- 查看学生表信息 SELECT*FROMstudent;+-----+-----------+-----+------------+-------+|no|name|sex|birthday|class|+-----+-----------+-----+------------+-------+|101|曾华|男|1977-09-01|95033||102|匡明|男|1975-10-02|95031||103|王丽|女|1976-01-23|95033||104|李军|男|1976-02-20|95033||105|王芳|女|1975-02-10|95031||106|陆军|男|1974-06-03|95031||107|王尼玛|男|1976-02-20|95033||108|张全蛋|男|1975-02-10|95031||109|赵铁柱|男|1974-06-03|95031||110|张飞|男|1974-06-03|95038|+-----+-----------+-----+------------+-------+-- 只查询性别为男，然后按 class 分组，并限制 class 行大于 1。 SELECTclassFROMstudentWHEREsex='男'GROUPBYclassHAVINGCOUNT(*)\u003e1;+-------+|class|+-------+|95033||95031|+-------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:20","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"NOTLIKE 模糊查询取反 查询 student 表中不姓 “王” 的同学记录。 -- NOT: 取反 -- LIKE: 模糊查询 mysql\u003eSELECT*FROMstudentWHEREnameNOTLIKE'王%';+-----+-----------+-----+------------+-------+|no|name|sex|birthday|class|+-----+-----------+-----+------------+-------+|101|曾华|男|1977-09-01|95033||102|匡明|男|1975-10-02|95031||104|李军|男|1976-02-20|95033||106|陆军|男|1974-06-03|95031||108|张全蛋|男|1975-02-10|95031||109|赵铁柱|男|1974-06-03|95031||110|张飞|男|1974-06-03|95038|+-----+-----------+-----+------------+-------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:21","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"YEAR 与 NOW 函数 查询 student 表中每个学生的姓名和年龄。 -- 使用函数 YEAR(NOW()) 计算出当前年份，减去出生年份后得出年龄。 SELECTname,YEAR(NOW())-YEAR(birthday)asageFROMstudent;+-----------+------+|name|age|+-----------+------+|曾华|42||匡明|44||王丽|43||李军|43||王芳|44||陆军|45||王尼玛|43||张全蛋|44||赵铁柱|45||张飞|45|+-----------+------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:22","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"MAX 与 MIN 函数 查询 student 表中最大和最小的 birthday 值。 SELECTMAX(birthday),MIN(birthday)FROMstudent;+---------------+---------------+|MAX(birthday)|MIN(birthday)|+---------------+---------------+|1977-09-01|1974-06-03|+---------------+---------------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:23","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"多段排序 以 class 和 birthday 从大到小的顺序查询 student 表。 SELECT*FROMstudentORDERBYclassDESC,birthday;+-----+-----------+-----+------------+-------+|no|name|sex|birthday|class|+-----+-----------+-----+------------+-------+|110|张飞|男|1974-06-03|95038||103|王丽|女|1976-01-23|95033||104|李军|男|1976-02-20|95033||107|王尼玛|男|1976-02-20|95033||101|曾华|男|1977-09-01|95033||106|陆军|男|1974-06-03|95031||109|赵铁柱|男|1974-06-03|95031||105|王芳|女|1975-02-10|95031||108|张全蛋|男|1975-02-10|95031||102|匡明|男|1975-10-02|95031|+-----+-----------+-----+------------+-------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:24","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 5 查询 “男” 教师及其所上的课程。 SELECT*FROMcourseWHEREt_noin(SELECTnoFROMteacherWHEREsex='男');+-------+--------------+------+|no|name|t_no|+-------+--------------+------+|3-245|操作系统|804||6-166|数字电路|856|+-------+--------------+------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:25","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"MAX 函数与子查询 查询最高分同学的 score 表。 -- 找出最高成绩（该查询只能有一个结果） SELECTMAX(degree)FROMscore;-- 根据上面的条件筛选出所有最高成绩表， -- 该查询可能有多个结果，假设 degree 值多次符合条件。 SELECT*FROMscoreWHEREdegree=(SELECTMAX(degree)FROMscore);+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|103|3-105|92|+------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:26","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 6 查询和 “李军” 同性别的所有同学 name 。 -- 首先将李军的性别作为条件取出来 SELECTsexFROMstudentWHEREname='李军';+-----+|sex|+-----+|男|+-----+-- 根据性别查询 name 和 sex SELECTname,sexFROMstudentWHEREsex=(SELECTsexFROMstudentWHEREname='李军');+-----------+-----+|name|sex|+-----------+-----+|曾华|男||匡明|男||李军|男||陆军|男||王尼玛|男||张全蛋|男||赵铁柱|男||张飞|男|+-----------+-----+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:27","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 7 查询和 “李军” 同性别且同班的同学 name 。 SELECTname,sex,classFROMstudentWHEREsex=(SELECTsexFROMstudentWHEREname='李军')ANDclass=(SELECTclassFROMstudentWHEREname='李军');+-----------+-----+-------+|name|sex|class|+-----------+-----+-------+|曾华|男|95033||李军|男|95033||王尼玛|男|95033|+-----------+-----+-------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:28","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"子查询 - 8 查询所有选修 “计算机导论” 课程的 “男” 同学成绩表。 需要的 “计算机导论” 和性别为 “男” 的编号可以在 course 和 student 表中找到。 SELECT*FROMscoreWHEREc_no=(SELECTnoFROMcourseWHEREname='计算机导论')ANDs_noIN(SELECTnoFROMstudentWHEREsex='男');+------+-------+--------+|s_no|c_no|degree|+------+-------+--------+|101|3-105|90||102|3-105|91||104|3-105|89||109|3-105|76|+------+-------+--------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:29","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"按等级查询 建立一个 grade 表代表学生的成绩等级，并插入数据： CREATETABLEgrade(lowINT(3),uppINT(3),gradechar(1));INSERTINTOgradeVALUES(90,100,'A');INSERTINTOgradeVALUES(80,89,'B');INSERTINTOgradeVALUES(70,79,'C');INSERTINTOgradeVALUES(60,69,'D');INSERTINTOgradeVALUES(0,59,'E');SELECT*FROMgrade;+------+------+-------+|low|upp|grade|+------+------+-------+|90|100|A||80|89|B||70|79|C||60|69|D||0|59|E|+------+------+-------+ 查询所有学生的 s_no 、c_no 和 grade 列。 思路是，使用区间 ( BETWEEN ) 查询，判断学生的成绩 ( degree ) 在 grade 表的 low 和 upp 之间。 SELECTs_no,c_no,gradeFROMscore,gradeWHEREdegreeBETWEENlowANDupp;+------+-------+-------+|s_no|c_no|grade|+------+-------+-------+|101|3-105|A||102|3-105|A||103|3-105|A||103|3-245|B||103|6-166|B||104|3-105|B||105|3-105|B||105|3-245|C||105|6-166|C||109|3-105|C||109|3-245|D||109|6-166|B|+------+-------+-------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:30","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"连接查询 准备用于测试连接查询的数据： CREATEDATABASEtestJoin;CREATETABLEperson(idINT,nameVARCHAR(20),cardIdINT);CREATETABLEcard(idINT,nameVARCHAR(20));INSERTINTOcardVALUES(1,'饭卡'),(2,'建行卡'),(3,'农行卡'),(4,'工商卡'),(5,'邮政卡');SELECT*FROMcard;+------+-----------+|id|name|+------+-----------+|1|饭卡||2|建行卡||3|农行卡||4|工商卡||5|邮政卡|+------+-----------+INSERTINTOpersonVALUES(1,'张三',1),(2,'李四',3),(3,'王五',6);SELECT*FROMperson;+------+--------+--------+|id|name|cardId|+------+--------+--------+|1|张三|1||2|李四|3||3|王五|6|+------+--------+--------+ 分析两张表发现，person 表并没有为 cardId 字段设置一个在 card 表中对应的 id 外键。如果设置了的话，person 中 cardId 字段值为 6 的行就插不进去，因为该 cardId 值在 card 表中并没有。 内连接 要查询这两张表中有关系的数据，可以使用 INNER JOIN ( 内连接 ) 将它们连接在一起。 -- INNER JOIN: 表示为内连接，将两张表拼接在一起。 -- on: 表示要执行某个条件。 SELECT*FROMpersonINNERJOINcardonperson.cardId=card.id;+------+--------+--------+------+-----------+|id|name|cardId|id|name|+------+--------+--------+------+-----------+|1|张三|1|1|饭卡||2|李四|3|3|农行卡|+------+--------+--------+------+-----------+-- 将 INNER 关键字省略掉，结果也是一样的。 -- SELECT * FROM person JOIN card on person.cardId = card.id; 注意：card 的整张表被连接到了右边。 左外连接 完整显示左边的表 ( person ) ，右边的表如果符合条件就显示，不符合则补 NULL 。 -- LEFT JOIN 也叫做 LEFT OUTER JOIN，用这两种方式的查询结果是一样的。 SELECT*FROMpersonLEFTJOINcardonperson.cardId=card.id;+------+--------+--------+------+-----------+|id|name|cardId|id|name|+------+--------+--------+------+-----------+|1|张三|1|1|饭卡||2|李四|3|3|农行卡||3|王五|6|NULL|NULL|+------+--------+--------+------+-----------+ 右外链接 完整显示右边的表 ( card ) ，左边的表如果符合条件就显示，不符合则补 NULL 。 SELECT*FROMpersonRIGHTJOINcardonperson.cardId=card.id;+------+--------+--------+------+-----------+|id|name|cardId|id|name|+------+--------+--------+------+-----------+|1|张三|1|1|饭卡||2|李四|3|3|农行卡||NULL|NULL|NULL|2|建行卡||NULL|NULL|NULL|4|工商卡||NULL|NULL|NULL|5|邮政卡|+------+--------+--------+------+-----------+ 全外链接 完整显示两张表的全部数据。 -- MySQL 不支持这种语法的全外连接 -- SELECT * FROM person FULL JOIN card on person.cardId = card.id; -- 出现错误： -- ERROR 1054 (42S22): Unknown column 'person.cardId' in 'on clause' -- MySQL全连接语法，使用 UNION 将两张表合并在一起。 SELECT*FROMpersonLEFTJOINcardonperson.cardId=card.idUNIONSELECT*FROMpersonRIGHTJOINcardonperson.cardId=card.id;+------+--------+--------+------+-----------+|id|name|cardId|id|name|+------+--------+--------+------+-----------+|1|张三|1|1|饭卡||2|李四|3|3|农行卡||3|王五|6|NULL|NULL||NULL|NULL|NULL|2|建行卡||NULL|NULL|NULL|4|工商卡||NULL|NULL|NULL|5|邮政卡|+------+--------+--------+------+-----------+ ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:5:31","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"事务 在 MySQL 中，事务其实是一个最小的不可分割的工作单元。事务能够保证一个业务的完整性。 比如我们的银行转账： -- a -\u003e -100 UPDATEusersetmoney=money-100WHEREname='a';-- b -\u003e +100 UPDATEusersetmoney=money+100WHEREname='b'; 在实际项目中，假设只有一条 SQL 语句执行成功，而另外一条执行失败了，就会出现数据前后不一致。 因此，在执行多条有关联 SQL 语句时，事务可能会要求这些 SQL 语句要么同时执行成功，要么就都执行失败。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:6:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"如何控制事务 - COMMIT / ROLLBACK 在 MySQL 中，事务的自动提交状态默认是开启的。 -- 查询事务的自动提交状态 SELECT@@AUTOCOMMIT;+--------------+|@@AUTOCOMMIT|+--------------+|1|+--------------+ 自动提交的作用：当我们执行一条 SQL 语句的时候，其产生的效果就会立即体现出来，且不能回滚。 什么是回滚？举个例子： CREATEDATABASEbank;USEbank;CREATETABLEuser(idINTPRIMARYKEY,nameVARCHAR(20),moneyINT);INSERTINTOuserVALUES(1,'a',1000);SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000|+----+------+-------+ 可以看到，在执行插入语句后数据立刻生效，原因是 MySQL 中的事务自动将它提交到了数据库中。那么所谓回滚的意思就是，撤销执行过的所有 SQL 语句，使其回滚到最后一次提交数据时的状态。 在 MySQL 中使用 ROLLBACK 执行回滚： -- 回滚到最后一次提交 ROLLBACK;SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000|+----+------+-------+ 由于所有执行过的 SQL 语句都已经被提交过了，所以数据并没有发生回滚。那如何让数据可以发生回滚？ -- 关闭自动提交 SETAUTOCOMMIT=0;-- 查询自动提交状态 SELECT@@AUTOCOMMIT;+--------------+|@@AUTOCOMMIT|+--------------+|0|+--------------+ 将自动提交关闭后，测试数据回滚： INSERTINTOuserVALUES(2,'b',1000);-- 关闭 AUTOCOMMIT 后，数据的变化是在一张虚拟的临时数据表中展示， -- 发生变化的数据并没有真正插入到数据表中。 SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000||2|b|1000|+----+------+-------+-- 数据表中的真实数据其实还是： +----+------+-------+|id|name|money|+----+------+-------+|1|a|1000|+----+------+-------+-- 由于数据还没有真正提交，可以使用回滚 ROLLBACK;-- 再次查询 SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000|+----+------+-------+ 那如何将虚拟的数据真正提交到数据库中？使用 COMMIT : INSERTINTOuserVALUES(2,'b',1000);-- 手动提交数据（持久性）， -- 将数据真正提交到数据库中，执行后不能再回滚提交过的数据。 COMMIT;-- 提交后测试回滚 ROLLBACK;-- 再次查询（回滚无效了） SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000||2|b|1000|+----+------+-------+ 总结 自动提交 查看自动提交状态：SELECT @@AUTOCOMMIT ； 设置自动提交状态：SET AUTOCOMMIT = 0 。 手动提交 @@AUTOCOMMIT = 0 时，使用 COMMIT 命令提交事务。 事务回滚 @@AUTOCOMMIT = 0 时，使用 ROLLBACK 命令回滚事务。 事务的实际应用，让我们再回到银行转账项目： -- 转账 UPDATEusersetmoney=money-100WHEREname='a';-- 到账 UPDATEusersetmoney=money+100WHEREname='b';SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|900||2|b|1100|+----+------+-------+ 这时假设在转账时发生了意外，就可以使用 ROLLBACK 回滚到最后一次提交的状态： -- 假设转账发生了意外，需要回滚。 ROLLBACK;SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000||2|b|1000|+----+------+-------+ 这时我们又回到了发生意外之前的状态，也就是说，事务给我们提供了一个可以反悔的机会。假设数据没有发生意外，这时可以手动将数据真正提交到数据表中：COMMIT 。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:6:1","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"手动开启事务 - BEGIN / START TRANSACTION 事务的默认提交被开启 ( @@AUTOCOMMIT = 1 ) 后，此时就不能使用事务回滚了。但是我们还可以手动开启一个事务处理事件，使其可以发生回滚： -- 使用 BEGIN 或者 START TRANSACTION 手动开启一个事务 -- START TRANSACTION; BEGIN;UPDATEusersetmoney=money-100WHEREname='a';UPDATEusersetmoney=money+100WHEREname='b';-- 由于手动开启的事务没有开启自动提交， -- 此时发生变化的数据仍然是被保存在一张临时表中。 SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|900||2|b|1100|+----+------+-------+-- 测试回滚 ROLLBACK;SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|1000||2|b|1000|+----+------+-------+ 仍然使用 COMMIT 提交数据，提交后无法再发生本次事务的回滚。 BEGIN;UPDATEusersetmoney=money-100WHEREname='a';UPDATEusersetmoney=money+100WHEREname='b';SELECT*FROMuser;+----+------+-------+|id|name|money|+----+------+-------+|1|a|900||2|b|1100|+----+------+-------+-- 提交数据 COMMIT;-- 测试回滚（无效，因为表的数据已经被提交） ROLLBACK; ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:6:2","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"事务的 ACID 特征与使用 事务的四大特征： A 原子性：事务是最小的单位，不可以再分割； C 一致性：要求同一事务中的 SQL 语句，必须保证同时成功或者失败； I 隔离性：事务1 和 事务2 之间是具有隔离性的； D 持久性：事务一旦结束 ( COMMIT ) ，就不可以再返回了 ( ROLLBACK ) 。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:6:3","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"事务的隔离性 事务的隔离性可分为四种 ( 性能从低到高 ) ： READ UNCOMMITTED ( 读取未提交 ) 如果有多个事务，那么任意事务都可以看见其他事务的未提交数据。 READ COMMITTED ( 读取已提交 ) 只能读取到其他事务已经提交的数据。 REPEATABLE READ ( 可被重复读 ) 如果有多个连接都开启了事务，那么事务之间不能共享数据记录，否则只能共享已提交的记录。 SERIALIZABLE ( 串行化 ) 所有的事务都会按照固定顺序执行，执行完一个事务后再继续执行下一个事务的写入操作。 查看当前数据库的默认隔离级别： -- MySQL 8.x, GLOBAL 表示系统级别，不加表示会话级别。 SELECT@@GLOBAL.TRANSACTION_ISOLATION;SELECT@@TRANSACTION_ISOLATION;+--------------------------------+|@@GLOBAL.TRANSACTION_ISOLATION|+--------------------------------+|REPEATABLE-READ|-- MySQL的默认隔离级别，可以重复读。 +--------------------------------+-- MySQL 5.x SELECT@@GLOBAL.TX_ISOLATION;SELECT@@TX_ISOLATION; 修改隔离级别： -- 设置系统隔离级别，LEVEL 后面表示要设置的隔离级别 (READ UNCOMMITTED)。 SETGLOBALTRANSACTIONISOLATIONLEVELREADUNCOMMITTED;-- 查询系统隔离级别，发现已经被修改。 SELECT@@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+|@@GLOBAL.TRANSACTION_ISOLATION|+--------------------------------+|READ-UNCOMMITTED|+--------------------------------+ 脏读 测试 READ UNCOMMITTED ( 读取未提交 ) 的隔离性： INSERTINTOuserVALUES(3,'小明',1000);INSERTINTOuserVALUES(4,'淘宝店',1000);SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|1000||4|淘宝店|1000|+----+-----------+-------+-- 开启一个事务操作数据 -- 假设小明在淘宝店买了一双800块钱的鞋子： STARTTRANSACTION;UPDATEuserSETmoney=money-800WHEREname='小明';UPDATEuserSETmoney=money+800WHEREname='淘宝店';-- 然后淘宝店在另一方查询结果，发现钱已到账。 SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|200||4|淘宝店|1800|+----+-----------+-------+ 由于小明的转账是在新开启的事务上进行操作的，而该操作的结果是可以被其他事务（另一方的淘宝店）看见的，因此淘宝店的查询结果是正确的，淘宝店确认到账。但就在这时，如果小明在它所处的事务上又执行了 ROLLBACK 命令，会发生什么？ -- 小明所处的事务 ROLLBACK;-- 此时无论对方是谁，如果再去查询结果就会发现： SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|1000||4|淘宝店|1000|+----+-----------+-------+ 这就是所谓的脏读，一个事务读取到另外一个事务还未提交的数据。这在实际开发中是不允许出现的。 读取已提交 把隔离级别设置为 READ COMMITTED ： SETGLOBALTRANSACTIONISOLATIONLEVELREADCOMMITTED;SELECT@@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+|@@GLOBAL.TRANSACTION_ISOLATION|+--------------------------------+|READ-COMMITTED|+--------------------------------+ 这样，再有新的事务连接进来时，它们就只能查询到已经提交过的事务数据了。但是对于当前事务来说，它们看到的还是未提交的数据，例如： -- 正在操作数据事务（当前事务） STARTTRANSACTION;UPDATEuserSETmoney=money-800WHEREname='小明';UPDATEuserSETmoney=money+800WHEREname='淘宝店';-- 虽然隔离级别被设置为了 READ COMMITTED，但在当前事务中， -- 它看到的仍然是数据表中临时改变数据，而不是真正提交过的数据。 SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|200||4|淘宝店|1800|+----+-----------+-------+-- 假设此时在远程开启了一个新事务，连接到数据库。 $mysql-uroot-p12345612-- 此时远程连接查询到的数据只能是已经提交过的 SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|1000||4|淘宝店|1000|+----+-----------+-------+ 但是这样还有问题，那就是假设一个事务在操作数据时，其他事务干扰了这个事务的数据。例如： -- 小张在查询数据的时候发现： SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|200||4|淘宝店|1800|+----+-----------+-------+-- 在小张求表的 money 平均值之前，小王做了一个操作： STARTTRANSACTION;INSERTINTOuserVALUES(5,'c',100);COMMIT;-- 此时表的真实数据是： SELECT*FROMuser;+----+-----------+-------+|id|name|money|+----+-----------+-------+|1|a|900||2|b|1100||3|小明|1000||4|淘宝店|1000||5|c|100|+----+-----------+-------+-- 这时小张再求平均值的时候，就会出现计算不相符合的情况： SELECTAVG(money)FROMuser;+------------+|AVG(money)|+------------+|820.0000|+------------+ 虽然 READ COMMITTED 让我们只能读取到其他事务已经提交的数据，但还是会出现问题，就是在读取同一个表的数据时，可能会发生前后不一致的情况。这被称为不可重复读现象 ( READ COMMITTED ) 。 幻读 将隔离级别设置为 REPEATABLE READ ( 可被重复读取 ) : SETGLOBALTRANSACTIONISOLATIONLEVELREPEATABLEREAD;SELECT@@GLOBAL.TRANSACTION_ISOLATION;+--------------------------------+|@@GLOBAL.TRANSACTION_ISOLATION|+--------------------------------+|REPEATABLE-READ|+--------------------------------+ 测试 REPEATABLE READ ，假设在两个不同的连接上分别执行 START TRANSACTION : -- 小张 - 成都 STARTTRANSACTION;INSERTINTOuserVALUES(6,'d',1000);-- 小王 - 北京 STARTTRANSACTION;-- 小张 - 成都 COMMIT; 当前事务开启后，没提交之前，查询不到，提交后可以被查询到。但是，在提交之前其他事务被开启了，那么在这条事务线上，就不会查询到当前有操作事务的连接。","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:6:4","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"索引优化 所谓索引就是为特定的 mysql 字段进行一些特定的算法排序，比如二叉树的算法和哈希算法 哈希算法是通过建立特征值，然后根据特征值来快速查找。 而用的最多，并且是 mysql 默认的就是二叉树算法 BTREE，通过 BTREE 算法建立索引的字段，比如扫描 20 行就能得到未使用 BTREE 前扫描了 2^20^ 行的结果。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:7:0","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"索引的类型 UNIQUE 唯一索引 不可以出现相同的值，可以有 NULL 值。 INDEX 普通索引 允许出现相同的索引内容。 PRIMARY KEY 主键索引 不允许出现相同的值，且不能为 NULL 值，一个表只能有一个 primary_key 索引。 fulltext index 全文索引 上述三种索引都是针对列的值发挥作用，但全文索引，可以针对值中的某个单词，比如一篇文章中的某个词，然而并没有什么卵用，因为只有 myisam 以及英文支持，并且效率让人不敢恭维 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:7:1","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"索引的相关操作 索引的创建 ALTER TABLE 适用于表创建完毕之后再添加。 ALTER TABLE 表名 ADD 索引类型 (unique,primary key,fulltext,index)[索引名](字段名) ALTERTABLE`table_name`ADDINDEX`index_name`(`column_list`)-- 索引名，可要可不要；如果不要，当前的索引名就是该字段名。 ALTERTABLE`table_name`ADDUNIQUE(`column_list`)ALTERTABLE`table_name`ADDPRIMARYKEY(`column_list`)ALTERTABLE`table_name`ADDFULLTEXTKEY(`column_list`) CREATE INDEX CREATE INDEX 可对表增加普通索引或 UNIQUE 索引。 --例：只能添加这两种索引 CREATEINDEXindex_nameONtable_name(column_list)CREATEUNIQUEINDEXindex_nameONtable_name(column_list) 另外，还可以在建表时添加： CREATETABLE`test1`(`id`smallint(5)UNSIGNEDAUTO_INCREMENTNOTNULL,-- 注意，下面创建了主键索引，这里就不用创建了 `username`varchar(64)NOTNULLCOMMENT'用户名',`nickname`varchar(50)NOTNULLCOMMENT'昵称/姓名',`intro`text,PRIMARYKEY(`id`),UNIQUEKEY`unique1`(`username`),-- 索引名称，可要可不要，不要就是和列名一样 KEY`index1`(`nickname`),FULLTEXTKEY`intro`(`intro`))ENGINE=MyISAMAUTO_INCREMENT=4DEFAULTCHARSET=utf8COMMENT='后台用户表'; 索引的删除 DROPINDEX`index_name`ON`talbe_name`ALTERTABLE`table_name`DROPINDEX`index_name`-- 这两句都是等价的,都是删除掉table_name中的索引index_name; ALTERTABLE`table_name`DROPPRIMARYKEY-- 删除主键索引，注意主键索引只能用这种方式删除 索引的查看 showindexfromtablename; 索引的更改 更改个毛线，删掉重建一个既可 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:7:2","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"创建索引的技巧 维度高的列创建索引。 数据列中不重复值出现的个数，这个数量越高，维度就越高。 如数据表中存在 8 行数据 a, b ,c, d, a, b ,c ,d 这个表的维度为 4。 要为维度高的列创建索引，如性别和年龄，那年龄的维度就高于性别。 性别这样的列不适合创建索引，因为维度过低。 对 where, on, group by, order by 中出现的列使用索引。 对较小的数据列使用索引，这样会使索引文件更小，同时内存中也可以装载更多的索引键。 为较长的字符串使用前缀索引。 不要过多创建索引，除了增加额外的磁盘空间外，对于DML操作的速度影响很大，因为其每增删改一次就得从新建立索引。 使用组合索引，可以减少文件索引大小，在使用时速度要优于多个单列索引。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:7:3","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"组合索引 ALTERTABLE`myIndex`ADDINDEX`name_city_age`(vc_Name(10),vc_City,i_Age); 上述的步骤就是将 vc_Name,vc_City,i_Age 建到一个索引里 这样一来，在执行这条 SQL 查询语句时： SELECT`i_testID`FROM`myIndex`WHERE`vc_Name`='erquan'AND`vc_City`='郑州'AND`i_Age`=25;-- 关联搜索; 查询速度会比只建立某一个字段的单独索引要快得多 如果分别在 vc_Name, vc_City, i_Age 上建立单列索引，让该表有 3 个单列索引，查询的速度将远远低于组合索引。 虽然此时有了三个索引，但 MySQL 只能用到其中的那个它认为似乎是最有效率的单列索引，另外两个是用不到的，也就是说还是一个全表扫描的过程。 建立这样的组合索引，其实是相当于分别建立了： vc_Name,vc_City,i_Age vc_Name,vc_City vc_Name 为什么没有 vc_City,i_Age 等这样的组合索引呢？这是因为 mysql 组合索引 “最左前缀” 的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个 T-SQL 会用到： SELECT*FROMmyIndexWHREEvc_Name=”erquan”ANDvc_City=”郑州”SELECT*FROMmyIndexWHREEvc_Name=”erquan” 而下面几个则不会用到： SELECT*FROMmyIndexWHREEi_Age=20ANDvc_City=”郑州”SELECT*FROMmyIndexWHREEvc_City=”郑州” 也就是，name_city_age(vc_Name(10),vc_City,i_Age) 会从左到右进行索引，如果没有左前索引，Mysql 不执行索引查询。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:7:4","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["数据库"],"content":"前缀索引 如果索引列长度过长，这种列索引时将会产生很大的索引文件，不便于操作，可以使用前缀索引方式进行索引前缀索引应该控制在一个合适的点，控制在 0.31 黄金值即可（大于这个值就可以创建）。 SELECTCOUNT(DISTINCT(LEFT(`title`,10)))/COUNT(*)FROMArctic; 这个值大于 0.31 就可以创建前缀索引，Distinct 去重复 ALTERTABLE`user`ADDINDEX`uname`(title(10)); 增加前缀索引 SQL，将人名的索引建立在 10，这样可以减少索引文件大小，加快索引查询速度。 ","date":"2021-12-23","objectID":"/Notes/posts/database/mysql/:7:5","tags":["数据库","快速入门","MySQL"],"title":"关于 MySQL 的一些笔记","uri":"/Notes/posts/database/mysql/"},{"categories":["刷题"],"content":"55. 跳跃游戏 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 ","date":"2022-03-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/:0:0","tags":["算法","贪心","dp"],"title":"10. 正则表达式匹配","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"categories":["刷题"],"content":"贪心 一次遍历，每次循环内更新能跳到的最远位置 func canJump(nums []int) bool { maxIndex := 0 for i := 0; i \u003c len(nums); i++ { if i \u003e maxIndex { return false } // 更新能跳到的最远位置 if nums[i]+i \u003e maxIndex { maxIndex = nums[i] + i } } return true // 能结束遍历说明必能跳到最后 } ","date":"2022-03-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/:1:0","tags":["算法","贪心","dp"],"title":"10. 正则表达式匹配","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"categories":["刷题"],"content":"DP 比较愚蠢的 dp func canJump(nums []int) bool { dp := make([]bool, len(nums)) dp[0] = true for i := 1; i \u003c len(nums); i++ { flag := false for j := i - 1; j \u003e= 0; j-- { // 遍历之前的每个dp if dp[j] \u0026\u0026 nums[j] \u003e= i-j { flag = true break } } if flag { dp[i] = true } } return dp[len(nums)-1] } ","date":"2022-03-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/:2:0","tags":["算法","贪心","dp"],"title":"10. 正则表达式匹配","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/"},{"categories":["刷题"],"content":"49. 字母异位词分组 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的字母得到的一个新单词，所有源单词中的字母通常恰好只用一次。 示例 1: 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] 示例 2: 输入: strs = [\"\"] 输出: [[\"\"]] 示例 3: 输入: strs = [\"a\"] 输出: [[\"a\"]] ","date":"2022-03-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/49.-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/:0:0","tags":["算法","字符串","哈希"],"title":"28. 实现 strStr()","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/49.-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"},{"categories":["刷题"],"content":"哈希 由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。 由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 26 的数组记录每个字母出现的次数。需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。 func groupAnagrams(strs []string) [][]string { hash := make(map[[26]int32][]string) for _, str := range strs { var count [26]int32 for _, letter := range str { count[letter-'a']++ } hash[count] = append(hash[count], str) } res := make([][]string, 0, len(hash)) for _, v := range hash { res = append(res, v) } return res } ","date":"2022-03-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/49.-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/:1:0","tags":["算法","字符串","哈希"],"title":"28. 实现 strStr()","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/49.-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/"},{"categories":["刷题"],"content":"39. 组合总和 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 示例 2： 输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 输入: candidates = [2], target = 1 输出: [] ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/39.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/:0:0","tags":["算法","回溯","组合"],"title":"39. 组合总和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/39.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"},{"categories":["刷题"],"content":"DFS 回溯 注意到这是个组合问题，所以要用 startIndex 避免重复 func combinationSum(candidates []int, target int) [][]int { res := make([][]int, 0) comb := make([]int, 0) var dfs func(sum, startIndex int) dfs = func(sum, startIndex int) { if sum == target { combCopy := make([]int, len(comb)) copy(combCopy, comb) res = append(res, combCopy) return } if sum \u003e target { return } for i := startIndex; i \u003c len(candidates); i++ { comb = append(comb, candidates[i]) dfs(sum+candidates[i], i) comb = comb[:len(comb)-1] } } dfs(0, 0) return res } ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/39.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/:1:0","tags":["算法","回溯","组合"],"title":"39. 组合总和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/39.-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/"},{"categories":["刷题"],"content":"42. 接雨水 hard 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/:0:0","tags":["算法","单调栈","DP"],"title":"42. 接雨水","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"categories":["刷题"],"content":"双指针 按列来计算：每一列雨水的高度，取决于该列左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。 即：当前列雨水面积 = min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。 func min(a, b int) int { if a \u003c b { return a } return b } func trap(height []int) (res int) { for i := 1; i \u003c len(height)-1; i++ { // 左右两个柱子不接雨水 lMax := height[i] rMax := height[i] // 分别找左右最高的柱子 for j := 0; j \u003c i; j++ { if height[j] \u003e lMax { lMax = height[j] } } for j := i + 1; j \u003c len(height); j++ { if height[j] \u003e rMax { rMax = height[j] } } res += min(lMax, rMax) - height[i] } return } ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/:1:0","tags":["算法","单调栈","DP"],"title":"42. 接雨水","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"categories":["刷题"],"content":"DP 为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。 我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。 这可以用动规来计算： 即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]); 从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]); func min(a, b int) int { if a \u003c b { return a } return b } func max(a, b int) int { if a \u003e b { return a } return b } func trap(height []int) (res int) { // 用dp计算前后最大高度 lDp, rDp := make([]int, len(height)), make([]int, len(height)) lDp[0], rDp[len(height)-1] = height[0], height[len(height)-1] for i := 1; i \u003c len(height); i++ { lDp[i] = max(lDp[i-1], height[i]) } for i := len(height) - 2; i \u003e= 0; i-- { rDp[i] = max(rDp[i+1], height[i]) } for i := 1; i \u003c len(height)-1; i++ { // 左右两个柱子不接雨水 lMax := lDp[i] rMax := rDp[i] res += min(lMax, rMax) - height[i] } return } ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/:2:0","tags":["算法","单调栈","DP"],"title":"42. 接雨水","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"categories":["刷题"],"content":"单调栈 构建一个栈顶到栈底元素从小到大排列的单调栈 ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/:3:0","tags":["算法","单调栈","DP"],"title":"42. 接雨水","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"categories":["刷题"],"content":"分析 在入栈的过程中，一旦发现添加的柱子高度大于栈头元素了，就表明出现凹槽了，栈顶元素就是凹槽底部的柱子，栈顶第二个元素就是凹槽左边的柱子，而添加的元素就是凹槽右边的柱子 遇到相同的元素，就更新栈内下标，就是将栈里元素（旧下标）弹出，将新元素（新下标）加入栈中。因为我们要求宽度的时候 如果遇到相同高度的柱子，需要使用最右边的柱子来计算宽度。 单调栈，其实是通过高 × 宽来计算雨水面积的。 高就是通过柱子的高度来计算，宽是通过柱子之间的下标来计算， ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/:3:1","tags":["算法","单调栈","DP"],"title":"42. 接雨水","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"categories":["刷题"],"content":"步骤 先将下标 0 的柱子加入到栈中（栈中存的是下标） 然后开始从下标 1 开始遍历所有的柱子 如果当前遍历的元素（柱子）高度小于栈顶元素的高度，就把这个元素加入栈中，因为栈里本来就要保持从小到大的顺序（从栈头到栈底）。 如果当前遍历的元素（柱子）高度等于栈顶元素的高度，要跟更新栈顶元素，因为遇到相相同高度的柱子，需要使用最右边的柱子来计算宽度。 如果当前遍历的元素（柱子）高度大于栈顶元素的高度，此时就出现凹槽了 取栈顶元素，将栈顶元素弹出，这个就是凹槽的底部，也就是中间位置，下标记为mid，对应的高度为height[mid]（就是图中的高度1）。 此时的栈顶元素st.top()，就是凹槽的左边位置，下标为st.top()，对应的高度为height[st.top()]（就是图中的高度2）。 当前遍历的元素i，就是凹槽右边的位置，下标为i，对应的高度为height[i]（就是图中的高度3）。 此时大家应该可以发现其实就是栈顶和栈顶的下一个元素以及要入栈的三个元素来接水！ 那么雨水高度是 min(凹槽左边高度, 凹槽右边高度) - 凹槽底部高度，代码为：int h = min(height[st.top()], height[i]) - height[mid]; 雨水的宽度是 凹槽右边的下标 - 凹槽左边的下标 - 1（因为只求中间宽度），代码为：int w = i - st.top() - 1 ; 当前凹槽雨水的体积就是：h * w。 func min(a, b int) int { if a \u003c b { return a } return b } func trap(height []int) (res int) { stack := []int{0} // 栈顶到栈底从小到大 存放下标 for i := 1; i \u003c len(height); i++ { if height[i] \u003c height[stack[len(stack)-1]] { stack = append(stack, i) } else if height[i] == height[stack[len(stack)-1]] { // 更新栈顶 stack[len(stack)-1] = i } else { for len(stack) != 0 \u0026\u0026 height[i] \u003e height[stack[len(stack)-1]] { midIndex := stack[len(stack)-1] stack = stack[:len(stack)-1] // 出栈 if len(stack) == 0 { break } h := min(height[i], height[stack[len(stack)-1]]) - height[midIndex] w := i - stack[len(stack)-1] - 1 res += h * w } stack = append(stack, i) } } return } ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/:3:2","tags":["算法","单调栈","DP"],"title":"42. 接雨水","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/42.-%E6%8E%A5%E9%9B%A8%E6%B0%B4/"},{"categories":["刷题"],"content":"48. 旋转图像 mid 给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 你必须在**原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[[7,4,1],[8,5,2],[9,6,3]] ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A8%A1%E6%8B%9F/48.-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/:0:0","tags":["算法","模拟"],"title":"48. 旋转图像","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A8%A1%E6%8B%9F/48.-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"},{"categories":["刷题"],"content":"模拟 一层一层来，一个一个转 就这样吧 func rotate(matrix [][]int) { n := len(matrix) for layer := 0; layer \u003c n/2; layer++ { end := n - 1 - layer for i := layer; i \u003c end; i++ { a := matrix[layer][i] // 左上 b := matrix[i][end] // 右上 c := matrix[end][n-1-i] // 右下 d := matrix[n-1-i][layer] // 左下 matrix[layer][i] = d matrix[i][end] = a matrix[end][n-1-i] = b matrix[n-1-i][layer] = c } } } ","date":"2022-03-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A8%A1%E6%8B%9F/48.-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/:1:0","tags":["算法","模拟"],"title":"48. 旋转图像","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A8%A1%E6%8B%9F/48.-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/"},{"categories":null,"content":"基本操作 Selenium 是一个自动化测试工具，利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些JavaScript动态渲染的页面来说，此种抓取方式非常有效。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"导入 from selenium import webdriver # 浏览器对象 from selenium.webdriver.common.by import By # find_element() from selenium.webdriver.common.keys import Keys # 导入 Keys 对象 from selenium.webdriver.support import expected_conditions as EC # 显示等待条件 from selenium.webdriver.support.wait import WebDriverWait # 显示等待 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"声明浏览器对象 browser = webdriver.Chrome() browser = webdriver.Firefox() browser = webdriver.Edge() browser = webdriver.PhantomJS() browser = webdriver.Safari() ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"其他操作 browser.get('https://www.taobao.com') # 访问 url print(browser.current_url) # 返回当前 url print(browser.get_cookies()) # 返回 cookies print(browser.page_source) # 返回当前页面源码 browser.close() # 关闭当前标签页 browser.quit() # 关闭浏览器 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"Cookies 操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"获取 Cookies .get_cookies() 返回现有 Cookies ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"删除 Cookies .delete_all_cookies() 删除现有 Cookies ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"添加 Cookies .add_cookie(dic_cookies) dic_cookies：字典形式的 Cookies 页面操作 页面操作以浏览器为对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:4:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"前进后退 .forward() .back() import time from selenium import webdriver browser = webdriver.Chrome() browser.get('https://www.baidu.com/') browser.get('https://www.taobao.com/') browser.get('https://www.python.org/') browser.back() time.sleep(1) browser.forward() browser.close() 连续访问3个页面，然后调用 back() 方法回到第二个页面，接下来再调用 forward() 方法又可以前进到第三个页面。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"标签页操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"打开新标签页 .execute_script(‘window.open()’) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:6:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"查看标签页 .window_handles 返回标签页列表 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:6:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"切换标签页 .switch_to_window(window_value) window_value：标签页名 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:6:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"切换 Frame .switch_to_frame(window_value) 网页中有一种节点叫作iframe，也就是子Frame，相当于页面的子页面，它的结构和外部网页的结构完全一致。Selenium打开页面后，它默认是在父级Frame里面操作，而此时如果页面中还有子Frame，它是不能获取到子Frame里面的节点的 browser.switch_to.frame('iframeResult') browser.switch_to.parent_frame() ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"延时等待 在 Selenium 中，get() 方法会在网页框架加载结束后结束执行，此时如果获取 page_source，可能并不是浏览器完全加载完成的页面，如果某些页面有额外的 Ajax 请求，我们在网页源代码中也不一定能成功获取到。所以，这里需要延时等待一定时间，确保节点已经加载出来 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"隐式等待 .implicitly_wait(seconds) 如果 Selenium 没有在 DOM 中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常 隐式等待的效果其实并没有那么好，因为我们只规定了一个固定时间，而页面的加载时间会受到网络条件的影响 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:8:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"显式等待 先指定要查找的节点，然后指定一个最长等待时间。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常 生成器 WebDriverWait(driver,timeout,poll_frequency=0.5,ignored_exceptions=None) driver：浏览器驱动 timeout：最长超时时间，默认以秒为单位 poll_frequency：检测的间隔步长，默认为 0.5s ignored_exceptions：超时后的抛出的异常信息，默认抛出 NoSuchElementExeception 异常。 wait = WebDriverWait(browser, 10) # 传入浏览器生成器和最长等待时间 直到函数 until(method) 和 until_not(method) 以显示等待为对象 method：expected_conditions wait = WebDriverWait(browser, 10) input = wait.until(EC.presence_of_element_located((By.ID, 'q'))) button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, '.btn-search'))) 等待条件 （expected_conditions） 方法 说明 title_is 判断当前页面的 title 是否完全等于（==）预期字符串，返回布尔值 title_contains 判断当前页面的 title 是否包含预期字符串，返回布尔值 presence_of_element_located 判断某个元素是否被加到了 dom 树里，并不代表该元素一定可见 visibility_of_element_located 判断元素是否可见（可见代表元素非隐藏，并且元素宽和高都不等于 0） visibility_of 同上一方法，只是上一方法参数为locator，这个方法参数是 定位后的元素 presence_of_all_elements_located 判断是否至少有 1 个元素存在于 dom 树中。举例：如果页面上有 n 个元素的 class 都是’wp’，那么只要有 1 个元素存在，这个方法就返回 True text_to_be_present_in_element 判断某个元素中的 text 是否 包含 了预期的字符串 text_to_be_present_in_element_value 判断某个元素中的 value 属性是否包含 了预期的字符串 frame_to_be_available_and_switch_to_it 判断该 frame 是否可以 switch进去，如果可以的话，返回 True 并且 switch 进去，否则返回 False invisibility_of_element_located 判断某个元素中是否不存在于dom树或不可见 element_to_be_clickable 判断某个元素中是否可见并且可点击 staleness_of 等某个元素从 dom 树中移除，注意，这个方法也是返回 True或 False element_to_be_selected 判断某个元素是否被选中了,一般用在下拉列表 element_selection_state_to_be 判断某个元素的选中状态是否符合预期 element_located_selection_state_to_be 跟上面的方法作用一样，只是上面的方法传入定位到的 element，而这个方法传入 locator alert_is_present 判断页面上是否存在 alert 异常 如果网络有问题，在设定时间内内没有成功加载，那就抛出 TimeoutException 异常 节点操作 节点操作均以节点为对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:8:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"查找结点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"单个节点 返回元素节点，为 WebElement 类型 分类方法 .find_element_by_XXX() find_element_by_id('id_vaule') # 通过 id 定位元素 find_element_by_name('name_vaule') # 通过 name 定位元素 find_element_by_tag_name('tag_name_vaule') # 通过 tag_name 定位元素 find_element_by_class_name('class_name') # 通过 class_name 定位元素 find_element_by_link_text('text_vaule') # 通过link标签（也就是a）的文本内容定位元素 find_element_by_partial_link_text('partial_text_vaule') # 通过link标签的部分文本内容定位元素 find_element_by_css_selector('css_selector') # 通过 css 选择器定位元素 find_element_by_xpath('xpath') # 通过 xpath 定位元素 例 browser.find_element_by_id(\"coolestWidgetEvah\") #按ID查找 browser.find_elements_by_xpath('//*[@id=\"q\"]') #通过Xpath browser.find_elements_by_class_name(\"cheese\") #按类名查找 browser.find_elements_by_link_text(\"cheese\") #按文本查找 browser.find_elements_by_partial_link_text(\"cheese\") #按文本查找(模糊) browser.find_elements_by_tag_name(\"iframe\") #按标签查找 browser.find_elements_by_name(\"cheese\") #按名称查找 通用方法 .find_element(By.XXX, value) By.ID = \"id\" By.XPATH = \"xpath\" By.LINK_TEXT = \"link text\" By.PARTIAL_LINK_TEXT = \"partial link text\" By.NAME = \"name\" By.TAG_NAME = \"tag name\" By.CLASS_NAME = \"class name\" By.CSS_SELECTOR = \"css selector\" ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:9:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"多个节点 如果要查找所有满足条件的节点，需要用 find_elements() 这样的方法。 返回节点列表，每个节点都是 WebElement 类型。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:9:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"获取节点信息 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"基本信息 .get_attribute(value) 获取属性 Gets the given attribute or property of the element. value：属性名 .text 获取文本 .id 获取 id，Internal ID used by selenium. .location 节点在页面中的相对位置，The location of the element in the renderable canvas. .size 获取节点大小（宽高），The size of the element. .tag_name 获取标签名称，This element’s tagName property. ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:10:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"判断操作 is_displayed() 是否可见，Whether the element is visible to a user. is_enabled() 是否可使用，Returns whether the element is enabled. is_selected() 是否被选中，Returns whether the element is selected.Can be used to check if a checkbox or radio button is selected. 交互操作 Selenium 可以驱动浏览器来执行一些操作，也就是说可以让浏览器模拟执行一些动作 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:10:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"节点操作 以节点为对象的操作 .send_keys(value) 选定元素进行输入，Simulates typing into the element. value：输入的值，可以是字符串也可以是 Keys 类型 .clear() 清空输入框 Clears the text if it’s a text entry element. .click() 点击元素，Clicks the element .submit() 提交，Submits a form. .screenshot(path) 节点截图，Saves a screenshot of the current element to a PNG image file. path：路径 usage： element.screenshot(‘/Screenshots/foo.png’) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"动作链 还有另外一些操作，它们没有特定的执行对象，比如鼠标拖曳、键盘按键等，这些动作用动作链来执行 actions = ActionChains(browser) # 声明动作链对象 actions.perform() # 执行操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:12:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"拖曳 .drag_and_drop(source, target) 元素拖曳到另一个元素 source：起始节点 target：终止节点 .drag_and_drop_by_offset(source, xoffset, yoffset) 元素按偏移量拖曳 source：The element to mouse down. xoffset：X offset to move to. yoffset：Y offset to move to. ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:12:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"点击 .click(on_element=None) 点击元素，Clicks an element on_element：The element to click. If None, clicks on current mouse position .click_and_hold() 按住元素，Holds down the left mouse button on an element. .release() 释放，Releasing a held mouse button on an element. .context_click() 右键单击元素，Performs a context-click (right click) on an element. .double_click() 双击元素，Double-clicks an element. ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:12:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"键盘操作 .key_down(value) 按下不放，Sends a key press only, without releasing it. Should only be used with modifier keys (Control, Alt and Shift). value：Keys对象，The modifier key to send. usage：ActionChains(driver).key_down(Keys.CONTROL).send_keys('c').key_up(Keys.CONTROL).perform()（pressing ctrl+c:） .key_up(value) 松开，Releases a modifier key. value：Keys 对象，The modifier key to send. ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:12:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"移动 .move_to_element(to_element) 将光标移至元素中央，Moving the mouse to the middle of an element. to_element：The WebElement to move to. .move_to_element_with_offset(to_element, xoffset, yoffset) 将光标移动指定偏移量，Move the mouse by an offset of the specified element. Offsets are relative to the top-left corner of the element. to_element：The WebElement to move to. xoffset：X offset to move to. yoffset：Y offset to move to. ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:12:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"发送按键 .send_keys(keys_to_send) 发送，Sends keys to current focused element. keys_to_send：Keys 对象，The keys to send. Modifier keys constants can be found in the ‘Keys’ class. .send_keys_to_element(element, keys_to_send) 发送到指定节点，Sends keys to an element. element：The element to send keys. keys_to_send：Keys 对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:12:5","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"执行 JavaScript browser.execute_script(JS_action) JS_action：jS 指令 例 browser = webdriver.Chrome() browser.get('https://www.zhihu.com/explore') browser.execute_script('window.scrollTo(0, document.body.scrollHeight)') browser.execute_script('alert(\"To Bottom\")') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:13:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"Keys 对象 我们经常需要模拟键盘的输入，当输入普通的值时，在send_keys()方法中传入要输入的字符串就好了。 但是我们有时候会用到一些特殊的按键，这时候就需要用到我们的Keys类 例 elem.send_keys(Keys.CONTROL, 'c') 按键 ADD = u'\\ue025' ALT = u'\\ue00a' ARROW_DOWN = u'\\ue015' ARROW_LEFT = u'\\ue012' ARROW_RIGHT = u'\\ue014' ARROW_UP = u'\\ue013' BACKSPACE = u'\\ue003' BACK_SPACE = u'\\ue003' CANCEL = u'\\ue001' CLEAR = u'\\ue005' COMMAND = u'\\ue03d' CONTROL = u'\\ue009' DECIMAL = u'\\ue028' DELETE = u'\\ue017' DIVIDE = u'\\ue029' DOWN = u'\\ue015' END = u'\\ue010' ENTER = u'\\ue007' EQUALS = u'\\ue019' ESCAPE = u'\\ue00c' F1 = u'\\ue031' F10 = u'\\ue03a' F11 = u'\\ue03b' F12 = u'\\ue03c' F2 = u'\\ue032' F3 = u'\\ue033' F4 = u'\\ue034' F5 = u'\\ue035' F6 = u'\\ue036' F7 = u'\\ue037' F8 = u'\\ue038' F9 = u'\\ue039' HELP = u'\\ue002' HOME = u'\\ue011' INSERT = u'\\ue016' LEFT = u'\\ue012' LEFT_ALT = u'\\ue00a' LEFT_CONTROL = u'\\ue009' LEFT_SHIFT = u'\\ue008' META = u'\\ue03d' MULTIPLY = u'\\ue024' NULL = u'\\ue000' NUMPAD0 = u'\\ue01a' NUMPAD1 = u'\\ue01b' NUMPAD2 = u'\\ue01c' NUMPAD3 = u'\\ue01d' NUMPAD4 = u'\\ue01e' NUMPAD5 = u'\\ue01f' NUMPAD6 = u'\\ue020' NUMPAD7 = u'\\ue021' NUMPAD8 = u'\\ue022' NUMPAD9 = u'\\ue023' PAGE_DOWN = u'\\ue00f' PAGE_UP = u'\\ue00e' PAUSE = u'\\ue00b' RETURN = u'\\ue006' RIGHT = u'\\ue014' SEMICOLON = u'\\ue018' SEPARATOR = u'\\ue026' SHIFT = u'\\ue008' SPACE = u'\\ue00d' SUBTRACT = u'\\ue027' TAB = u'\\ue004' UP = u'\\ue013' 常见操作 设置浏览器类的 options 选项 options = webdriver.ChromeOptions() # 不加载图片,加快访问速度 options.add_experimental_option(\"prefs\", {\"profile.managed_default_content_settings.images\": 2}) # 此步骤很重要，设置为开发者模式，防止被各大网站识别出来使用了Seleniu options.add_experimental_option('excludeSwitches', ['enable-automation']) browser = webdriver.Chrome(options=options) 弹出框的处理 switch_to.alert browser.switch_to.alert.accept() # 确认 browser.switch_to.alert.send_keys('abc')# 输入文本 browser.switch_to.alert.dismiss() # 取消 brower.switch_to_alert().text # 获取文本 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/selenium/:14:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/selenium/"},{"categories":null,"content":"基本操作 注意：当 element 对象使用 xpath 方法时，切记在语法字符串前加上当前路径 . ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"导入 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"从字符串中导入 from lxml import etree text = ''' \u003cdiv\u003e \u003cul\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link1.html\"\u003efirst item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-inactive\"\u003e\u003ca href=\"link3.html\"\u003ethird item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e \u003c/ul\u003e \u003c/div\u003e ''' html = etree.HTML(text) #调用HTML类进行初始化，构造了一个XPath解析对象 result = etree.tostring(html) #result为修正后的HTML代码(bytes类型) print(result.decode('utf-8')) #用decode方法将其转成str类型并输出 etree 模块可以自动修正 HTML 文本 \u003chtml\u003e\u003cbody\u003e\u003cdiv\u003e \u003cul\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link1.html\"\u003efirst item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-inactive\"\u003e\u003ca href=\"link3.html\"\u003ethird item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e \u003c/li\u003e\u003c/ul\u003e \u003c/div\u003e \u003c/body\u003e\u003c/html\u003e ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:1:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"从文件中导入 html = etree.parse('path', etree.HTMLParser()) 选取节点 在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档节点（或称为根节点） XPath 使用路径表达式来选取 XML 文档中的节点或节点集。节点是通过沿着路径 (path) 或者步 (steps) 来选取的 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:1:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"路径选取 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"基本表达式 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 .. 选取当前节点的父节点。 @ 选取属性。 例 路径表达式 结果 bookstore 选取 bookstore 元素的所有子节点。 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"谓语 谓语（Predicates）用来查找某个特定的节点或者包含某个指定的值的节点；谓语被嵌在方括号中。 例 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()\u003c3] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=‘eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price\u003e35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price\u003e35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"选取未知节点 XPath 通配符可用来选取未知的 XML 元素。 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 例 路径表达式 结果 /bookstore/* 选取 bookstore 元素的所有子元素。 //* 选取文档中的所有元素。 //title[@*] 选取所有带有属性的 title 元素。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"选取若干路径 在路径表达式中使用“|”运算符 例 路径表达式 结果 //book/title | //book/price 选取 book 元素的所有 title 和 price 元素。 //title | //price 选取文档中的所有 title 和 price 元素。 /bookstore/book/title | //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:2:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"步选取 步（step）包括： 轴（axis） 定义所选节点与当前节点之间的树关系 节点测试（node-test） 识别某个轴内部的节点 零个或者更多谓语（predicate） 更深入地提炼所选的节点集 步的语法 轴名称::节点测试[谓语] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"轴 轴可定义相对于当前节点的节点集。 轴名称 结果 ancestor 选取当前节点的所有先辈（父、祖父等）。 ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身。 attribute 选取当前节点的所有属性。 child 选取当前节点的所有子元素。 descendant 选取当前节点的所有后代元素（子、孙等）。 descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。 following 选取文档中当前节点的结束标签之后的所有节点。 namespace 选取当前节点的所有命名空间节点。 parent 选取当前节点的父节点。 preceding 选取文档中当前节点的开始标签之前的所有节点。 preceding-sibling 选取当前节点之前的所有同级节点。 self 选取当前节点。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"例 例子 结果 child::book 选取所有属于当前节点的子元素的 book 节点。 attribute::lang 选取当前节点的 lang 属性。 child::* 选取当前节点的所有子元素。 attribute::* 选取当前节点的所有属性。 child::text() 选取当前节点的所有文本子节点。 child::node() 选取当前节点的所有子节点。 descendant::book 选取当前节点的所有 book 后代。 ancestor::book 选择当前节点的所有 book 先辈。 ancestor-or-self::book 选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点） child::*/child::price 选取当前节点的所有 price 孙节点。z Python 实现 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"选取所有节点 result = html.xpath('//*') #匹配所有节点 result = html.xpath('//li')#获取所有 li 节点 返回形式是一个列表，每个元素是 Element 类型，其后跟了节点的名称，如 html、body、div、ul、li、a 等 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"选取子节点 通过 / 或 // 即可查找元素的子节点或子孙节点 result = html.xpath('//li/a') #选择 li 节点的所有直接 a 子节点 result = html.xpath('//ul//a') #获取 ul 节点下的所有子孙 a 节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"父节点 选中 href 属性为 link4.html 的 a 节点，然后再获取其父节点，然后再获取其 class 属性 result = html.xpath('//a[@href=\"link4.html\"]/../@class') 输出 ['item-1'] 通过 parent:: 来获取父节点 result = html.xpath('//a[@href=\"link4.html\"]/parent::*/@class') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"属性匹配 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"单值匹配 用 @ 符号进行属性过滤 如果要选取 class 为 item-0 的 li 节点 result = html.xpath('//li[@class=\"item-0\"]') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:7:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"多值匹配 若有 \u003cli class=\"li li-first\"\u003e\u003ca href=\"link.html\"\u003efirst item\u003c/a\u003e\u003c/li\u003e 使用上述方法将得不到结果，需要用 contains 方法 result = html.xpath('//li[contains(@class, \"li\")]/a/text()') 输出 ['first item'] 此种方式在某个节点的某个属性有多个值时经常用到，如某个节点的 class 属性通常有多个 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:7:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"多属性匹配 另外，我们可能还遇到一种情况，那就是根据多个属性确定一个节点，这时就需要同时匹配多个属性。此时可以使用运算符 and 来连接 text = ''' \u003cli class=\"li li-first\" name=\"item\"\u003e\u003ca href=\"link.html\"\u003efirst item\u003c/a\u003e\u003c/li\u003e ''' html = etree.HTML(text) result = html.xpath('//li[contains(@class, \"li\") and @name=\"item\"]/a/text()') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:7:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"文本获取 尝试获取前面 li 节点中的文本 result = html.xpath('//li[@class=\"item-0\"]/text()') result = html.xpath('//li[@class=\"item-0\"]/a/text()') result = html.xpath('//li[@class=\"item-0\"]//text()') 输出 ['\\n '] ['first item', 'fifth item'] ['first item', 'fifth item', '\\n '] 直接子节点并没有文本内容；自动修正的 li 节点的尾标签换行了。 先选取 a 节点再获取文本 使用 //，还会输出尾部的换行符 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"属性获取 想获取所有 li 节点下所有 a 节点的 href 属性 result = html.xpath('//li/a/@href') 输出 ['link1.html', 'link2.html', 'link3.html', 'link4.html', 'link5.html'] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"按序选择 有时候，我们在选择的时候某些属性可能同时匹配了多个节点，但是只想要其中的某个节点，如第二个节点或者最后一个节点，这时可以利用中括号传入索引的方法获取特定次序的节点 result = html.xpath('//li[1]/a/text()') result = html.xpath('//li[last()]/a/text()') result = html.xpath('//li[position()\u003c3]/a/text()') result = html.xpath('//li[last()-2]/a/text()') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":null,"content":"节点轴选择 result = html.xpath('//li[1]/ancestor::*') result = html.xpath('//li[1]/ancestor::div') result = html.xpath('//li[1]/attribute::*') result = html.xpath('//li[1]/child::a[@href=\"link1.html\"]') result = html.xpath('//li[1]/descendant::span') result = html.xpath('//li[1]/following::*[2]') result = html.xpath('//li[1]/following-sibling::*') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/xpath/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/xpath/"},{"categories":["刷题"],"content":"20. 有效的括号 easy 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false 示例 4： 输入：s = \"([)]\" 输出：false 示例 5： 输入：s = \"{[]}\" 输出：true ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/:0:0","tags":["算法","栈"],"title":"20. 有效的括号","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"},{"categories":["刷题"],"content":"辅助栈 func isValid(s string) bool { quoteMap := map[byte]byte{ '(': ')', '[': ']', '{': '}', } stack := make([]byte, 0) for _, quote := range []byte(s) { switch quote { case ')', ']', '}': if len(stack) == 0 { return false } if quote != quoteMap[stack[len(stack)-1]] { return false } stack = stack[:len(stack)-1] default: stack = append(stack, quote) } } return len(stack) == 0 } ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/:1:0","tags":["算法","栈"],"title":"20. 有效的括号","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/20.-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"},{"categories":["刷题"],"content":"21. 合并两个有序链表 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:0:0","tags":["算法","链表"],"title":"21. 合并两个有序链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"归并 加个伪头节点更方便 func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { if list1 == nil \u0026\u0026 list2 == nil { return nil } fakeHead := \u0026ListNode{} // 这玩意儿可以叫哨兵节点... p := fakeHead for list1 != nil || list2 != nil { if list1 == nil { p.Next = list2 list2 = list2.Next } else if list2 == nil { p.Next = list1 list1 = list1.Next } else { if list1.Val \u003e list2.Val { p.Next = list2 list2 = list2.Next } else { p.Next = list1 list1 = list1.Next } } p = p.Next } return fakeHead.Next } ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:1:0","tags":["算法","链表"],"title":"21. 合并两个有序链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"递归 蛮傻的 func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { if list1 == nil \u0026\u0026 list2 == nil { return nil } if list1 == nil { return list2 } if list2 == nil { return list1 } if list1.Val \u003e list2.Val { list2.Next = mergeTwoLists(list1, list2.Next) return list2 } else { list1.Next = mergeTwoLists(list1.Next, list2) return list1 } } ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/:2:0","tags":["算法","链表"],"title":"21. 合并两个有序链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/21.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"平分物品 现在有 n 个物品，每一个物品都有一个价值，现在想将这些物品分给两个人，要求这两个人每一个人分到的物品的价值总和相同（个数可以不同，总价值相同即可），剩下的物品就需要扔掉，现在想知道最少需要扔多少价值的物品才能满足要求分给两个人。 输入描述: 第一行输入一个整数 T，代表有 T 组测试数据。 对于每一组测试数据，一行输入一个整数 n ，代表物品的个数。接下来 n 个数，a[i] 代表每一个物品的价值。 1\u003c= T \u003c= 10 1 \u003c= n \u003c= 15 1 \u003c= a[i] \u003c= 100000 输出描述: 对于每一组测试数据，输出一个答案代表最少需要扔的价值。 输入例子1: 1 5 30 60 5 15 30 输出例子1: 20 例子说明1: 样例解释，扔掉第三个和第四个物品，然后将第一个物品和第五个物品给第一个人，第二个物品给第二个人，每一个人分到的价值为，扔掉的价值为 20。 ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%B9%B3%E5%88%86%E7%89%A9%E5%93%81/:0:0","tags":["算法","回溯"],"title":"平分物品","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%B9%B3%E5%88%86%E7%89%A9%E5%93%81/"},{"categories":["刷题"],"content":"DFS 对于每一个物品，都有三种选择： 分给第一个人 分给第二个人 丢掉 这样就可以构建一个树了 package main import ( \"fmt\" \"math\" ) func main() { var exampleCount int fmt.Scan(\u0026exampleCount) for exampleCount \u003e 0 { var n int fmt.Scan(\u0026n) things := make([]int, 0) for n \u003e 0 { var value int fmt.Scan(\u0026value) things = append(things, value) n-- } fmt.Println(f(things)) exampleCount-- } } func min(a, b int) int { if a \u003c b { return a } return b } func f(things []int) int { res := math.MaxInt32 var dfs func(layer, value1, value2, weight int) dfs = func(layer, value1, value2, weight int) { if layer == len(things) { if value1 == value2 { res = min(weight, res) } return } // 分配给第一个人 dfs(layer+1, value1+things[layer], value2, weight) // 分配给第二个人 dfs(layer+1, value1, value2+things[layer], weight) // 丢掉 dfs(layer+1, value1, value2, weight+things[layer]) } dfs(0, 0, 0, 0) return res } ","date":"2022-03-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%B9%B3%E5%88%86%E7%89%A9%E5%93%81/:1:0","tags":["算法","回溯"],"title":"平分物品","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%B9%B3%E5%88%86%E7%89%A9%E5%93%81/"},{"categories":["刷题"],"content":"96. 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 ","date":"2022-03-17","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/96.-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:0:0","tags":["算法","dp"],"title":"96. 不同的二叉搜索树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/96.-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"DP 每次只遍历一半会更快。 func numTrees(n int) int { dp := make([]int, n+1) dp[0], dp[1] = 1, 1 for i := 2; i \u003c= n; i++ { for j := 1; j \u003c= i/2; j++ { // 遍历每一个结点作为头节点 因为是对称的情况所以可以遍历一半 dp[i] += dp[j-1] * dp[i-j] } dp[i] *= 2 if i%2 == 1 { // 单独处理奇数的情况 dp[i] += dp[i/2] * dp[i/2] } } return dp[n] } ","date":"2022-03-17","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/96.-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:1:0","tags":["算法","dp"],"title":"96. 不同的二叉搜索树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/96.-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["刷题"],"content":"递归 思路一致，不过超时了…… // 易于理解的递归思路 func numTrees(n int) int { if n == 1 || n == 0 { return 1 } sum := 0 for i := 1; i \u003c= n; i++ { // 遍历每一个结点作为头结点 sum += numTrees(i-1) * numTrees(n-i) } return sum } ","date":"2022-03-17","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/96.-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/:2:0","tags":["算法","dp"],"title":"96. 不同的二叉搜索树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/96.-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"},{"categories":["Linux"],"content":"MPICH MPI（Message Passing Interface）是目前发展较快、使用面较广的一个公共的消息传递库，顾名思义，就是在现有机器的软硬件通信基础上，实现了并行应用程序中各并行任务之间的相互通信、协调和同步功能，并对这些并行任务进行管理。 MPI 具有可移植性、高效性、灵活性和易用性的特点，不仅适用于具有分布式内存的大型机、工作站机群，也可用于具有共享内存的大型机。 MPI 标准的常用实现有 OpenMPI 和 MPICH。 MPICH 是 MPI 的一种高效便携式实现标准，通过安装MPICH构建MPI编程环境，从而进行并行程序的开发。MPICH 是 MPI（Message-Passing Interface）的一个应用实现，支持最新的 MPI-2 接口标准（现在好像已经有MPI-3了），是用于并行运算的工具。 ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/mpich/:0:0","tags":["Linux"],"title":"MPICH","uri":"/Notes/posts/linux/useful/mpich/"},{"categories":["Linux"],"content":"安装 sudo apt-get install mpich 如果需要卸载： sudo apt-get --purge remove mpich ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/mpich/:1:0","tags":["Linux"],"title":"MPICH","uri":"/Notes/posts/linux/useful/mpich/"},{"categories":["Linux"],"content":"测试安装 随便找个地方新建一个测试文件，mpi_hello.cpp，代码如下： #include \u003ciostream\u003e #include \u003cstring.h\u003e #include \u003cmpi.h\u003e using namespace std; const int max_string = 100; int main () { int comm_sz=0; int my_rank=0; char greeting[max_string]; MPI_Init(NULL,NULL); MPI_Comm_rank(MPI_COMM_WORLD,\u0026my_rank); MPI_Comm_size(MPI_COMM_WORLD,\u0026comm_sz); if(my_rank!=0){ sprintf(greeting,\"Greetings from process %d of %d!\",my_rank,comm_sz); MPI_Send(greeting,strlen(greeting),MPI_CHAR,0,0,MPI_COMM_WORLD); } else{ cout\u003c\u003c\"Greetings from process \"\u003c\u003cmy_rank\u003c\u003c\" of \"\u003c\u003ccomm_sz\u003c\u003c\"!\"\u003c\u003cendl; for(int i=1;i\u003ccomm_sz;i++){ MPI_Recv(greeting,max_string,MPI_CHAR,i,0,MPI_COMM_WORLD,MPI_STATUS_IGNORE); cout\u003c\u003cgreeting\u003c\u003cendl; } } MPI_Finalize (); return 0; } 编译 mpicxx -g -Wall -o mpi_hello.o mpi_hello.cpp mpicc：编译 C 程序 mpicxx：是编译 C++ 程序 -g：允许使用调试器 -Wall：显示警告（W 大写） -o outfile.o：编译出可执行的文件，文件名为 outfile.o -02：告诉编译器对代码进行优化 编译完成后，开始运行，可由 -n 后面的数字来调节创建进程数。 mpirun -n 4 ./mpi_hello.o 最后得到的结果为，有可能顺序不一样 Greetings from process 0 of 4! Greetings from process 1 of 4! Greetings from process 2 of 4! Greetings from process 3 of 4! ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/mpich/:1:1","tags":["Linux"],"title":"MPICH","uri":"/Notes/posts/linux/useful/mpich/"},{"categories":["Linux"],"content":"远程并行 ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/mpich/:2:0","tags":["Linux"],"title":"MPICH","uri":"/Notes/posts/linux/useful/mpich/"},{"categories":["Linux"],"content":"NFS NFS 即网络文件系统（Network File-System），可以通过网络让不同机器、不同系统之间可以实现文件共享。通过 NFS，可以访问远程共享目录，就像访问本地磁盘一样。NFS 只是一种文件系统，本身并没有传输功能，是基于 RPC（远程过程调用）协议实现的，采用 C/S 架构。 ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/nfs/:0:0","tags":["Linux"],"title":"NFS","uri":"/Notes/posts/linux/useful/nfs/"},{"categories":["Linux"],"content":"搭建 NFS Server 安装 NFS 软件包 sudo apt-get install nfs-kernel-server # 安装 NFS服务器端 添加 NFS 共享目录 sudo vim /etc/exports 添加一行，把 “/nfsroot” 目录设置为 NFS 共享目录 /nfsroot *(rw,sync,no_root_squash) # * 表示允许任何网段 IP 的系统访问该 NFS 目录 新建“/nfsroot”目录，并为该目录设置最宽松的权限： sudo mkdir /nfsroot sudo chmod -R 777 /nfsroot sudo chown ipual:ipual /nfsroot/ -R # ipual 为当前用户，-R 表示递归更改该目录下所有文件 启动 NFS 服务 sudo /etc/init.d/nfs-kernel-server start # or sudo /etc/init.d/nfs-kernel-server restart 在 NFS 服务已经启动的情况下，如果修改了 “/etc/exports” 文件，需要重启 NFS 服务，以刷新 NFS 的共享目录。 ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/nfs/:1:0","tags":["Linux"],"title":"NFS","uri":"/Notes/posts/linux/useful/nfs/"},{"categories":["Linux"],"content":"NFS Client 配置 安装客户端 sudo apt-get install nfs-common # 安装 NFS客户端 挂载 sudo mount -t nfs 192.168.163.128:/nfsroot /mnt -o nolock 192.168.12.123 为主机 ip，/nfsroot 为主机共享目录，/mnt 为设备挂载目录，如果指令运行没有出错，则 NFS 挂载成功，在主机的 /mnt 目录下应该可以看到 /nfsroot 目录下的内容（可先在 nfsroot 目录下新建测试目录）， 卸载： umount /mnt 若要开机自动挂载，在 /etc/fstab 里添加 192.168.12.123:/nfsroot /mnt nfs rw 0 0 ","date":"2021-03-16","objectID":"/Notes/posts/linux/useful/nfs/:2:0","tags":["Linux"],"title":"NFS","uri":"/Notes/posts/linux/useful/nfs/"},{"categories":["刷题"],"content":"2044. 统计按位或能得到最大值的子集数目 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集 不同 。 对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。 示例 1： 输入：nums = [3,1] 输出：2 解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ： - [3] - [3,1] 示例 2： 输入：nums = [2,2,2] 输出：7 解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 23 - 1 = 7 个子集。 ","date":"2022-03-15","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/2044.-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/:0:0","tags":["算法","回溯","DFS"],"title":"2044. 统计按位或能得到最大值的子集数目","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/2044.-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"},{"categories":["刷题"],"content":"DFS func countMaxOrSubsets(nums []int) (ans int) { maxOr := 0 var dfs func(int, int) dfs = func(pos, or int) { if pos == len(nums) { if or \u003e maxOr { maxOr = or ans = 1 } else if or == maxOr { ans++ } return } dfs(pos+1, or|nums[pos]) // 或 dfs(pos+1, or) // 不或 } dfs(0, 0) return } ","date":"2022-03-15","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/2044.-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/:1:0","tags":["算法","回溯","DFS"],"title":"2044. 统计按位或能得到最大值的子集数目","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/2044.-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/"},{"categories":["刷题"],"content":"⭐ 46. 全排列 mid 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3： 输入：nums = [1] 输出：[[1]] ","date":"2022-03-15","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/46.-%E5%85%A8%E6%8E%92%E5%88%97/:0:0","tags":["算法","回溯","全排列"],"title":"46. 全排列","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/46.-%E5%85%A8%E6%8E%92%E5%88%97/"},{"categories":["刷题"],"content":"全排列回溯 还原变量的思想值得好好学习 func permute(nums []int) [][]int { res := make([][]int, 0) var bt func(nums, path []int) bt = func(nums, path []int) { if len(nums) == 0 { p := make([]int, len(path)) copy(p, path) // 拷贝 res = append(res, p) return } n := len(nums) for i := 0; i \u003c n; i++ { cur := nums[i] path = append(path, cur) nums = append(nums[:i], nums[i+1:]...) bt(nums, path) // 还原 nums = append(nums[:i], append([]int{cur}, nums[i:]...)...) path = path[:len(path)-1] } } bt(nums, []int{}) return res } ","date":"2022-03-15","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/46.-%E5%85%A8%E6%8E%92%E5%88%97/:1:0","tags":["算法","回溯","全排列"],"title":"46. 全排列","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/46.-%E5%85%A8%E6%8E%92%E5%88%97/"},{"categories":["Python"],"content":"SQLAlchemy ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:0:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"认识 ORM：Object Relational Mapping（对象关系映射）将数据库中的表与类构建映射 简洁易读：将数据表抽象为对象（数据模型），更直观易读 可移植：封装了多种数据库引擎，面对多个数据库，操作基本一致，代码易维护 更安全：有效避免 SQL 注入 数据库与 python 对象的映射 数据库表 (table）映射为 Python 的类 (class)，称为 model 表的字段 (field) 映射为 Column 表的记录 (record）以类的实例 (instance) 来表示 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:1:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"快速入门 FastAPI 的文件结构 . └── sql_app ├── __init__.py ├── crud.py # 增删查改 ├── database.py # 创建引擎 ├── main.py ├── models.py # 声明映射 └── schemas.py # 建立 pydantic 模型 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"创建引擎 # database.py from sqlalchemy import create_engine # using MySQL engine = create_engine('mysql+pymysql://user:pwd@localhost/testdb', pool_recycle=3600) # using SQLite engine = create_engine(\"sqlite:///testdb.db\") 或者将数据库链接分离 # database.py SQLALCHEMY_DATABASE_URL1 = \"sqlite:///./sql_app.db\" SQLALCHEMY_DATABASE_URL2 = \"postgresql://user:password@postgresserver/db\" engine = create_engine( SQLALCHEMY_DATABASE_URL1, connect_args={\"check_same_thread\": False} ) # needed only for SQLite ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:1","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"建立对象 # database.py SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:2","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"声名映射 声明 Base 实例（在 database.py 中） # database.py from sqlalchemy.ext.declarative import declarative_base Base = declarative_base() 新建表 # models.py from sqlalchemy import Boolean, Column, ForeignKey, Integer, String from sqlalchemy.orm import relationship from .database import Base class User(Base): __tablename__ = \"users\" id = Column(Integer, primary_key=True, index=True) email = Column(String, unique=True, index=True) hashed_password = Column(String) is_active = Column(Boolean, default=True) items = relationship(\"Item\", back_populates=\"owner\") class Item(Base): __tablename__ = \"items\" id = Column(Integer, primary_key=True, index=True) title = Column(String, index=True) description = Column(String, index=True) owner_id = Column(Integer, ForeignKey(\"users.id\")) owner = relationship(\"User\", back_populates=\"items\") SQLAlchemy 提供了 backref 让我们可以只需要定义一个关系： items = relationship(\"Item\", backref=\"owner\") 添加了这个就可以不用再在 Item 中定义 relationship 了！ ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:3","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"建立 Pydantic 模型 # schemas.py from typing import List, Optional from pydantic import BaseModel class ItemBase(BaseModel): title: str description: Optional[str] = None class ItemCreate(ItemBase): # 创建时的所用的对象 pass class Item(ItemBase): # API调用的对象 id: int owner_id: int class Config: orm_mode = True # 将字典识别为ORM对象 class UserBase(BaseModel): email: str class UserCreate(UserBase): # 创建时的所用的对象 password: str class User(UserBase): # API调用的对象 id: int is_active: bool items: List[Item] = [] class Config: orm_mode = True ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:4","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"CRUD Create, Read, Update, and Delete 读 详细：https://www.cnblogs.com/jingqi/p/8059673.html from sqlalchemy.orm import Session from . import models, schemas def get_user(db: Session, user_id: int): return db.query(models.User).filter(models.User.id == user_id).first() def get_user_by_email(db: Session, email: str): return db.query(models.User).filter(models.User.email == email).first() def get_users(db: Session, skip: int = 0, limit: int = 100): return db.query(models.User).offset(skip).limit(limit).all() def get_items(db: Session, skip: int = 0, limit: int = 100): return db.query(models.Item).offset(skip).limit(limit).all() 建 # 把描述的表创建出来 Base.metadata.create_all(engine) # Bas # 把多个表数据添加到会话 session.add_all(Users) # 把一个表数据添加到会话 session.add(dog) # 提交会话 session.commit() def create_user(db: Session, user: schemas.UserCreate): fake_hashed_password = user.password + \"notreallyhashed\" db_user = models.User(email=user.email, hashed_password=fake_hashed_password) db.add(db_user) # 增加实例到数据库中 db.commit() # 提交更改 db.refresh(db_user) # 刷新实例 return db_user def create_user_item(db: Session, item: schemas.ItemCreate, user_id: int): db_item = models.Item(**item.dict(), owner_id=user_id) # 使用字典传入 db.add(db_item) db.commit() db.refresh(db_item) return db_item 改 直接改 删 db.delete(user1) 删除整个数据库 db.drop_all() ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:5","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"创建表 from typing import List from fastapi import Depends, FastAPI, HTTPException from sqlalchemy.orm import Session from . import crud, models, schemas from .database import SessionLocal, engine models.Base.metadata.create_all(bind=engine) # 正式新建数据库和表（如果原来没有的话） app = FastAPI() # Dependency def get_db(): db = SessionLocal() try: yield db finally: db.close() @app.post(\"/users/\", response_model=schemas.User) def create_user(user: schemas.UserCreate, db: Session = Depends(get_db)): db_user = crud.get_user_by_email(db, email=user.email) # 检查用户是否被注册 if db_user: raise HTTPException(status_code=400, detail=\"Email already registered\") return crud.create_user(db=db, user=user) # 新建用户 @app.get(\"/users/\", response_model=List[schemas.User]) def read_users(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): users = crud.get_users(db, skip=skip, limit=limit) return users @app.get(\"/users/{user_id}\", response_model=schemas.User) def read_user(user_id: int, db: Session = Depends(get_db)): db_user = crud.get_user(db, user_id=user_id) if db_user is None: raise HTTPException(status_code=404, detail=\"User not found\") return db_user @app.post(\"/users/{user_id}/items/\", response_model=schemas.Item) def create_item_for_user( user_id: int, item: schemas.ItemCreate, db: Session = Depends(get_db) ): return crud.create_user_item(db=db, item=item, user_id=user_id) @app.get(\"/items/\", response_model=List[schemas.Item]) def read_items(skip: int = 0, limit: int = 100, db: Session = Depends(get_db)): items = crud.get_items(db, skip=skip, limit=limit) return items ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:2:6","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"概念 概念 对应 说明 engine 连接 驱动引擎 session 连接池、事务、会话 由此开始查询 model 表 类定义 column 列 query 若干行 可以链式添加多个文件 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:3:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"Engine 位于数据库驱动之上的一个抽象概念，它适配了各种数据库驱动，提供了连接池等功能 用法：engine = create_engine(\u003c数据库连接串\u003e) 数据库连接串的格式是 dialect+driver://username:password@host:port/database?param dialect 可以是 mysql, postgresql, oracle, mssql, sqlite driver：驱动，比如 MySQL 的驱动 pymysql， 如果不填写，就使用默认驱动 再往后就是用户名、密码、地址、端口、数据库、连接参数 例 # MySQL engine = create_engine('mysql+pymysql://scott:tiger@localhost/foo?charset=utf8mb4') # PostgreSQL engine = create_engine('postgresql+psycopg2://scott:tiger@localhost/mydatabase') # Oracle engine = create_engine('oracle+cx_oracle://scott:tiger@tnsname') # MS SQL engine = create_engine('mssql+pymssql://scott:tiger@hostname:port/dbname') # SQLite engine = create_engine('sqlite:////absolute/path/to/foo.db') ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:3:1","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"Session ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:3:2","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"Column 参数 type：字段的数据类型 Object Name Description BigInteger A type for bigger int integers. Boolean A bool datatype. Date A type for datetime.date() objects. DateTime A type for datetime.datetime() objects. Enum Generic Enum Type. Float Type representing floating point types, such as FLOAT or REAL. Integer A type for int integers. Interval A type for datetime.timedelta() objects. LargeBinary A type for large binary byte data. MatchType Refers to the return type of the MATCH operator. Numeric A type for fixed precision numbers, such as NUMERIC or DECIMAL. PickleType Holds Python objects, which are serialized using pickle. SchemaType Mark a type as possibly requiring schema-level DDL for usage. SmallInteger A type for smaller int integers. String The base for all string and character types. Text A variably sized string type. Time A type for datetime.time() objects. Unicode A variable length Unicode string type. UnicodeText An unbounded-length Unicode string type. 类型名 说明 Integer 普通整数，一般是32位 SmallInteger 取值范围小的整数，一般是16位 Float 浮点数 Numeric 定点数 String 字符串 Text 文本字符串 Boolean 布尔值 Date 日期 Time 时间 DateTime 日期和时间 primary_key：设置字段是否为主键 unique：设置字段是否唯一 index：设置字段是否为索引参数 default：设置字段默认值 nullable：设置字段是否可空，默认为 True（可空） autoincrement：设置字段是否自动递增 comment：设置字段注释 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:4:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"query Session 的 query 函数会返回一个 Query 对象 db.query(User).filter(User.id == user_id).first() ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:5:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"get 根据指定主键查询 query.get(id) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:5:1","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"filter equals: query.filter(User.name == 'ed') not equals: query.filter(User.name != 'ed') LIKE: query.filter(User.name.like('%ed%')) IN: query.filter(User.name.in_(['ed', 'wendy', 'jack'])) # works with query objects too: query.filter(User.name.in_( session.query(User.name).filter(User.name.like('%ed%')) )) NOT IN: query.filter(~User.name.in_(['ed', 'wendy', 'jack'])) IS NULL: query.filter(User.name == None) # alternatively, if pep8/linters are a concern query.filter(User.name.is_(None)) IS NOT NULL: query.filter(User.name != None) # alternatively, if pep8/linters are a concern query.filter(User.name.isnot(None)) AND: # use and_() from sqlalchemy import and_ query.filter(and_(User.name == 'ed', User.fullname == 'Ed Jones')) # or send multiple expressions to .filter() query.filter(User.name == 'ed', User.fullname == 'Ed Jones') # or chain multiple filter()/filter_by() calls query.filter(User.name == 'ed').filter(User.fullname == 'Ed Jones') OR: from sqlalchemy import or_ query.filter(or_(User.name == 'ed', User.name == 'wendy')) MATCH: query.filter(User.name.match('wendy')) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:5:2","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"filter_by 查询指定字段值的结果 query.filter_by(User.name='wang_wu').all() # 查询所有名字为wang_wu的实例 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:5:3","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"返回列表 (List) 和单项 (Scalar) all() 返回一个列表: \u003e\u003e\u003e query = session.query(User).filter(User.name.like('%ed')).order_by(User.id) SQL\u003e\u003e\u003e query.all() [\u003cUser(name='ed', fullname='Ed Jones', password='f8s7ccs')\u003e, \u003cUser(name='fred', fullname='Fred Flinstone', password='blah')\u003e] first() 返回至多一个结果，而且以单项形式，而不是只有一个元素的tuple形式返回这个结果. \u003e\u003e\u003e query.first() \u003cUser(name='ed', fullname='Ed Jones', password='f8s7ccs')\u003e one() 返回且仅返回一个查询结果。当结果的数量不足一个或者多于一个时会报错。 \u003e\u003e\u003e user = query.one() Traceback (most recent call last): ... MultipleResultsFound: Multiple rows were found for one() 没有查找到结果时： \u003e\u003e\u003e user = query.filter(User.id == 99).one() Traceback (most recent call last): ... NoResultFound: No row was found for one() one_or_none()：从名称可以看出，当结果数量为 0 时返回 None， 多于1个时报错 scalar()和one() 类似，但是返回单项而不是 tuple ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:5:4","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"嵌入使用 SQL 你可以在 Query 中通过 text() 使用 SQL 语句。例如： \u003e\u003e\u003e from sqlalchemy import text \u003e\u003e\u003e for user in session.query(User).\\ ... filter(text(\"id\u003c224\")).\\ ... order_by(text(\"id\")).all(): ... print(user.name) ed wendy mary fred 除了上面这种直接将参数写进字符串的方式外，你还可以通过 params() 方法来传递参数 \u003e\u003e\u003e session.query(User).filter(text(\"id\u003c:value and name=:name\")).\\ ... params(value=224, name='fred').order_by(User.id).one() \u003cUser(name='fred', fullname='Fred Flinstone', password='blah')\u003e 并且，你可以直接使用完整的 SQL 语句，但是要注意将表名和列明写正确。 \u003e\u003e\u003e session.query(User).from_statement( ... text(\"SELECT * FROM users where name=:name\")).\\ ... params(name='ed').all() [\u003cUser(name='ed', fullname='Ed Jones', password='f8s7ccs')\u003e] ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:5:5","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"关系 外键 (ForeignKey) 始终定义在多的一方 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:6:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"一对多 Child 为多 class Parent(Base): __tablename__ = 'parent' id = Column(Integer,primary_key = True) children = relationship(\"Child\",backref='parent') class Child(Base): __tablename__ = 'child' id = Column(Integer,primary_key = True) parent_id = Column(Integer,ForeignKey('parent.id')) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:6:1","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"多对一 Parent 为多 class Parent(Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) child_id = Column(Integer, ForeignKey('child.id')) child = relationship(\"Child\", backref=\"parents\") class Child(Base): __tablename__ = 'child' id = Column(Integer, primary_key=True) 为了建立双向关系,可以在 relationship() 中设置 backref，Child 对象就有 parents 属性. 设置 cascade= ‘all’，可以级联删除 children = relationship(\"Child\",cascade='all',backref='parent') ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:6:2","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"一对一 “一对一“就是“多对一”和“一对多”的一个特例，只需在 relationship 加上一个参数 uselist=False 替换多的一端即可 从一对多转换到一对一 class Parent(Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) child = relationship(\"Child\", uselist=False, backref=\"parent\") class Child(Base): __tablename__ = 'child' id = Column(Integer, primary_key=True) parent_id = Column(Integer, ForeignKey('parent.id')) 从多对一转换到一对一 class Parent(Base): __tablename__ = 'parent' id = Column(Integer, primary_key=True) child_id = Column(Integer, ForeignKey('child.id')) child = relationship(\"Child\", backref=backref(\"parent\", uselist=False)) class Child(Base): __tablename__ = 'child' id = Column(Integer, primary_key=True) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:6:3","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"多对多 多对多关系需要一个中间关联表,通过参数 secondary 来指定 from sqlalchemy import Table,Text post_keywords = Table('post_keywords',Base.metadata, Column('post_id',Integer,ForeignKey('posts.id')), Column('keyword_id',Integer,ForeignKey('keywords.id')) ) class BlogPost(Base): __tablename__ = 'posts' id = Column(Integer,primary_key=True) body = Column(Text) keywords = relationship('Keyword',secondary=post_keywords,backref='posts') class Keyword(Base): __tablename__ = 'keywords' id = Column(Integer,primary_key = True) keyword = Column(String(50),nullable=False,unique=True) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:6:4","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"技巧 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:7:0","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"relationship() 中 lazy 属性详解 lazy 决定了 SQLAlchemy 什么时候从数据库中加载数据 select：就是访问到属性的时候，就会全部加载该属性的数据 joined：对关联的两个表使用联接 subquery：与 joined 类似，但使用子子查询 dynamic：不加载记录，但提供加载记录的查询，也就是生成 query 对象 只可以用在一对多和多对多关系中，不可以用在一对一和多对一中 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:7:1","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"关于更新数据的讨论 # 1 (bad) user.no_of_logins += 1 # result: UPDATE user SET no_of_logins = 31 WHERE user.id = 6 # 2 (bad) user.no_of_logins = user.no_of_logins + 1 # result: UPDATE user SET no_of_logins = 31 WHERE user.id = 6 # 3 (bad) setattr(user, 'no_of_logins', user.no_of_logins + 1) # result: UPDATE user SET no_of_logins = 31 WHERE user.id = 6 # 4 (ok) user.no_of_logins = User.no_of_logins + 1 # result: UPDATE user SET no_of_logins = no_of_logins + 1 WHERE user.id = 6 # 5 (ok) setattr(user, 'no_of_logins', User.no_of_logins + 1) # result: UPDATE user SET no_of_logins = no_of_logins + 1 WHERE user.id = 6 If you are going to increment twice via code that produces SQL like SET no_of_logins = no_of_logins + 1, then you will need to commit or at least flush in between increments, or else you will only get one increment in total: # 6 (bad) user.no_of_logins = User.no_of_logins + 1 user.no_of_logins = User.no_of_logins + 1 session.commit() # result: UPDATE user SET no_of_logins = no_of_logins + 1 WHERE user.id = 6 # 7 (ok) user.no_of_logins = User.no_of_logins + 1 session.flush() # result: UPDATE user SET no_of_logins = no_of_logins + 1 WHERE user.id = 6 user.no_of_logins = User.no_of_logins + 1 session.commit() # result: UPDATE user SET no_of_logins = no_of_logins + 1 WHERE user.id = 6 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:7:2","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"关于插入大量数据的讨论 官方：https://docs.sqlalchemy.org/en/13/faq/performance.html#i-m-inserting-400-000-rows-with-the-orm-and-it-s-really-slow 大体意思：ORM 模型不适合于大量数据的插入，使用 sqlalchemy Core 或者 sqlalchemy 提供的 bulk insert 函数会是更好的选择 SQLAlchemy ORM: Total time for 100000 records 2.39429616928 secs SQLAlchemy ORM pk given: Total time for 100000 records 1.51412987709 secs SQLAlchemy ORM bulk_save_objects(): Total time for 100000 records 0.568987131119 secs SQLAlchemy ORM bulk_insert_mappings(): Total time for 100000 records 0.320806980133 secs SQLAlchemy Core: Total time for 100000 records 0.206904888153 secs sqlite3: Total time for 100000 records 0.165791988373 sec Script: import time import sqlite3 from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String, create_engine from sqlalchemy.orm import scoped_session, sessionmaker Base = declarative_base() DBSession = scoped_session(sessionmaker()) engine = None class Customer(Base): __tablename__ = \"customer\" id = Column(Integer, primary_key=True) name = Column(String(255)) def init_sqlalchemy(dbname='sqlite:///sqlalchemy.db'): global engine engine = create_engine(dbname, echo=False) DBSession.remove() DBSession.configure(bind=engine, autoflush=False, expire_on_commit=False) Base.metadata.drop_all(engine) Base.metadata.create_all(engine) def test_sqlalchemy_orm(n=100000): init_sqlalchemy() t0 = time.time() for i in xrange(n): customer = Customer() customer.name = 'NAME ' + str(i) DBSession.add(customer) if i % 1000 == 0: DBSession.flush() DBSession.commit() print( \"SQLAlchemy ORM: Total time for \" + str(n) + \" records \" + str(time.time() - t0) + \" secs\") def test_sqlalchemy_orm_pk_given(n=100000): init_sqlalchemy() t0 = time.time() for i in xrange(n): customer = Customer(id=i + 1, name=\"NAME \" + str(i)) DBSession.add(customer) if i % 1000 == 0: DBSession.flush() DBSession.commit() print( \"SQLAlchemy ORM pk given: Total time for \" + str(n) + \" records \" + str(time.time() - t0) + \" secs\") def test_sqlalchemy_orm_bulk_save_objects(n=100000): init_sqlalchemy() t0 = time.time() for chunk in range(0, n, 10000): DBSession.bulk_save_objects( [ Customer(name=\"NAME \" + str(i)) for i in xrange(chunk, min(chunk + 10000, n)) ] ) DBSession.commit() print( \"SQLAlchemy ORM bulk_save_objects(): Total time for \" + str(n) + \" records \" + str(time.time() - t0) + \" secs\") def test_sqlalchemy_orm_bulk_insert(n=100000): init_sqlalchemy() t0 = time.time() for chunk in range(0, n, 10000): DBSession.bulk_insert_mappings( Customer, [ dict(name=\"NAME \" + str(i)) for i in xrange(chunk, min(chunk + 10000, n)) ] ) DBSession.commit() print( \"SQLAlchemy ORM bulk_insert_mappings(): Total time for \" + str(n) + \" records \" + str(time.time() - t0) + \" secs\") def test_sqlalchemy_core(n=100000): init_sqlalchemy() t0 = time.time() engine.execute( Customer.__table__.insert(), [{\"name\": 'NAME ' + str(i)} for i in xrange(n)] ) print( \"SQLAlchemy Core: Total time for \" + str(n) + \" records \" + str(time.time() - t0) + \" secs\") def init_sqlite3(dbname): conn = sqlite3.connect(dbname) c = conn.cursor() c.execute(\"DROP TABLE IF EXISTS customer\") c.execute( \"CREATE TABLE customer (id INTEGER NOT NULL, \" \"name VARCHAR(255), PRIMARY KEY(id))\") conn.commit() return conn def test_sqlite3(n=100000, dbname='sqlite3.db'): conn = init_sqlite3(dbname) c = conn.cursor() t0 = time.time() for i in xrange(n): row = ('NAME ' + str(i),) c.execute(\"INSERT INTO customer (name) VALUES (?)\", row) conn.commit() print( \"sqlite3: Total time for \" + str(n) + \" records \" + str(time.time() - t0) + \" sec\") if __name__ == '__main__': test_sqlalchemy_orm(100000) test_sqlalchemy_orm_pk_given(100000) test_sqlalchemy_orm_bulk_save_objects(100000) test_sqlalchemy_orm_bulk_insert(100000) test_sqlalchemy_core(100000) test_sqlite3(100000) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:7:3","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["Python"],"content":"级联删除 https://www.cnblogs.com/ShanCe/p/15381412.html ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/sqlalchemy/:7:4","tags":["Python","后端","数据库","ORM"],"title":"SQLAlchemy","uri":"/Notes/posts/python/web-backend/sqlalchemy/"},{"categories":["前端"],"content":"Tailwind ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:0:0","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"要点 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:0","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"响应式变体 移动优先，未加前缀的功能类在所有的屏幕上都生效 而加了前缀的功能类（如 md:uppercase）仅在指定断点及以上的屏幕上生效。 要为移动设备设计样式，就需要使用无前缀的功能类，而不是带 sm: 前缀的版本 因此，通常最好先为移动设备设计布局，接着在 sm 屏幕上进行更改，然后是 md 屏幕，以此类推 Tailwind 的断点仅包括 min-width 而没有 max-width 这意味着在较小的断点上添加的任何功能类都将应用在更大的断点上。 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:1","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"状态变体 默认变体参考：https://www.tailwindcss.cn/docs/hover-focus-and-other-states#-4 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:2","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"dark 变体 dark 变体可以与响应式变体和状态变体结合使用： \u003cbutton class=\"lg:dark:hover:bg-white ...\"\u003e \u003c!-- ... --\u003e \u003c/button\u003e 为了使其正常工作，必须把响应式变体要在最前面，然后是 dark 变体，最后是状态变体。 默认情况下，dark variance 只对 backgroundColor、borderColor、gradientColorStops、placeholderColor 和 textColor 启用。 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:3","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"其他 在 HTML 中使用类 如果您只想对 html 或者 body 元素应用某种全局样式，只需将现有类添加到 HTML 中的那些元素，而不是编写新的 CSS ： \u003c!doctype html\u003e \u003chtml lang=\"en\" class=\"text-gray-900 leading-tight\"\u003e \u003c!-- ... --\u003e \u003cbody class=\"min-h-screen bg-gray-100\"\u003e \u003c!-- ... --\u003e \u003c/body\u003e \u003c/html\u003e 使用 @apply 抽取组件类 \u003cbutton class=\"btn-indigo\"\u003e Click me \u003c/button\u003e \u003cstyle\u003e .btn-indigo { @apply py-2 px-4 bg-indigo-500 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75; } \u003c/style\u003e 为了避免意外的特定性问题，我们建议您使用 @layer components { ... } 指令包装您的自定义组件样式，以告诉 Tailwind 这些样式属于哪一层 @tailwind base; @tailwind components; @tailwind utilities; @layer components { .btn-blue { @apply py-2 px-4 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75; } } @layer components { @variants responsive, hover { .btn-blue { @apply py-2 px-4 bg-blue-500 ...; } } } Tailwind 会将这些样式自动移到与 @tailwind components 相同的位置，因此您不必担心在源文件中正确放置顺序。 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:4","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"添加新的功能类 使用 CSS @tailwind base; @tailwind components; @tailwind utilities; @layer utilities { .scroll-snap-none { scroll-snap-type: none; } .scroll-snap-x { scroll-snap-type: x; } .scroll-snap-y { scroll-snap-type: y; } } 通过使用 @layer 指令， Tailwind 将自动把这些样式移动到 @tailwind utilities 相同的位置，以避免出现意外的未知问题。 附带响应式变体 @tailwind base; @tailwind components; @tailwind utilities; @layer utilities { @variants responsive { .scroll-snap-none { scroll-snap-type: none; } .scroll-snap-x { scroll-snap-type: x; } .scroll-snap-y { scroll-snap-type: y; } } } 附带深色模式变体 @tailwind base; @tailwind components; @tailwind utilities; @layer utilities { @variants dark { .filter-none { filter: none; } .filter-grayscale { filter: grayscale(100%); } } } 附带状态变体 @tailwind base; @tailwind components; @tailwind utilities; @layer utilities { @variants hover, focus { .filter-none { filter: none; } .filter-grayscale { filter: grayscale(100%); } } } 状态变体的生成顺序与您在 @variants 指令中列出的顺序相同，因此，如果您希望一个变体优先于另一个变体，请确保这个变体最后被列出 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:5","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"Preflight 默认的外边距 (margin) 已移除 默认启用 box-border，即为元素规定的高度或宽度将包括元素的 border 和 padding ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:1:6","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["前端"],"content":"常用 overflow-hidden font-bold 加粗 h-full w-full 满长/满宽（拉伸到与父元素一致） -m-XXX 重叠 w-2/3 w-1/3 宽占比 布局 flex （flex-col） items-center 居中 justify-XXX 主轴定位 space-x-10 子元素间间距 ","date":"2022-01-17","objectID":"/Notes/posts/frontend/css/tailwind/:2:0","tags":["CSS","前端","快速入门"],"title":"Tailwind","uri":"/Notes/posts/frontend/css/tailwind/"},{"categories":["刷题"],"content":"17. 电话号码的字母组合 mid 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] 示例 2： 输入：digits = \"\" 输出：[] 示例 3： 输入：digits = \"2\" 输出：[\"a\",\"b\",\"c\"] ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/17.-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:0:0","tags":["算法","回溯"],"title":"17. 电话号码的字母组合","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/17.-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["刷题"],"content":"回溯 经典的全排列 var phoneMap map[string]string = map[string]string{ \"2\": \"abc\", \"3\": \"def\", \"4\": \"ghi\", \"5\": \"jkl\", \"6\": \"mno\", \"7\": \"pqrs\", \"8\": \"tuv\", \"9\": \"wxyz\", } func letterCombinations(digits string) []string { if digits == \"\" { return []string{} } res := make([]string, 0) var bt func(index int, combination string) bt = func(index int, combination string) { if index == len(digits) { res = append(res, combination) // tmpStr = \"\" return } for _, word := range phoneMap[string(digits[index])] { bt(index+1, combination+string(word)) } } bt(0, \"\") return res } ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/17.-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/:1:0","tags":["算法","回溯"],"title":"17. 电话号码的字母组合","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/17.-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"categories":["刷题"],"content":"2100. 适合打劫银行的日子 mid 你和一群强盗准备打劫银行。给你一个下标从 0 开始的整数数组 security ，其中 security[i] 是第 i 天执勤警卫的数量。日子从 0 开始编号。同时给你一个整数 time 。 如果第 i 天满足以下所有条件，我们称它为一个适合打劫银行的日子： 第 i 天前和后都分别至少有 time 天。 第 i 天前连续 time 天警卫数目都是非递增的。 第 i 天后连续 time 天警卫数目都是非递减的。 请你返回一个数组，包含 所有 适合打劫银行的日子（下标从 0 开始）。返回的日子可以 任意 顺序排列。 示例 1： 输入：security = [5,3,3,3,5,6,2], time = 2 输出：[2,3] 示例 2： 输入：security = [1,1,1,1,1], time = 0 输出：[0,1,2,3,4] 示例 3： 输入：security = [1,2,3,4,5,6], time = 2 输出：[] ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/2100.-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/:0:0","tags":["算法","dp"],"title":"2100. 适合打劫银行的日子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/2100.-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/"},{"categories":["刷题"],"content":"动态规划 把第 i 天前非递增天数和第 i 天非递减天数求出来就可以了 func goodDaysToRobBank(security []int, time int) []int { res := make([]int, 0) dp1 := make([]int, len(security)) dp1[0] = 0 for i := 1; i \u003c len(security); i++ { if security[i-1] \u003e= security[i] { dp1[i] = dp1[i-1] + 1 } else { dp1[i] = 0 } } dp2 := make([]int, len(security)) dp2[len(security)] = 0 for i := len(security) - 1; i \u003e= 0; i-- { if security[i] \u003c= security[i+1] { dp2[i] = dp2[i+1] + 1 } else { dp2[i] = 0 } } for i := time; i \u003c len(security)-time; i++ { if dp1[i] \u003e= time \u0026\u0026 dp2[i] \u003e= time { res = append(res, i) } } return res } 前两个 for 循环还能合到一起，不过懒得合了 ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/2100.-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/:1:0","tags":["算法","dp"],"title":"2100. 适合打劫银行的日子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/2100.-%E9%80%82%E5%90%88%E6%89%93%E5%8A%AB%E9%93%B6%E8%A1%8C%E7%9A%84%E6%97%A5%E5%AD%90/"},{"categories":["刷题"],"content":"28. 实现 strStr() 实现 strStr() 函数。 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 -1 。 示例 1： 输入：haystack = \"hello\", needle = \"ll\" 输出：2 示例 2： 输入：haystack = \"aaaaa\", needle = \"bba\" 输出：-1 ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/28.-%E5%AE%9E%E7%8E%B0-strstr/:0:0","tags":["算法","字符串","KMP"],"title":"28. 实现 strStr()","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/28.-%E5%AE%9E%E7%8E%B0-strstr/"},{"categories":["刷题"],"content":"KMP // strStr KMP算法 时间复杂度O(N+M),空间复杂度O(M) func strStrSimple(haystack string, needle string) int { n, m := len(haystack), len(needle) if m == 0 { return 0 } next := make([]int, m) GetNext(next, needle) // 因为next数组里记录的起始位置为0 j := 0 // i从0开始匹配 for i := 0; i \u003c n; i++ { // 如果不匹配，就寻找之前匹配的位置 for j \u003e 0 \u0026\u0026 haystack[i] != needle[j] { j = next[j-1] } // 如果匹配，i和j同时向后移动 if haystack[i] == needle[j] { j++ } // 如果j从0移动到m的位置，意味着模式串needle与文本串haystack匹配成功 if j == m { return i - m + 1 } } return -1 } func GetNext(next []int, s string) { // next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 j := 0 next[0] = 0 // j指向前缀起始位置，i指向后缀起始位置 for i := 1; i \u003c len(s); i++ { // 如果前后缀不相同，那么j就要向前回退 for j \u003e 0 \u0026\u0026 s[i] != s[j] { j = next[j-1] } // 说明找到了相同的前后缀, j++，同时记录next[i] if s[i] == s[j] { j++ } next[i] = j } } ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/28.-%E5%AE%9E%E7%8E%B0-strstr/:1:0","tags":["算法","字符串","KMP"],"title":"28. 实现 strStr()","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/28.-%E5%AE%9E%E7%8E%B0-strstr/"},{"categories":["刷题"],"content":"459. 重复的子字符串 easy 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 输入: s = \"abab\" 输出: true 解释: 可由子串 \"ab\" 重复两次构成。 ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/459.-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["算法","字符串"],"title":"459. 重复的子字符串","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/459.-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"枚举 func repeatedSubstringPattern(s string) bool { for i := 1; i \u003c= len(s)/2; i++ { // i代表长度 if len(s)%i == 0 { // 长度整除 isMatch := true for j := i; j \u003c len(s); j++ { // 判断之后的字符串是否可以由0到i-1的子串构成 if s[j] != s[j-i] { isMatch = false break } } if isMatch { return true } } } return false } ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/459.-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["算法","字符串"],"title":"459. 重复的子字符串","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/459.-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"KMP func getNext(s string) []int { next := make([]int, len(s)) // 0-i子串的最长公共前后缀 next[0] = 0 i := 0 // i指向前缀 for j := 1; j \u003c len(s); j++ { // j指向后缀 for i \u003e 0 \u0026\u0026 s[i] != s[j] { i = next[i-1] } if s[i] == s[j] { i++ } next[j] = i } return next } func repeatedSubstringPattern(s string) bool { if len(s) == 0 { return false } next := getNext(s) if next[len(s)-1] != 0 \u0026\u0026 len(s)%(len(s)-next[len(s)-1]) == 0 { return true } return false } ","date":"2022-03-14","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/459.-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["算法","字符串"],"title":"459. 重复的子字符串","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/459.-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["刷题"],"content":"151. 翻转字符串里的单词 mid 给你一个字符串 s ，逐个翻转字符串中的所有 单词 。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 请你返回一个翻转 s 中单词顺序并用单个空格相连的字符串。 示例 1： 输入：s = \"the sky is blue\" 输出：\"blue is sky the\" 示例 2： 输入：s = \" hello world \" 输出：\"world hello\" 解释：颠倒后的字符串中不能存在前导空格和尾随空格。 ","date":"2022-03-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/151.-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/:0:0","tags":["算法","字符串","双指针"],"title":"151. 翻转字符串里的单词","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/151.-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"},{"categories":["刷题"],"content":"双指针 目标是：原地反转，空间复杂度 $O(1)$ 去空格：快慢指针 整体反转：头尾指针 部分反转：头尾指针 要注意去空格的边界条件，因为每一次循环，slow 最后要 +1 留一个空格，所以字符串末尾有空格和没空格是有区别的。 func reverse(b []byte) { l, r := 0, len(b)-1 for l \u003c= r { b[l], b[r] = b[r], b[l] l++ r-- } } func reverseWords(s string) string { b := []byte(s) // 移除多余空格 slow, fast := 0, 0 for fast \u003c len(b) { // 寻找一个单词的开头 for fast \u003c len(b) \u0026\u0026 b[fast] == ' ' { fast++ } for fast \u003c len(b) \u0026\u0026 b[fast] != ' ' { b[slow], b[fast] = b[fast], b[slow] slow++ fast++ } slow++ } if b[slow-2] == ' ' { // 字符末尾有空格 b = b[:slow-2] } else { // 字符末尾无空格 b = b[:slow-1] } reverse(b) slow, fast = 0, 0 for fast \u003c len(b) { for slow \u003c len(b) \u0026\u0026 b[slow] == ' ' { slow++ } fast = slow for fast \u003c len(b) \u0026\u0026 b[fast] != ' ' { fast++ } reverse(b[slow:fast]) slow = fast } return string(b) } ","date":"2022-03-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/151.-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/:1:0","tags":["算法","字符串","双指针"],"title":"151. 翻转字符串里的单词","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/151.-%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/"},{"categories":["刷题"],"content":"541. 反转字符串 II 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 输入：s = \"abcdefg\", k = 2 输出：\"bacdfeg\" 示例 2： 输入：s = \"abcd\", k = 2 输出：\"bacd\" ","date":"2022-03-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/:0:0","tags":["算法","字符串","双指针","模拟"],"title":"541. 反转字符串 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/"},{"categories":["刷题"],"content":"双指针 + 模拟 没啥好说的 func reverse(b []byte, l, r int) []byte { for l \u003c= r { b[l], b[r] = b[r], b[l] l++ r-- } return b } func reverseStr(s string, k int) string { b := []byte(s) curLen := 0 for curLen \u003c len(s) { if curLen+2*k \u003e len(s) { if len(s)-curLen \u003e k { b = reverse(b, curLen, curLen+k-1) } else { b = reverse(b, curLen, len(s)-1) } return string(b) } else { b = reverse(b, curLen, curLen+k-1) curLen += k * 2 } } return string(b) } ","date":"2022-03-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/:1:0","tags":["算法","字符串","双指针","模拟"],"title":"541. 反转字符串 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/541.-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-ii/"},{"categories":["刷题"],"content":"10. 正则表达式匹配 hard 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 输入：s = \"aa\", p = \"a\" 输出：false 解释：\"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入：s = \"aa\", p = \"a*\" 输出：true 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/10.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/:0:0","tags":["算法","dp"],"title":"10. 正则表达式匹配","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/10.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"categories":["刷题"],"content":"DP 注意，* 可以消除前面的字符 func isMatch(s string, p string) bool { row, col := len(s), len(p) match := func(i, j int) bool { if i == 0 { return false } if p[j-1] == '.' { return true } return s[i-1] == p[j-1] } dp := make([][]bool, row+1) for i := 0; i \u003c= row; i++ { dp[i] = make([]bool, col+1) } dp[0][0] = true for i := 2; i \u003c= col; i++ { if p[i-1] == '*' { dp[0][i] = dp[0][i-2] } } for i := 1; i \u003c= row; i++ { for j := 1; j \u003c= col; j++ { if p[j-1] != '*' { if match(i, j) { dp[i][j] = dp[i-1][j-1] } else { dp[i][j] = false } } else { if match(i, j-1) { dp[i][j] = dp[i-1][j] || dp[i][j-2] } else { dp[i][j] = dp[i][j-2] } } } } return dp[row][col] } ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/10.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/:1:0","tags":["算法","dp"],"title":"10. 正则表达式匹配","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/10.-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"categories":["刷题"],"content":"202. 快乐数 easy 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 示例 1： 输入：n = 19 输出：true 解释： 1^2 + 9^2 = 82 8^2 + 2^2 = 68 6^2 + 8^2 = 100 1^2 + 0^2 + 0^2 = 1 示例 2： 输入：n = 2 输出：false ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/:0:0","tags":["算法","哈希","双指针"],"title":"202. 快乐数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"categories":["刷题"],"content":"哈希表 没别哒，就是把每一次的计算结果存起来，因为不是从头循环 func isHappy(n int) bool { hash := make(map[int]bool) sum := n for !hash[sum] { hash[sum] = true sum = getSum(sum) if sum == 1 { return true } } return false } func getSum(n int) int { sum := 0 for n \u003e 0 { sum += (n % 10) * (n % 10) n /= 10 } return sum } ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/:1:0","tags":["算法","哈希","双指针"],"title":"202. 快乐数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"categories":["刷题"],"content":"快慢指针 慢指针走一步，快指针走两步，一定会相遇（都为 1 也是相遇的） func getSum(n int) int { sum := 0 for n \u003e 0 { sum += (n % 10) * (n % 10) n /= 10 } return sum } // 非常妙的快慢指针 func isHappy(n int) bool { slowSum, fastSum := n, n for { slowSum = getSum(slowSum) fastSum = getSum(fastSum) fastSum = getSum(fastSum) if slowSum == fastSum { break } } return slowSum == 1 } ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/:2:0","tags":["算法","哈希","双指针"],"title":"202. 快乐数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/202.-%E5%BF%AB%E4%B9%90%E6%95%B0/"},{"categories":["刷题"],"content":"242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 **注意：**若 s 和 *t* 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。 示例 1: 输入: s = \"anagram\", t = \"nagaram\" 输出: true 示例 2: 输入: s = \"rat\", t = \"car\" 输出: false ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/242.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/:0:0","tags":["算法","字符串","哈希"],"title":"242. 有效的字母异位词","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/242.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"},{"categories":["刷题"],"content":"哈希表 用一个 [26]int 来代替 map[byte]int 三个循环 func isAnagram(s string, t string) bool { if len(s) != len(t) { return false } var hash [26]int for _, letter := range s { hash[letter-'a']++ } for _, letter := range t { if hash[letter-'a'] == 0 { return false } hash[letter-'a']-- } for i := 0; i \u003c 26; i++ { if hash[i] \u003e 0 { return false } } return true // 甚至可以酱紫写 xia // return record == [26]int{} } ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/242.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/:1:0","tags":["算法","字符串","哈希"],"title":"242. 有效的字母异位词","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/242.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"},{"categories":["刷题"],"content":"349. 两个数组的交集 给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。 示例 1： 输入：nums1 = [1,2,2,1], nums2 = [2,2] 输出：[2] 示例 2： 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4] 输出：[9,4] 解释：[4,9] 也是可通过的 ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/349.-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:0:0","tags":["算法","数组","哈希"],"title":"349. 两个数组的交集","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/349.-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["刷题"],"content":"哈希 注意去重 func intersection(nums1 []int, nums2 []int) (res []int) { hash := make(map[int]struct{}, 0) for i := 0; i \u003c len(nums1); i++ { hash[nums1[i]] = struct{}{} } for i := 0; i \u003c len(nums2); i++ { if _, ok := hash[nums2[i]]; ok { res = append(res, nums2[i]) delete(hash, nums2[i]) // 去重 } } return } ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/349.-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/:1:0","tags":["算法","数组","哈希"],"title":"349. 两个数组的交集","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/349.-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"},{"categories":["刷题"],"content":"383. 赎金信 给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。 如果可以，返回 true ；否则返回 false 。 magazine 中的每个字符只能在 ransomNote 中使用一次。 示例 1： 输入：ransomNote = \"a\", magazine = \"b\" 输出：false 示例 2： 输入：ransomNote = \"aa\", magazine = \"ab\" 输出：false 示例 3： 输入：ransomNote = \"aa\", magazine = \"aab\" 输出：true ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/383.-%E8%B5%8E%E9%87%91%E4%BF%A1/:0:0","tags":["算法","字符串","哈希"],"title":"383. 赎金信","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/383.-%E8%B5%8E%E9%87%91%E4%BF%A1/"},{"categories":["刷题"],"content":"哈希 只由小写字母构成，那就用数组代替 map func canConstruct(ransomNote string, magazine string) bool { var hash [26]int for _, letter := range []byte(magazine) { hash[letter-'a']++ } for _, letter := range []byte(ransomNote) { hash[letter-'a']-- if hash[letter-'a'] \u003c 0 { return false } } return true } ","date":"2022-03-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/383.-%E8%B5%8E%E9%87%91%E4%BF%A1/:1:0","tags":["算法","字符串","哈希"],"title":"383. 赎金信","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/383.-%E8%B5%8E%E9%87%91%E4%BF%A1/"},{"categories":["Golang"],"content":"bufio Go 语言在 io 操作中，还提供了一个 bufio 的包，使用这个包可以大幅提高文件读写的效率。 参考：https://www.cnblogs.com/ricklz/p/13188188.html ","date":"2022-03-10","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/:0:0","tags":["Go 库","io"],"title":"bufio","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/"},{"categories":["Golang"],"content":"原理 bufio 是通过缓冲来提高效率。 io 操作本身的效率并不低，低的是频繁的访问本地磁盘的文件。所以 bufio 就提供了缓冲区（分配一块内存），读和写都先在缓冲区中，最后再读写文件，来降低访问本地磁盘的次数，从而提高效率。 bufio 封装了io.Reader 或 io.Writer 接口对象，并创建另一个也实现了该接口的对象。 ","date":"2022-03-10","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/:1:0","tags":["Go 库","io"],"title":"bufio","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/"},{"categories":["Golang"],"content":"Reader bufio.Reader 是 bufio 中对 io.Reader 的封装 // Reader implements buffering for an io.Reader object. type Reader struct { buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid } bufio.Read(p []byte) 相当于读取大小 len(p) 的内容，思路如下： 当缓存区有内容的时，将缓存区内容全部填入 p 并清空缓存区 当缓存区没有内容的时候且 len(p)\u003elen(buf)，即要读取的内容比缓存区还要大，直接去文件读取即可 当缓存区没有内容的时候且 len(p)\u003clen(buf)，即要读取的内容比缓存区小，缓存区从文件读取内容充满缓存区，并将 p 填满（此时缓存区有剩余内容） 以后再次读取时缓存区有内容，将缓存区内容全部填入 p 并清空缓存区（此时和情况 1 一样） ","date":"2022-03-10","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/:2:0","tags":["Go 库","io"],"title":"bufio","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/"},{"categories":["Golang"],"content":"实例化 bufio 包提供了两个实例化 bufio.Reader 对象的函数：NewReader 和 NewReaderSize。其中，NewReader 函数是调用 NewReaderSize 函数实现的： // NewReader returns a new Reader whose buffer has the default size. func NewReader(rd io.Reader) *Reader { // defaultBufSize = 4096,默认的大小 return NewReaderSize(rd, defaultBufSize) } 调用的 NewReaderSize // NewReaderSize returns a new Reader whose buffer has at least the specified // size. If the argument io.Reader is already a Reader with large enough // size, it returns the underlying Reader. func NewReaderSize(rd io.Reader, size int) *Reader { // Is it already a Reader? b, ok := rd.(*Reader) if ok \u0026\u0026 len(b.buf) \u003e= size { return b } if size \u003c minReadBufferSize { size = minReadBufferSize } r := new(Reader) r.reset(make([]byte, size), rd) return r } ","date":"2022-03-10","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/:2:1","tags":["Go 库","io"],"title":"bufio","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/"},{"categories":["Golang"],"content":"Writer bufio.Writer 是 bufio 中对 io.Writer 的封装 // Writer implements buffering for an io.Writer object. // If an error occurs writing to a Writer, no more data will be // accepted and all subsequent writes, and Flush, will return the error. // After all data has been written, the client should call the // Flush method to guarantee all data has been forwarded to // the underlying io.Writer. type Writer struct { err error buf []byte n int wr io.Writer } bufio.Write(p []byte) 的思路如下 判断 buf 中可用容量是否可以放下 p 如果能放下，直接把 p 拼接到 buf 后面，即把内容放到缓冲区 如果缓冲区的可用容量不足以放下，且此时缓冲区是空的，直接把 p 写入文件即可 如果缓冲区的可用容量不足以放下，且此时缓冲区有内容，则用 p 把缓冲区填满，把缓冲区所有内容写入文件，并清空缓冲区 判断 p 的剩余内容大小能否放到缓冲区，如果能放下（此时和步骤 1 情况一样）则把内容放到缓冲区 如果 p 的剩余内容依旧大于缓冲区，（注意此时缓冲区是空的，情况和步骤 3 一样）则把 p 的剩余内容直接写入文件 ","date":"2022-03-10","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/:3:0","tags":["Go 库","io"],"title":"bufio","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/"},{"categories":["Golang"],"content":"Scanner bufio.Reader 结构体中所有读取数据的方法，都包含了 delim 分隔符，这个用起来很不方便，所以 Google 对此在 go1.1 版本中加入了 bufio.Scanner 结构体，用于读取数据。 type Scanner struct { // 内含隐藏或非导出字段 } Scanner 类型提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行。 Scanner.Scan 方法默认是以换行符 \\n，作为分隔符。如果你想指定分隔符，Go 语言提供了四种方法： ScanBytes (返回单个字节作为一个 token) ScanLines (返回一行文本) ScanRunes (返回单个 UTF-8 编码的 rune 作为一个 token ScanWords(返回通过“空格”分词的单词)。 除了这几个预定的，我们也可以自定义分割函数。 扫描会在抵达输入流结尾、遇到的第一个 I/O 错误、token 过大不能保存进缓冲时，不可恢复地停止。 当扫描停止后，当前读取位置可能会远在最后一个获得的 token 后面。需要更多对错误管理的控制或 token 很大，或必须从 reader 连续扫描的程序，应使用 bufio.Reader 代替。 input := \"hello world\" scanner := bufio.NewScanner(strings.NewReader(input)) scanner.Split(bufio.ScanWords) for scanner.Scan() { fmt.Println(scanner.Text()) } if err := scanner.Err(); err != nil { fmt.Fprintln(os.Stderr, \"reading input:\", err) } ","date":"2022-03-10","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/:4:0","tags":["Go 库","io"],"title":"bufio","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/bufio/"},{"categories":["算法"],"content":"142. 环形链表 II 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点 示例 2： 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 快慢指针 + 数学 slow 走一步，fast 走两步，一定会相遇 相遇后，建个 p 从头走，slow 继续走，相遇点即为第一个公共结点 证明详见：https://www.programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#_142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii func detectCycle(head *ListNode) *ListNode { slow, fast := head, head for fast != nil \u0026\u0026 fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { for slow != head { slow = slow.Next head = head.Next } return head } } return nil } ","date":"2022-03-09","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/142.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/:0:0","tags":["算法","链表","双指针","数学"],"title":"142. 环形链表 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/142.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/"},{"categories":["算法"],"content":"19. 删除链表的倒数第 N 个结点 ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/:0:0","tags":["算法","链表"],"title":"19. 删除链表的倒数第 N 个结点","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"categories":["算法"],"content":"快慢指针 伪头节点真香，删除头节点很方便 func removeNthFromEnd(head *ListNode, n int) *ListNode { if head.Next == nil { return nil } fakeHead := \u0026ListNode{Next: head} pre, p, q := fakeHead, head, head for i := 0; i \u003c n; i++ { q = q.Next } for q != nil { pre = p p = p.Next q = q.Next } pre.Next = p.Next return fakeHead.Next } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/:1:0","tags":["算法","链表"],"title":"19. 删除链表的倒数第 N 个结点","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/19.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/"},{"categories":["算法"],"content":"206. 反转链表 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":["算法","链表"],"title":"206. 反转链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["算法"],"content":"⭐ 双指针 func reverseList(head *ListNode) *ListNode { if head == nil { return nil } var pre, cur *ListNode = nil, head for cur != nil { tmp := cur.Next cur.Next = pre pre = cur cur = tmp } return pre } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:1:0","tags":["算法","链表"],"title":"206. 反转链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["算法"],"content":"递归 实质上和双指针一样 func reverseList(head *ListNode) *ListNode { var reverse func(pre, cur *ListNode) *ListNode reverse = func(pre, cur *ListNode) *ListNode { if cur == nil { return pre } after := cur.Next cur.Next = pre return reverse(cur, after) } return reverse(nil, head) } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:2:0","tags":["算法","链表"],"title":"206. 反转链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["算法"],"content":"另一种递归 很妙啊 func reverseList(head *ListNode) *ListNode { if head == nil { return nil } if head.Next == nil { return head } last := reverseList(head.Next) head.Next.Next = head // 翻转头节点与第二个节点的指向 head.Next = nil return last } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:3:0","tags":["算法","链表"],"title":"206. 反转链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":["刷题"],"content":"384. 打乱数组 给你一个整数数组 nums ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 等可能 的。 实现 Solution class: Solution(int[] nums) 使用整数数组 nums 初始化对象 int[] reset() 重设数组到它的初始状态并返回 int[] shuffle() 返回数组随机打乱后的结果 示例 1： 输入 [\"Solution\", \"shuffle\", \"reset\", \"shuffle\"] [[[1, 2, 3]], [], [], []] 输出 [null, [3, 1, 2], [1, 2, 3], [1, 3, 2]] 解释 Solution solution = new Solution([1, 2, 3]); solution.shuffle(); // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2] solution.reset(); // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3] solution.shuffle(); // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2] 提示： 1 \u003c= nums.length \u003c= 200 -106 \u003c= nums[i] \u003c= 106 nums 中的所有元素都是 唯一的 最多可以调用 5 * 104 次 reset 和 shuffle ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/:0:0","tags":["算法","数组"],"title":"384. 打乱数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"朴素思想 每次从剩余的原数组中拿一个出来到新数组，直到拿完为止 import \"math/rand\" type Solution struct { nums, original []int } func Constructor(nums []int) Solution { return Solution{nums, append([]int(nil), nums...)} } func (s *Solution) Reset() []int { copy(s.nums, s.original) return s.nums } func (s *Solution) Shuffle() []int { shuffled := make([]int, len(s.nums)) for i := range shuffled { j := rand.Intn(len(s.nums)) shuffled[i] = s.nums[j] s.nums = append(s.nums[:j], s.nums[j+1:]...) } s.nums = shuffled return s.nums } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/:1:0","tags":["算法","数组"],"title":"384. 打乱数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"Fisher-Yates 洗牌算法 type Solution struct { nums, original []int } func Constructor(nums []int) Solution { return Solution{nums, append([]int(nil), nums...)} } func (s *Solution) Reset() []int { copy(s.nums, s.original) return s.nums } func (s *Solution) Shuffle() []int { n := len(s.nums) for i := range s.nums { j := i + rand.Intn(n-i) s.nums[i], s.nums[j] = s.nums[j], s.nums[i] } return s.nums } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/:2:0","tags":["算法","数组"],"title":"384. 打乱数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/384.-%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"454. 四数相加 II mid 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 \u003c= i, j, k, l \u003c n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 1： 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出：2 解释： 两个元组如下： 1. (0, 0, 0, 1) -\u003e nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -\u003e nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] 输出：1 ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/454.-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-ii/:0:0","tags":["算法","哈希"],"title":"454. 四数相加 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/454.-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-ii/"},{"categories":["刷题"],"content":"分组 + 哈希 找到所有 a+b 的和，跟 c+d 的和匹配；注意可以重复 func fourSumCount(nums1 []int, nums2 []int, nums3 []int, nums4 []int) int { hash := make(map[int]int) count := 0 for _, a := range nums1 { for _, b := range nums2 { hash[a+b]++ } } for _, c := range nums3 { for _, d := range nums4 { count += hash[-(c + d)] } } return count } ","date":"2022-03-08","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/454.-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-ii/:1:0","tags":["算法","哈希"],"title":"454. 四数相加 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/454.-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-ii/"},{"categories":["刷题"],"content":"9. 回文数 给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 例如，121 是回文，而 123 不是。 示例 1： 输入：x = 121 输出：true 示例 2： 输入：x = -121 输出：false 解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 ","date":"2022-03-07","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/:0:0","tags":["算法","数学"],"title":"9. 回文数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["刷题"],"content":"转字符串 比较无脑 func isPalindrome(x int) bool { if x \u003c 0 { return false } arr := make([]int, 0) for x \u003e 0 { arr = append(arr, x%10) x /= 10 } l, r := 0, len(arr)-1 for l \u003c= r { if arr[l] != arr[r] { return false } l++ r-- } return true } ","date":"2022-03-07","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/:1:0","tags":["算法","数学"],"title":"9. 回文数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["刷题"],"content":"反转一半数字 func isPalindrome(x int) bool { // 特殊情况： // 如上所述，当 x \u003c 0 时，x 不是回文数。 // 同样地，如果数字的最后一位是 0，为了使该数字为回文， // 则其第一位数字也应该是 0 // 只有 0 满足这一属性 if x \u003c 0 || (x%10 == 0 \u0026\u0026 x != 0) { return false } revertedNumber := 0 for x \u003e revertedNumber { revertedNumber = revertedNumber*10 + x%10 x /= 10 } // 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。 // 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123， // 由于处于中位的数字不影响回文（它总是与自己相等），所以我们可以简单地将其去除。 return x == revertedNumber || x == revertedNumber/10 } ","date":"2022-03-07","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/:2:0","tags":["算法","数学"],"title":"9. 回文数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/"},{"categories":["Golang"],"content":"非类型安全指针 相对于 C 指针，Go 指针有很多限制。 比如，Go 指针不支持算术运算，并且对于任意两个指针值，很可能它们不能转换到对方的类型。 事实上，一般指针的完整称呼应该为类型安全指针。 虽然类型安全指针有助于我们轻松写出安全的代码，但是有时候施加在类型安全指针上的限制也确实导致我们不能写出最高效的代码。 实际上，Go 也支持限制较少的非类型安全指针。 非类型安全指针和 C 指针类似，它们都很强大，但同时也都很危险。 在某些情形下，通过非类型安全指针的帮助，我们可以写出效率更高的代码； 但另一方面，使用非类型安全指针也导致我们可能轻易地写出潜在的不安全的代码，这些潜在的不安全点很难在它们产生危害之前被及时发现。 使用非类型安全指针的另外一个较大的风险是 Go 中目前提供的非类型安全指针机制并不受到 Go1 兼容性保证的保护。 使用了非类型安全指针的代码可能从今后的某个 Go 版本开始将不再能编译通过，或者运行行为发生了变化。 如果出于种种原因，你确实希望在你的代码中使用非类型安全指针，你不仅需要提防上述风险，你还需遵守 Go 官方文档中列出的非类型安全指针使用模式，并清楚地知晓使用非类型安全指针带来的效果。否则，你很难使用非类型安全指针写出安全的代码。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/:0:0","tags":["进阶"],"title":"Go 非类型安全指针","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"关于 unsafe 标准库包 非类型安全指针在 Go 中为一种特别的类型。 我们必须引入 unsafe 标准库包来使用非类型安全指针。 非类型安全指针 unsafe.Pointer 被声明定义为： type Pointer *ArbitraryType 当然，这不是一个普通的类型定义。这里的 ArbitraryType 仅仅是暗示 unsafe.Pointer 类型值可以被转换为任意类型安全指针（反之亦然）。换句话说，unsafe.Pointer 类似于 C 语言中的 void*。 非类型安全指针是指底层类型为 unsafe.Pointer 的类型。 非类型安全指针的零值也使用预声明的 nil 标识符来表示。 在 Go 1.17 之前，unsafe 标准库包只提供了三个函数： func Alignof(variable ArbitraryType) uintptr。 此函数用来取得一个值在内存中的地址对齐保证（address alignment guarantee）。 注意，同一个类型的值做为结构体字段和非结构体字段时地址对齐保证可能是不同的。 当然，这和具体编译器的实现有关。对于目前的标准编译器，同一个类型的值做为结构体字段和非结构体字段时的地址对齐保证总是相同的。 gccgo 编译器对这两种情形是区别对待的。 func Offsetof(selector ArbitraryType) uintptr 此函数用来取得一个结构体值的某个字段的地址相对于此结构体值的地址的偏移。 在一个程序中，对于同一个结构体类型的不同值的对应相同字段，此函数的返回值总是相同的。 func Sizeof(variable ArbitraryType) uintptr 此函数用来取得一个值的尺寸（亦即此值的类型的尺寸）。 在一个程序中，对于同一个类型的不同值，此函数的返回值总是相同的。 注意： 这三个函数的返回值的类型均为内置类型 uintptr。下面我们将了解到 uintptr 类型的值可以转换为非类型安全指针（反之亦然）。 尽管这三个函数之一的任何调用的返回结果在同一个编译好的程序中总是一致的，但是这样的一个调用在不同架构的操作系统中（或者使用不同的编译器编译时）的返回值可能是不一样的。 这三个函数的调用总是在编译时刻被估值，估值结果为类型为 uintptr 的常量。 传递给 Offsetof 函数的实参必须为一个字段选择器形式value.field。 此选择器可以表示一个内嵌字段，但此选择器的路径中不能包含指针类型的隐式字段。 一个使用了这三个函数的例子： package main import \"fmt\" import \"unsafe\" func main() { var x struct { a int64 b bool c string } const M, N = unsafe.Sizeof(x.c), unsafe.Sizeof(x) fmt.Println(M, N) // 16 32 fmt.Println(unsafe.Alignof(x.a)) // 8 fmt.Println(unsafe.Alignof(x.b)) // 1 fmt.Println(unsafe.Alignof(x.c)) // 8 fmt.Println(unsafe.Offsetof(x.a)) // 0 fmt.Println(unsafe.Offsetof(x.b)) // 8 fmt.Println(unsafe.Offsetof(x.c)) // 16 } 下面是一个展示了上面提到的最后一个注意点的例子： package main import \"fmt\" import \"unsafe\" func main() { type T struct { c string } type S struct { b bool } var x struct { a int64 *S T } fmt.Println(unsafe.Offsetof(x.a)) // 0 fmt.Println(unsafe.Offsetof(x.S)) // 8 fmt.Println(unsafe.Offsetof(x.T)) // 16 // 此行可以编译过，因为选择器x.c中的隐含字段T为非指针。 fmt.Println(unsafe.Offsetof(x.c)) // 16 // 此行编译不过，因为选择器x.b中的隐含字段S为指针。 //fmt.Println(unsafe.Offsetof(x.b)) // error // 此行可以编译过，但是它将打印出字段b在x.S中的偏移量. fmt.Println(unsafe.Offsetof(x.S.b)) // 0 } 注意，上面程序中的注释所暗示的输出结果是此程序在AMD64架构上使用标准编译器1.17版本编译时的结果。 unsafe包提供的这三个函数看上去并不怎么危险。 它们的原型在以后的Go 1版本中几乎不可能会发生改变。 Rob Pike甚至曾经将这几个函数挪到其它包中。 unsafe包的危险性基本上来自于非类型安全指针。它们和C指针一样危险，这是Go安全指针千方百计设法去避免的。 Go 1.17引入了一个新类型和两个新函数。 此新类型为IntegerType。它的定义如下。 此类型不代表着一个具体类型，它只是表示任意整数类型（有点泛型的意思）。 type IntegerType int Go 1.17引入的两个函数为： func Add(ptr Pointer, len IntegerType) Pointer。 此函数在一个（非安全）指针表示的地址上添加一个偏移量，然后返回表示新地址的一个指针。 此函数以一种更正规的形式部分地覆盖了下面将要介绍的使用模式3中展示的合法用法。 func Slice(ptr *ArbitraryType, len IntegerType) []ArbitraryType。 此函数用来从一个任意（安全）指针派生出一个指定长度的切片。 Go 1.17引入的这两个函数具有一定的危险性，需谨慎使用。下面时使用了这两个函数的一个例子。 package main import ( \"fmt\" \"unsafe\" ) func main() { a := [16]int{3: 3, 9: 9, 11: 11} fmt.Println(a) eleSize := int(unsafe.Sizeof(a[0])) p9 := \u0026a[9] up9 := unsafe.Pointer(p9) p3 := (*int)(unsafe.Add(up9, -6 * eleSize)) fmt.Println(*p3) // 3 s := unsafe.Slice(p9, 5)[:3] fmt.Println(s) // [9 0 11] fmt.Println(len(s), cap(s)) // 3 5 t := unsafe.Slice((*int)(nil), 0) fmt.Println(t == nil) // true // 下面是两个不正确的调用。因为它们 // 的返回结果引用了未知的内存块。 _ = unsafe.Add(up9, 7 * eleSize) _ = unsafe.Slice(p9, 8) } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/:1:0","tags":["进阶"],"title":"Go 非类型安全指针","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"非类型安全指针相关的类型转换 目前（Go 1.17），Go支持下列和非类型安全指针相关的类型转换： 一个类型安全指针值可以被显式转换为一个非类型安全指针类型，反之亦然。 一个uintptr值可以被显式转换为一个非类型安全指针类型，反之亦然。 但是，注意，一个nil非类型安全指针类型不应该被转换为uintptr并进行算术运算后再转换回来。 通过使用这些转换规则，我们可以将任意两个类型安全指针转换为对方的类型，我们也可以将一个安全指针值和一个uintptr值转换为对方的类型。 然而，尽管这些转换在编译时刻是合法的，但是它们中一些在运行时刻并非是合法和安全的。 这些转换摧毁了Go的类型系统（不包括非类型安全指针部分）精心设立的内存安全屏障。 我们必须遵循本文后面要介绍的一些用法指示来使用非类型安全指针才能写出合法并安全的代码。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/:1:1","tags":["进阶"],"title":"Go 非类型安全指针","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"我们需要知道的一些事实 在开始介绍合法的非类型安全指针使用模式之前，我们需要知道一些事实。 事实一：非类型安全指针值是指针但uintptr值是整数 每一个非零安全或者不安全指针值均引用着另一个值。但是一个uintptr值并不引用任何值，它被看作是一个整数，尽管常常它存储的是一个地址的数字表示。 Go是一门支持垃圾回收的语言。 当一个Go程序在运行中，Go运行时（runtime）将不时地检查哪些内存块将不再被程序中的任何仍在使用中的值所引用并且回收这些内存块。 指针在这一过程中扮演着重要的角色。值与值之间和内存块与值之间的引用关系是通过指针来表征的。 既然一个uintptr值是一个整数，那么它可以参与算术运算。 下一节中的例子将展示指针和uintptr值的不同。 事实二：不再被使用的内存块的回收时间点是不确定的 在运行时刻，一次新的垃圾回收过程可能在一个不确定的时间启动，并且此过程可能需要一段不确定的时长才能完成。 所以一个不再被使用的内存块的回收时间点是不确定的。 一个例子： import \"unsafe\" // 假设此函数不会被内联（inline）。 //go:noinline func createInt() *int { return new(int) } func foo() { p0, y, z := createInt(), createInt(), createInt() var p1 = unsafe.Pointer(y) // 和y一样引用着同一个值 var p2 = uintptr(unsafe.Pointer(z)) // 此时，即使z指针值所引用的int值的地址仍旧存储 // 在p2值中，但是此int值已经不再被使用了，所以垃圾 // 回收器认为可以回收它所占据的内存块了。另一方面， // p0和p1各自所引用的int值仍旧将在下面被使用。 // uintptr值可以参与算术运算。 p2 += 2; p2--; p2-- *p0 = 1 // okay *(*int)(p1) = 2 // okay *(*int)(unsafe.Pointer(p2)) = 3 // 危险操作！ } 在上面这个例子中，值p2仍旧在使用这个事实并不能保证曾经被z指针值所引用的int值所占的内存块一定还没有被回收。 换句话说，当*(*int)(unsafe.Pointer(p2)) = 3被执行的时候，此内存块有可能已经被回收了。 所以，继续通过解引用值p2中存储的地址是非常危险的，因为此内存块可能已经被重新分配给其它值使用了。 事实三：一个值的地址在程序运行中可能改变 详情请阅读内存块一文（见链接所指一节的尾部）。 这里我们只需要知道当一个协程的栈的大小改变时，开辟在此栈上的内存块需要移动，从而相应的值的地址将改变。 事实四：一个值的生命范围可能并没有代码中看上去的大 比如中下面这个例子，值t仍旧在使用中并不能保证被值t.y所引用的值仍在被使用。 type T struct { x int y *[1\u003c\u003c23]byte } func bar() { t := T{y: new([1\u003c\u003c23]byte)} p := uintptr(unsafe.Pointer(\u0026t.y[0])) ... // 使用t.x和t.y // 一个聪明的编译器能够觉察到值t.y将不会再被用到， // 所以认为t.y值所占的内存块可以被回收了。 *(*byte)(unsafe.Pointer(p)) = 1 // 危险操作！ println(t.x) // ok。继续使用值t，但只使用t.x字段。 } 事实五：*unsafe.Pointer是一个类型安全指针类型 是的，类型*unsafe.Pointer是一个类型安全指针类型。 它的基类型为unsafe.Pointer。 既然它是一个类型安全指针类型，根据上面列出的类型转换规则，它的值可以转换为类型unsafe.Pointer，反之亦然。 一个例子： package main import \"unsafe\" func main() { x := 123 // 类型为int p := unsafe.Pointer(\u0026x) // 类型为unsafe.Pointer pp := \u0026p // 类型为*unsafe.Pointer p = unsafe.Pointer(pp) pp = (*unsafe.Pointer)(p) } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/:1:2","tags":["进阶"],"title":"Go 非类型安全指针","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"如何正确地使用非类型安全指针？ unsafe标准库包的文档中列出了六种非类型安全指针的使用模式。 下面将对它们逐一进行讲解。 使用模式一：将类型*T1的一个值转换为非类型安全指针值，然后将此非类型安全指针值转换为类型*T2。 利用前面列出的非类型安全指针相关的转换规则，我们可以将一个*T1值转换为类型*T2，其中T1和T2为两个任意类型。 然而，我们只有在T1的尺寸不小于T2并且此转换具有实际意义的时候才应该实施这样的转换。 通过将一个*T1值转换为类型*T2，我们也可以将一个T1值转换为类型T2。 一个这样的例子是math标准库包中的Float64bits函数。 此函数将一个float64值转换为一个uint64值。 在此转换过程中，此float64值在内存中的每个位（bit）都保持不变。 函数math.Float64frombits为此转换的逆转换。 func Float64bits(f float64) uint64 { return *(*uint64)(unsafe.Pointer(\u0026f)) } func Float64frombits(b uint64) float64 { return *(*float64)(unsafe.Pointer(\u0026b)) } 请注意，函数调用math.Float64bits(aFloat64)的结果和显式转换uint64(aFloat64)的结果不同。 在下面这个例子中，我们使用此模式将一个[]MyString值和一个[]string值转换为对方的类型。 结果切片和被转换的切片将共享底层元素。（这样的转换是不可能通过安全的方式来实现的。） package main import ( \"fmt\" \"unsafe\" ) func main() { type MyString string ms := []MyString{\"C\", \"C++\", \"Go\"} fmt.Printf(\"%s\\n\", ms) // [C C++ Go] // ss := ([]string)(ms) // 编译错误 ss := *(*[]string)(unsafe.Pointer(\u0026ms)) ss[1] = \"Rust\" fmt.Printf(\"%s\\n\", ms) // [C Rust Go] // ms = []MyString(ss) // 编译错误 ms = *(*[]MyString)(unsafe.Pointer(\u0026ss)) } 当然，从Go 1.17开始，我们也可以使用unsafe.Slice((*string)(\u0026ms[0]), len(ms))来实现此类型转换。 此模式在实践中的另一个应用是将一个不再使用的字节切片转换为一个字符串（从而避免对底层字节序列的一次开辟和复制）。如下例所示： func ByteSlice2String(bs []byte) string { return *(*string)(unsafe.Pointer(\u0026bs)) } 此实现借鉴于strings标准库包中的Builder类型的String方法的实现。 字节切片的尺寸比字符串的尺寸要大，并且它们的底层结构类似，所以此转换（对于当前的主流Go编译器来说）是安全的。 即使这样，此实现也只推荐在标准库中使用，而不推荐在用户代码中使用。 在用户代码中，最好尽量使用文末提供的另一种实现。 反过来，下面这个例子中的转换是非法的，因为字符串的尺寸比字节切片的尺寸小。 func String2ByteSlice(s string) []byte { return *(*[]byte)(unsafe.Pointer(\u0026s)) // 危险 } 在后面的模式六中展示了一种合法的（无需复制底层字节序列即可）将一个字符串转换为字节切片的实现。 注意：当运用上面展示的使用非类型安全指针将一个字节切片转换为字符串的技巧时，请确保结果字符串在使用过程中绝对不修改此字节切片中的字节值。 使用模式二：将一个非类型安全指针值转换为一个uintptr值，然后使用此uintptr值。 此模式不是很有用。一般我们将最终的转换结果uintptr值输出到日志中用来调试，但是有很多其它安全并且简洁的途径也可以实现此目的。 一个例子： package main import \"fmt\" import \"unsafe\" func main() { type T struct{a int} var t T fmt.Printf(\"%p\\n\", \u0026t) // 0xc6233120a8 println(\u0026t) // 0xc6233120a8 fmt.Printf(\"%x\\n\", uintptr(unsafe.Pointer(\u0026t))) // c6233120a8 } 输出地址在每次运行中可能都会不同。 使用模式三：将一个非类型安全指针转换为一个uintptr值，然后此uintptr值参与各种算术运算，再将算术运算的结果uintptr值转回非类型安全指针。 转换前后的非类型安全指针必须指向同一个内存块。一个例子： package main import \"fmt\" import \"unsafe\" type T struct { x bool y [3]int16 } const N = unsafe.Offsetof(T{}.y) const M = unsafe.Sizeof(T{}.y[0]) func main() { t := T{y: [3]int16{123, 456, 789}} p := unsafe.Pointer(\u0026t) // \"uintptr(p) + N + M + M\"为t.y[2]的内存地址。 ty2 := (*int16)(unsafe.Pointer(uintptr(p)+N+M+M)) fmt.Println(*ty2) // 789 } 其实，对于这样地址加减运算，更推荐使用上面介绍的Go 1.17中引入的unsafe.Add函数来完成。 注意：在上面这个例子中，转换unsafe.Pointer(uintptr(p) + N + M + M)不应该像下面这样被拆成两行。 请阅读下面的代码中的注释以获取原因。 func main() { t := T{y: [3]int16{123, 456, 789}} p := unsafe.Pointer(\u0026t) // ty2 := (*int16)(unsafe.Pointer(uintptr(p)+N+M+M)) addr := uintptr(p) + N + M + M // ...（一些其它操作） // 从这里到下一行代码执行之前，t值将不再被任何值 // 引用，所以垃圾回收器认为它可以被回收了。一旦 // 它真地被回收了，下面继续使用t.y[2]值的曾经 // 的地址是非法和危险的！另一个危险的原因是 // t的地址在执行下一行之前可能改变（见事实三）。 // 另一个潜在的危险是：如果在此期间发生了一些 // 操作导致协程堆栈大小改变的情况，则记录在addr // 中的地址将失效。 ty2 := (*int16)(unsafe.Pointer(addr)) fmt.Println(*ty2) } 这样的bug是非常微妙和很难被觉察到的，并且爆发出来的几率是相当得低。 一旦这样的bug爆发出来，将很让人摸不到头脑。这也是使用非类型安全指针被认为是危险操作的原因之一。 中间uintptr值可以参与\u0026^清位运算来进行内存对齐计算，只要保证转换前后的非类型安全指针同时指向同一个内存块，整个转换就是合法安全的。 另一个需要注意的细节是最好不要将一个内存块的结尾边界地址存储在一个（安全或非安全）指针中。 这样做将导致紧随着此内存块的另一个内存块因为被引用而不会被垃圾回收掉，或者因为形成非法指针而导致程序崩溃（取决于具体编译器实现）。 请阅读这个问答以获取更多解释。 使用模式四：将非类型安全指针值转换为uintptr值并传递给syscall.Syscall函数调用。 通过对上一个使用模式的解释，我们知道像下面这样含有uintptr类型的参数的函数定义是危险的。 // 假设此函数不会被内联。 func DoSomething(addr uintptr) { // 对处于传递进来的地址处的值进行读写... } 上面这个函数是危险的原因在于此函数本身不能保证传递进来的地址处的内存块一定没有被回收。 如果此内存块已经被回收了或者被重新分配给了其它值，那么此函数内部的操作将是非法和危险的。 然而，syscall标准库包中的Syscall函数的原型为： func Syscall(trap, a1, a2, a3 uintptr) (r1, r2 uintptr, err Errno) 那么此函数是如何保证处于传递给它的地址参数值a1、a2和a3处的内存块在此函数执行过程中一定没有被回收和被移动呢？ 此函数无法做出这样的保证。事实上，是编译器做出了这样的保证。 这是syscall.Syscall这样的函数的特权。其它自定义函数无法享受到这样的待遇。 我们可以认为编译器针对每个syscall.Syscall函数调用中的每个被转换为uintptr类型的非类型安全指针实参添加了一些指令，从而保证此非类型安全指针所引用着的内存块在此调用返回之前不会被垃圾回收和移动。 注意：在Go 1.15之前，类型转换表达式uintptr(anUnsafePointer)可以呈现为相关实参的子表达式。 但是，从Go 1.15开始，使用此模式的要求变得略加严格：相关","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/:1:3","tags":["进阶"],"title":"Go 非类型安全指针","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"总结一下 从上面解释中，我们得知，对于某些情形，非类型安全机制可以帮助我们写出运行效率更高的代码。 但是，使用非类型安全指针也使得我们可能轻易地写出一些重现几率非常低的微妙的bug。 一个含有这样的bug的程序很可能在很长一段时间内都运行正常，但是突然变得不正常甚至崩溃。 这样的bug很难发现和调试。 我们只应该在不得不使用非类型安全机制的时候才使用它们。 特别地，当我们使用非类型安全机制时，请务必遵循上面列出的使用模式。 重申一次，我们应该知晓当前的非类型安全机制规则和使用模式可能在以后的Go版本中完全失效。 当然，目前没有任何迹象表明这种变化将很快会来到。 但是，一旦发生这种变化，本文中列出的当前是正确的代码将变得不再安全甚至编译不通过。 所以，在实践中，请尽量保证能够将使用了非类型安全机制的代码轻松改为使用安全途径实现。 最后值得提一下的是，Go官方工具链1.14中加入了一个-gcflags=all=-d=checkptr编译器动态分析选项（在Windows平台上推荐使用工具链1.15+）。 当此选项被使用的时候，编译出的程序在运行时会监测到很多（但并非所有）非类型安全指针的错误使用。一旦错误的使用被监测到，恐慌将产生。 感谢Matthew Dempsky实现了此特性。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/:1:4","tags":["进阶"],"title":"Go 非类型安全指针","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/"},{"categories":["Golang"],"content":"Go 类型系统 太难了根本看不懂 T T ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:0:0","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"概述 本文将介绍 Go 中的各个类型种类。Go 类型系统中的各种概念也将被介绍。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:0","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"概念：基本类型（basic type） 内置字符串类型：string. 内置布尔类型：bool. 内置数值类型： int8、uint8（byte）、int16、uint16、int32（rune）、uint32、int64、uint64、int、uint、uintptr。 float32、float64。 complex64、complex128。 注意，byte 是 uint8 的一个内置别名，rune 是 int32 的一个内置别名。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:1","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"概念：组合类型（composite type） Go支持下列组合类型： 指针类型 - 类 C 指针 结构体类型 - 类 C 结构体 函数类型 - 函数类型在 Go 中是一种一等公民类别 容器类型，包括: 数组类型 - 定长容器类型 切片类型 - 动态长度和容量容器类型 映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。 通道类型 - 通道用来同步并发的协程 接口类型 - 接口在反射和多态中发挥着重要角色 非定义组合类型可以用它们各自的字面表示形式来表示。 下面是一些各种不同种类的非定义组合类型字面表示形式的例子（非定义类型将在下面解释）： // 假设T为任意一个类型，Tkey为一个支持比较的类型。 *T // 一个指针类型 [5]T // 一个元素类型为T、元素个数为5的数组类型 []T // 一个元素类型为T的切片类型 map[Tkey]T // 一个键值类型为Tkey、元素类型为T的映射类型 // 一个结构体类型 struct { name string age int } // 一个函数类型 func(int) (bool, string) // 一个接口类型 interface { Method0(string) int Method1() (int, bool) } // 几个通道类型 chan T chan\u003c- T \u003c-chan T ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:2","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"事实：类型的种类 每种上面提到的基本类型和组合类型都对应着一个类型种类（kind）。除了这些种类，今后将要介绍的非类型安全指针类型属于另外一个新的类型种类。 所以，目前（Go 1.17），Go 有 26 个类型种类。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:3","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"✔️ 语法：类型定义 type definition declaration 在Go中，我们可以用如下形式来定义新的类型。在此语法中，type为一个关键字。 // 定义单个类型。 type NewTypeName SourceType // 定义多个类型。 type ( NewTypeName1 SourceType1 NewTypeName2 SourceType2 ) 新的类型名必须为标识符。但是请注意：包级类型（以及类型别名）的名称不能为 init。 上例中的第二个类型声明中包含两个类型描述（type specification）。 如果一个类型声明包含多于一个的类型描述，这些类型描述必须用一对小括号 () 括起来。 注意： 一个新定义的类型和它的源类型为两个不同的类型。 在两个不同的类型定义中定义的两个类型肯定为两个不同的类型。 一个新定义的类型和它的源类型的底层类型一致并且它们的值可以相互显式转换。 类型定义可以出现在函数体内。 一些类型定义的例子： // 下面这些新定义的类型和它们的源类型都是基本类型。 type ( MyInt int Age int Text string ) // 下面这些新定义的类型和它们的源类型都是组合类型。 type IntPtr *int type Book struct{author, title string; pages int} type Convert func(in0 int, in1 bool)(out0 int, out1 string) type StringArray [5]string type StringSlice []string func f() { // 这三个新定义的类型名称只能在此函数内使用。 type PersonAge map[string]int type MessageQueue chan string type Reader interface{Read([]byte) int} } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:4","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"✔️ 语法：类型别名声明 type alias declaration 从 Go 1.9 开始，我们可以使用下面的语法来声明自定义类型别名。此语法和类型定义类似，但是请注意每个类型描述中多了一个等号 =。 type ( Name = string Age = int ) type table = map[string]int type Table = map[Name]Age 类型别名也必须为标识符。同样地，类型别名可以被声明在函数体内。 在上面的类型别名声明的例子中，Name 是内置类型 string 的一个别名，它们表示同一个类型。 事实上，文字表示形式 map[string]int 和 map[Name]Age 也表示同一类型。 所以，table 和 Table 一样表示同一个类型。 注意，尽管两个别名 table 和 Table 表示同一个类型，但 Table 是导出的，所以它可以被其它包引入使用，而table 却不可以。 类型别名声明在重构一些大的 Go 项目等场合很有用。 在通常编程中，类型定义声明使用得更广泛。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:5","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"概念：定义类型和非定义类型 defined type and undefined type 一个定义类型是一个在某个类型定义声明中定义的类型。 所有的基本类型都是定义类型。一个非定义类型一定是一个组合类型。 在下面的例子中，别名 C 和类型字面表示 []string 都表示同一个非定义类型。 类型 A 和别名 B 均表示同一个定义类型。 type A []string type B = A type C = []string ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:6","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"概念：有名类型和无名类型 named type and unnamed type 在 Go 1.9 之前，有名类型这一术语准确地定义在 Go 白皮本中。它曾被定义为一个有名字的类型。 随着 Go 1.9 中引入的类型别名新特性，此术语被从白皮书中删除了，原因是它可能会造成一些理解上的困惑。 比如，一些类型字面表示（比如上一节出现中的别名 C）是一个标识符（即一个名称），但是它们所表示的类型（比如 []string）在 Go 1.9 之前却被称为无名类型。 为了避免出现这样的困惑，从 Go 1.9 开始，一个新的术语定义类型被引入来填补移除有名类型后的空白。 然而此举也给一些概念解释造成了新的障碍，或者形成了一些尴尬的局面。 为了避免这些尴尬的此文将遵守如下原则： 一个类型别名将不会被称为一个类型，尽管我们常说它表示着一个类型。 术语有名类型和定义类型将被视为完全相同的概念。（同样地，无名类型和非定义类型亦为同一概念。） 换句话说，当提到 “一个类型别名 T 是一个有名类型”，其实际意义是类型别名 T 表示着一个有名类型。 如果 T 表示着一个无名类型，则我们不应该说 T 是一个有名类型，即使别名 T 它本身拥有一个名字。 当我们提及一个类型名（称），它可能是一个定义类型的名称，也可能是一个类型别名的名称。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:7","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"✔️ 概念：底层类型 underlying type 在 Go 中，每个类型都有一个底层类型。规则： 一个内置类型的底层类型为它自己。 unsafe 标准库包中定义的 Pointer 类型的底层类型是它自己。 至少我们可以认为是这样。事实上，关于unsafe.Pointer 类型的底层类型，官方文档中并没有清晰的说明。我们也可以认为 unsafe.Pointer 类型的底层类型为 *T，其中 T 表示一个任意类型。 一个非定义类型（必为一个组合类型）的底层类型为它自己。 在一个类型声明中，新声明的类型和源类型共享底层类型。 一个例子： // 这四个类型的底层类型均为内置类型int。 type ( MyInt int Age MyInt ) // 下面这三个新声明的类型的底层类型各不相同。 type ( IntSlice []int // 底层类型为[]int MyIntSlice []MyInt // 底层类型为[]MyInt AgeSlice []Age // 底层类型为[]Age ) // 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。 type Ages AgeSlice 如何溯源一个声明的类型的底层类型？规则很简单，在溯源过程中，当遇到一个内置类型或者非定义类型时，溯源结束。 以上面这几个声明的类型为例，下面是它们的底层类型的溯源过程： MyInt → int Age → MyInt → int IntSlice → []int MyIntSlice → []MyInt → []int AgeSlice → []Age → []MyInt → []int Ages → AgeSlice → []Age → []MyInt → []int 在 Go 中， 底层类型为内置类型 bool 的类型称为布尔类型； 底层类型为任一内置整数类型的类型称为整数类型； 底层类型为内置类型 float32 或者 float64 的类型称为浮点数类型； 底层类型为内置类型 complex64 或 complex128 的类型称为复数类型； 整数类型、浮点数类型和复数类型统称为数字值类型； 底层类型为内置类型 string 的类型称为字符串类型。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:8","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"事实：可比较类型和不可比较类型 目前（Go 1.17），下面这些类型的值不支持（使用 == 和 != 运算标识符）比较。这些类型称为不可比较类型。 切片类型 映射类型 函数类型 任何包含有不可比较类型的字段的结构体类型 任何元素类型为不可比较类型的数组类型。 其它类型称为可比较类型。 映射类型的键值类型必须为可比较类型。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:1:9","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"基本类型的字面量表示 这一节不是很重要。。 一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:0","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"布尔值的字面量形式 Go白皮书没有定义布尔类型值字面量形式。 我们可以将 false 和 true 这两个预声明的有名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。有名常量声明将在下一篇文章中介绍和详细解释。 布尔类型的零值可以使用预声明的 false 来表示。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:1","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"整数类型值的字面量形式 整数类型值有四种字面量形式：十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）。 比如，下面的三个字面量均表示十进制的15： 0xF // 十六进制表示（必须使用0x或者0X开头） 0XF 017 // 八进制表示（必须使用0、0o或者0O开头） 0o17 0O17 0b1111 // 二进制表示（必须使用0b或者0B开头） 0B1111 15 // 十进制表示（必须不能用0开头） （注意：二进制形式和以 0o 或 0O 开头的八进制形式从 Go 1.13 开始才支持。） 下面的程序打印出两个 true。 package main func main() { println(15 == 017) // true println(15 == 0xF) // true } 整数类型的零值的字面量一般使用 0 表示。 当然，00 和 0x0 等也是合法的整数类型零值的字面量形式。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:2","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"浮点数类型值的字面量形式 一个浮点数的完整十进制字面量形式可能包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个以 10为 底数的整数指数部分。 整数指数部分由字母 e 或者 E 带一个十进制的整数字面量组成（xEn 表示 x 乘以 10n 的意思，而 xE-n 表示 x 除以 10n 的意思）。 常常地，某些部分可以根据情况省略掉。一些例子： 1.23 01.23 // == 1.23 .23 1. // 一个e或者E随后的数值是指数值（底数为10）。 // 指数值必须为一个可以带符号的十进制整数字面量。 1.23e2 // == 123.0 123E2 // == 12300.0 123.E+2 // == 12300.0 1e-1 // == 0.1 .1e0 // == 0.1 0010e-2 // == 0.1 0e+5 // == 0.0 从 Go 1.13 开始，Go 也支持另一种浮点数字面量形式：十六进制浮点数字面量。 在一个十六进制浮点数字面量中 一个十六进制浮点数字面量必须以一个以 2 为底数的整数指数部分。 这样的一个整数指数部分由字母 p 或者 P 带一个十进制的整数字面量组成（yPn 表示 y 乘以 2n 的意思，而 yP-n 表示 y 除以 2n 的意思）。 和整数的十六进制字面量一样，一个十六进制浮点数字面量也必须使用 0x 或者 0X 开头。 和整数的十六进制字面量不同的是，一个十六进制浮点数字面量可以包括一个小数点和一个十六进制小数部分。 一些合法的浮点数的十六进制字面量例子： 0x1p-2 // == 1.0/4 = 0.25 0x2.p10 // == 2.0 * 1024 == 2048.0 0x1.Fp+0 // == 1+15.0/16 == 1.9375 0X.8p1 // == 8.0/16 * 2 == 1.0 0X1FFFP-16 // == 0.1249847412109375 而下面这几个均是不合法的浮点数的十六进制字面量。 0x.p1 // 整数部分表示必须包含至少一个数字 1p-2 // p指数形式只能出现在浮点数的十六进制字面量中 0x1.5e-2 // e和E不能出现在十六进制浮点数字面量的指数部分中 注意：下面这个表示是合法的，但是它不是浮点数的十六进制字面量。事实上，它是一个减法算术表达式。其中的 e 为是十进制中的 14，0x15e 为一个整数十六进制字面量，-2 并不是此整数十六进制字面量的一部分。 0x15e-2 // == 0x15e - 2 (整数相减表达式) 浮点类型的零值的标准字面量形式为 0.0。 当然其它很多形式也是合法的，比如 0.、.0、0e0 和 0x0p0 等。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:3","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"虚部字面量形式 一个虚部值的字面量形式由一个浮点数字面量或者一个整数字面量和其后跟随的一个小写的字母 i 组成。 在 Go1.13 之前，如果虚部中 i 前的部分为一个整数字面量，则其必须为并且总是被视为十进制形式。 一些例子： 1.23i 1.i .23i 123i 0123i // == 123i（兼容性使然。见下） 1.23E2i // == 123i 1e-1i 011i // == 11i（兼容性使然。见下） 00011i // == 11i（兼容性使然。见下） // 下面这几行从Go 1.13开始才能编译通过。 0o11i // == 9i 0x11i // == 17i 0b11i // == 3i 0X.8p-0i // == 0.5i 注意：在 Go 1.13 之前，虚部字面量中字母 i 前的部分只能为浮点数字面量。 为了兼容老的 Go 版本，从 Go 1.13 开始，一些虚部字面量中表现为（不以 0o 和 0O 开头的）八进制形式的整数字面量仍被视为浮点数字面量。 比如上例中的 011i、0123i 和 00011i。 虚部字面量用来表示复数的虚部。下面是一些复数值的字面量形式： 1 + 2i // == 1.0 + 2.0i 1. - .1i // == 1.0 + -0.1i 1.23i - 7.89 // == -7.89 + 1.23i 1.23i // == 0.0 + 1.23i 复数零值的标准字面表示为 0.0+0.0i。 当然 0i、.0i、0+0i 等表示也是合法的。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:4","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"数值字面表示中使用下划线分段来增强可读性 从 Go 1.13 开始，下划线 _ 可以出现在整数、浮点数和虚部数字面量中，以用做分段符以增强可读性。 但是要注意，在一个数值字面表示中，一个下划线 _ 不能出现在此字面表示的首尾，并且其两侧的字符必须为（相应进制的）数字字符或者进制表示头。 一些合法和不合法使用下划线的例子： // 合法的使用下划线的例子 6_9 // == 69 0_33_77_22 // == 0337722 0x_Bad_Face // == 0xBadFace 0X_1F_FFP-16 // == 0X1FFFP-16 0b1011_0111 + 0xA_B.Fp2i // 非法的使用下划线的例子 _69 // 下划线不能出现在首尾 69_ // 下划线不能出现在首尾 6__9 // 下划线不能相连 0_xBadFace // x不是一个合法的八进制数字 1_.5 // .不是一个合法的十进制数字 1._5 // .不是一个合法的十进制数字 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:5","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"rune 值的字面量形式 上面已经提到，rune 类型是 int32 类型的别名。 因此，rune 类型（泛指）是特殊的整数类型。 一个 rune 值可以用上面已经介绍的整数类型的字面量形式表示。 另一方面，很多各种整数类型的值也可以用本小节介绍的rune 字面量形式来表示。 在 Go 中，一个 rune 值表示一个 Unicode 码点。 一般说来，我们可以将一个 Unicode 码点看作是一个 Unicode 字符。 但是，我们也应该知道，有些 Unicode 字符由多个 Unicode 码点组成。 每个英文或中文 Unicode 字符值含有一个 Unicode 码点。 一个 rune 字面量由若干包在一对单引号中的字符组成。 包在单引号中的字符序列表示一个 Unicode 码点值。 rune 字面量形式有几个变种，其中最常用的一种变种是将一个 rune 值对应的 Unicode 字符直接包在一对单引号中。比如： 'a' // 一个英文字符 'π' '众' // 一个中文字符 下面这些 rune 字面量形式的变种和 'a' 是等价的 （字符 a 的 Unicode 值是 97）。 '\\141' // 141是97的八进制表示 '\\x61' // 61是97的十六进制表示 '\\u0061' '\\U00000061' 注意：\\ 之后必须跟随三个八进制数字字符（0-7）表示一个 byte 值， \\x 之后必须跟随两个十六进制数字字符（0-9，a-f 和 A-F）表示一个 byte 值， \\u 之后必须跟随四个十六进制数字字符表示一个 rune 值（此 run 值的高四位都为 0）， \\U 之后必须跟随八个十六进制数字字符表示一个 rune 值。 这些八进制和十六进制的数字字符序列表示的整数必须是一个合法的 Unicode 码点值，否则编译将失败。 下面这些 println 函数调用都将打印出 true。 package main func main() { println('a' == 97) println('a' == '\\141') println('a' == '\\x61') println('a' == '\\u0061') println('a' == '\\U00000061') println(0x61 == '\\x61') println('\\u4f17' == '众') } 事实上，在日常编程中，这四种rune字面量形式的变种很少用来表示 rune 值。 它们多用做字符串的双引号字面量形式中的转义字符（详见下一小节）。 如果一个 rune 字面量中被单引号包起来的部分含有两个字符， 并且第一个字符是 \\，第二个字符不是 x、 u 和 U，那么这两个字符将被转义为一个特殊字符。 目前支持的转义组合为： \\a (rune值：0x07) 铃声字符 \\b (rune值：0x08) 退格字符（backspace） \\f (rune值：0x0C) 换页符（form feed） \\n (rune值：0x0A) 换行符（line feed or newline） \\r (rune值：0x0D) 回车符（carriage return） \\t (rune值：0x09) 水平制表符（horizontal tab） \\v (rune值：0x0b) 竖直制表符（vertical tab） \\\\ (rune值：0x5c) 一个反斜杠（backslash） \\' (rune值：0x27) 一个单引号（single quote） 其中，\\n 在日常编程中用得最多。 一个例子： println('\\n') // 10 println('\\r') // 13 println('\\'') // 39 println('\\n' == 10) // true println('\\n' == '\\x0A') // true rune 类型的零值常用 '\\000'、'\\x00' 或 '\\u0000' 等来表示。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:6","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"字符串值的字面量形式 在 Go 中，字符串值是 UTF-8 编码的， 甚至所有的 Go 源代码都必须是 UTF-8 编码的。 Go 字符串的字面量形式有两种。 一种是解释型字面表示（interpreted string literal，双引号风格）。 另一种是直白字面表示（raw string literal，反引号风格）。 下面的两个字符串表示形式是等价的： // 解释形式 \"Hello\\nworld!\\n\\\"你好世界\\\"\" // 直白形式 `Hello world! \"你好世界\"` 在上面的解释形式（双引号风格）的字符串字面量中，每个 \\n 将被转义为一个换行符，每个 \\\" 将被转义为一个双引号字符。 双引号风格的字符串字面量中支持的转义字符和 rune 字面量基本一致，除了一个例外：双引号风格的字符串字面量中支持 \\\" 转义，但不支持 \\' 转义；而 rune 字面量则刚好相反。 以 \\、\\x、\\u 和 \\U 开头的 rune 字面量（不包括两个单引号）也可以出现在双引号风格的字符串字面量中。比如： // 这几个字符串字面量是等价的。 \"\\141\\142\\143\" \"\\x61\\x62\\x63\" \"\\x61b\\x63\" \"abc\" // 这几个字符串字面量是等价的。 \"\\u4f17\\xe4\\xba\\xba\" // “众”的Unicode值为4f17，它的UTF-8 // 编码为三个字节：0xe4 0xbc 0x97。 \"\\xe4\\xbc\\x97\\u4eba\" // “人”的Unicode值为4eba，它的UTF-8 // 编码为三个字节：0xe4 0xba 0xba。 \"\\xe4\\xbc\\x97\\xe4\\xba\\xba\" \"众人\" 在 UTF-8 编码中，一个 Unicode 码点（rune）可能由 1 到 4 个字节组成。 每个英文字母的 UTF-8 编码只需要一个字节；每个中文字符的 UTF-8 编码需要三个字节。 直白反引号风格的字面表示中是不支持转义字符的。 除了首尾两个反引号，直白反引号风格的字面表示中不能包含反引号。 为了跨平台兼容性，直白反引号风格的字面表示中的回车符（Unicode 码点为 0x0D） 将被忽略掉。 字符串类型的零值在代码里用 \"\" 或 `` 表示。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:7","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"基本数值类型字面量的适用范围 一个数值型的字面量只有在不需要舍入时，才能用来表示一个整数基本类型的值。 比如，1.0 可以表示任何基本整数类型的值，但 1.01 却不可以。 当一个数值型的字面量用来表示一个非整数基本类型的值时，舍入（或者精度丢失）是允许的。 每种数值类型有一个能够表示的数值范围。 如果一个字面量超出了一个类型能够表示的数值范围（溢出），则在编译时刻，此字面量不能用来表示此类型的值。 下表是一些例子： 字面表示 此字面表示可以表示哪些类型的值（在编译时刻） 256 除了 int8 和 uint8 类型外的所有的基本数值类型。 255 除了 int8 类型外的所有的基本数值类型。 -123 除了无符号整数类型外的所有的基本数值类型。 123 所有的基本数值类型。 123.000 1.23e2 'a' 1.0+0i 1.23 所有浮点数和复数基本数值类型。 0x10000000000000000 (16 zeros) 3.5e38 除了 float32 和 complex64 类型外的所有浮点数和复数基本数值类型。 1+2i 所有复数基本数值类型。 2e+308 无。 注意几个溢出的例子： 字面量 0x10000000000000000 需要 65 个比特才能表示，所以在运行时刻，任何基本整数类型都不能精确表示此字面量。 在 IEEE-754 标准中，最大的可以精确表示的 float32 类型数值为 3.40282346638528859811704183484516925440e+38，所以 3.5e38 不能表示任何 float32 和 complex64 类型的值。 在 IEEE-754 标准中，最大的可以精确表示的 float64 类型数值为 1.797693134862315708145274237317043567981e+308，因此 2e+308 不能表示任何基本数值类型的值。 尽管 0x10000000000000000 可以用来表示 float32 类型的值，但是它不能被任何 float32 类型的值所精确表示。上面已经提到了，当使用字面量来表示非整数基本数值类型的时候，精度丢失是允许的（但溢出是不允许的）。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:2:8","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"字符串 和很多其它编程语言一样，字符串类型是 Go 中的一种重要类型。本文将列举出关于字符串的各种事实。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:0","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"字符串类型的内部结构定义 对于标准编译器，字符串类型的内部结构声明如下： type _string struct { elements *byte // 引用着底层的字节 len int // 字符串中的字节数 } 从这个声明来看，我们可以将一个字符串的内部定义看作为一个字节序列。 事实上，我们确实可以把一个字符串看作是一个元素类型为 byte 的（且元素不可修改的）切片。 注意，前面的文章已经提到过多次，byte 是内置类型 uint8 的一个别名。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:1","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"关于字符串的一些简单事实 从前面的若干文章，我们已经了解到下列关于字符串的一些事实： 字符串值（和布尔以及各种数值类型的值）可以被用做常量。 Go 支持两种风格的字符串字面量表示形式：双引号风格（解释型字面表示）和反引号风格（直白字面表示）。 字符串类型的零值为空字符串。一个空字符串在字面上可以用 \"\" 或者 `` 来表示。 我们可以用运算符 + 和 += 来衔接字符串。 字符串类型都是可比较类型。 同一个字符串类型的值可以用 == 和 != 比较运算符来比较，也可以用 \u003e、\u003c、\u003e= 和 \u003c= 比较运算符来比较。 当比较两个字符串值的时候，它们的底层字节将逐一进行比较。 如果一个字符串是另一个字符串的前缀，并且另一个字符串较长，则另一个字符串为两者中的较大者。 一个例子： package main import \"fmt\" func main() { const World = \"world\" var hello = \"hello\" // 衔接字符串。 var helloWorld = hello + \" \" + World helloWorld += \"!\" fmt.Println(helloWorld) // hello world! // 比较字符串。 fmt.Println(hello == \"hello\") // true fmt.Println(hello \u003e helloWorld) // false } 更多关于字符串类型和值的事实： 字符串值的内容（即底层字节）是不可更改的。 字符串值的长度也是不可独立被更改的。 一个可寻址的字符串只能通过将另一个字符串赋值给它来整体修改它。 表达式 aString[i] 是不可寻址的。换句话说，aString[i] 不可被修改。 对于标准编译器来说，一个字符串的赋值完成之后，此赋值中的目标值和源值将共享底层字节。 一个子切片表达式 aString[start:end] 的估值结果也将和基础字符串 aString 共享一部分底层字节。 一个例子： package main import ( \"fmt\" \"strings\" ) func main() { var helloWorld = \"hello world!\" var hello = helloWorld[:5] // 取子字符串 // 104是英文字符h的ASCII（和Unicode）码。 fmt.Println(hello[0]) // 104 fmt.Printf(\"%T \\n\", hello[0]) // uint8 // hello[0]是不可寻址和不可修改的，所以下面 // 两行编译不通过。 /* hello[0] = 'H' // error fmt.Println(\u0026hello[0]) // error */ // 下一条语句将打印出：5 12 true fmt.Println(len(hello), len(helloWorld), strings.HasPrefix(helloWorld, hello)) } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:2","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"字符串编码和 Unicode 码点 Unicode 标准为全球各种人类语言中的每个字符制定了一个独一无二的值。 但 Unicode 标准中的基本单位不是字符，而是码点（code point）。大多数的码点实际上就对应着一个字符。 但也有少数一些字符是由多个码点组成的。 码点值在 Go 中用 rune 值来表示。 在 UTF-8 编码中，一个码点值可能由 1 到 4 个字节组成。 比如，每个英语码点值（均对应一个英语字符）均由一个字节组成，而每个中文字符（均对应一个中文字符）均由三个字节组成。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:3","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"字符串相关的类型转换 我们已经了解到整数可以被显式转换为字符串类型（但是反之不行）。 这里介绍两种新的字符串相关的类型转换规则： 一个字符串值可以被显式转换为一个字节切片（byte slice），反之亦然。 一个字符串值可以被显式转换为一个码点切片（rune slice），反之亦然。 码点切片到字符串的转换 码点切片中的每个码点值将被 UTF-8 编码为一到四个字节至结果字符串中。 如果一个码点值是一个不合法的 Unicode 码点值 则它将被视为 Unicode 替换字符（码点）值 0xFFFD（Unicode replacement character）。 替换字符值 0xFFFD 将被 UTF-8 编码为三个字节 0xef 0xbf 0xbd。 字符串到码点切片的转换 此字符串中存储的字节序列将被解读为一个一个码点的 UTF-8 编码序列。 非法的 UTF-8 编码字节序列将被转化为 Unicode 替换字符值 0xFFFD。 字符串到字节切片的转换 结果切片中的底层字节序列是此字符串中存储的字节序列的一份深复制。 即 Go 运行时将为结果切片开辟一块足够大的内存来容纳被复制过来的所有字节。 当此字符串的长度较长时，此转换开销是比较大的。 字节切片到字符串的转换 同样 此字节切片中的字节序列也将被深复制到结果字符串中。 当此字节切片的长度较长时，此转换开销同样是比较大的。 在这两种转换中，必须使用深复制的原因是字节切片中的字节元素是可修改的，但是字符串中的字节是不可修改的，所以一个字节切片和一个字符串是不能共享底层字节序列的。 请注意，在字符串和字节切片之间的转换中， 非法的 UTF-8 编码字节序列将被保持原样不变。 标准编译器做了一些优化，从而使得这些转换在某些情形下将不用深复制。 这样的情形将在下一节中介绍。 Go 并不支持字节切片和码点切片之间的直接转换。我们可以用下面列出的方法来实现这样的转换： 利用字符串做为中间过渡。这种方法相对方便但效率较低，因为需要做两次深复制。 使用 unicode/utf8 标准库包中的函数来实现这些转换。 这种方法效率较高，但使用起来不太方便。 使用 bytes 标准库包中的 Runes 函数来将一个字节切片转换为码点切片。 但此包中没有将码点切片转换为字节切片的函数。 一个展示了上述各种转换的例子： package main import ( \"bytes\" \"unicode/utf8\" ) func Runes2Bytes(rs []rune) []byte { n := 0 for _, r := range rs { n += utf8.RuneLen(r) } n, bs := 0, make([]byte, n) for _, r := range rs { n += utf8.EncodeRune(bs[n:], r) } return bs } func main() { s := \"颜色感染是一个有趣的游戏。\" bs := []byte(s) // string -\u003e []byte s = string(bs) // []byte -\u003e string rs := []rune(s) // string -\u003e []rune s = string(rs) // []rune -\u003e string rs = bytes.Runes(bs) // []byte -\u003e []rune bs = Runes2Bytes(rs) // []rune -\u003e []byte } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:4","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"字符串和字节切片之间的转换的编译器优化 上面已经提到了字符串和字节切片之间的转换将深复制它们的底层字节序列。 标准编译器做了一些优化，从而在某些情形下避免了深复制。 至少这些优化在当前（Go 官方工具链 1.17）是存在的。 这样的情形包括： 一个 for-range 循环中跟随 range 关键字的从字符串到字节切片的转换； 一个在映射元素读取索引语法中被用做键值的从字节切片到字符串的转换（注意：对修改写入索引语法无效）； 一个字符串比较表达式中被用做比较值的从字节切片到字符串的转换； 一个（至少有一个被衔接的字符串值为非空字符串常量的）字符串衔接表达式中的从字节切片到字符串的转换。 一个例子： package main import \"fmt\" func main() { var str = \"world\" // 这里，转换[]byte(str)将不需要一个深复制。 for i, b := range []byte(str) { fmt.Println(i, \":\", b) } key := []byte{'k', 'e', 'y'} m := map[string]string{} // 这个string(key)转换仍然需要深复制。 m[string(key)] = \"value\" // 这里的转换string(key)将不需要一个深复制。 // 即使key是一个包级变量，此优化仍然有效。 fmt.Println(m[string(key)]) // value } 注意：在最后一行中，如果在估值 string(key) 的时候有数据竞争的情况，则这行的输出有可能并不是 value。 但是，无论如何，此行都不会造成恐慌（即使有数据竞争的情况发生）。 另一个例子： package main import \"fmt\" import \"testing\" var s string var x = []byte{1023: 'x'} var y = []byte{1023: 'y'} func fc() { // 下面的四个转换都不需要深复制。 if string(x) != string(y) { s = (\" \" + string(x) + string(y))[1:] } } func fd() { // 两个在比较表达式中的转换不需要深复制， // 但两个字符串衔接中的转换仍需要深复制。 // 请注意此字符串衔接和fc中的衔接的差别。 if string(x) != string(y) { s = string(x) + string(y) } } func main() { fmt.Println(testing.AllocsPerRun(1, fc)) // 1 fmt.Println(testing.AllocsPerRun(1, fd)) // 3 } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:5","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"使用 for-range 循环遍历字符串中的码点 for-range 循环控制中的 range 关键字后可以跟随一个字符串，用来遍历此字符串中的码点（而非字节元素）。 字符串中非法的 UTF-8 编码字节序列将被解读为 Unicode 替换码点值0xFFFD。 一个例子： package main import \"fmt\" func main() { s := \"éक्षिaπ囧\" for i, rn := range s { fmt.Printf(\"%2v: 0x%x %v \\n\", i, rn, string(rn)) } fmt.Println(len(s)) } 此程序的输出如下： 0: 0x65 e 1: 0x301 ́ 3: 0x915 क 6: 0x94d ् 9: 0x937 ष 12: 0x93f ि 15: 0x61 a 16: 0x3c0 π 18: 0x56e7 囧 21 从此输出结果可以看出： 下标循环变量的值并非连续。原因是下标循环变量为字符串中字节的下标，而一个码点可能需要多个字节进行 UTF-8 编码。 第一个字符 é 由两个码点（共三字节）组成，其中一个码点需要两个字节进行 UTF-8 编码。 第二个字符 क्षि 由四个码点（共 12 字节）组成，每个码点需要三个字节进行UTF-8编码。 英语字符 a 由一个码点组成，此码点只需一个字节进行 UTF-8 编码。 字符 π 由一个码点组成，此码点只需两个字节进行 UTF-8 编码。 汉字 囧 由一个码点组成，此码点只需三个字节进行 UTF-8 编码。 那么如何遍历一个字符串中的字节呢？使用传统 for 循环： package main import \"fmt\" func main() { s := \"éक्षिaπ囧\" for i := 0; i \u003c len(s); i++ { fmt.Printf(\"第%v个字节为0x%x\\n\", i, s[i]) } } 当然，我们也可以利用前面介绍的编译器优化来使用 for-range 循环遍历一个字符串中的字节元素。 对于官方标准编译器来说，此方法比刚展示的方法效率更高。 package main import \"fmt\" func main() { s := \"éक्षिaπ囧\" // 这里，[]byte(s)不需要深复制底层字节。 for i, b := range []byte(s) { fmt.Printf(\"The byte at index %v: 0x%x \\n\", i, b) } } 从上面几个例子可以看出，len(s) 将返回字符串 s 中的字节数。 如何得到一个字符串中的码点数呢？ 使用刚介绍的 for-range 循环来统计一个字符串中的码点数 使用 unicode/utf8 标准库包中的 RuneCountInString，与上一种方法效率一致 使用 len([]rune(s)) 来获取字符串 s 中码点数。标准编译器从 1.11 版本开始，对此表达式做了优化以避免一个不必要的深复制，从而使得它的效率和前两种方法一致。 注意，这三种方法的时间复杂度均为 O(n)。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:6","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"更多字符串衔接方法 除了使用 + 运算符来衔接字符串，我们也可以用下面的方法来衔接字符串： fmt 标准库包中的 Sprintf / Sprint/Sprintln 函数可以用来衔接各种类型的值的字符串表示，当然也包括字符串类型的值。 使用 strings 标准库包中的 Join 函数。 bytes 标准库包提供的 Buffer 类型可以用来构建一个字节切片，然后我们可以将此字节切片转换为一个字符串。 从 Go 1.10 开始，strings 标准库包中的 Builder 类型可以用来拼接字符串。 和 bytes.Buffer 类型类似，此类型内部也维护着一个字节切片，但是它在将此字节切片转换为字符串时避免了底层字节的深复制。 标准编译器对使用 + 运算符的字符串衔接做了特别的优化。 所以，一般说来，在被衔接的字符串的数量是已知的情况下，使用 + 运算符进行字符串衔接是比较高效的。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:7","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"语法糖：将字符串当作字节切片使用 我们了解到内置函数 copy 和 append 可以用来复制和添加切片元素。 事实上，做为一个特例，如果这两个函数的调用中的第一个实参为一个字节切片的话，那么第二个实参可以是一个字符串。 （对于 append 函数调用，字符串实参后必须跟随三个点 ...） 换句话说，在此特例中，字符串可以当作字节切片来使用。 一个例子： package main import \"fmt\" func main() { hello := []byte(\"Hello \") world := \"world!\" // helloWorld := append(hello, []byte(world)...) // 正常的语法 helloWorld := append(hello, world...) // 语法糖 fmt.Println(string(helloWorld)) helloWorld2 := make([]byte, len(hello) + len(world)) copy(helloWorld2, hello) // copy(helloWorld2[len(hello):], []byte(world)) // 正常的语法 copy(helloWorld2[len(hello):], world) // 语法糖 fmt.Println(string(helloWorld2)) } ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:8","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"更多关于字符串的比较 上面已经提到了比较两个字符串事实上逐个比较这两个字符串中的字节。 Go 编译器一般会做出如下的优化： 对于 == 和 != 比较，如果这两个字符串的长度不相等，则这两个字符串肯定不相等（无需进行字节比较）。 如果这两个字符串底层引用着字符串切片的指针相等，则比较结果等同于比较这两个字符串的长度。 所以两个相等的字符串的比较的时间复杂度取决于它们底层引用着字符串切片的指针是否相等。 如果相等，则对它们的比较的时间复杂度为 O(1)，否则时间复杂度为 O(n)。 上面已经提到了，对于标准编译器，一个字符串赋值完成之后，目标字符串和源字符串将共享同一个底层字节序列。 所以比较这两个字符串的代价很小。 一个例子： package main import ( \"fmt\" \"time\" ) func main() { bs := make([]byte, 1\u003c\u003c26) s0 := string(bs) s1 := string(bs) s2 := s1 // s0、s1和s2是三个相等的字符串。 // s0的底层字节序列是bs的一个深复制。 // s1的底层字节序列也是bs的一个深复制。 // s0和s1底层字节序列为两个不同的字节序列。 // s2和s1共享同一个底层字节序列。 startTime := time.Now() _ = s0 == s1 duration := time.Now().Sub(startTime) fmt.Println(\"duration for (s0 == s1):\", duration) startTime = time.Now() _ = s1 == s2 duration = time.Now().Sub(startTime) fmt.Println(\"duration for (s1 == s2):\", duration) } 输出如下： duration for (s0 == s1): 10.462075ms duration for (s1 == s2): 136ns 1ms 等于 1000000ns！所以请尽量避免比较两个很长的不共享底层字节序列的相等的（或者几乎相等的）字符串。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:3:9","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"值部 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:4:0","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"Go 类型分为两大类别（category） Go 可以被看作是一门 C 语言血统的语言，Go 中的指针和结构体类型的内存结构和 C 语言很类似。 另一方面，Go 也可以被看作是 C 语言的一个扩展框架。 在 C 中，值的内存结构都是很透明的；但在 Go 中，对于某些类型的值，其内存结构却不是很透明。 在 C 中，每个值在内存中只占据一个内存块（一段连续内存）；但是，一些 Go 类型的值可能占据多个内存块。 以后，我们称一个 Go 值分布在不同内存块上的部分为此值的各个值部（value part）。 一个分布在多个内存块上的值含有一个直接值部和若干被此直接值部引用着的间接值部。 上面的段落描述了两个类别的 Go 类型。下表将列出这两个类别（category）中的类型（type）种类（kind）： 每个值在内存中只分布在一个内存块上的类型 每个值在内存中会分布在多个内存块上的类型 单直接值部 直接值部 -\u003e 底层间接值部 布尔类型、各种数值类型、指针类型、非类型安全指针类型、结构体类型、数组类型 切片类型、映射类型、通道类型、函数类型、接口类型、字符串类型 接口类型和字符串类型值是否包含间接部分取决于具体编译器实现。 如果不使用今后将介绍的非类型安全途径，我们无法从这两类类型的值的外在表现来判定它们的值是否含有间接部分。 同样地，函数类型的值是否包含间接部分几乎也是不可能验证的。 通过封装了很多具体的实现细节，第二个类别中的类型给 Go 编程带来了很大的便利。 本文余下的内容将对第二类类型的内在实现做一个简单介绍。 这些实现的细节将不会在本文中谈及。本文的介绍主要基于官方标准编译器的实现。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:4:1","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"Go 中的两种指针类型 在继续下面的内容之前，我们先了解一下 Go 中的两种指针类型并明确一下“引用”这个词的含义。 除了普通的类型安全的指针，Go 还支持另一种称为非类型安全的指针类型。 非类型安全的指针类型提供在 unsafe 标准库包中。 非类型安全指针类型通常使用 unsafe.Pointer 来表示。 unsafe.Pointer 类似于 C 语言中的 void*。 在本文的余下内容中，当一个指针被谈及，它可能表示一个类型安全指针，也可能表示一个非类型安全指针。 一个指针值存储着另一个值的地址，除非此指针值是一个 nil 空指针。 我们可以说此指针引用着另外一个值，或者说另外一个值正被此指针所引用。 一个值可能被间接引用，比如 如果一个结构体值 a 含有一个指针字段 b 并且这个指针字段 b 引用着另外一个值 c，那么我们可以说结构体值 a 也引用着值 c。 如果一个值 x（直接或者间接地）引用着另一个值 y，并且值 y（直接或者间接地）引用着第三个值 z，则我们可以说值 x 间接地引用着值 z。 以后，我们将一个含有（直接或者间接）指针字段的结构体类型称为一个指针包裹类型，将一个含有（直接或者间接）指针的类型称为指针持有者类型。 指针类型和指针包裹类型都属于指针持有者类型。 元素类型为指针持有者类型的数组类型也是指针持有者类型。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:4:2","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"第二个分类中的类型的（可能的）内部实现结构定义 为了更好地理解第二个分类中的类型的值的运行时刻行为，我们可以认为这些类型在内部是使用第一个分类中的类型来定义的（如下所示）。 如果你以前并没有很多使用过 Go 中各种类型的经验，目前你不必深刻地理解这些定义。 对这些定义拥有一个粗糙的印象足够对理解后续文章中将要讲解的类型有所帮助。 你可以在今后有了更多的 Go 编程经验之后再重读一下本文。 映射、通道和函数类型的内部定义 映射、通道和函数类型的内部定义很相似： // 映射类型 type _map *hashtableImpl // 目前，官方标准编译器是使用 // 哈希表来实现映射的。 // 通道类型 type _channel *channelImpl // 函数类型 type _function *functionImpl 从这些定义，我们可以看出来，这三个种类的类型的内部结构其实是一个指针类型。 或者说，这些类型的值的直接部分在内部是一个指针。 这些类型的每个值的直接部分引用着它的具体实现的底层间接部分。 切片类型的内部定义 切片类型的内部定义： type _slice struct { elements unsafe.Pointer // 引用着底层的元素 len int // 当前的元素个数 cap int // 切片的容量 } 从这个定义可以看出来，一个切片类型在内部可以看作是一个指针包裹类型。 每个非零切片值包含着一个底层间接部分用来存储此切片的元素。 一个切片值的底层元素序列（间接部分）被此切片值的 elements 字段所引用。 字符串类型的内部结构 type _string struct { elements *byte // 引用着底层的byte元素 len int // 字符串的长度 } 从此定义可以看出，每个字符串类型在内部也可以看作是一个指针包裹类型。 每个非零字符串值含有一个指针字段 elements。 这个指针字段引用着此字符串值的底层字节元素序列。 接口类型的内部定义 我们可以认为接口类型在内部是如下定义的： type _interface struct { dynamicType *_type // 引用着接口值的动态类型 dynamicValue unsafe.Pointer // 引用着接口值的动态值 } 从这个定义来看，接口类型也可以看作是一个指针包裹类型。一个接口类型含有两个指针字段。 每个非零接口值的（两个）间接部分分别存储着此接口值的动态类型和动态值。 这两个间接部分被此接口值的直接字段dynamicType 和 dynamicValue所引用。 事实上，上面这个内部定义只用于表示空接口类型的值。空接口类型没有指定任何方法。 非空接口类型的内部定义如下： type _interface struct { dynamicTypeInfo *struct { dynamicType *_type // 引用着接口值的动态类型 methods []*_function // 引用着动态类型的对应方法列表 } dynamicValue unsafe.Pointer // 引用着动态值 } 一个非空接口类型的值的 dynamicTypeInfo 字段的 methods 字段引用着一个方法列表。 此列表中的每一项为此接口值的动态类型上定义的一个方法，此方法对应着此接口类型所指定的一个的同原型的方法。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:4:3","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"在赋值中，底层间接值部将不会被复制 现在我们了解了第二个分类中的类型的内部结构是一个指针持有（指针或者指针包裹）类型。 这对于我们理解 Go 中的值复制行为有很大帮助。 在 Go 中，每个赋值操作（包括函数调用传参等）都是一个值的浅复制过程（假设源值和目标值的类型相同）。 换句话说，在一个赋值操作中，只有源值的直接部分被复制给了目标值。 如果源值含有间接部分，则在此赋值操作完成之后，目标值和源值的直接部分将引用着相同的间接部分。 换句话说，两个值将共享底层的间接值部，如下图所示： 事实上，对于字符串值和接口值的赋值，上述描述在理论上并非百分百正确。 官方 FAQ 明确说明了在一个接口值的赋值中，接口的底层动态值将被复制到目标值。 但是，因为一个接口值的动态值是只读的，所以在接口值的赋值中，官方标准编译器并没有复制底层的动态值。这可以被视为是一个编译器优化。 对于字符串值的赋值，道理是一样的。所以对于官方标准编译器来说，上一段的描述是 100% 正确的。 因为一个间接值部可能并不专属于任何一个值，所以在使用 unsafe.Sizeof 函数计算一个值的尺寸的时候，此值的间接部分所占内存空间未被计算在内。 ","date":"2022-03-07","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/:4:4","tags":[],"title":"Go 类型系统","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AF%A6%E8%A7%A3/"},{"categories":["Golang"],"content":"channel 用例大全 本文摘自 https://gfw.go101.org/article/channel-use-cases.html 本文将展示很多通道用例。 希望这篇文章能够说服你接收下面的观点： 使用通道进行异步和并发编程是简单和惬意的； 通道同步技术比被很多其它语言采用的其它同步方案（比如角色模型和async/await模式）有着更多的应用场景和更多的使用变种。 请注意，本文的目的是展示尽量多的通道用例。但是，我们应该知道通道并不是 Go 支持的唯一同步技术，并且通道并不是在任何情况下都是最佳的同步技术。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:0:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"将通道用做 future/promise 很多其它流行语言支持 future/promise 来实现异步（并发）编程。 Future/promise 常常用在请求/回应场合。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:1:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"返回单向接收通道做为函数返回结果 在下面这个例子中，sumSquares 函数调用的两个实参请求并发进行。 每个通道读取操作将阻塞到请求返回结果为止。 两个实参总共需要大约 3 秒钟（而不是 6 秒钟）准备完毕（以较慢的一个为准）。 package main import ( \"time\" \"math/rand\" \"fmt\" ) func longTimeRequest() \u003c-chan int32 { r := make(chan int32) go func() { time.Sleep(time.Second * 3) // 模拟一个工作负载 r \u003c- rand.Int31n(100) }() return r } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) a, b := longTimeRequest(), longTimeRequest() fmt.Println(sumSquares(\u003c-a, \u003c-b)) } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:1:1","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"将单向发送通道类型用做函数实参 和上例一样，在下面这个例子中，sumSquares 函数调用的两个实参的请求也是并发进行的。 和上例不同的是longTimeRequest 函数接收一个单向发送通道类型参数而不是返回一个单向接收通道结果。 package main import ( \"time\" \"math/rand\" \"fmt\" ) func longTimeRequest(r chan\u003c- int32) { time.Sleep(time.Second * 3) // 模拟一个工作负载 r \u003c- rand.Int31n(100) } func sumSquares(a, b int32) int32 { return a*a + b*b } func main() { rand.Seed(time.Now().UnixNano()) ra, rb := make(chan int32), make(chan int32) go longTimeRequest(ra) go longTimeRequest(rb) fmt.Println(sumSquares(\u003c-ra, \u003c-rb)) } 对于上面这个特定的例子，我们可以只使用一个通道来接收回应结果，因为两个参数的作用是对等的。 ... results := make(chan int32, 2) // 缓冲与否不重要 go longTimeRequest(results) go longTimeRequest(results) fmt.Println(sumSquares(\u003c-results, \u003c-results)) } 这可以看作是后面将要提到的数据聚合的一个应用。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:1:2","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"采用最快回应 本用例可以看作是上例中只使用一个通道变种的增强。 有时候，一份数据可能同时从多个数据源获取。这些数据源将返回相同的数据。 因为各种因素，这些数据源的回应速度参差不一，甚至某个特定数据源的多次回应速度之间也可能相差很大。 同时从多个数据源获取一份相同的数据可以有效保障低延迟。我们只需采用最快的回应并舍弃其它较慢回应。 注意：如果有 N 个数据源，为了防止被舍弃的回应对应的协程永久阻塞，则传输数据用的通道必须为一个容量至少为 N-1 的缓冲通道。 package main import ( \"fmt\" \"time\" \"math/rand\" ) func source(c chan\u003c- int32) { ra, rb := rand.Int31(), rand.Intn(3) + 1 // 睡眠1秒/2秒/3秒 time.Sleep(time.Duration(rb) * time.Second) c \u003c- ra } func main() { rand.Seed(time.Now().UnixNano()) startTime := time.Now() c := make(chan int32, 5) // 必须用一个缓冲通道 for i := 0; i \u003c cap(c); i++ { go source(c) } rnd := \u003c- c // 只有第一个回应被使用了 fmt.Println(time.Since(startTime)) fmt.Println(rnd) } “采用最快回应”用例还有一些其它实现方式，本文后面将会谈及。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:1:3","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"更多“请求/回应”用例变种 做为函数参数和返回结果使用的通道可以是缓冲的，从而使得请求协程不需阻塞到它所发送的数据被接收为止。 有时，一个请求可能并不保证返回一份有效的数据。对于这种情形，我们可以使用一个形如struct{v T; err error}的结构体类型或者一个空接口类型做为通道的元素类型以用来区分回应的值是否有效。 有时，一个请求可能需要比预期更长的用时才能回应，甚至永远都得不到回应。 我们可以使用本文后面将要介绍的超时机制来应对这样的情况。 有时，回应方可能会不断地返回一系列值，这也同时属于后面将要介绍的数据流的一个用例。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:1:4","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"使用通道实现通知 通知可以被看作是特殊的请求/回应用例。在一个通知用例中，我们并不关心回应的值，我们只关心回应是否已发生。 所以我们常常使用空结构体类型 struct{} 来做为通道的元素类型，因为空结构体类型的尺寸为零，能够节省一些内存（虽然常常很少量）。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:2:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"⭐ 向一个通道发送一个值来实现单对单通知 我们已知道，如果一个通道中无值可被接收，则此通道上的下一个接收操作将阻塞到另一个协程发送一个值到此通道为止。 所以一个协程可以向此通道发送一个值来通知另一个等待着从此通道接收数据的协程。 在下面这个例子中，通道 done 被用来做为一个信号通道来实现单对单通知。 package main import ( \"crypto/rand\" \"fmt\" \"os\" \"sort\" ) func main() { values := make([]byte, 32 * 1024 * 1024) if _, err := rand.Read(values); err != nil { fmt.Println(err) os.Exit(1) } done := make(chan struct{}) // 也可以是缓冲的 // 排序协程 go func() { sort.Slice(values, func(i, j int) bool { return values[i] \u003c values[j] }) done \u003c- struct{}{} // 通知排序已完成 }() // 并发地做一些其它事情... \u003c- done // 等待通知 fmt.Println(values[0], values[len(values)-1]) } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:2:1","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"从一个通道接收一个值来实现单对单通知 如果一个通道的数据缓冲队列已满（非缓冲的通道的数据缓冲队列总是满的）但它的发送协程队列为空，则向此通道发送一个值将阻塞，直到另外一个协程从此通道接收一个值为止。 所以我们可以通过从一个通道接收数据来实现单对单通知。一般我们使用非缓冲通道来实现这样的通知。 这种通知方式不如上例中介绍的方式使用得广泛。 package main import ( \"fmt\" \"time\" ) func main() { done := make(chan struct{}) // 此信号通道也可以缓冲为1。如果这样，则在下面 // 这个协程创建之前，我们必须向其中写入一个值。 go func() { fmt.Print(\"Hello\") // 模拟一个工作负载。 time.Sleep(time.Second * 2) // 使用一个接收操作来通知主协程。 \u003c- done }() done \u003c- struct{}{} // 阻塞在此，等待通知 fmt.Println(\" world!\") } 另一个事实是，上面的两种单对单通知方式其实并没有本质的区别。 它们都可以被概括为较快者等待较慢者发出通知。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:2:2","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"多对单和单对多通知 略微扩展一下上面两个用例，我们可以很轻松地实现多对单和单对多通知。 package main import \"log\" import \"time\" type T = struct{} func worker(id int, ready \u003c-chan T, done chan\u003c- T) { \u003c-ready // 阻塞在此，等待通知 log.Print(\"Worker#\", id, \"开始工作\") // 模拟一个工作负载。 time.Sleep(time.Second * time.Duration(id+1)) log.Print(\"Worker#\", id, \"工作完成\") done \u003c- T{} // 通知主协程（N-to-1） } func main() { log.SetFlags(0) ready, done := make(chan T), make(chan T) go worker(0, ready, done) go worker(1, ready, done) go worker(2, ready, done) // 模拟一个初始化过程 time.Sleep(time.Second * 3 / 2) // 单对多通知 ready \u003c- T{}; ready \u003c- T{}; ready \u003c- T{} // 等待被多对单通知 \u003c-done; \u003c-done; \u003c-done } 事实上，上例中展示的多对单和单对多通知实现方式在实践中用的并不多。 在实践中，我们多使用 sync.WaitGroup 来实现多对单通知，使用关闭一个通道的方式来实现单对多通知（详见下一个用例）。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:2:3","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"✔️ 通过关闭一个通道来实现群发通知 上一个用例中的单对多通知实现在实践中很少用，因为通过关闭一个通道的方式在来实现单对多通知的方式更简单。 我们已经知道，从一个已关闭的通道可以接收到无穷个值，我们可以利用这一特性来实现群发通知。 我们可以把上一个例子中的三个数据发送操作ready \u003c- struct{}{}替换为一个通道关闭操作close(ready)来达到同样的单对多通知效果。 ... close(ready) // 群发通知 ... 当然，我们也可以通过关闭一个通道来实现单对单通知。事实上，关闭通道来是实践中用得最多通知实现方式。 从一个已关闭的通道可以接收到无穷个值这一特性也将被用在很多其它在后面将要介绍的用例中。 实际上，这一特性被广泛地使用于标准库包中。比如，context 标准库包使用了此特性来传达操作取消消息。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:2:4","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"定时通知（timer） 用通道实现一个一次性的定时通知器是很简单的。 下面是一个自定义实现： package main import ( \"fmt\" \"time\" ) func AfterDuration(d time.Duration) \u003c- chan struct{} { c := make(chan struct{}, 1) go func() { time.Sleep(d) c \u003c- struct{}{} }() return c } func main() { fmt.Println(\"Hi!\") \u003c- AfterDuration(time.Second) fmt.Println(\"Hello!\") \u003c- AfterDuration(time.Second) fmt.Println(\"Bye!\") } 事实上，time 标准库包中的 After 函数提供了和上例中 AfterDuration 同样的功能。 在实践中，我们应该尽量使用 time.After 函数以使代码看上去更干净。 注意，操作 \u003c-time.After(aDuration) 将使当前协程进入阻塞状态，而一个 time.Sleep(aDuration) 函数调用不会如此。 \u003c-time.After(aDuration) 经常被使用在后面将要介绍的超时机制实现中。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:2:5","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"将通道用做互斥锁（mutex） 上面的某个例子提到了容量为 1 的缓冲通道可以用做一次性二元信号量。 事实上，容量为 1 的缓冲通道也可以用做多次性二元信号量（即互斥锁）尽管这样的互斥锁效率不如 sync 标准库包中提供的互斥锁高效。 有两种方式将一个容量为 1 的缓冲通道用做互斥锁： 通过发送操作来加锁，通过接收操作来解锁； 通过接收操作来加锁，通过发送操作来解锁。 下面是一个通过发送操作来加锁的例子。 package main import \"fmt\" func main() { mutex := make(chan struct{}, 1) // 容量必须为1 counter := 0 increase := func() { mutex \u003c- struct{}{} // 加锁 counter++ \u003c-mutex // 解锁 } increase1000 := func(done chan\u003c- struct{}) { for i := 0; i \u003c 1000; i++ { increase() } done \u003c- struct{}{} } done := make(chan struct{}) go increase1000(done) go increase1000(done) \u003c-done; \u003c-done fmt.Println(counter) // 2000 } 下面是一个通过接收操作来加锁的例子，其中只显示了相对于上例而修改了的部分。 ... func main() { mutex := make(chan struct{}, 1) mutex \u003c- struct{}{} // 此行是必需的 counter := 0 increase := func() { \u003c-mutex // 加锁 counter++ mutex \u003c- struct{}{} // 解锁 } ... ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:3:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"将通道用做计数信号量（counting semaphore） 缓冲通道可以被用做计数信号量。 计数信号量可以被视为多主锁。如果一个缓冲通道的容量为 N，那么它可以被看作是一个在任何时刻最多可有 N 个主人的锁。 上面提到的二元信号量是特殊的计数信号量，每个二元信号量在任一时刻最多只能有一个主人。 计数信号量经常被使用于限制最大并发数。 和将通道用做互斥锁一样，也有两种方式用来获取一个用做计数信号量的通道的一份所有权。 通过发送操作来获取所有权，通过接收操作来释放所有权； 通过接收操作来获取所有权，通过发送操作来释放所有权。 下面是一个通过接收操作来获取所有权的例子： package main import ( \"log\" \"time\" \"math/rand\" ) type Seat int type Bar chan Seat func (bar Bar) ServeCustomer(c int) { log.Print(\"顾客#\", c, \"进入酒吧\") seat := \u003c- bar // 需要一个位子来喝酒 log.Print(\"++ customer#\", c, \" drinks at seat#\", seat) log.Print(\"++ 顾客#\", c, \"在第\", seat, \"个座位开始饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了第\", seat, \"个座位\") bar \u003c- seat // 释放座位，离开酒吧 } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) // 此酒吧有10个座位 // 摆放10个座位。 for seatId := 0; seatId \u003c cap(bar24x7); seatId++ { bar24x7 \u003c- Seat(seatId) // 均不会阻塞 } for customerId := 0; ; customerId++ { time.Sleep(time.Second) go bar24x7.ServeCustomer(customerId) } for {time.Sleep(time.Second)} // 睡眠不属于阻塞状态 } 在上例中，只有获得一个座位的顾客才能开始饮酒。 所以在任一时刻同时在喝酒的顾客数不会超过座位数 10。 上例 main 函数中的最后一行 for 循环是为了防止程序退出。 后面将介绍一种更好的实现此目的的方法。 在上例中，尽管在任一时刻同时在喝酒的顾客数不会超过座位数 10，但是在某一时刻可能有多于 10 个顾客进入了酒吧，因为某些顾客在排队等位子。 在上例中，每个顾客对应着一个协程。虽然协程的开销比系统线程小得多，但是如果协程的数量很多，则它们的总体开销还是不能忽略不计的。 所以，最好当有空位的时候才创建顾客协程。 ... // 省略了和上例相同的代码 func (bar Bar) ServeCustomerAtSeat(c int, seat Seat) { log.Print(\"++ 顾客#\", c, \"在第\", seat, \"个座位开始饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了第\", seat, \"个座位\") bar \u003c- seat // 释放座位，离开酒吧 } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) for seatId := 0; seatId \u003c cap(bar24x7); seatId++ { bar24x7 \u003c- Seat(seatId) } // 这个for循环和上例不一样。 for customerId := 0; ; customerId++ { time.Sleep(time.Second) seat := \u003c- bar24x7 // 需要一个空位招待顾客 go bar24x7.ServeCustomerAtSeat(customerId, seat) } for {time.Sleep(time.Second)} } 在上面这个修改后的例子中，在任一时刻最多只有 10 个顾客协程在运行（但是在程序的生命期内，仍旧会有大量的顾客协程不断被创建和销毁）。 ✔️ 在下面这个更加高效的实现中，在程序的生命期内最多只会有 10 个顾客协程被创建出来。 ... // 省略了和上例相同的代码 func (bar Bar) ServeCustomerAtSeat(consumers chan int) { for c := range consumers { seatId := \u003c- bar log.Print(\"++ 顾客#\", c, \"在第\", seatId, \"个座位开始饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了第\", seatId, \"个座位\") bar \u003c- seatId // 释放座位，离开酒吧 } } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) for seatId := 0; seatId \u003c cap(bar24x7); seatId++ { bar24x7 \u003c- Seat(seatId) } consumers := make(chan int) for i := 0; i \u003c cap(bar24x7); i++ { go bar24x7.ServeCustomerAtSeat(consumers) } for customerId := 0; ; customerId++ { time.Sleep(time.Second) consumers \u003c- customerId } } 题外话：当然，如果我们并不关心座位号（这种情况在编程实践中很常见），则实际上 bar24x7 计数信号量是完全不需要的： ... // 省略了和上例相同的代码 func ServeCustomer(consumers chan int) { for c := range consumers { log.Print(\"++ 顾客#\", c, \"开始在酒吧饮酒\") time.Sleep(time.Second * time.Duration(2 + rand.Intn(6))) log.Print(\"-- 顾客#\", c, \"离开了酒吧\") } } func main() { rand.Seed(time.Now().UnixNano()) const BarSeatCount = 10 consumers := make(chan int) for i := 0; i \u003c BarSeatCount; i++ { go ServeCustomer(consumers) } for customerId := 0; ; customerId++ { time.Sleep(time.Second) consumers \u003c- customerId } } 通过发送操作来获取所有权的实现相对简单一些，省去了摆放座位的步骤。 package main import ( \"log\" \"time\" \"math/rand\" ) type Customer struct{id int} type Bar chan Customer func (bar Bar) ServeCustomer(c Customer) { log.Print(\"++ 顾客#\", c.id, \"开始饮酒\") time.Sleep(time.Second * time.Duration(3 + rand.Intn(16))) log.Print(\"-- 顾客#\", c.id, \"离开酒吧\") \u003c- bar // 离开酒吧，腾出位子 } func main() { rand.Seed(time.Now().UnixNano()) bar24x7 := make(Bar, 10) // 最对同时服务10位顾客 for customerId := 0; ; customerId++ { time.Sleep(time.Second * 2) customer := Customer{customerId} bar24x7 \u003c- customer // 等待进入酒吧 go bar24x7.ServeCustomer(customer) } for {time.Sleep(time.Second)} } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:4:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"对话（或称乒乓） 两个协程可以通过一个通道进行对话，整个过程宛如打乒乓球一样。 下面是一个这样的例子，它将打印出一系列斐波那契（Fibonacci）数。 package main import \"fmt\" import \"time\" import \"os\" type Ball uint64 func Play(playerName string, table chan Ball) { var lastValue Ball = 1 for { ball := \u003c- table // 接球 fmt.Println(playerName, ball) ball += lastValue if ball \u003c lastValue { // 溢出结束 os.Exit(0) } lastValue = ball table \u003c- ball // 回球 time.Sleep(time.Second) } } func main() { table := make(chan Ball) go func() { table \u003c- 1 // （裁判）发球 }() go Play(\"A:\", table) Play(\"B:\", table) } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:5:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"使用通道传送传输通道 这个看得有点懵。。 一个通道类型的元素类型可以是另一个通道类型。 在下面这个例子中， 单向发送通道类型 chan\u003c- int 是另一个通道类型 chan chan\u003c- int 的元素类型。 package main import \"fmt\" var counter = func (n int) chan\u003c- chan\u003c- int { requests := make(chan chan\u003c- int) go func() { for request := range requests { if request == nil { n++ // 递增计数 } else { request \u003c- n // 返回当前计数 } } }() return requests // 隐式转换到类型chan\u003c- (chan\u003c- int) }(0) func main() { increase1000 := func(done chan\u003c- struct{}) { for i := 0; i \u003c 1000; i++ { counter \u003c- nil } done \u003c- struct{}{} } done := make(chan struct{}) go increase1000(done) go increase1000(done) \u003c-done; \u003c-done request := make(chan int, 1) counter \u003c- request fmt.Println(\u003c-request) // 2000 } 尽管对于上面这个用例来说，使用通道传送传输通道这种方式并非是最有效的实现方式，但是这种方式肯定有最适合它的用武之地。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:6:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"检查通道的长度和容量 我们可以使用内置函数 cap 和 len 来查看一个通道的容量和当前长度。 但是在实践中我们很少这样做。 我们很少使用内置函数 cap 的原因是一个通道的容量常常是已知的或者不重要的。 我们很少使用内置函数 len 的原因是一个 len 调用的结果并不能总能准确地反映出的一个通道的当前长度。 但有时确实有一些场景需要调用这两个函数。比如，有时一个协程欲将一个未关闭的并且不会再向其中发送数据的缓冲通道中的所有数据接收出来，在确保只有此一个协程从此通道接收数据的情况下，我们可以用下面的代码来实现之： for len(c) \u003e 0 { value := \u003c-c // 使用value ... } 我们也可以用本文后面将要介绍的尝试接收机制来实现这一需求。两者的运行效率差不多，但尝试接收机制的优点是多个协程可以并发地进行读取操作。 有时一个协程欲将一个缓冲通道写满而又不阻塞，在确保只有此一个协程向此通道发送数据的情况下，我们可以用下面的代码实现这一目的： for len(c) \u003c cap(c) { c \u003c- aValue } 当然，我们也可以使用后面将要介绍的尝试发送机制来实现这一需求。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:7:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"✔️ 使当前协程永久阻塞 Go中的选择机制（select）是一个非常独特的特性。它给并发编程带来了很多新的模式和技巧。 我们可以用一个无分支的 select 流程控制代码块使当前协程永久处于阻塞状态。 这是 select 流程控制的最简单的应用。 事实上，上面很多例子中的 for {time.Sleep(time.Second)} 都可以换为 select{}。 一般，select{} 用在主协程中以防止程序退出。 一个例子： package main import \"runtime\" func DoSomething() { for { // 做点什么... runtime.Gosched() // 防止本协程霸占CPU不放 } } func main() { go DoSomething() go DoSomething() select{} } 另外还有一些使当前协程永久阻塞的方法，但是 select{} 是最简单的方法。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:8:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"⭐ 尝试发送和尝试接收 含有一个 default 分支和一个 case 分支的 select 代码块可以被用做一个尝试发送或者尝试接收操作，取决于 case 关键字后跟随的是一个发送操作还是一个接收操作。 如果 case 关键字后跟随的是一个发送操作，则此 select 代码块为一个尝试发送操作。 如果 case 分支的发送操作是阻塞的，则 default 分支将被执行，发送失败；否则发送成功，case 分支得到执行。 如果 case 关键字后跟随的是一个接收操作，则此 select 代码块为一个尝试接收操作。 如果 case 分支的接收操作是阻塞的，则 default 分支将被执行，接收失败；否则接收成功，case 分支得到执行。 尝试发送和尝试接收代码块永不阻塞。 标准编译器对尝试发送和尝试接收代码块做了特别的优化，使得它们的执行效率比多 case 分支的普通 select 代码块执行效率高得多。 下例演示了尝试发送和尝试接收代码块的工作原理。 package main import \"fmt\" func main() { type Book struct{id int} bookshelf := make(chan Book, 3) for i := 0; i \u003c cap(bookshelf) * 2; i++ { select { case bookshelf \u003c- Book{id: i}: fmt.Println(\"成功将书放在书架上\", i) default: fmt.Println(\"书架已经被占满了\") } } for i := 0; i \u003c cap(bookshelf) * 2; i++ { select { case book := \u003c-bookshelf: fmt.Println(\"成功从书架上取下一本书\", book.id) default: fmt.Println(\"书架上已经没有书了\") } } } 输出结果： 成功将书放在书架上 0 成功将书放在书架上 1 成功将书放在书架上 2 书架已经被占满了 书架已经被占满了 书架已经被占满了 成功从书架上取下一本书 0 成功从书架上取下一本书 1 成功从书架上取下一本书 2 书架上已经没有书了 书架上已经没有书了 书架上已经没有书了 后面的很多用例还要用到尝试发送和尝试接收代码块。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"无阻塞地检查一个通道是否已经关闭 假设我们可以保证没有任何协程会向一个通道发送数据，则我们可以使用下面的代码来（并发安全地）检查此通道是否已经关闭，此检查不会阻塞当前协程。 func IsClosed(c chan T) bool { select { case \u003c-c: return true default: } return false } 此方法常用来查看某个期待中的通知是否已经来临。此通知将由另一个协程通过关闭一个通道来发送。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:1","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"峰值限制（peak/burst limiting） 将 ““通道用做计数信号量” 用例和 “通道尝试（发送或者接收）操作” 结合起来可用实现峰值限制。 峰值限制的目的是防止过大的并发请求数。 下面是对 “将通道用做计数信号量” 一节中的最后一个例子的简单修改，从而使得顾客不再等待而是离去或者寻找其它酒吧。 ... bar24x7 := make(Bar, 10) // 此酒吧只能同时招待10个顾客 for customerId := 0; ; customerId++ { time.Sleep(time.Second) consumer := Consumer{customerId} select { case bar24x7 \u003c- consumer: // 试图进入此酒吧 go bar24x7.ServeConsumer(consumer) default: log.Print(\"顾客#\", customerId, \"不愿等待而离去\") } } ... ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:2","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"另一种“采用最快回应”的实现方式 在上面的 “采用最快回应” 用例一节已经提到，我们也可以使用选择机制来实现 “采用最快回应” 用例。 每个数据源协程只需使用一个缓冲为 1 的通道并向其尝试发送回应数据即可。示例代码如下： package main import ( \"fmt\" \"math/rand\" \"time\" ) func source(c chan\u003c- int32) { ra, rb := rand.Int31(), rand.Intn(3)+1 // 休眠1秒/2秒/3秒 time.Sleep(time.Duration(rb) * time.Second) select { case c \u003c- ra: default: } } func main() { rand.Seed(time.Now().UnixNano()) c := make(chan int32, 1) // 此通道容量必须至少为1 for i := 0; i \u003c 5; i++ { go source(c) } rnd := \u003c-c // 只采用第一个成功发送的回应数据 fmt.Println(rnd) } 注意，使用选择机制来实现“采用最快回应”的代码中使用的通道的容量必须至少为 1，以保证最快回应总能够发送成功。 否则，如果数据请求者因为种种原因未及时准备好接收，则所有回应者的尝试发送都将失败，从而所有回应的数据都将被错过。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:3","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"第三种“采用最快回应”的实现方式 如果一个 “采用最快回应” 用例中的数据源的数量很少，比如两个或三个，我们可以让每个数据源使用一个单独的缓冲通道来回应数据，然后使用一个 select 代码块来同时接收这三个通道。 示例代码如下： package main import ( \"fmt\" \"math/rand\" \"time\" ) func source() \u003c-chan int32 { c := make(chan int32, 1) // 必须为一个缓冲通道 go func() { ra, rb := rand.Int31(), rand.Intn(3)+1 time.Sleep(time.Duration(rb) * time.Second) c \u003c- ra }() return c } func main() { rand.Seed(time.Now().UnixNano()) var rnd int32 // 阻塞在此直到某个数据源率先回应。 select{ case rnd = \u003c-source(): case rnd = \u003c-source(): case rnd = \u003c-source(): } fmt.Println(rnd) } 注意：如果上例中使用的通道是非缓冲的，未被选中的 case 分支对应的两个 source 函数调用中开辟的协程将处于永久阻塞状态，从而造成内存泄露。 本小节和上一小节中展示的两种方法也可以用来实现多对单通知。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:4","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"✔️ 超时机制（timeout） 在一些请求/回应用例中，一个请求可能因为种种原因导致需要超出预期的时长才能得到回应，有时甚至永远得不到回应。 对于这样的情形，我们可以使用一个超时方案给请求者返回一个错误信息。 使用选择机制可以很轻松地实现这样的一个超时方案。 下面这个例子展示了如何实现一个支持超时设置的请求： func requestWithTimeout(timeout time.Duration) (int, error) { c := make(chan int) go doRequest(c) // 可能需要超出预期的时长回应 select { case data := \u003c-c: return data, nil case \u003c-time.After(timeout): return 0, errors.New(\"超时了！\") } } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:5","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"脉搏器（ticker） 我们可以使用尝试发送操作来实现一个每隔一定时间发送一个信号的脉搏器。 package main import \"fmt\" import \"time\" func Tick(d time.Duration) \u003c-chan struct{} { c := make(chan struct{}, 1) // 容量最好为1 go func() { for { time.Sleep(d) select { case c \u003c- struct{}{}: default: } } }() return c } func main() { t := time.Now() for range Tick(time.Second) { fmt.Println(time.Since(t)) } } 事实上，time 标准库包中的 Tick 函数提供了同样的功能，但效率更高。 我们应该尽量使用标准库包中的实现。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:6","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"速率限制（rate limiting） 上面已经展示了如何使用尝试发送实现峰值限制。 同样地，我们也可以使用使用尝试机制来实现速率限制，但需要前面刚提到的定时器实现的配合。 速率限制常用来限制吞吐和确保在一段时间内的资源使用不会超标。 下面的例子借鉴了官方 Go 维基中的例子。 在此例中，任何一分钟时段内处理的请求数不会超过 200。 package main import \"fmt\" import \"time\" type Request interface{} func handle(r Request) {fmt.Println(r.(int))} const RateLimitPeriod = time.Minute const RateLimit = 200 // 任何一分钟内最多处理200个请求 func handleRequests(requests \u003c-chan Request) { quotas := make(chan time.Time, RateLimit) go func() { tick := time.NewTicker(RateLimitPeriod / RateLimit) defer tick.Stop() for t := range tick.C { select { case quotas \u003c- t: default: } } }() for r := range requests { \u003c-quotas go handle(r) } } func main() { requests := make(chan Request) go handleRequests(requests) // time.Sleep(time.Minute) for i := 0; ; i++ {requests \u003c- i} } 上例的代码虽然可以保证任何一分钟时段内处理的请求数不会超过 200，但是如果在开始的一分钟内没有任何请求，则接下来的某个瞬时时间点可能会同时处理最多 200 个请求（试着将 time.Sleep 行的注释去掉看看）。 这可能会造成卡顿情况。我们可以将速率限制和峰值限制一并使用来避免出现这样的情况。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:7","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"开关 向一个 nil 通道发送数据或者从中接收数据都属于阻塞操作。 利用这一事实，我们可以将一个 select 流程控制中的 case 操作中涉及的通道设置为不同的值，以使此 select 流程控制选择执行不同的分支。 下面是另一个乒乓模拟游戏的实现。此实现使用了选择机制。在此例子中，两个 case 操作中的通道有且只有一个为 nil，所以只能是不为 nil 的通道对应的分支被选中。 每个循环步将对调这两个 case 操作中的通道，从而改变两个分支的可被选中状态。 package main import \"fmt\" import \"time\" import \"os\" type Ball uint8 func Play(playerName string, table chan Ball, serve bool) { var receive, send chan Ball if serve { receive, send = nil, table } else { receive, send = table, nil } var lastValue Ball = 1 for { select { case send \u003c- lastValue: case value := \u003c- receive: fmt.Println(playerName, value) value += lastValue if value \u003c lastValue { // 溢出了 os.Exit(0) } lastValue = value } receive, send = send, receive // 开关切换 time.Sleep(time.Second) } } func main() { table := make(chan Ball) go Play(\"A:\", table, false) Play(\"B:\", table, true) } 下面是另一个也展示了开关效果的但简单得多的（非并发的）小例子。 此程序将不断打印出 1212...。 它在实践中没有太多实用价值，这里只是为了学习的目的才展示之。 package main import \"fmt\" import \"time\" func main() { for c := make(chan struct{}, 1); true; { select { case c \u003c- struct{}{}: fmt.Print(\"1\") case \u003c-c: fmt.Print(\"2\") } time.Sleep(time.Second) } } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:8","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"控制代码被执行的几率 我们可以通过在一个 select 流程控制中使用重复的 case 操作来增加对应分支中的代码的执行几率。 一个例子： package main import \"fmt\" func main() { foo, bar := make(chan struct{}), make(chan struct{}) close(foo); close(bar) // 仅为演示目的 x, y := 0.0, 0.0 f := func(){x++} g := func(){y++} for i := 0; i \u003c 100000; i++ { select { case \u003c-foo: f() case \u003c-foo: f() case \u003c-bar: g() } } fmt.Println(x/y) // 大致为2 } 在上面这个例子中，函数f的调用执行几率大致为函数g的两倍。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:9","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"从动态数量的分支中选择 每个 select 控制流程中的分支数量在运行中是固定的，但是我们可以使用 reflect 标准库包中提供的功能在运行时刻来构建动态分支数量的 select 控制流程。 但是请注意：一个 select 控制流程中的分支越多，此 select 控制流程的执行效率就越低（这是我们常常只使用不多于三个分支的 select 控制流程的原因）。 reflect 标准库包中也提供了模拟尝试发送和尝试接收代码块的 TrySend 和 TryRecv 函数。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:9:10","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"⭐ 数据流操纵 本节将介绍一些使用通道进行数据流处理的用例。 一般来说，一个数据流处理程序由多个模块组成。不同的模块执行分配给它们的不同的任务。 每个模块由一个或者数个并行工作的协程组成。实践中常见的工作任务包括： 数据生成/搜集/加载； 数据服务/存盘； 数据计算/处理； 数据验证/过滤； 数据聚合/分流； 数据组合/拆分； 数据复制/增殖； 等等。 一个模块中的工作协程从一些其它模块接收数据做为输入，并向另一些模块发送输出数据。 换句话数，一个模块可能同时兼任数据消费者和数据产生者的角色。 多个模块一起组成了一个数据流处理系统。 下面将展示一些模块工作协程的实现。这些实现仅仅是为了解释目的，所以它们都很简单，并且它们可能并不高效。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:0","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"⭐ 数据生成/搜集/加载 一个数据产生者可能通过以下途径生成数据： 加载一个文件、或者读取一个数据库、或者用爬虫抓取网页数据； 从一个软件或者硬件系统搜集各种数据； 产生一系列随机数； 等等。 这里，我们使用一个随机数产生器做为一个数据产生者的例子。 此数据产生者函数没有输入，只有输出。 import ( \"crypto/rand\" \"encoding/binary\" ) func RandomGenerator() \u003c-chan uint64 { c := make(chan uint64) go func() { rnds := make([]byte, 8) for { _, err := rand.Read(rnds) if err != nil { close(c) break } c \u003c- binary.BigEndian.Uint64(rnds) } }() return c } 事实上，此随机数产生器是一个多返回值的 future/promise。 一个数据产生者可以在任何时刻关闭返回的通道以结束数据生成。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:1","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"✔️ 数据聚合 一个数据聚合模块的工作协程将多个数据流合为一个数据流。 假设数据类型为int64，下面这个函数将任意数量的数据流合为一个。 func Aggregator(inputs ...\u003c-chan uint64) \u003c-chan uint64 { out := make(chan uint64) for _, in := range inputs { go func(in \u003c-chan uint64) { for { out \u003c- \u003c-in // \u003c=\u003e out \u003c- (\u003c-in) } }(in) } return out } 一个更完美的实现需要考虑一个输入数据流是否已经关闭。（下面要介绍的其它工作协程同理。） import \"sync\" func Aggregator(inputs ...\u003c-chan uint64) \u003c-chan uint64 { output := make(chan uint64) var wg sync.WaitGroup for _, in := range inputs { wg.Add(1) go func(int \u003c-chan uint64) { defer wg.Done() // 如果通道in被关闭，此循环将最终结束。 for x := range in { output \u003c- x } }(in) } go func() { wg.Wait() close(output) }() return output } 如果被聚合的数据流的数量很小，我们也可以使用一个 select 控制流程代码块来聚合这些数据流。 // 假设数据流的数量为2。 ... output := make(chan uint64) go func() { inA, inB := inputs[0], inputs[1] for { select { case v := \u003c- inA: output \u003c- v case v := \u003c- inB: output \u003c- v } } } ... ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:2","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据分流 数据分流是数据聚合的逆过程。数据分流的实现很简单，但在实践中用的并不多。 func Divisor(input \u003c-chan uint64, outputs ...chan\u003c- uint64) { for _, out := range outputs { go func(o chan\u003c- uint64) { for { o \u003c- \u003c-input // \u003c=\u003e o \u003c- (\u003c-input) } }(out) } } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:3","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据合成 数据合成将多个数据流中读取的数据合成一个。 下面是一个数据合成工作函数的实现中，从两个不同数据流读取的两个 uint64 值组成了一个新的 uint64 值。 当然，在实践中，数据的组合比这复杂得多。 func Composor(inA, inB \u003c-chan uint64) \u003c-chan uint64 { output := make(chan uint64) go func() { for { a1, b, a2 := \u003c-inA, \u003c-inB, \u003c-inA output \u003c- a1 ^ b \u0026 a2 } }() return output } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:4","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据分解 数据分解是数据合成的逆过程。一个数据分解者从一个通道读取一份数据，并将此数据分解为多份数据。 这里就不举例了 (?) ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:5","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据复制/增殖 数据复制（增殖）可以看作是特殊的数据分解。一份输入数据将被复制多份并输出给多个数据流。 一个例子： func Duplicator(in \u003c-chan uint64) (\u003c-chan uint64, \u003c-chan uint64) { outA, outB := make(chan uint64), make(chan uint64) go func() { for x := range in { outA \u003c- x outB \u003c- x } }() return outA, outB } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:6","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据计算/分析 数据计算和数据分析模块的功能因具体程序不同而有很大的差异。 一般来说，数据分析者接收一份数据并对之加工处理后转换为另一份数据。 下面的简单示例中，每个输入的 uint64 值将被进行位反转后输出。 func Calculator(in \u003c-chan uint64, out chan uint64) (\u003c-chan uint64) { if out == nil { out = make(chan uint64) } go func() { for x := range in { out \u003c- ^x } }() return out } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:7","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据验证/过滤 一个数据验证或过滤者的任务是检查输入数据的合理性并抛弃不合理的数据。 比如，下面的工作者协程将抛弃所有的非素数。 import \"math/big\" func Filter0(input \u003c-chan uint64, output chan uint64) \u003c-chan uint64 { if output == nil { output = make(chan uint64) } go func() { bigInt := big.NewInt(0) for x := range input { bigInt.SetUint64(x) if bigInt.ProbablyPrime(1) { output \u003c- x } } }() return output } func Filter(input \u003c-chan uint64) \u003c-chan uint64 { return Filter0(input, nil) } 请注意这两个函数版本分别被本文下面最后展示的两个例子所使用。 ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:8","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"数据服务/存盘 一般，一个数据服务或者存盘模块为一个数据流系统中的最后一个模块。 这里的实现值是简单地将数据输出到终端。 import \"fmt\" func Printer(input \u003c-chan uint64) { for x := range input { fmt.Println(x) } } ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:9","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["Golang"],"content":"组装数据流系统 现在，让我们使用上面的模块工作者函数实现来组装一些数据流系统。 组装数据流仅仅是创建一些工作者协程函数调用，并为这些调用指定输入数据流和输出数据流。 数据流系统例子1（一个流线型系统）： package main ... // 上面的模块工作者函数实现 func main() { Printer( Filter( Calculator( RandomGenerator(), nil, ), ), ) } 上面这个流线型系统描绘在下图中： 数据流系统例子 2（一个单向无环图系统）： package main ... // 上面的模块工作者函数实现 func main() { filterA := Filter(RandomGenerator()) filterB := Filter(RandomGenerator()) filterC := Filter(RandomGenerator()) filter := Aggregator(filterA, filterB, filterC) calculatorA := Calculator(filter, nil) calculatorB := Calculator(filter, nil) calculator := Aggregator(calculatorA, calculatorB) Printer(calculator) } 上面这个单向无环图系统描绘在下图中： 更复杂的数据流系统可以表示为任何拓扑结构的图。比如一个复杂的数据流系统可能有多个输出模块。 但是有环拓扑结构的数据流系统在实践中很少用。 从上面两个例子可以看出，使用通道来构建数据流系统是很简单和直观的。 从上例可以看出，通过使用数据聚合模块，我们可以很轻松地实现各个模块的工作协程数量的扇入（fan-in）和扇出（fan-out）。 事实上，我们也可以使用一个简单的通道来代替数据聚合模块的角色。比如，下面的代码使用两个通道代替了上例中的两个数据聚合器。 package main ... // 上面的模块工作者函数实现 func main() { c1 := make(chan uint64, 100) Filter0(RandomGenerator(), c1) // filterA Filter0(RandomGenerator(), c1) // filterB Filter0(RandomGenerator(), c1) // filterC c2 := make(chan uint64, 100) Calculator(c1, c2) // calculatorA Calculator(c1, c2) // calculatorB Printer(c2) } 修改后的数据流的拓扑结构如下图所示： ","date":"2022-03-06","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/:10:10","tags":["进阶"],"title":"channel 用例大全","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/"},{"categories":["刷题"],"content":"35. 搜索插入位置 easy 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 请必须使用时间复杂度为 O(log n) 的算法。 示例 1: 输入: nums = [1,3,5,6], target = 5 输出: 2 示例 2: 输入: nums = [1,3,5,6], target = 2 输出: 1 示例 3: 输入: nums = [1,3,5,6], target = 7 输出: 4 nums 为无重复元素的升序排列数组 ","date":"2022-03-05","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/:0:0","tags":["算法","数组","二分"],"title":"35. 搜索插入位置","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"categories":["刷题"],"content":"二分 经典的二分搜索的变种题 // searchInsert 找到第一个比target大的 或者找到最后一个比target小的元素即可 func searchInsert(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := (low + high) \u003e\u003e 1 if target \u003c nums[mid] { if mid == 0 || target \u003e nums[mid-1] { return mid } high = mid - 1 } else if target \u003e nums[mid] { if mid == len(nums)-1 || target \u003c nums[mid+1] { return mid + 1 } low = mid + 1 } else { return mid } } return -1 } ","date":"2022-03-05","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/:1:0","tags":["算法","数组","二分"],"title":"35. 搜索插入位置","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/35.-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"},{"categories":["刷题"],"content":"54. 螺旋矩阵 mid 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,9,8,7,4,5] 示例 2： 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] 输出：[1,2,3,4,8,12,11,10,9,5,6,7] ","date":"2022-03-05","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/:0:0","tags":["算法","数组","模拟"],"title":"54. 螺旋矩阵","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"模拟 就恩写；注意边界条件 func spiralOrder(matrix [][]int) []int { m, n := len(matrix), len(matrix[0]) res := make([]int, m*n) if n == 1 { for i, x := range matrix { res[i] = x[0] } return res } layer := 0 // 当前层 i, j := 0, 0 // 行列指针 state := 'r' count := 0 for count \u003c m*n { if state == 'r' { res[count] = matrix[i][j] j++ if j+1 == n-layer { state = 'd' } if j+1 \u003e n-layer { // 溢出后的处理 j = n - layer - 1 i++ } } else if state == 'd' { res[count] = matrix[i][j] i++ if i+1 == m-layer { state = 'l' } if i+1 \u003e m-layer { i = m - layer - 1 j-- } } else if state == 'l' { res[count] = matrix[i][j] j-- if j == layer { state = 'u' } if j \u003c layer { j = layer i-- } } else if state == 'u' { res[count] = matrix[i][j] i-- if i == layer { state = 'r' layer++ i++ j++ } } count++ fmt.Println(res) } return res } ","date":"2022-03-05","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/:1:0","tags":["算法","数组","模拟"],"title":"54. 螺旋矩阵","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"更好的模拟 func spiralOrder(matrix [][]int) []int { if len(matrix) == 0 { return []int{} } m, n := len(matrix), len(matrix[0]) res := make([]int, m*n) l, r, t, b := 0, n-1, 0, m-1 // 左右上下 count := 0 state := 'r' for count \u003c m*n { if state == 'r' { // l2r for col := l; col \u003c= r; col++ { res[count] = matrix[t][col] count++ } t++ state = 'd' } else if state == 'd' { // u2d for row := t; row \u003c= b; row++ { res[count] = matrix[row][r] count++ } r-- state = 'l' } else if state == 'l' { // r2l for col := r; col \u003e= l; col-- { res[count] = matrix[b][col] count++ } b-- state = 'u' } else if state == 'u' { // d2u for row := b; row \u003e= t; row-- { res[count] = matrix[row][l] count++ } l++ state = 'r' } } return res } ","date":"2022-03-05","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/:2:0","tags":["算法","数组","模拟"],"title":"54. 螺旋矩阵","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/"},{"categories":["刷题"],"content":"283. 移动零 easy 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组进行操作。 示例 1: 输入: nums = [0,1,0,3,12] 输出: [1,3,12,0,0] 示例 2: 输入: nums = [0] 输出: [0] ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/:0:0","tags":["算法","数组","双指针"],"title":"283. 移动零","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"},{"categories":["刷题"],"content":"快慢指针 不多 bb func moveZeroes(nums []int) { var i, j = 0, 0 for j \u003c len(nums) { for nums[j] == 0 { // j移动到第一个非零位置 j++ if j == len(nums) { return } } nums[i], nums[j] = nums[j], nums[i] i++ j++ } } ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/:1:0","tags":["算法","数组","双指针"],"title":"283. 移动零","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/"},{"categories":["刷题"],"content":"367. 有效的完全平方数 easy 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 进阶：不要 使用任何内置的库函数，如 sqrt 。 示例 1： 输入：num = 16 输出：true 示例 2： 输入：num = 14 输出：false ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:0:0","tags":["算法","数组","二分"],"title":"367. 有效的完全平方数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["刷题"],"content":"二分 不多 bb，跟 69 题差不多 func isPerfectSquare(num int) bool { low, high := 0, num for low \u003c= high { mid := low + (high-low)\u003e\u003e1 if mid*mid \u003c num { low = mid + 1 } else if mid*mid \u003e num { high = mid - 1 } else { return true } } return false } ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/:1:0","tags":["算法","数组","二分"],"title":"367. 有效的完全平方数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"},{"categories":["刷题"],"content":"69. x 的 平方根 easy ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/:0:0","tags":["算法","数组","二分"],"title":"69. x 的平方根","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/"},{"categories":["刷题"],"content":"二分法 不多 bb func mySqrt(x int) int { low, high := 0, x for low \u003c= high { mid := low + (high-low)\u003e\u003e1 if mid*mid \u003c x { if (mid+1)*(mid+1) \u003e x { // 找到最后一个小于x的mid return mid } low = mid + 1 } else if mid*mid \u003e x { high = mid - 1 } else { return mid } } return -1 } ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/:1:0","tags":["算法","数组","二分"],"title":"69. x 的平方根","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/"},{"categories":["刷题"],"content":"袖珍计算器算法 func mySqrt(x int) int { if x == 0 { return 0 } ans := int(math.Exp(0.5 * math.Log(float64(x)))) if (ans + 1) * (ans + 1) \u003c= x { return ans + 1 } return ans } ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/:2:0","tags":["算法","数组","二分"],"title":"69. x 的平方根","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/"},{"categories":["刷题"],"content":"977. 有序数组的平方 easy 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/:0:0","tags":["算法","数组","双指针"],"title":"977. 有序数组的平方","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"},{"categories":["刷题"],"content":"归并 实际上是合并两个有序数组的题目 func sortedSquares(nums []int) []int { ans := make([]int, len(nums)) i := len(ans) - 1 l, r := 0, len(nums)-1 for l \u003c= r { if nums[l]*nums[l] \u003e= nums[r]*nums[r] { ans[i] = nums[l] * nums[l] l++ } else { ans[i] = nums[r] * nums[r] r-- } i-- } return ans } ","date":"2022-03-04","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/:1:0","tags":["算法","数组","双指针"],"title":"977. 有序数组的平方","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/"},{"categories":["Golang"],"content":"go test Go语言提供了go test 命令行工具，使用该工具可以很方便的进行测试。 不仅 Go 语言源码中大量使用 go test，在各种开源框架中的应用也极为普遍。 目前 go test 支持的测试类型有： 单元测试 性能测试 示例测试 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:0:0","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"单元测试 单元测试是指对软件中的最小可测试单元进行检查和验证，比如对一个函数的测试。 测试文件名必须以\"_test.go\"结尾； 测试函数名必须以“TestXxx”开始； 命令行下使用\"go test\"即可启动测试； ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:1:0","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"规范 Go 语言推荐测试文件和源代码文件放在一块，测试文件以 _test.go 结尾。比如，当前 package 有 calc.go 一个文件，我们想测试 calc.go 中的 Add 和 Mul 函数，那么应该新建 calc_test.go 作为测试文件。 example/ |--calc.go |--calc_test.go 假如 calc.go 的代码如下： package main func Add(a int, b int) int { return a + b } func Mul(a int, b int) int { return a * b } 那么 calc_test.go 中的测试用例可以这么写： package main import \"testing\" func TestAdd(t *testing.T) { if ans := Add(1, 2); ans != 3 { t.Errorf(\"1 + 2 expected be 3, but %d got\", ans) } if ans := Add(-10, -20); ans != -30 { t.Errorf(\"-10 + -20 expected be -30, but %d got\", ans) } } ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:1:1","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"测试文件 单元测试源码文件可以由多个测试用例组成，每个测试用例函数需要以 Test 为前缀，例如： func TestXXX( t *testing.T ) 测试用例文件不会参与正常源码编译，不会被包含到可执行文件中。 测试用例文件使用 go test 指令来执行，没有也不需要 main() 作为函数入口。所有在以 _test 结尾的源码内以 Test 开头的函数会自动被执行。 测试用例可以不传入 *testing.T 参数。 基准测试 (benchmark) 的参数是 *testing.B，TestMain 的参数是 *testing.M 类型。 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:1:2","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"go test 默认的情况下，go test 命令不需要任何的参数，它会自动把你源码包下面所有 test 文件测试完毕，当然你也可以带上参数。 -bench regexp 执行相应的 benchmarks，例如 -bench=.； -cover 开启测试覆盖率； -run regexp 只运行 regexp 匹配的函数，例如 -run=Array 那么就执行包含有 Array 开头的函数； -v 显示测试的详细命令。 示例 运行 go test，该 package 下所有的测试用例都会被执行。 $ go test ok example 0.009s 或者指定 test 文件 go test helloworld_test.go 显示每个用例的结果 go test -v，-v 参数会显示每个用例的测试结果 $ go test -v === RUN TestAdd --- PASS: TestAdd (0.00s) === RUN TestMul --- PASS: TestMul (0.00s) PASS ok example 0.007s 查看覆盖率 运行指定函数 如果只想运行其中的一个用例，例如 TestAdd，可以用 -run 参数指定，该参数支持通配符 *，和部分正则表达式，例如 ^、$。 $ go test -run TestAdd -v === RUN TestAdd --- PASS: TestAdd (0.00s) PASS ok example 0.007s 标记单元测试结果 当需要终止当前测试用例时，可以使用 FailNow，参考下面的代码。 测试结果标记（具体位置是./src/chapter11/gotest/fail_test.go） func TestFailNow(t *testing.T) { t.FailNow() } 还有一种只标记错误不终止测试的方法，代码如下： func TestFail(t *testing.T) { fmt.Println(\"before fail\") t.Fail() fmt.Println(\"after fail\") } 测试结果如下： === RUN TestFail before fail after fail --- FAIL: TestFail (0.00s) FAIL exit status 1 FAIL command-line-arguments 0.002s 从日志中看出，第 5 行调用 Fail() 后测试结果标记为失败，但是第 7 行依然被程序执行了。 单元测试日志 每个测试用例可能并发执行，使用 testing.T 提供的日志输出可以保证日志跟随这个测试上下文一起打印输出。testing.T 提供了几种日志输出方法，详见下表所示。 方 法 备 注 Log 打印日志，同时结束测试 Logf 格式化打印日志，同时结束测试 Error 打印错误日志，同时结束测试 Errorf 格式化打印错误日志，同时结束测试 Fatal 打印致命日志，同时结束测试 Fatalf 格式化打印致命日志，同时结束测试 开发者可以根据实际需要选择合适的日志。 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:1:3","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"性能测试 Benchmark 性能测试，也称基准测试，可以测试一段程序的性能，可以得到时间消耗、内存使用情况的报告。 Go 语言中提供了基准测试框架，使用方法类似于单元测试，使用者无须准备高精度的计时器和各种分析工具，基准测试本身即可以打印出非常标准的测试报告。 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:2:0","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"快速浏览 进行性能测试时，尽可能保持测试环境的稳定 实现 benchmark 测试 • 位于 _test.go 文件中 • 函数名以 Benchmark 开头 • 参数为 b *testing.B • b.ResetTimer() 可重置定时器 • b.StopTimer() 暂停计时 • b.StartTimer() 开始计时 执行 benchmark 测试 • go test -bench . 执行当前测试 • b.N 决定用例需要执行的次数 • -bench 可传入正则，匹配用例 • -cpu 可改变 CPU 核数 • -benchtime 可指定执行时间或具体次数 • -count 可设置 benchmark 轮数 • -benchmem 可查看内存分配量和分配次数 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:2:1","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"规范 基准测试（具体位置是 ./src/chapter11/gotest/benchmark_test.go） package code11_3 import \"testing\" func BenchmarkAdd(b *testing.B) { var n int for i := 0; i \u003c b.N; i++ { n++ } } 这段代码使用基准测试框架测试加法性能。 第 7 行中的 b.N 由基准测试框架提供。N 值是动态调整的，直到可靠的算出程序执行时间后才会停止，具体执行次数会在执行结束后打印出来。 测试代码需要保证函数可重入性及无状态，也就是说，测试代码不使用全局变量等带有记忆性质的数据结构。避免多次运行同一段代码时的环境不一致，不能假设 N 值范围。 使用如下命令行开启基准测试： $ go test -v -bench=. benchmark_test.go goos: linux goarch: amd64 Benchmark_Add-4 20000000 0.33 ns/op PASS ok command-line-arguments 0.700s 第 1 行的 -bench=. 表示运行 benchmark_test.go 文件里的所有基准测试，和单元测试中的 -run 类似。 第 4 行中显示基准测试名称，20000000 表示测试的次数，也就是 testing.B 结构中提供给程序使用的 N。“0.33 ns/op”表示每一个操作耗费多少时间（纳秒）。 Windows 下使用 go test 命令行时，-bench=. 应写为 -bench=\".\"。 基准测试原理 基准测试框架对一个测试用例的默认测试时间是 1 秒。开始测试时，当以 Benchmark 开头的基准测试用例函数返回时还不到 1 秒，那么 testing.B 中的 N 值将按 1、2、5、10、20、50……递增，同时以递增后的值重新调用基准测试用例函数。 自定义测试时间 -benchtime 通过 -benchtime 参数可以自定义测试时间，例如： $ go test -v -bench=. -benchtime=5s benchmark_test.go goos: linux goarch: amd64 Benchmark_Add-4 10000000000 0.33 ns/op PASS ok command-line-arguments 3.380s -benchtime 的值除了是时间外，还可以是具体的次数。例如，执行 30 次可以用 -benchtime=30x 测试 CPU 核数 -cpu -cpu 支持传入一个列表作为参数，例如： $ go test -bench='Fib$' -cpu=2,4 . goos: darwin goarch: amd64 pkg: example BenchmarkFib-2 206 5774888 ns/op BenchmarkFib-4 205 5799426 ns/op PASS ok example 3.563s 测试内存 -benchmem 基准测试可以对一段代码可能存在的内存分配进行统计，下面是一段使用字符串格式化的函数，内部会进行一些分配操作。 func BenchmarkAlloc(b *testing.B) { for i := 0; i \u003c b.N; i++ { fmt.Sprintf(\"%d\", i) } } 在命令行中添加 -benchmem 参数以显示内存分配情况，参见下面的指令： $ go test -v -bench=Alloc -benchmem benchmark_test.go goos: linux goarch: amd64 Benchmark_Alloc-4 20000000 109 ns/op 16 B/op 2 allocs/op PASS ok command-line-arguments 2.311s 代码说明如下： 第 1 行的代码中 -bench 后添加了 Alloc，指定只测试 BenchmarkAlloc() 函数。 第 4 行代码的“16 B/op”表示每一次调用需要分配 16 个字节，“2 allocs/op”表示每一次调用有两次分配。 控制计时器 有些测试需要一定的启动和初始化时间，如果从 Benchmark() 函数开始计时会很大程度上影响测试结果的精准性。 testing.B 提供了一系列的方法可以方便地控制计时器，从而让计时器只在需要的区间进行测试。我们通过下面的代码来了解计时器的控制。 基准测试中的计时器控制（具体位置是 ./src/chapter11/gotest/benchmark_test.go）： func BenchmarkAddTimerControl(b *testing.B) { // 重置计时器 b.ResetTimer() // 停止计时器 b.StopTimer() // 开始计时器 b.StartTimer() var n int for i := 0; i \u003c b.N; i++ { n++ } } 从 Benchmark() 函数开始，Timer 就开始计数。StopTimer() 可以停止这个计数过程，做一些耗时的操作，通过 StartTimer() 重新开始计时。ResetTimer() 可以重置计数器的数据。 计数器内部不仅包含耗时数据，还包括内存分配的数据。 测试不同的数据 不同的函数复杂度不同，O(1)，O(n)，O(n^2) 等，利用 benchmark 验证复杂度一个简单的方式，是构造不同的输入。对刚才的 benchmark 稍作改造，便能够达到目的。 // generate_test.go package main import ( \"math/rand\" \"testing\" \"time\" ) func generate(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func benchmarkGenerate(i int, b *testing.B) { for n := 0; n \u003c b.N; n++ { generate(i) } } func BenchmarkGenerate1000(b *testing.B) { benchmarkGenerate(1000, b) } func BenchmarkGenerate10000(b *testing.B) { benchmarkGenerate(10000, b) } func BenchmarkGenerate100000(b *testing.B) { benchmarkGenerate(100000, b) } func BenchmarkGenerate1000000(b *testing.B) { benchmarkGenerate(1000000, b) } 这里，我们实现一个辅助函数 benchmarkGenerate 允许传入参数 i，并构造了 4 个不同输入的 benchmark 用例。运行结果如下： $ go test -bench . goos: darwin goarch: amd64 pkg: example BenchmarkGenerate1000-8 34048 34643 ns/op BenchmarkGenerate10000-8 4070 295642 ns/op BenchmarkGenerate100000-8 403 3230415 ns/op BenchmarkGenerate1000000-8 39 32083701 ns/op PASS ok example 6.597s 通过测试结果可以发现，输入变为原来的 10 倍，函数每次调用的时长也差不多是原来的 10 倍，这说明复杂度是线性的。 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:2:2","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"示例测试 示例测试，广泛应用于 Go 源码和各种开源框架中，用于展示某个包或某个方法的用法。 例子测试函数名需要以 “Example” 开头； 检测单行输出格式为 “// Output: \u003c期望字符串\u003e”； 检测多行输出格式为 “// Output: \\ \u003c期望字符串\u003e \\ \u003c期望字符串\u003e”，每个期望字符串占一行； 检测无序输出格式为 “// Unordered output: \\ \u003c期望字符串\u003e \\ \u003c期望字符串\u003e\"，每个期望字符串占一行； 测试字符串时会自动忽略字符串前后的空白字符； 如果测试函数中没有 “Output” 标识，则该测试函数不会被执行； 执行测试可以使用 go test，此时该目录下的其他测试文件也会一并执行； 执行测试可以使用 go test \u003cxxx_test.go\u003e，此时仅执行特定文件中的测试函数； ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:3:0","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"示例 源代码文件 example.go 中包含 SayHello()、SayGoodbye()和PrintNames() 三个方法，如下所示： package gotest import \"fmt\" // SayHello 打印一行字符串 func SayHello() { fmt.Println(\"Hello World\") } // SayGoodbye 打印两行字符串 func SayGoodbye() { fmt.Println(\"Hello,\") fmt.Println(\"goodbye\") } // PrintNames 打印学生姓名 func PrintNames() { students := make(map[int]string, 4) students[1] = \"Jim\" students[2] = \"Bob\" students[3] = \"Tom\" students[4] = \"Sue\" for _, value := range students { fmt.Println(value) } } 这几个方法打印内容略有不同，分别代表一种典型的场景： SayHello()：只有一行打印输出 SayGoodbye()：有两行打印输出 PrintNames()：有多行打印输出，且由于 Map 数据结构的原因，多行打印次序是随机的。 测试文件 example_test.go 中包含 3 个测试方法，于源代码文件中的 3 个方法一一对应，测试文件如下所示： package gotest_test import \"gotest\" // 检测单行输出 func ExampleSayHello() { gotest.SayHello() // OutPut: Hello World } // 检测多行输出 func ExampleSayGoodbye() { gotest.SayGoodbye() // OutPut: // Hello, // goodbye } // 检测乱序输出 func ExamplePrintNames() { gotest.PrintNames() // Unordered output: // Jim // Bob // Tom // Sue } 例子测试函数命名规则为\"Examplexxx”，其中\"xxx\"为自定义的标识，通常为待测函数名称。 这三个测试函数分别代表三种场景： ExampleSayHello()： 待测试函数只有一行输出，使用\"// OutPut: “检测。 ExampleSayGoodbye()：待测试函数有多行输出，使用”// OutPut: “检测，其中期望值也是多行。 ExamplePrintNames()：待测试函数有多行输出，但输出次序不确定，使用”// Unordered output:“检测。 注：字符串比较时会忽略前后的空白字符。 命令行下，使用 go test 或 go test example_test.go 命令即可启动测试，如下所示： E:\\OpenSource\\GitHub\\RainbowMango\\GoExpertProgrammingSourceCode\\GoExpert\\src\\gotest\u003ego test example_test.go ok command-line-arguments 0.331s ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:3:1","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["Golang"],"content":"子测试 ","date":"2022-02-25","objectID":"/Notes/posts/golang/go-test/:4:0","tags":[],"title":"Go test 教程","uri":"/Notes/posts/golang/go-test/"},{"categories":["专业课"],"content":"操作系统一 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:0:0","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"操作系统引论 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:1:0","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"操作系统概念 定义 计算机系统中的一个系统软件，是程序模块的集合 （有效、合理、方便） 目标 方便性 有效性：提高系统资源利用率、提高系统吞吐量 可扩充性 开放性：软硬件兼容 作用 作为用户与硬件之间的接口 计算机系统资源的管理者 硬件资源 软件资源 实现了对计算机资源的抽象 覆盖了一系列软件（I/O 操作命令、文件管理等）后成为虚机器 推动 OS 发展的动力 不断提高计算机资源利用率 方便用户 器件的不断更新与迭代 计算机体系结构的不断发展 不断提出新的应用需求 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:1:1","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"操作系统的发展过程 人工操作 脱机 / 假脱机（SPOOLing）方式 事先将装有用户程序和数据的纸带装入纸带输入机，在一台外围机的控制下，把纸带（卡片）上的数据（程序）输入到磁带上 当 CPU 需要这些程序和数据时，再从磁带上高速调入内存。 当 CPU 需要输出时，先由 CPU 把数据直接从内存高速地输送到磁带上，然后在另一台外围机的控制下，再将磁带上的结果通过相应的输出设备输出。 单道批处理 首先由监督程序将磁带上的第一个作业装入内存，并将运行控制权交给该作业； 当该作业处理完成时，又把控制权交还给监督程序，再由监督程序吧磁带上的第二个作业调入内存。 计算机系统就这样自动地一个作业紧接着一个作业地进行处理，直至磁带上的所有作业全部完成 特点 自动性、顺序性、单道性（内存中仅有一道程序） 多道批处理 (并发) 利用 A 程序的 I/O 操作而暂停执行 CPU 空挡时间，调度 B 程序运行 特点 资源利用率高 系统吞吐量大 平均周转时间长（需要排队依次进行处理） 无交互能力（修改和调试程序不方便） 需要解决的问题 处理机争用问题 内存分配和保护问题 I/O 设备分配问题 文件的组织和管理问题 作业管理问题 用户与系统的接口问题 (多道、单道的比较) 分时系统 人机交互、共享主机 时间片（time slice）：一段很短的时间，用来切割 CPU 关键问题 系统首先必须能提供多个终端，同时给多个用户使用； 其次，当用户在自己的终端上键入命令时，系统应能及时接收、并及时处理该命令，再将结果返回给用户。 及时接收 要做到及时接收多个用户键入的命令或数据，只需在系统中配置一个多路卡即可（多路卡实现分时多路复用，使主机能同时接收各用户从终端上输入的数据） 此外，还须为每个终端配置一个缓冲区，用来暂存用户键入的命令（或数据）。 及时处理 人-机交互的关键在于，用户键入命令后能对自己的作业机器运行及时地实施控制，或进行修改。因此，各个用户的作业都必须驻留在内存中，并能频繁地获得处理机运行。 作业直接进入内存 采用轮转运行方式 特征 多路性 该特性是指系统允许将多台终端同时连接到一台主机上，并按分时原则为每个用户服务。多路性允许多个用户共享一台计算机，显著地提高了资源利用率，降低了使用费用，从而促进了计算机更广泛的应用。 独立性 该特性是指系统提供了这样的用机环境，即每个用户在各自的终端上进行操作，彼此之间互不干扰，给用户的感觉就像是他一人独占主机进行操作。 及时性 该特性是指用户的请求能在很短时间内获得相应。这一时间间隔是根据人们所能接收的等待时间确定的，通常仅为1~3秒钟。 交互性 该特性是指用户可通过终端与系统进行广泛的人机对话。其广泛性表现在：用户可以请求系统提供多方面的服务。 实时系统 （Real time system） 计算机对所接收到的信号做出及时或实时的反应 实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。 实时任务的类型 周期性实时任务和非周期性实时任务 周期性实时任务：外部设备周期性地发出激励信号给计算机，要求它按规定周期循环执行，以便周期性地控制某外部设备。 非周期性实时任务：无明显周期性，但联系着一个截止时间，或称为最终期限。它可分为： 开始截止时间：某任务在某时间以前必须开始执行 完成截止时间：某任务在某时间以前必须完成 硬实时任务和软实时任务 硬实时任务：系统必须满足任务对截止时间的要求 软实时任务：也联系着一个截止时间，但并不严格，若偶尔错过了任务的截止时间，对系统产生的影响也不会太大。 分时系统和实时系统的比较 微机操作系统 单用户单任务操作系统 MS-DOS 单用户多任务操作系统 Windows XP 多用户多任务操作系统 UNIX，Linux ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:1:2","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"操作系统的基本特性 并发 （Concurrence）多时间在同一时间段内发生 多道程序宏观上并发，微观上交替执行 引入进程（Process） 未引入进程系统：计算和 I/O 顺序执行 引入进程系统：为计算程序和 I/O 程序分别建立一个进程，两个进程可并发进行 线程（Threads） 比进程更小的单位 共享 （Sharing）系统中的资源可供内存中多个并发执行的进程（线程）共同使用 互斥共享（音频设备、打印机） 同时访问（磁盘文件、可重入代码） 虚拟 （Virtual）把一个物理实体变为若干个逻辑上的对应物 如 CPU：每个进程的虚处理机 存储器：每个进程占有的地址空间（指令+数据+堆栈） 显示设备：多窗口或虚拟终端 打印设备：将临界资源变成同时访问资源 方法 时分复用 虚拟处理机技术、虚拟设备技术 空分复用 对存储空间的管理，实际上是内存的分时复用 异步 （Asynchronism） 也称不确定性 / 随机，指进程的执行顺序和执行时间的不确定性 并发执行的程序走走停停，不可预知 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:1:3","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"操作系统的主要功能 资源管理 处理机管理（硬件） 存储器管理（硬件） 设备管理（硬件） 文件管理（软件） 用户接口 命令接口 图形接口 程序接口 处理机管理功能 进程控制：创建、撤销、状态迁移 进程同步：互斥访问临界资源 进程通信：进程合作 调度 作业调度：按照算法为作业分配资源 进程调度：按照算法先后执行进程 存储器管理功能 内存分配 为每道程序分配内存空间 提高存储器利用率，减少内存碎片 满足正在运行的程序数据动态增长的需要 分类 静态分配 动态分配 内存保护 每道程序在自己的内存空间内运行，彼此互不干扰 不允许用户访问操作系统的程序与数据 不允许用户转到非共享的其他用户程序 地址映射 能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址 内存扩充 借助虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序能并发运行。 功能 请求调入 置换 设备管理功能 主要任务 完成用户提出的 I/O 请求，并分配 I/O 设备 提高 I/O 利用率 主要内容 缓冲管理 在 I/O 设备和 CPU 中之间引入缓冲 设备分配 设备处理 虚拟设备 文件管理功能 文件存储空间的管理 为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存取速度 目录管理 为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效的组织，以实现方便的按名存取 文件的读 / 写管理和保护 文件的读 / 写管理 根据用户请求，从外存中读取数据，或将数据写入外存。 文件保护 放置未经核准的用户存取文件；放置冒名顶替存取文件；放置以不正确的方式存取文件 操作系统与用户之间的接口 用户接口 用户可以通过该接口向作业发出命令以控制作业的运行 命令接口（联机用户接口、脱机用户接口） + 图形用户接口 程序接口 由一组==系统调用==构成，它长得蛮像个库函数（API） 程序接口是为用户程序在执行中访问系统而设置的，是用户程序取得操作系统服务的唯一途径 一些概念 系统调用 系统调用是操作系统提供给应用程序 / 编程人员的唯一接口，它使 CPU 状态从用户态陷入内核态 内核 内核是一组程序模块，作为可信软件来提供支持进程并发执行的基本功能和基本操作 它驻留内核空间，运行于和心态，具有访问硬件设备和内存的全部权限，可以执行特权指令。 它是对操作系统核心功能的抽象概念 处理过程 用户使用系统调用（此时用户程序挂起），导致操作系统功能执行（此时从用户态陷入内核态），并返回用户请求的服务，用户程序恢复现场。 用户态 （user mode）非特权状态、目态 在此状态下，执行的代码被硬件限定，不能进行某些操作 核心态 特权状态、管态 核心态是操作系统内核所运行的模式，运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。 特权指令 管理硬件和系统安全，只能在核心态执行，用户程序不得含有特权指令。 现代操作系统的新功能 blabla ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:1:4","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"操作系统结构设计 传统 OS 结构 无结构操作系统 模块化结构 OS 模块独立性 内聚性 指模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越强 耦合度 模块间相互联系和相互影响的程度。耦合度越低，模块独立性越强 分层式结构 OS 在目标系统 A~n~ 和裸机系统 A~0~ 之间，铺设若干个层次的软件 A~1~、A~2~、A~3~、…、A~n-1~，使 A~n~ 通过 A~n-1~、A~n-2~、…、A~2~、A~1~ 层，最终能在 A~0~ 上运行。 自底向上的分层设计的基本原则是每一步设计都是建立在可靠的基础上，每一层仅能使用期底层所提供的功能和服务 客户 / 服务器模式 （Client / Server Model） 客户机、服务器、网络系统 面向对象的程序设计 微内核 OS 结构 基于客户服务器模式 应用机制与策略分离原理 机制是指实现某一功能的具体执行机构，通常处于系统基层，在微内核操作系统中，将机制放在 OS 的微内核中。 策略是指在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标，通常处于系统高层。 采用面向对象技术 微内核 能实现现代 OS 最基本核心功能的小型内核 包含 与硬件处理紧密相关的部分 一些较基本的功能 客户与服务器间的通信 如 进程管理 低级存储器管理 中断和陷入管理 优点 正确性、灵活性、易维护性、可扩充性 提高系统可扩展性 提高系统可靠性 提高可移植性 提供了对分布式系统的支持 融入了面向对象技术 存在的问题 效率低：系统在用户态与内核态多次切换（上下文切换频繁） ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:1:5","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"进程的描述与控制 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:0","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"前驱图和程序执行 前驱图 顺序执行 前驱图 特征 顺序性 封闭性：程序运行时独占全部资源 可再现性 并发执行 允许多道程序共享资源，次序不确定 前驱图 特征 间断性：程序共享系统资源，程序之间会有相互制约的关系，出现 “执行——暂停——执行” 的间断性活动规律 失去封闭性：程序共享系统资源 不可再现性：失去封闭性，导致了不可再现性 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:1","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"进程的描述 （Process） 进程的定义和特征 进程定义 描述性定义 计算机中的所有程序（软件），按照某种顺序运行，这种运行的过程叫做进程 （一个活动，有程序输入、输出和状态） 典型定义 ==进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位== 进程是 CPU 抽象的结果 进程实体 进程在计算机系统中的映像 它包括 进程控制块：（Process Control Block，PCB）系统为了控制进程而设计的数据结构 进程描述信息 进程控制信息 … 程序段 相关数据段 管理用户的用户堆栈和系统堆栈：可归类到数据段中 进程特征 动态性：“由创建而产生，由调度而执行，由撤销而消亡”，它有一定的生命期 并发性：多个进程实体同存于内存中，且能在一段时间内同时运行；引入进程实体的目的就是并发执行 独立性：进程实体能够独立运行、获取资源、接受调度 异步性：进程按各自独立的、不可预知的速度向前推进 进程与程序的不同 进程是动态的，程序是静态的 进程是暂时的，程序时永恒的 进程包含程序、数据和PCB 进程可以包含多个程序（调用），同一程序可以对应多个进程（多次执行） 进程的基本状态及转换 进程的三种基本状态 就绪状态（Ready） 进程被分配到除 CPU 以外的所有必要资源 按一定的策略可被排成就绪队列 执行状态（Running） 占用 CPU 运行 执行态进程数小于等于 CPU 数 阻塞状态（Block） 暂时无法继续执行 可以排成一个阻塞队列 三种基本状态的转换 创建状态和终止状态 创建状态 创建进程的过程 进程刚建立，还未进入就绪队列 终止状态 终止进程的过程 挂起状态和进程状态的转换 定义 挂起状态（Suspend）：进程从内存转到外存（进入静止状态，不可接受调度） 执行的进程暂停、就绪的进程不调度 引入挂起状态的原因 终端用户的请求 父进程请求 负荷调节的需要 操作系统的需要 引入挂起原语操作后的状态转换 进程管理中的数据结构 (PCB) PCB 的作用 作为独立运行基本单位的标志 实现间断性运行的方式 提供进程管理需要的信息 提供进程调度所需要的信息 实现与其它进程通信 PCB 中的信息 进程标识符（编号） 处理机状态（通用寄存器，计数器，程序状态字 PSW，用户栈指针） 进程调度信息（进程状态、优先级） 进程控制信息（程序和数据的地址、进程同步和通信机制（信号量等）、资源清单、链接指针） PCB 组织方式 线性结构 / 方式 将所有的 PCB 都组织在一张线性表中，将该表的首址存放在内存的一个专用区域中 链接结构 把相同状态进程的 PCB 分别通过 PCB 中的链接字链接成一个队列，这样就可以形成就绪队列、若干个阻塞队列和空白队列等 索引结构 系统根据所有进程状态的不同，建立几张索引表 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:2","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"进程控制 操作系统内核 支撑功能 中断处理 时钟管理（时间片） 原语操作（由若干条指令组成，在执行过程中不允许被中断） 资源管理功能 进程管理 存储器管理 设备管理 进程的创建 进程的层次结构 父进程 - 子进程 - 孙进程 进程图 用于描述进程间关系的一棵有向树。图中的结点代表进程。 引起创建进程的事件 用户登录 作业调度 提供服务 应用请求 进程的创建 申请空白 PCB 为新进程分配其运行所需的资源 初始化进程控制块 PCB 将新进程插入就绪列 进程的终止 正常结束 异常结束 外界干预（父进程、操作员或操作系统的干预） 进程终止过程 根据被终止进程的标识符，从 PCB 集合中检索出该进程的 PCB，从中读出该进程的状态 若被终止进程正处于执行状态，应立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度 若该进程还有子孙进程，还应将子孙进程也终止 将被终止进程所有全部资源或者归还给其父进程，或归还给系统 将被终止进程从所在队列中移出 进程的阻塞与唤醒 引起进程的阻塞与唤醒的事件 向系统请求共享资源失败 等待某种操作的完成 新数据尚未到达 无新任务可做，等待新任务的到达 进程阻塞过程 进程使用阻塞原语 block 自己 停止运行并进入阻塞队列 调度程序重新调度 阻塞原语：block 阻塞是进程自身的一种主动行为。 进程唤醒过程 调用唤醒原语 wakeup，将等待该事件的进程唤醒。 将进程从阻塞队列移出， 将 PCB 改为就绪， 加入就绪队列。 进程的挂起 挂起原语：suspend 检查进程状态， 改为对应的静止状态， 复制 PCB 到指定内存区域以备查看。 指引重新调度 进程的激活 挂起原语：active 将进程从外存调入内存，检查状态，改为对应就绪/阻塞状态。 如果有抢占机制比较是否抢占。 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:3","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"进程同步 基本概念 进程同步机制的主要任务：对多个相关进程在执行次序中进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好地相互合作，从而使程序的执行具有可再现性。 两种形式的制约关系 直接实现同步，间接实现互斥 间接相互制约关系：互斥 多个程序在并发执行时，由于共享系统资源致使这些执行程序之间形成相互制约的关系。 直接相互制约关系：同步 源于进程之间的合作关系，前趋图 临界资源 （Critical Resource） 系统中一次只允许一个进程使用的资源 诸进程间应采取互斥方式，实现对临界资源的共享。 临界区 （Critical Section） 进程中访问临界资源的代码段 while(TRUE) { 进入区 临界区 退出区 剩余区 } 同步机制应遵循的问题 空闲让进：无其他进程处于临界区时，允许一个进程进入临界区 忙则等待：已有进程进入临界区时，其他进程必须等待 有限等待：在有限时间内能进入自己的临界区，以免陷入“死等”状态；保证有限时间内进入临界区 让权等待：进程不能进入临界区时应立即释放处理机（避免死等资源，即忙等待 Busy waiting） 硬件同步机制 关中断 禁止中断发生，不适用于多 CPU 在进入锁测试之前关闭中断，直到完成锁测试并上锁之后才能打开中断。 Test-and-Set 指令实现互斥 疯狂测试 lock，如果开门了就锁门后访问 boolean TS(boolean *lock) { boolean old; old = *lock; *lock = TRUE; return old; } do{ … while TS(\u0026lock) critical section; lock = FALSE; remainder section; }while(TRUE) 利用 Swap 指令实现进程互斥 疯狂交换 key 和 lock，如果 key 变 true了访问 void swap(boolean *a, boolean *b) { boolean temp; temp = *a; *a = *b; *b = temp; } do{ key = TRUE; do{ swap(\u0026lock,\u0026key); }while(key!=FALSE) 临界区操作; lock = FALSE; … }while(TRUE) 信号量机制 整型信号量 信号量定义为一个整型量 S 两个原子操作 wait(S) 和 signal(S) 被分别称为 P、V 操作。 // 只要信号量小于等于0就不断进行测试（忙等），其实是未遵循让权等待的 wait(S){ // 探测 while(S\u003c=0); S--; } signal(S){ // 释放 S++; } 记录型信号量 解决忙等问题 typedef struct{ int value; struct process_control_block *list; }semaphore wait(semaphore *S) { S-\u003evalue--; if(S-\u003evalue\u003c0) block(S-\u003elist); } signal(semaphore *S) // 释放一个单位资源 { S-\u003evalue++; if(S-\u003evalue\u003c=0) wakeup(S-\u003elist); } value：代表资源数目的整型变量 list：一个进程链表指针，用于链接上述所有等待进程。 S-\u003evalue：表示资源数量 S-\u003evalue 大于等于 0：表示系统中可用资源数 S-\u003evalue 小于 0：表示已阻塞进程数 S-\u003evalue 初始值为 1：表示互斥信号量（临界资源只有一个） S-\u003elist：记录阻塞进程信息 AND 型信号量 解决死锁问题 将进程在整个运行过程中需要的所有资源，一次性全部分配给进程，待进程使用完后再一起释放，只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。 信号量集 解决多份资源问题 进程对信号量 S~i~ 是该资源的分配下限值 t~i~，要求 S~i~≥t~i~，否则不予分配。一旦允许分配，进程对该资源的需求值为 d~i~，即表示资源占用量，进行 S~i~=S~i~-d~i~ 操作。 特殊情况 Swait(S,d,d)：只有一个信号量 S，允许每次申请 d 个资源，当少于 d 时，不予分配 Swait(S,1,1)：一般的记录型信号量 (S\u003e1) 或互斥信号量 (S=1) Swait(S,1,0)：S≥1，允许多个进程进入某特定区；S=0，将阻止任何进程进入特定区 信号量应用 利用信号量实现进程互斥 两个信号量互斥 设 mutex 为互斥信号量，其初值为 1，取值范围为 (-1,0,1)。当 mutex=1 时，表示两个进程皆未进入需要互斥的临界区；当 mutex=0 时，表示有一个进程进入临界区运行，另外一个必须等待，挂入阻塞队列；当 mutex=-1 时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。 代码描述 semaphore mutex=1; PA(){ while(1){ wait(mutex); 临界区 signal(mutex); 剩余区 } } 利用信号量实现前趋关系 管程机制（自学） 面向对象的封装 代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成了一个操作系统的资源管理模块，称之为管程。 组成 管程的名称 局部于管程的共享数据结构说明 对该数据结构进行操作的一组过程 对局部于管程的共享数据设置初始值的语句 管程和进程的不同 进程定义的是私有数据结构 PCB，管程定义的是公共数据结构 进程是由顺序程序执行有关操作，管程进行同步操作和初始化操作 进程的设置目的在于实现系统的并发性，管程的设置目的则是解决共享资源互斥使用问题 进程为主动工作方式，管程为被动工作方式 进程具有动态性，管程是操作系统中的一个资源管理模块，供进程调用 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:4","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"经典进程的同步问题 生产者-消费者问题 生产者-消费者问题是相互合作的进程关系的一种抽象 记录型信号量 循环队列 P 操作互换会引起死锁；V 操作互换不影响 AND 信号量 哲学家进餐问题 记录型信号量 避免死锁的方法 读者-写者问题 写者进程与所有其他读者进程互斥 写者进程互斥 记录型信号量 信号量集机制 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:5","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"进程通信 进程通信就是进程之间的信息交换，用于同步和互斥。 互斥实质上是一种特殊的同步 进程同步实质上就是一种进程通信 概念 低级进程通信（信号量） 效率低 通信对用户不透明 P/V 操作称为低级通信原语 高级进程通信 进程通信 IPC（Inter Process Communication） 使用方便 高效地传送大量数据 进程通信的类型 共享存储器系统（Shared-Memory System） 共享数据结构或存储区 基于共享数据的通信方式（数据结构） 基于共享存储区的通信方式（内存） 管道通信系统 所谓 “管道”，指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件 写进程 —\u003e 管道文件 —\u003e 读进程 以文件为传输介质 以字符流方式读写 消息传递系统（Message Passing System） 以格式化的消息（message）为单位 实现方式 程序员利用系统提供的一组通信命令（原语）进行通信 直接通信方式（原语操作） 间接通信方式（通过共享中间实体（信箱通）） 客户-服务器系统（Client-Server System） 套接字：分基于文件型和基于网络型 远程方法调用和远程文件调用 消息传递通信的实现方式 直接消息传递系统 发送进程利用 OS 所提供的发送命令（原语），直接把消息发送给目标进程。 直接通信原语 对称寻址方式 send(receiver,message); receive(sender,message); 非对称寻址方式 send(P,message); receive(id,message); 消息的格式 进程的同步方式 通信链路 信箱通信 信箱的结构 信箱头：用于存放有关信箱的描述信息 信箱体：由若干个可以存放消息（或消息头）的信箱格组成，信箱格的数目已经每格的大小是在创建信箱时确定的 信箱通信原语 邮箱的创建和撤销 消息的发送和接收 信箱的类型 私用邮箱 公用邮箱 共享邮箱 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:6","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"线程的基本概念 线程的引入 引入线程是为了减少程序在并发执行时所付出的时空开销，使 OS 具有更好的并发性 进程是可拥有资源的独立单位和可独立调度和分派的基本单位 线程：资源共享、调度独立（作为调度和分派的基本单位） 线程与进程的比较 调度的基本单位 进程是能独立运行的基本单位，在每次被调度时，都需要进行上下文切换，开销较大； 线程切换仅需保存和设置少量寄存器内容，切换代价远低于进程 并发性 都可以并发执行 拥有资源 进程可以拥有资源，并作为系统中拥有资源的一个基本单位； 线程并不拥有系统资源，而是仅有一点必不可少的、能保证独立运行的资源；线程仅拥有隶属进程的资源 独立性 进程间地址空间和资源互相独立； 线程间共享地址空间和资源 系统开销 进程需要切换上下文； 线程没什么资源，开销小 支持多处理机系统 进程必须在单处理机上运行； 单进程中的多线程可分配到不同处理机上执行 线程的实现 内核支持线程（KST, Kernel Supported Threads）：内核创建，能够并发，用户切换线程需要陷入 用户级线程（ULT, User Level Threads）：用户创建，切换不需要陷入，但阻塞后无法调度 组合模式：两者结合相互利用 （线程的实现、线程的创建与终止……） ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:2:7","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"处理机调度与死锁 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:3:0","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"处理机调度的层次和调度算法的目标 调度的实质是一种资源分配，处理机调度是对处理机资源进行分配 作业：作业是任务实体，进程是完成任务的执行实体 周转时间：从作业提交给用户开始，到作业完成为止的时间间隔（等待时间与运行时间之和） 系统性能：平均作业周转时间 带权周转时间：$W_i=\\frac{T_i}{T{ki}}$（T~ki~ 为运行时间），大于等于 1（周转时间与运行时间之比） 响应时间：交互式进程从提交一个请求到接受到响应的时间间隔 处理机调度的层次 作业从进入系统成为后备作业开始，直到运行结束退出系统为止，需经历不同级别的调度 高级调度（作业调度 / 长程调度） 启动、进入系统时 决定外存上后备队列的哪几个作业调入内存 调度对象是作业，主要用于多道批处理系统中。 中级调度（内存调度 / 平衡调度） 挂起 / 唤醒，做内外存的对换 主要目的是提高内存利用率和系统吞吐量。 低级调度（进程 / 线程调度） 决定就绪队列中的哪个进程获得处理机 调度对象是进程（内核级线程），基本调度 在多道批处理、分时和实时三种类型的 OS 中，都必须配置这级调度。 处理机调度算法目标 处理机调度算法的共同目标 资源利用率 ($CPU的利用率=\\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$) 公平性 诸进程都获得合理的 CPU 时间，不会发生进程饥饿现象 平衡性 CPU 都能经常处于忙碌状态；系统资源的平衡性 策略强制执行 如安全策略 批处理系统的目标 平均周期时间短 周转时间：从作业被提交给系统开始，到作业完成为止的这段时间间隔，包括作业在外存后备队列上等待调度的时间，进程在就绪队列上等待进程调度的时间，进程在 CPU 上执行的时间，以及进程等待 I/O 操作完成的时间。 平均周转时间最短，有效提高系统资源利用率，可使大部分用户满意。 平均周转时间：$ (T=\\frac{1}{n}[\\sum_{i=1}^{n}{T_i}])$ 平均带权周转时间： $(W=\\frac{1}{n}\\sum_{i=1}^{n}{\\frac{T_i}{T_s}})$ 作业周转时间 $T$，系统为其服务时间 $T_s$ 系统吞吐量高 吞吐量：在单位时间内系统所完成的作业数 处理机利用率高 分时系统的目标 响应时间快 响应时间：从用户通过键盘提交一个请求开始，直到屏幕上显示出处理结果为止的一段时间间隔。 均衡性 均衡性：系统响应时间的快慢应与用户所请求服务的复杂性相适应。 实时系统的目标 截止时间的保证 截止时间：某任务必须开始执行的最迟时间，或必须完成的最迟时间 可预测性 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:3:1","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"作业与作业调度 凡是涉及作业的调度算法均是非抢占式的 概念 进程：程序段 + 数据 + PCB 作业（Job）：包含程序、数据、作业说明书。 作业步：完成作业的每一个加工步骤。 作业控制块（JCB Job Control Block）：是作业在系统中存在的标志。 作业运行的三个阶段和三种状态 输入、后备、执行、完成 收容阶段（后备状态）：建立 JCB 进入后备队列 运行阶段（运行状态）：分配资源、进入就绪队列 完成阶段（完成状态）：完成 作业最终转化为进程，其中的低级调度不可避免 作业调度的主要任务 接纳多少个作业（允许多少个作业同时在内存中运行） 接纳哪些作业（取决于所采用的调度算法） 选择作业 -\u003e 分配资源 -\u003e 创建进程 -\u003e 作业控制 -\u003e 后续处理 先来先服务 FCFS 调度算法 （First Coming First Serverd） 作业调度 √，进程调度 √ 系统按照作业到达的先后顺序来进行调度，或者说优先考虑等待时间最长的作业，而不管作业所需执行时间的长短 特点 不可抢占性、实现简单、顾及作业等候时间 有利于长作业(进程)，不利于短作业(进程) 有利于 CPU 繁忙型作业，不利于 I/O 繁忙型作业 效率不高、没有考虑优先级 短作业优先 SJF 调度算法 （Short Job First / shortest process first，有时会写作 SJN/SPN，N 表 next） 作业调度 √，进程调度 √ 以作业长短来计算优先级，作业越短，优先级越高。作业的长短是以作业所要求的运行时间来衡量的。 优点 易于实现 平均周转时间比 FCFS 小 缺点： 效率还不是很高 必须预知作业的运行时间 对长作业非常不利，忽视了长作业的等待时间，出现饥饿现象 人-机无法交互 未考虑作业的紧迫程度 最短剩余时间优先 SRTF （shortest remaining time first） SJF 算法的抢占式 一旦有作业就绪，让其需要的 CPU 时间与当前运行作业剩余时间做判断，小者上 CPU 优先级调度 PSA 算法 （priority-scheduling algorithm） 作业调度 √，进程调度 √ 基于作业的紧迫度，由外部赋予作业相应的优先级。 可以是抢占式，也可以是非抢占式的 一般为高优先权优先（HPF，highest-priority first） 使得紧迫的任务得以优先执行 静态优先级较死板，动态优先级开销大 高响应比优先调度 HRRN 算法 （highest response ratio next） 既考虑等待时间，也考虑运行时间。进程都到之后开始计算优先权。 动态优先级 ($优先权=\\frac{等待时间+要求服务时间}{要求服务时间}=\\frac{响应时间}{要求服务时间}=响应比R_p$) 作业等待时间相同，服务时间越短，优先级越高，利于短作业 要求服务时间相同，等待时间越长，优先级越高，利于长作业 作业优先级可以随等待时间的增加而提高 缺点：每次调度都需进行响应比的计算 响应时间并不是周转时间，响应时间是一种不断变化的过程；周转时间是作业运行结束后得出的结果 同理，这里的等待时间表示已经等待的时间，是过程；通常意义上的等待时间则是一种结果 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:3:2","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"进程调度 进程调度的任务 保存处理机的现场信息 按某种算法选取进程 把处理器分配给进程 进程调度机制 排队器 分派器 上下文切换器 进程调度方式 非抢占方式：一旦分配给某进程，就一直让它运行下去。 正在执行的进程运行完毕，或因发生某时间而使其无法再继续运行 正在执行中的进程因提出 I/O 请求而暂停执行 进程通信或同步过程中，执行了某种原语操作 抢占方式：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程 优先权原则 短进程优先原则 时间片原则 轮转调度 RR 算法 （round robin） 调度契机 一个时间片尚未用完，正在允许的进程便已完成 在一个时间片用完时，计时器中断处理程序被激活，若进程尚未运行完毕，调度程序将把它送往就绪队列的末尾。 时间片未用完时，进程因 I/O 原因造成了堵塞 特点 只能用于调度 CPU 这一类可抢占资源 作业调度一般不使用轮转，因为它资源特别多，包含有对不可抢占资源的分配 短作业存在优先权 长作业上下文切换时间开销大 时间片的选择 时间片过大 -\u003e 退化成 FCFS 时间片过小 -\u003e 过多的上下文切换，吞吐量小 根据系统对响应时间的要求 R和就绪队列中所允许的最大进程数 N~max~ 确定 这里也有响应时间，为用户数目 × 时间片大小 多级反馈队列调度算法 MFQ （multileved feedback queue） 描述 设置多个就绪队列（优先级逐个降低，时间片逐个增大） 每个队列都采用 FCFS 算法，最后一个队列 RR 算法 若有新进程进入，加入第一队列末尾 若进程未在时间片内完成，则到第二队列末尾 队列按照优先级调度 随着队列优先级的降低，分配的时间片变长 调度算法的性能 终端型用户：交互型作业，较小，可以保证在第一队列时间片内完成即可 短批处理作业用户：稍短的，第一队列完成；稍长的，第二、三队列各执行一个时间片完成，周转时间也较短 长批处理作业用户：依次在第 1 到 n 个队列中运行，再以轮转的方式运行，不必担心作业长期得不到处理。 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:3:3","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"死锁概述 定义 计算机系统中多道程序并发执行时，两个或两个以上的进程由于竞争系统资源而造成的一种互相等待的现象 若无外力作用，这组进程将永远不能继续执行 资源类型 可重用性资源（数目相对固定）和可消耗性资源（生产创建，消费消耗） 可抢占性资源（处理机）和不可抢占性资源（打印机） 死锁产生原因 竞争不可抢占性资源 竞争可消耗性资源 进程推进顺序不当 如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件，那么该组进程是死锁的。 产生死锁的必要条件 互斥条件（Mutual Exclusion） 资源要求互斥访问 请求和保持条件（Hold and wait） 提出的请求得不到满足，手头的资源释放不出来 不可抢占条件（No preemption） 资源只能由占有者资源释放 循环等待条件（Circular wait） 必有一个进程-资源的环形链，环路中的进程形成等待链 处理死锁的方法 不让死锁发生 预防死锁：静态策略，破坏死锁产生的必要条件 避免死锁：动态策略，不限制必要条件，而去防止系统进入不安全状态（银行家算法） 让死锁发生 检测死锁：通过检测机构及时发现死锁，再采取措施（资源分配图） 解除死锁：当死锁发生，撤销一些进程，回收资源再分配 预防死锁 破坏四个必要条件之一 “互斥条件”是设备的固有属性，应加以保证，不能被破坏 破坏“请求和保持”条件：进程在中间不会请求新的资源，所有进程在开始前必须一次性申请所需全部资源 简单、安全、易于实现 资源浪费严重 进程延迟运行 破坏“不可抢占”条件：（不可抢占→可抢占）进程逐个申请资源；一旦进程申请的新资源不能得到满足时，必须放弃自己所有已有的资源。 实现复杂、代价高昂 延长了进程的周转时间，增加系统开销、降低系统吞吐量 破坏“循环等待”条件：资源按类型分配序号并排队；规定每个进程必须按序号递增的顺序请求资源（而不按自己的使用顺序） 避免死锁 实质：确保系统不进入不安全状态 避免死锁与预防死锁的区别 预防死锁对进程的资源申请命令施加限制（规定死的） 避免死锁在进程请求分配资源时进行动态检查，并根据检查结果决定分配 安全状态与安全序列 安全状态：系统能按某种进程推进顺序（$P_1,P_2,…,P_n$）为每个进程 $P_i$ 分配其所需资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利完成。 此时（$P_1,P_2,…,P_n$）为安全序列。 若不存在安全序列，则称为不安全状态。 只要处于安全状态，不定不会死锁 处于不安全状态，也不一定会发生死锁 发生死锁了，就一定处于不安全状态 ==银行家算法避免死锁== 四个数据结构 可利用资源向量 Available 一个数组，记录每类资源剩余的量，初始值为每个资源的总量 最大需求矩阵 Max 每一类进程所需的每一类资源总数 纵资源类型，横坐标进程类型 分配矩阵 Allocation 每一类进程的资源数已分配到的每一类资源量 需求矩阵 Need 每一类进程还需要的每一类资源数 Need[i,j] = Max[i,j] - Allocation[i,j] 其他 Request_i[j] = k：进程 P~i~ 申请 R~j~ 资源 k 个 银行家算法 两个判断 -\u003e 试分配 -\u003e 安全性检查 if Request_i[j] \u003c= Need[i,j]，便转向步骤 2；否则认为出错。 if Request_i[j] \u003c= Available[j]，便转向步骤 3；否则表示尚无足够资源，$P_i$ 须等待。 系统试探着把资源分配给进程 $P_i$，并修改下面数据结构中的数值： Available[j] = Available[j] - Request_i[j]; Allocation[i,j]=Allocation[i,j]+Request_i[j]; Need[i,j]=Need[i,j]-Request_i[j]; 系统执行安全性算法，检查此次资源分配后系统是否处于安全状态 若安全才正式将资源分配 给进程 $P_i$ 否则作废，恢复原来的资源分配状态 安全性算法 设置两个向量： 工作向量 Work，表示系统可提供给进程继续运行所需的各类资源数目，初始化 Work=Available Finish，表示系统是否有足够的资源分配给进程，使之运行完成。开始时 Finish[i]=false；当有足够资源分配给进程时，Finish[i]=true 从进程集合中找到一个能满足下述条件的进程 Finish[i]=false \u0026\u0026 Need[i,j]≤Work[j] 若找到，执行步骤 3，否则执行 4 当进程 $P_i$ 获得资源后，可顺利执行，直至完成，并释放出分配给它的资源，故应执行： Work[j] = Work[j] + Allocation[i,j]; Finish[i] = true; go to step 2 如果所有进程的 Finish[i] == true 都满足，则表示系统处于安全状态。 步骤 2 中所有类型的资源都要被判断，步骤 3 中所有类型的资源都要被释放，使用循环 不足 对资源分配保守 计算多 一些情况下缺乏实用性（进程对资源的需求动态、进程数量不确定） ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:3:4","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["专业课"],"content":"死锁的检测与解除 死锁检测 资源分配图 （Resource Allocation Graph） 若不存在环路，则必然不存在死锁 死锁定理 从既不阻塞又非独立的进程结点开始简化：消去请求边和分配边 将请求边转换为分配边（如果可以的话） S 为死锁状态的充分条件是：当且仅当 S 状态的资源分配图是不可完全简化的 死锁检测的数据结构 类似银行家算法的数据结构 可利用资源向量 Available 不占用资源的进程（Allocation == 0）记入 L 表 从进程集合中找到一个 Request_i \u003c= Work 的进程 将其资源分配图简化 释放资源 增加工作向量 Work += Allocation 记入 L 表 若不能把所有进程都计入 L 表 -\u003e 状态 S 资源分配图不能被完全简化 -\u003e 死锁 死锁解除 抢占资源（剥夺资源） 从其他进程剥夺资源给死锁进程 终止（或撤销）进程 撤销所有死锁进程 按照某种资源逐个撤销代价最小的进程，直至资源可用 ","date":"0001-01-01","objectID":"/Notes/posts/courses/operating-system/operatingsystem1/:3:5","tags":["OS"],"title":"操作系统（1）","uri":"/Notes/posts/courses/operating-system/operatingsystem1/"},{"categories":["Golang"],"content":"runtime/pprof ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:0:0","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"简介 benchmark (基准测试) 可以度量某个函数或方法的性能，也就是说，如果我们知道性能的瓶颈点在哪里，benchmark 是一个非常好的方式。但是面对一个未知的程序，如何去分析这个程序的性能，并找到瓶颈点呢？ pprof 就是用来解决这个问题的。pprof 包含两部分： 编译到程序中的 runtime/pprof 包 性能剖析工具 go tool pprof ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:1:0","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"pprof 使用模式 Report generation：报告生成 Interactive terminal use：交互式终端 Web interface：Web 界面 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:1:1","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"使用方法 第一种，在 go 程序中添加如下代码： // 开启 cpu 采集分析： pprof.StartCPUProfile(w io.Writer) // 停止 cpu 采集分析： pprof.StopCPUProfile() StartCPUProfile 为当前 process 开启 CPU profiling 。 StopCPUProfile 停止当前的 CPU profile。当所有的 profile 写完了后它才返回。 WriteHeapProfile 把内存 heap 相关的内容写入到文件中 pprof.WriteHeapProfile(w io.Writer) 第二种，在 benchmark 测试的时候 go test -cpuprofile cpu.prof -memprofile mem.prof -bench . 第三种，对 http server 采集数据 go tool pprof $host/debug/pprof/profile ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:1:2","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"命令 go tool pprof XXX.pprof go tool pprof 简单的使用格式为：go tool pprof [binary] [source] binary： 是应用的二进制文件，用来解析各种符号 source： 表示 profile 数据的来源，可以是本地的文件，也可以是 http 地址 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:1:3","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"分析 命令行交互分析 go tool pprof XXX.pprof 字段 说明 Type： 分析类型，这里是 cpu Duration： 程序执行的时长 Duration 下面还有一行提示，这是交互模式（通过输入 help 获取帮助信息，输入 o 获取选项信息）。 可以看出，go 的 pprof 操作还有很多其他命令。 top top 命令：对函数的 cpu 耗时和百分比排序后输出 字段 说明 flat 当前函数占用 cpu 耗时 flat % 当前函数占用 cpu 耗时百分比 sum% 函数占用 cpu 时间累积占比，从小到大一直累积到 100% cum 当前函数加上调用当前函数的函数占用 cpu 的总耗时 %cum 当前函数加上调用当前函数的函数占用 cpu 的总耗时占比 可以在 top 后添加数字，如 top15 list list 命令：可以列出函数最耗时的代码部分，格式：list 函数名 命令行下直接输出分析数据 在命令行直接输出数据，基本命令格式为： Copygo tool pprof \u003cformat\u003e [options] [binary] \u003csource\u003e 输入命令：go tool pprof -text cpu.pprof ，输出： 可视化分析 图形化分析前，先要安装 graphviz 软件， 下载地址：graphviz 地址， 下载对应的平台安装包，安装完成后，把执行文件 bin 放入 Path 环境变量中，然后在终端输入 dot -version 命令查看是否安装成功 go tool pprof -http :8080 XXX.pprof 或者进入命令行交互界面输入 web 命令，即可打开一张图片 每个框代表一个函数，理论上框越大表示占用的 cpu 资源越多 每个框之间的线条代表函数之间的调用关系，线条上的数字表示函数调用的次数 每个框中第一行数字表示当前函数占用 cpu 的百分比，第二行数字表示当前函数累计占用 cpu 的百分比 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:1:4","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"性能分析类型 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:2:0","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"CPU 性能分析 CPU 性能分析 (CPU profiling) 是最常见的性能分析类型。 启动 CPU 分析时，运行时 (runtime) 将每隔 10ms 中断一次，记录此时正在运行的协程 (goroutines) 的堆栈信息。 程序运行结束后，可以分析记录的数据找到最热代码路径 (hottest code paths)。 Compiler hot paths are code execution paths in the compiler in which most of the execution time is spent, and which are potentially executed very often. – What’s the meaning of “hot codepath” 一个函数在性能分析数据中出现的次数越多，说明执行该函数的代码路径 (code path) 花费的时间占总运行时间的比重越大。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:2:1","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"内存性能分析 内存性能分析 (Memory profiling) 记录堆内存分配时的堆栈信息，忽略栈内存分配信息。 内存性能分析启用时，默认每 1000 次采样 1 次，这个比例是可以调整的。因为内存性能分析是基于采样的，因此基于内存分析数据来判断程序所有的内存使用情况是很困难的。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:2:2","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"阻塞性能分析 阻塞性能分析 (block profiling) 是 Go 特有的。 阻塞性能分析用来记录一个协程等待一个共享资源花费的时间。在判断程序的并发瓶颈时会很有用。阻塞的场景包括： 在没有缓冲区的信道上发送或接收数据。 从空的信道上接收数据，或发送数据到满的信道上。 尝试获得一个已经被其他协程锁住的排它锁。 一般情况下，当所有的 CPU 和内存瓶颈解决后，才会考虑这一类分析。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:2:3","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"锁性能分析 锁性能分析 (mutex profiling) 与阻塞分析类似，但专注于因为锁竞争导致的等待或延时。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:2:4","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"CPU 性能分析 记录性能数据会对程序的性能产生影响，建议一次只记录一类数据。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:3:0","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"生成 profile Go 的运行时性能分析接口都位于 runtime/pprof 包中。只需要调用 runtime/pprof 库即可得到我们想要的数据。 假设我们实现了这么一个程序，随机生成了 5 组数据，并且使用冒泡排序法排序。 // main.go package main import ( \"math/rand\" \"time\" ) func generate(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func bubbleSort(nums []int) { for i := 0; i \u003c len(nums); i++ { for j := 1; j \u003c len(nums)-i; j++ { if nums[j] \u003c nums[j-1] { nums[j], nums[j-1] = nums[j-1], nums[j] } } } } func main() { n := 10 for i := 0; i \u003c 5; i++ { nums := generate(n) bubbleSort(nums) n *= 10 } } 如果我们想度量这个应用程序的 CPU 性能数据，只需要在 main 函数中添加 2 行代码即可： import ( \"math/rand\" \"os\" \"runtime/pprof\" \"time\" ) func main() { pprof.StartCPUProfile(os.Stdout) defer pprof.StopCPUProfile() n := 10 for i := 0; i \u003c 5; i++ { nums := generate(n) bubbleSort(nums) n *= 10 } } 为了简单，直接将数据输出到标准输出 os.Stdout。运行该程序，将输出定向到文件 cpu.pprof 中。 $ go run main.go \u003e cpu.pprof 一般来说，不建议将结果直接输出到标准输出，因为如果程序本身有输出，则会相互干扰，直接记录到一个文件中是最好的方式。 func main() { f, _ := os.OpenFile(\"cpu.pprof\", os.O_CREATE|os.O_RDWR, 0644) defer f.Close() pprof.StartCPUProfile(f) defer pprof.StopCPUProfile() n := 10 for i := 0; i \u003c 5; i++ { nums := generate(n) bubbleSort(nums) n *= 10 } } 这样只需运行 go run main.go 即可。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:3:1","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"分析数据 接下来，可以用 go tool pprof 分析这份数据 $ go tool pprof -http=:9999 cpu.pprof 如果提示 Graphviz 没有安装，则通过 brew install graphviz(MAC) 或 apt install graphviz (Ubuntu) 即可。 访问 localhost:9999，可以看到这样的页面： 除了在网页中查看分析数据外，我们也可以在命令行中使用交互模式查看。 $ go tool pprof cpu.pprof File: main Type: cpu Time: Nov 19, 2020 at 1:43am (CST) Duration: 16.42s, Total samples = 14.26s (86.83%) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top Showing nodes accounting for 14.14s, 99.16% of 14.26s total Dropped 34 nodes (cum \u003c= 0.07s) flat flat% sum% cum cum% 14.14s 99.16% 99.16% 14.17s 99.37% main.bubbleSort 0 0% 99.16% 14.17s 99.37% main.main 0 0% 99.16% 14.17s 99.37% runtime.main 可以看到 main.bubbleSort 是消耗 CPU 最多的函数。 还可以按照 cum (累计消耗)排序： (pprof) top --cum Showing nodes accounting for 14.14s, 99.16% of 14.26s total Dropped 34 nodes (cum \u003c= 0.07s) flat flat% sum% cum cum% 14.14s 99.16% 99.16% 14.17s 99.37% main.bubbleSort 0 0% 99.16% 14.17s 99.37% main.main 0 0% 99.16% 14.17s 99.37% runtime.main help 可以查看所有支持的命令和选项： (pprof) help Commands: callgrind Outputs a graph in callgrind format comments Output all profile comments disasm Output assembly listings annotated with samples dot Outputs a graph in DOT format eog Visualize graph through eog evince Visualize graph through evince gif Outputs a graph image in GIF format gv Visualize graph through gv ...... ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:3:2","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"内存性能分析 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:4:0","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"生成 profile 假设我们实现了这么一个程序，生成长度为 N 的随机字符串，拼接在一起。 package main import ( \"github.com/pkg/profile\" \"math/rand\" ) const letterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } func concat(n int) string { s := \"\" for i := 0; i \u003c n; i++ { s += randomString(n) } return s } func main() { defer profile.Start(profile.MemProfile, profile.MemProfileRate(1)).Stop() concat(100) } 接下来，我们使用一个易用性更强的库 pkg/profile 来采集性能数据，pkg/profile 封装了 runtime/pprof 的接口，使用起来更简单。 比如我们想度量 concat() 的 CPU 性能数据，只需要一行代码即可生成 profile 文件。 import ( \"github.com/pkg/profile\" ) func main() { defer profile.Start().Stop() concat(100) } 运行 go run main.go： $ go run main.go 2020/11/22 18:38:29 profile: cpu profiling enabled, /tmp/profile068616584/cpu.pprof 2020/11/22 18:39:12 profile: cpu profiling disabled, /tmp/profile068616584/cpu.pprof CPU profile 文件已经在 tmp 目录生成，得到 profile 文件后，就可以像之前一样，用 go tool pprof 命令，在浏览器或命令行进行分析了。 接下来将使用类似的方式，进行采集内存数据，同样地，只需简单地修改 main 函数即可。 func main() { defer profile.Start(profile.MemProfile, profile.MemProfileRate(1)).Stop() concat(100) } 运行 go run main.go: $ go run main.go 2020/11/22 18:59:04 profile: memory profiling enabled (rate 1), /tmp/profile215959616/mem.pprof 2020/11/22 18:59:04 profile: memory profiling disabled, /tmp/profile215959616/mem.pprof ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:4:1","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"分析数据 接下来，我们在浏览器中分析内存性能数据： go tool pprof -http=:9999 /tmp/profile215959616/mem.pprof 从这张图中，我们可以看到 concat 消耗了 524k 内存，randomString 仅消耗了 22k 内存。 理论上，concat 函数仅仅是将 randomString 生成的字符串拼接起来，消耗的内存应该和 randomString 一致，但怎么会产生 20 倍的差异呢？这和 Go 语言字符串内存分配的方式有关系。 字符串是不可变的，因为将两个字符串拼接时，相当于是产生新的字符串，如果当前的空间不足以容纳新的字符串，则会申请更大的空间，将新字符串完全拷贝过去，这消耗了 2 倍的内存空间。在这 100 次拼接的过程中，会产生多次字符串拷贝，从而消耗大量的内存。 那有什么好的方式呢？使用 strings.Builder 替换 + 进行字符串拼接，将有效地降低内存消耗。 func concat(n int) string { var s strings.Builder for i := 0; i \u003c n; i++ { s.WriteString(randomString(n)) } return s.String() } 接下来，重新运行 go run main.go： $ go run main.go 2020/11/22 19:17:55 profile: memory profiling enabled (rate 1), /tmp/profile061547314/mem.pprof 2020/11/22 19:17:55 profile: memory profiling disabled, /tmp/profile061547314/mem.pprof 使用交互模式，查看内存消耗情况： $ go tool pprof /tmp/profile061547314/mem.pprof File: main Type: inuse_space Time: Nov 22, 2020 at 7:17pm (CST) Entering interactive mode (type \"help\" for commands, \"o\" for options) (pprof) top --cum Showing nodes accounting for 71.22kB, 89.01% of 80.01kB total Dropped 25 nodes (cum \u003c= 0.40kB) Showing top 10 nodes out of 50 flat flat% sum% cum cum% 0 0% 0% 71.88kB 89.84% main.main 0 0% 0% 71.88kB 89.84% runtime.main 0 0% 0% 67.64kB 84.54% main.concat 45.77kB 57.20% 57.20% 45.77kB 57.20% strings.(*Builder).WriteString 21.88kB 27.34% 84.54% 21.88kB 27.34% main.randomString 可以看到，使用 strings.Builder 后，concat 内存消耗降为了原来的 1/8 。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:4:2","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"benchmark 生成 profile 除了直接在命令行中查看测试的结果外，也可以生成 profile 文件，使用 go tool pprof 分析。 testing 支持生成 CPU、memory 和 block 的 profile 文件。 -cpuprofile=$FILE -memprofile=$FILE, -memprofilerate=N 调整记录速率为原来的 1/N。 -blockprofile=$FILE 在介绍 benchmark 如何使用，我们举了下面这个例子： func fib(n int) int { if n == 0 || n == 1 { return n } return fib(n-2) + fib(n-1) } func BenchmarkFib(b *testing.B) { for n := 0; n \u003c b.N; n++ { fib(30) // run fib(30) b.N times } } 只需要在 go test 添加 -cpuprofile 参数即可生成 BenchmarkFib 对应的 CPU profile 文件： $ go test -cpuprofile cpu.prof -memprofile mem.prof -bench . goos: linux goarch: amd64 pkg: example BenchmarkFib-8 196 6071636 ns/op PASS ok example 2.046s 用例执行完毕后，当前目录多出了一个 cpu.pprof 文件，接下来就可以使用 go tool pprof 命令进行分析了。 使用 -text 选项可以直接将结果以文本形式打印出来。 $ go tool pprof -text cpu.pprof File: example.test Type: cpu Time: Nov 22, 2020 at 7:52pm (CST) Duration: 2.01s, Total samples = 1.77s (87.96%) Showing nodes accounting for 1.77s, 100% of 1.77s total flat flat% sum% cum cum% 1.76s 99.44% 99.44% 1.76s 99.44% example.fib 0.01s 0.56% 100% 0.01s 0.56% runtime.futex 0 0% 100% 1.76s 99.44% example.BenchmarkFib 0 0% 100% 0.01s 0.56% runtime.findrunnable pprof 支持多种输出格式（图片、文本、Web等），直接在命令行中运行 go tool pprof 即可看到所有支持的选项： $ go tool pprof Details: Output formats (select at most one): -dot Outputs a graph in DOT format -png Outputs a graph image in PNG format -text Outputs top entries in text form -tree Outputs a text rendering of call graph -web Visualize graph through web browser ... ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/:5:0","tags":["Go 库"],"title":"Go runtime/pprof库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/"},{"categories":["Golang"],"content":"Go 高性能编程 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/:0:0","tags":["进阶"],"title":"Go 高性能编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"常用数据结构 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/:1:0","tags":["进阶"],"title":"Go 高性能编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"字符串高效拼接 在 Go 语言中，字符串 (string) 是不可变的，拼接字符串事实上是创建了一个新的字符串对象。 如果代码中存在大量的字符串拼接，对性能会产生严重的影响。 常见的拼接方式 为了避免编译器优化，我们首先实现一个生成长度为 n 的随机字符串的函数。 const letterBytes = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" func randomString(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } 然后利用这个函数生成字符串 str，然后将 str 拼接 N 次。在 Go 语言中，常见的字符串拼接方式有如下 5 种： 使用 + func plusConcat(n int, str string) string { s := \"\" for i := 0; i \u003c n; i++ { s += str } return s } 使用 fmt.Sprintf func sprintfConcat(n int, str string) string { s := \"\" for i := 0; i \u003c n; i++ { s = fmt.Sprintf(\"%s%s\", s, str) } return s } 使用 strings.Builder func builderConcat(n int, str string) string { var builder strings.Builder for i := 0; i \u003c n; i++ { builder.WriteString(str) } return builder.String() } 使用 bytes.Buffer func bufferConcat(n int, s string) string { buf := new(bytes.Buffer) for i := 0; i \u003c n; i++ { buf.WriteString(s) } return buf.String() } 使用 []byte func byteConcat(n int, str string) string { buf := make([]byte, 0) for i := 0; i \u003c n; i++ { buf = append(buf, str...) } return string(buf) } 如果长度是可预知的，那么创建 []byte 时，我们还可以预分配切片的容量(cap)。 func preByteConcat(n int, str string) string { buf := make([]byte, 0, n*len(str)) for i := 0; i \u003c n; i++ { buf = append(buf, str...) } return string(buf) } make([]byte, 0, n*len(str)) 第二个参数是长度，第三个参数是容量 (cap)，切片创建时，将预分配 cap 大小的内存。 benchmark 性能比拼 每个 benchmark 用例中，生成了一个长度为 10 的字符串，并拼接 1w 次。 func benchmark(b *testing.B, f func(int, string) string) { var str = randomString(10) for i := 0; i \u003c b.N; i++ { f(10000, str) } } func BenchmarkPlusConcat(b *testing.B) { benchmark(b, plusConcat) } func BenchmarkSprintfConcat(b *testing.B) { benchmark(b, sprintfConcat) } func BenchmarkBuilderConcat(b *testing.B) { benchmark(b, builderConcat) } func BenchmarkBufferConcat(b *testing.B) { benchmark(b, bufferConcat) } func BenchmarkByteConcat(b *testing.B) { benchmark(b, byteConcat) } func BenchmarkPreByteConcat(b *testing.B) { benchmark(b, preByteConcat) } 运行该用例： $ go test -bench=\"Concat$\" -benchmem . goos: darwin goarch: amd64 pkg: example BenchmarkPlusConcat-8 19 56 ms/op 530 MB/op 10026 allocs/op BenchmarkSprintfConcat-8 10 112 ms/op 835 MB/op 37435 allocs/op BenchmarkBuilderConcat-8 8901 0.13 ms/op 0.5 MB/op 23 allocs/op BenchmarkBufferConcat-8 8130 0.14 ms/op 0.4 MB/op 13 allocs/op BenchmarkByteConcat-8 8984 0.12 ms/op 0.6 MB/op 24 allocs/op BenchmarkPreByteConcat-8 17379 0.07 ms/op 0.2 MB/op 2 allocs/op PASS ok example 8.627s 从基准测试的结果来看，使用 + 和 fmt.Sprintf 的效率是最低的，和其余的方式相比，性能相差约 1000 倍，而且消耗了超过 1000 倍的内存。当然 fmt.Sprintf 通常是用来格式化字符串的，一般不会用来拼接字符串。 strings.Builder、bytes.Buffer 和 []byte 的性能差距不大，而且消耗的内存也十分接近，性能最好且消耗内存最小的是 preByteConcat，这种方式预分配了内存，在字符串拼接的过程中，不需要进行字符串的拷贝，也不需要分配新的内存，因此性能最好，且内存消耗最小。 建议 综合易用性和性能，一般推荐使用 strings.Builder 来拼接字符串。 这是 Go 官方对 strings.Builder 的解释： A Builder is used to efficiently build a string using Write methods. It minimizes memory copying. string.Builder 也提供了预分配内存的方式 Grow： func builderConcat(n int, str string) string { var builder strings.Builder builder.Grow(n * len(str)) for i := 0; i \u003c n; i++ { builder.WriteString(str) } return builder.String() } 使用了 Grow 优化后的版本的 benchmark 结果如下： BenchmarkBuilderConcat-8 16855 0.07 ns/op 0.1 MB/op 1 allocs/op BenchmarkPreByteConcat-8 17379 0.07 ms/op 0.2 MB/op 2 allocs/op 与预分配内存的 []byte 相比，因为省去了 []byte 和字符串 (string) 之间的转换，内存分配次数还减少了 1 次，内存消耗减半。 性能背后的原理 比较 strings.Builder 和 + strings.Builder 和 + 性能和内存消耗差距如此巨大，是因为两者的内存分配方式不一样。 字符串在 Go 语言中是不可变类型，占用内存大小是固定的，当使用 + 拼接 2 个字符串时，生成一个新的字符串，那么就需要开辟一段新的空间，新空间的大小是原来两个字符串的大小之和。拼接第三个字符串时，再开辟一段新空间，新空间大小是三个字符串大小之和，以此类推。 假设一个字符串大小为 10 byte，拼接 1w 次，需要申请的内存大小为： 10 + 2 * 10 + 3 * 10 + ... + 10000 * 10 byte = 500 MB 而 strings.Builder，bytes.Buffer，包括切片 []byte 的内存是以倍数申请的。例如，初始大小为 0，当第一次写入大小为 10 byte 的字符串时，则会申请大小为 16 byte 的内存（恰好大于 10 byte 的 2 的指数），第二次写入 10 byte 时，内存不够，则申请 32 byte 的内存，第三次写入内存足够，则不申请新的，以此类推。在实际过程中，超过一定大小，比如 2048 byte 后，申请策略上会有些许调整。我们可以通过打印 builder.Cap() 查看字符串拼接过程中，strings.Builder 的内存申请过程。 func ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/:1:1","tags":["进阶"],"title":"Go 高性能编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"切片 (slice) 性能及陷阱 切片的本质 在 Go 语言中，切片 (slice) 可能是使用最为频繁的数据结构之一，切片类型为处理同类型数据序列提供一个方便而高效的方式。 数组 Go 的切片 (slice) 是在数组 (array) 之上的抽象数据类型，数组类型定义了长度和元素类型。例如， [3]int 类型表示由 3 个 int 整型组成的数组，数组以索引方式访问，例如表达式 s[n] 访问数组的第 n 个元素。数组的长度是固定的，长度是数组类型的一部分。长度不同的 2 个数组是不可以相互赋值的，因为这 2 个数组属于不同的类型。例如下面的代码是不合法的： a := [3]int{1, 2, 3} b := [4]int{2, 4, 5, 6} a = b // cannot use b (type [4]int) as type [3]int in assignment 在 C 语言中，数组变量是指向第一个元素的指针，但是 Go 语言中并不是。 Go 语言中，数组变量属于值类型(value type)，因此当一个数组变量被赋值或者传递时，实际上会复制整个数组。例如，将 a 赋值给 b，修改 a 中的元素并不会改变 b 中的元素： a := [...]int{1, 2, 3} // ... 会自动计算数组长度 b := a a[0] = 100 fmt.Println(a, b) // [100 2 3] [1 2 3] **为了避免复制数组，一般会传递指向数组的指针。**例如： func square(arr *[3]int) { for i, num := range *arr { (*arr)[i] = num * num } } func TestArrayPointer(t *testing.T) { a := [...]int{1, 2, 3} square(\u0026a) fmt.Println(a) // [1 4 9] if a[1] != 4 \u0026\u0026 a[2] != 9 { t.Fatal(\"failed\") } } 切片 数组固定长度，缺少灵活性，大部分场景下会选择使用基于数组构建的功能更强大，使用更便利的切片类型。 切片使用字面量初始化时和数组很像，但是不需要指定长度： languages := []string{\"Go\", \"Python\", \"C\"} 或者使用内置函数 make 进行初始化，make 的函数定义如下： func make([]T, len, cap) []T 第一个参数是 []T，T 即元素类型，第二个参数是长度 len，即初始化的切片拥有多少个元素，第三个参数是容量 cap，容量是可选参数，默认等于长度。使用内置函数 len 和 cap 可以得到切片的长度和容量，例如： func printLenCap(nums []int) { fmt.Printf(\"len: %d, cap: %d %v\\n\", len(nums), cap(nums), nums) } func TestSliceLenAndCap(t *testing.T) { nums := []int{1} printLenCap(nums) // len: 1, cap: 1 [1] nums = append(nums, 2) printLenCap(nums) // len: 2, cap: 2 [1 2] nums = append(nums, 3) printLenCap(nums) // len: 3, cap: 4 [1 2 3] nums = append(nums, 3) printLenCap(nums) // len: 4, cap: 4 [1 2 3 3] } 容量是当前切片已经预分配的内存能够容纳的元素个数，如果往切片中不断地增加新的元素，超过了当前切片的容量，就需要分配新的内存，并将当前切片所有的元素拷贝到新的内存块上。 因此为了减少内存的拷贝次数，容量在比较小的时候，一般是以 2 的倍数扩大的，例如 2 4 8 16 …，当达到 2048 时，会采取新的策略，避免申请内存过大，导致浪费。Go 语言源代码 runtime/slice.go 中是这么实现的，不同版本可能有所差异： newcap := old.cap doublecap := newcap + newcap if cap \u003e doublecap { newcap = cap // 要分配的长度大于原容量的两倍时 直接分配 } else { if old.len \u003c 1024 { newcap = doublecap // 要分配的长度小于原容量的两倍时 分配两倍 } else { // Check 0 \u003c newcap to detect overflow // and prevent an infinite loop. for 0 \u003c newcap \u0026\u0026 newcap \u003c cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u003c= 0 { newcap = cap } } } 切片和数组很相似，按照下标进行索引。切片本质是一个数组片段的描述，包括了数组的指针，这个片段的长度和容量 (不改变内存分配情况下的最大长度)。 struct { ptr *[]T len int cap int } 切片操作并不复制切片指向的元素，创建一个新的切片会复用原来切片的底层数组，因此切片操作是非常高效的。下面的例子展示了这个过程： nums := make([]int, 0, 8) nums = append(nums, 1, 2, 3, 4, 5) nums2 := nums[2:4] printLenCap(nums) // len: 5, cap: 8 [1 2 3 4 5] printLenCap(nums2) // len: 2, cap: 6 [3 4] nums2 = append(nums2, 50, 60) printLenCap(nums) // len: 5, cap: 8 [1 2 3 4 50] printLenCap(nums2) // len: 4, cap: 6 [3 4 50 60] nums2 执行了一个切片操作 [2, 4)，此时 nums 和 nums2 指向的是同一个数组。 nums2 增加 2 个元素 50 和 60 后，将底层数组下标 [4] 的值改为了 50，下标 [5] 的值置为 60。 因为 nums 和 nums2 指向的是同一个数组，因此 nums 被修改为 [1, 2, 3, 4, 50]。 切片操作及性能 搞清楚切片的本质之后，理解切片的常用操作的性能就容易很多了。 Go 语言在 Github 上的官方 wiki - SliceTricks 介绍了切片常见的操作技巧。另一个项目 Go Slice Tricks Cheat Sheet 将这些操作以图片的形式呈现了出来，非常直观。 Copy Append 切片有三个属性，指针(ptr)、长度(len) 和容量(cap)。append 时有两种场景： 当 append 之后的长度小于等于 cap，将会直接利用原底层数组剩余的空间。 当 append 后的长度大于 cap 时，则会分配一块更大的区域来容纳新的底层数组。 因此，为了避免内存发生拷贝，如果能够知道最终的切片的大小，预先设置 cap 的值能够获得最好的性能。 Delete 切片的底层是数组，因此删除意味着后面的元素需要逐个向前移位。每次删除的复杂度为 O(N)，因此切片不合适大量随机删除的场景，这种场景下适合使用链表。 Delete(GC) 删除后，将空余的位置置空，有助于垃圾回收。 Insert insert 和 append 类似。即在某个位置添加一个元素后，将该位置后面的元素再 append 回去。复杂度为 O(N)。因此，不适合大量随机插入的场景。 Filter 当原切片不会再被使用时，就地 filter 方式是比较推荐的，可以节省内存空间。 Push 在末尾追加元素，不考虑内存拷贝的情况，复杂度为 O(1)。 在头部追加元素，时间和空间复杂度均为 O(N)，不推荐。 Pop 尾部删除元素，复杂度 O(1) 头部删除元素，如果使用切片方式，复杂度为 O(1)。 但是需要注意的是，底层数组没有发生改变，第 0 个位置的内存仍旧没有释放。如果有大量这样的操作，头部的内存会一直被占用。 性能陷阱 大量内存得不到释放 在已有切片的基础上进行切片，不会创建新的底层数组。因为原来的底层数组没有发生变化，内存会一直占用，直到没有变量引用该数组。 因此很可能出现这么一种情况，原切片由大量的元素构成，但是我们在原切片的基础上切片，虽然只使用了很小一段，但底层数组在内存中仍然占据了大量空间，得不到释放。 比较推荐的做法，使用 copy 替代 re-slice。 func lastNumsBySlice(origin []int) []int { return origin[len(origin)-2:] } func lastNumsByCopy(origin []int) []int { result := make([]int, 2) copy(result, origin[len(origin)-2:]) return result ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/:1:2","tags":["进阶"],"title":"Go 高性能编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"for 和 range 的性能比较 range 的简单回顾 Go 语言中，range 可以用来很方便地遍历数组 (array)、切片 (slice)、字典 (map) 和信道 (chan) array/slice words := []string{\"Go\", \"语言\", \"高性能\", \"编程\"} for i, s := range words { words = append(words, \"test\") fmt.Println(i, s) } 输出结果如下： 0 Go 1 语言 2 高性能 3 编程 变量 words 在循环开始前，仅会计算一次，如果在循环中修改切片的长度不会改变本次循环的次数。 迭代过程中，每次迭代的下标和值被赋值给变量 i 和 s，第二个参数 s 是可选的。 针对 nil 切片，迭代次数为 0。 range 还有另一种只遍历下标的写法，这种写法与 for 几乎没什么差异了。 for i := range words { fmt.Println(i, words[i]) } 输出也是一样的： 0 Go 1 语言 2 高性能 3 编程 map m := map[string]int{ \"one\": 1, \"two\": 2, \"three\": 3, } for k, v := range m { delete(m, \"two\") m[\"four\"] = 4 fmt.Printf(\"%v: %v\\n\", k, v) } 输出结果为： one: 1 four: 4 three: 3 和切片不同的是，迭代过程中，删除还未迭代到的键值对，则该键值对不会被迭代。 在迭代过程中，如果创建新的键值对，那么新增键值对，可能被迭代，也可能不会被迭代。 针对 nil 字典，迭代次数为 0 channel ch := make(chan string) go func() { ch \u003c- \"Go\" ch \u003c- \"语言\" ch \u003c- \"高性能\" ch \u003c- \"编程\" close(ch) }() for n := range ch { fmt.Println(n) } 发送给信道 (channel) 的值可以使用 for 循环迭代，直到信道被关闭。 如果是 nil 信道，循环将永远阻塞。 for 和 range 的性能比较 []int func generateWithCap(n int) []int { rand.Seed(time.Now().UnixNano()) nums := make([]int, 0, n) for i := 0; i \u003c n; i++ { nums = append(nums, rand.Int()) } return nums } func BenchmarkForIntSlice(b *testing.B) { nums := generateWithCap(1024 * 1024) for i := 0; i \u003c b.N; i++ { len := len(nums) var tmp int for k := 0; k \u003c len; k++ { tmp = nums[k] } _ = tmp } } func BenchmarkRangeIntSlice(b *testing.B) { nums := generateWithCap(1024 * 1024) for i := 0; i \u003c b.N; i++ { var tmp int for _, num := range nums { tmp = num } _ = tmp } } 运行结果如下： $ go test -bench=IntSlice$ . goos: darwin goarch: amd64 pkg: example/hpg-range BenchmarkForIntSlice-8 3603 324512 ns/op BenchmarkRangeIntSlice-8 3591 322744 ns/op generateWithCap 用于生成长度为 n 元素类型为 int 的切片。 从最终的结果可以看到，遍历 []int 类型的切片，for 与 range 性能几乎没有区别。 []struct 那如果是稍微复杂一点的 []struct 类型呢？ type Item struct { id int val [4096]byte } func BenchmarkForStruct(b *testing.B) { var items [1024]Item for i := 0; i \u003c b.N; i++ { length := len(items) var tmp int for k := 0; k \u003c length; k++ { tmp = items[k].id } _ = tmp } } func BenchmarkRangeIndexStruct(b *testing.B) { var items [1024]Item for i := 0; i \u003c b.N; i++ { var tmp int for k := range items { tmp = items[k].id } _ = tmp } } func BenchmarkRangeStruct(b *testing.B) { var items [1024]Item for i := 0; i \u003c b.N; i++ { var tmp int for _, item := range items { tmp = item.id } _ = tmp } } 先看下 Benchmark 的结果： $ go test -bench=Struct$ . goos: darwin goarch: amd64 pkg: example/hpg-range BenchmarkForStruct-8 3769580 324 ns/op BenchmarkRangeIndexStruct-8 3597555 330 ns/op BenchmarkRangeStruct-8 2194 467411 ns/op 仅遍历下标的情况下，for 和 range 的性能几乎是一样的。 items 的每一个元素的类型是一个结构体类型 Item，Item 由两个字段构成，一个类型是 int，一个是类型是 [4096]byte，也就是说每个 Item 实例需要申请约 4KB 的内存。 在这个例子中，for 的性能大约是 range (同时遍历下标和值) 的 2000 倍。 []int 和 []struct{} 的性能差异 与 for 不同的是，range 对每个迭代值都创建了一个拷贝。因此如果每次迭代的值内存占用很小的情况下，for 和 range 的性能几乎没有差异，但是如果每个迭代值内存占用很大，例如上面的例子中，每个结构体需要占据 4KB 的内存，这种情况下差距就非常明显了。 我们可以用一个非常简单的例子来证明 range 迭代时，返回的是拷贝。 persons := []struct{ no int }{{no: 1}, {no: 2}, {no: 3}} for _, s := range persons { s.no += 10 } for i := 0; i \u003c len(persons); i++ { persons[i].no += 100 } fmt.Println(persons) // [{101} {102} {103}] persons 是一个长度为 3 的切片，每个元素是一个结构体。 使用 range 迭代时，试图将每个结构体的 no 字段增加 10，但修改无效，因为 range 返回的是拷贝。 使用 for 迭代时，将每个结构体的 no 字段增加 100，修改有效。 []*struct{} 那如果切片中是指针，而不是结构体呢？ func generateItems(n int) []*Item { items := make([]*Item, 0, n) for i := 0; i \u003c n; i++ { items = append(items, \u0026Item{id: i}) } return items } func BenchmarkForPointer(b *testing.B) { items := generateItems(1024) for i := 0; i \u003c b.N; i++ { length := len(items) var tmp int for k := 0; k \u003c length; k++ { tmp = items[k].id } _ = tmp } } func BenchmarkRangePointer(b *testing.B) { items := generateItems(1024) for i := 0; i \u003c b.N; i++ { var tmp int for _, item := range items { tmp = item.id } _ = tmp } } 运行结果如下： goos: darwin goarch: amd64 pkg: example/hpg-range BenchmarkForPointer-8 271279 4160 ns/op BenchmarkRangePointer-8 264068 4194 ns/op 切片元素从结构体 Item 替换为指针 *Item 后，for 和 range 的性能几乎是一样的。而且使","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/:1:3","tags":["进阶"],"title":"Go 高性能编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Go 进阶 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:0:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"一些总结 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些种类型的值可以有间接底层部分？ 在 Go 中，下列种类的类型的值可以有间接底层部分： 字符串类型 函数类型 切片类型 映射类型 通道类型 接口类型 注意：此答案基于标准编译器的实现。事实上，函数类型的值是否有间接底层部分是难以证明的。 另外，字符串和接口类型的值在逻辑上应该被认为是不含间接底层部分。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些种类型的值可以用做内置 len（以及 cap、close、delete 和 make）函数调用的实参？ len cap close delete make 字符串值 可以 数组或者数组指针值 可以 可以 切片值 可以 可以 可以 映射值 可以 可以 可以 通道值 可以 可以 可以 可以 可以被用做内置函数 len 调用的参数的值的类型都可以被称为（广义上的）容器类型。 这些容器类型的值都可以跟在 for-range 循环的 range 关键字后。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"各种容器类型比较 类型 容器值是否支持添加新的元素？ 容器值中的元素是否可以被替换？ 容器值中的元素是否可寻址？ 访问容器值元素是否会更改容器长度？ 容器值是否可以有间接底层部分？ 字符串 否 否 否 否 是(1) 数组 否 是(2) 是(2) 否 否 切片 否(3) 是 是 否 是 映射 是 是 否 否 是 通道 是(4) 否 否 是 是 (1) 对于标准编译器和运行时来说。 (2) 对于可寻址的数组值来说。 (3) 一般说来，一个切片的长度只能通过将另外一个切片赋值给它来被整体替换修改，这里我们不视这种情况为“添加新的元素”。 其实，切片的长度也可以通过调用 reflect.SetLen 来单独修改。增加切片的长度可以看作是一种变相的向切片添加元素。 但reflect.SetLen函数的效率很低，因此很少使用。 (4) 对于带缓冲并且缓冲未满的通道来说。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些种类型的值可以用组合字面量（T{...}）表示？ 下面在四种类型的值（除了切片和映射类型的零值）可以用组合字面量表示。 类型（T） T{}是类型T的零值？ 结构体类型 是 数组类型 是 切片类型 否 （零值用nil表示） 映射类型 否 （零值用nil表示） ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:4","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"各种类型的尺寸 详见值复制成本一文。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:5","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些种类型的零值使用预声明的nil标识符表示？ 下面这些类型的零值可以用预声明的nil标识符表示。 类型（T） T(nil)的尺寸 指针 1 word 切片 3 words 映射 1 word 通道 1 word 函数 1 word 接口 2 words 上表列出的尺寸为标准编译器的结果。 一个word（原生字）在32位的架构中为4个字节，在64位的架构中为8个字节。 一个Go值的间接底层部分未统计在尺寸中。 一个类型的零值的尺寸和其它非零值的尺寸是一致的。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:6","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"我们可以为什么样的类型声明方法？ 详见方法一文。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:7","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"什么样的类型可以被内嵌在结构体类型中？ 详见类型内嵌一文。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:8","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些函数调用将在编译时刻被估值？ 如果一个函数调用在编译时刻被估值，则估值结果为一个常量。 函数 返回类型 其调用是否总是在编译时刻估值？ unsafe.Sizeof uintptr 是 unsafe.Alignof unsafe.Offsetof len int 否 Go语言白皮书中提到：如果表达式s表示一个字符串常量，则表达式len(s)将在编译时刻估值；如果表达式s表示一个数组或者数组的指针，并且s中不含有数据接收操作和估值结果为非常量的函数调用，则表达式len(s)和cap(s)将在编译时刻估值。 cap real 默认类型为 float64 （结果为类型不确定值） 否 Go语言白皮书提到： 表达式real(s)和imag(s)在s为一个复数常量表达式时才在编译时刻估值。 imag complex 默认类型为 complex128 （结果为类型不确定值） 否 Go语言白皮书提到： 表达式complex(sr, si)只有在sr和si都为常量表达式的时候才在编译时刻估值。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:9","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些值是可寻址的？ 请阅读此条问答获取详情。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:10","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些类型不支持比较？ 请阅读此条问答获取详情。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:11","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些代码元素允许被声明却不使用？ 允许被声明却不使用？ 包引入 不允许 类型 允许 变量 包级全局变量允许，但局部变量不允许（对于官方标准编译器）。 常量 允许 函数 允许 跳转标签 不允许 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:12","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些有名代码元素可多个被一起声明在一对小括号()中？ 下面这些同种类的代码元素可多个被一起声明在一对小括号()中： 包引入 类型 变量 常量 函数是不能多个被一起声明在一对小括号()中的。跳转标签也不能。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:13","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些代码元素的声明可以被声明在函数内也可以被声明在函数外？ 下面这些代码元素的声明既可以被声明在函数内也可以被声明在函数外： 类型 变量 常量 包引入必须被声明在其它种类的代码元素的声明之前。 函数必须声明在任何函数体之外。匿名函数可以定义在函数体内，但那不属于声明。 跳转标签必须声明在函数体内。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:14","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"哪些表达式的估值结果可以包含一个额外的可选的值？ 下列表达式的估值结果可以包含一个额外的可选的值： 语法 额外的可选的值（语法示例中的ok）的含义 舍弃额外的可选的值会对估值行为发生影响吗？ 映射元素访问 e, ok = aMap[key] 键值key对应的条目是否存储在映射值中 否 数据接收 e, ok = \u003c- aChannel 被接收到的值e是否是在通道关闭之前发送的 否 类型断言 v, ok = anInterface.(T) 接口值的动态类型是否为类型T 是 （当可选的值被舍弃并且断言失败的时候，将产生一个恐慌。） ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:15","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"几种导致当前协程永久阻塞的方法 无需引入任何包，我们可以使用下面几种方法使当前协程永久阻塞： 向一个永不会被接收数据的通道发送数据。 make(chan struct{}) \u003c- struct{}{} // 或者 make(chan\u003c- struct{}) \u003c- struct{}{} 从一个未被并且将来也不会被发送数据的（并且保证永不会被关闭的）通道读取数据。 \u003c-make(chan struct{}) // 或者 \u003c-make(\u003c-chan struct{}) // 或者 for range make(\u003c-chan struct{}) {} 从一个nil通道读取或者发送数据。 chan struct{}(nil) \u003c- struct{}{} // 或者 \u003c-chan struct{}(nil) // 或者 for range chan struct{}(nil) {} 使用一个不含任何分支的 select 流程控制代码块。 select{} ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:16","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"几种衔接字符串的方法 详见字符串一文。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:17","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"官方标准编译器中实现的一些优化 详见Go语言101维基中的一文。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:18","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"在Go程序运行中将会产生恐慌或者崩溃的情形 详见Go语言101维基中的一文。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:1:19","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"内存对齐 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:2:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"引入 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？ func main() { fmt.Printf(\"bool size: %d\\n\", unsafe.Sizeof(bool(true))) fmt.Printf(\"int32 size: %d\\n\", unsafe.Sizeof(int32(0))) fmt.Printf(\"int8 size: %d\\n\", unsafe.Sizeof(int8(0))) fmt.Printf(\"int64 size: %d\\n\", unsafe.Sizeof(int64(0))) fmt.Printf(\"byte size: %d\\n\", unsafe.Sizeof(byte(0))) fmt.Printf(\"string size: %d\\n\", unsafe.Sizeof(\"EDDYCJY\")) } 输出结果： bool size: 1 int32 size: 4 int8 size: 1 int64 size: 8 byte size: 1 string size: 16 这么一算，Part1 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病 真实情况是怎么样的呢？我们实际调用看看，如下： type Part1 struct { a bool b int32 c int8 d int64 e byte } func main() { part1 := Part1{} fmt.Printf(\"part1 size: %d, align: %d\\n\", unsafe.Sizeof(part1), unsafe.Alignof(part1)) } 输出结果： part1 size: 32, align: 8 最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。 在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:2:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"定义 有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放 上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。 相反 CPU 读取内存是一块一块读取的，块的大小可以为 2、4、6、8、16 字节等大小。 块大小我们称其为内存访问粒度。如下图： 在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势 例 在上图中，假设从 Index1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下： CPU 首次读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0 CPU 再次读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节 合并 1-4 字节的数据 合并后放入寄存器 从上述流程可得出，不做 “内存对齐” 是一件有点 “麻烦” 的事。因为它会增加许多耗费时间的动作。 而假设做了内存对齐，从 Index0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的空间换时间做法。 为什么要关心对齐 你正在编写的代码在性能（CPU、Memory）方面有一定的要求 你正在处理向量方面的指令 某些硬件平台（ARM）体系不支持未对齐的内存访问 另外作为一个工程师，你也很有必要学习这块知识点哦 :) 为什么要做对齐 平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况 性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:2:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"默认系数 在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 #pragma pack(n) 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下： 32 位：4 64 位：8 另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑 类型的对称系数 在 Go 中可以调用 unsafe.Alignof 来返回相应类型的对齐系数。 func main() { fmt.Printf(\"bool align: %d\\n\", unsafe.Alignof(bool(true))) fmt.Printf(\"int32 align: %d\\n\", unsafe.Alignof(int32(0))) fmt.Printf(\"int8 align: %d\\n\", unsafe.Alignof(int8(0))) fmt.Printf(\"int64 align: %d\\n\", unsafe.Alignof(int64(0))) fmt.Printf(\"byte align: %d\\n\", unsafe.Alignof(byte(0))) fmt.Printf(\"string align: %d\\n\", unsafe.Alignof(\"EDDYCJY\")) fmt.Printf(\"map align: %d\\n\", unsafe.Alignof(map[string]string{})) } bool align: 1 int32 align: 4 int8 align: 1 int64 align: 8 byte align: 1 string align: 8 map align: 8 通过观察输出结果，可得知基本都是 2^n，最大也不会超过 8。这是因为当前测试（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:2:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"结构体的整体对齐 在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的 对齐规则 结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（#pragma pack(n)）或当前成员变量类型的长度（unsafe.Sizeof），取最小值作为当前类型的对齐值，其偏移量必须为对齐值的整数倍 结构体本身，对齐值必须为编译器默认对齐长度（#pragma pack(n)）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值 结合以上两点，可得知若编译器默认对齐长度（#pragma pack(n)）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的 分析流程 变量对齐 第一个成员 a 类型为 bool 大小/对齐值为 1 字节 初始地址，偏移量为 0。占用了第 1 位 第二个成员 b 类型为 int32 大小/对齐值为 4 字节 根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb 第三个成员 c 类型为 int8 大小/对齐值为 1 字节 根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c… 第四个成员 d 类型为 int64 大小/对齐值为 8 字节 根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此 9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd 第五个成员 e 类型为 byte 大小/对齐值为 1 字节 根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e… 整体对齐 在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 2^n，不是偶数倍。显然不符合对齐的规则 根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐 axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:2:4","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"调整字段顺序来优化内存 在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 :-) type Part1 struct { a bool b int32 c int8 d int64 e byte } type Part2 struct { e byte c int8 a bool b int32 d int64 } func main() { part1 := Part1{} part2 := Part2{} fmt.Printf(\"part1 size: %d, align: %d\\n\", unsafe.Sizeof(part1), unsafe.Alignof(part1)) fmt.Printf(\"part2 size: %d, align: %d\\n\", unsafe.Sizeof(part2), unsafe.Alignof(part2)) } part1 size: 32, align: 8 part2 size: 16, align: 8 通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小 Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx Part2 内存布局：ecax|bbbb|dddd|dddd 通过调整结构体内成员变量的字段顺序可以达到缩小结构体占用大小的的效果，因为它巧妙地减少了 Padding 的存在，让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮助。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:2:5","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"边界检查消除 Go 是一个内存安全的语言。在数组和切片的索引和子切片操作中，Go 运行时将检查操作中使用的下标是否越界。 如果下标越界，一个恐慌将产生，以防止这样的操作破坏内存安全。这样的检查称为边界检查。 边界检查使得我们的代码能够安全地运行；但是另一方面，也使得我们的代码运行效率略微降低。 从 Go 官方工具链 1.7 开始，官方标准编译器使用了一个新的基于 SSA（single-assignment form，静态单赋值形式）的后端。 SSA 使得 Go 编译器可以有效利用诸如 BCE（bounds check elimination，边界检查消除）和 CSE（common subexpression elimination，公共子表达式消除）等优化： BCE 可以避免很多不必要的边界检查 CSE 可以避免很多重复表达式的计算，从而使得编译器编译出的程序执行效率更高。 有时候这些优化的效果非常明显。 本文将展示一些例子来解释边界检查消除在官方标准编译器 1.7+ 中的表现。 对于 Go 官方工具链 1.7+，我们可以使用编译器选项 -gcflags=\"-d=ssa/check_bce/debug=1\" 来列出哪些代码行仍然需要边界检查。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"例子 1 // example1.go package main func f1(s []int) { _ = s[0] // 第5行： 需要边界检查 _ = s[1] // 第6行： 需要边界检查 _ = s[2] // 第7行： 需要边界检查 } func f2(s []int) { _ = s[2] // 第11行： 需要边界检查 _ = s[1] // 第12行： 边界检查消除了！ _ = s[0] // 第13行： 边界检查消除了！ } func f3(s []int, index int) { _ = s[index] // 第17行： 需要边界检查 _ = s[index] // 第18行： 边界检查消除了！ } func f4(a [5]int) { _ = a[4] // 第22行： 边界检查消除了！ } func main() {} $ go run -gcflags=\"-d=ssa/check_bce/debug=1\" example1.go ./example1.go:5: Found IsInBounds ./example1.go:6: Found IsInBounds ./example1.go:7: Found IsInBounds ./example1.go:11: Found IsInBounds ./example1.go:17: Found IsInBounds 我们可以看到函数 f2 中的第 12 行和第 13 行不再需要边界检查了，因为第 11 行的检查确保了第 12 行和第 13 行中使用的下标肯定不会越界。 但是，函数 f1 中的三行仍然都需要边界检查，因为第 5 行中的边界检查不能保证第 6 行和第 7 行中的下标没有越界，第 6 行中的边界检查也不能保证第第 7 行中的下标没有越界。 在函数 f3 中，编译器知道如果第一个 s[index] 是安全的，则第二个 s[index] 是无需边界检查的。 编译器也正确地认为函数 f4 中的唯一一行（第 22 行）是无需边界检查的。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"例子 2 // example2.go package main func f5(s []int) { for i := range s { _ = s[i] _ = s[i:len(s)] _ = s[:i+1] } } func f6(s []int) { for i := 0; i \u003c len(s); i++ { _ = s[i] _ = s[i:len(s)] _ = s[:i+1] } } func f7(s []int) { for i := len(s) - 1; i \u003e= 0; i-- { _ = s[i] // line22 _ = s[i:len(s)] } } func f8(s []int, index int) { if index \u003e= 0 \u0026\u0026 index \u003c len(s) { _ = s[index] _ = s[index:len(s)] } } func f9(s []int) { if len(s) \u003e 2 { _, _, _ = s[0], s[1], s[2] } } func main() {} $ go run -gcflags=\"-d=ssa/check_bce/debug=1\" example2.go 官方标准编译器消除了上例程序中的所有边界检查。 注意：在 Go 官方工具链 1.11 之前，官方标准编译器没有足够聪明到认为第 22 行是不需要边界检查的。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"例子 3 // example3.go package main import \"math/rand\" func fa() { s := []int{0, 1, 2, 3, 4, 5, 6} index := rand.Intn(7) _ = s[:index] // 第9行： 需要边界检查 _ = s[index:] // 第10行： 边界检查消除了！ } func fb(s []int, index int) { _ = s[:index] // 第14行： 需要边界检查 _ = s[index:] // 第15行： 需要边界检查（不够智能？） } func fc() { s := []int{0, 1, 2, 3, 4, 5, 6} s = s[:4] index := rand.Intn(7) _ = s[:index] // 第22行： 需要边界检查 _ = s[index:] // 第23行： 需要边界检查（不够智能？） } func main() {} $ go run -gcflags=\"-d=ssa/check_bce/debug=1\" example3.go ./example3.go:9: Found IsSliceInBounds ./example3.go:14: Found IsSliceInBounds ./example3.go:15: Found IsSliceInBounds ./example3.go:22: Found IsSliceInBounds ./example3.go:23: Found IsSliceInBounds 噢，仍然有这么多的边界检查！ 但是等等，为什么官方标准编译器认为第 10 行不需要边界检查，却认为第 15 和第 23 行仍旧需要边界检查呢？ 是标准编译器不够智能吗？ 事实上，这里标准编译器做得对。原因是一个子切片表达式中的起始下标可能会大于基础切片的长度。 让我们先看一个简单的使用了子切片的例子： package main func main() { s0 := make([]int, 5, 10) // len(s0) == 5, cap(s0) == 10 index := 8 // 在Go中，对于一个子切片表达式s[a:b]，a和b须满足 // 0 \u003c= a \u003c= b \u003c= cap(s);否则，将产生一个恐慌。 _ = s0[:index] // 上一行是安全的不能保证下一行是无需边界检查的。 // 事实上，下一行将产生一个恐慌，因为起始下标 // index大于终止下标（即切片s0的长度）。 _ = s0[index:] // panic } 所以 如果s[:index]是安全的，则s[index:]是无需边界检查的 这条论述只有在 len(s) 和 cap(s) 相等的情况下才正确。这就是函数 fb 和 fc 中的代码仍旧需要边界检查的原因。 而在例子 3 中，标准编译器成功地检测到在函数 fa 中 len(s) 和 cap(s) 是相等的。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"例子 4 // example4.go package main import \"math/rand\" func fb2(s []int, index int) { _ = s[index:] // 第7行： 需要边界检查 _ = s[:index] // 第8行： 边界检查消除了！ } func fc2() { s := []int{0, 1, 2, 3, 4, 5, 6} s = s[:4] index := rand.Intn(7) _ = s[index:] // 第15行： 需要边界检查 _ = s[:index] // 第16行： 边界检查消除了！ } func main() {} $ go run -gcflags=\"-d=ssa/check_bce/debug=1\" example4.go ./example4.go:7:7: Found IsSliceInBounds ./example4.go:15:7: Found IsSliceInBounds 在此例子中，标准编译器成功推断出： 在函数 fb2 中，如果第 7 行是安全的，则第 8 行是无需边界检查的； 在函数 fc2 中，如果第 15 行是安全的，则第 16 行是无需边界检查的。 注意：Go 官方工具链 1.9 之前中的标准编译器没有出推断出第 8 行不需要边界检查。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:4","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"例子 5 当前版本的标准编译器并非足够智能到可以消除到一切应该消除的边界检查。 有时候，我们需要给标准编译器一些暗示来帮助标准编译器将这些不必要的边界检查消除掉。 // example5.go package main func fd(is []int, bs []byte) { if len(is) \u003e= 256 { for _, n := range bs { _ = is[n] // 第7行： 需要边界检查 } } } func fd2(is []int, bs []byte) { if len(is) \u003e= 256 { is = is[:256] // 第14行： 一个暗示 for _, n := range bs { _ = is[n] // 第16行： 边界检查消除了！ } } } func fe(isa []int, isb []int) { if len(isa) \u003e 0xFFF { for _, n := range isb { _ = isa[n \u0026 0xFFF] // 第24行： 需要边界检查 } } } func fe2(isa []int, isb []int) { if len(isa) \u003e 0xFFF { isa = isa[:0xFFF+1] // 第31行： 一个暗示 for _, n := range isb { _ = isa[n \u0026 0xFFF] // 第33行： 边界检查消除了！ } } } func main() {} $ go run -gcflags=\"-d=ssa/check_bce/debug=1\" example5.go ./example5.go:7: Found IsInBounds ./example5.go:24: Found IsInBounds ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:5","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"总结 本文上面列出的例子并没有涵盖标准编译器支持的所有边界检查消除的情形。本文列出的仅仅是一些常见的情形。 尽管标准编译器中的边界检查消除特性依然不是 100% 完美，但是对很多常见的情形，它确实很有效。 自从标准编译器支持此特性以来，在每个版本更新中，此特性都在不断地改进增强。 无需质疑，在以后的版本中，标准编译器会更加得智能，以至于上面第 5 个例子中提供给编译器的暗示有可能将变得不再必要。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:3:6","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"延迟函数调用 deferred function call 在Go中，一个函数调用可以跟在一个 defer 关键字后面，形成一个延迟函数调用。 和协程调用类似，被延迟的函数调用的所有返回值必须全部被舍弃。 当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的退出阶段后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。 下面这个例子展示了如何使用延迟调用函数。 package main import \"fmt\" func main() { defer fmt.Println(\"The third line.\") defer fmt.Println(\"The second line.\") fmt.Println(\"The first line.\") } 输出结果： The first line. The second line. The third line. 事实上，每个协程维护着两个调用堆栈。 一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈中最早被推入的调用是对应协程的启动调用。 另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。 下面是另一个略微复杂一点的使用了延迟调用的例子程序。此程序将按照自然数的顺序打印出 0 到 9 十个数字。 package main import \"fmt\" func main() { defer fmt.Println(\"9\") fmt.Println(\"0\") defer fmt.Println(\"8\") fmt.Println(\"1\") if false { defer fmt.Println(\"not reachable\") } defer func() { defer fmt.Println(\"7\") fmt.Println(\"3\") defer func() { fmt.Println(\"5\") fmt.Println(\"6\") }() fmt.Println(\"4\") }() fmt.Println(\"2\") return defer fmt.Println(\"not reachable\") } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:4:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"一个延迟调用可以修改包含此延迟调用的最内层函数的返回值 一个例子： package main import \"fmt\" func Triple(n int) (r int) { defer func() { r += n // 修改返回值 }() return n + n // \u003c=\u003e r = n + n; return } func main() { fmt.Println(Triple(5)) // 15 } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:4:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"延迟函数调用的必要性和好处 事实上，上面的几个使用了延迟函数调用的例子中的延迟函数调用并非绝对必要。 但是延迟调用对于下面将要介绍的恐慌 / 恢复特性是必要的。 另外延迟函数调用可以帮助我们写出更整洁和更鲁棒的代码。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:4:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"⭐ 协程和延迟调用的实参的估值时刻 一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说， 对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。 对于一个协程调用，它的实参是在此协程被创建的时候估值的。 一个匿名函数体内的表达式是在此函数被执行的时候才会被逐个估值的，不管此函数是被普通调用还是延迟 / 协程调用。 一个例子： package main import \"fmt\" func main() { func() { for i := 0; i \u003c 3; i++ { defer fmt.Println(\"a:\", i) // 推入堆栈时被估值 } }() fmt.Println() func() { for i := 0; i \u003c 3; i++ { defer func() { fmt.Println(\"b:\", i) // 执行时被估值 }() } }() } 运行之，将得到如下结果： a: 2 a: 1 a: 0 b: 3 b: 3 b: 3 第一个匿名函数中的循环打印出 2、1 和 0 这个序列，但是第二个匿名函数中的循环打印出三个 3。 因为第一个循环中的 i 是在 fmt.Println 函数调用被推入延迟调用堆栈的时候估的值，而第二个循环中的 i 是在第二个匿名函数调用的退出阶段估的值（此时循环变量 i 的值已经变为 3）。 我们可以对第二个循环略加修改（使用两种方法），使得它和第一个循环打印出相同的结果。 for i := 0; i \u003c 3; i++ { defer func(i int) { // 此i为形参i，非实参循环变量i。 fmt.Println(\"b:\", i) }(i) } 或者 for i := 0; i \u003c 3; i++ { i := i // 在下面的调用中，左i遮挡了右i。 // \u003c=\u003e var i = i defer func() { // 此i为上面的左i，非循环变量i。 fmt.Println(\"b:\", i) }() } 同样的估值时刻规则也适用于协程调用。下面这个例子程序将打印出 123 789。 package main import \"fmt\" import \"time\" func main() { var a = 123 go func(x int) { // x在创建时被估值 time.Sleep(time.Second) fmt.Println(x, a) // 123 789 }(a) a = 789 time.Sleep(2 * time.Second) } 顺便说一句，使用 time.Sleep 调用来做并发同步不是一个好的方法。 如果上面这个程序运行在一个满负荷运行的电脑上，此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:4:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"如何优雅地关闭通道 一些观点认为： 没有一个简单和通用的方法用来在不改变一个通道的状态的情况下检查这个通道是否已经关闭。 关闭一个已经关闭的通道将产生一个恐慌，所以在不知道一个通道是否已经关闭的时候关闭此通道是很危险的。 向一个已关闭的通道发送数据将产生一个恐慌，所以在不知道一个通道是否已经关闭的时候向此通道发送数据是很危险的。 是的，Go 语言中并没有提供一个内置函数来检查一个通道是否已经关闭。 在 Go 中，如果我们能够保证从不会向一个通道发送数据，那么有一个简单的方法来判断此通道是否已经关闭： package main import \"fmt\" type T int func IsClosed(ch \u003c-chan T) bool { select { case \u003c-ch: return true default: } return false } func main() { c := make(chan T) fmt.Println(IsClosed(c)) // false close(c) fmt.Println(IsClosed(c)) // true } 如前所述，此方法并不是一个通用的检查通道是否已经关闭的方法。 事实上，即使有一个内置 closed 函数用来检查一个通道是否已经关闭，它的有用性也是十分有限的。 原因是当此函数的一个调用的结果返回时，被查询的通道的状态可能已经又改变了，导致此调用结果并不能反映出被查询的通道的最新状态。 虽然我们可以根据一个调用 closed(ch) 的返回结果为 true 而得出我们不应该再向通道 ch 发送数据的结论， 但是我们不能根据一个调用 closed(ch) 的返回结果为 false 而得出我们可以继续向通道 ch 发送数据的结论。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:5:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"通道关闭原则 一个常用的使用 Go 通道的原则是不要在数据接收方或者在有多个发送者的情况下关闭通道。 换句话说，我们只应该让一个通道唯一的发送者关闭此通道。 下面我们将称此原则为通道关闭原则。 当然，这并不是一个通用的关闭通道的原则。通用的原则是不要关闭已关闭的通道。 如果我们能够保证从某个时刻之后，再没有协程将向一个未关闭的非 nil 通道发送数据，则一个协程可以安全地关闭此通道。 然而，做出这样的保证常常需要很大的努力，从而导致代码过度复杂。 另一方面，遵循通道关闭原则是一件相对简单的事儿。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:5:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"粗鲁地关闭通道的方法 如果由于某种原因，你一定非要从数据接收方或者让众多发送者中的一个关闭一个通道，你可以使用恢复机制来防止可能产生的恐慌而导致程序崩溃。 下面就是这样的一个实现（假设通道的元素类型为T）。 func SafeClose(ch chan T) (justClosed bool) { defer func() { if recover() != nil { // 一个函数的返回结果可以在defer调用中修改。 justClosed = false } }() // 假设ch != nil。 close(ch) // 如果ch已关闭，则产生一个恐慌。 return true // \u003c=\u003e justClosed = true; return } 此方法违反了通道关闭原则。 同样的方法可以用来粗鲁地向一个关闭状态未知的通道发送数据。 func SafeSend(ch chan T, value T) (closed bool) { defer func() { if recover() != nil { closed = true } }() ch \u003c- value // 如果ch已关闭，则产生一个恐慌。 return false // \u003c=\u003e closed = false; return } 这样的粗鲁方法不仅违反了通道关闭原则，而且 Go 白皮书和标准编译器不保证它的实现中不存在数据竞争。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:5:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"礼貌地关闭通道的方法 很多Go程序员喜欢使用 sync.Once 来关闭通道。 type MyChannel struct { C chan T once sync.Once } func NewMyChannel() *MyChannel { return \u0026MyChannel{C: make(chan T)} } func (mc *MyChannel) SafeClose() { mc.once.Do(func() { close(mc.C) }) } 当然，我们也可以使用 sync.Mutex 来防止多次关闭一个通道。 type MyChannel struct { C chan T closed bool mutex sync.Mutex } func NewMyChannel() *MyChannel { return \u0026MyChannel{C: make(chan T)} } func (mc *MyChannel) SafeClose() { mc.mutex.Lock() defer mc.mutex.Unlock() if !mc.closed { close(mc.C) mc.closed = true } } func (mc *MyChannel) IsClosed() bool { mc.mutex.Lock() defer mc.mutex.Unlock() return mc.closed } 这些实现确实比上一节中的方法礼貌一些，但是它们不能完全有效地避免数据竞争。 目前的 Go 白皮书并不保证发生在一个通道上的并发关闭操作和发送操纵不会产生数据竞争。 如果一个 SafeClose 函数和同一个通道上的发送操作同时运行，则数据竞争可能发生（虽然这样的数据竞争一般并不会带来什么危害）。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:5:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"优雅地关闭通道的方法 上一节中介绍的 SafeSend 函数有一个弊端，它的调用不能做为 case 操作而被使用在 select 代码块中。 另外，很多 Go 程序员认为上面两节展示的关闭通道的方法不是很优雅。 本节下面将介绍一些在各种情形下使用纯通道操作来关闭通道的方法。 为了演示程序的完整性，下面这些例子中使用到了sync.WaitGroup。在实践中，sync.WaitGroup并不是必需的。 情形一 M 个接收者和一个发送者。发送者通过关闭用来传输数据的通道来传递发送结束信号 这是最简单的一种情形。当发送者欲结束发送，让它关闭用来传输数据的通道即可。 package main import ( \"time\" \"math/rand\" \"sync\" \"log\" ) func main() { rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... const Max = 100000 const NumReceivers = 100 wgReceivers := sync.WaitGroup{} wgReceivers.Add(NumReceivers) // ... dataCh := make(chan int) // 发送者 go func() { for { if value := rand.Intn(Max); value == 0 { // 此唯一的发送者可以安全地关闭此数据通道。 close(dataCh) return } else { dataCh \u003c- value } } }() // 接收者 for i := 0; i \u003c NumReceivers; i++ { go func() { defer wgReceivers.Done() // 接收数据直到通道dataCh已关闭 // 并且dataCh的缓冲队列已空。 for value := range dataCh { log.Println(value) } }() } wgReceivers.Wait() } 情形二 一个接收者和 N 个发送者，此唯一接收者通过关闭一个额外的信号通道来通知发送者不要在发送数据了 此情形比上一种情形复杂一些。我们不能让接收者关闭用来传输数据的通道来停止数据传输，因为这样做违反了通道关闭原则。 但是我们可以让接收者关闭一个额外的信号通道来通知发送者不要再发送数据了。 package main import ( \"time\" \"math/rand\" \"sync\" \"log\" ) func main() { rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... const Max = 100000 const NumSenders = 1000 wgReceivers := sync.WaitGroup{} wgReceivers.Add(1) // ... dataCh := make(chan int) stopCh := make(chan struct{}) // stopCh是一个额外的信号通道。它的 // 发送者为dataCh数据通道的接收者。 // 它的接收者为dataCh数据通道的发送者。 // 发送者 for i := 0; i \u003c NumSenders; i++ { go func() { for { // 这里的第一个尝试接收用来让此发送者 // 协程尽早地退出。对于这个特定的例子， // 此select代码块并非必需。 select { case \u003c- stopCh: return default: } // 即使stopCh已经关闭，此第二个select // 代码块中的第一个分支仍很有可能在若干个 // 循环步内依然不会被选中。如果这是不可接受 // 的，则上面的第一个select代码块是必需的。 select { case \u003c- stopCh: return case dataCh \u003c- rand.Intn(Max): } } }() } // 接收者 go func() { defer wgReceivers.Done() for value := range dataCh { if value == Max-1 { // 此唯一的接收者同时也是stopCh通道的 // 唯一发送者。尽管它不能安全地关闭dataCh数 // 据通道，但它可以安全地关闭stopCh通道。 close(stopCh) return } log.Println(value) } }() // ... wgReceivers.Wait() } 如此例中的注释所述，对于此额外的信号通道 stopCh，它只有一个发送者，即 dataCh 数据通道的唯一接收者。 dataCh 数据通道的接收者关闭了信号通道 stopCh，这是不违反通道关闭原则的。 在此例中，数据通道 dataCh 并没有被关闭。是的，我们不必关闭它。 当一个通道不再被任何协程所使用后，它将逐渐被垃圾回收掉，无论它是否已经被关闭。 所以这里的优雅性体现在通过不关闭一个通道来停止使用此通道。 情形三 M 个接收者和 N 个发送者。它们中的任何协程都可以让一个中间调解协程帮忙发出停止数据传送的信号 这是最复杂的一种情形。我们不能让接收者和发送者中的任何一个关闭用来传输数据的通道，我们也不能让多个接收者之一关闭一个额外的信号通道。 这两种做法都违反了通道关闭原则。 然而，我们可以引入一个中间调解者角色并让其关闭额外的信号通道来通知所有的接收者和发送者结束工作。 具体实现见下例。注意其中使用了一个尝试发送操作来向中间调解者发送信号。 package main import ( \"time\" \"math/rand\" \"sync\" \"log\" \"strconv\" ) func main() { rand.Seed(time.Now().UnixNano()) log.SetFlags(0) // ... const Max = 100000 const NumReceivers = 10 const NumSenders = 1000 wgReceivers := sync.WaitGroup{} wgReceivers.Add(NumReceivers) // ... dataCh := make(chan int) stopCh := make(chan struct{}) // stopCh是一个额外的信号通道。它的发送 // 者为中间调解者。它的接收者为dataCh // 数据通道的所有的发送者和接收者。 toStop := make(chan string, 1) // toStop是一个用来通知中间调解者让其 // 关闭信号通道stopCh的第二个信号通道。 // 此第二个信号通道的发送者为dataCh数据 // 通道的所有的发送者和接收者，它的接收者 // 为中间调解者。它必须为一个缓冲通道。 var stoppedBy string // 中间调解者 go func() { stoppedBy = \u003c-toStop close(stopCh) }() // 发送者 for i := 0; i \u003c NumSenders; i++ { go func(id string) { for { value := rand.Intn(Max) if value == 0 { // 为了防止阻塞，这里使用了一个尝试 // 发送操作来向中间调解者发送信号。 select { case toStop \u003c- \"发送者#\" + id: default: } return } // 此处的尝试接收操作是为了让此发送协程尽早 // 退出。标准编译器对尝试接收和尝试发送做了 // 特殊的优化，因而它们的速度很快。 select { case \u003c- stopCh: return default: } // 即使stopCh已关闭，如果这个select代码块 // 中第二个分支的发送操作是非阻塞的，则第一个 // 分支仍很有可能在若干个循环步内依然不会被选 // 中。如果这是不可接受的，则上面的第一个尝试 // 接收操作代码块是必需的。 select { case \u003c- stopCh: return case dataCh \u003c- value: } } }(strconv.Itoa(i)) } // 接收者 for i := 0; i \u003c NumReceivers; i++ { go func(id string) { defer wgReceivers.Done() for { // 和发送者协程一样，此处的尝试接收操作是为了 // 让此接收协程尽早退出。 select { case \u003c- stopCh: return default: } // 即使stopCh已关闭，如果这个select代码块 // 中第二个分支的接收操作是非阻塞的，则第一个 // 分支仍很有可能在若干个循环步内依然不会被选 // 中。如果这是不可接受的，则上面尝试接收操作 // 代码块是必需的。 select { case \u003c- stopCh: return case value := \u003c-dataCh: if value == Max-1 { // 为了防止阻塞，这里使用了一个尝试 // 发送操作来向中间调解者发送信号。 select { case toStop \u003c- \"接收者#\" + id: default: } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:5:4","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"结论 并没有什么情况非得逼得我们违反通道关闭原则。 如果你遇到了此情形，请考虑修改你的代码流程和结构设计。 使用通道编程宛如在艺术创作一般！ ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:5:5","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"Go中的 nil nil是Go中的一个使用频率很高的预声明标识符。 很多种类的类型的零值都用nil表示。 很多有其它语言编程经验的程序员在初学Go语言的时候常将nil看成是其它语言中的null或者NULL。 这种看法只是部分上正确的，但是Go中的nil和其它语言中的null或者NULL也是有很大的区别的。 本文的剩余部分将列出和nil相关的各种事实。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"nil是一个预声明的标识符 我们可以直接使用它。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"预声明的nil标识符可以表示很多种类型的零值 在Go中，预声明的nil可以表示下列种类（kind）的类型的零值： 指针类型（包括类型安全和非类型安全指针） 映射类型 切片类型 函数类型 通道类型 接口类型 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"预声明标识符nil没有默认类型 Go中其它的预声明标识符都有各自的默认类型，比如 预声明标识符true和false的默认类型均为内置类型bool。 预声明标识符iota的默认类型为内置类型int。 但是，预声明标识符nil没有一个默认类型，尽管它有很多潜在的可能类型。 事实上，预声明标识符nil是Go中唯一一个没有默认类型的类型不确定值。 我们必须在代码中提供足够的信息以便让编译器能够推断出一个类型不确定的nil值的期望类型。 一个例子： package main func main() { // 代码中必须提供充足的信息来让编译器推断出某个nil的类型。 _ = (*struct{})(nil) _ = []int(nil) _ = map[int]bool(nil) _ = chan string(nil) _ = (func())(nil) _ = interface{}(nil) // 下面这一组和上面这一组等价。 var _ *struct{} = nil var _ []int = nil var _ map[int]bool = nil var _ chan string = nil var _ func() = nil var _ interface{} = nil // 下面这行编译不通过。 var _ = nil } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"nil不是一个关键字 预声明标识符nil可以被更内层的同名标识符所遮挡。 一个例子： package main import \"fmt\" func main() { nil := 123 fmt.Println(nil) // 123 // 下面这行编译报错，因为此行中的nil是一个int值。 var _ map[string]int = nil } （顺便说一下，其它语言中的null和NULL也不是关键字。） ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:4","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"不同种类的类型的nil值的尺寸很可能不相同 一个类型的所有值的内存布局都是一样的，此类型nil值也不例外（假设此类型的零值使用nil表示）。 所以同一个类型的nil值和非nil值的尺寸是一样的。但是不同类型的nil值的尺寸可能是不一样的。 一个例子： package main import ( \"fmt\" \"unsafe\" ) func main() { var p *struct{} = nil fmt.Println( unsafe.Sizeof( p ) ) // 8 var s []int = nil fmt.Println( unsafe.Sizeof( s ) ) // 24 var m map[int]bool = nil fmt.Println( unsafe.Sizeof( m ) ) // 8 var c chan string = nil fmt.Println( unsafe.Sizeof( c ) ) // 8 var f func() = nil fmt.Println( unsafe.Sizeof( f ) ) // 8 var i interface{} = nil fmt.Println( unsafe.Sizeof( i ) ) // 16 } 上例打印出来的尺寸值取决于系统架构和具体编译器实现。 上例中的输出是使用官方标准编译器编译并在64位的系统架构上运行的结果。 在32位的系统架构上，这些输出值将减半。 对于官方标准编译器，如果两个类型属于同一种（kind）类型，并且它们的零值用nil表示，则这两个类型的尺寸肯定相等。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:5","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"两个不同类型的nil值可能不能相互比较 比如，下例中的两行中的比较均编译不通过。 // error: 类型不匹配 var _ = (*int)(nil) == (*bool)(nil) // error: 类型不匹配 var _ = (chan int)(nil) == (chan bool)(nil) 请阅读Go中的值比较规则来了解哪些值可以相互比较。 类型确定的nil值也要遵循这些规则。 下面这些比较是合法的： type IntPtr *int // 类型IntPtr的底层类型为*int。 var _ = IntPtr(nil) == (*int)(nil) // 任何类型都实现了interface{}类型。 var _ = (interface{})(nil) == (*int)(nil) // 一个双向通道可以隐式转换为和它的 // 元素类型一样的单项通道类型。 var _ = (chan int)(nil) == (chan\u003c- int)(nil) var _ = (chan int)(nil) == (\u003c-chan int)(nil) ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:6","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"同一个类型的两个nil值可能不能相互比较 在Go中，映射类型、切片类型和函数类型是不支持比较类型。 比较同一个不支持比较的类型的两个值（包括nil值）是非法的。 比如，下面的几个比较都编译不通过。 var _ = ([]int)(nil) == ([]int)(nil) var _ = (map[string]int)(nil) == (map[string]int)(nil) var _ = (func())(nil) == (func())(nil) 但是，映射类型、切片类型和函数类型的任何值都可以和类型不确定的裸nil标识符比较。 // 这几行编译都没问题。 var _ = ([]int)(nil) == nil var _ = (map[string]int)(nil) == nil var _ = (func())(nil) == nil ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:7","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"两个nil值可能并不相等 如果可被比较的两个nil值中的一个的类型为接口类型，而另一个不是，则比较结果总是false。 原因是，在进行此比较之前，此非接口nil值将被转换为另一个nil值的接口类型，从而将此比较转化为两个接口值的比较。 从接口一文中，我们得知每个接口值可以看作是一个包裹非接口值的盒子。 一个非接口值被转换为一个接口类型的过程可以看作是用一个接口值将此非接口值包裹起来的过程。 一个nil接口值中什么也没包裹，但是一个包裹了nil非接口值的接口值并非什么都没包裹。 一个什么都没包裹的接口值和一个包裹了一个非接口值（即使它是nil）的接口值是不相等的。 一个例子： fmt.Println( (interface{})(nil) == (*int)(nil) ) // false ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:8","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"访问nil映射值的条目不会产生恐慌 访问一个nil映射将得到此映射的类型的元素类型的零值。 比如： fmt.Println( (map[string]int)(nil)[\"key\"] ) // 0 fmt.Println( (map[int]bool)(nil)[123] ) // false fmt.Println( (map[int]*int64)(nil)[123] ) // ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:9","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"range关键字后可以跟随nil通道、nil映射、nil切片和nil数组指针 遍历nil映射和nil切片的循环步数均为零。 遍历一个nil数组指针的循环步数为对应数组类型的长度。 （但是，如果此数组类型的长度不为零并且第二个循环变量未被舍弃或者忽略，则对应for-range循环将导致一个恐慌。） 遍历一个nil通道将使当前协程永久阻塞。 比如，下面的代码将输出0、1、2、3和4后进入阻塞状态。 Hello、world和Bye不会被输出。 for range []int(nil) { fmt.Println(\"Hello\") } for range map[string]string(nil) { fmt.Println(\"world\") } for i := range (*[5]int)(nil) { fmt.Println(i) } for range chan bool(nil) { // 阻塞在此 fmt.Println(\"Bye\") } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:10","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"通过nil非接口属主实参调用方法不会造成恐慌 一个例子： package main type Slice []bool func (s Slice) Length() int { return len(s) } func (s Slice) Modify(i int, x bool) { s[i] = x // panic if s is nil } func (p *Slice) DoNothing() { } func (p *Slice) Append(x bool) { *p = append(*p, x) // 如果p为空指针，则产生一个恐慌。 } func main() { // 下面这几行中的选择器不会造成恐慌。 _ = ((Slice)(nil)).Length _ = ((Slice)(nil)).Modify _ = ((*Slice)(nil)).DoNothing _ = ((*Slice)(nil)).Append // 这两行也不会造成恐慌。 _ = ((Slice)(nil)).Length() ((*Slice)(nil)).DoNothing() // 下面这两行都会造成恐慌。但是恐慌不是因为nil // 属主实参造成的。恐慌都来自于这两个方法内部的 // 对空指针的解引用操作。 /* ((Slice)(nil)).Modify(0, true) ((*Slice)(nil)).Append(true) */ } 事实上，上面的Append方法实现不完美。我们应该像下面这样实现之： func (p *Slice) Append(x bool) { if p == nil { *p = []bool{x} return } *p = append(*p, x) } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:11","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"如果类型T的零值可以用预声明的nil标识符表示，则*new(T)的估值结果为一个T类型的nil值 一个例子： package main import \"fmt\" func main() { fmt.Println(*new(*int) == nil) // true fmt.Println(*new([]int) == nil) // true fmt.Println(*new(map[int]bool) == nil) // true fmt.Println(*new(chan string) == nil) // true fmt.Println(*new(func()) == nil) // true fmt.Println(*new(interface{}) == nil) // true } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:12","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"总结一下 在Go中，为了简单和方便，nil被设计成一个可以表示成很多种类型的零值的预声明标识符。 换句话说，它可以表示很多内存布局不同的值，而不仅仅是一个值。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:6:13","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"恐慌（panic）和恢复（recover） Go 不支持异常抛出和捕获，而是推荐使用返回值显式返回错误。 不过，Go 支持一套和异常抛出 / 捕获类似的机制。此机制称为恐慌 / 恢复（panic/recover）机制。 我们可以调用内置函数 panic 来产生一个恐慌以使当前协程进入恐慌状况。 进入恐慌状况是另一种使当前函数调用开始返回的途径。 一旦一个函数调用产生一个恐慌，此函数调用将立即进入它的退出阶段，在此函数调用中被推入堆栈的延迟调用将按照它们被推入的顺序逆序执行。 通过在一个延迟函数调用之中调用内置函数 recover，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况。 在一个处于恐慌状况的协程退出之前，其中的恐慌不会蔓延到其它协程；如果一个协程在恐慌状况下退出，它将使整个程序崩溃。 内置函数 panic 和 recover 的声明原型如下： func panic(v interface{}) func recover() interface{} 在一个 panic 函数调用中，我们可以传任何实参值。 一个 recover 函数的返回值为其所恢复的恐慌在产生时被一个 panic 函数调用所消费的参数。 下面这个例子展示了如何产生一个恐慌和如何消除一个恐慌。 package main import \"fmt\" func main() { defer func() { fmt.Println(\"正常退出\") }() fmt.Println(\"嗨！\") defer func() { v := recover() fmt.Println(\"恐慌被恢复了：\", v) }() panic(\"拜拜！\") // 产生一个恐慌 fmt.Println(\"执行不到这里\") } 它的输出结果： 嗨！ 恐慌被恢复了： 拜拜！ 正常退出 下面的例子在一个新协程里面产生了一个恐慌，并且此协程在恐慌状况下退出，所以整个程序崩溃了。 package main import ( \"fmt\" \"time\" ) func main() { fmt.Println(\"hi!\") go func() { time.Sleep(time.Second) panic(123) }() for { time.Sleep(time.Second) } } 运行之，输出如下： hi! panic: 123 goroutine 5 [running]: ... Go运行时（runtime）会在若干情形下产生恐慌，比如一个整数被 0 除的时候。下面这个程序将崩溃退出。 package main func main() { a, b := 1, 0 _ = a/b } 它的输出： panic: runtime error: integer divide by zero goroutine 1 [running]: ... 一般说来，恐慌用来表示正常情况下不应该发生的逻辑错误。 如果这样的一个错误在运行时刻发生了，则它肯定是由于某个 bug 引起的。 另一方面，非逻辑错误是现实中难以避免的错误，它们不应该导致恐慌。 我们必须正确地对待和处理非逻辑错误。 对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"一些恐慌/恢复用例 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"用例1：避免恐慌导致程序崩溃 这可能是最常见的panic/recover用例了。 此用例广泛地使用于并发程序中，尤其是响应大量用户请求的应用。 一个例子： package main import \"errors\" import \"log\" import \"net\" func main() { listener, err := net.Listen(\"tcp\", \":12345\") if err != nil { log.Fatalln(err) } for { conn, err := listener.Accept() if err != nil { log.Println(err) } // 在一个新协程中处理客户端连接。 go ClientHandler(conn) } } func ClientHandler(c net.Conn) { defer func() { if v := recover(); v != nil { log.Println(\"捕获了一个恐慌：\", v) log.Println(\"防止了程序崩溃\") } c.Close() }() panic(\"未知错误\") // 演示目的产生的一个恐慌 } 运行此服务器程序，并在另一个终端窗口运行telnet localhost 12345，我们可以观察到服务器程序不会因为客户连接处理协程中的产生的恐慌而导致崩溃。 如果我们在上例中不捕获客户连接处理协程中的潜在恐慌，则这样的恐慌将使整个程序崩溃。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"用例2：自动重启因为恐慌而退出的协程 当在一个协程将要退出时，程序侦测到此协程是因为一个恐慌而导致此次退出时，我们可以立即重新创建一个相同功能的协程。 一个例子： package main import \"log\" import \"time\" func shouldNotExit() { for { time.Sleep(time.Second) // 模拟一个工作负载 // 模拟一个未预料到的恐慌。 if time.Now().UnixNano() \u0026 0x3 == 0 { panic(\"unexpected situation\") } } } func NeverExit(name string, f func()) { defer func() { if v := recover(); v != nil { // 侦测到一个恐慌 log.Printf(\"协程%s崩溃了，准备重启一个\", name) go NeverExit(name, f) // 重启一个同功能协程 } }() f() } func main() { log.SetFlags(0) go NeverExit(\"job#A\", shouldNotExit) go NeverExit(\"job#B\", shouldNotExit) select{} // 永久阻塞主线程 } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"用例3：使用panic/recover函数调用模拟长程跳转 有时，我们可以使用panic/recover函数调用来模拟跨函数跳转，尽管一般这种方式并不推荐使用。 这种跳转方式的可读性不高，代码效率也不是很高，唯一的好处是它有时可以使代码看上去不是很啰嗦。 在下面这个例子中，一旦一个恐慌在一个内嵌函数中产生，当前协程中的执行将会跳转到延迟调用处。 package main import \"fmt\" func main() { n := func () (result int) { defer func() { if v := recover(); v != nil { if n, ok := v.(int); ok { result = n } } }() func () { func () { func () { // ... panic(123) // 用恐慌来表示成功返回 }() // ... }() }() // ... return 0 }() fmt.Println(n) // 123 } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:4","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"用例4：使用panic/recover函数调用来减少错误检查代码 一个例子： func doSomething() (err error) { defer func() { err = recover() }() doStep1() doStep2() doStep3() doStep4() doStep5() return } // 在现实中，各个doStepN函数的原型可能不同。 // 每个doStepN函数的行为如下： // * 如果已经成功，则调用panic(nil)来制造一个恐慌 // 以示不需继续； // * 如果本步失败，则调用panic(err)来制造一个恐慌 // 以示不需继续； // * 不制造任何恐慌表示继续下一步。 func doStepN() { ... if err != nil { panic(err) } ... if done { panic(nil) } } 下面这段同功能的代码比上面这段代码看上去要啰嗦一些。 func doSomething() (err error) { shouldContinue, err := doStep1() if !shouldContinue { return err } shouldContinue, err = doStep2() if !shouldContinue { return err } shouldContinue, err = doStep3() if !shouldContinue { return err } shouldContinue, err = doStep4() if !shouldContinue { return err } shouldContinue, err = doStep5() if !shouldContinue { return err } return } // 如果返回值err不为nil，则shouldContinue一定为true。 // 如果shouldContinue为true，返回值err可能为nil或者非nil。 func doStepN() (shouldContinue bool, err error) { ... if err != nil { return false, err } ... if done { return false, nil } return true, nil } 但是，这种panic/recover函数调用的使用方式一般并不推荐使用，因为它的效率略低一些，并且这种用法不太符合Go编程习俗。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:5","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"详解恐慌和恢复原理 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:6","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"函数调用的退出阶段 在Go中，一个函数调用在其退出完毕之前可能将经历一个退出阶段。 在此退出阶段，所有在执行此函数调用期间被推入延迟调用堆栈的延迟函数调用将按照它们的推入顺序的逆序被执行。 当这些延迟函数调用都退出完毕之后，此函数调用的退出阶段也就结束了，或者说此函数调用也退出完毕了， 退出阶段有时候也被称为返回阶段。 一个函数调用可能通过三种途径进入它的退出阶段： 此调用正常返回； 当此调用中产生了一个恐慌； 当runtime.Goexit函数在此调用中被调用并且退出完毕。 比如，在下面这段代码中， 函数f0或者f1的一个调用将在它正常返回后进入它的退出阶段； 函数f2的一个调用将在“被零除”恐慌产生之后进入它的退出阶段； 函数f3的一个调用将在其中的runtime.Goexit函数调用退出完毕之后进入它的退出阶段。 import ( \"fmt\" \"runtime\" ) func f0() int { var x = 1 defer fmt.Println(\"正常退出：\", x) x++ return x } func f1() { var x = 1 defer fmt.Println(\"正常退出：\", x) x++ } func f2() { var x, y = 1, 0 defer fmt.Println(\"因恐慌而退出：\", x) x = x / y // 将产生一个恐慌 x++ // 执行不到 } func f3() int { x := 1 defer fmt.Println(\"因Goexit调用而退出：\", x) x++ runtime.Goexit() return x+x // 执行不到 } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:7","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"函数调用关联恐慌和Goexit信号 当一个函数调用中直接产生了一个恐慌的时候，我们可以认为此（尚未被恢复的）恐慌将和此函数调用相关联起来。 类似地，当一个函数调用直接调用了runtime.Goexit函数，则runtime.Goexit函数返回完毕之后，我们可以认为一个Goexit信号将和此函数调用相关联起来。 恐慌和Goexit信号互相独立于对方，两者互不干扰。 按照上一节中的解释，当一个恐慌或者一个Goexit信号和一个函数调用相关联之后，此函数调用将立即进入它的退出阶段。 我们已经了解到恐慌是可以被恢复的。 但是，Goexit信号是不能被取消的。 在任何一个给定时刻，一个函数调用最多只能和一个未恢复的恐慌相关联。 如果一个调用正和一个未恢复的恐慌相关联，则 在此恐慌被恢复之后，此调用将不再和任何恐慌相关联。 当在此函数调用中产生了一个新的恐慌，此新恐慌将替换原来的未被恢复的恐慌做为和此函数调用相关联的恐慌。 比如，在下面这个例子中，最终被恢复的恐慌是恐慌3。它是最后一个和main函数调用相关联的恐慌。 package main import \"fmt\" func main() { defer func() { fmt.Println(recover()) // 3 }() defer panic(3) // 将替换恐慌2 defer panic(2) // 将替换恐慌1 defer panic(1) // 将替换恐慌0 panic(0) } 因为Goexit信号不可被取消，争论一个函数调用是否最多只能和一个Goexit信号相关联是没有意义和没有必要的。 在某个时刻，一个协程中可能共存多个未被恢复的恐慌，尽管这在实际编程中并不常见。 每个未被恢复的恐慌和此协程的调用堆栈中的一个尚未退出的函数调用相关联。 当仍和一个未被恢复的恐慌相关联的一个内层函数调用退出完毕之后，此未被恢复的恐慌将传播到调用此内层函数调用的外层函数调用中。 这和在此外层函数调用中直接产生一个新的恐慌的效果是一样的。也就是说， 如果此外层函数已经和一个未被恢复的旧恐慌相关联，则传播出来的新恐慌将替换此旧恐慌并和此外层函数调用相关联起来。 对于这种情形，此外层函数调用肯定已经进入了它的退出阶段（刚提及的内层函数肯定就是被延迟调用的），这时延迟调用堆栈中的下一个延迟调用将被执行。 如果此外层函数尚未和一个未被恢复的旧恐慌相关联，则传播出来的恐慌将和此外层函数调用相关联起来。 对于这种情形，如果此外层函数调用尚未进入它的退出阶段，则它将立即进入。 所以，当一个协程完成完毕后，此协程中最多只有一个尚未被恢复的恐慌。 如果一个协程带着一个尚未被恢复的恐慌退出完毕，则这将使整个程序崩溃，此恐慌信息将在程序崩溃的时候被打印出来。 在一个函数调用被执行的起始时刻，此调用将没有任何恐慌和Goexit信号和它相关联，这个事实和此函数调用的外层调用是否已经进入退出阶段无关。 当然，在此函数调用的执行过程中，恐慌可能产生，runtime.Goexit函数也可能被调用，因此恐慌和Goexit信号以后可能和此调用相关联起来。 下面这个例子程序在运行时将崩溃，因为新开辟的协程在退出完毕时仍带有一个未被恢复的恐慌。 package main func main() { // 新开辟一个协程。 go func() { // 一个匿名函数调用。 // 当它退出完毕时，恐慌2将传播到此新协程的入口 // 调用中，并且替换掉恐慌0。恐慌2永不会被恢复。 defer func() { // 上一个例子中已经解释过了：恐慌2将替换恐慌1. defer panic(2) // 当此匿名函数调用退出完毕后，恐慌1将传播到刚 // 提到的外层匿名函数调用中并与之关联起来。 func () { panic(1) // 在恐慌1产生后，此新开辟的协程中将共存 // 两个未被恢复的恐慌。其中一个（恐慌0） // 和此协程的入口函数调用相关联；另一个 // （恐慌1）和当前这个匿名调用相关联。 }() }() panic(0) }() select{} } 此程序的输出（当使用标准编译器1.17版本编译）： panic: 0 panic: 1 panic: 2 goroutine 5 [running]: ... 此输出的格式并非很完美，它容易让一些程序员误认为恐慌0是最终未被恢复的恐慌。而事实上，恐慌2才是最终未被恢复的恐慌。 类似地，当一个和Goexit信号相关联的内层函数调用退出完毕后，此Goexit信号也将传播到外层函数调用中，并和外层函数调用相关联起来。 如果外层函数调用尚未进入退出阶段，则其将立即进入。 上面提到了恐慌和Goexit信号是互不干扰的。 换句话说，一个尚未被恢复的恐慌不会导致一个Goexit信号被取消；一个Goexit信号也不会压制遮挡一个尚未被恢复的恐慌。 不过目前最新版本的官方两个编译器（标准编译器v1.17和gccgo v8.0）都并未正确实现此规则。 比如，下面这个程序本应崩溃退出，但是并没有（使用最新版本的标准编译器和gccgo编译器编译）。 package main import \"runtime\" func f() { // 此调用产生的Goexit信号将压制先前 // 产生的恐慌\"bye\"，但是不应该如此。 defer runtime.Goexit() panic(\"bye\") } func main() { go f() for runtime.NumGoroutine() \u003e 1 { runtime.Gosched() } } 标准编译器和gccgo编译器将在以后的版本中修复此问题。 下面这个例子程序运行时应该马上退出，但是当前版本的gccgo编译器（v8.0）和Go官方工具链1.14之前的官方标准编译器均未正确实现之，从而导致此程序在运行时永不退出。 package main import \"runtime\" func f() { defer func() { recover() }() defer panic(\"将取消Goexit信号但是不应该这样\") runtime.Goexit() } func main() { c := make(chan struct{}) go func() { defer close(c) f() for { runtime.Gosched() } }() \u003c-c } 标准编译器从1.14版本开始修复了此问题。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:8","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"一些recover调用相当于空操作（No-Op） 内置recover函数必须在合适的位置调用才能发挥作用；否则，它的调用相当于空操作。 比如，在下面这个程序中，没有一个recover函数调用恢复了恐慌bye。 package main func main() { defer func() { defer func() { recover() // 空操作 }() }() defer func() { func() { recover() // 空操作 }() }() func() { defer func() { recover() // 空操作 }() }() func() { defer recover() // 空操作 }() func() { recover() // 空操作 }() recover() // 空操作 defer recover() // 空操作 panic(\"bye\") } 我们已经知道下面这个recover调用是有作用的。 package main func main() { defer func() { recover() // 将恢复恐慌\"byte\" }() panic(\"bye\") } 那么为什么本节中的第一个例子中的所有recover调用都不起作用呢？ 让我们先看看当前版本的Go白皮书是怎么说的： 在下面的情况下，recover函数调用的返回值为nil： 传递给相应panic函数调用的实参为nil； 当前协程并没有处于恐慌状态； recover函数并未直接在一个延迟函数调用中调用。 上一篇文章中提供了一个第一种情况的例子。 本节中的第一个例子中的大多recover调用要么符合Go白皮书中描述的第二种情况，要么符合第三种情况，除了第一个recover调用。 是的，当前版本的白皮书中的描述并不准确。此描述正在被改进中。 事实上，当前版本的白皮书也没有解释清楚为什么下面这个例子中的第二个recover调用没有起作用。此调用本用来恢复恐慌1。 // 此程序将带着未被恢复的恐慌1而崩溃退出。 package main func demo() { defer func() { defer func() { recover() // 此调用将恢复恐慌2 }() defer recover() // 空操作 panic(2) }() panic(1) } func main() { demo() } 当前版本的白皮书没提到的一点是：在任何时刻，一个协程中只有最新产生的恐慌才能够被恢复。 换句话说，每个recover调用都试图恢复当前协程中最新产生的且尚未恢复的恐慌。 这解释了为什么上例中的第二个recover调用不会起作用。 好了，到此我们可以对哪些recover调用会起作用做一个简短的描述： 一个recover调用只有在它的直接外层调用（即recover调用的父调用）是一个延迟调用，并且此延迟调用（即父调用）的直接外层调用（即recover调用的爷调用）和当前协程中最新产生并且尚未恢复的恐慌相关联时才起作用。一个有效的recover调用将最新产生并且尚未恢复的恐慌和与此恐慌相关联的函数调用（即爷调用）剥离开来，并且返回当初传递给产生此恐慌的panic函数调用的参数。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:7:9","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"类型转换、赋值和值比较规则大全 此篇文章将列出Go中所有的类型转换、赋值和值比较规则。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:8:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"类型转换规则大全 在Go中，如果一个值v可以被显式地转换为类型T，则此转换可以使用语法形式(T)(v)来表示。 在大多数情况下，特别是T为一个类型名（即一个标识符）时，此形式可简化为T(v)。 当我们说一个值x可以被隐式转换为一个类型T，这同时也意味着x可以被显式转换为类型T。 1. 显然的类型转换规则 如果两个类型表示着同一个类型，则它们的值可以相互隐式转换为这两个类型中的任意一个。 比如， 类型byte和uint8的任何值可以转换为这两个类型中的任意一个。 类型rune和int32的任何值可以转换为这两个类型中的任意一个。 类型[]byte和[]uint8的任何值可以转换为这两个类型中的任意一个。 此条规则没什么可解释的，无论你是否认为此种情况中发生了转换。 2. 底层类型相关的类型转换规则 给定一个非接口值x和一个非接口类型T，并假设x的类型为Tx， 如果类型Tx和T的底层类型相同（忽略掉结构体字段标签），则x可以被显式转换为类型T。 如果类型Tx和T中至少有一个是非定义类型并且它们的底层类型相同（考虑结构体字段标签），则x可以被隐式转换为类型T。 如果类型Tx和T的底层类型不同，但是两者都是非定义的指针类型并且它们的基类型的底层类型相同（忽略掉结构体字段标签），则x可以（而且只能）被显式转换为类型T。 （注意：两处“忽略掉结构体字段标签”从Go 1.8开始生效。） 一个例子： package main func main() { // 类型[]int、IntSlice和MySlice共享底层类型：[]int。 type IntSlice []int type MySlice []int var s = []int{} var is = IntSlice{} var ms = MySlice{} var x struct{n int `foo`} var y struct{n int `bar`} // 这两行隐式转换编译不通过。 /* is = ms ms = is */ // 必须使用显式转换。 is = IntSlice(ms) ms = MySlice(is) x = struct{n int `foo`}(y) y = struct{n int `bar`}(x) // 这些隐式转换是没问题的。 s = is is = s s = ms ms = s } 指针相关的转换例子： package main func main() { type MyInt int type IntPtr *int type MyIntPtr *MyInt var pi = new(int) // pi的类型为*int var ip IntPtr = pi // 没问题，因为底层类型相同 // 并且pi的类型为非定义类型。 // var _ *MyInt = pi // 不能隐式转换 var _ = (*MyInt)(pi) // 显式转换是没问题的 // 类型*int的值不能被直接转换为类型MyIntPtr， // 但是可以间接地转换过去。 /* var _ MyIntPtr = pi // 不能隐式转换 var _ = MyIntPtr(pi) // 也不能显式转换 */ var _ MyIntPtr = (*MyInt)(pi) // 间接隐式转换没问题 var _ = MyIntPtr((*MyInt)(pi)) // 间接显式转换没问题 // 类型IntPtr的值不能被直接转换为类型MyIntPtr， // 但是可以间接地转换过去。 /* var _ MyIntPtr = ip // 不能隐式转换 var _ = MyIntPtr(ip) // 也不能显式转换 */ // 间接隐式或者显式转换都是没问题的。 var _ MyIntPtr = (*MyInt)((*int)(ip)) // ok var _ = MyIntPtr((*MyInt)((*int)(ip))) // ok } 3. 通道相关的类型转换规则 给定一个通道值x，假设它的类型Tx是一个双向通道类型，T也是一个通道类型（无论是双向的还是单向的）。如果Tx和T的元素类型相同并且它们中至少有一个为非定义类型，则x可以被隐式转换为类型T。 一个例子： package main func main() { type C chan string type C1 chan\u003c- string type C2 \u003c-chan string var ca C var cb chan string cb = ca // ok，因为底层类型相同 ca = cb // ok，因为底层类型相同 // 这4行都满足此第3条转换规则的条件。 var _, _ chan\u003c- string = ca, cb // ok var _, _ \u003c-chan string = ca, cb // ok var _ C1 = cb // ok var _ C2 = cb // ok // 类型C的值不能直接转换为类型C1或C2。 /* var _ = C1(ca) // compile error var _ = C2(ca) // compile error */ // 但是类型C的值可以间接转换为类型C1或C2。 var _ = C1((chan\u003c- string)(ca)) // ok var _ = C2((\u003c-chan string)(ca)) // ok var _ C1 = (chan\u003c- string)(ca) // ok var _ C2 = (\u003c-chan string)(ca) // ok } 4. 和接口实现相关的类型转换规则 给定一个值x和一个接口类型I，如果x的类型（或者默认类型）为Tx并且类型Tx实现了接口类型I，则x可以被 隐式 转换为类型I。 此转换的结果为一个类型为I的接口值。此接口值包裹了 x的一个副本（如果Tx是一个非接口值）； x的动态值的一个副本（如果Tx是一个接口值）。 请阅读接口一文获取更多详情和示例。 5. 类型不确定值相关的类型转换规则 如果一个类型不确定值可以表示为类型T的值，则它可以被隐式转换为类型T。 一个例子： package main func main() { var _ []int = nil var _ map[string]int = nil var _ chan string = nil var _ func()() = nil var _ *bool = nil var _ interface{} = nil var _ int = 123.0 var _ float64 = 123 var _ int32 = 1.23e2 var _ int8 = 1 + 0i } 6. 常量相关的类型转换规则 （此规则和上一条规则有些重叠。） 常量的类型转换结果一般仍然是一个常量。（除了下面第8条规则中将介绍的字符串转换为字节切片或者码点切片的情况。） 给定一个常量值x和一个类型T，如果x可以表示成类型T的一个值，则x可以被显式地转换为类型T；特别地，如果x是一个类型不确定值，则它可以被隐式转换为类型T。 一个例子： package main func main() { const I = 123 const I1, I2 int8 = 0x7F, -0x80 const I3, I4 int8 = I, 0.0 const F = 0.123456789 const F32 float32 = F const F32b float32 = I const F64 float64 = F const F64b = float64(I3) // 这里必须显式转换 const C1, C2 complex64 = F, I const I5 = int(C2) // 这里必须显式转换 } 7. 非常量数值转换规则 非常量浮点数和整数值可以被显式转换为任何浮点数和整数类型。 非常量复数值可以被显式转换为任何复数类型。 注意， 非常量复数值不能被转换为浮点数或整数类型。 非常量浮点数和整数值不能被转换为复数类型。 在非常量数值的转换过程中，溢出和舍入是允许的。当一个浮点数被转换为整数时，小数部分将被舍弃（向零靠拢）。 一个例子： package main import \"fmt\" func main() { var a, b = 1.6, -1.6 // 类型均为float64 fmt.Println(int(a), int(b)) // 1 -1 var i, j int16 = 0x7FFF, -0x8000 fmt.Println(int8(i), uint16(j)) // -1 32768 var c1 complex64 = 1 + 2i var _ = complex128(c1) } 8. 字符串相关的转换规则 如果一个值的类型（或者默认类型）为一个整数类型，则此值可以被当作一个码点值（rune值）显式转换为任何字符串类型。 一个字符串可以被显式转换为一个字节切片类型，反之亦然。 字节切片类型是指底层类型为[]byte的类型。 一个字符串可以被显式转换为一个码点切片类型，反之亦然。 码点切片类型是指底层类型为[]rune的类型。 请阅读字符串一文获取更多详情和示例。 9. 切片相关的类型转换规则 从Go 1.17开始，一个切片可以被转化为一个相同元素类型的数组的指针类型。 但是如果数组的长度大于被转化切片的长度，则将导致恐慌产生。 这里有一个例子。 10","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:8:1","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"赋值规则 赋值可以看作是隐式类型转换。 各种隐式转换规则在上一节中已经列出。 除了这些规则，赋值语句中的目标值必须为一个可寻址的值、一个映射元素表达式或者一个空标识符。 在一个赋值中，源值被复制给了目标值。精确地说，源值的直接部分被复制给了目标值。 注意：函数传参和结果返回其实都是赋值。 ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:8:2","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"值比较规则 Go白皮书提到： 在任何比较中，第一个比较值必须能被赋值给第二个比较值的类型，或者反之。 所以，值比较规则和赋值规则非常相似。 换句话说，两个值是否可以比较取决于其中一个值是否可以隐式转换为另一个值的类型。 很简单？此规则描述基本正确，但是存在另外一条优先级更高的规则： 如果一个比较表达式中的两个比较值均为类型确定值，则它们的类型必须都属于可比较类型。 按照上面这条规则，如果一个不可比较类型（肯定是一个非接口类型）实现了一个接口类型，则比较这两个类型的值是非法的，即使前者的值可以隐式转化为后者。 注意，尽管切片/映射/函数类型为不可比较类型，但是它们的值可以和类型不确定的预声明nil标识符比较。 上述规则并未覆盖所有的情况。如果两个值均为类型不确定值，它们可以比较吗？这种情况的规则比较简单： 两个类型不确定的布尔值可以相互比较。 两个类型不确定的数字值可以相互比较。 两个类型不确定的字符串值可以相互比较。 两个类型不确定的数字值的比较结果服从直觉。 注意，两个类型不确定的nil值不能相互比较。 任何比较的结果均为一个类型不确定的布尔值。 一些值比较的例子： package main // 一些类型为不可比较类型的变量。 var s []int var m map[int]int var f func()() var t struct {x []int} var a [5]map[int]int func main() { // 这些比较编译不通过。 /* _ = s == s _ = m == m _ = f == f _ = t == t _ = a == a _ = nil == nil _ = s == interface{}(nil) _ = m == interface{}(nil) _ = f == interface{}(nil) */ // 这些比较编译都没问题。 _ = s == nil _ = m == nil _ = f == nil _ = 123 == interface{}(nil) _ = true == interface{}(nil) _ = \"abc\" == interface{}(nil) } 两个值是如何进行比较的？ 假设两个值可以相互比较，并且它们的类型同为T。 （如果它们的类型不同，则其中一个可以转换为另一个的类型。这里我们不考虑两者均为类型不确定值的情形。） 如果T是一个布尔类型，则这两个值只有在它们同为true或者false的时候比较结果才为true。 如果T是一个整数类型，则这两个值只有在它们在内存中的表示完全一致的情况下比较结果才为true。 如果 T 是一个浮点数类型， 则这两个值只要满足下面任何一种情况，它们的比较结果就为 true ： 它们都为+Inf； 它们都为-Inf； 它们都为-0.0或者都为+0.0。 它们都不是NaN并且它们在内存中的表示完全一致。 如果T是一个复数类型，则这两个值只有在它们的实部和虚部均做为浮点数进行进行比较的结果都为true的情况下比较结果才为true。 如果T是一个指针类型（类型安全或者非类型安全），则这两个值只有在它们所表示的地址值相等或者它们都为nil的情况下比较结果才为true。 如果T是一个通道类型，则这两个值只有在它们引用着相同的底层内部通道或者它们都为nil时比较结果才为true。 如果T是一个结构体类型，则它们的相应字段将逐对进行比较。只要有一对字段不相等，这两个结构体值就不相等。 如果T是一个数组类型，则它们的相应元素将逐对进行比较。只要有一对元素不相等，这两个结构体值就不相等。 如果T是一个接口类型，请参阅两个接口值是如何进行比较的。 如果T是一个字符串类型，请参阅两个字符串值是如何进行比较的。 请注意，动态类型均为同一个不可比较类型的两个接口值的比较将产生一个恐慌。比如下面的例子： package main func main() { type T struct { a interface{} b int } var x interface{} = []int{} var y = T{a: x} var z = [3]T{{a: y}} // 这三个比较均会产生一个恐慌。 _ = x == x _ = y == y _ = z == z } ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:8:3","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["Golang"],"content":"默认参数的实现 golang 本身并不支持像 C++ 那样的函数默认参数，不过可以自己实现相关方法达到默认参数的目的； 以下用创建人的个人信息为例，名字必须输入，而邮箱地址和年龄可以不用输入，不输入时使用默认值，示例代码如下： package main import ( \"fmt\" ) type DetailInfo struct { Email string Age int } type Handler interface { parse(detail *DetailInfo) } type HandleFunc func(*DetailInfo) func (f HandleFunc) parse(detail *DetailInfo) { f(detail) } // 针对不同默认参数设置闭包函数， 这里比较关键，闭包函数=函数+运行环境（可以引用外部函数的变量） func WithEmail(email string) HandleFunc { return func(detail *DetailInfo) { detail.Email = email } } func WithAge(age int) HandleFunc { return func(detail *DetailInfo) { detail.Age = age } } type Persion struct { Name string DetailInfo } // 这里的接口类Handler并不是必须的，换成闭包函数HandleFunc类型一样可以 func newPersion(name string, infos ...Handler) Persion { detail := \u0026DetailInfo{ Email: \"unkown\", Age: -1} for _, info := range infos { // 接口函数调用闭包函数 info.parse(detail) } return Persion{Name: name, DetailInfo: DetailInfo{Email: detail.Email, Age: detail.Age}} } func main() { persion1 := newPersion(\"小明\") fmt.Println(\"persion1:\", persion1) persion2 := newPersion(\"小红\", WithEmail(\"xiaohong@qq.com\")) fmt.Println(\"persion2:\", persion2) persion3 := newPersion(\"张三\", WithAge(18)) fmt.Println(\"persion3:\", persion3) persion4 := newPersion(\"李四\", WithEmail(\"lisi@qq.com\"), WithAge(28)) fmt.Println(\"persion3:\", persion4) } 输出结果： persion1: {小明 {unkown -1}} persion2: {小红 {xiaohong@qq.com -1}} persion3: {张三 {unkown 18}} persion3: {李四 {lisi@qq.com 28}} 分析： 关键点是用到了可变参数 ... 和闭包函数； 通过可变参数循环调用闭包函数，给参数赋值； 通过闭包函数特性（可以引用外部函数的变量），给需要设置的参数赋值； ","date":"2022-03-03","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/:9:0","tags":["进阶"],"title":"Go 进阶","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"},{"categories":["刷题"],"content":"剑指 Offer 15. 二进制中1的个数 easy 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。 示例 1： 输入：n = 11 (控制台输入 00000000000000000000000000001011) 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1' ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:0:0","tags":["算法","位运算"],"title":"剑指 Offer 15. 二进制中1的个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"位运算 func hammingWeight(num uint32) (count int) { for num \u003e 0 { if num\u00261 == 1 { count++ } num = num \u003e\u003e 1 } return } func hammingWeight(num uint32) (ones int) { for i := 0; i \u003c 32; i++ { if 1\u003c\u003ci\u0026num \u003e 0 { ones++ } } return } ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:1:0","tags":["算法","位运算"],"title":"剑指 Offer 15. 二进制中1的个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"位运算优化 func hammingWeight(num uint32) (ones int) { for ; num \u003e 0; num \u0026= num - 1 { ones++ } return } ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/:2:0","tags":["算法","位运算"],"title":"剑指 Offer 15. 二进制中1的个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"剑指 Offer 16. 数值的整数次方 easy 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/:0:0","tags":["算法","数学"],"title":"剑指 Offer 16. 数值的整数次方","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"categories":["刷题"],"content":"快速幂（二进制） func myPow(x float64, n int) float64 { if x == 0 { return 0 } if n \u003c 0 { x, n = 1/x, -n } res := 1.0 var b int // 二进制n的某一位 0或1 for n != 0 { b = n \u0026 1 // 获取二进制n最后一位 if b != 0 { res *= x } n = n \u003e\u003e 1 // n右移一位 x = x * x } return res } ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/:1:0","tags":["算法","数学"],"title":"剑指 Offer 16. 数值的整数次方","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"categories":["刷题"],"content":"二分法角度理解 ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/:2:0","tags":["算法","数学"],"title":"剑指 Offer 16. 数值的整数次方","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"},{"categories":["刷题"],"content":"剑指 Offer 33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 参考以下这颗二叉搜索树： 5 / \\ 2 6 / \\ 1 3 示例 1： 输入: [1,6,3,2,5] 输出: false 示例 2： 输入: [1,3,2,6,5] 输出: true ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/:0:0","tags":["算法","树","分治"],"title":"剑指 Offer 33. 二叉搜索树的后序遍历序列","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"categories":["刷题"],"content":"递归分治 逻辑 从后向前遍历，寻找第一个小于根节点的元素下标 i（这样可以保证右子树均大于根节点） 对左子树正确性进行判断，即从 i 向前进行遍历，若发现大于根节点的值，则判断不是搜索二叉树，返回 false 对左右子树递归 func verifyPostorder(postorder []int) bool { if len(postorder) == 0 { return true } rootVal := postorder[len(postorder)-1] var i int for i = len(postorder) - 1; i \u003e= 0; i-- { // 找到第一个小于rootVal的下标 if postorder[i] \u003c rootVal { break } } for j := i; j \u003e= 0; j-- { if postorder[j] \u003e rootVal { return false } } return verifyPostorder(postorder[:i+1]) \u0026\u0026 verifyPostorder(postorder[i+1:len(postorder)-1]) } ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/:1:0","tags":["算法","树","分治"],"title":"剑指 Offer 33. 二叉搜索树的后序遍历序列","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"},{"categories":["刷题"],"content":"剑指 Offer 65. 不用加减乘除做加法 easy 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例: 输入: a = 1, b = 1 输出: 2 提示： a, b 均可能是负数或 0 结果不会溢出 32 位整数 ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/:0:0","tags":["算法","位运算"],"title":"剑指 Offer 65. 不用加减乘除做加法","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"},{"categories":["刷题"],"content":"位运算 func add(a int, b int) int { // 进位 var carry int for b != 0 { // 进位 carry = (a \u0026 b) \u003c\u003c 1 // 不加进位 a ^= b // 加进位 b = carry } return a } ","date":"2022-03-03","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/:1:0","tags":["算法","位运算"],"title":"剑指 Offer 65. 不用加减乘除做加法","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/"},{"categories":["刷题"],"content":"剑指 Offer 07. 重建二叉树 mid 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["算法","树","分治"],"title":"剑指 Offer 07. 重建二叉树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"分治 func buildTree(preorder []int, inorder []int) *TreeNode { hash := make(map[int]int) // 构建中序遍历的哈希表 for i, val := range inorder { hash[val] = i } var bt func(preorder []int, inorder []int, offset int) *TreeNode bt = func(preorder []int, inorder []int, offset int) *TreeNode { // 为了方便哈希表查找 添加offset参数为相对0位置的偏移量 if len(preorder) == 0 { return nil } root := TreeNode{Val: preorder[0]} // 找到根节点 i := hash[root.Val] - offset // 找到根节点在中序遍历中的索引位置 root.Left = bt(preorder[1:i+1], inorder[:i], offset) root.Right = bt(preorder[i+1:], inorder[i+1:], offset+i+1) return \u0026root } root := bt(preorder, inorder, 0) return root } ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":["算法","树","分治"],"title":"剑指 Offer 07. 重建二叉树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"剑指 Offer 26. 树的子结构 mid 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构) B 是 A 的子结构， 即 A 中有出现和 B 相同的结构和节点值。 例如: 给定的树 A: 3 / \\ 4 5 / \\ 1 2 给定的树 B： 4 / 1 返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 示例 1： 输入：A = [1,2,3], B = [3,1] 输出：false 示例 2： 输入：A = [3,4,5,1,2], B = [4,1] 输出：true ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/:0:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 26. 树的子结构","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"categories":["刷题"],"content":"对称性递归 // 从头结点开始 是不是子树 func isSubStructureHelp(A *TreeNode, B *TreeNode) bool { if B == nil { return true } else if A == nil { // B不空A空 return false } if A.Val == B.Val { return isSubStructureHelp(A.Left, B.Left) \u0026\u0026 isSubStructureHelp(A.Right, B.Right) } return false } func isSubStructure(A *TreeNode, B *TreeNode) bool { if A == nil || B == nil { return false } return isSubStructureHelp(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B) } ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/:1:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 26. 树的子结构","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"},{"categories":["刷题"],"content":"剑指 Offer 27. 二叉树的镜像 mid 请完成一个函数，输入一个二叉树，该函数输出它的镜像。 例如输入： 4 / \\ 2 7 / \\ / \\ 1 3 6 9 镜像输出： 4 / \\ 7 2 / \\ / \\ 9 6 3 1 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/:0:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 27. 二叉树的镜像","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"categories":["刷题"],"content":"递归 // 递归 func mirrorTree(root *TreeNode) *TreeNode { if root == nil { return nil } left := mirrorTree(root.Left) right := mirrorTree(root.Right) root.Left = right root.Right = left return root } ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/:1:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 27. 二叉树的镜像","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-27.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/"},{"categories":["刷题"],"content":"剑指 Offer 28. 对称的二叉树 mid 请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 1 / \\ 2 2 / \\ / \\ 3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 1 / \\ 2 2 \\ \\ 3 3 ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 28. 对称的二叉树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"递归 func isSymmetric(root *TreeNode) bool { if root == nil { return true } return isSymmetricHelp(root.Left, root.Right) } // 判断两棵树是否镜像 func isSymmetricHelp(A *TreeNode, B *TreeNode) bool { if A == nil \u0026\u0026 B == nil { return true } else if A == nil || B == nil { // 若一个为空一个不为空 return false } if A.Val == B.Val \u0026\u0026 isSymmetricHelp(A.Left, B.Right) \u0026\u0026 isSymmetricHelp(A.Right, B.Left) { return true } return false } ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 28. 对称的二叉树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-28.-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"剑指 Offer 32 - II. 从上到下打印二叉树 II easy 从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [9,20], [15,7] ] ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/:0:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 32 - II. 从上到下打印二叉树 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/"},{"categories":["刷题"],"content":"解 记录一下就好了 func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } result := make([][]int, 0) queue := make([]*TreeNode, 0) queue = append(queue, root) curCount := 1 curLevel := 0 nextCount := 0 for len(queue) != 0 { curNodes := make([]int, 0) for curCount \u003e 0 { curNode := queue[0] queue = queue[1:] curNodes = append(curNodes, curNode.Val) if curNode.Left != nil { queue = append(queue, curNode.Left) nextCount++ } if curNode.Right != nil { queue = append(queue, curNode.Right) nextCount++ } curCount-- } result = append(result, curNodes) curCount = nextCount nextCount = 0 curLevel++ } return result } ","date":"2022-02-28","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/:1:0","tags":["算法","树","对称性递归"],"title":"剑指 Offer 32 - II. 从上到下打印二叉树 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-ii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/"},{"categories":["刷题"],"content":"剑指 Offer 55 - II. 平衡二叉树 easy 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":["算法","树","回溯"],"title":"剑指 Offer 55 - II. 平衡二叉树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"后序遍历（DFS） package tree func max(a, b int) int { if a \u003e b { return a } return b } func abs(a int) int { if a \u003c 0 { return -a } return a } func isBalanced(root *TreeNode) bool { var bp func(root *TreeNode) (int, bool) bp = func(root *TreeNode) (int, bool) { // 返回高度, 是否是平衡二叉树 if root == nil { return 0, true } d1, b1 := bp(root.Left) d2, b2 := bp(root.Right) if b1 \u0026\u0026 b2 \u0026\u0026 abs(d1-d2) \u003c= 1 { return max(d1, d2)+1, true } return max(d1, d2)+1, false } _, res := bp(root) return res } ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":["算法","树","回溯"],"title":"剑指 Offer 55 - II. 平衡二叉树","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":["刷题"],"content":"剑指 Offer 64. 求1+2+…+n mid 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 输入: n = 3 输出: 6 示例 2： 输入: n = 9 输出: 45 ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821+2++n/:0:0","tags":["算法","回溯"],"title":"剑指 Offer 64. 求1+2+…+n","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821+2++n/"},{"categories":["刷题"],"content":"逻辑与算符短路 // 逻辑短路 func sumNums(n int) int { res := 0 var sum func(n int) bool sum = func(n int) bool { res += n return n \u003e 0 \u0026\u0026 sum(n-1) // 不满足n\u003e1时 递归就会退出 } sum(n) return res } ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821+2++n/:1:0","tags":["算法","回溯"],"title":"剑指 Offer 64. 求1+2+…+n","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-64.-%E6%B1%821+2++n/"},{"categories":["刷题"],"content":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。(一个节点也可以是它自己的祖先) ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:0:0","tags":["算法","树"],"title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["刷题"],"content":"两次遍历 func getPath(root, target *TreeNode) (path []*TreeNode) { // 获取从根节点到目标节点的路径结点数组 node := root for node != target { path = append(path, node) if target.Val \u003c node.Val { node = node.Left } else { node = node.Right } } path = append(path, node) return } func lowestCommonAncestor(root, p, q *TreeNode) (ancestor *TreeNode) { pathP := getPath(root, p) pathQ := getPath(root, q) for i := 0; i \u003c len(pathP) \u0026\u0026 i \u003c len(pathQ) \u0026\u0026 pathP[i] == pathQ[i]; i++ { ancestor = pathP[i] } return } ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:1:0","tags":["算法","树"],"title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["刷题"],"content":"一次遍历 func lowestCommonAncestor(root, p, q *TreeNode) (ancestor *TreeNode) { ancestor = root for { if p.Val \u003c ancestor.Val \u0026\u0026 q.Val \u003c ancestor.Val { ancestor = ancestor.Left } else if p.Val \u003e ancestor.Val \u0026\u0026 q.Val \u003e ancestor.Val { ancestor = ancestor.Right } else { return } } } ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:2:0","tags":["算法","树"],"title":"剑指 Offer 68 - I. 二叉搜索树的最近公共祖先","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-i.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["刷题"],"content":"剑指 Offer 68 - II. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:0:0","tags":["算法","树","回溯"],"title":"剑指 Offer 68 - II. 二叉树的最近公共祖先","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["刷题"],"content":"DFS 递归地判断子树是否包含了 p 或 q func max(a, b int) int { if a \u003e b { return a } return b } // DFS func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { minDepth := math.MaxInt var res *TreeNode var bp func(root *TreeNode) (pv, qv bool, d int) bp = func(root *TreeNode) (pv, qv bool, d int) { // 返回以root为头节点的树是否含有p和q 和它的深度 if root == nil { return false, false, 0 } pv1, qv1, d1 := bp(root.Left) pv2, qv2, d2 := bp(root.Right) d = max(d1, d2) + 1 if pv1 || pv2 || root.Val == p.Val { pv = true } if qv1 || qv2 || root.Val == q.Val { qv = true } if pv \u0026\u0026 qv \u0026\u0026 d \u003c minDepth { res = root minDepth = d } return } bp(root) return res } ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:1:0","tags":["算法","树","回溯"],"title":"剑指 Offer 68 - II. 二叉树的最近公共祖先","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["刷题"],"content":"更好的 DFS func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil { return nil } if root.Val == p.Val || root.Val == q.Val { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left != nil \u0026\u0026 right != nil { return root } if left == nil { return right } return left } ","date":"2022-02-27","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/:2:0","tags":["算法","树","回溯"],"title":"剑指 Offer 68 - II. 二叉树的最近公共祖先","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-68-ii.-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"},{"categories":["刷题"],"content":"209. 长度最小的子数组 mid 给定一个含有 n 个正整数的数组和一个正整数 target 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr]，并返回其长度**。**如果不存在符合条件的子数组，返回 0 。 示例 1： 输入：target = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的子数组。 示例 2： 输入：target = 4, nums = [1,4,4] 输出：1 示例 3： 输入：target = 11, nums = [1,1,1,1,1,1,1,1] 输出：0 ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/:0:0","tags":["算法","数组","滑动窗口"],"title":"209. 长度最小的子数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"滑动窗口 func minSubArrayLen(target int, nums []int) int { i, j := 0, 0 minLen := math.MaxInt var curSum int for j \u003c len(nums) { curSum += nums[j] // 加上新边界 for curSum \u003e= target { if j-i+1 \u003c minLen { minLen = j - i + 1 } curSum -= nums[i] // 减去旧的左边界 i++ } j++ } if minLen == math.MaxInt { return 0 } return minLen } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/:1:0","tags":["算法","数组","滑动窗口"],"title":"209. 长度最小的子数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/209.-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"59. 螺旋矩阵 II mid 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 1 \u003c= n \u003c= 20 ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/:0:0","tags":["算法","数组","模拟"],"title":"59. 螺旋矩阵 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/"},{"categories":["刷题"],"content":"模拟 就恩写；注意边界条件 func generateMatrix(n int) [][]int { if n == 1 { return [][]int{{1}} } res := make([][]int, n) for i := 0; i \u003c n; i++ { res[i] = make([]int, n) } count := 1 for layer := 0; layer \u003c= n-2; layer++ { // 顺时针填空 左闭右开 中心特例 if layer == n-layer-1 { // 中心 res[layer][layer] = n * n break } // l2r for col := layer; col \u003c n-layer-1; col++ { res[layer][col] = count count++ } // u2d for row := layer; row \u003c n-layer-1; row++ { res[row][n-layer-1] = count count++ } // r2l for col := n - layer - 1; col \u003e layer; col-- { res[n-layer-1][col] = count count++ } // d2u for row := n - layer - 1; row \u003e layer; row-- { res[row][layer] = count count++ } } return res } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/:1:0","tags":["算法","数组","模拟"],"title":"59. 螺旋矩阵 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/"},{"categories":["刷题"],"content":"更好懂的模拟 func generateMatrix(n int) [][]int { top, bottom := 0, n-1 left, right := 0, n-1 num := 1 tar := n * n matrix := make([][]int, n) for i := 0; i \u003c n; i++ { matrix[i] = make([]int, n) } for num \u003c= tar { for i := left; i \u003c= right; i++ { matrix[top][i] = num num++ } top++ for i := top; i \u003c= bottom; i++ { matrix[i][right] = num num++ } right-- for i := right; i \u003e= left; i-- { matrix[bottom][i] = num num++ } bottom-- for i := bottom; i \u003e= top; i-- { matrix[i][left] = num num++ } left++ } return matrix } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/:2:0","tags":["算法","数组","模拟"],"title":"59. 螺旋矩阵 II","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/59.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-ii/"},{"categories":["刷题"],"content":"7. 整数反转 mid 给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。 如果反转后整数超过 32 位的有符号整数的范围 [−2^31^, 2^31^ − 1] ，就返回 0。 假设环境不允许存储 64 位整数（有符号或无符号）。 示例 1： 输入：x = 123 输出：321 示例 2： 输入：x = -123 输出：-321 示例 3： 输入：x = 120 输出：21 ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/:0:0","tags":["算法","数学"],"title":"7. 整数反转","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"categories":["刷题"],"content":"数学 func reverse(x int) int { var digit, res int for x != 0 { if res \u003c math.MinInt32/10 || res \u003e math.MaxInt32/10 { return 0 } digit = x % 10 x /= 10 res = res*10 + digit } return res } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/:1:0","tags":["算法","数学"],"title":"7. 整数反转","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/7.-%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"},{"categories":["刷题"],"content":"76. 最小覆盖子串 hard 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\" 输出：\"BANC\" 示例 2： 输入：s = \"a\", t = \"a\" 输出：\"a\" 示例 3: 输入: s = \"a\", t = \"aa\" 输出: \"\" 解释: t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/76.-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/:0:0","tags":["算法","字符串","滑动窗口"],"title":"76. 最小覆盖子串","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/76.-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"},{"categories":["刷题"],"content":"滑动窗口 典型的滑动窗口思路，窗口扩展时寻找可行解，窗口收缩时优化可行解。 func minWindow(s string, t string) string { if s == t { return s } hash := make(map[byte]int) // 记录目标字母及其个数 作为需求 for i := 0; i \u003c len(t); i++ { hash[t[i]]++ } reL, reR := 0, -1 // 目标的左右边界 minLen := math.MaxInt left, right := 0, 0 sum := len(t) // 记录总数 为0时代表全命中 for right \u003c len(s) { if _, ok := hash[s[right]]; ok { // 存在 hash[s[right]]-- if hash[s[right]] \u003e= 0 { // 变成负数时sum不用减少 因为已经满足 sum-- } } if sum == 0 { // 全部命中 for left \u003c= right { // left右移 直到不满足全命中 if _, ok := hash[s[left]]; ok { hash[s[left]]++ if hash[s[left]] \u003e 0 { // 需求得不到满足了 if minLen \u003e right-left+1 { // 刷新最短值 reR, reL = right, left minLen = right - left + 1 } sum++ left++ // 正式地++ 破坏全命中状态 break } } left++ // 注意 先判断再++ } } right++ } return s[reL : reR+1] } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/76.-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/:1:0","tags":["算法","字符串","滑动窗口"],"title":"76. 最小覆盖子串","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/76.-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"剑指 Offer 22. 链表中倒数第 k 个节点 easy 输入一个链表，输出该链表中倒数第 k 个节点。为了符合大多数人的习惯，本题从 1 开始计数，即链表的尾节点是倒数第1个节点。 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 3 个节点是值为 4 的节点。 示例： 给定一个链表: 1-\u003e2-\u003e3-\u003e4-\u003e5, 和 k = 2. 返回链表 4-\u003e5. ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/:0:0","tags":["算法","链表"],"title":"剑指 Offer 22. 链表中倒数第 k 个节点","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["算法"],"content":"双指针 fast 先走 k 步，然后 slow 和 fast 一起走，直到 fast 走到空 func getKthFromEnd(head *ListNode, k int) *ListNode { curNode, preNode := head, head for curNode != nil { curNode = curNode.Next if k == 0 { preNode = preNode.Next } else { k-- } } return preNode } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/:1:0","tags":["算法","链表"],"title":"剑指 Offer 22. 链表中倒数第 k 个节点","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-22.-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"categories":["刷题"],"content":"剑指 Offer 40. 最小的 k 个数 easy 输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 示例 1： 输入：arr = [3,2,1], k = 2 输出：[1,2] 或者 [2,1] 示例 2： 输入：arr = [0,1,2,1], k = 1 输出：[0] ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/:0:0","tags":["算法","排序"],"title":"剑指 Offer 40. 最小的 k 个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"排序 排序后取前 k 个数，很笨！ func getLeastNumbers(arr []int, k int) []int { sort.Ints(arr) return arr[:k] } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/:1:0","tags":["算法","排序"],"title":"剑指 Offer 40. 最小的 k 个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"快排思想 // 快排思想 func getLeastNumbers(arr []int, k int) []int { var quickSort func(nums []int, l, r, x int) quickSort = func(nums []int, l, r, x int) { if l \u003e r { return } i, j := l, r pivotPos := true for i \u003c j { if nums[i] \u003e nums[j] { nums[i], nums[j] = nums[j], nums[i] pivotPos = !pivotPos } if pivotPos { j-- } else { i++ } } num := i - l + 1 // 本次划分 可以保证划分正确的个数为num if x == num { // 正好 return } else if x \u003c num { quickSort(nums, l, i-1, x) } else { quickSort(nums, i+1, r, x-num) } } if k == 0 { return []int{} } quickSort(arr, 0, len(arr)-1, k) return arr[:k] } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/:2:0","tags":["算法","排序"],"title":"剑指 Offer 40. 最小的 k 个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"堆 func getLeastNumbers3(arr []int, k int) []int { // 大顶堆 var heapify func(nums []int, root, end int) heapify = func(nums []int, root, end int) { // 大顶堆堆化，堆顶值小一直下沉 for { // 左孩子节点索引 child := root*2 + 1 // 越界跳出 if child \u003e end { return } // 比较左右孩子，取大值，否则child不用++ if child \u003c end \u0026\u0026 nums[child] \u003c= nums[child+1] { child++ } // 如果父节点已经大于左右孩子大值，已堆化 if nums[root] \u003e nums[child] { return } // 孩子节点大值上冒 nums[root], nums[child] = nums[child], nums[root] // 更新父节点到子节点，继续往下比较，不断下沉 root = child } } end := len(arr) - 1 // 从最后一个非叶子节点开始堆化 for i := end / 2; i \u003e= 0; i-- { heapify(arr, i, end) } // 依次弹出元素，然后再堆化，相当于依次把最大值放入尾部 for i := end; i \u003e= 0; i-- { arr[0], arr[i] = arr[i], arr[0] end-- heapify(arr, 0, end) } return arr[:k] } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/:3:0","tags":["算法","排序"],"title":"剑指 Offer 40. 最小的 k 个数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-40.-%E6%9C%80%E5%B0%8F%E7%9A%84-k-%E4%B8%AA%E6%95%B0/"},{"categories":["刷题"],"content":"剑指 Offer 41. 数据流中的中位数 hard 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 输入： [\"MedianFinder\",\"addNum\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[1],[2],[],[3],[]] 输出：[null,null,null,1.50000,null,2.00000] 示例 2： 输入： [\"MedianFinder\",\"addNum\",\"findMedian\",\"addNum\",\"findMedian\"] [[],[2],[],[3],[]] 输出：[null,null,2.00000,null,2.50000] ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-41.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","tags":["算法","排序"],"title":"剑指 Offer 41. 数据流中的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-41.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["刷题"],"content":"大顶堆 + 小顶堆 import ( \"container/heap\" \"sort\" ) type MedianFinder struct { minH iMinHeap // 小顶堆，保存较大的一半 maxH iMaxHeap // 大顶堆，保存较小的一半 } func Constructor() MedianFinder { maxH, minH := iMaxHeap{}, iMinHeap{} heap.Init(\u0026maxH) heap.Init(\u0026minH) finder := MedianFinder{ minH: minH, maxH: maxH, } return finder } func (mf *MedianFinder) AddNum(num int) { if mf.minH.Len() != mf.maxH.Len() { heap.Push(\u0026mf.minH, num) heap.Push(\u0026mf.maxH, heap.Pop(\u0026mf.minH)) } else { heap.Push(\u0026mf.maxH, num) heap.Push(\u0026mf.minH, heap.Pop(\u0026mf.maxH)) } } func (mf *MedianFinder) FindMedian() float64 { if mf.minH.Len() == mf.maxH.Len() { return float64(mf.minH.Peek()+mf.maxH.Peek()) * 0.5 } return float64(mf.minH.Peek()) } // ---------------- 大顶堆/小顶堆 定义 ---------------- // // int类型小顶堆，sort.IntSlice 默认升序，即小顶堆 type iMinHeap struct{ sort.IntSlice } func (h *iMinHeap) Push(x interface{}) { h.IntSlice = append(h.IntSlice, x.(int)) } func (h *iMinHeap) Pop() interface{} { n := h.IntSlice.Len() x := h.IntSlice[n-1] h.IntSlice = h.IntSlice[:n-1] return x } // Peek 查看堆顶元素，不改变结构 func (h iMinHeap) Peek() int { return h.IntSlice[0] } // int类型大顶堆，大顶堆需要重新 Less() 比较器 type iMaxHeap struct{ sort.IntSlice } func (h iMaxHeap) Less(i, j int) bool { return h.IntSlice[i] \u003e h.IntSlice[j] } func (h *iMaxHeap) Push(x interface{}) { h.IntSlice = append(h.IntSlice, x.(int)) } func (h *iMaxHeap) Pop() interface{} { n := h.IntSlice.Len() x := h.IntSlice[n-1] h.IntSlice = h.IntSlice[:n-1] return x } func (h iMaxHeap) Peek() int { return h.IntSlice[0] } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-41.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:1:0","tags":["算法","排序"],"title":"剑指 Offer 41. 数据流中的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-41.-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["刷题"],"content":"剑指 Offer 61. 扑克牌中的顺子 easy 从若干副扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2～10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。 示例 1: 输入: [1,2,3,4,5] 输出: True 示例 2: 输入: [0,0,1,2,5] 输出: True 限制： 数组长度为 5 数组的数取值为 [0, 13] . ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/:0:0","tags":["算法","排序"],"title":"剑指 Offer 61. 扑克牌中的顺子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"},{"categories":["刷题"],"content":"朴素的方法 排序、数 0、看条件 func isStraight(nums []int) bool { sort.Ints(nums) zeroCount := 0 for _, num := range nums { if num == 0 { zeroCount++ } } one, two := 0, 0 for i := zeroCount + 1; i \u003c 5; i++ { { diff := nums[i] - nums[i-1] if diff == 1 { continue } else if diff == 2 { one++ } else if diff == 3 { two++ } else { return false } } } if (one == 0 \u0026\u0026 two == 0) || (one \u003c= zeroCount \u0026\u0026 two == 0) || (one == 0 \u0026\u0026 two*2 \u003c= zeroCount) { return true } else { return false } } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/:1:0","tags":["算法","排序"],"title":"剑指 Offer 61. 扑克牌中的顺子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"},{"categories":["刷题"],"content":"分析 其实不用考虑大小王的个数的，想到 $max-min\u003c5$ 这个点，题目就很简单了 ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/:2:0","tags":["算法","排序"],"title":"剑指 Offer 61. 扑克牌中的顺子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"},{"categories":["刷题"],"content":"哈希表 + 遍历 哈希表判断重复；遍历找最小和最大 func isStraight(nums []int) bool { hash := make(map[int]struct{}) minVal, maxVal := math.MaxInt, math.MinInt for i := 0; i \u003c len(nums); i++ { if nums[i] != 0 { // 把0跳过 if _, ok := hash[nums[i]]; ok { // 有重复 必不可能构成顺子 return false } hash[nums[i]] = struct{}{} if nums[i] \u003c minVal { minVal = nums[i] } if nums[i] \u003e maxVal { maxVal = nums[i] } } } if maxVal-minVal \u003c 5 { return true } return false } ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/:2:1","tags":["算法","排序"],"title":"剑指 Offer 61. 扑克牌中的顺子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"},{"categories":["刷题"],"content":"排序 + 遍历 代码懒得写了 ","date":"2022-02-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/:2:2","tags":["算法","排序"],"title":"剑指 Offer 61. 扑克牌中的顺子","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-61.-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/"},{"categories":["Linux"],"content":"apt-get ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/apt-get/:0:0","tags":["Linux","快速入门"],"title":"apt-get","uri":"/Notes/posts/linux/useful/apt-get/"},{"categories":["Linux"],"content":"基本语法 apt-get [options] command ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/apt-get/:1:0","tags":["Linux","快速入门"],"title":"apt-get","uri":"/Notes/posts/linux/useful/apt-get/"},{"categories":["Linux"],"content":"参数 -h, --help // 查看帮助文档 -v, --version // 查看 apt-get 的版本 -y // 在需要确认的场景中回应 yes -s, --dry-run // 模拟执行并输出结果 -d, --download-only // 把包下载到缓存中而不安装 --only-upgrade // 更新当前版本的包而不是安装新的版本 --no-upgrade // 在执行 install 命令时，不安装已安装包的更新 -q, --quiet // 减少输出 --purge // 配合 remove 命令删除包的配置文件 --reinstall // 重新安装已安装的包或其新版本 ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/apt-get/:1:1","tags":["Linux","快速入门"],"title":"apt-get","uri":"/Notes/posts/linux/useful/apt-get/"},{"categories":["Linux"],"content":"子命令 update update 命令用于重新同步包索引文件，/etc/apt/sources.list 文件中的配置指定了包索引文件的来源。更新了包索引文件后就可以得到可用的包的更新信息和新的包信息。这样我们本地就有了这样的信息：有哪些软件的哪些版本可以从什么地方(源)安装。 update 命令应该总是在安装或升级包之前执行。 install install 命令用来安装或者升级包。每个包都有一个包名，而不是一个完全限定的文件名(例如，在 Debian 系统中，提供的参数是 apt-utils，而不是 apt-utils_1.6.1_amd64.deb)。被安装的包依赖的包也将被安装。配置文件 /etc/apt/sources.list 中包含了用于获取包的源(服务器)。install 命令还可以用来更新指定的包。 upgrade upgrade 命令用于从 /etc/apt/sources.list 中列出的源安装系统上当前安装的所有包的最新版本。在任何情况下，当前安装的软件包都不会被删除，尚未安装的软件包也不会被检索和安装。如果当前安装的包的新版本不能在不更改另一个包的安装状态的情况下升级，则将保留当前版本。必须提前执行 update 命令以便 apt-get 知道已安装的包是否有新版本可用。 注意 update 与 upgrade 的区别： update 是更新软件列表，upgrade 是更新软件。 dist-upgrade 除执行升级功能外，dist-upgrade 还智能地处理与新版本包的依赖关系的变化。apt-get 有一个 “智能” 的冲突解决系统，如果有必要，它将尝试升级最重要的包，以牺牲不那么重要的包为代价。因此，distr -upgrade 命令可能会删除一些包。因此在更新系统中的包时，建议按顺序执行下面的命令： $ apt-get update $ apt-get upgrade -y $ apt-get dis-upgrade -y remove remove 与 install 类似，不同之处是删除包而不是安装包。注意，使用 remove 命令删除一个包会将其配置文件留在系统上。 purge purge 命令与 remove 命令类似，purge 命令在删除包的同时也删除了包的配置文件。 autoremove autoremove 命令用于删除自动安装的软件包，这些软件包当初是为了满足其他软件包对它的依赖关系而安装的，而现在已经不再需要了。 download download 命令把指定包的二进制文件下载到当前目录中。注意，是类似 *.deb 这样的包文件。 clean clean 命令清除在本地库中检索到的包。它从 /var/cache/apt/archives/ 和 /var/cache/apt/archives/partial/ 目录删除除锁文件之外的所有内容。 autoclean 与 clean 命令类似，autoclean 命令清除检索到的包文件的本地存储库。不同之处在于，它只删除不能再下载的软件包文件，而且这些文件在很大程度上是无用的。这允许长时间维护缓存，而不至于大小失控。 source source 命令下载包的源代码。默认会下载最新可用版本的源代码到当前目录中。 changelog changelog 命令尝试下载并显示包的更新日志。 ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/apt-get/:1:2","tags":["Linux","快速入门"],"title":"apt-get","uri":"/Notes/posts/linux/useful/apt-get/"},{"categories":["Linux"],"content":"cloc 统计多种语言代码数据 sudo apt-get install cloc 命令 cloc \u003cfilename\u003e ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/cloc/:0:0","tags":["Linux","快速入门"],"title":"cloc","uri":"/Notes/posts/linux/useful/cloc/"},{"categories":["Linux"],"content":"crontab crontab -e ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/crontab/:0:0","tags":["Linux","快速入门"],"title":"crontab","uri":"/Notes/posts/linux/useful/crontab/"},{"categories":["Linux"],"content":"时间语法 # For details see man 4 crontabs # Example of job definition: # .---------------- minute (0 - 59) # | .------------- hour (0 - 23) # | | .---------- day of month (1 - 31) # | | | .------- month (1 - 12) OR jan,feb,mar,apr ... # | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat # | | | | | # * * * * * user-name command to be executed ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/crontab/:1:0","tags":["Linux","快速入门"],"title":"crontab","uri":"/Notes/posts/linux/useful/crontab/"},{"categories":["Python"],"content":"Django ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:0:0","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"认识 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:1:0","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"概念 URLs: 虽然可以通过单个功能来处理来自每个URL的请求，但是编写单独的视图函数来处理每个资源是更加可维护的。URL映射器用于根据请求URL将HTTP请求重定向到相应的视图。URL映射器还可以匹配出现在URL中的字符串或数字的特定模式，并将其作为数据传递给视图功能。 View: 视图 是一个请求处理函数，它接收HTTP请求并返回HTTP响应。视图通过模型访问满足请求所需的数据，并将响应的格式委托给 模板。 Models: 模型 是定义应用程序数据结构的Python对象，并提供在数据库中管理（添加，修改，删除）和查询记录的机制。 Templates: 模板 是定义文件（例如HTML页面）的结构或布局的文本文件，用于表示实际内容的占位符。一个视图可以使用HTML模板，从数据填充它动态地创建一个HTML页面模型。可以使用模板来定义任何类型的文件的结构; 它不一定是HTML！ ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:1:1","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"开始 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:0","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"创建项目 django-admin startproject mysite 这行代码将会在当前目录下创建一个 mysite 目录。 mysite/ manage.py mysite/ __init__.py settings.py urls.py asgi.py wsgi.py ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:1","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"创建 app py manage.py startapp app_name 这将会创建一个 app 目录 app_name/ __init__.py admin.py # 数据库后台 apps.py # django把项目和app关联起来的文件 migrations/ # 数据库相关 __init__.py models.py tests.py # 单元测试 views.py # 业务逻辑代码 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:2","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"运行服务器 python manage.py runserver 0.0.0.0:8000 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:3","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"生成迁移文件 python manage.py makemigrations 为模型的改变生成迁移文件 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:4","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"创建模型对应的数据表 python manage.py migrate 该命令选中未执行过的迁移，将对模型的更改同步到数据库结构上 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:5","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"创建管理账号 python manage.py createsuperuser ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:2:6","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"urls urls.py：URLconf 文件 from django.contrib import admin from django.urls import path, include from app01 import views urlpatterns = [ path('admin/', admin.site.urls), path('app01/', views.test_view), path('app02/', include('app02.urls')) ] ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:3:0","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"Models ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:4:0","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"认识 ORM 对象关系映射(Object Relational Mapping)，它的实质就是将关系数据（库）中的业务数据用对象的形式表示出来，并通过面向对象（Object-Oriented）的方式将这些对象组织起来，实现系统业务逻辑的过程 映射(Mapping) —— 把表结构映射成类 对象 —— 像操作类对象一样，操作数据库里的数据 SQL 语句映射，实现了代码与数据库操作的解耦合，在 Django 中体现在 Models.py 中 Model 模型是真实数据的简单明确的描述。它包含了储存的数据所必要的字段和行为 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:4:1","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"views 每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 HttpResponse 对象，或者抛出一个异常，比如 Http404 。至于你还想干些什么，随便你。 你的视图可以从数据库里读取记录，可以使用一个模板引擎（比如 Django 自带的，或者其他第三方的），可以生成一个 PDF 文件，可以输出一个 XML，创建一个 ZIP 文件，你可以做任何你想做的事，使用任何你想用的 Python 库。 Django 只要求返回的是一个 HttpResponse ，或者抛出一个异常 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/django/:5:0","tags":["Python","后端"],"title":"Django","uri":"/Notes/posts/python/web-backend/django/"},{"categories":["Python"],"content":"FastAPI ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:0:0","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"认识 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:1:0","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"运行 uvicorn main:app --reload main：main.py 文件（一个 Python「模块」）。 app：在 main.py 文件中通过 app = FastAPI() 创建的对象。 --reload：让服务器在更新代码后重新启动。仅在开发时使用该选项 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:1:1","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"查看 API 文档 交互式文档：url/docs 可选的文档：url/redoc ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:1:2","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"特性 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:0","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"基本格式 from fastapi import FastAPI app = FastAPI() @app.get(\"/\") # 路径操作装饰器 async def root(): # 路径操作函数 return {\"message\": \"Hello World\"} ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:1","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"路径参数 @app.get(\"/items/{item_id}\") async def read_item(item_id): # 无类型 return {\"item_id\": item_id} @app.get(\"/items/{item_id}\") async def read_item(item_id: int): # 有类型 return {\"item_id\": item_id} 关于路径顺序： 由于路径操作是按顺序依次运行的，你需要确保路径 /users/me 声明在路径 /users/{user_id}之前 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:2","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"枚举 from enum import Enum from fastapi import FastAPI class ModelName(str, Enum): alexnet = \"alexnet\" resnet = \"resnet\" lenet = \"lenet\" app = FastAPI() @app.get(\"/models/{model_name}\") async def get_model(model_name: ModelName): if model_name == ModelName.alexnet: return {\"model_name\": model_name, \"message\": \"Deep Learning FTW!\"} if model_name.value == \"lenet\": return {\"model_name\": model_name, \"message\": \"LeCNN all the images\"} return {\"model_name\": model_name, \"message\": \"Have some residuals\"} ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:3","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"查询参数 声明不属于路径参数的其他函数参数时，它们将被自动解释为\"查询字符串\"参数 from fastapi import FastAPI app = FastAPI() fake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}] @app.get(\"/items/\") async def read_item(skip: int = 0, limit: int = 10): return fake_items_db[skip : skip + limit] 查询字符串是键值对的集合，这些键值对位于 URL 的 ？ 之后，并以 \u0026 符号分隔。 http://127.0.0.1:8000/items/?skip=0\u0026limit=10 可选参数 通过同样的方式，你可以将它们的默认值设置为 None 来声明可选查询参数： from typing import Optional from fastapi import FastAPI app = FastAPI() @app.get(\"/items/{item_id}\") async def read_item(item_id: str, q: Optional[str] = None): if q: return {\"item_id\": item_id, \"q\": q} return {\"item_id\": item_id} 在这个例子中，函数参数 q 将是可选的，并且默认值为 None。 必需、不必需与可选 当你想让一个查询参数成为必需的，不声明任何默认值就可以 如果你不想添加一个特定的值，而只是想使该参数成为可选的，则将默认值设置为 None @app.get(\"/items/{item_id}\") async def read_user_item( item_id: str, needy: str, skip: int = 0, limit: Optional[int] = None ): item = {\"item_id\": item_id, \"needy\": needy, \"skip\": skip, \"limit\": limit} return item needy，一个必需的 str 类型参数。意味着必须传入 skip，一个默认值为 0 的 int 类型参数。意味着不必须传入，但是会存在 limit，一个可选的 int 类型参数。意味着不传入就不存在 查询参数列表 当你使用 Query 显式地定义查询参数时，你还可以声明它去接收一组值，或换句话来说，接收多个值 q: Optional[List[str]] = Query(None) 输入类似于 http://localhost:8000/items/?q=foo\u0026q=bar 的 url 即可接收到多个查询值 你还可以定义在没有任何给定值时的默认 list 值 q: List[str] = Query([\"foo\", \"bar\"]) 你也可以直接使用 list 代替 List [str] q: list = Query([]) 在这种情况下，将不会检查列表的内容。 例如，List[int] 将检查（并记录到文档）列表的内容必须是整数。但是单独的 list 不会。 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:4","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"请求体 request 请求体是客户端发送给 API 的数据。响应体是 API 发送给客户端的数据。 你的 API 几乎总是要发送响应体。但是客户端并不总是需要发送请求体。 模板 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None app = FastAPI() @app.post(\"/items/\") async def create_item(item: Item): return item 导入 Pydantic 的 BaseModel 创建数据模型 将你的数据模型声明为继承自 BaseModel 的类。 使用标准的 Python 类型来声明所有属性 将模型声明为参数 访问模型属性 @app.post(\"/items/\") async def create_item(item: Item): item_dict = item.dict() if item.tax: price_with_tax = item.price + item.tax item_dict.update({\"price_with_tax\": price_with_tax}) return item_dict 请求体加参数 你可以同时声明路径参数和请求体。 FastAPI 将识别出与路径参数匹配的函数参数应从路径中获取，而声明为 Pydantic 模型的函数参数应从请求体中获取。 @app.put(\"/items/{item_id}\") async def create_item(item_id: int, item: Item): # Item是自己定义的模型 return {\"item_id\": item_id, **item.dict()} 甚至可以做到请求体 + 路径参数 + 查询参数 @app.put(\"/items/{item_id}\") async def create_item(item_id: int, item: Item, q: Optional[str] = None): result = {\"item_id\": item_id, **item.dict()} if q: result.update({\"q\": q}) return result 函数参数将依次按如下规则进行识别： 如果在路径中也声明了该参数，它将被用作路径参数。 如果参数属于单一类型（比如 int、float、str、bool 等）它将被解释为查询参数。 如果参数的类型被声明为一个 Pydantic 模型，它将被解释为请求体。 多个请求体 多个请求体 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None class User(BaseModel): username: str full_name: Optional[str] = None @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item, user: User): results = {\"item_id\": item_id, \"item\": item, \"user\": user} return results 在这种情况下，FastAPI 将注意到该函数中有多个请求体参数（两个 Pydantic 模型参数）。 因此，它将使用参数名称作为请求体中的键（字段名称），并期望一个类似于以下内容的请求体： { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }, \"user\": { \"username\": \"dave\", \"full_name\": \"Dave Grohl\" } } 添加额外请求体 body 为了扩展先前的模型，你可能决定除了 item 和 user 之外，还想在同一请求体中具有另一个键 importance。 你可以使用 Body 指示 FastAPI 将其作为请求体的另一个键进行处理 from typing import Optional from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None class User(BaseModel): username: str full_name: Optional[str] = None @app.put(\"/items/{item_id}\") async def update_item( item_id: int, item: Item, user: User, importance: int = Body(...) ): results = {\"item_id\": item_id, \"item\": item, \"user\": user, \"importance\": importance} return results 在这种情况下，FastAPI 将期望像这样的请求体： { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 }, \"user\": { \"username\": \"dave\", \"full_name\": \"Dave Grohl\" }, \"importance\": 5 } 嵌入单个请求体参数 假设你只有一个来自 Pydantic 模型 Item 的请求体参数 item。 默认情况下，FastAPI 将直接期望这样的请求体。 但是，如果你希望它期望一个拥有 item 键并在值中包含模型内容的 JSON，就像在声明额外的请求体参数时所做的那样，则可以使用一个特殊的 Body 参数 embed： item: Item = Body(..., embed=True) 比如： from typing import Optional from fastapi import Body, FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: Optional[str] = None price: float tax: Optional[float] = None @app.put(\"/items/{item_id}\") async def update_item(item_id: int, item: Item = Body(..., embed=True)): results = {\"item_id\": item_id, \"item\": item} return results 在这种情况下，FastAPI 将期望像这样的请求体： { \"item\": { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 } } 而不是： { \"name\": \"Foo\", \"description\": \"The pretender\", \"price\": 42.0, \"tax\": 3.2 } 总结 你可以添加多个请求体参数到路径操作函数中，即使一个请求只能有一个请求体。 但是 FastAPI 会处理它，在函数中为你提供正确的数据，并在路径操作中校验并记录正确的模式。 你还可以声明将作为请求体的一部分所接收的单一值。 你还可以指示 FastAPI 在仅声明了一个请求体参数的情况下，将原本的请求体嵌入到一个键中。 请求体字段 与使用 Query、Path 和 Body 在路径操作函数中声明额外的校验和元数据的方式相同，你可以使用 Pydantic 的 Field 在 Pydantic 模型内部声明校验和元数据。 from pydantic import Field class Item(BaseModel): name: str description: Optional[str] = Field( None, title=\"The description of the item\", max_length=300 ) price: float = Field(..., gt=0, description=\"The price mu","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:5","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"校验 对查询参数的校验 除了可以设置参数是否可选，还能对参数设置其他的约束条件 from fastapi import Query async def read_items(q: Optional[str] = Query(None, min_length=3, max_length=50)): # ... 其中 q: str = Query(None) 使得参数可选，等同于： q: str = None 甚至还能用正则。。。 q: Optional[str] = Query(None, min_length=3, max_length=50, regex=\"^fixedquery$\") 默认值可以更换 q: str = Query(\"fixedquery\", min_length=3) 若要声明为必须参数，使用 ... q: str = Query(..., min_length=3) 声明更多元数据 你可以添加更多有关该参数的信息。 这些信息将包含在生成的 OpenAPI 模式中，并由文档用户界面和外部工具所使用 添加 title 与 description q: Optional[str] = Query( None, title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, ) 别名参数 要添加含有 “-” 之类被 python 所禁止的变量名，可以用 alias 参数声明一个别名，该别名将用于在 URL 中查找查询参数值： item_query: Optional[str] = Query(None, alias=\"item-query\") 可以传入类似 http://127.0.0.1:8000/items/?item-query=foobaritems 的参数了 弃用参数 现在假设你不再喜欢此参数。 你不得不将其保留一段时间，因为有些客户端正在使用它，但你希望文档清楚地将其展示为已弃用。 那么将参数 deprecated=True 传入 Query q: Optional[str] = Query( None, alias=\"item-query\", title=\"Query string\", description=\"Query string for the items to search in the database that have a good match\", min_length=3, max_length=50, regex=\"^fixedquery$\", deprecated=True, ) 对路径参数的校验 首先，从 fastapi 导入 Path from fastapi import FastAPI, Path, Query 路径参数总是必需的，因为它必须是路径的一部分。 所以，你应该在声明时使用 ... 将其标记为必需参数。 然而，即使你使用 None 声明路径参数或设置一个其他默认值也不会有任何影响，它依然会是必需参数 模板如下 @app.get(\"/items/{item_id}\") async def read_items( item_id: int = Path(..., title=\"The ID of the item to get\"), ): # ... 为了解决 “带有「默认值」的参数放在没有「默认值」的参数之前，Python 将会报错” 的问题，API 中的参数可以自由排布 @app.get(\"/items/{item_id}\") async def read_items( q: str, item_id: int = Path(..., title=\"The ID of the item to get\") ): # ... 如果不想这样，传递 * 作为函数的第一个参数 Python 不会对该 * 做任何事情，但是它将知道之后的所有参数都应作为关键字参数（键值对），也被称为 kwargs，来调用。即使它们没有默认值 async def read_items( *, item_id: int = Path(..., title=\"The ID of the item to get\"), q: str ): # ... 数值校验 gt：大于（greater than） ge：大于等于（greater than or equal） lt：小于（less than） le：小于等于（less than or equal） async def read_items( *, item_id: int = Path(..., title=\"The ID of the item to get\", gt=0, le=1000), q: str, ): # ... ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:6","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"Cookie 参数 from fastapi import Cookie 可以像定义 Query 参数和 Path 参数一样来定义 Cookie 参数 @app.get(\"/items/\") async def read_items(ads_id: Optional[str] = Cookie(None)): return {\"ads_id\": ads_id} Cookie 、Path 、Query 是兄弟类，它们都继承自公共的 Param 类 但请记住，当你从 fastapi 导入的 Query、Path、Cookie 或其他参数声明函数，这些实际上是返回特殊类的函数。 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:7","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"Header 参数 from fastapi import Header 使用和 Path, Query and Cookie 一样的结构定义 header 参数 @app.get(\"/items/\") async def read_items(user_agent: Optional[str] = Header(None)): return {\"User-Agent\": user_agent} 特性 默认情况下, Header 将把参数名称的字符从下划线 (_) 转换为连字符 (-) 来提取并记录 headers 同时，HTTP headers 是大小写不敏感的，因此，因此可以使用标准Python样式(也称为 “snake_case”)声明它们 若需要禁用下划线到连字符的自动转换 Header(None, convert_underscores=False) 接受重复值 相同的 header 具有多个值时，可以在类型声明中使用一个 list 来定义这些情况 比如，为了声明一个 X-Token header 可以出现多次，你可以这样写 @app.get(\"/items/\") async def read_items(x_token: Optional[List[str]] = Header(None)): return {\"X-Token values\": x_token} 如果你与路径操作通信时发送两个HTTP headers，就像： X-Token: foo X-Token: bar 响应会是: { \"X-Token values\": [ \"bar\", \"foo\" ] } ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:8","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"响应 response 响应模型 response_model 使用 response_model 参数来声明用于响应的模型，也就是要向前端返回的数据类型 这样做的主要目的是确保私有数据在返回时被过滤掉 FastAPI 将使用此 response_model 来： 将输出数据转换为其声明的类型 校验数据。 在 OpenAPI 的路径操作中为响应添加一个 JSON Schema。 并在自动生成文档系统中使用 class UserIn(BaseModel): username: str password: str email: EmailStr full_name: Optional[str] = None class UserOut(BaseModel): username: str email: EmailStr full_name: Optional[str] = None @app.post(\"/user/\", response_model=UserOut) async def create_user(user: UserIn): return user FastAPI 将会负责过滤掉未在输出模型中声明的所有数据 过滤默认值 响应模型也可以拥有默认值 你可以设置路径操作装饰器的 response_model_exclude_unset=True 参数，以便在响应的返回数据中去除默认值 @app.get(\"/items/{item_id}\", response_model=Item, response_model_exclude_unset=True) 指定返回的数据 使用路径操作装饰器的 response_model_include 和 response_model_exclude 参数 class Item(BaseModel): name: str description: Optional[str] = None price: float tax: float = 10.5 items = { \"foo\": {\"name\": \"Foo\", \"price\": 50.2}, \"bar\": {\"name\": \"Bar\", \"description\": \"The Bar fighters\", \"price\": 62, \"tax\": 20.2}, \"baz\": { \"name\": \"Baz\", \"description\": \"There goes my baz\", \"price\": 50.2, \"tax\": 10.5, }, } @app.get( \"/items/{item_id}/name\", response_model=Item, response_model_include={\"name\", \"description\"}, ) async def read_item_name(item_id: str): return items[item_id] @app.get(\"/items/{item_id}/public\", response_model=Item, response_model_exclude={\"tax\"}) async def read_item_public_data(item_id: str): return items[item_id] 可以用 set，也可以用 list 多个模型 拥有多个相关的模型是很常见的。 对用户模型来说尤其如此，因为： 输入模型需要拥有密码属性。 输出模型不应该包含密码。 数据库模型很可能需要保存密码的哈希值 下面是应该如何根据它们的密码字段以及使用位置去定义模型的大概思路 from typing import Optional from fastapi import FastAPI from pydantic import BaseModel, EmailStr app = FastAPI() class UserBase(BaseModel): username: str email: EmailStr full_name: Optional[str] = None class UserIn(UserBase): password: str class UserOut(UserBase): pass class UserInDB(UserBase): hashed_password: str def fake_password_hasher(raw_password: str): return \"supersecret\" + raw_password def fake_save_user(user_in: UserIn): hashed_password = fake_password_hasher(user_in.password) user_in_db = UserInDB(**user_in.dict(), hashed_password=hashed_password) print(\"User saved! ..not really\") return user_in_db @app.post(\"/user/\", response_model=UserOut) async def create_user(user_in: UserIn): user_saved = fake_save_user(user_in) return user_saved 最终的结果如下 UserInDB( username = user_dict[\"username\"], password = user_dict[\"password\"], email = user_dict[\"email\"], full_name = user_dict[\"full_name\"], hashed_password = hashed_password, ) Union 你可以将一个响应声明为两种类型的 Union，这意味着该响应将是两种类型中的任何一种。 这将在 OpenAPI 中使用 anyOf 进行定义。 from typing import Union from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class BaseItem(BaseModel): description: str type: str class CarItem(BaseItem): type = \"car\" class PlaneItem(BaseItem): type = \"plane\" size: int items = { \"item1\": {\"description\": \"All my friends drive a low rider\", \"type\": \"car\"}, \"item2\": { \"description\": \"Music is my aeroplane, it's my aeroplane\", \"type\": \"plane\", \"size\": 5, }, } @app.get(\"/items/{item_id}\", response_model=Union[PlaneItem, CarItem]) async def read_item(item_id: str): return items[item_id] 定义一个 Union 类型时，首先包括最详细的类型，然后是不太详细的类型。在上面的示例中，更详细的 PlaneItem 位于 Union[PlaneItem，CarItem] 中的 CarItem 之前 列表形式的响应模型 可以用同样的方式声明由对象列表构成的响应 from typing import List from fastapi import FastAPI from pydantic import BaseModel app = FastAPI() class Item(BaseModel): name: str description: str items = [ {\"name\": \"Foo\", \"description\": \"There comes my hero\"}, {\"name\": \"Red\", \"description\": \"It's my aeroplane\"}, ] @app.get(\"/items/\", response_model=List[Item]) async def read_items(): return items 任意 dict 构成的响应 你还可以使用一个任意的普通 dict 声明响应，仅声明键和值的类型，而不使用 Pydantic 模型。 如果你事先不知道有效的字段/属性名称（对于 Pydantic 模型是必需的），这将很有用。 在这种情况下，你可以使用 typing.Dict： from typing import Dict from fastapi import FastAPI app = FastAPI() @app.get(\"/keyword-weights/\", response_model=Dict[str, float]) async def read_keyword_weights(): return {\"foo\": 2.3, \"bar\": 3.4} 响应状态码 可以在路径操作器中使用 status_code 参数来声明用于响应的 HTTP 状态码 @a","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:9","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"路径修饰器的其他参数 tags 传递 list 或 str 参数 Tags will be added to the OpenAPI schema and used by the automatic documentation interfaces @app.post(\"/items/\", response_model=Item, tags=[\"items\"]) async def create_item(item: Item): return item @app.get(\"/items/\", tags=[\"items\"]) async def read_items(): return [{\"name\": \"Foo\", \"price\": 42}] @app.get(\"/users/\", tags=[\"users\"]) async def read_users(): return [{\"username\": \"johndoe\"}] Summary and description @app.post( \"/items/\", response_model=Item, summary=\"Create an item\", description=\"Create an item with all the information, name, description, price, tax and a set of unique tags\", ) async def create_item(item: Item): return item Description from docstring You can write Markdown in the docstring, it will be interpreted and displayed correctly @app.post(\"/items/\", response_model=Item, summary=\"Create an item\") async def create_item(item: Item): \"\"\" Create an item with all the information: - **name**: each item must have a name - **description**: a long description - **price**: required - **tax**: if the item doesn't have tax, you can omit this - **tags**: a set of unique tag strings for this item \"\"\" return item Response description @app.post( \"/items/\", response_model=Item, summary=\"Create an item\", response_description=\"The created item\", ) Notice that response_description refers specifically to the response, the description refers to the path operation in general. deprecated 标记已废弃的 API @app.get(\"/elements/\", tags=[\"items\"], deprecated=True) async def read_elements(): return [{\"item_id\": \"Foo\"}] ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:2:10","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"ORM 使用 sqlalchemy ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:3:0","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"目录格式 数据库操作 Demo：https://www.jianshu.com/p/ca0d29b6e127 . └── sql_app ├── __init__.py # 声明模块 ├── crud.py # 增删查改函数 ├── database.py ├── main.py ├── models.py # 数据库表格模板 └── schemas.py ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:3:1","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"跨域资源共享 跨域资源共享指浏览器中运行的前端拥有与后端通信的 JavaScript 代码，而后端处于与前端不同的「源」的情况。 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:4:0","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"源 源是协议（http，https）、域（myapp.com，localhost，localhost.tiangolo.com）以及端口（80、443、8080）的组合。 因此，这些都是不同的源： http://localhost https://localhost http://localhost:8080 即使它们都在 localhost 中，但是它们使用不同的协议或者端口，所以它们都是不同的「源」。 后端必须有一个「允许的源」列表，才能接收来自前端的请求 可以使用 \"*\"（一个「通配符」）声明这个列表，表示全部都是允许的，但为了一切都能正常工作，最好显式地指定允许的源 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:4:1","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"CORSMiddleware 你可以在 FastAPI 应用中使用 CORSMiddleware 来配置它。 导入 CORSMiddleware。 创建一个允许的源列表（由字符串组成）。 将其作为「中间件」添加到你的 FastAPI 应用中。 你也可以指定后端是否允许： 凭证（授权 headers，Cookies 等）。 特定的 HTTP 方法（POST，PUT）或者使用通配符 \"*\" 允许所有方法。 特定的 HTTP headers 或者使用通配符 \"*\" 允许所有 headers。 from fastapi import FastAPI from fastapi.middleware.cors import CORSMiddleware app = FastAPI() origins = [ \"http://localhost.tiangolo.com\", \"https://localhost.tiangolo.com\", \"http://localhost\", \"http://localhost:8080\", ] app.add_middleware( CORSMiddleware, allow_origins=origins, allow_credentials=True, allow_methods=[\"*\"], allow_headers=[\"*\"], ) @app.get(\"/\") async def main(): return {\"message\": \"Hello World\"} 参数 allow_origins - 一个允许跨域请求的源列表。例如 ['https://example.org', 'https://www.example.org']。你可以使用 ['*'] 允许任何源。 allow_origin_regex - 一个正则表达式字符串，匹配的源允许跨域请求。例如 'https://.*\\.example\\.org'。 allow_methods - 一个允许跨域请求的 HTTP 方法列表。默认为 ['GET']。你可以使用 ['*'] 来允许所有标准方法。 allow_headers - 一个允许跨域请求的 HTTP 请求头列表。默认为 []。你可以使用 ['*'] 允许所有的请求头。Accept、Accept-Language、Content-Language 以及 Content-Type 请求头总是允许 CORS 请求。 allow_credentials - 指示跨域请求支持 cookies。默认是 False。另外，允许凭证时 allow_origins 不能设定为 ['*']，必须指定源。 expose_headers - 指示可以被浏览器访问的响应头。默认为 []。 max_age - 设定浏览器缓存 CORS 响应的最长时间，单位是秒。默认为 600。 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:4:2","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"文件结构 . ├── app │ ├── __init__.py │ ├── main.py │ ├── dependencies.py │ └── routers │ │ ├── __init__.py │ │ ├── items.py │ │ └── users.py │ └── internal │ ├── __init__.py │ └── admin.py ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:5:0","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"路径分离 APIRouter 可以将 APIRouter 视为一个「迷你 FastAPI」类 from fastapi import APIRouter router = APIRouter() @router.get(\"/users/\", tags=[\"users\"]) async def read_users(): return [{\"username\": \"Rick\"}, {\"username\": \"Morty\"}] 可以在 APIRouter 中增添配置，免去将配置项添加到每一个路径操作中的烦恼 prefix：父级路径 tags：标签 responses dependencies：注入的依赖项 仍然可以添加更多将会应用于特定的路径操作的 tags，以及一些特定于该路径操作的额外 responses router = APIRouter( prefix=\"/items\", tags=[\"items\"], dependencies=[Depends(get_token_header)], responses={404: {\"description\": \"Not found\"}}, ) fake_items_db = {\"plumbus\": {\"name\": \"Plumbus\"}, \"gun\": {\"name\": \"Portal Gun\"}} @router.get(\"/\") async def read_items(): return fake_items_db @router.get(\"/{item_id}\") async def read_item(item_id: str): if item_id not in fake_items_db: raise HTTPException(status_code=404, detail=\"Item not found\") return {\"name\": fake_items_db[item_id][\"name\"], \"item_id\": item_id} ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:5:1","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"主体 主题通常位于项目根目录，名字为 main.py from fastapi import Depends, FastAPI from .dependencies import get_query_token, get_token_header from .internal import admin from .routers import items, users app = FastAPI(dependencies=[Depends(get_query_token)]) app.include_router(users.router) app.include_router(items.router) app.include_router( admin.router, prefix=\"/admin\", tags=[\"admin\"], dependencies=[Depends(get_token_header)], responses={418: {\"description\": \"I'm a teapot\"}}, ) # 没必要 @app.get(\"/\") async def root(): return {\"message\": \"Hello Bigger Applications!\"} 「相对导入」： from .routers import items, users 「绝对导入」： from app.routers import items, users ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:5:2","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"依赖项 声明依赖项 函数式 from typing import Optional from fastapi import Depends, FastAPI app = FastAPI() async def common_parameters(q: Optional[str] = None, skip: int = 0, limit: int = 100): return {\"q\": q, \"skip\": skip, \"limit\": limit} @app.get(\"/items/\") async def read_items(commons: dict = Depends(common_parameters)): return commons @app.get(\"/users/\") async def read_users(commons: dict = Depends(common_parameters)): return commons 只能传给 Depends 一个参数。 且该参数必须是可调用对象，比如函数。 该函数接收的参数和路径操作函数的参数一样 对象式 from typing import Optional from fastapi import Depends, FastAPI app = FastAPI() fake_items_db = [{\"item_name\": \"Foo\"}, {\"item_name\": \"Bar\"}, {\"item_name\": \"Baz\"}] class CommonQueryParams: def __init__(self, q: Optional[str] = None, skip: int = 0, limit: int = 100): self.q = q self.skip = skip self.limit = limit @app.get(\"/items/\") async def read_items(commons: CommonQueryParams = Depends(CommonQueryParams)): response = {} if commons.q: response.update({\"q\": commons.q}) items = fake_items_db[commons.skip : commons.skip + commons.limit] response.update({\"items\": items}) return response Instead of writing: commons: CommonQueryParams = Depends(CommonQueryParams) … you can also write: commons: CommonQueryParams = Depends() 子依赖项 from typing import Optional from fastapi import Cookie, Depends, FastAPI app = FastAPI() def query_extractor(q: Optional[str] = None): return q def query_or_cookie_extractor( q: str = Depends(query_extractor), last_query: Optional[str] = Cookie(None) ): if not q: return last_query return q @app.get(\"/items/\") async def read_query(query_or_default: str = Depends(query_or_cookie_extractor)): return {\"q_or_cookie\": query_or_default} query_or_cookie_extractor 的参数： 尽管该函数自身是依赖项，但还声明了另一个依赖项（它「依赖」于其他对象） 该函数依赖 query_extractor, 并把 query_extractor 的返回值赋给参数 q 同时，该函数还声明了类型是 str 的可选 cookie（last_query） 用户未提供查询参数 q 时，则使用上次使用后保存在 cookie 中的查询 如果在同一个路径操作 多次声明了同一个依赖项，例如，多个依赖项共用一个子依赖项，FastAPI 在处理同一请求时，只调用一次该子依赖项。 路径操作装饰器依赖项 有时，我们并不需要在路径操作函数中使用依赖项的返回值。或者说，有些依赖项不返回值，但仍要执行或解析该依赖项。 对于这种情况，不必在声明路径操作函数的参数时使用 Depends，而是可以在路径操作装饰器中添加一个由 dependencies 组成的 list。 from fastapi import Depends, FastAPI, Header, HTTPException app = FastAPI() async def verify_token(x_token: str = Header(...)): if x_token != \"fake-super-secret-token\": raise HTTPException(status_code=400, detail=\"X-Token header invalid\") async def verify_key(x_key: str = Header(...)): if x_key != \"fake-super-secret-key\": raise HTTPException(status_code=400, detail=\"X-Key header invalid\") return x_key @app.get(\"/items/\", dependencies=[Depends(verify_token), Depends(verify_key)]) async def read_items(): return [{\"item\": \"Foo\"}, {\"item\": \"Bar\"}] 路径操作装饰器依赖项（以下简称为**“路径装饰器依赖项”**）的执行或解析方式和普通依赖项一样，但就算这些依赖项会返回值，它们的值也不会传递给路径操作函数。 全局依赖项 有时，我们要为整个应用添加依赖项 app = FastAPI(dependencies=[Depends(verify_token), Depends(verify_key)]) 一些在应用程序的好几个地方所使用的依赖项，可以放在它们自己的 dependencies 模块（app/dependencies.py）中 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:5:3","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"测试 from fastapi.testclient import TestClient Import TestClient. Create a TestClient passing to it your FastAPI application. Create functions with a name that starts with test_ (this is standard pytest conventions). Use the TestClient object the same way as you do with requests. Write simple assert statements with the standard Python expressions that you need to check (again, standard pytest). from fastapi import FastAPI from fastapi.testclient import TestClient app = FastAPI() @app.get(\"/\") async def read_main(): return {\"msg\": \"Hello World\"} client = TestClient(app) def test_read_main(): response = client.get(\"/\") assert response.status_code == 200 assert response.json() == {\"msg\": \"Hello World\"} ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/fastapi/:5:4","tags":["Python","后端"],"title":"FastAPI","uri":"/Notes/posts/python/web-backend/fastapi/"},{"categories":["Python"],"content":"Flask ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/flask/:0:0","tags":["Python","后端"],"title":"Flask","uri":"/Notes/posts/python/web-backend/flask/"},{"categories":["Python"],"content":"例子 ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/flask/:1:0","tags":["Python","后端"],"title":"Flask","uri":"/Notes/posts/python/web-backend/flask/"},{"categories":["Python"],"content":"初始化 from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' app.run(debug=True) # 自动以调试方式运行 若想要在命令行中控制运行 $ set FLASK_APP=hello.py $ flask run 若想要其他机器访问 app.run(host=0.0.0.0) ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/flask/:1:1","tags":["Python","后端"],"title":"Flask","uri":"/Notes/posts/python/web-backend/flask/"},{"categories":["Python"],"content":"路由 @app.route('/') def hello_world(): return 'Hello, World!' @app.route('/hello/\u003canything\u003e') def hello_anything(anything): return 'Hello %s' % anything @app.route('/plus/\u003cint:number\u003e') def wow_number(number): return '%splus %sis %s' % (number, number, (number+number)) @app.route('/json/\u003cstring:data\u003e') def json(data): return {'data': data} string （缺省值） 接受任何不包含斜杠的文本 int 接受正整数 float 接受正浮点数 path 类似 string ，但可以包含斜杠 uuid 接受 UUID 字符串 唯一的 URL 与重定向 以下两条规则的不同之处在于是否使用尾部的斜杠。: @app.route('/projects/') def projects(): return 'The project page' @app.route('/about') def about(): return 'The about page' projects 的 URL 是中规中矩的，尾部有一个斜杠，看起来就如同一个文件夹。 访问一个没有斜杠结尾的 URL 时 Flask 会自动进行重定向，帮你在尾部加上一个斜杠。 about 的 URL 没有尾部斜杠，因此其行为表现与一个文件类似。如果访问这个 URL 时添加了尾部斜杠就会得到一个 404 错误。这样可以保持 URL 唯一，并帮助 搜索引擎避免重复索引同一页面。 Flask HTTP方法 from flask import request @app.route('/login', methods=['GET', 'POST']) def login(): if request.method == 'POST': return do_the_login() else: return show_the_login_form() 方法 名称 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 3 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 4 DELETE 请求服务器删除指定的页面。 重定向 网页跳转 from flask import abort, redirect @app.route('/bilibili') def index(): return redirect(\"https://www.bilibili.com\") POST @app.route('/test/post', methods=['POST']) def post(): print('gooooooood') my_json = request.get_json() print(my_json) name = my_json.get('name')+u'大帅哥' age = my_json.get('age') if all([name, age]): # return my_json.get('name') + ' is ' + str(my_json.get('age')) + ' years old.' return jsonify(name=name, age=age) else: return \"Request failed!\" ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/flask/:1:2","tags":["Python","后端"],"title":"Flask","uri":"/Notes/posts/python/web-backend/flask/"},{"categories":["Python"],"content":"Cookies 要访问 cookies ，可以使用 cookies 属性。可以使用响应 对象 的 set_cookie 方法来设置 cookies 。 请求对象的 cookies 属性是一个包含了客户端传输的所有 cookies 的字典。 在 Flask 中，如果使用会话（Session），那么就不要直接使用 cookies ，因为会话比较安全一些。 读取 cookies: from flask import request @app.route('/') def index(): username = request.cookies.get('username') # use cookies.get(key) instead of cookies[key] to not get a # KeyError if the cookie is missing. 储存 cookies: from flask import make_response @app.route('/') def index(): resp = make_response(render_template(...)) resp.set_cookie('username', 'the username') return resp ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/flask/:1:3","tags":["Python","后端"],"title":"Flask","uri":"/Notes/posts/python/web-backend/flask/"},{"categories":["Python"],"content":"Sessions from . import admin from app import db from flask import request, jsonify, current_app, session from app.models import Admin, AdminLoginLog from app.utils.tool import admin_login_required # 登录 @admin.route(\"/login\", methods=[\"POST\"]) def login(): \"\"\"用户的登录\"\"\" # 获取参数 req_dict = request.get_json() username = req_dict.get(\"username\") password = req_dict.get(\"password\") # 校验参数 # 参数完整的校验 if not all([username, password]): return jsonify(re_code=400, msg=\"参数不完整\") try: admin_info = Admin.query.filter_by(username=username).first() except Exception as e: current_app.logger.error(e) return jsonify(re_code=400, msg=\"获取用户信息失败\") # 用数据库的密码与用户填写的密码进行对比验证 if admin_info is None or admin_info.password != password: return jsonify(re_code=400, msg=\"用户名或密码错误\") # 添加管理员登录日志 ip_addr = request.remote_addr # 获取管理员登录的ip admin_login_log = AdminLoginLog(admin_id=admin_info.id, ip=ip_addr) try: db.session.add(admin_login_log) db.session.commit() except: db.session.rollback() # 如果验证相同成功，保存登录状态， 在session中 session[\"username\"] = admin_info.username session[\"admin_id\"] = admin_info.id session[\"avatar\"] = admin_info.avatar return jsonify(re_code=200, msg=\"登录成功\") # 检查登陆状态 @admin.route(\"/session\", methods=[\"GET\"]) def check_login(): \"\"\"检查登陆状态\"\"\" # 尝试从session中获取用户的名字 username = session.get(\"username\") admin_id = session.get('admin_id') avatar = session.get(\"avatar\") # 如果session中数据username名字存在，则表示用户已登录，否则未登录 if username is not None: return jsonify(re_code=200, msg=\"true\", data={\"username\": username, \"admin_id\": admin_id, \"avatar\": avatar}) else: return jsonify(re_code=400, msg=\"管理员未登录\") # 登出 @admin.route(\"/session\", methods=[\"DELETE\"]) @admin_login_required def logout(): \"\"\"登出\"\"\" # 清除session数据 session.clear() return jsonify(re_code=200, msg=\"成功退出登录!\") ","date":"2021-10-23","objectID":"/Notes/posts/python/web-backend/flask/:1:4","tags":["Python","后端"],"title":"Flask","uri":"/Notes/posts/python/web-backend/flask/"},{"categories":["前端"],"content":"flex 布局 https://css-tricks.com/snippets/css/a-guide-to-flexbox/ Flex 是 Flexible Box 的缩写，意为“弹性布局”或者“弹性盒子”，是 CSS3 中的一种新的布局模式，可以简便、完整、响应式地实现各种页面布局，当页面需要适应不同的屏幕大小以及设备类型时非常适用。 ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:0:0","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"基本概念 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称“容器”。 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称“项目”。 容器默认存在两根轴，分别为水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置叫做 main start，结束位置叫做 main end； 交叉轴的开始位置叫做 cross start，结束位置叫做 cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做 main size，占据的交叉轴空间叫做 cross size。 可以通过将元素的 display 属性设置为 flex（生成块级 flex 容器）或 inline-flex（生成类似 inline-block 的行内块级 flex 容器）。 当一个元素设置了 Flex 布局以后，其子元素的 float、clear 和 vertical-align 等属性将失效。 CSS 中提供了以下属性来实现 Flex 布局： 属性 描述 display 指定 HTML 元素的盒子类型 flex-direction 指定弹性盒子中子元素的排列方式 flex-wrap 设置当弹性盒子的子元素超出父容器时是否换行 flex-flow flex-direction 和 flex-wrap 两个属性的简写 justify-content 设置弹性盒子中元素在主轴（横轴）方向上的对齐方式 align-items 设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式 align-content 修改 flex-wrap 属性的行为，类似 align-items，但不是设置子元素对齐，而是设置行对齐 order 设置弹性盒子中子元素的排列顺序 align-self 在弹性盒子的子元素上使用，用来覆盖容器的 align-items 属性 flex 设置弹性盒子中子元素如何分配空间 flex-grow 设置弹性盒子的扩展比率 flex-shrink 设置弹性盒子的收缩比率 flex-basis 设置弹性盒子伸缩基准值 按照作用范围的不同，这些属性可以分为两类 容器属性（flex-direction、flex-wrap、flex-flow、justify-content、align-items、align-content） 项目属性（order、align-self、flex、flex-grow、flex-shrink、flex-basis） ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:1:0","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"容器属性 ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:0","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"flex-direction flex-direction 属性用来决定主轴的方向（即项目的排列方向），属性的可选值如下： 值 描述 row 默认值，主轴沿水平方向从左到右 row-reverse 主轴沿水平方向从右到左 column 主轴沿垂直方向从上到下 column-reverse 主轴沿垂直方向从下到上 initial 将此属性设置为属性的默认值 inherit 从父元素继承此属性的值 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e #main { border: 1px solid #CCC; padding: 5px; position: relative; } .row, .row_reverse, .column, .column_reverse{ display: flex; margin-bottom: 5px; } .row { flex-direction: row; } .row_reverse { flex-direction: row-reverse; } .column { flex-direction: column; } .column_reverse { flex-direction: column-reverse; position: absolute; top: 120px; left: 400px; } .row div, .row_reverse div, .column div, .column_reverse div { width: 50px; height: 50px; border: 1px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"main\"\u003e \u003cdiv class=\"row\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"row_reverse\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"column\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"column_reverse\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 运行结果如下图所示： ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:1","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"flex-wrap flex-wrap 属性用来设置当弹性盒子的子元素（项目）超出父容器时是否换行，属性的可选值如下： 值 描述 nowrap 默认值，表示项目不会换行 wrap 表示项目会在需要时换行 wrap-reverse 表示项目会在需要时换行，但会以相反的顺序 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e #main { border: 1px solid #CCC; padding: 5px; } .nowrap, .wrap, .wrap_reverse { display: flex; flex-direction: row; margin-bottom: 15px; } .nowrap { flex-wrap: nowrap; } .wrap { flex-wrap: wrap; } .wrap_reverse { flex-wrap: wrap-reverse; } .nowrap div, .wrap div, .wrap_reverse div { width: 70px; height: 50px; border: 1px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"main\"\u003e \u003cdiv class=\"nowrap\"\u003e \u003cdiv\u003e1\u003c/div\u003e\u003cdiv\u003e2\u003c/div\u003e\u003cdiv\u003e3\u003c/div\u003e\u003cdiv\u003e4\u003c/div\u003e\u003cdiv\u003e5\u003c/div\u003e\u003cdiv\u003e6\u003c/div\u003e\u003cdiv\u003e7\u003c/div\u003e\u003cdiv\u003e8\u003c/div\u003e\u003cdiv\u003e9\u003c/div\u003e\u003cdiv\u003e10\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"wrap\"\u003e \u003cdiv\u003e1\u003c/div\u003e\u003cdiv\u003e2\u003c/div\u003e\u003cdiv\u003e3\u003c/div\u003e\u003cdiv\u003e4\u003c/div\u003e\u003cdiv\u003e5\u003c/div\u003e\u003cdiv\u003e6\u003c/div\u003e\u003cdiv\u003e7\u003c/div\u003e\u003cdiv\u003e8\u003c/div\u003e\u003cdiv\u003e9\u003c/div\u003e\u003cdiv\u003e10\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"wrap_reverse\"\u003e \u003cdiv\u003e1\u003c/div\u003e\u003cdiv\u003e2\u003c/div\u003e\u003cdiv\u003e3\u003c/div\u003e\u003cdiv\u003e4\u003c/div\u003e\u003cdiv\u003e5\u003c/div\u003e\u003cdiv\u003e6\u003c/div\u003e\u003cdiv\u003e7\u003c/div\u003e\u003cdiv\u003e8\u003c/div\u003e\u003cdiv\u003e9\u003c/div\u003e\u003cdiv\u003e10\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 运行结果如下图所示： ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:2","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"flex-flow flex-flow 属性是 flex-direction 和 flex-wrap 两个属性的简写，语法格式如下： flex-flow: flex-direction flex-wrap; 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e .flex_flow { display: flex; flex-flow: row-reverse wrap; } .flex_flow div { width: 60px; height: 60px; margin-bottom: 5px; border: 1px solid black; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"flex_flow\"\u003e \u003cdiv\u003e1\u003c/div\u003e\u003cdiv\u003e2\u003c/div\u003e\u003cdiv\u003e3\u003c/div\u003e\u003cdiv\u003e4\u003c/div\u003e\u003cdiv\u003e5\u003c/div\u003e\u003cdiv\u003e6\u003c/div\u003e\u003cdiv\u003e7\u003c/div\u003e\u003cdiv\u003e8\u003c/div\u003e\u003cdiv\u003e9\u003c/div\u003e\u003cdiv\u003e10\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:3","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"justify-content justify-content 属性用于设置弹性盒子中元素在主轴（横轴）方向上的对齐方式，属性的可选值如下： 值 描述 flex-start 默认值，左对齐 flex-end 右对齐 center 居中 space-between 两端对齐，项目之间的间隔是相等的 space-around 每个项目两侧的间隔相等 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e .flex { display: flex; flex-flow: row wrap; margin-top: 10px; } .flex div { width: 60px; height: 60px; margin-bottom: 5px; border: 1px solid black; } .flex-start { justify-content: flex-start; } .flex-end { justify-content: flex-end; } .center { justify-content: center; } .space-between { justify-content: space-between; } .space-around { justify-content: space-around; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"flex flex-start\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"flex flex-end\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"flex center\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"flex space-between\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e \u003c/div\u003e \u003cdiv class=\"flex space-around\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:4","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"align-items align-items 属性用来设置弹性盒子中元素在侧轴（纵轴）方向上的对齐方式，属性的可选值如下： 值 描述 stretch 默认值，项目将被拉伸以适合容器 center 项目位于容器的中央 flex-start 项目位于容器的顶部 flex-end 项目位于容器的底部 baseline 项目与容器的基线对齐 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:5","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"align-content align-content 属性与 justify-content 属性类似，可以在弹性盒子的侧轴还有多余空间时调整容器内项目的对齐方式 值 描述 stretch 默认值，将项目拉伸以占据剩余空间 center 项目在容器内居中排布 flex-start 项目在容器的顶部排列 flex-end 项目在容器的底部排列 space-between 多行项目均匀分布在容器中，其中第一行分布在容器的顶部，最后一行分布在容器的底部 space-around 多行项目均匀分布在容器中，并且每行的间距（包括离容器边缘的间距）都相等 initial 将此属性设置为属性的默认值 inherit 从父元素继承该属性的值 ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:2:6","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"项目属性 ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:3:0","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"order order 属性用来设置项目在容器中出现的顺序，可以通过具体的数值来定义项目在容器中的位置 属性的语法格式如下： order: number; 其中 number 就是项目在容器中的位置，默认值为 0 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e .flex { display: flex; flex-flow: row wrap; margin-top: 10px; } .flex div { width: 60px; height: 60px; margin-bottom: 5px; border: 1px solid black; } .flex div:nth-child(1) { order: 5; } .flex div:nth-child(2) { order: 3; } .flex div:nth-child(3) { order: 1; } .flex div:nth-child(4) { order: 2; } .flex div:nth-child(5) { order: 4; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"flex\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 运行结果如下图所示： ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:3:1","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"align-self align-self 属性允许为某个项目设置不同于其它项目的对齐方式，该属性可以覆盖 align-items 属性的值。 align-self 属性的可选值如下： 值 描述 auto 默认值，表示元素将继承其父容器的 align-items 属性值，如果没有父容器，则为“stretch” stretch 项目将被拉伸以适合容器 center 项目位于容器的中央 flex-start 项目位于容器的顶部 flex-end 项目位于容器的底部 baseline 项目与容器的基线对齐 initial 将此属性设置为属性的默认值 inherit 从父元素继承属性的值 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e .flex { display: flex; flex-flow: row wrap; align-items: flex-end; border: 1px solid #CCC; height: 150px; } .flex div { width: 60px; height: 60px; border: 1px solid black; } .flex div:nth-child(4) { align-self: flex-start; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"flex\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 运行结果如下图所示： ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:3:2","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["前端"],"content":"flex flex 属性是 flex-grow、flex-shrink 和 flex-basis 三个属性的简写，语法格式如下： flex: flex-grow flex-shrink flex-basis; 参数说明如下： flex-grow：(必填参数) 一个数字，用来设置项目相对于其他项目的增长量，默认值为 0； flex-shrink：(选填参数) 一个数字，用来设置项目相对于其他项目的收缩量，默认值为 1； flex-basis：(选填参数) 项目的长度，合法值为 auto（默认值，表示自动） inherit（表示从父元素继承该属性的值） 或者以具体的值加 “%\"、“px”、“em” 等单位的形式。 另外，flex 属性还有两个快捷值，分别为 auto（1 1 auto）和 none（0 0 auto）。 示例代码如下： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cstyle\u003e .flex { display: flex; flex-flow: row wrap; align-items: flex-end; border: 1px solid #CCC; } .flex div { width: 60px; height: 60px; border: 1px solid black; } .flex div:nth-child(2) { flex:0; } .flex div:nth-child(4) { flex:1 1 auto; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv class=\"flex\"\u003e \u003cdiv\u003eA\u003c/div\u003e\u003cdiv\u003eB\u003c/div\u003e\u003cdiv\u003eC\u003c/div\u003e\u003cdiv\u003eD\u003c/div\u003e\u003cdiv\u003eE\u003c/div\u003e \u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 运行结果如下图所示： 图：flex 属性演示 另外，除了可以使用 flex 属性外，您也可以使用 flex-grow、flex-shrink、flex-basis 几个属性来分别设置项目的增长量、收缩量以及项目长度，例如： .flex div:nth-child(4) { flex-grow: 1; flex-shrink: 1; flex-basis: auto; /* 等同于 flex:1 1 auto; */ } ","date":"2022-01-08","objectID":"/Notes/posts/frontend/css/flex/:3:3","tags":["CSS","前端"],"title":"flex 布局","uri":"/Notes/posts/frontend/css/flex/"},{"categories":["其他"],"content":"123","date":"2022-02-20","objectID":"/Notes/posts/markdown/","tags":["其他"],"title":"Hi~ 我是一个帮助文档","uri":"/Notes/posts/markdown/"},{"categories":["其他"],"content":"Hi~ 我是一个帮助文档 ","date":"2022-02-20","objectID":"/Notes/posts/markdown/:0:0","tags":["其他"],"title":"Hi~ 我是一个帮助文档","uri":"/Notes/posts/markdown/"},{"categories":["其他"],"content":"测试图片插入 截图插入 拖动本地图片插入 现均已上传至腾讯云图床 ","date":"2022-02-20","objectID":"/Notes/posts/markdown/:1:0","tags":["其他"],"title":"Hi~ 我是一个帮助文档","uri":"/Notes/posts/markdown/"},{"categories":["其他"],"content":"格式化 标题 # + word 共六级 这是斜体 * + word + * 这是加粗 ** + word + ** 这是加粗斜体 *** + word + *** 这是中划线 ~~ + word + ~~ 这是引用 \u003e + word 引用中的引用 (?) 若要在下一行退出引用，多按一次回车 这是有序列表 num. + word 或 1. + word，因为数字不必按数学顺序排列 这是无序列表 - + word 二级列表 三级列表 四级列表（之后都是方块啦） ​ 一个制表符缩进以填写其他内容 四级列表 要退出列表模式，使用shift + tab 将短语表示为代码，Just like this ` + word + ` 使用``` + 语言名 + ```内容 来创建代码块 name=input(\"type your name: \") print('Hello world'+name) 在单独一行上使用多个*或-（破折号）以创建分隔线 将链接文本放在[]中，将链接放在()中即可创造链接，添加title以增加悬停提示 要将 URL 或电子邮件地址转换为链接，请将其括在\u003c\u003e中，https://github.com/Trouvaille0198/Notes，不过用Typora编辑的话也可以不括… 链接也可以格式化哦 使用|来创建表格 1 2 3 嘿 哈 吼 哼 嚯 嗐 插入图片的格式：，不过这里建议直接复制粘贴呢~ 这是下标 H~2~O ~ + word + ~ 这是上标 X^2^ ^ + word + ^ 这是==高亮== == + word + == （Typora专有） ","date":"2022-02-20","objectID":"/Notes/posts/markdown/:2:0","tags":["其他"],"title":"Hi~ 我是一个帮助文档","uri":"/Notes/posts/markdown/"},{"categories":["前端"],"content":"HTML ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:0:0","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"书写规范 \u003c!-- html文件开始, lang=\"zh_CN\"表示中文 --\u003e \u003chtml lang=\"zh_CN\"\u003e \u003c!-- 头信息 一般分 title标题 css样式 js代码 --\u003e \u003chead\u003e \u003c!-- 表示当前页面使用UTF-8编码 --\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e标题\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 页面主体信息 --\u003e hello \u003c/body\u003e \u003c/html\u003e html 语言是不区分大小写的语言。 html 的属性写法，写在标签中 属性名 = 值，值是可以用双引号，也可以用单引号或者不写，注意如果不写后面一定要加一个空格。 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:1:0","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"基本结构标签 \u003chtml\u003e\u003chtml\u003e ：HTML标签，根标签，页面中最大的标签 \u003chead\u003e\u003c/head\u003e：文档的头部，在其中必须设置title标签 \u003ctitle\u003e\u003c/title\u003e：文档的标题 \u003cbody\u003e\u003c/body\u003e：文档主体，包含文档的所有内容 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:1:1","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"其他信息 文档类型声明标签 \u003c!DOCTYPE\u003e 告诉浏览器使用那种HTML版本来显示网页，写在最前面 \u003c!DOCTYPE html\u003e lang 语言种类 定义当前文档显示的语言。en 为英语；zh-CN 为中文 \u003chtml lang=\"en\"\u003e 字符集 通过 \u003cmeta\u003e 标签的 charset 属性规定字符编码 \u003cmeta charset=\"UTF-8\"\u003e ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:1:2","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"常用标签 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:0","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"标题标签 \u003ch1\u003e-\u003ch6\u003e 6 个等级，1-6 重要级递减 加了标题的文字更粗更大，一个标题独占一行 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:1","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"段落标签 \u003cp\u003e 分段，浏览器根据窗口大小自动换行，段落之前有空行 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:2","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"换行标签 \u003cbr /\u003e （单标签） 强制换行 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:3","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"文本格式化标签 加粗 \u003cstrong\u003e\u003c/strong\u003e 或 \u003cb\u003e\u003c/b\u003e 倾斜 \u003cem\u003e\u003c/em\u003e 或 \u003ci\u003e\u003c/i\u003e 删除线 \u003cdel\u003e\u003c/del\u003e 或 \u003cs\u003e\u003c/s\u003e 下划线 \u003cins\u003e\u003c/ins\u003e 或 \u003cu\u003e\u003c/u\u003e ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:4","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"区块 \u003cdiv\u003e 和 \u003cspan\u003e 没有语义，是一个盒子，用来装内容 \u003cdiv\u003e 独占一行，大盒子 \u003cspan\u003e 在一行可以放多个，小盒子 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:5","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"图像标签 \u003cimg src=\"图像URL\" /\u003e src 是 \u003cimg\u003e 标签的必须属性，用于指定图像文件的路径和文件名 属性名称 属性值 描述 src url 图像的路径 alt 文本 图像不能显示时的替换文本 title 文本 鼠标悬停显示的内容 width 像素 设置图像的宽度 height 像素 设置图像的高度 border 数字 设置图像边框的宽度 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:6","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"超链接标签 \u003ca\u003e 语法格式 \u003ca href=\"跳转目标\" target=\"目标窗口的弹出方式\"\u003e 文本或图像 \u003c/a\u003e href 用于指定链接目标的 url 地址，必须属性 target 用于指定链接页面的打开方式，其中 _self 为默认值，_blank 为在新窗口中打开 分类 外部链接：http:// 内部链接：页面名称 空链接：# 下载链接：地址链接的是文件、exe、zip 等，会下载这个文件 网页元素链接：文本、图像、视频、音频、表格等都可以添加超链接 锚点链接：快速定位到页面中的某个位置 id 属性 在 HTML 文档中插入 id \u003cp id=\"tips\"\u003e有用的提示部分\u003c/p\u003e 在 HTML 文档中创建一个链接到\"有用的提示部分 (id=\"tips\")\" \u003ca href=\"#tips\"\u003e访问有用的提示部分\u003c/a\u003e 或者，从另一个页面创建一个链接到\"有用的提示部分 (id=\"tips\")\" \u003ca href=\"https://www.runoob.com/html/html-links.html#tips\"\u003e访问有用的提示部分\u003c/a\u003e ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:7","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"注释 \u003c!-- --\u003e ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:8","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"特殊字符 显示结果 描述 实体名称 实体编号 空格 \u0026nbsp; \u0026#160; \u003c 小于号 \u0026lt; \u0026#60; \u003e 大于号 \u0026gt; \u0026#62; \u0026 和号 \u0026amp; \u0026#38; \" 引号 \u0026quot; \u0026#34; ' 撇号 \u0026apos; (IE 不支持) \u0026#39; ￠ 分（cent） \u0026cent; \u0026#162; £ 镑（pound） \u0026pound; \u0026#163; ¥ 元（yen） \u0026yen; \u0026#165; € 欧元（euro） \u0026euro; \u0026#8364; § 小节 \u0026sect; \u0026#167; © 版权（copyright） \u0026copy; \u0026#169; ® 注册商标 \u0026reg; \u0026#174; ™ 商标 \u0026trade; \u0026#8482; × 乘号 \u0026times; \u0026#215; ÷ 除号 \u0026divide; \u0026#247; ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:9","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"表格标签 \u003ctable\u003e \u003ctr\u003e \u003ctd\u003e单元格内的文字\u003c/td\u003e ... \u003c/tr\u003e ... \u003c/table\u003e \u003ctable\u003e\u003c/table\u003e 定义表格 \u003ctr\u003e\u003c/tr\u003e 定义表格中的行 \u003ctd\u003e\u003c/td\u003e 定义单元格 \u003cth\u003e\u003c/th\u003e 表头单元格标签，加粗居中显示 表格结构标签 \u003cthead\u003e\u003c/thead\u003e 表格的头部区域，一般包含着 tr 和 td \u003ctbody\u003e\u003c/tbody\u003e 表格的主题区域，一般包含着 tr 和 th 合并单元格 跨行合并，写在最上侧单元格 \u003ctd rowspan=\"要合并的数量\"\u003e\u003c/td\u003e ​ 跨列合并，写在最左侧单元格 \u003ctd colspan=\"要合并的数量\"\u003e\u003c/td\u003e 例 \u003ctable border=\"1\" width=\"300\" height=\"300\" align=\"center\" cellspacing=\"0\"\u003e \u003cthead\u003e \u003c!-- thhead表示表头 --\u003e \u003cth\u003e第1列\u003c/th\u003e \u003cth\u003e第2列\u003c/th\u003e\u003c!-- th是字体加粗的td标签一般用在表头 --\u003e \u003cth\u003e第3列\u003c/th\u003e \u003c/thead\u003e \u003ctr\u003e\u003c!-- 行 --\u003e \u003ctd align=\"left\"\u003e1-1\u003c/td\u003e\u003c!-- 列，单元格 --\u003e \u003ctd align=\"center\"\u003e1-2\u003c/td\u003e \u003ctd align=\"right\"\u003e1-3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e\u003c!-- 行 --\u003e \u003ctd\u003e\u003cb\u003e2-1\u003c/b\u003e\u003c/td\u003e\u003c!-- 列，单元格 b标签加粗 --\u003e \u003ctd\u003e2-2\u003c/td\u003e \u003ctd\u003e2-3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e\u003c!-- 行 --\u003e \u003ctd\u003e3-1\u003c/td\u003e\u003c!-- 列，单元格 --\u003e \u003ctd\u003e3-2\u003c/td\u003e \u003ctd\u003e3-3\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cbody\u003e \u003c!-- colspan表示跨列 rowspan表示跨行--\u003e \u003ctable border=\"1\" width=\"300\" height=\"300\" align=\"center\" cellspacing=\"0\"\u003e \u003cthead\u003e \u003c!-- thhead表示表头 --\u003e \u003cth\u003e第1列\u003c/th\u003e \u003cth\u003e第2列\u003c/th\u003e\u003c!-- th是字体加粗的td标签一般用在表头 --\u003e \u003cth\u003e第3列\u003c/th\u003e \u003c/thead\u003e \u003ctr\u003e\u003c!-- 行 --\u003e \u003ctd colspan=\"2\"\u003e1-1\u003c/td\u003e\u003c!-- 第一行的第一列跨2列 --\u003e \u003ctd\u003e1-3\u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e\u003c!-- 行 --\u003e \u003ctd rowspan=\"2\"\u003e2-1\u003c/td\u003e\u003c!-- 第二行的第一列跨2行 --\u003e \u003ctd colspan=\"2\" rowspan=\"2\"\u003e2-2\u003c/td\u003e\u003c!-- 第二行的第二列跨2行2列 --\u003e \u003c/tr\u003e \u003ctr\u003e\u003c!-- 行 --\u003e \u003c/tr\u003e \u003c/table\u003e \u003c/body\u003e ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:10","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"水平线标签 \u003chr /\u003e 生成一条水平线 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:11","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"列表标签 无序列表 \u003cul\u003e \u003cli\u003e列表项1\u003c/li\u003e \u003cli\u003e列表项2\u003c/li\u003e \u003cli\u003e列表项3\u003c/li\u003e \u003c/ul\u003e \u003cli\u003e\u003c/li\u003e 中间可以放置任何元素 有序列表 \u003col\u003e \u003cli\u003e列表项1\u003c/li\u003e \u003cli\u003e列表项2\u003c/li\u003e \u003cli\u003e列表项3\u003c/li\u003e \u003c/ol\u003e 自定义列表 常用于对术语或名词进行解释或描述，其列表项前没有任何符号 \u003cdl\u003e \u003cdt\u003e名词1\u003c/dt\u003e \u003cdd\u003e名词1的解释1\u003c/dd\u003e \u003cdd\u003e名词1的解释2\u003c/dd\u003e \u003c/dl\u003e 输出 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:12","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"表单标签 表单域 把范围内的表单元素提交给服务器 \u003cform action=\"url地址\" method=\"提交方式\" name=\"表单域名称\"\u003e 各种表单元素控件 \u003c/form\u003e 表单控件 允许用户在表单中输入或者选择的内容控件 输入表单元素 \u003cinput type=\"属性值\" /\u003e type 属性值 值 描述 button 定义可点击的按钮（通常与 JavaScript 一起使用来启动脚本）。 checkbox 定义复选框。 file 定义文件选择字段和 “浏览…” 按钮，供文件上传。 date 定义 date 控件（包括年、月、日，不包括时间）。 hidden 定义隐藏输入字段。 image 定义图像作为提交按钮。 password 定义密码字段（字段中的字符会被遮蔽）。 radio 定义单选按钮。 reset 定义重置按钮（重置所有的表单值为默认值）。 submit 定义提交按钮。 search 定义用于输入搜索字符串的文本字段。 text 默认。定义一个单行的文本字段（默认宽度为 20 个字符）。 color 定义拾色器。 其他参数 属性 值 描述 checked checked 规定此 input 元素首次加载时应当被选中。 maxlength number 规定输入字段中的字符的最大长度。 name field_name 定义 input 元素的名称。单选按钮和复选框应有相同的name value value 规定 input 元素的值。在文本框中会显示 定义标注标签 \u003clabel\u003e\u003c/label\u003e 绑定一个表单元素，当点击 label 标签内的文本时，浏览器会自动将焦点（光标）转到或者选择对应的表单元素上以增加用户体验 \u003clabel for=\"id名字\"\u003e文本或图片\u003c/label\u003e 在 input 标签内写上 id 属性，即可一一对应 下拉表单元素 有多个选项，用下拉列表以节约空间 \u003cselect\u003e \u003coption\u003e选项1\u003c/option\u003e \u003coption\u003e选项2\u003c/option\u003e \u003coption\u003e选项3\u003c/option\u003e \u003c/select\u003e 在 option 中定义 selected=\"selected\"，默认选中此选项 文本域元素 当用户输入内容较多时，用文本域标签定义多行文本输入 \u003ctextarea\u003e文本内容\u003c/textarea\u003e 例 \u003ctextarea rows=\"10\" cols=\"30\"\u003e 我是一个文本框。 \u003c/textarea\u003e 例子 \u003cform action=\"demo_form.php\" method=\"post/get\"\u003e \u003cinput type=\"text\" name=\"email\" size=\"40\" maxlength=\"50\" value=\"type your email here\"\u003e \u003cinput type=\"password\"\u003e \u003cinput type=\"checkbox\" checked=\"checked\"\u003e \u003cinput type=\"radio\" checked=\"checked\"\u003e \u003cinput type=\"submit\" value=\"Send\"\u003e \u003cinput type=\"reset\"\u003e \u003cinput type=\"hidden\"\u003e \u003cselect\u003e \u003coption\u003e苹果\u003c/option\u003e \u003coption selected=\"selected\"\u003e香蕉\u003c/option\u003e \u003coption\u003e樱桃\u003c/option\u003e \u003c/select\u003e \u003ctextarea name=\"comment\" rows=\"6\" cols=\"20\"\u003e\u003c/textarea\u003e \u003c/form\u003e \u003cbody\u003e \u003c!-- form标签就是表单 input type=text 是文本输入框 value 表示默认显示内容 input type=password 是密码输入框 value 表示默认显示内容 password类型显示······ input type=radio 是单选框 name 表示单选框的组同名的是一组 一组只能选一个，checked表示默认选中 input type=checkbox 是多选框 name 表示多选框的组同名的是一组 一组可以选多个，checked表示默认选中 select 是选择框下拉框 name 表示名字 option是下拉选项 selected表示默认选中 value表示选中后的值 不写取option中间的值 textarea 表示文本域 多行文本框 rows表示行 cols表示列 input type=reset 重置按钮 value表示修改按钮上的文本 input type=submit 提交按钮 value表示修改按钮上的文本 input type=button 提交按钮 value表示修改按钮上的文本 input type=file 文件上传按钮 value表示修改按钮上的文本 input type=hidden 隐藏域 不显示的组件，不需要用户参与的 --\u003e \u003cform action=\"\"\u003e \u003ch1 align=\"center\"\u003e 用户注册\u003c/h1\u003e \u003ctable cellspacing=\"0\" align=\"center\"\u003e \u003ctr\u003e \u003ctd\u003e用户名：\u003c/td\u003e \u003ctd\u003e \u003cinput type=\"text\" value=\"默认值\"/\u003e\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e密码：\u003c/td\u003e \u003ctd\u003e \u003cinput type=\"password\" value=\"密码\"/\u003e\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e确认密码：\u003c/td\u003e \u003ctd\u003e \u003cinput type=\"password\" value=\"密码\"/\u003e\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e性别：\u003c/td\u003e \u003ctd\u003e \u003cinput type=\"radio\" name=\"sex\" checked=\"checked\"\u003e男\u003cinput type=\"radio\" name=\"sex\"\u003e女\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e 兴趣爱好：\u003c/td\u003e \u003ctd\u003e \u003cinput type=\"checkbox\" name=\"hobby\" checked=\"checked\"\u003ejava \u003cinput type=\"checkbox\" name=\"hobby\"checked=\"checked\"\u003epython \u003cinput type=\"checkbox\" name=\"hobby\"\u003ec++\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e 国籍：\u003c/td\u003e \u003ctd\u003e \u003cselect name=\"nation\"\u003e \u003coption\u003e--请选择国籍--\u003c/option\u003e \u003coption value=\"1\" selected=\"selected\"\u003e中国\u003c/option\u003e \u003coption value=\"2\"\u003e美国\u003c/option\u003e \u003coption value=\"3\"\u003e英国\u003c/option\u003e \u003c/select\u003e\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e 自我评价：\u003c/td\u003e \u003ctd\u003e \u003ctextarea cols=\"30\" rows=\"10\"\u003e这里写默认值 没有value属性\u003c/textarea\u003e\u003cbr\u003e \u003c/td\u003e \u003c/tr\u003e \u003ctr\u003e \u003ctd\u003e \u003cinput type=\"reset\" value=\"重置\"\u003e\u003cinput type=\"submit\" value=\"提交\"\u003e\u003c/td\u003e \u003ctd\u003e\u003cinput type=\"button\" value=\"普通按钮\"\u003e\u003cinput type=\"file\" value=\"提交文件\"\u003e\u003c/td\u003e \u003c/tr\u003e \u003c/table\u003e \u003cinput type=\"hidden\" name=\"1111\" value=\"隐藏域\"\u003e\u003cbr\u003e \u003c/form\u003e \u003c/body\u003e 表单提交 \u003cform action=\"http://localhost:8080\" method=\"GET\"\u003e action：访问服务器的地址 method：请求方式有GET和POST http://localhost:8080/?username=user\u0026password=123\u0026password2=123\u0026sex=1\u0026hobby=java\u0026hobby=python\u0026nation=1\u0026desc=desc\u00261111=abc 表单项数据要发送给服务器需要给表单项属性加上 name 属性 表单项属性要发送指定数据给服务器，例如单选框选中男就发送 1 过去就需要给每个表单项设置 value 值 表单项不在提交的 form 标签中，也不会提交 表单请求方法有 get 和 post GET方式 传递参数的地方 地址?参数 地址?键=值\u0026键=值(name=value) 不安全 参数长度有限 POST 方式 传递参数的地方 请求的请求实体中 相对安全 参数长度理论无限制 一般带有上传文件/密码的表单使用 post 传递 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/html/:2:13","tags":["HTML","前端","快速入门"],"title":"HTML","uri":"/Notes/posts/frontend/html/"},{"categories":["前端"],"content":"DOM ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:0:0","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"简介 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:1:0","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"概念 文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可拓展标记语言（HTML 或 XML）的标准编程接口 文档：一个页面就是一个文档，用 document 表示 元素：页面中所有标签都是元素，用 element 表示 节点：网页中所有内容都是节点（标签，属性，文本，注释等），用 node 表示 DOM 把以上内容都看作对象 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:1:1","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"节点思想 根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:1:2","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"DOM 属性 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:2:0","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"元素属性 以下为 Node 对象的属性 .nodeName nodeName 属性规定节点的名称。 nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document .nodeValue nodeValue 属性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 \u003chtml\u003e \u003cbody\u003e \u003cp id=\"intro\"\u003eHello World!\u003c/p\u003e \u003cscript\u003e x=document.getElementById(\"intro\"); document.write(x.firstChild.nodeValue); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e nodeType nodeType 属性返回节点的类型。nodeType 是只读的 元素类型 NodeType 元素 1 属性 2 文本 3 注释 8 文档 9 以下为 Element 的属性 .innerHTML innerHTML 属性可用于获取或改变任意 HTML 元素，包括 \u003chtml\u003e 和 \u003cbody\u003e \u003chtml\u003e \u003cbody\u003e \u003cp id=\"intro\"\u003eHello World!\u003c/p\u003e \u003cscript\u003e var txt=document.getElementById(\"intro\").innerHTML; document.write(txt); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e .attributes 返回该元素所有属性节点的一个实时集合 var para = document.getElementsByTagName(\"p\")[0]; var atts = para.attributes; .classList 返回一个元素的类属性的实时 DOMTokenList 集合。 .className 获取或设置指定元素的class属性的值，返回以空格分隔的字符串 .tagName 返回当前元素的标签名 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:2:1","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"元素定位 以下为 Node 对象的属性 .parentNode 返回父节点，若无则返回 null .firstChild 返回第一个孩子节点 .lastChild 返回最后一个孩子节点 .nextSibling 返回下一个兄弟 .previousSibling 返回前一个兄弟 .childNodes 返回孩子节点的 NodeList ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:2:2","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"根节点 这里有两个特殊的属性，可以访问全部文档： document.documentElement - 全部文档 document.body - 文档的主体 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:2:3","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"DOM 方法 方法 描述 getElementById() 返回带有指定 ID 的元素。 getElementsByTagName() 返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组）。 getElementsByClassName() 返回包含带有指定类名的所有元素的节点列表。 appendChild() 把新的子节点添加到指定节点。 removeChild() 删除子节点。 replaceChild() 替换子节点。 insertBefore() 在指定的子节点前面插入新的子节点。 createAttribute() 创建属性节点。 createElement() 创建元素节点。 createTextNode() 创建文本节点。 getAttribute() 返回指定的属性值。 setAttribute() 把指定属性设置或修改为指定的值。 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:3:0","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"访问 以下为 Document 对象的方法 getElementById() 返回带有指定 ID 的元素 document.getElementById(\"intro\"); getElementsByTagName() 返回带有指定标签名的所有元素 document.getElementsByTagName(\"p\"); getElementsByClassName() 返回带有相同类名的所有 HTML 元素 以下为 Node 对象的方法 .getRootNode() 返回上下文中的根节点 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:3:1","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"修改 创建 创建内容 创建元素内容的最简单的方法是使用 innerHTML 属性 document.getElementById(\"p1\").innerHTML=\"New text!\"; 改变样式 document.getElementById(\"p2\").style.color=\"blue\"; 创建元素 先创建该元素（元素节点），然后把它追加到已有的元素上 \u003cdiv id=\"d1\"\u003e \u003cp id=\"p1\"\u003eThis is a paragraph.\u003c/p\u003e \u003cp id=\"p2\"\u003eThis is another paragraph.\u003c/p\u003e \u003c/div\u003e \u003cscript\u003e var para=document.createElement(\"p\"); var node=document.createTextNode(\"This is new.\"); para.appendChild(node); var element=document.getElementById(\"d1\"); element.appendChild(para); \u003c/script\u003e 以下为 Document 对象的方法 createElement() 创建元素节点 var para=document.createElement(\"p\"); createTextNode() 创建文本节点 var node=document.createTextNode(\"This is a new paragraph.\"); 添加 以下为 Node 对象的方法 appendChild() 添加孩子节点，将新元素作为父元素的最后一个子元素进行添加 element.appendChild(para); insertBefore(newItem,existingItem) 在指定的已有子节点之前插入新的子节点 删除 removeChild() 删除指定的子节点，为 Node 对象的方法 parent.removeChild(child); ​ 在不直接引用父元素的情况下删除某个元素：找需要删除的子元素，然后使用 parentNode 属性来查找其父元素 var child=document.getElementById(\"p1\"); child.parentNode.removeChild(child); 替换 replaceChild(newnode,oldnode) 替换一个子节点为指定节点，为 Node 对象的方法 parent.replaceChild(newChild,oldChild); ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:3:2","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"其他 以下为 Node 对象的方法 .contains() 返回 Boolean，来表示传入的节点是否为该节点的后代节点 node.contains( otherNode ) .cloneNode() 返回调用该方法的节点的一个副本 var dupNode = node.cloneNode(); .hasChildNodes() 返回 Boolean，来表示该元素是否包含有子节点 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:3:3","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"事件 HTML DOM 允许您在事件发生时执行代码。 当 HTML 元素”有事情发生“时，浏览器就会生成事件： 当用户点击鼠标时 当网页已加载时 当图片已加载时 当鼠标移动到元素上时 当输入字段被改变时 当 HTML 表单被提交时 当用户触发按键时 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:4:0","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"创建事件 在元素中创建 如需在用户点击某个元素时执行代码，把 JavaScript 代码添加到 HTML 事件属性中 onclick=JavaScript \u003chtml\u003e \u003cbody\u003e \u003ch1 onclick=\"this.innerHTML='hello!'\"\u003e请点击这段文本!\u003c/h1\u003e \u003c/body\u003e \u003c/html\u003e 使用 DOM 分配事件 \u003cscript\u003e document.getElementById(\"myBtn\").onclick=function(){displayDate()}; \u003c/script\u003e ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:4:1","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"事件类型 onload 用户进入界面 onload 事件可用于检查访客的浏览器类型和版本，以便基于这些信息来加载不同版本的网页 \u003cbody onload=\"checkCookies()\"\u003e onunload 用户离开界面 onchange onchange 事件常用于输入字段的验证。当用户改变输入字段的内容时，运行对应 js 语句。 \u003cinput type=\"text\" id=\"fname\" onchange=\"upperCase()\"\u003e onmouseover 鼠标指针移动到元素上时 onmouseout 鼠标指针离开元素时 \u003cdiv onmouseover=\"mOver(this)\" onmouseout=\"mOut(this)\" style=\"background-color:yellow;width:200px;height:50px;padding-top:25px;text-align:center;\"\u003e Mouse Over Me \u003c/div\u003e \u003cscript\u003e function mOver(obj) { obj.innerHTML=\"谢谢你\" } function mOut(obj) { obj.innerHTML=\"把鼠标指针移动到上面\" } \u003c/script\u003e onmousedown 鼠标被点击时 onmouseup 鼠标松开时 \u003cdiv onmousedown=\"mDown(this)\" onmouseup=\"mUp(this)\" style=\"background-color:#D94A38;width:200px;height:50px;padding-top:25px;text-align:center;\"\u003e 点击这里 \u003c/div\u003e \u003cscript\u003e function mDown(obj) { obj.style.backgroundColor=\"#1ec5e5\"; obj.innerHTML=\"松开鼠标\" } function mUp(obj) { obj.style.backgroundColor=\"#D94A38\"; obj.innerHTML=\"谢谢你\" } \u003c/script\u003e onclick 一次鼠标点击过程完成时 ondblclick 一次鼠标双击过程完成时 onfocus 元素获得焦点时 在本例中，当输入框获得焦点时，其背景颜色将改变 \u003chtml\u003e \u003chead\u003e \u003cscript type=\"text/javascript\"\u003e function setStyle(x) { document.getElementById(x).style.background=\"yellow\" } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e First name: \u003cinput type=\"text\" onfocus=\"setStyle(this.id)\" id=\"fname\" /\u003e \u003cbr /\u003e Last name: \u003cinput type=\"text\" onfocus=\"setStyle(this.id)\" id=\"lname\" /\u003e \u003c/body\u003e \u003c/html\u003e onkeydown 某个按键被按下时 //键盘监听 document.addEventListener(\"keydown\",keydown); //参数1：表示事件，keydown:键盘向下按；参数2：表示要触发的事件 function keydown(event){ //表示键盘监听所触发的事件，同时传递传递参数event document.write(event.keyCode);//keyCode表示键盘编码 } onkeyup 某个按键松开时 onkeypress 某个按键被被按下并松开时 属性 此事件发生在何时… onabort 图像的加载被中断。 onblur 元素失去焦点。 onchange 域的内容被改变。 onclick 当用户点击某个对象时调用的事件句柄。 ondblclick 当用户双击某个对象时调用的事件句柄。 onerror 在加载文档或图像时发生错误。 onfocus 元素获得焦点。 onkeydown 某个键盘按键被按下。 onkeypress 某个键盘按键被按下并松开。 onkeyup 某个键盘按键被松开。 onload 一张页面或一幅图像完成加载。 onmousedown 鼠标按钮被按下。 onmousemove 鼠标被移动。 onmouseout 鼠标从某元素移开。 onmouseover 鼠标移到某元素之上。 onmouseup 鼠标按键被松开。 onreset 重置按钮被点击。 onresize 窗口或框架被重新调整大小。 onselect 文本被选中。 onsubmit 确认按钮被点击。 onunload 用户退出页面。 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:4:2","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"对象 EventTarget \u003c- Node \u003c- Element \u003c- Document ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:0","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"Node Node 是一个接口，各种类型的 DOM API 对象会从这个接口继承。它允许我们使用相似的方式对待这些不同类型的对象；比如, 继承同一组方法，或者用同样的方式测试。 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:1","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"Element Element 是一个通用性非常强的基类，所有 Document对象下的对象都继承自它。这个接口描述了所有相同种类的元素所普遍具有的方法和属性 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:2","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"Document Document 接口表示任何在浏览器中载入的网页，并作为网页内容的入口，也就是 DOM 树 Document 接口描述了任何类型的文档的通用属性与方法。 属性 .body 返回当前文档中的 \u003cbody\u003e 元素或者 \u003cframeset\u003e 元素 .scripts 返回一个 HTMLCollection 对象,包含了当前文档中所有 \u003cscript\u003e 元素的集合 var scriptList = document.scripts; .URL 返回 url .title 返回标题 方法 .write() 向文档流中写入内容 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:3","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"NodeList NodeList 对象是节点的集合，通常是由属性，如Node.childNodes 和 方法，如document.querySelectorAll 返回的。 NodeList 不是一个数组，是一个类似数组的对象 (Like Array Object)。虽然 NodeList 不是一个数组，但是可以使用 forEach() 来迭代，也可以用下标直接访问 在一些情况下，NodeList 是一个实时集合，也就是说，如果文档中的节点树发生变化，NodeList 也会随之变化 属性 NodeList.length NodeList 中包含的节点个数。 遍历 使用 length 属性来循环节点列表 x=document.getElementsByTagName(\"p\"); for (i=0;i\u003cx.length;i++) { document.write(x[i].innerHTML); document.write(\"\u003cbr /\u003e\"); } for…of 循环同样能正确的遍历 NodeList 对象： var list = document.querySelectorAll('input[type=checkbox]'); for (var checkbox of list) { checkbox.checked = true; } ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:4","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"DOMTokenList DOMTokenList 接口表示一组空格分隔的标记（tokens），主要用于操作 classList 属性 .length 一个整数，表示存储在该对象里值的个数 方法 .contains(token) 是否包括指定字符串，返回 bool .add(token) 添加一个或多个标记（token）到 DOMTokenList 列表中。 .remove(token) 移除一个或多个标记（token）。 .replace(oldToken, newToken) 使用 newToken 替换 token 。 修改空格和重复的特性 修改 DOMTokenList 的方法（例如 DOMTokenList.add()）会自动去除多余的空格（Whitespace）和列表中的重复项目 \u003cspan class=\" d d e f\"\u003e\u003c/span\u003e let span = document.querySelector(\"span\"); let classes = span.classList; span.classList.add(\"x\"); span.textContent = `span classList is \"${classes}\"`; 输出：span classList is “d e f x” ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:5","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"Window Window 对象表示浏览器中打开的窗口，如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 属性 方法 .alert() 显示带有一条指定消息和一个 OK 按钮的警告框 window.alert(message); .open() 打开一个新的浏览器窗口或查找一个已命名的窗口 window.open(URL,name,features,replace) 参数 描述 URL 一个可选的字符串，声明了要在新窗口中显示的文档的 URL。如果省略了这个参数，或者它的值是空字符串，那么新窗口就不会显示任何文档。 name 一个可选的字符串，该字符串是一个由逗号分隔的特征列表，其中包括数字、字母和下划线，该字符声明了新窗口的名称。这个名称可以用作标记 \u003ca\u003e 和 \u003cform\u003e 的属性 target 的值。如果该参数指定了一个已经存在的窗口，那么 open() 方法就不再创建一个新窗口，而只是返回对指定窗口的引用。在这种情况下，features 将被忽略。 features 一个可选的字符串，声明了新窗口要显示的标准浏览器的特征。如果省略该参数，新窗口将具有所有标准特征。 replace 一个可选的布尔值。规定了装载到窗口的 URL 是在窗口的浏览历史中创建一个新条目，还是替换浏览历史中的当前条目。支持下面的值：true - URL 替换浏览历史中的当前条目。false - URL 在浏览历史中创建新的条目。 \u003chtml\u003e \u003chead\u003e \u003cscript type=\"text/javascript\"\u003e function open_win() { window.open(\"http://www.w3school.com.cn\") } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=button value=\"Open Window\" onclick=\"open_win()\" /\u003e \u003c/body\u003e \u003c/html\u003e .close() 关闭浏览器窗口 .confirm(message) 如果用户点击确定按钮，则 confirm() 返回 true。如果点击取消按钮，则 confirm() 返回 false \u003chtml\u003e \u003chead\u003e \u003cscript type=\"text/javascript\"\u003e function disp_confirm() { var r = confirm(\"Press a button\") if (r == true) { document.write(\"You pressed OK!\") } else { document.write(\"You pressed Cancel!\") } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" onclick=\"disp_confirm()\" value=\"Display a confirm box\" /\u003e \u003c/body\u003e \u003c/html\u003e .moveBy() 相对窗口的当前坐标把它移动指定的像素 window.moveBy(x,y) 下面的例子将把窗口相对其当前位置移动 50 个像素 \u003chtml\u003e \u003chead\u003e \u003cscript type=\"text/javascript\"\u003e function moveWin() { myWindow.moveBy(50, 50) } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e myWindow = window.open('', '', 'width=200,height=100') myWindow.document.write(\"This is 'myWindow'\") \u003c/script\u003e \u003cinput type=\"button\" value=\"Move 'myWindow'\" onclick=\"moveWin()\" /\u003e \u003c/body\u003e \u003c/html\u003e .moveTo() 把窗口的左上角移动到一个指定的坐标 window.moveTo(x,y) .print() 打印当前窗口的内容 .prompt() 显示可提示用户进行输入的对话框 如果用户单击提示框的取消按钮，则返回 null。如果用户单击确认按钮，则返回输入字段当前显示的文本。 prompt(text,defaultText) 参数 描述 text 可选。要在对话框中显示的纯文本（而不是 HTML 格式的文本）。 defaultText 可选。默认的输入文本。 \u003chtml\u003e \u003chead\u003e \u003cscript type=\"text/javascript\"\u003e function disp_prompt() { var name = prompt(\"Please enter your name\", \"\") if (name != null \u0026\u0026 name != \"\") { document.write(\"Hello \" + name + \"!\") } } \u003c/script\u003e \u003c/head\u003e \u003cbody\u003e \u003cinput type=\"button\" onclick=\"disp_prompt()\" value=\"Display a prompt box\" /\u003e \u003c/body\u003e \u003c/html\u003e .resizeBy(width,height) 根据指定的像素来调整窗口的大小 .resizeTo(width,height) 把窗口大小调整为指定的宽度和高度 .scrollBy() 把内容滚动指定的像素数 scrollBy(xnum,ynum) .scrollTo() 把内容滚动到指定的坐标 scrollTo(xpos,ypos) setTimeOut() 在指定的毫秒数后调用函数或计算表达式 setTimeout(code,millisec) setTimeout() 只执行 code 一次。如果要多次调用，请使用 setInterval() 或者让 code 自身再次调用 setTimeout() function timedMsg() { var t = setTimeout(\"alert('5 seconds!')\", 5000) } setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式 setInterval(code,millisec[,\"lang\"]) 返回一个可以传递给 Window.clearInterval() 从而取消对 code 的周期性执行的值 此方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。 \u003chtml\u003e \u003cbody\u003e \u003cp id='clock'\u003e\u003c/p\u003e \u003cscript language=javascript\u003e var int = self.setInterval(\"clock()\", 50) function clock() { var t = new Date() document.getElementById(\"clock\").innerHTML = t } \u003c/script\u003e \u003c/form\u003e \u003cbutton onclick=\"int=window.clearInterval(int)\"\u003e Stop interval\u003c/button\u003e \u003c/body\u003e \u003c/html\u003e clearInterval() 取消由 setInterval() 设置的 timeout clearInterval(id_of_setinterval) id_of_setinterval：由 setInterval() 返回的 ID 值 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/dom/:5:6","tags":["JavaScript","前端"],"title":"JavaScript DOM","uri":"/Notes/posts/frontend/javascript/dom/"},{"categories":["前端"],"content":"BasicGrammar ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:0:0","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"概念 JavaScript 是一种运行在浏览器中的解释型的编程语言 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:1:0","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"基本操作 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:2:0","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"变量的声明与赋值 //var是一个JS关键字 var age; //赋值 age = 3; //变量的初始化=声明+赋值 var age = 18; //一次声明多个变量 var game = \"Overwatch\", hero = \"Genji\", ultimate = \"龍神の剣を喰らえ\"; 允许不声明，直接赋值 尽量不要用 name 作为变量名 声明变量本质——向内存申请空间 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:2:1","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"数据类型 JS 是一种弱类型语言（或动态语言），不用提前声明变量类型 相同变量可以用作不同数据类型 JS 中有六种数据类型，包括五种基本数据类型（Number, String, Boolean, Undefined, Null），和一种复杂数据类型（Object） 字符串的拼接——字符串 + 任何类型 = 新的字符串 使用 var 声明了变量，但未给变量初始化值，那么这个变量的值就是 undefined Number JavaScript 不区分整数和浮点数，统一用 Number 表示，以下都是合法的 Number 类型： 123; // 整数 123 0.456; // 浮点数 0.456 1.2345e3; // 科学计数法表示 1.2345x1000，等同于 1234.5 -99; // 负数 NaN; // NaN表示Not a Number，当无法计算结果时用NaN表示 Infinity; // Infinity表 示无限大，当数值超过了 JavaScript 的 Number 所能表示的最大值时，就表示为 Infinity 说明 二进制前加 0b，八进制前加 0，十六进制前加 0x 最大值和最小值，Number.MAX_VALUE 和 Number.MIN_VALUE 其他特殊值 Infinity，无穷大； -Infinity，无穷小； NaN，代表一个非数值 字符串 String 字符串是以单引号 ' 或双引号 \" 括起来的任意文本，比如 'abc'，\"xyz\" 等等。请注意，'' 或 \"\"本身只是一种表示方式，不是字符串的一部分 需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果 var s = 'Test'; s[0] = 'X'; alert(s); // s仍然为'Test' 多行字符串 由于多行字符串用 \\n 写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法，用反引号 ` 表示： `这是一个 多行 字符串`; 模板字符串 如果有很多变量需要连接，用 + 号就比较麻烦。ES6 新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量： var name = '小明'; var age = 20; var message = `你好, ${name}, 你今年${age}岁了!`; alert(message); 操作字符串 获取长度 var s = 'Hello, world!'; s.length; // 13 把一个字符串全部变为大写 var s = 'Hello'; s.toUpperCase(); // 返回'HELLO' 把一个字符串全部变为小写 var s = 'Hello'; var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower lower; // 'hello' 搜索指定字符串出现的位置 var s = 'hello, world'; s.indexOf('world'); // 返回7 s.indexOf('World'); // 没有找到指定的子串，返回-1 返回指定索引区间的子串 var s = 'hello, world' s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello' s.substring(7); // 从索引7开始到结束，返回'world' 把字符串分割为字符串数组 var s = 'How are you doing today?' s.split(' '); // [How,are,you,doing,today?] s.split(''); // [H,o,w, ,a,r,e, ,y,o,u, ,d,o,i,n,g, ,t,o,d,a,y,?] 布尔值 Bool 布尔值和布尔代数的表示完全一致，一个布尔值只有 true、false 两种值 true; // 这是一个true值 false; // 这是一个false值 2 \u003e 1; // 这是一个true值 2 \u003e= 3; // 这是一个false值 JavaScript 在设计时，有两种比较运算符： 第一种是 == 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果； 第二种是 === 比较，它不会自动转换数据类型，如果数据类型不一致，返回 false，如果一致，再比较。 由于 JavaScript 这个设计缺陷，不要使用 == 比较，始终坚持使用 === 比较。 另一个例外是 NaN 这个特殊的 Number 与所有其他值都不相等，包括它自己： NaN === NaN; // false 唯一能判断 NaN 的方法是通过 isNaN() 函数： isNaN(NaN); // true 最后要注意浮点数的相等比较： 1 / 3 === (1 - 2 / 3); // false 这不是 JavaScript 的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。 要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值： Math.abs(1 / 3 - (1 - 2 / 3)) \u003c 0.0000001; // true null 和 undefined null 表示一个“空”的值，它和 0 以及空字符串 '' 不同，0 是一个数值，'' 表示长度为 0 的字符串，而 null 表示“空”。 在其他语言中，也有类似 JavaScript 的 null 的表示，例如 Java 也用 null，Swift 用 nil，Python 用 None 表示。但是，在JavaScript 中，还有一个和 null 类似的 undefined，它表示“未定义”。 JavaScript 的设计者希望用 null 表示一个空的值，而 undefined 表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用 null。undefined 仅仅在判断函数参数是否传递的情况下有用。 数组 Array 数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript 的数组可以包括任意数据类型。例如： var arr = [1, 2, 3.14, 'Hello', null, true]; 上述数组包含 6 个元素。数组用 [] 表示，元素之间用 , 分隔。 另一种创建数组的方法是通过 Array() 函数实现： var arr = new Array(1, 2, 3); // 创建了数组[1, 2, 3] 然而，出于代码的可读性考虑，强烈建议直接使用 []。 数组的元素可以通过索引来访问。请注意，索引的起始值为 0： var arr = [1, 2, 3.14, 'Hello', null, true]; arr[0]; // 返回索引为0的元素，即1 arr[5]; // 返回索引为5的元素，即true arr[6]; // 索引超出了范围，返回undefined 获取长度 length 属性 要取得 Array 的长度，直接访问 length 属性： var arr = [1, 2, 3.14, 'Hello', null, true]; arr.length; // 6 请注意，直接给 Array 的 length 赋一个新的值会导致 Array 大小的变化： var arr = [1, 2, 3]; arr.length; // 3 arr.length = 6; arr; // arr变为[1, 2, 3, undefined, undefined, undefined] arr.length = 2; arr; // arr变为[1, 2] Array 可以通过索引把对应的元素修改为新的值 请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化： var arr = [1, 2, 3]; arr[5] = 'x'; arr; // arr变为[1, 2, 3, undefined, undefined, 'x'] 大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript 的 Array 却不会有任何错误。在编写代码时，不建议直接修改 Array 的大小，访问索引时要确保索引不会越界。 搜索元素位置 .indexOf() 与 String 类似，Array 也可以通过 indexOf() 来搜索一个指定的元素的位置： var arr = [10, 20, '30', 'xyz']; arr.indexOf(10); // 元素10的索引为0 arr.indexOf(20); // 元素20的索引为1 arr.indexOf(30); // 元素30没有找到，返回-1 arr.indexOf('30'); // 元素'30'的索引为2 注意了，数字 30 和字符串 '30' 是不同的元素。 获取切片 .slice() slice() 就是对应String的 substring() 版本，它截取 Array 的部分元素，然后返回一个新的 Array： var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G']; arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C'] arr.slice(3); // 从索引3开始到结束: ['D","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:2:2","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"Map 和 Set JavaScript的默认对象表示方式 {} 可以视为其他语言中的 Map 或 Dictionary 的数据结构，即一组键值对。 但是J avaScript 的对象有个小问题，就是键必须是字符串。但实际上 Number 或者其他数据类型作为键也是非常合理的。 Map Map 是一组键值对的结构，具有极快的查找速度。 举个例子，假设要根据同学的名字查找对应的成绩，如果用 Array 实现，需要两个 Array： var names = ['Michael', 'Bob', 'Tracy']; var scores = [95, 75, 85]; 给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从 scores 取出对应的成绩，Array 越长，耗时越长。 如果用 Map 实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用 JavaScript 写一个 Map 如下： var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]); m.get('Michael'); // 95 初始化 Map 需要一个二维数组，或者直接初始化一个空 Map。Map 具有以下方法： var m = new Map(); // 空Map m.set('Adam', 67); // 添加新的key-value m.set('Bob', 59); m.has('Adam'); // 是否存在key 'Adam': true m.get('Adam'); // 67 m.delete('Adam'); // 删除key 'Adam' m.get('Adam'); // undefined 由于一个 key 只能对应一个 value，所以，多次对一个 key 放入 value，后面的值会把前面的值冲掉： var m = new Map(); m.set('Adam', 67); m.set('Adam', 88); m.get('Adam'); // 88 Set Set 和 Map 类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 Set 中，没有重复的 key。 要创建一个 Set，需要提供一个Array作为输入，或者直接创建一个空 Set： var s1 = new Set(); // 空Set var s2 = new Set([1, 2, 3]); // 含1, 2, 3 重复元素在 Set 中自动被过滤： var s = new Set([1, 2, 3, 3, '3']); s; // Set {1, 2, 3, \"3\"} 通过 add(key) 方法可以添加元素到 Set 中，可以重复添加，但不会有效果： s.add(4); s; // Set {1, 2, 3, 4} s.add(4); s; // 仍然是 Set {1, 2, 3, 4} 通过 delete(key) 方法可以删除元素： var s = new Set([1, 2, 3]); s; // Set {1, 2, 3} s.delete(3); s; // Set {1, 2} ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:2:3","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"iterable 遍历 Array 可以采用下标循环，遍历 Map 和 Set 就无法使用下标。为了统一集合类型，ES6标准引入了新的 iterable 类型，Array、Map 和 Set都属于 iterable 类型。 for … of 具有 iterable 类型的集合可以通过新的 for ... of 循环来遍历。 for ... of 循环是ES6引入的新的语法， var a = ['A', 'B', 'C']; var s = new Set(['A', 'B', 'C']); var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); for (var x of a) { // 遍历Array console.log(x); } for (var x of s) { // 遍历Set console.log(x); } for (var x of m) { // 遍历Map console.log(x[0] + '=' + x[1]); } forEach 更好的方式是直接使用 iterable 内置的 forEach 方法，它接收一个函数，每次迭代就自动回调该函数 var a = ['A', 'B', 'C']; a.forEach(function (element, index, array) { // element: 指向当前元素的值 // index: 指向当前索引 // array: 指向Array对象本身 console.log(element + ', index = ' + index); }); Set 与 Array 类似，但 Set 没有索引，因此回调函数的前两个参数都是元素本身： var s = new Set(['A', 'B', 'C']); s.forEach(function (element, sameElement, set) { console.log(element); }); Map 的回调函数参数依次为 value、key 和 map 本身： var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]); m.forEach(function (value, key, map) { console.log(value); }); 如果对某些参数不感兴趣，由于 JavaScript 的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得 Array 的 element： var a = ['A', 'B', 'C']; a.forEach(function (element) { console.log(element); }); for in 和 for of 辨析 for… in 遍历对象时，得到 key 遍历数组时，得到下标 for… of 遍历数组时，得到值 不能遍历对象 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:2:4","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"函数 //1、利用函数关键字 function 函数名() { //函数体 } //2、函数表达式（匿名函数，只有变量名没有函数名） var 变量名 = function () { //函数体 }; 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined 在第二种声明方式下，function (x) { ... } 是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量 变量名，所以，通过变量变量名就可以调用该函数。上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个 ;，表示赋值语句结束。 由于 JavaScript 允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数 传入的参数比定义的少也没有问题，返回 NaN ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:0","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"arguements JavaScript还有一个免费赠送的关键字 arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments 类似Array 但它不是一个 Array function foo(x) { console.log('x = ' + x); // 10 for (var i=0; i\u003carguments.length; i++) { console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30 } } foo(10, 20, 30); //输出 x = 10 arg 0 = 10 arg 1 = 20 arg 2 = 30 利用 arguments，可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值 function abs() { if (arguments.length === 0) { return 0; } var x = arguments[0]; return x \u003e= 0 ? x : -x; } abs(); // 0 abs(10); // 10 abs(-9); // 9 实际上 arguments 最常用于判断传入参数的个数。你可能会看到这样的写法： // foo(a[, b], c) // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null： function foo(a, b, c) { if (arguments.length === 2) { // 实际拿到的参数是a和b，c为undefined c = b; // 把b赋给c b = null; // b变为默认值 } // ... } 要把中间的参数 b 变为“可选”参数，就只能通过 arguments 判断，然后重新调整参数并赋值。 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:1","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"rest function foo(a, b, ...rest) { console.log('a = ' + a); console.log('b = ' + b); console.log(rest); } foo(1, 2, 3, 4, 5); // 结果: // a = 1 // b = 2 // Array [ 3, 4, 5 ] foo(1); // 结果: // a = 1 // b = undefined // Array [] rest 参数只能写在最后，前面用 ... 标识，传入的参数先绑定a、b，多余的参数以数组形式交给变量 rest，所以，不再需要 arguments 我们就获取了全部参数。 如果传入的参数连正常定义的参数都没填满，也不要紧，rest 参数会接收一个空数组（注意不是 undefined ） function sum(...rest) { var result = 0; for (var i = 0; i \u003c rest.length; i++) { result += rest[i]; } return result; } ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:2","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"变量作用域与解构赋值 如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量 不同函数内部的同名变量互相独立，互不影响 由于 JavaScript 的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行 function foo() { var x = 1; function bar() { var y = x + 1; // bar可以访问foo的变量x! } var z = y + 1; // ReferenceError! foo不可以访问bar的变量y! } JavaScript 的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量 function foo() { var x = 1; function bar() { var x = 'A'; console.log('x in bar() = ' + x); // 'A' } console.log('x in foo() = ' + x); // 1 bar(); } ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:3","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"变量提升 JavaScript 的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部 function foo() { var x = 'Hello, ' + y; console.log(x); var y = 'Bob'; } 语句 var x = 'Hello, ' + y; 并不报错，原因是变量 y 在稍后申明了。但是 console.log 显示 Hello, undefined，说明变量 y 的值为 undefined。这正是因为 JavaScript 引擎自动提升了变量 y 的声明，但不会提升变量 y 的赋值。 由于 JavaScript 的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个 var 申明函数内部用到的所有变量 function foo() { var x = 1, // x初始化为1 y = x + 1, // y初始化为2 z, i; // z和i为undefined // 其他语句: for (i=0; i\u003c100; i++) { ... } } ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:4","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"全局作用域 不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到 window 的一个属性： 例如，直接访问全局变量 course 和访问 window.course 是完全一样的。 顶层函数的定义也被视为一个全局变量，并绑定到 window 对象： var course = 'Learn JavaScript'; alert(course); // 'Learn JavaScript' alert(window.course); // 'Learn JavaScript' function foo() { alert('foo'); } foo(); // 直接调用foo() window.foo(); // 通过window.foo()调用 这说明 JavaScript 实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报 ReferenceError 错误 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:5","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"名字空间 全局变量会绑定到 window 上，不同的 JavaScript 文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中 // 唯一的全局变量MYAPP: var MYAPP = {}; // 其他变量: MYAPP.name = 'myapp'; MYAPP.version = 1.0; // 其他函数: MYAPP.foo = function () { return 'foo'; }; 把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:6","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"局部作用域 由于 JavaScript 的变量作用域实际上是函数内部，我们在 for 循环等语句块中是无法定义具有局部作用域的变量的： function foo() { for (var i=0; i\u003c100; i++) { // } i += 100; // 仍然可以引用变量i } 为了解决块级作用域，ES6引入了新的关键字 let，用 let 替代 var 可以申明一个块级作用域的变量： function foo() { var sum = 0; for (let i=0; i\u003c100; i++) { sum += i; } // SyntaxError: i += 1; } ==let 的具体作用==：https://typescript.bootcss.com/variable-declarations.html ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:7","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"常量 由于 var 和 let 申明的是变量，如果要申明一个常量，在 ES6 之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值” var PI = 3.14; ES6标准引入了新的关键字 const 来定义常量，const 与 let 都具有块级作用域： 'use strict'; const PI = 3.14; PI = 3; // 某些浏览器不报错，但是无效果！ PI; // 3.14 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:8","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"解构赋值 从 ES6 开始，JavaScript 引入了解构赋值，可以同时对一组变量进行赋值。 var [x, y, z] = ['hello', 'JavaScript', 'ES6']; 详解 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致 let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; x; // 'hello' y; // 'JavaScript' z; // 'ES6' 解构赋值还可以忽略某些元素 let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素 z; // 'ES6' 如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性 var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school', address: { city: 'Beijing', street: 'No.1 Road', zipcode: '100001' } }; var {name, address: {city, zip}} = person; name; // '小明' city; // 'Beijing' zip; // undefined, 因为属性名是zipcode而不是zip // 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性: address; // Uncaught ReferenceError: address is not defined 如果要使用的变量名和属性名不一致，可以用下面的语法获取 var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school' }; // 把passport属性赋值给变量id: let {name, passport:id} = person; name; // '小明' id; // 'G-12345678' // 注意: passport不是变量，而是为了让变量id获得passport属性: passport; // Uncaught ReferenceError: passport is not defined 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题 var person = { name: '小明', age: 20, gender: 'male', passport: 'G-12345678' }; // 如果person对象没有single属性，默认赋值为true: var {name, single=true} = person; name; // '小明' single; // true 有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误 // 声明变量: var x, y; // 解构赋值: {x, y} = { name: '小明', x: 100, y: 200}; // 语法错误: Uncaught SyntaxError: Unexpected token = 这是因为JavaScript引擎把 { 开头的语句当作了块处理，于是 = 不再合法。解决方法是用小括号括起来： ({x, y} = { name: '小明', x: 100, y: 200}); 使用场景 解构赋值在很多时候可以大大简化代码。例如，交换两个变量x和y的值，可以这么写，不再需要临时变量： var x=1, y=2; [x, y] = [y, x]快速获取当前页面的域名和路径： var {hostname:domain, pathname:path} = location; 如果一个函数接收一个对象作为参数，那么，可以使用解构直接把对象的属性绑定到变量中。例如，下面的函数可以快速创建一个Date对象： function buildDate({year, month, day, hour=0, minute=0, second=0}) { return new Date(year + '-' + month + '-' + day + ' ' + hour + ':' + minute + ':' + second); } 它的方便之处在于传入的对象只需要year、month和day这三个属性： buildDate({ year: 2017, month: 1, day: 1 }); // Sun Jan 01 2017 00:00:00 GMT+0800 (CST) 也可以传入hour、minute和second属性： buildDate({ year: 2017, month: 1, day: 1, hour: 20, minute: 15 }); // Sun Jan 01 2017 20:15:00 GMT+0800 (CST) 使用解构赋值可以减少代码量，但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行。目前支持解构赋值的浏览器包括Chrome，Firefox，Edge等 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:9","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"方法 在一个对象中绑定函数，称为这个对象的方法 var xiaoming = { name: '小明', birth: 1990, age: function () { var y = new Date().getFullYear(); return y - this.birth; } }; xiaoming.age; // function xiaoming.age() xiaoming.age(); // 今年调用是25,明年调用就变成26了 在一个方法内部，this 是一个特殊变量，它始终指向当前对象，也就是 xiaoming 这个变量。所以，this.birth 可以拿到 xiaoming 的 birth 属性。 函数嵌套中的 this 用法 用var that = this;，你就可以放心地在方法内部定义其他函数 var xiaoming = { name: '小明', birth: 1990, age: function () { var that = this; // 在方法内部一开始就捕获this function getAgeFromBirth() { var y = new Date().getFullYear(); return y - that.birth; // 用that而不是this } return getAgeFromBirth(); } }; xiaoming.age(); // 25 apply 要指定函数的 this 指向哪个对象，可以用函数本身的 apply 方法，它接收两个参数，第一个参数就是需要绑定的 this 变量，第二个参数是 Array，表示函数本身的参数。 用 apply 修复 getAge() 调用 function getAge() { var y = new Date().getFullYear(); return y - this.birth; } var xiaoming = { name: '小明', birth: 1990, age: getAge }; xiaoming.age(); // 25 getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空 另一个与 apply() 类似的方法是 call()，唯一区别是： apply() 把参数打包成 Array 再传入； call() 把参数按顺序传入。 比如调用 Math.max(3, 5, 4)，分别用 apply() 和 call() 实现如下： Math.max.apply(null, [3, 5, 4]); // 5 Math.max.call(null, 3, 5, 4); // 5 对普通函数调用，我们通常把 this 绑定为 null。 装饰器 利用 apply()，我们还可以动态改变函数的行为。 JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。 例 现在假定我们想统计一下代码一共调用了多少次 parseInt()，可以把所有的调用都找出来，然后手动加上 count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的 parseInt()： var count = 0; var oldParseInt = parseInt; // 保存原函数 window.parseInt = function () { count += 1; return oldParseInt.apply(null, arguments); // 调用原函数 }; ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:10","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"高阶函数 JavaScript 的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数 function add(x, y, f) { return f(x) + f(y); } 编写高阶函数，就是让函数的参数能够接收别的函数 map 要把一个函数作用在一个数组上，就可以用 map 实现 map() 方法定义在 JavaScript 的 Array 中 function pow(x) { return x * x; } var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]; var results = arr.map(pow); console.log(results); // [1, 4, 9, 16, 25, 36, 49, 64, 81] reduce Array 的 reduce() 把一个函数作用在这个 Array 的 [x1, x2, x3...] 上，这个函数必须接收两个参数，reduce() 把结果继续和序列的下一个元素做累积计算，其效果就是： [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4) 比方说对一个Array求和，就可以用reduce实现 var arr = [1, 3, 5, 7, 9]; arr.reduce(function (x, y) { return x + y; }); // 25 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:11","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"箭头函数 箭头函数包括一个参数列表（零个或多个参数，如果参数个数不是一个的话要用 () 包围起来），然后是标识 =\u003e，函数体放在最后。 只有在函数体的表达式个数多于 1 个，或者函数体包含非表达式语句的时候才需要用 {} 包围。如果只有一个表达式，并且省略了包围的 {} 的话，则意味着表达式前面有一个隐含的 return。 var f1 = () =\u003e 12; var f2 = x =\u003e x * 2; var f3 = (x,y) =\u003e { var z = x * 2 + y; y++; x *= 3; return (x + y + z) / 2; }; ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:3:12","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"面向对象编程 JavaScript 不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。 JavaScript 的原型链和 Java 的 Class 区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:4:0","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"创建对象 原型回溯 JavaScript 对每个创建的对象都会设置一个原型，指向它的原型对象。 当我们用 obj.xxx 访问一个对象的属性时，JavaScript 引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到 Object.prototype 对象，最后，如果还没有找到，就只能返回 undefined 创建一个 Array 对象： var arr = [1, 2, 3]; ​ 其原型链是： arr ----\u003e Array.prototype ----\u003e Object.prototype ----\u003e null 创建一个函数时： function foo() { return 0; } ​ 函数也是一个对象，它的原型链是： foo ----\u003e Function.prototype ----\u003e Object.prototype ----\u003e null 如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长 构造函数 例 function Cat(name) { this.name = name; // this.say = function () { // alert('miao~ ' + this.name); // } } Cat.prototype.say = function () { alert('miao~ ' + this.name); } var cat1 = new Cat('aa'); var cat2 = new Cat('bb'); cat1.say(); cat2.say(); 构造 除了直接用 { ... } 创建一个对象外，JavaScript 还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数 function Student(name) { this.name = name; this.hello = function () { alert('Hello, ' + this.name + '!'); } } 按照约定，构造函数首字母应当大写，而普通函数首字母应当小写 调用 用关键字 new 来调用这个函数，并返回一个对象 var xiaoming = new Student('小明'); xiaoming.name; // '小明' xiaoming.hello(); // Hello, 小明! 如果不写 new，这就是一个普通函数，它返回 undefined。但是，如果写了 new，它就变成了一个构造函数，它绑定的 this 指向新创建的对象，并默认返回 this，也就是说，不需要在最后写 return this; constructor 属性 对象会从原型上获得了个 constructor属性，它指向构造函数本身 xiaoming.constructor === Student.prototype.constructor === Student; Object.getPrototypeOf(xiaoming) === Student.prototype; // true xiaoming instanceof Student; // true 共享函数 Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 要让创建的对象共享一个函数，根据对象的属性查找原则，我们只要把这个函数移动到对象共同的原型上就可以了，在例子中也就是 Student.prototype 修改代码如下： function Student(name) { this.name = name; } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; 封装 可以编写一个 createStudent() 函数，在内部封装所有的 new 操作。一个常用的编程模式像这样： function Student(props) { this.name = props.name || '匿名'; // 默认值为'匿名' this.grade = props.grade || 1; // 默认值为1 } Student.prototype.hello = function () { alert('Hello, ' + this.name + '!'); }; function createStudent(props) { return new Student(props || {}) } 这个 createStudent() 函数有几个巨大的优点：一是不需要 new 来调用，二是参数非常灵活，可以不传，也可以这么传： var xiaoming = createStudent({ name: '小明' }); xiaoming.grade; // 1 如果创建的对象有很多属性，我们只需要传递需要的某些属性，剩下的属性可以用默认值。由于参数是一个 Object，我们无需记忆参数的顺序。如果恰好从 JSON 拿到了一个对象，就可以直接创建出 xiaoming。 原型继承 在传统的基于 Class 的语言如 Java、C++ 中，继承的本质是扩展一个已有的 Class，并生成新的 Subclass。 由于这类语言严格区分类和实例，继承实际上是类型的扩展。但是，JavaScript 由于采用原型继承，我们无法直接扩展一个 Class，因为根本不存在 Class 这种类型。 JS 的继承就你妈是一坨屎，暂且不学 class 继承 新的关键字 class 从 ES6 开始正式被引入到 JavaScript 中。class 的目的就是让定义类更简单。 class Student { constructor(name) { this.name = name; } hello() { alert('Hello, ' + this.name + '!'); } } 比较一下就可以发现，class 的定义包含了构造函数 constructor 和定义在原型对象上的函数 hello()（注意没有 function 关键字），这样就避免了 Student.prototype.hello = function () {...} 这样分散的代码。 用 class 定义对象，继承可以直接通过 extends 来实现 class PrimaryStudent extends Student { constructor(name, grade) { super(name); // 记得用super调用父类的构造方法! this.grade = grade; } myGrade() { alert('I am at grade ' + this.grade); } } ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:4:1","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"骚皮操作 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:5:0","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["前端"],"content":"! 与 ？ ! 用法 用在变量前表示取反 用在赋值的内容后时，使 null 和 undefined 类型可以赋值给其他类型并通过编译 let y:number y = null // 无法通过编译 y = undefined // 无法通过编译 y = null! y = undefined! // 由于x是可选的，因此parma.x的类型为number | undefined，无法传递给number类型的y，因此需要用x! interface IDemo { x?: number } let y:number const demo = (parma: IDemo) =\u003e { y = parma.x! return y } 如果存在空情况的判断并赋具体值时，可以不用 !，但是如果要想令 y 存在等于 undefined 的情况还是需要用! interface IDemo { x?: number } let y:number const demo = (parma: IDemo) =\u003e { y = parma.x || 1 // 如果为undefined，返回y=1，如果不为undefined，则返回parma.x的值 return y } ? 用法 除了表示可选参数外 当使用 A 对象属性 A.B 时，如果无法确定 A 是否为空，则需要用 A?.B，表示当A有值的时候才去访问 B 属性，没有值的时候就不去访问，如果不使用?则会报错 // 由于函数参数可选，因此parma无法确定是否拥有，所以无法正常使用parma.x，使用parma?.x向编译器假设此时parma不为空且为IDemo类型，同时parma?.x无法保证非空，因此使用parma?.x!来保证了整体通过编译 interface IDemo { x: number } let y:number const demo = (parma?: IDemo) =\u003e { y = parma?.x! console.log(parma?.x) // 只是单纯调用属性时就无需! return y } // 如果使用y = parma!.x!是会报错的，因为当parma为空时，是不拥有x属性的，会报找不到x的错误 但是 ? 用法只能读操作而不能写操作，对一个可能为空的属性赋值是不会被编译通过的，此时还需用用到类型断言 interface IDemo { x: number } // 编译报错，不能赋值给可选属性 const demo = (parma?: IDemo) =\u003e { parma?.x = 1 } // 使用类型断言 const demo = (parma?: IDemo) =\u003e { let _parma = parma as IDemo _parma.x = 1 } ?? 用法 空值合并操作符（??）是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。 ","date":"2021-10-23","objectID":"/Notes/posts/frontend/javascript/basicgrammar/:5:1","tags":["JavaScript","前端"],"title":"JavaScript 基本语法","uri":"/Notes/posts/frontend/javascript/basicgrammar/"},{"categories":["Linux"],"content":"环境安装 ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/install/:0:0","tags":["Linux","快速入门"],"title":"Linux 上的环境安装","uri":"/Notes/posts/linux/useful/install/"},{"categories":["Linux"],"content":"Node.js 执行以下命令，下载 Node.js Linux 64位二进制安装包。 wget https://nodejs.org/dist/v10.16.3/node-v10.16.3-linux-x64.tar.xz 执行以下命令，解压安装包。 tar xvf node-v10.16.3-linux-x64.tar.xz 依次执行以下命令，创建软链接。 ln -s /root/node-v10.16.3-linux-x64/bin/node /usr/local/bin/node ln -s /root/node-v10.16.3-linux-x64/bin/npm /usr/local/bin/npm 成功创建软链接后，即可在云服务器任意目录下使用 node 及 npm 命令。 依次执行以下命令，查看 Node.js 及 npm 版本信息。 node -v npm -v ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/install/:1:0","tags":["Linux","快速入门"],"title":"Linux 上的环境安装","uri":"/Notes/posts/linux/useful/install/"},{"categories":["Linux"],"content":"Go ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/install/:2:0","tags":["Linux","快速入门"],"title":"Linux 上的环境安装","uri":"/Notes/posts/linux/useful/install/"},{"categories":["Linux"],"content":"安装 下载go源码包 //下载地址 go官网 https://golang.org/dl/ cd /opt/ wget https://dl.google.com/go/go1.11.4.linux-amd64.tar.gz 4.解压缩go源码包，确认当前linux系统版本是32位还是64位，再选择go源码包 //查看linux多少位 [root@pyyuc /opt 21:59:02]#uname -m x86_64 //决定下载64位 tar -zxvf go1.11.4.linux-amd64.tar.gz //解压缩后go源码路径确保为 /opt/go/ 给予 go 目录权限 sudo chmod -R 777 go/ sudo chmod -R 777 gocode/ ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/install/:2:1","tags":["Linux","快速入门"],"title":"Linux 上的环境安装","uri":"/Notes/posts/linux/useful/install/"},{"categories":["Linux"],"content":"配置环境变量 配置go的工作空间(配置GOPATH)，以及go的环境变量 go的代码必须在GOPATH中，也就是一个工作目录，目录包含三个子目录 $GOPATH src 存放go源代码的目录,存放golang项目的目录，所有项目都放到gopath的src目录下 bin 在go install后生成的可执行文件的目录 pkg 编译后生成的，源码文件，如.a 创建/opt/gocode/{src,bin,pkg}，用于设置GOPATH为/opt/godocer mkdir -p /opt/gocode/{src,bin,pkg} /opt/gocode/ ├── bin ├── pkg └── src 6.设置GOPATH环境变量 修改/etc/profile系统环境变量文件，写入GOPATH信息以及go sdk路径 export GOROOT=/opt/go #Golang源代码目录，安装目录 export GOPATH=/opt/gocode #Golang项目代码目录 export PATH=$GOROOT/bin:$PATH #Linux环境变量 export PATH=$GOPATH/bin:$PATH #Linux环境变量 s export GOBIN=$GOPATH/bin #go install后生成的可执行命令存放路径 读取/etc/profile，立即生效 source /etc/profile #读取环境变量 查看 go 环境是否生效 //查看go环境变量路径 which go //查看go语言环境信息 go env //查看go版本，查看是否安装成功 [root@pyyuc ~ 22:59:05]#go version go version go1.11.4 linux/amd64 ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/install/:2:2","tags":["Linux","快速入门"],"title":"Linux 上的环境安装","uri":"/Notes/posts/linux/useful/install/"},{"categories":["Linux"],"content":"screen ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/screen/:0:0","tags":["Linux","快速入门"],"title":"screen","uri":"/Notes/posts/linux/useful/screen/"},{"categories":["Linux"],"content":"概述 Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。 在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。 ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/screen/:1:0","tags":["Linux","快速入门"],"title":"screen","uri":"/Notes/posts/linux/useful/screen/"},{"categories":["Linux"],"content":"语法 screen [-AmRvx -ls -wipe] [-d \u003c作业名称\u003e] [-h \u003c行数\u003e] [-r \u003c作业名称\u003e] [-s ] [-S \u003c作业名称\u003e] ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/screen/:2:0","tags":["Linux","快速入门"],"title":"screen","uri":"/Notes/posts/linux/useful/screen/"},{"categories":["Linux"],"content":"参数说明 -A 将所有的视窗都调整为目前终端机的大小。 -d \u003c作业名称\u003e 将指定的 screen 作业离线。 -h \u003c行数\u003e 指定视窗的缓冲区行数。 -m 即使目前已在作业中的 screen 作业，仍强制建立新的 screen 作业。 -r \u003c作业名称\u003e 恢复离线的screen作业。 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。 -s 指定建立新视窗时，所要执行的shell。 -S \u003c作业名称\u003e 指定 screen 作业的名称。 -v 显示版本信息。 -x 恢复之前离线的 screen 作业。 -ls 或 –list 显示目前所有的 screen 作业。 -wipe 检查目前所有的 screen 作业，并删除已经无法使用的 screen 作业。 ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/screen/:2:1","tags":["Linux","快速入门"],"title":"screen","uri":"/Notes/posts/linux/useful/screen/"},{"categories":["Linux"],"content":"常用命令 screen -S yourname 新建一个叫 yourname 的 session screen -ls 列出当前所有的 session screen -r yourname 回到 yourname 这个 session screen -d yourname 远程 detach 某个 session screen -d -r yourname 结束当前 session 并回到 yourname 这个 session ","date":"2021-10-23","objectID":"/Notes/posts/linux/useful/screen/:2:2","tags":["Linux","快速入门"],"title":"screen","uri":"/Notes/posts/linux/useful/screen/"},{"categories":["前端"],"content":"TypeScript ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:0:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"简介 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:1:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"认识 TypeScript 是一种给 JavaScript 添加特性的语言扩展。增加的功能包括： 类型批注和编译时类型检查 类型推断 类型擦除 接口 枚举 Mixin 泛型编程 名字空间 元组 Await TypeScript 作为 JavaScript 的超集，他在拥有 JavaScript 所有能力的基础上，做到了静态类型，这解决了 JavaScript 编写不规范会导致的很多问题，虽然它依旧是弱类型语言，但它在变量进行类型隐式转换时也做了限制，让它在编写的过程中可以更加规范。而不规范的地方，会直接报错来提醒开发者。 TypeScript 的类型推导是基于上下文类型推导（Contextual Typing）的。所以即便你不添加任何类型，编译器也会根据编写的代码，推导出变量或函数的类型，当无法推导出的时候，TypeScript 则将其设置为any const hello : string = \"Hello World!\" console.log(hello) ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:1:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"TS 与 JS 的区别 TypeScript JavaScript JavaScript 的超集用于解决大型项目的代码复杂性 一种脚本语言，用于创建动态网页。 可以在编译期间发现并纠正错误 作为一种解释型语言，只能在运行时发现错误 强类型，支持静态和动态类型 弱类型，没有静态类型选项 最终被编译成 JavaScript 代码，使浏览器可以理解 可以直接在浏览器中使用 支持模块、泛型和接口 不支持模块，泛型或接口 支持 ES3，ES4，ES5 和 ES6 等 不支持编译其他 ES3，ES4，ES5 或 ES6 功能 社区的支持仍在增长，而且还不是很大 大量的社区支持以及大量文档和解决问题的支持 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:1:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"安装 针对使用 npm 的用户： npm install -g typescript # or npm i -g typescript 使用命令来执行 ts 代码： tsc file1.ts node file.js 简化执行步骤 安装 ts-node npm i -g ts-node 执行 ts-node f ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:1:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"基础类型 我们使用 let 关键字来代替大家所熟悉的 JavaScript 关键字 var。 let 关键字是 JavaScript 的一个新概念，TypeScript 实现了它。很多常见的问题都可以通过使用 let 来解决，所以尽可能地使用 let 来代替 var 吧。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"布尔值 boolean let isDone: boolean = false; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"数字 number 和 JavaScript 一样，TypeScript 里的所有数字都是浮点数 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; let octalLiteral: number = 0o744; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"字符串 string let name: string = \"bob\"; name = \"smith\"; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"数组 list 两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组： let list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array\u003c元素类型\u003e： let list: Array\u003cnumber\u003e = [1, 2, 3]; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"元组 tuple 元组类型允许表示一个已知元素数量和类型的数组（各元素的类型不必相同） // Declare a tuple type let x: [string, number]; // Initialize it x = ['hello', 10]; // OK // Initialize it incorrectly x = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： console.log(x[0].substr(1)); // OK console.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型 console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString x[6] = true; // Error, 布尔不是(string | number)类型 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:5","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"枚举 enum enum 类型是对 JavaScript 标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字。 enum Color {Red, Green, Blue} let c: Color = Color.Green; 指定编号 默认情况下，从 0 开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1 开始编号： enum Color {Red = 1, Green, Blue} let c: Color = Color.Green; // 或者，全部都采用手动赋值： enum Color {Red = 1, Green = 2, Blue = 4} let c: Color = Color.Green; 字符串枚举 在 TypeScript 2.4 版本，允许我们使用字符串枚举。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 enum Direction { NORTH = \"NORTH\", SOUTH = \"SOUTH\", EAST = \"EAST\", WEST = \"WEST\", } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:6","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"任意值 any 有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这种情况下，我们不希望类型检查器对这些值进行检查。 那么我们可以使用 any 类型来标记这些变量： let notSure: any = 4; notSure = \"maybe a string instead\"; notSure = false; // okay, definitely a boolean 在 TypeScript 中，任何类型都可以被归为 any 类型。这让 any 类型成为了类型系统的顶级类型（也被称作全局超级类型）。 any 类型本质上是类型系统的一个逃逸舱。作为开发者，这给了我们很大的自由：TypeScript 允许我们对 any 类型的值执行任何操作，而无需事先执行任何形式的检查。 let value: any; value.foo.bar; // OK value.trim(); // OK value(); // OK new value(); // OK value[0][1]; // OK 在许多场景下，这太宽松了。使用 any 类型，可以很容易地编写类型正确但在运行时有问题的代码。如果我们使用 any 类型，就无法使用 TypeScript 提供的大量的保护机制。为了解决 any 带来的问题，TypeScript 3.0 引入了 unknown 类型。 当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据： let list: any[] = [1, true, \"free\"]; list[1] = 100; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:7","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"unknown 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。这使得 unknown 成为 TypeScript 类型系统的另一种顶级类型（另一种是 any）。 对 value 变量的所有赋值都被认为是类型正确的： let value: unknown; value = true; // OK value = 42; // OK value = \"Hello World\"; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\"type\"); // OK unknown 类型只能被赋值给 any 类型和 unknown 类型本身： let value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error let value7: any[] = value; // Error let value8: Function = value; // Error 对类型为 unknown 的值执行操作是非法的： let value: unknown; value.foo.bar; // Error value.trim(); // Error value(); // Error new value(); // Error value[0][1]; // Error 通过将 any 类型改变为 unknown 类型，我们已将允许所有更改的默认设置，更改为禁止任何更改。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:8","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"空值 void 某种程度上来说，void 类型像是与 any 类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void function warnUser(): void { alert(\"This is my warning message\"); } 声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null： let unusable: void = undefined; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:9","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"Null 和 Undefined TypeScript 里，undefined 和 null 两者各自有自己的类型分别叫做 undefined 和 null。 和 void 相似，它们的本身的类型用处不是很大… // Not much else we can assign to these variables! let u: undefined = undefined; let n: null = null; 默认情况下 null 和 undefined 是所有类型的子类型。 就是说你可以把他们赋值给 number 类型的变量 然而，当你指定了 --strictNullChecks 标记，null 和 undefined只能赋值给 void 和它们各自。 这能避免很多常见的问题。 也许在某处你想传入一个 string 或 null 或 undefined，你可以使用联合类型 string | null | undefined。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:10","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"never never 类型表示的是那些永不存在的值的类型 例如，never 类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型 变量也可能是 never 类型，当它们被永不为真的类型保护所约束时。 never 类型是任何类型的子类型，也可以赋值给任何类型 然而，没有类型是 never 的子类型或可以赋值给 never 类型（除了 never 本身之外）。 即使 any 也不可以赋值给 never。 // 返回never的函数必须存在无法达到的终点 function error(message: string): never { throw new Error(message); } // 推断的返回值类型为never function fail() { return error(\"Something failed\"); } // 返回never的函数必须存在无法达到的终点 function infiniteLoop(): never { while (true) { } } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:2:11","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"类型断言 有时候你会遇到这样的情况，你会比 TypeScript 更了解某个值的详细信息。通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型时 通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。类型断言好比其他语言里的类型转换，但是不进行特殊的数据检查和解构。它没有运行时的影响，只是在编译阶段起作用。 类型断言有两种形式 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:3:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"“尖括号” 语法 let someValue: any = \"this is a string\"; let strLength: number = (\u003cstring\u003esomeValue).length; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:3:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"as 语法 let someValue: any = \"this is a string\"; let strLength: number = (someValue as string).length; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:3:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"类型守卫 A type guard is some expression that performs a runtime check that guarantees the type in some scope. 类型保护是可执行运行时检查的一种表达式，用于确保该类型在一定的范围内。 换句话说，类型保护可以保证一个字符串是一个字符串，尽管它的值也可以是一个数值。 类型保护与特性检测并不是完全不同，其主要思想是尝试检测属性、方法或原型，以确定如何处理值。目前主要有四种的方式来实现类型保护： ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:4:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"in 关键字 interface Admin { name: string; privileges: string[]; } interface Employee { name: string; startDate: Date; } type UnknownEmployee = Employee | Admin; function printEmployeeInformation(emp: UnknownEmployee) { console.log(\"Name: \" + emp.name); if (\"privileges\" in emp) { console.log(\"Privileges: \" + emp.privileges); } if (\"startDate\" in emp) { console.log(\"Start Date: \" + emp.startDate); } } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:4:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"typeof 关键字 function padLeft(value: string, padding: string | number) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`); } typeof 类型保护只支持两种形式：typeof v === \"typename\" 和 typeof v !== typename； \"typename\" 必须是 \"number\"， \"string\"， \"boolean\" 或 \"symbol\"。 但是 TypeScript 并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:4:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"instanceof 关键字 interface Padder { getPaddingString(): string; } class SpaceRepeatingPadder implements Padder { constructor(private numSpaces: number) {} getPaddingString() { return Array(this.numSpaces + 1).join(\" \"); } } class StringPadder implements Padder { constructor(private value: string) {} getPaddingString() { return this.value; } } let padder: Padder = new SpaceRepeatingPadder(6); if (padder instanceof SpaceRepeatingPadder) { // padder的类型收窄为 'SpaceRepeatingPadder' } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:4:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"自定义类型保护的类型谓词 function isNumber(x: any): x is number { return typeof x === \"number\"; } function isString(x: any): x is string { return typeof x === \"string\"; } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:4:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"接口 interface TypeScript 的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在 TypeScript 里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 interface LabelledValue { label: string; } function printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label); } let myObj = {size: 10, label: \"Size 10 Object\"}; printLabel(myObj); LabelledValue 接口就好比一个名字，用来描述上面例子里的要求。 它代表了有一个 label 属性且类型为string 的对象，上述代码等同于： function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label); } let myObj = { size: 10, label: \"Size 10 Object\" }; printLabel(myObj); 编译器只会检查那些必需的属性是否存在，并且其类型是否匹配。 类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"可选属性 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。 在可选属性名字定义的后面加一个 ? 符号 interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): {color: string; area: number} { let newSquare = {color: \"white\", area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare; } let mySquare = createSquare({color: \"black\"}); ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 可以在属性名前用 readonly 来指定只读属性 interface Point { readonly x: number; readonly y: number; } let p1: Point = { x: 10, y: 20 }; p1.x = 5; // error! TypeScript 具有 ReadonlyArray\u003cT\u003e 类型，它与 Array\u003cT\u003e 相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： let a: number[] = [1, 2, 3, 4]; let ro: ReadonlyArray\u003cnumber\u003e = a; ro[0] = 12; // error! ro.push(5); // error! ro.length = 100; // error! a = ro; // error! ReadonlyArray 不可赋值。要做到这点，可以用类型断言重写： a = ro as number[]; 最简单判断该用 readonly 还是 const 的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用 readonly。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"额外的属性检查 对象字面量会被特殊对待而且会经过额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误： interface SquareConfig { color?: string; width?: number; } function createSquare(config: SquareConfig): { color: string; area: number } { // ... } // error: 'colour' not expected in type 'SquareConfig' let mySquare = createSquare({ colour: \"red\", width: 100 }); 要绕开这些检查， 最简便的方法是使用类型断言： let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 但最佳的方式是能够添加一个字符串索引签名（前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性）： interface SquareConfig { color?: string; width?: number; [propName: string]: any; } 还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： let squareOptions = { colour: \"red\", width: 100 }; let mySquare = createSquare(squareOptions); 因为 squareOptions 不会经过额外属性检查，所以编译器不会报错 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"函数类型 除了描述带有属性的普通对象外，接口也可以描述函数类型 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 interface SearchFunc { (source: string, subString: string): boolean; } let mySearch: SearchFunc; mySearch = function(source: string, subString: string) { let result = source.search(subString); return result \u003e -1; } 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配： let mySearch: SearchFunc; mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result \u003e -1; } 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的 如果你不想指定类型，TypeScript 的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc 类型变量 let mySearch: SearchFunc; mySearch = function(src, sub) { let result = src.search(sub); return result \u003e -1; } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"可索引的类型 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如 a[10] 或 ageMap[\"daniel\"] 可索引类型具有一个索引签名，它描述了对象索引的类型，还有相应的索引返回值类型 interface StringArray { [index: number]: string; } let myArray: StringArray; myArray = [\"Bob\", \"Fred\"]; let myStr: string = myArray[0]; 共有支持两种索引签名：字符串和数字 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number 来索引时，JavaScript 会将它转换成 string 然后再去索引对象。 也就是说用 100（一个 number）去索引等同于使用 \"100\"（一个 string）去索引，因此两者需要保持一致。 class Animal { name: string; } class Dog extends Animal { breed: string; } // 错误：使用'string'索引，有时会得到Animal! interface NotOkay { [x: number]: Animal; [x: string]: Dog; } 字符串索引签名能够很好的描述 dictionary 模式，并且它们也会确保所有属性与其返回值类型相匹配，因为字符串索引声明了 obj.property 和 obj[\"property\"] 两种形式都可以 下面的例子里，name 的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示： interface NumberDictionary { [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配 } 可以将索引签名设置为只读，这样就防止了给索引赋值： interface ReadonlyStringArray { readonly [index: number]: string; } let myArray: ReadonlyStringArray = [\"Alice\", \"Bob\"]; myArray[2] = \"Mallory\"; // error! ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:5","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"类类型 实现接口 与 C# 或 Java 里接口的基本作用一样，TypeScript 也能够用它来明确的强制一个类去符合某种契约。 interface ClockInterface { currentTime: Date; } class Clock implements ClockInterface { currentTime: Date; constructor(h: number, m: number) { } } 可以在接口中描述一个方法，在类里实现它： interface ClockInterface { currentTime: Date; setTime(d: Date); } class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { } } 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:5:6","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"联合类型和类型别名 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:6:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"联合类型 联合类型通常与 null 或 undefined 一起使用： const sayHello = (name: string | undefined) =\u003e { /* ... */ }; sayHello(\"Semlinker\"); sayHello(undefined); ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:6:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"可辨识联合 可辨识联合（Discriminated Unions）类型，也称为代数数据类型或标签联合类型。它包含 3 个要点：可辨识、联合类型和类型守卫。 这种类型的本质是结合联合类型和字面量类型的一种类型保护方法。如果一个类型是多个类型的联合类型，且多个类型含有一个公共属性，那么就可以利用这个公共属性，来创建不同的类型保护区块。 可辨识 可辨识要求联合类型中的每个元素都含有一个单例类型属性，比如： enum CarTransmission { Automatic = 200, Manual = 300 } interface Motorcycle { vType: \"motorcycle\"; // discriminant make: number; // year } interface Car { vType: \"car\"; // discriminant transmission: CarTransmission } interface Truck { vType: \"truck\"; // discriminant capacity: number; // in tons } 在上述代码中，我们分别定义了 Motorcycle、 Car 和 Truck 三个接口 在这些接口中都包含一个 vType 属性，该属性被称为可辨识的属性，而其它的属性只跟特性的接口相关。 联合类型 基于前面定义了三个接口，我们可以创建一个 Vehicle 联合类型： type Vehicle = Motorcycle | Car | Truck; 现在我们就可以开始使用 Vehicle 联合类型，对于 Vehicle 类型的变量，它可以表示不同类型的车辆。 类型守卫 下面我们来定义一个 evaluatePrice 方法，该方法用于根据车辆的类型、容量和评估因子来计算价格： const EVALUATION_FACTOR = Math.PI; function evaluatePrice(vehicle: Vehicle) { return vehicle.capacity * EVALUATION_FACTOR; } const myTruck: Truck = { vType: \"truck\", capacity: 9.5 }; evaluatePrice(myTruck); 对于以上代码，TypeScript 编译器将会提示以下错误信息： Property 'capacity' does not exist on type 'Vehicle'. Property 'capacity' does not exist on type 'Motorcycle'. 原因是在 Motorcycle 接口中，并不存在 capacity 属性，而对于 Car 接口来说，它也不存在 capacity 属性。那么，现在我们应该如何解决以上问题呢？这时，我们可以使用类型守卫。下面我们来重构一下前面定义的 evaluatePrice 方法，重构后的代码如下： function evaluatePrice(vehicle: Vehicle) { switch(vehicle.vType) { case \"car\": return vehicle.transmission * EVALUATION_FACTOR; case \"truck\": return vehicle.capacity * EVALUATION_FACTOR; case \"motorcycle\": return vehicle.make * EVALUATION_FACTOR; } } 在以上代码中，我们使用 switch 和 case 运算符来实现类型守卫，从而确保在 evaluatePrice 方法中，我们可以安全地访问 vehicle 对象中的所包含的属性，来正确的计算该车辆类型所对应的价格。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:6:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"类型别名 类型别名用来给一个类型起个新名字 type Message = string | string[]; let greet = (message: Message) =\u003e { // ... }; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:6:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"交叉类型 TypeScript 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 interface IPerson { id: string; age: number; } interface IWorker { companyId: string; } type IStaff = IPerson \u0026 IWorker; const staff: IStaff = { id: 'E1006', age: 33, companyId: 'EFT' }; console.dir(staff) ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:6:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"函数 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"与 JS 函数的区别 TypeScript JavaScript 含有类型 无类型 箭头函数 箭头函数（ES2015） 函数类型 无函数类型 必填和可选参数 所有参数都是可选的 默认参数 默认参数 剩余参数 剩余参数 函数重载 无函数重载 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"箭头函数 常见语法 myBooks.forEach(() =\u003e console.log('reading')); myBooks.forEach(title =\u003e console.log(title)); myBooks.forEach((title, idx, arr) =\u003e console.log(idx + '-' + title); ); myBooks.forEach((title, idx, arr) =\u003e { console.log(idx + '-' + title); }); 使用示例 // 未使用箭头函数 function Book() { let self = this; self.publishDate = 2016; setInterval(function () { console.log(self.publishDate); }, 1000); } // 使用箭头函数 function Book() { this.publishDate = 2016; setInterval(() =\u003e { console.log(this.publishDate); }, 1000); } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"参数类型和返回类型 function createUserId(name: string, id: number): string { return name + id; } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"函数类型 let IdGenerator: (chars: string, nums: number) =\u003e string; function createUserId(name: string, id: number): string { return name + id; } IdGenerator = createUserId; 搞不懂有啥用。。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"可选参数及默认参数 // 可选参数 function createUserId(name: string, id: number, age?: number): string { return name + id; } // 默认参数 function createUserId( name: string = \"Semlinker\", id: number, age?: number ): string { return name + id; } 在实际使用时，需要注意的是可选参数要放在普通参数的后面，不然会导致编译错误。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:5","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"剩余参数 function push(array, ...items) { items.forEach(function (item) { array.push(item); }); } let a = []; push(a, 1, 2, 3); ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:6","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"函数重载 function add(a: number, b: number): number; function add(a: string, b: string): string; function add(a: string, b: number): string; function add(a: number, b: string): string; function add(a: Combinable, b: Combinable) { if (typeof a === \"string\" || typeof b === \"string\") { return a.toString() + b.toString(); } return a + b; } 在定义重载的时候，一定要把最精确的定义放在最前面 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:7:7","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"数组 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:8:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"数组解构 let x: number; let y: number; let z: number; let five_array = [0,1,2,3,4]; [x,y,z] = five_array; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:8:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"数组展开运算符 let two_array = [0, 1]; let five_array = [...two_array, 2, 3, 4]; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:8:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"数组遍历 let colors: string[] = [\"red\", \"green\", \"blue\"]; for (let i of colors) { console.log(i); } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:8:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"对象 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:9:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"对象解构 let person = { name: \"Semlinker\", gender: \"Male\", }; let { name, gender } = person; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:9:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"对象运算符 let person = { name: \"Semlinker\", gender: \"Male\", address: \"Xiamen\", }; // 组装对象 let personWithAge = { ...person, age: 33 }; // 获取除了某些项外的其它项 let { name, ...rest } = person; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:9:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"类 在 TypeScript 中，我们可以通过 Class 关键字来定义一个类： class Greeter { // 静态属性 static cname: string = \"Greeter\"; // 成员属性 greeting: string; // 构造函数 - 执行初始化操作 constructor(message: string) { this.greeting = message; } // 静态方法 static getClassName() { return \"Class name is Greeter\"; } // 成员方法 greet() { return \"Hello, \" + this.greeting; } } let greeter = new Greeter(\"world\"); 类的静态成员存在于类本身上面而不是类的实例上。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:10:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"访问器 在 TypeScript 中，我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。 class Hello{ private _name: string; private _age: number; get name(): string { return this._name; } set name(value: string) { this._name = value; } get age(): number{ return this._age; } set age(age: number) { if(age\u003e0 \u0026\u0026 age\u003c100){ console.log(\"年龄在0-100之间\"); // 年龄在0-100之间 return; } this._age = age; } } let hello = new Hello(); hello.name = \"muyy\"; hello.age = 23 console.log(hello.name); // muyy 另外一个例子： let passcode = \"Hello TypeScript\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026\u0026 passcode == \"Hello TypeScript\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Semlinker\"; if (employee.fullName) { console.log(employee.fullName); } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:10:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"继承 通过 extends 关键字来实现继承： class Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name}moved ${distanceInMeters}m.`); } } class Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); } } let sam = new Snake(\"Sammy the Python\"); sam.move(); ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:10:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"ECMAScript 私有字段 在 TypeScript 3.8 版本就开始支持 ECMAScript 私有字段，使用方式如下： class Person { #name: string; constructor(name: string) { this.#name = name; } greet() { console.log(`Hello, my name is ${this.#name}!`); } } let semlinker = new Person(\"Semlinker\"); semlinker.#name; // ~~~~~ // Property '#name' is not accessible outside class 'Person' // because it has a private identifier. 与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则： 私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:10:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"泛型 泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型 泛型与模板类似 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:11:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"泛型接口 interface GenericIdentityFn\u003cT\u003e { (arg: T): T; } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:11:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"泛型类 class GenericNumber\u003cT\u003e { zeroValue: T; add: (x: T, y: T) =\u003e T; } let myGenericNumber = new GenericNumber\u003cnumber\u003e(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function (x, y) { return x + y; }; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:11:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"范型变量 一些常见泛型变量代表的意思： T（Type）：表示一个 TypeScript 类型 K（Key）：表示对象中的键类型 V（Value）：表示对象中的值类型 E（Element）：表示元素类型 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:11:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"泛型工具类型 typeof 在 TypeScript 中，typeof 操作符可以用来获取一个变量声明或对象的类型。 interface Person { name: string; age: number; } const sem: Person = { name: 'semlinker', age: 30 }; type Sem = typeof sem; // -\u003e Person function toArray(x: number): Array\u003cnumber\u003e { return [x]; } type Func = typeof toArray; // -\u003e (x: number) =\u003e number[] keyof keyof 操作符可以用来一个对象中的所有 key 值： interface Person { name: string; age: number; } type K1 = keyof Person; // \"name\" | \"age\" type K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\" type K3 = keyof { [x: string]: Person }; // string | number in in 用来遍历枚举类型： type Keys = \"a\" | \"b\" | \"c\" type Obj = { [p in Keys]: any } // -\u003e { a: any, b: any, c: any } infer 在条件类型语句中，可以用 infer 声明一个类型变量并且对它进行使用。 type ReturnType\u003cT\u003e = T extends ( ...args: any[] ) =\u003e infer R ? R : any; 以上代码中 infer R 就是声明一个变量来承载传入函数签名的返回值类型，简单说就是用它取到函数返回值的类型方便之后使用。（不明白） extends 有时候我们定义的泛型不想过于灵活或者说想继承某些类等，可以通过 extends 关键字添加泛型约束。 interface ILengthwise { length: number; } function loggingIdentity\u003cT extends ILengthwise\u003e(arg: T): T { console.log(arg.length); return arg; } 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型： loggingIdentity(3); // Error, number doesn't have a .length property 这时我们需要传入符合约束类型的值，必须包含必须的属性： loggingIdentity({length: 10, value: 3}); Partial Partial\u003cT\u003e 的作用就是将某个类型里的属性全部变为可选项 ? 定义： /** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial\u003cT\u003e = { [P in keyof T]?: T[P]; }; 在以上代码中，首先通过 keyof T 拿到 T 的所有属性名，然后使用 in 进行遍历，将值赋给 P，最后通过 T[P] 取得相应的属性值。中间的 ? 号，用于将所有属性变为可选。 示例： interface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial\u003cTodo\u003e) { return { ...todo, ...fieldsToUpdate }; } const todo1 = { title: \"organize desk\", description: \"clear clutter\", }; const todo2 = updateTodo(todo1, { description: \"throw out trash\", }); 在上面的 updateTodo 方法中，我们利用 Partial\u003cT\u003e 工具类型，定义 fieldsToUpdate 的类型为 Partial\u003cTodo\u003e，即： { title?: string | undefined; description?: string | undefined; } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:11:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"装饰器 它是一个表达式 该表达式被执行后，返回一个函数 函数的入参分别为 target、name 和 descriptor 执行该函数后，可能返回 descriptor 对象，用于配置 target 对象 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:12:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"类装饰器 声明： declare type ClassDecorator = \u003cTFunction extends Function\u003e( target: TFunction ) =\u003e TFunction | void; 类装饰器用来装饰类，它接收一个参数： target: TFunction：被装饰的类 例： function Greeter(target: Function): void { target.prototype.greet = function (): void { console.log(\"Hello Semlinker!\"); }; } @Greeter class Greeting { constructor() { // 内部实现 } } let myGreeting = new Greeting(); myGreeting.greet(); // console output: 'Hello Semlinker!'; 上面的例子中，我们定义了 Greeter 类装饰器，同时我们使用了 @Greeter 语法糖，来使用装饰器。 还可以在装饰器中加入参数 function Greeter(greeting: string) { return function (target: Function) { target.prototype.greet = function (): void { console.log(greeting); }; }; } @Greeter(\"Hello TS!\") class Greeting { constructor() { // 内部实现 } } let myGreeting = new Greeting(); myGreeting.greet(); // console output: 'Hello TS!'; ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:12:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"属性装饰器 声明： declare type PropertyDecorator = (target:Object, propertyKey: string | symbol ) =\u003e void; 属性装饰器用来装饰类的属性。它接收两个参数： target: Object：被装饰的类 propertyKey: string | symbol：被装饰类的属性名 例： function logProperty(target: any, key: string) { delete target[key]; const backingField = \"_\" + key; Object.defineProperty(target, backingField, { writable: true, enumerable: true, configurable: true }); // property getter const getter = function (this: any) { const currVal = this[backingField]; console.log(`Get: ${key}=\u003e ${currVal}`); return currVal; }; // property setter const setter = function (this: any, newVal: any) { console.log(`Set: ${key}=\u003e ${newVal}`); this[backingField] = newVal; }; // Create new property with getter and setter Object.defineProperty(target, key, { get: getter, set: setter, enumerable: true, configurable: true }); } class Person { @logProperty public name: string; constructor(name : string) { this.name = name; } } const p1 = new Person(\"semlinker\"); p1.name = \"kakuqo\"; 以上代码我们定义了一个 logProperty 函数，来跟踪用户对属性的操作，当代码成功运行后，在控制台会输出以下结果：（晕晕的，暂时难以接受。。） Set: name =\u003e semlinker Set: name =\u003e kakuqo ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:12:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"方法装饰器 声明： declare type MethodDecorator = \u003cT\u003e(target:Object, propertyKey: string | symbol, descriptor: TypePropertyDescript\u003cT\u003e) =\u003e TypedPropertyDescriptor\u003cT\u003e | void; 方法装饰器用来装饰类的方法。它接收三个参数： target: Object：被装饰的类 propertyKey: string | symbol：方法名 descriptor: TypePropertyDescript：属性描述符 例： function LogOutput(tarage: Function, key: string, descriptor: any) { let originalMethod = descriptor.value; let newMethod = function(...args: any[]): any { let result: any = originalMethod.apply(this, args); if(!this.loggedOutput) { this.loggedOutput = new Array\u003cany\u003e(); } this.loggedOutput.push({ method: key, parameters: args, output: result, timestamp: new Date() }); return result; }; descriptor.value = newMethod; } class Calculator { @LogOutput double (num: number): number { return num * 2; } } let calc = new Calculator(); calc.double(11); // console ouput: [{method: \"double\", output: 22, ...}] console.log(calc.loggedOutput); ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:12:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"参数装饰器 声明： declare type ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number ) =\u003e void 参数装饰器用来装饰函数参数，它接收三个参数： target: Object：被装饰的类 propertyKey: string | symbol：方法名 parameterIndex: number：方法中参数的索引值 function Log(target: Function, key: string, parameterIndex: number) { let functionLogged = key || target.prototype.constructor.name; console.log(`The parameter in position ${parameterIndex}at ${functionLogged}has been decorated`); } class Greeter { greeting: string; constructor(@Log phrase: string) { this.greeting = phrase; } } // console output: The parameter in position 0 // at Greeter has been decorated ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:12:4","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"编译上下文 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:13:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"tsconfig.json 的作用 用于标识 TypeScript 项目的根路径； 用于配置 TypeScript 编译器； 用于指定编译的文件。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:13:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"tsconfig.json 重要字段 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:13:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"compilerOptions 选项 compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。 compilerOptions 每个选项的详细说明如下： { \"compilerOptions\": { /* 基本选项 */ \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 } } ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:13:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"与 Vue3 的结合 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:14:0","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"ref 的类型声明 const year = ref(2020) const month = ref\u003cstring | number\u003e('9') 如果不给定 ref 定义的类型的话， vue3 也能根据初始值来进行类型推导，然后需要指定复杂类型的时候简单传递一个泛型即可。 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:14:1","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"reactive 的类型声明 const student = reactive\u003cStudent\u003e({ name: '阿勇', age: 16 }) // or const student: Student = reactive({ name: '阿勇', age: 16 }) // or const student = reactive({ name: '阿勇', age: 16, class: 'cs' }) as Student 比较倾向于第一种 ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:14:2","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["前端"],"content":"自定义 hooks 作者：JS开发宝典 链接：https://zhuanlan.zhihu.com/p/360947847 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 vue3 借鉴 react hooks 开发出了 Composition API ，那么也就意味着 Composition API 也能进行自定义封装 hooks ，接下来我们就用 TypeScript 风格封装一个计数器逻辑的 hooks （ useCount ）: 首先来看看这个 hooks 怎么使用： import { ref } from '/@modules/vue' import useCount from './useCount' export default { name: 'CountDemo', props: { msg: String }, setup() { const { current: count, inc, dec, set, reset } = useCount(2, { min: 1, max: 15 }) const msg = ref('Demo useCount') return { count, inc, dec, set, reset, msg } } } 出来的效果就是： 贴上 useCount 的源码： import { ref, Ref, watch } from 'vue' interface Range { min?: number, max?: number } interface Result { current: Ref\u003cnumber\u003e, inc: (delta?: number) =\u003e void, dec: (delta?: number) =\u003e void, set: (value: number) =\u003e void, reset: () =\u003e void } export default function useCount(initialVal: number, range?: Range): Result { const current = ref(initialVal) const inc = (delta?: number): void =\u003e { if (typeof delta === 'number') { current.value += delta } else { current.value += 1 } } const dec = (delta?: number): void =\u003e { if (typeof delta === 'number') { current.value -= delta } else { current.value -= 1 } } const set = (value: number): void =\u003e { current.value = value } const reset = () =\u003e { current.value = initialVal } watch(current, (newVal: number, oldVal: number) =\u003e { if (newVal === oldVal) return if (range \u0026\u0026 range.min \u0026\u0026 newVal \u003c range.min) { current.value = range.min } else if (range \u0026\u0026 range.max \u0026\u0026 newVal \u003e range.max) { current.value = range.max } }) return { current, inc, dec, set, reset } } 分析源码 这里首先是对 hooks 函数的入参类型和返回类型进行了定义，入参的 Range 和返回的 Result 分别用一个接口来指定，这样做了以后，最大的好处就是在使用 useCount 函数的时候，ide就会自动提示哪些参数是必填项，各个参数的类型是什么，防止业务逻辑出错。 接下来，在增加 inc 和减少 dec 的两个函数中增加了 typeo 类型守卫检查，因为传入的 delta 类型值在某些特定场景下不是很确定，比如在 template 中调用方法的话，类型检查可能会失效，传入的类型就是一个原生的 Event 。 关于 ref 类型值，这里并没有特别声明类型，因为 vue3 会进行自动类型推导，但如果是复杂类型的话可以采用类型断言的方式： ref(initObj) as Ref\u003cObjType\u003e ","date":"2021-12-15","objectID":"/Notes/posts/frontend/javascript/typescript/:14:3","tags":["TypeScript","JavaScript","前端","快速入门"],"title":"TypeScript 基本语法","uri":"/Notes/posts/frontend/javascript/typescript/"},{"categories":["Machine Learning"],"content":"基本概念 有了数据，通过某种学习算法，得到模型，进行预测。 数据 数据集（Data Set）：一组记录的集合（一堆西瓜） 样本（Sample）：一个对象或事件的描述（一个西瓜） 特征向量（Feature Vector）：各种属性（Attribute）张成的一个样本空间（Sample Space），各种属性的总合就是维度（Dimensionality） 算法 学习（Learning）或训练（Training） 模型（学习器 Learner） 有监督学习 分类（Classification）：预测离散值，二分类，多分类 回归（Regression）：预测连续值 无监督学习 聚类（Clustering）：机器自动形成簇（Cluster），对应一些潜在的分类 预测 测试（Testing） 测试样本（Testing Sample） 泛化能力（Generalization）：模型适用于新样本的能力 假设空间：将学习过程看作一个在所有假设（Hypothesis）组成的空间中进行搜索的过程，搜索目标是找到与训练集匹配的假设 归纳偏好：机器学习算法在学习过程中对某种类型假设的偏好 原理：奥卡姆剃刀 模型评估与选择 ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:0:0","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"术语 过拟合（Overfitting）：将训练样本自身特点当作了潜在样本的一般性质，导致泛化能力下降 m：样本数量；Y：正确结果；Y’：预测结果；a：错误数 性能度量 错误率（Error Rate）：$E=\\cfrac{a}{m}$ 精度（Accuracy）：$1-E$ 误差（Error）：$|Y-Y’|$ 数据集 训练集（Training Set）：用于训练模型的集数据集 测试集（Testing Set）：用于测试模型的数据集 验证集（Validation Set）：用于评估测试的数据集，用于调参（Parameter tuning） 步骤：用训练集训练-\u003e用验证集看结果-\u003e调参-\u003e循环。最后在测试集上看结果 ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:1:0","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"一种训练集，一种算法 ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:2:0","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"测试集的选择方法 留出法 将数据集D划分为互斥集合，训练集S与测试集T，用T来评估和测试误差。 要求 数据划分时保持数据分布的一致性，如分层采样（Stratified Sampling） 通常三七分，二八分（大部分数据用来训练），或进行多次随机划分，训练出多个模型，最后取平均值。 k折交叉验证法 将数据集D分成k份，每次以k-1个子集作为训练集S来训练，用余下的那一个子集用来测试，重复k次取平均值。 缺点：太慢太麻烦 自助法 在数据集D中随机挑选样本放入训练集S中，再放回，重复m次（自助采样）。 此时，D中部分样本会在S中多次出现，部分样本不会出现，不被采到的概率为$(1-\\cfrac{1}{m})^m$，取极限约为36.8%，将不出现的样本作为测试集T，这样的测试结果称为包外估计（out-of-bagestimate）。 缺点：改变了初始数据集的分布，引入估计偏差。 ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:2:1","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"性能度量（Performance Measure） 基本公式 给定样例集$D={(x_1,y_1),(x_2,y_2),\\ldots,(x_m,y_m)}$，其中$y_i$是示例$x_i$的真实标记，要评估学习器$f$的性能，就要把学习器的预测结果$f(x)$与真实标记$y$进行比较。 均方误差 $$ E(f;D)=\\cfrac{1}{m}\\sum\\limits_{i=1}^{m}(f(x_i)-y_i)^2 $$ 对于数据分布$\\cal{D}$和概率密度函数$p(\\cdot)$，均方误差可描述为 $$ E(f;D)=\\int_{x\\sim D}(f(x)-y)^2p(x)dx $$ 错误率 $$ E(f;D)=\\cfrac{1}{m}\\sum\\limits_{i=1}^{m}\\Bbb{I}(f(x_i)\\neq y_i) $$ 错误精度 $$ acc(f;D)=1-E(f;D) $$ 查准率与查全率 混淆矩阵 查准率$P$（Precision）：预测为正例的结果中有多少是对的，阈值（Threshold）较大（谨慎），查准率往往会高 $$ P=\\cfrac{TP}{TP+FP} $$ 查全率$R$（Recall）：真正的正例有多少被预测出来了，阈值较小（宽松），查全率往往会高 $$ R=\\cfrac{TP}{TP+FN} $$ 最优阈值的确定 选取平衡点（Break-Even Point），简称BEP $F1$ 度量（P与R的调和平均数） $$ \\cfrac{1}{F1}=\\cfrac{1}{2}(\\cfrac{1}{R}+\\cfrac{1}{P}) \\ F1=\\cfrac{2\\times P\\times R}{P+R}=\\cfrac{2\\times TP}{样例总数+TP-TN} $$ ​ 与算术平均与几何平均相比，调和平均更重视最小值 $F_\\beta$ 度量（加权调和平均） $$ \\cfrac{1}{F_\\beta}=\\cfrac{1}{1+\\beta^2}(\\cfrac{1}{P}+\\cfrac{\\beta^2}{R}) =\\cfrac{(1+\\beta^2)\\times P\\times R}{(\\beta^2\\times P)+R} $$ ​ $\\beta$度量了查全率相对于查准率的重要性，$\\beta\u003e1$时查全率影响更大；$\\beta\u003c1$时查准率影响更大 n 个二分类实现的多分类问题 先分别计算，再求平均值 有$(P_1,R_1),(P_2,R_2),\\ldots,(P_n,R_n)$ macro-P 宏查准率：$macro-P=\\cfrac{1}{n}\\sum\\limits_{i=1}^n P_i$ macro-R 宏查全率：$macro-R=\\cfrac{1}{n}\\sum\\limits_{i=1}^n R_i$ macro-F1 宏F1：$macro-F1=\\cfrac{2\\times macroP\\times macroR}{macroP+macroR}$ 先平均再计算 macro-P 宏查准率：$micro-P=\\cfrac{\\overline{TP}}{\\overline{TP}+\\overline{FP}}$ macro-R 宏查全率：$micro-R=\\cfrac{\\overline{TP}}{\\overline{TP}+\\overline{FN}}$ macro-F1 宏 F1：$micro-F1=\\cfrac{2\\times microP\\times microR}{microP+microR}$ ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:2:2","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"一种训练集，多种算法 ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:3:0","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"P-R曲线 要比较 ABC 三个模型的好坏 首先确定 A 和 B 优于 C，AB 间由于交叉不好确定 对于 AB 法一：比较面积，但不易估算 法二：$F1$ 法三：$F\\beta$ ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:3:1","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["Machine Learning"],"content":"ROC 与 AUC ","date":"2021-10-23","objectID":"/Notes/posts/machinelearning/machinelearning/:4:0","tags":["ml"],"title":"机器学习","uri":"/Notes/posts/machinelearning/machinelearning/"},{"categories":["其他"],"content":"诗 长安紫陌芙蓉阙 马嵬坡下白练雪 何必长存破风意 红尘万丈早归去 ​ （HWSN 2017.6.19） 忆江南 梅时雨，舟桨渡平川 烟卷云浓西去水，风斜雾横北归山 犹把露衣沾 ​ （2017.7.9） 不屑牛酒寻上色 嘲凡皮相美天功 ​ （2017.10.25） 巧巧红妆花间客，朵朵轻云芳柔甚 片月风流夜搅衣，风雨归去空留恨 愿莫效此薄情郎，伤心万尺倾国色 少小臣嗣玉金环，暇时万把腰千缠 缠得非金却何是？罗红绮蓝葱头簪 碧眼丹容含春意，多情自小现端倪 不喜舞剑喜柳面，不爱经籍爱芳仪 锦缎丝袍穿巷井，璎珞摇鸣逐娇影 借齿伶俐讨巧笑，凭笔生花画蛾螓 拥衾兰语如梦令，阁床狂酒醉花阴 好晴悠游江城子，云黑卧看雨霖铃 暗潮波生惊沉帆，家世蒙蔑翻宦海 诛雷疾发荒四壁，华尘梦烟皆飞散 从此落魄贵公子，白马孤魂踏九川 五陵金枝桃李年，眉若远黛肤胜雪 紫陌逢识少年后，自此未语不成眠 一纸鱼信悄相约，风萍飘乎长安月 芙蓉帐里情悠悠，鸳鸯枕头语窃窃 红烛冷褪马前归，喃口两语赠长别 “他年两情离魂所，明朝花红柳河纤” ","date":"2021-10-23","objectID":"/Notes/posts/poetry/classical/:0:0","tags":["古体诗"],"title":"诗","uri":"/Notes/posts/poetry/classical/"},{"categories":["其他"],"content":"诗 听惯莫名来的雨 只道又不知是谁的眼泪 轻轻落在夜的脚边 ​ （Ls 2019.4.14） ”谁不爱懦弱的快活？” 小草们临风呼叫 “我织上泥土的颜色，泥土编织成我 风来，我就起到天际” 风止了你才肯罢休 可总有人要骑上野马 去踏碎满地的骄傲 （Sty 2019.3.12） 何必掘出春天的墓骨 迫她目睹她梦的毁灭 丑恶断不能无人欣赏 那就让美来歌颂卑劣 ​ （Sty 2019.1.21） ","date":"2021-10-23","objectID":"/Notes/posts/poetry/modern/:0:0","tags":["现代诗"],"title":"诗","uri":"/Notes/posts/poetry/modern/"},{"categories":["C#"],"content":"BasicGrammar ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:0:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"认识 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:1:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"简介 C#：是一个现代的、通用的、面向对象的编程语言 .Net Framework：是一个创新的平台，能编写出下面类型的应用程序： Windows 应用程序 Web 应用程序 Web 服务 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:1:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"程序结构 一个 C# 程序主要包括以下部分： 命名空间声明（Namespace declaration） 一个 class Class 方法 Class 属性 一个 Main 方法 语句（Statements）\u0026 表达式（Expressions） 注释 using System; namespace HelloWorldApplication { /* 类名为 HelloWorld */ class HelloWorld { /* main 函数 */ static void Main(string[] args) { /* 我的第一个 C# 程序 */ Console.WriteLine(\"Hello World!\"); Console.ReadKey(); } } } 程序的第一行 using System; using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。 下一行是 namespace（命名空间）声明 一个 namespace 里包含了一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。 下一行是 class 声明 类 HelloWorld 包含了程序使用的数据和方法声明。 类一般包含多个方法。方法定义了类的行为。 在这里，HelloWorld 类只有一个 Main 方法。 下一行定义了 Main 方法，是所有 C# 程序的 入口点。 Main 方法说明当执行时 类将做什么动作。 下一行 /*...*/ 为注释语句，将会被编译器忽略。 Main 方法通过语句Console.WriteLine(\"Hello World\"); 指定了它的行为。 WriteLine 是一个定义在 System 命名空间中的 Console 类的一个方法。该语句会在屏幕上显示消息 “Hello World”。 最后一行 Console.ReadKey(); 是针对 VS.NET 用户的。这使得程序会等待一个按键的动作，防止程序从 Visual Studio .NET 启动时屏幕会快速运行并关闭。 注意 C# 是大小写敏感的。 所有的语句和表达式必须以分号（;）结尾。 程序的执行从 Main 方法开始。 与 Java 不同的是，文件名可以不同于类的名称 有例： using System; namespace RectangleApplication { class Rectangle { // 成员变量 double length; double width; public void Acceptdetails() { length = 4.5; width = 3.5; } public double GetArea() { return length * width; } public void Display() { Console.WriteLine(\"Length: {0}\", length); Console.WriteLine(\"Width: {0}\", width); Console.WriteLine(\"Area: {0}\", GetArea()); } } class ExecuteRectangle { static void Main(string[] args) { Rectangle r = new Rectangle(); r.Acceptdetails(); r.Display(); Console.ReadLine(); } } } 运行得 Length: 4.5 Width: 3.5 Area: 15.75 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:2:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"数据类型 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:3:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"值类型 (Value types) 值类型变量可以直接分配给一个值。它们是从类 System.ValueType 中派生的 类型 描述 范围 默认值 bool 布尔值 True 或 False False byte 8 位无符号整数 0 到 255 0 char 16 位 Unicode 字符 U +0000 到 U +ffff ‘\\0’ decimal 128 位精确的十进制值，28-29 有效位数 (-7.9 x 1028 到 7.9 x 1028) / 100 到 28 0.0M double 64 位双精度浮点型 (+/-)5.0 x 10-324 到 (+/-)1.7 x 10308 0.0D float 32 位单精度浮点型 -3.4 x 1038 到 + 3.4 x 1038 0.0F int 32 位有符号整数类型 -2,147,483,648 到 2,147,483,647 0 long 64 位有符号整数类型 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 0L sbyte 8 位有符号整数类型 -128 到 127 0 short 16 位有符号整数类型 -32,768 到 32,767 0 uint 32 位无符号整数类型 0 到 4,294,967,295 0 ulong 64 位无符号整数类型 0 到 18,446,744,073,709,551,615 0 ushort 16 位无符号整数类型 0 到 65,535 0 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:3:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"引用类型 (Reference types) 引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。 换句话说，它们指的是一个内存位置。使用多个变量时，引用类型可以指向一个内存位置。如果内存位置的数据是由一个变量改变的，其他变量会自动反映这种值的变化。内置的 引用类型有：object、dynamic 和 string 对象 Object 类型 对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。 当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱 object obj; // 这是装箱 obj = 100; // 这是拆箱 动态 Dynamic 类型 您可以存储任何类型的值在动态数据类型变量中。 声明动态类型的语法： dynamic \u003cvariable_name\u003e = value; 例如： dynamic d = 20; 动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的 字符串 String 类型 字符串类型允许您给变量分配任何字符串值。 字符串类型是 System.String 类的别名。 它是从对象类型派生的。 例如： String str = \"runoob.com\"; 字符串前面可以加 @（称作\"逐字字符串\"）将转义字符（\\）当作普通字符对待，比如： string str = @\"C:\\Windows\"; 等价于： string str = \"C:\\\\Windows\"; @ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。 string str = @\"\u003cscript type=\"\"text/javascript\"\"\u003e \u003c!-- --\u003e \u003c/script\u003e\"; 用户自定义引用类型有：class、interface 或 delegate。我们将在以后的章节中讨论这些类型。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:3:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"指针类型 (Pointer types) 指针类型变量存储另一种类型的内存地址。C# 中的指针与 C 或 C++ 中的指针有相同的功能 声明指针类型的语法： type* identifier; 例如： char* cptr; int* iptr; ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:3:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"类型转换 类型转换从根本上说是类型铸造，或者说是把数据从一种类型转换为另一种类型 型铸造有两种形式： 隐式类型转换 - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。 显式类型转换 - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失 namespace TypeConversionApplication { class ExplicitConversion { static void Main(string[] args) { double d = 5673.74; int i; // 强制转换 double 为 int i = (int)d; Console.WriteLine(i); Console.ReadKey(); } } } // 结果为 5673 类型转换方法 序号 方法 \u0026 描述 1 ToBoolean 如果可能的话，把类型转换为布尔型。 2 ToByte 把类型转换为字节类型。 3 ToChar 如果可能的话，把类型转换为单个 Unicode 字符类型。 4 ToDateTime 把类型（整数或字符串类型）转换为 日期-时间 结构。 5 ToDecimal 把浮点型或整数类型转换为十进制类型。 6 ToDouble 把类型转换为双精度浮点型。 7 ToInt16 把类型转换为 16 位整数类型。 8 ToInt32 把类型转换为 32 位整数类型。 9 ToInt64 把类型转换为 64 位整数类型。 10 ToSbyte 把类型转换为有符号字节类型。 11 ToSingle 把类型转换为小浮点数类型。 12 ToString 把类型转换为字符串类型。 13 ToType 把类型转换为指定类型。 14 ToUInt16 把类型转换为 16 位无符号整数类型。 15 ToUInt32 把类型转换为 32 位无符号整数类型。 16 ToUInt64 把类型转换为 64 位无符号整数类型。 namespace TypeConversionApplication { class StringConversion { static void Main(string[] args) { int i = 75; float f = 53.005f; double d = 2345.7652; bool b = true; Console.WriteLine(i.ToString()); Console.WriteLine(f.ToString()); Console.WriteLine(d.ToString()); Console.WriteLine(b.ToString()); Console.ReadKey(); } } } 输出 75 53.005 2345.7652 True ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:3:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"变量 类型 举例 整数类型 sbyte、byte、short、ushort、int、uint、long、ulong 和 char 浮点型 float 和 double 十进制类型 decimal 布尔类型 true 或 false 值，指定的值 空类型 可为空值的数据类型 C# 允许定义其他值类型的变量，比如 enum，也允许定义引用类型变量，比如 class ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:4:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"基本操作 定义 \u003cdata_type\u003e \u003cvariable_list\u003e; // 定义 int i, j, k; char c, ch; float f, salary; double d; 初始化 \u003cdata_type\u003e \u003cvariable_name\u003e = value; // 初始化 int d = 3, f = 5; byte z = 22; double pi = 3.14159; char x = 'x'; 接受来自用户的值 int num; num = Convert.ToInt32(Console.ReadLine()); ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:4:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"常量 常量是固定值，程序执行期间不会改变。常量可以是任何基本数据类型。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:5:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"定义 常量是使用 const 关键字来定义的 。定义一个常量的语法如下： const \u003cdata_type\u003e \u003cconstant_name\u003e = value; using System; public class ConstTest { class SampleClass { public int x; public int y; public const int c1 = 5; public const int c2 = c1 + 5; public SampleClass(int p1, int p2) { x = p1; y = p2; } } static void Main() { SampleClass mC = new SampleClass(11, 22); Console.WriteLine(\"x = {0}, y = {1}\", mC.x, mC.y); Console.WriteLine(\"c1 = {0}, c2 = {1}\", SampleClass.c1, SampleClass.c2); } } 输出 x = 11, y = 22 c1 = 5, c2 = 10 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:5:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"类型 整数常量 85 // 十进制 0213 // 八进制 0x4b // 十六进制 30 // int 30u // 无符号 int 30l // long 30ul // 无符号 long 浮点常量 3.14159 // 合法 314159E-5L // 合法 510E // 非法：不完全指数 210f // 非法：没有小数或指数 .e55 // 非法：缺少整数或小数 使用浮点形式表示时，必须包含小数点、指数或同时包含两者。 使用指数形式表示时，必须包含整数部分、小数部分或同时包含两者。 有符号的指数是用 e 或 E 表示的。 字符常量 一个字符常量可以是一个普通字符（例如 'x'）、一个转义序列（例如 '\\t'）或者一个通用字符（例如 '\\u02C0'） 转义序列 含义 \\ \\ 字符 ' ’ 字符 \" \" 字符 ? ? 字符 \\a Alert 或 bell \\b 退格键（Backspace） \\f 换页符（Form feed） \\n 换行符（Newline） \\r 回车 \\t 水平制表符 tab \\v 垂直制表符 tab \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 字符串常量 字符串常量是括在双引号 \"\" 里，或者是括在 @\"\" 里 string a = \"hello, world\"; // hello, world string b = @\"hello, world\"; // hello, world string c = \"hello \\t world\"; // hello world string d = @\"hello \\t world\"; // hello \\t world string e = \"Joe said \\\"Hello\\\" to me\"; // Joe said \"Hello\" to me string f = @\"Joe said \"\"Hello\"\" to me\"; // Joe said \"Hello\" to me string g = \"\\\\\\\\server\\\\share\\\\file.txt\"; // \\\\server\\share\\file.txt string h = @\"\\\\server\\share\\file.txt\"; // \\\\server\\share\\file.txt string i = \"one\\r\\ntwo\\r\\nthree\"; string j = @\"one two three\"; ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:5:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"算术运算符 下表显示了 C# 支持的所有算术运算符。假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 using System; namespace OperatorsAppl { class Program { static void Main(string[] args) { int a = 21; int b = 10; int c; c = a + b; Console.WriteLine(\"Line 1 - c 的值是 {0}\", c); c = a - b; Console.WriteLine(\"Line 2 - c 的值是 {0}\", c); c = a * b; Console.WriteLine(\"Line 3 - c 的值是 {0}\", c); c = a / b; Console.WriteLine(\"Line 4 - c 的值是 {0}\", c); c = a % b; Console.WriteLine(\"Line 5 - c 的值是 {0}\", c); // ++a 先进行自增运算再赋值 c = ++a; Console.WriteLine(\"Line 6 - c 的值是 {0}\", c); // 此时 a 的值为 22 // --a 先进行自减运算再赋值 c = --a; Console.WriteLine(\"Line 7 - c 的值是 {0}\", c); Console.ReadLine(); } } } 输出 Line 1 - c 的值是 31 Line 2 - c 的值是 11 Line 3 - c 的值是 210 Line 4 - c 的值是 2 Line 5 - c 的值是 1 Line 6 - c 的值是 22 Line 7 - c 的值是 21 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"逻辑运算符 假设变量 A 为布尔值 true，变量 B 为布尔值 false，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都非零，则条件为真。 (A \u0026\u0026 B) 为假。 || 称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。 (A || B) 为真。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"位运算符 位运算符作用于位，并逐位执行操作。\u0026、 | 和 ^ 的真值表如下所示： p q p \u0026 q（与） p | q（或） p ^ q（异或） 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 符号 说明 ~ 按位取反运算符是一元运算符，具有\"翻转\"位效果，即0变成1，1变成0，包括符号位。 « 二进制左移运算符。左操作数的值向左移动右操作数指定的位数。 » 二进制右移运算符。左操作数的值向右移动右操作数指定的位数。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 »= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:5","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"其他运算符 运算符 描述 实例 sizeof() 返回数据类型的大小。 sizeof(int)，将返回 4. typeof() 返回 class 的类型。 typeof(StreamReader); \u0026 返回变量的地址。 \u0026a; 将得到变量的实际地址。 * 变量的指针。 *a; 将指向一个变量。 ? : 条件表达式 如果条件为真 ? 则为 X : 否则为 Y is 判断对象是否为某一类型。 If( Ford is Car) // 检查 Ford 是否是 Car 类的一个对象。 as 强制转换，即使转换失败也不会抛出异常。 Object obj = new StringReader(“Hello”); StringReader r = obj as StringReader; ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:6","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"运算优先级 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:6:7","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"判断语句 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:7:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"if 语句 if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:7:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"if…else 语句 if(boolean_expression) { /* 如果布尔表达式为真将执行的语句 */ } else { /* 如果布尔表达式为假将执行的语句 */ } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:7:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"switch 语句 switch(expression){ case constant-expression : statement(s); break; case constant-expression : statement(s); break; /* 您可以有任意数量的 case 语句 */ default : /* 可选的 */ statement(s); break; } switch 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型（其中有一个单一的转换函数将其转换为整型或枚举类型） case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量 不是每一个 case 都需要包含 break。如果 case 语句为空，则可以不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 using System; namespace DecisionMaking { class Program { static void Main(string[] args) { /* 局部变量定义 */ char grade = 'B'; switch (grade) { case 'A': Console.WriteLine(\"很棒！\"); break; case 'B': case 'C': Console.WriteLine(\"做得好\"); break; case 'D': Console.WriteLine(\"您通过了\"); break; case 'F': Console.WriteLine(\"最好再试一下\"); break; default: Console.WriteLine(\"无效的成绩\"); break; } Console.WriteLine(\"您的成绩是 {0}\", grade); Console.ReadLine(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:7:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"循环语句 C# 拥有 break 和 continue 两个循环控制语句 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:8:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"while 循环 while(condition) { statement(s); } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:8:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"for 循环 for ( init; condition; increment ) { statement(s); } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:8:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"foreach 循环 使用 foreach 可以迭代数组或者一个集合对象。 以下实例有三个部分： 通过 foreach 循环输出整型数组中的元素。 通过 for 循环输出整型数组中的元素。 foreach 循环设置数组元素的计算器。 class ForEachTest { static void Main(string[] args) { int[] fibarray = new int[] { 0, 1, 1, 2, 3, 5, 8, 13 }; foreach (int element in fibarray) { System.Console.WriteLine(element); } System.Console.WriteLine(); // 类似 foreach 循环 for (int i = 0; i \u003c fibarray.Length; i++) { System.Console.WriteLine(fibarray[i]); } System.Console.WriteLine(); // 设置集合中元素的计算器 int count = 0; foreach (int element in fibarray) { count += 1; System.Console.WriteLine(\"Element #{0}: {1}\", count, element); } System.Console.WriteLine(\"Number of elements in the array: {0}\", count); } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:8:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"do…while 循环 do…while 循环在循环的尾部检查它的条件，所以它确保至少执行一次循环。 do { statement(s); } while( condition ); ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:8:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"封装 封装 被定义为\"把一个或多个项目封闭在一个物理的或者逻辑的包中\"。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问 C# 封装根据具体的需要，设置使用者的访问权限，并通过 访问修饰符 来实现 一个 访问修饰符 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示： public：所有对象都可以访问； private：对象本身在对象内部可以访问； protected：只有该类对象及其子类对象可以访问 internal：同一个程序集的对象可以访问； protected internal：访问限于当前程序集或派生自包含类的类型 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:9:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Public 访问修饰符 Public 访问修饰符允许一个类将其成员变量和成员函数暴露给其他的函数和对象。任何公有成员可以被外部的类访问 using System; namespace RectangleApplication { class Rectangle { //成员变量 public double length; public double width; public double GetArea() { return length * width; } public void Display() { Console.WriteLine(\"长度： {0}\", length); Console.WriteLine(\"宽度： {0}\", width); Console.WriteLine(\"面积： {0}\", GetArea()); } }// Rectangle 结束 class ExecuteRectangle { static void Main(string[] args) { Rectangle r = new Rectangle(); r.length = 4.5; r.width = 3.5; r.Display(); Console.ReadLine(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:9:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Protected 访问修饰符 Protected 访问修饰符允许子类访问它的基类的成员变量和成员函数。这样有助于实现继承。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:9:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Private 访问修饰符 如果没有指定访问修饰符，则使用类成员的默认访问修饰符，即为 private。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:9:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Internal 访问修饰符 Internal 访问说明符限于当前命名空间 换句话说，带有 internal 访问修饰符的任何成员可以被定义在该成员所定义的应用程序内的任何类或方法访问。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:9:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Protected Internal 访问修饰符 Protected Internal 访问修饰符允许在本类,派生类或者包含该类的程序集中访问。这也被用于实现继承。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:9:5","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"方法 一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:10:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"定义方法 \u003cAccess Specifier\u003e \u003cReturn Type\u003e \u003cMethod Name\u003e(Parameter List) { // Method Body } Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。 Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 void。 Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。 Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。 Method body：方法主体，包含了完成任务所需的指令集。 有例 class NumberManipulator { public int FindMax(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } ... } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:10:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"引用方法 using System; namespace CalculatorApplication { class NumberManipulator { public int FindMax(int num1, int num2) { /* 局部变量声明 */ int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } static void Main(string[] args) { /* 局部变量定义 */ int a = 100; int b = 200; int ret; NumberManipulator n = new NumberManipulator(); //调用 FindMax 方法 ret = n.FindMax(a, b); Console.WriteLine(\"最大值是： {0}\", ret ); Console.ReadLine(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:10:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"参数传递 方式 描述 值参数 这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值，这保证了实参数据的安全。 引用参数 这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。 输出参数 这种方式可以返回多个值。 // 值参数，这个函数屁用没有 public void swap(int x, int y) { int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */ } // 调用时 int a = 100; int b = 200; n.swap(a, b); // 引用参数，使用 ref 修饰 public void swap(ref int x, ref int y) { int temp; temp = x; /* 保存 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 temp 赋值给 y */ } // 调用时 int a = 100; int b = 200; n.swap(ref a, ref b); // 输出参数 public void getValue(out int x ) { int temp = 5; x = temp; } // 调用时 int a = 100; n.swap(out a); 提供给输出参数的变量不需要赋值（只需要声明即可）。当需要从一个参数没有指定初始值的方法中返回值时，输出参数特别有用 using System; namespace CalculatorApplication { class NumberManipulator { public void getValues(out int x, out int y ) { Console.WriteLine(\"请输入第一个值： \"); x = Convert.ToInt32(Console.ReadLine()); Console.WriteLine(\"请输入第二个值： \"); y = Convert.ToInt32(Console.ReadLine()); } static void Main(string[] args) { NumberManipulator n = new NumberManipulator(); /* 局部变量定义 */ int a , b; /* 调用函数来获取值 */ n.getValues(out a, out b); Console.WriteLine(\"在方法调用之后，a 的值： {0}\", a); Console.WriteLine(\"在方法调用之后，b 的值： {0}\", b); Console.ReadLine(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:10:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"可空类型 nullable 可空类型可以表示其基础值类型正常范围内的值，再加上一个 null 值。 例如，Nullable\u003c Int32 \u003e，读作\"可空的 Int32\"，可以被赋值为 -2,147,483,648 到 2,147,483,647 之间的任意值，也可以被赋值为 null 值。 \u003cdata_type\u003e ? \u003cvariable_name\u003e = null;、 int i; //默认值0 int? ii; //默认值null using System; namespace CalculatorApplication { class NullablesAtShow { static void Main(string[] args) { int? num1 = null; int? num2 = 45; double? num3 = new double?(); double? num4 = 3.14157; bool? boolval = new bool?(); // 显示值 Console.WriteLine(\"显示可空类型的值： {0}, {1}, {2}, {3}\", num1, num2, num3, num4); Console.WriteLine(\"一个可空的布尔值： {0}\", boolval); Console.ReadLine(); } } } 输出 显示可空类型的值： , 45, , 3.14157 一个可空的布尔值： ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:11:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Null 合并运算符（ ?? ） Null 合并运算符为类型转换定义了一个预设值，以防可空类型的值为 Null。 using System; namespace CalculatorApplication { class NullablesAtShow { static void Main(string[] args) { double? num1 = null; double? num2 = 3.14157; double num3; num3 = num1 ?? 5.34; // num1 如果为空值则返回 5.34 Console.WriteLine(\"num3 的值： {0}\", num3); num3 = num2 ?? 5.34; Console.WriteLine(\"num3 的值： {0}\", num3); Console.ReadLine(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:11:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"数组 Array ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:12:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"基本操作 声明 datatype[] arrayName; //如 double[] balance; 初始化 数组是一个引用类型，需要使用 new 关键字来创建数组的实例 double[] balance = new double[10]; 赋值 给单个元素赋值 double[] balance = new double[10]; balance[0] = 4500.0; 在声明数组的同时赋值 double[] balance = { 2340.0, 4523.69, 3421.0}; 创建并初始化一个数组 int[] marks = new int[5] { 99, 98, 92, 97, 95}; 省略数组的大小 int[] marks = new int[] { 99, 98, 92, 97, 95}; 赋值一个数组变量到另一个目标数组变量中。在这种情况下，目标和源会指向相同的内存位置 int 、[] marks = new int[] { 99, 98, 92, 97, 95}; int[] score = marks; 当创建一个数组时，C# 编译器会根据数组类型隐式初始化每个数组元素为一个默认值。例如，int 数组的所有元素都会被初始化为 0 访问 double salary = balance[9]; ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:12:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"多维数组 多维数组又称为矩形数组 声明一个 string 变量的二维数组，如下： string [,] names; 或者，声明一个 int 变量的三维数组，如下： int [ , , ] m; 初始化二维数组 多维数组可以通过在括号内为每行指定值来进行初始化。下面是一个带有 3 行 4 列的数组。 int [,] a = new int [3,4] { {0, 1, 2, 3} , /* 初始化索引号为 0 的行 */ {4, 5, 6, 7} , /* 初始化索引号为 1 的行 */ {8, 9, 10, 11} /* 初始化索引号为 2 的行 */ }; 访问二维数组元素 二维数组中的元素是通过使用下标（即数组的行索引和列索引）来访问的。例如： int val = a[2,3]; ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:12:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"交错数组 交错数组就是数组的数组 可以声明一个带有 int 值的交错数组 scores，如下所示： int [][] scores; 第一个中括号中的数字为数组的长度 声明一个数组不会在内存中创建数组。 创建上面的数组： int[][] scores = new int[5][]; for (int i = 0; i \u003c scores.Length; i++) { scores[i] = new int[4]; } 初始化一个交错数组，如下所示： int[][] scores = new int[2][]{new int[]{92,93,94},new int[]{85,66,87,88}}; 其中，scores 是一个由两个整型数组组成的数组 – scores[0] 是一个带有 3 个整数的数组，scores[1] 是一个带有 4 个整数的数组。 有例： using System; namespace ArrayApplication { class MyArray { static void Main(string[] args) { /* 一个由 5 个整型数组组成的交错数组 */ int[][] a = new int[][]{new int[]{0,0},new int[]{1,2}, new int[]{2,4},new int[]{ 3, 6 }, new int[]{ 4, 8 } }; int i, j; /* 输出数组中每个元素的值 */ for (i = 0; i \u003c 5; i++) { for (j = 0; j \u003c 2; j++) { Console.WriteLine(\"a[{0}][{1}] = {2}\", i, j, a[i][j]); } } Console.ReadKey(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:12:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"Array 类 Array 类是 C# 中所有数组的基类，它是在 System 命名空间中定义。Array 类提供了各种用于数组的属性和方法。 属性 Length 数组长度，32 位整数 LongLength 数组长度，64 位整数 Rank 数组的秩，即维度数 IsReadOnly 数组是否为只读 IsFixedSize 数组大小是否固定 方法 list 代表数组实例 list.GetValue(int index) 获取一维数组中指定位置的元素值 list.SetValue(object? value, int index) 给一维数组中指定位置的元素设置值。索引由一个 32 位整数指定 Array.Clear(Array array, int startIndex, int length) 删除数组中的所有元素 Array.IndexOf(T[] array, object? value) 获取指定数组指定元素的索引 Array.LastIndexOf(T[] array, object? value) 获取指定数组指定元素出现的最后位置的索引 Array.Sort(T[] array) 顺序排序 Array.Reverse(T[] array) 将数组倒置 list.GetLength(int dimension) 查询数组指定秩的元素数量 list.GetLongLength(int dimension) 查询数组指定秩的元素数量，64 位整数 Array.FindIndex(T[] array, int startIndex, int count, Predicate\u003cT\u003e match) 搜索指定元素，返回索引（用法存疑） Array.Copy(Array sourceArray, Array destinationArray, int length) 将 SourceArray 拷贝到 destinationArray 上 list.CopyTo(Array array, int index) 将 list 拷贝至 array（从 array 索引为 index 的位上开始） Clone() ConstrainedCopy() BinarySearch() GetLowerBound() GetUpperBound() using System; namespace TypeConversionApplication { class ExplicitConversion { static void Main(string[] args) { int[] list; Console.WriteLine(\"Sort\"); list = new int[] { 1, 5, 2, 6, 3 }; Array.Sort(list); foreach (int x in list) { Console.WriteLine(x); } Console.WriteLine(\"Reverse\"); list = new int[] { 1, 5, 2, 6, 3 }; Array.Reverse(list); foreach (int x in list) { Console.WriteLine(x); } Console.WriteLine(\"Clear\"); list = new int[] { 1, 5, 2, 6, 3 }; Array.Clear(list, 0, list.Length); foreach (int x in list) { Console.WriteLine(x); } Console.WriteLine(\"GetValue\"); list = new int[] { 1, 5, 2, 6, 3 }; Console.WriteLine(list.GetValue(0)); Console.WriteLine(\"SetValue\"); list = new int[] { 1, 5, 2, 6, 3 }; list.SetValue(100, 0); Console.WriteLine(list[0]); Console.WriteLine(\"IndexOf\"); list = new int[] { 1, 5, 2, 6, 3, 1 }; Console.WriteLine(Array.IndexOf(list, 1)); Console.WriteLine(\"LastIndexOf\"); list = new int[] { 1, 5, 2, 6, 3, 1 }; Console.WriteLine(Array.LastIndexOf(list, 1)); Console.WriteLine(\"GetLength\"); int[,] list2 = new int[,] { { 1, 2 }, { 3, 4 }, { 5, 6 } }; Console.WriteLine(list2.GetLength(0)); // 秩为0的元素数量，为3 Console.WriteLine(list2.GetLength(1)); // 秩为1的元素数量，为2 Console.WriteLine(\"Copy\"); list = new int[] { 1, 5, 2, 6, 3, 1 }; int[] listCopy = new int[10]; Array.Copy(list, listCopy, 4); foreach (int i in listCopy) { Console.WriteLine(i); } Console.WriteLine(\"CopyTo\"); list = new int[] { 1, 5, 2, 6, 3, 1 }; int[] listCopy2 = new int[10]; list.CopyTo(listCopy2, 1); foreach (int i in listCopy2) { Console.WriteLine(i); //0 1 5 2 6 3 1 0 0 0 } // Console.ReadKey(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:12:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"字符串 String 可以使用字符数组来表示字符串，但是更常见的做法是使用 string 关键字来声明一个字符串变量。 string 关键字是 System.String 类的别名。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:13:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"创建 可以使用以下方法之一来创建 string 对象： 通过给 String 变量指定一个字符串 通过使用 String 类构造函数 通过使用字符串串联运算符（ + ） 通过检索属性或调用一个返回字符串的方法 通过格式化方法来转换一个值或对象为它的字符串表示形式 using System; namespace StringApplication { class Program { static void Main(string[] args) { //字符串，字符串连接 string fname, lname; fname = \"Rowan\"; lname = \"Atkinson\"; string fullname = fname + lname; Console.WriteLine(\"Full Name: {0}\", fullname); //通过使用 string 构造函数 char[] letters = { 'H', 'e', 'l', 'l','o' }; string greetings = new string(letters); Console.WriteLine(\"Greetings: {0}\", greetings); //方法返回字符串 string[] sarray = { \"Hello\", \"From\", \"Tutorials\", \"Point\" }; string message = String.Join(\" \", sarray); Console.WriteLine(\"Message: {0}\", message); //用于转化值的格式化方法 DateTime waiting = new DateTime(2012, 10, 10, 17, 58, 1); string chat = String.Format(\"Message sent at {0:t} on {0:D}\", waiting); Console.WriteLine(\"Message: {0}\", chat); Console.ReadKey() ; } } } 输出 Full Name: RowanAtkinson Greetings: Hello Message: Hello From Tutorials Point Message: Message sent at 17:58 on Wednesday, 10 October 2012 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:13:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"属性 Length 字符串长度 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:13:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"方法 ToUpper() 小写转大写 ToLower() 大写转小写 Equals(String? value, StringComparison comparisonType) 是否与 value 相同 StringComparison comparisonType StringComparison.OrdinalIgnoreCase 不区分大小写 StringComparison.Ordinal 区分大小写 Spilt(String? separator, StringSplitOptions options = StringSplitOptions.None) 根据 separator 分割字符串，返回字符串类型的数组 StringSplitOptions options StringSplitOptions.RemoveEmptyEntries 移除空字符串 SubString(int startIndex) 截取字符串，在截取的时候包含截取的索引位置 返回从 startIndex 后的字符串 IndexOf(char value) 返回 value 在字符串中的位置索引 LastIndexOf()(char value) 返回 value 在最后出现在字符串中的位置索引 StartsWith(char value) 判断字符串是否以 value 开头 Replace(char oldChar, char newChar) 替换指定字符串 Contains(char value) 判断字符串是否包含指定的子字符串 value Trim() 掉字符串前后的空格 TrimStart() 和 TrimEnd() 去掉字符串前面的空格，去掉字符串后面的空格 IsNullOrEmpty() 判断字符串是否为空 string.Join(char separator, string[] str) 数组 str 按照指定的字符串 separator 连接，并返回一个字符串 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:13:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"结构体 struct ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:14:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"定义 struct Books { public string title; public string author; public string subject; public int book_id; }; 有例： public class testStructure { public static void Main(string[] args) { Books Book1; /* 声明 Book1，类型为 Books */ Books Book2; /* 声明 Book2，类型为 Books */ /* book 1 详述 */ Book1.title = \"C Programming\"; Book1.author = \"Nuha Ali\"; Book1.subject = \"C Programming Tutorial\"; Book1.book_id = 6495407; /* book 2 详述 */ Book2.title = \"Telecom Billing\"; Book2.author = \"Zara Ali\"; Book2.subject = \"Telecom Billing Tutorial\"; Book2.book_id = 6495700; Console.ReadKey(); } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:14:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"特点 结构可带有方法、字段、索引、属性、运算符方法和事件。 结构可定义构造函数，但不能定义析构函数。但是不能为结构定义无参构造函数。无参构造函数(默认)是自动定义的，且不能被改变。 与类不同，结构不能继承其他的结构或类。 结构不能作为其他结构或类的基础结构。 结构可实现一个或多个接口。 结构成员不能指定为 abstract、virtual 或 protected。 当您使用 New 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 New 操作符即可被实例化。 如果不使用 New 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。 有例： struct Books { private string title; private string author; private string subject; private int book_id; public void setValues(string t, string a, string s, int id) { title = t; author = a; subject = s; book_id =id; } public void display() { Console.WriteLine(\"Title : {0}\", title); Console.WriteLine(\"Author : {0}\", author); Console.WriteLine(\"Subject : {0}\", subject); Console.WriteLine(\"Book_id :{0}\", book_id); } }; ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:14:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"类与结构体的不同点 类是引用类型，结构是值类型。 结构不支持继承。 结构不能声明默认的构造函数。 结构体中声明的字段无法赋予初值，类可以 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:14:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"枚举 enum 枚举是一组命名整型常量。枚举类型是使用 enum 关键字声明的 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:15:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"声明 enum \u003cenum_name\u003e { enumeration list }; enum_name 指定枚举的类型名称。 enumeration list 是一个用逗号分隔的标识符列表。 枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。 默认情况下，第一个枚举符号的值是 0 enum Days { Sun, Mon, tue, Wed, thu, Fri, Sat }; 有例： using System; public class EnumTest { enum Day { Sun, Mon, Tue, Wed, Thu, Fri, Sat }; static void Main() { int x = (int)Day.Sun; int y = (int)Day.Fri; Console.WriteLine(\"Sun = {0}\", x); Console.WriteLine(\"Fri = {0}\", y); } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:15:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"类 class 你定义一个类时，你定义了一个数据类型的蓝图 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:16:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"定义 \u003caccess specifier\u003e class class_name { // member variables \u003caccess specifier\u003e \u003cdata type\u003e variable1; \u003caccess specifier\u003e \u003cdata type\u003e variable2; ... \u003caccess specifier\u003e \u003cdata type\u003e variableN; // member methods \u003caccess specifier\u003e \u003creturn type\u003e method1(parameter_list) { // method body } \u003caccess specifier\u003e \u003creturn type\u003e method2(parameter_list) { // method body } ... \u003caccess specifier\u003e \u003creturn type\u003e methodN(parameter_list) { // method body } } 访问标识符 \u003caccess specifier\u003e 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 internal，成员的默认访问标识符是 private。 数据类型 \u003cdata type\u003e 指定了变量的类型，返回类型 \u003creturn type\u003e 指定了返回的方法返回的数据类型。 如果要访问类的成员，你要使用点（.）运算符。点运算符链接了对象的名称和成员的名称 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:17:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"构造函数 构造函数是类的一个特殊的成员函数，当创建类的新对象时执行。 构造函数的名称与类的名称完全相同，它没有任何返回类型 using System; namespace LineApplication { class Line { private double length; // 线条的长度 public Line() { Console.WriteLine(\"对象已创建\"); } public void setLength( double len ) { length = len; } public double getLength() { return length; } static void Main(string[] args) { Line line = new Line(); // 设置线条长度 line.setLength(6.0); Console.WriteLine(\"线条的长度： {0}\", line.getLength()); Console.ReadKey(); } } } 默认的构造函数没有任何参数。有参数的构造函数叫做参数化构造函数 public Line(double len) // 参数化构造函数 { Console.WriteLine(\"对象已创建，length = {0}\", len); length = len; } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:17:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"析构函数 当类的对象超出范围时，析构函数执行 析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数 析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。 ~Line() //析构函数 { Console.WriteLine(\"对象已删除\"); } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:17:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"静态成员 使用 static 关键字把类成员定义为静态的 当我们声明一个类成员为静态时，意味着无论有多少个类的对象被创建，只会有一个该静态成员的副本。 静态变量用于定义常量，因为它们的值可以通过直接调用类而不需要创建类的实例来获取 静态变量可在成员函数或类的定义外部进行初始化，也可以在类的定义内部初始化 class StaticVar { public static int num; public void count() { num++; } public int getNum() { return num; } } // 调用 count() 时，所有实例的 num 都会 ++ ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:17:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"继承 \u003c访问修饰符符\u003e class \u003c基类\u003e { ... } class \u003c派生类\u003e : \u003c基类\u003e { ... } 有例： using System; namespace InheritanceApplication { class Shape { public void setWidth(int w) { width = w; } public void setHeight(int h) { height = h; } protected int width; protected int height; } // 派生类 class Rectangle: Shape { public int getArea() { return (width * height); } } class RectangleTester { static void Main(string[] args) { Rectangle Rect = new Rectangle(); Rect.setWidth(5); Rect.setHeight(7); // 打印对象的面积 Console.WriteLine(\"总面积： {0}\", Rect.getArea()); Console.ReadKey(); } } } 要点 父类对象应在子类对象创建之前被创建 多重继承 多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。而单一继承指一个类别只可以继承自一个父类。 using System; namespace InheritanceApplication { class Shape { public void setWidth(int w) { width = w; } public void setHeight(int h) { height = h; } protected int width; protected int height; } // 基类 PaintCost public interface PaintCost { int getCost(int area); } // 派生类 class Rectangle : Shape, PaintCost { public int getArea() { return (width * height); } public int getCost(int area) { return area * 70; } } class RectangleTester { static void Main(string[] args) { Rectangle Rect = new Rectangle(); int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 打印对象的面积 Console.WriteLine(\"总面积： {0}\", Rect.getArea()); Console.WriteLine(\"油漆总成本： ${0}\" , Rect.getCost(area)); Console.ReadKey(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:17:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"多态 多态是同一个行为具有多个不同表现形式或形态的能力，往往表现为“一个接口，多个功能” 多态性可以是静态的或动态的。 在静态多态性中，函数的响应是在编译时发生的。 在动态多态性中，函数的响应是在运行时发生的。 静态多态性 在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定 函数重载 可以在同一个范围内对相同的函数名有多个定义 函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。 不能重载只有返回类型不同的函数声明 public class TestData { public int Add(int a, int b, int c) { return a + b + c; } public int Add(int a, int b) { return a + b; } } 运算符重载 重载运算符是具有特殊名称的函数，是通过关键字 operator 后跟运算符的符号来定义的。 与其他函数一样，重载运算符有返回类型和参数列表。 public static Box operator+ (Box b, Box c) { Box box = new Box(); box.length = b.length + c.length; box.breadth = b.breadth + c.breadth; box.height = b.height + c.height; return box; } // 此函数为用户自定义的类 Box 实现了加法运算符（+）。它把两个 Box 对象的属性相加，并返回相加后的 Box 对象。 有例： using System; namespace OperatorOvlApplication { class Box { private double length; // 长度 private double breadth; // 宽度 private double height; // 高度 public double getVolume() { return length * breadth * height; } public void setLength( double len ) { length = len; } public void setBreadth( double bre ) { breadth = bre; } public void setHeight( double hei ) { height = hei; } // 重载 + 运算符来把两个 Box 对象相加 public static Box operator+ (Box b, Box c) { Box box = new Box(); box.length = b.length + c.length; box.breadth = b.breadth + c.breadth; box.height = b.height + c.height; return box; } } class Tester { static void Main(string[] args) { Box Box1 = new Box(); // 声明 Box1，类型为 Box Box Box2 = new Box(); // 声明 Box2，类型为 Box Box Box3 = new Box(); // 声明 Box3，类型为 Box double volume = 0.0; // 体积 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); Console.WriteLine(\"Box1 的体积： {0}\", volume); // Box2 的体积 volume = Box2.getVolume(); Console.WriteLine(\"Box2 的体积： {0}\", volume); // 把两个对象相加 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); Console.WriteLine(\"Box3 的体积： {0}\", volume); Console.ReadKey(); } } } 可重载和不可重载的运算符 运算符 描述 +, -, !, ~, ++, – 这些一元运算符只有一个操作数，且可以被重载。 +, -, *, /, % 这些二元运算符带有两个操作数，且可以被重载。 ==, !=, \u003c, \u003e, \u003c=, \u003e= 这些比较运算符可以被重载。 \u0026\u0026, || 这些条件逻辑运算符不能被直接重载。 +=, -=, *=, /=, %= 这些赋值运算符不能被重载。 =, ., ?:, -\u003e, new, is, sizeof, typeof 这些运算符不能被重载。 有例： public static Box operator+ (Box b, Box c) { Box box = new Box(); box.length = b.length + c.length; box.breadth = b.breadth + c.breadth; box.height = b.height + c.height; return box; } public static bool operator == (Box lhs, Box rhs) { bool status = false; if (lhs.length == rhs.length \u0026\u0026 lhs.height == rhs.height \u0026\u0026 lhs.breadth == rhs.breadth) { status = true; } return status; } public static bool operator !=(Box lhs, Box rhs) { bool status = false; if (lhs.length != rhs.length || lhs.height != rhs.height || lhs.breadth != rhs.breadth) { status = true; } return status; } public static bool operator \u003c(Box lhs, Box rhs) { bool status = false; if (lhs.length \u003c rhs.length \u0026\u0026 lhs.height \u003c rhs.height \u0026\u0026 lhs.breadth \u003c rhs.breadth) { status = true; } return status; } public static bool operator \u003e(Box lhs, Box rhs) { bool status = false; if (lhs.length \u003e rhs.length \u0026\u0026 lhs.height \u003e rhs.height \u0026\u0026 lhs.breadth \u003e rhs.breadth) { status = true; } return status; } public static bool operator \u003c=(Box lhs, Box rhs) { bool status = false; if (lhs.length \u003c= rhs.length \u0026\u0026 lhs.height \u003c= rhs.height \u0026\u0026 lhs.breadth \u003c= rhs.breadth) { status = true; } return status; } public static bool operator \u003e=(Box lhs, Box rhs) { bool status = false; if (lhs.length \u003e= rhs.length \u0026\u0026 lhs.height \u003e= rhs.height \u0026\u0026 lhs.breadth \u003e= rhs.breadth) { status = true; } return status; } 动态多态性 动态多态性是通过 抽象类 和 虚方法 实现的。 abstract 使用关键字 abstract 创建抽象类，用于提供接口的部分类的实现 当一个派生类继承自该抽象类时，实现即完成。 抽象类包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。 抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。 规则 不能创建一个抽象类的实例。 不能在一个抽象类外部声明一个抽象方法。 通过在类定义前面放置关键字 sealed，可以将类声明为密封类。当一个类被声明为 sealed 时，它不能被继承。抽象类不能被声明为 sealed。 有例： using System; namespace PolymorphismApplication { abstract class Shape { abstract public int area(); } class Rectangle: Shape { private int length; private int width; public Rectangle( in","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:17:5","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"接口 interface 接口定义了所有类继承接口时应遵循的语法合同。 接口定义了语法合同 “是什么” 部分，派生类定义了语法合同 “怎么做” 部分。 接口使得实现接口的类或结构在形式上保持一致。 抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。 接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:18:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"定义 使用 interface 关键字声明，它与类的声明类似。接口声明默认是 public 的 using System; interface IMyInterface { // 接口成员 void MethodToImplement(); } 以上代码定义了接口 IMyInterface。通常接口命令以 I 字母开头，这个接口只有一个方法 MethodToImplement()，没有参数和返回值，当然可以按照需求设置参数和返回值 class InterfaceImplementer : IMyInterface { static void Main() { InterfaceImplementer iImp = new InterfaceImplementer(); iImp.MethodToImplement(); } public void MethodToImplement() { Console.WriteLine(\"MethodToImplement() called.\"); } } InterfaceImplementer 类实现了 IMyInterface 接口，接口的实现与类的继承语法格式类似： class InterfaceImplementer : IMyInterface 继承接口后，我们需要实现接口的方法 MethodToImplement() , 方法名必须与接口定义的方法名一致 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:18:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"继承 以下实例定义了两个接口 IMyInterface 和 IParentInterface。 如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。 以下实例 IMyInterface 继承了 IParentInterface 接口，因此接口实现类必须实现 MethodToImplement() 和 ParentInterfaceMethod() 方法： ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:18:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"实例 以下实例定义了两个接口 IMyInterface 和 IParentInterface。 如果一个接口继承其他接口，那么实现类或结构就需要实现所有接口的成员。 以下实例 IMyInterface 继承了 IParentInterface 接口，因此接口实现类必须实现 MethodToImplement() 和 ParentInterfaceMethod() 方法： using System; interface IParentInterface { void ParentInterfaceMethod(); } interface IMyInterface : IParentInterface { void MethodToImplement(); } class InterfaceImplementer : IMyInterface { static void Main() { InterfaceImplementer iImp = new InterfaceImplementer(); iImp.MethodToImplement(); iImp.ParentInterfaceMethod(); } public void MethodToImplement() { Console.WriteLine(\"MethodToImplement() called.\"); } public void ParentInterfaceMethod() { Console.WriteLine(\"ParentInterfaceMethod() called.\"); } } 实例输出结果为： MethodToImplement() called. ParentInterfaceMethod() called. ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:19:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"命名空间 命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。 在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:20:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"定义 以关键字 namespace 开始，后跟命名空间的名称 namespace namespace_name { // 代码声明 } 为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示： namespace_name.item_name; 有例： using System; namespace first_space { class namespace_cl { public void func() { Console.WriteLine(\"Inside first_space\"); } } } namespace second_space { class namespace_cl { public void func() { Console.WriteLine(\"Inside second_space\"); } } } class TestClass { static void Main(string[] args) { first_space.namespace_cl fc = new first_space.namespace_cl(); second_space.namespace_cl sc = new second_space.namespace_cl(); fc.func(); sc.func(); Console.ReadKey(); } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:21:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"using 关键字 using 关键字表明程序使用的是给定命名空间中的名称 using System; using first_space; using second_space; namespace first_space { class abc { public void func() { Console.WriteLine(\"Inside first_space\"); } } } namespace second_space { class efg { public void func() { Console.WriteLine(\"Inside second_space\"); } } } class TestClass { static void Main(string[] args) { abc fc = new abc(); efg sc = new efg(); fc.func(); sc.func(); Console.ReadKey(); } } 嵌套命名空间 命名空间可以被嵌套 namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } 有例： using System; using SomeNameSpace; using SomeNameSpace.Nested; namespace SomeNameSpace { public class MyClass { static void Main() { Console.WriteLine(\"In SomeNameSpace\"); Nested.NestedNameSpaceClass.SayHello(); } } // 内嵌命名空间 namespace Nested { public class NestedNameSpaceClass { public static void SayHello() { Console.WriteLine(\"In Nested\"); } } } } 用处 1. using指令：引入命名空间 这是最常见的用法，例如： using System; using Namespace1.SubNameSpace; 2. using static 指令：指定无需指定类型名称即可访问其静态成员的类型 using static System.Math;var = PI; // 直接使用System.Math.PI 3. 起别名 using Project = PC.MyCompany.Project; 4. using语句：将实例与代码绑定 using (Font font3 = new Font(\"Arial\", 10.0f), font4 = new Font(\"Arial\", 10.0f)) { // Use font3 and font4. } 代码段结束时，自动调用font3和font4的Dispose方法，释放实例。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:21:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"预处理指令 预处理器指令指导编译器在实际编译开始之前对信息进行预处理 所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号 ; 结束。 预处理器指令 描述 #define 用于定义一系列成为符号的字符。 #undef 用于取消定义符号。 #if 用于测试符号是否为真。 #else 用于创建复合条件指令，与 #if 一起使用。 #elif 用于创建复合条件指令。 #endif 定一个条件指令的结束。 #line 允许修改编译器的行数以及（可选地）输出错误和警告的文件名。 #error 允许从代码的指定位置生成一个错误。 #warning 允许从代码的指定位置生成一级警告。 #region 允许在使用 Visual Studio Code Editor 的大纲特性时，指定一个可展开或折叠的代码块。 #endregion 标识着 #region 块的结束。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:22:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"#define 指令 #define 预处理器指令创建符号常量 #define symbol 有例： #define PI using System; namespace PreprocessorDAppl { class Program { static void Main(string[] args) { #if (PI) Console.WriteLine(\"PI is defined\"); #else Console.WriteLine(\"PI is not defined\"); #endif Console.ReadKey(); } } } 输出 PI is defined ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:22:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"条件指令 条件指令用于测试符号是否为真。如果为真，编译器会执行 #if 和下一个指令之间的代码 #if symbol [operator symbol]... 其中，symbol 是要测试的符号名称。也可以使用 true 和 false，或在符号前放置否定运算符。 常见运算符有： == (等于) != (不等于) \u0026\u0026 (与) || (或) 您也可以用括号把符号和运算符进行分组。条件指令用于在调试版本或编译指定配置时编译代码。一个以 #if 指令开始的条件指令，必须显示地以一个 #endif 指令终止。 #define DEBUG #define VC_V10 using System; public class TestClass { public static void Main() { #if (DEBUG \u0026\u0026 !VC_V10) Console.WriteLine(\"DEBUG is defined\"); #elif (!DEBUG \u0026\u0026 VC_V10) Console.WriteLine(\"VC_V10 is defined\"); #elif (DEBUG \u0026\u0026 VC_V10) Console.WriteLine(\"DEBUG and VC_V10 are defined\"); #else Console.WriteLine(\"DEBUG and VC_V10 are not defined\"); #endif Console.ReadKey(); } } 输出 DEBUG and VC_V10 are defined ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:22:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"异常处理 关键词 try：一个 try 块标识了一个将被激活的特定的异常的代码块。后跟一个或多个 catch 块。 catch：程序通过异常处理程序捕获异常。catch 关键字表示异常的捕获。 finally：finally 块用于执行给定的语句，不管异常是否被抛出都会执行。例如，如果您打开一个文件，不管是否出现异常文件都要被关闭。 throw：当问题出现时，程序抛出一个异常。使用 throw 关键字来完成。 ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:23:0","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"语法 可以列出多个 catch 语句捕获不同类型的异常，以防 try 块在不同的情况下生成多个异常 try { // 引起异常的语句 } catch( ExceptionName e1 ) { // 错误处理代码 } catch( ExceptionName e2 ) { // 错误处理代码 } catch( ExceptionName eN ) { // 错误处理代码 } finally { // 要执行的语句 } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:23:1","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"异常类 C# 异常是使用类来表示的，他们主要是直接或间接地派生于 System.Exception 类 System.ApplicationException 和 System.SystemException 类是派生于 System.Exception 类的异常类。 System.ApplicationException 类支持由应用程序生成的异常。所以程序员定义的异常都应派生自该类。 System.SystemException 类是所有预定义的系统异常的基类。 异常类 描述 System.IO.IOException 处理 I/O 错误。 System.IndexOutOfRangeException 处理当方法指向超出范围的数组索引时生成的错误。 System.ArrayTypeMismatchException 处理当数组类型不匹配时生成的错误。 System.NullReferenceException 处理当依从一个空对象时生成的错误。 System.DivideByZeroException 处理当除以零时生成的错误。 System.InvalidCastException 处理在类型转换期间生成的错误。 System.OutOfMemoryException 处理空闲内存不足生成的错误。 System.StackOverflowException 处理栈溢出生成的错误。 有例： using System; namespace ErrorHandlingApplication { class DivNumbers { int result; DivNumbers() { result = 0; } public void division(int num1, int num2) { try { result = num1 / num2; } catch (DivideByZeroException e) { Console.WriteLine(\"Exception caught: {0}\", e); } finally { Console.WriteLine(\"Result: {0}\", result); } } static void Main(string[] args) { DivNumbers d = new DivNumbers(); d.division(25, 0); Console.ReadKey(); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:23:2","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"创建自定义异常 用户自定义的异常类是派生自 ApplicationException 类 using System; namespace UserDefinedException { class TestTemperature { static void Main(string[] args) { Temperature temp = new Temperature(); try { temp.showTemp(); } catch(TempIsZeroException e) { Console.WriteLine(\"TempIsZeroException: {0}\", e.Message); } Console.ReadKey(); } } } public class TempIsZeroException: ApplicationException { public TempIsZeroException(string message): base(message) { } } public class Temperature { int temperature = 0; public void showTemp() { if(temperature == 0) { throw (new TempIsZeroException(\"Zero Temperature found\")); } else { Console.WriteLine(\"Temperature: {0}\", temperature); } } } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:23:3","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["C#"],"content":"抛出对象 如果异常是直接或间接派生自 System.Exception 类，您可以抛出一个对象。 您可以在 catch 块中使用 throw 语句来抛出当前的对象 Catch(Exception e) { // ... Throw e } ","date":"2021-10-23","objectID":"/Notes/posts/c#/basicgrammar/:23:4","tags":["快速入门"],"title":"C# 基础语法","uri":"/Notes/posts/c#/basicgrammar/"},{"categories":["Golang"],"content":"gin Gin is a HTTP web framework written in Go (Golang). It features a Martini-like API, but with performance up to 40 times faster than Martini. package main import \"github.com/gin-gonic/gin\" func main() { r := gin.Default() r.GET(\"/ping\", func(c *gin.Context) { c.JSON(200, gin.H{ \"message\": \"pong\", }) }) r.Run() // listen and serve on 0.0.0.0:8080 } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:0:0","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Quick Start ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:1:0","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Installation $ go get -u github.com/gin-gonic/gin Import it in your code: import \"github.com/gin-gonic/gin\" (Optional) Import net/http. This is required for example if using constants such as http.StatusOK. import \"net/http\" ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:1:1","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"特性 快速：路由不使用反射，基于 Radix 树，内存占用少。 中间件：HTTP 请求，可先经过一系列中间件处理，例如：Logger，Authorization，GZIP 等。这个特性和 NodeJs 的 Koa 框架很像。中间件机制也极大地提高了框架的可扩展性。 异常处理：服务始终可用，不会宕机。Gin 可以捕获 panic，并恢复。而且有极为便利的机制处理 HTTP 请求过程中发生的错误。 JSON：Gin 可以解析并验证请求的 JSON。这个特性对 Restful API 的开发尤其有用。 路由分组：例如将需要授权和不需要授权的 API 分组，不同版本的 API 分组。而且分组可嵌套，且性能不受影响。 渲染内置：原生支持 JSON，XML 和 HTML 的渲染。 ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:1:2","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"路由 路径参数 /user/:name/*role，: 代表动态参数，* 代表可选。 // 匹配 /user/geektutu r.GET(\"/user/:name\", func(c *gin.Context) { name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s\", name) }) // $ curl http://localhost:9999/user/geektutu // Hello geektutu 查询参数 // 匹配users?name=xxx\u0026role=xxx，role可选 r.GET(\"/users\", func(c *gin.Context) { name := c.Query(\"name\") // 获取查询参数 role := c.DefaultQuery(\"role\", \"teacher\") // 获取并设置查询默认参数 c.String(http.StatusOK, \"%s is a %s\", name, role) }) // $ curl \"http://localhost:9999/users?name=Tom\u0026role=student\" // Tom is a student 获取 POST 参数 // POST r.POST(\"/form\", func(c *gin.Context) { username := c.PostForm(\"username\") password := c.DefaultPostForm(\"password\", \"000000\") // 可设置默认值 c.JSON(http.StatusOK, gin.H{ \"username\": username, \"password\": password, }) }) // $ curl http://localhost:9999/form -X POST -d 'username=geektutu\u0026password=1234' // {\"password\":\"1234\",\"username\":\"geektutu\"} Map 参数 (字典参数) r.POST(\"/post\", func(c *gin.Context) { ids := c.QueryMap(\"ids\") names := c.PostFormMap(\"names\") c.JSON(http.StatusOK, gin.H{ \"ids\": ids, \"names\": names, }) }) // $ curl -g \"http://localhost:9999/post?ids[Jack]=001\u0026ids[Tom]=002\" -X POST -d 'names[a]=Sam\u0026names[b]=David' // {\"ids\":{\"Jack\":\"001\",\"Tom\":\"002\"},\"names\":{\"a\":\"Sam\",\"b\":\"David\"}} 重定向 Redirect r.GET(\"/redirect\", func(c *gin.Context) { c.Redirect(http.StatusMovedPermanently, \"/index\") }) r.GET(\"/goindex\", func(c *gin.Context) { c.Request.URL.Path = \"/\" r.HandleContext(c) }) // $ curl -i http://localhost:9999/redirect // HTTP/1.1 301 Moved Permanently // Content-Type: text/html; charset=utf-8 // Location: / // Date: Thu, 08 Aug 2019 17:22:14 GMT // Content-Length: 36 // \u003ca href=\"/\"\u003eMoved Permanently\u003c/a\u003e. // $ curl \"http://localhost:9999/goindex\" // Who are you? 分组路由 Grouping Routes 如果有一组路由，前缀都是 /api/v1 开头，是否每个路由都需要加上 /api/v1 这个前缀呢？答案是不需要，分组路由可以解决这个问题。 利用分组路由还可以更好地实现权限控制，例如将需要登录鉴权的路由放到同一分组中去，简化权限控制。 // group routes 分组路由 defaultHandler := func(c *gin.Context) { c.JSON(http.StatusOK, gin.H{ \"path\": c.FullPath(), }) } // group: v1 v1 := r.Group(\"/v1\") { v1.GET(\"/posts\", defaultHandler) v1.GET(\"/series\", defaultHandler) } // group: v2 v2 := r.Group(\"/v2\") { v2.GET(\"/posts\", defaultHandler) v2.GET(\"/series\", defaultHandler) } // $ curl http://localhost:9999/v1/posts // {\"path\":\"/v1/posts\"} // $ curl http://localhost:9999/v2/posts // {\"path\":\"/v2/posts\"} ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:1:3","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"上传文件 单个文件 r.POST(\"/upload1\", func(c *gin.Context) { file, _ := c.FormFile(\"file\") // c.SaveUploadedFile(file, dst) c.String(http.StatusOK, \"%s uploaded!\", file.Filename) }) 多个文件 r.POST(\"/upload2\", func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[\"upload[]\"] for _, file := range files { log.Println(file.Filename) // c.SaveUploadedFile(file, dst) } c.String(http.StatusOK, \"%d files uploaded!\", len(files)) }) ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:1:4","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"HTML 模板 Template type student struct { Name string Age int8 } r.LoadHTMLGlob(\"templates/*\") stu1 := \u0026student{Name: \"Geektutu\", Age: 20} stu2 := \u0026student{Name: \"Jack\", Age: 22} r.GET(\"/arr\", func(c *gin.Context) { c.HTML(http.StatusOK, \"arr.tmpl\", gin.H{ \"title\": \"Gin\", \"stuArr\": [2]*student{stu1, stu2}, }) }) \u003c!-- templates/arr.tmpl --\u003e \u003chtml\u003e \u003cbody\u003e \u003cp\u003ehello, {{.title}}\u003c/p\u003e {{range $index, $ele := .stuArr }} \u003cp\u003e{{ $index }}: {{ $ele.Name }} is {{ $ele.Age }} years old\u003c/p\u003e {{ end }} \u003c/body\u003e \u003c/html\u003e $ curl http://localhost:9999/arr \u003chtml\u003e \u003cbody\u003e \u003cp\u003ehello, Gin\u003c/p\u003e \u003cp\u003e0: Geektutu is 20 years old\u003c/p\u003e \u003cp\u003e1: Jack is 22 years old\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e Gin 默认使用模板 Go 语言标准库的模板 text/template 和 html/template，语法与标准库一致，支持各种复杂场景的渲染。 ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:1:5","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"中间件 Middleware // 作用于全局 r.Use(gin.Logger()) r.Use(gin.Recovery()) // 作用于单个路由 r.GET(\"/benchmark\", MyBenchLogger(), benchEndpoint) // 作用于某个组 authorized := r.Group(\"/\") authorized.Use(AuthRequired()) { authorized.POST(\"/login\", loginEndpoint) authorized.POST(\"/submit\", submitEndpoint) } 如何自定义中间件呢？ func Logger() gin.HandlerFunc { return func(c *gin.Context) { t := time.Now() // 给Context实例设置一个值 c.Set(\"geektutu\", \"1111\") // 请求前 c.Next() // 请求后 latency := time.Since(t) log.Print(latency) } } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:2:0","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"热加载调试 Hot Reload Python 的 Flask 框架，有 debug 模式，启动时传入 debug=True 就可以热加载 (Hot Reload, Live Reload) 了。即更改源码，保存后，自动触发更新，浏览器上刷新即可。免去了杀进程、重新启动之苦。 Gin 原生不支持，但有很多额外的库可以支持。例如 github.com/codegangsta/gin github.com/pilu/fresh 这次，我们采用 github.com/pilu/fresh 。 go get -v -u github.com/pilu/fresh 安装好后，只需要将go run main.go命令换成fresh即可。每次更改源文件，代码将自动重新编译 (Auto Compile)。 ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:3:0","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Examples ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:0","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Using HTTP method func main() { // Creates a gin router with default middleware: // logger and recovery (crash-free) middleware router := gin.Default() router.GET(\"/someGet\", getting) router.POST(\"/somePost\", posting) router.PUT(\"/somePut\", putting) router.DELETE(\"/someDelete\", deleting) router.PATCH(\"/somePatch\", patching) router.HEAD(\"/someHead\", head) router.OPTIONS(\"/someOptions\", options) // By default it serves on :8080 unless a // PORT environment variable was defined. router.Run() // router.Run(\":3000\") for a hard coded port } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:1","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Parameters in path func main() { router := gin.Default() // This handler will match /user/john but will not match /user/ or /user router.GET(\"/user/:name\", func(c *gin.Context) { name := c.Param(\"name\") c.String(http.StatusOK, \"Hello %s\", name) }) // However, this one will match /user/john/ and also /user/john/send // If no other routers match /user/john, it will redirect to /user/john/ router.GET(\"/user/:name/*action\", func(c *gin.Context) { name := c.Param(\"name\") action := c.Param(\"action\") message := name + \" is \" + action c.String(http.StatusOK, message) }) router.Run(\":8080\") } * 代表可选。 ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:2","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Query string parameters func main() { router := gin.Default() // Query string parameters are parsed using the existing underlying request object. // The request responds to a url matching: /welcome?firstname=Jane\u0026lastname=Doe router.GET(\"/welcome\", func(c *gin.Context) { firstname := c.DefaultQuery(\"firstname\", \"Guest\") // set default value lastname := c.Query(\"lastname\") // shortcut for c.Request.URL.Query().Get(\"lastname\") c.String(http.StatusOK, \"Hello %s %s\", firstname, lastname) }) router.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:3","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Multipart/Urlencoded form func main() { router := gin.Default() router.POST(\"/form_post\", func(c *gin.Context) { message := c.PostForm(\"message\") nick := c.DefaultPostForm(\"nick\", \"anonymous\") // set default value c.JSON(200, gin.H{ \"status\": \"posted\", \"message\": message, \"nick\": nick, }) }) router.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:4","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Query and post form POST /post?id=1234\u0026page=1 HTTP/1.1 Content-Type: application/x-www-form-urlencoded name=manu\u0026message=this_is_great func main() { router := gin.Default() router.POST(\"/post\", func(c *gin.Context) { id := c.Query(\"id\") page := c.DefaultQuery(\"page\", \"0\") name := c.PostForm(\"name\") message := c.PostForm(\"message\") fmt.Printf(\"id: %s; page: %s; name: %s; message: %s\", id, page, name, message) }) router.Run(\":8080\") } id: 1234; page: 1; name: manu; message: this_is_great ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:5","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Map as querystring or postform parameters POST /post?ids[a]=1234\u0026ids[b]=hello HTTP/1.1 Content-Type: application/x-www-form-urlencoded names[first]=thinkerou\u0026names[second]=tianou func main() { router := gin.Default() router.POST(\"/post\", func(c *gin.Context) { ids := c.QueryMap(\"ids\") names := c.PostFormMap(\"names\") fmt.Printf(\"ids: %v; names: %v\", ids, names) }) router.Run(\":8080\") } ids: map[b:hello a:1234], names: map[second:tianou first:thinkerou] ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:6","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Multipart/Urlencoded binding package main import ( \"github.com/gin-gonic/gin\" ) type LoginForm struct { User string `form:\"user\" binding:\"required\"` Password string `form:\"password\" binding:\"required\"` } func main() { router := gin.Default() router.POST(\"/login\", func(c *gin.Context) { // you can bind multipart form with explicit binding declaration: // c.ShouldBindWith(\u0026form, binding.Form) // or you can simply use autobinding with ShouldBind method: var form LoginForm // in this case proper binding will be automatically selected if c.ShouldBind(\u0026form) == nil { if form.User == \"user\" \u0026\u0026 form.Password == \"password\" { c.JSON(200, gin.H{\"status\": \"you are logged in\"}) } else { c.JSON(401, gin.H{\"status\": \"unauthorized\"}) } } }) router.Run(\":8080\") } Test it with: $ curl -v --form user=user --form password=password http://localhost:8080/login ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:7","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Upload Files Single File The filename is always optional and must not be used blindly by the application: path information should be stripped, and conversion to the server file system rules should be done. func main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // single file file, _ := c.FormFile(\"file\") log.Println(file.Filename) // Upload the file to specific dst. c.SaveUploadedFile(file, dst) c.String(http.StatusOK, fmt.Sprintf(\"'%s' uploaded!\", file.Filename)) }) router.Run(\":8080\") } How to curl: curl -X POST http://localhost:8080/upload \\ -F \"file=@/Users/appleboy/test.zip\" \\ -H \"Content-Type: multipart/form-data\" Multiple Files func main() { router := gin.Default() // Set a lower memory limit for multipart forms (default is 32 MiB) router.MaxMultipartMemory = 8 \u003c\u003c 20 // 8 MiB router.POST(\"/upload\", func(c *gin.Context) { // Multipart form form, _ := c.MultipartForm() files := form.File[\"upload[]\"] for _, file := range files { log.Println(file.Filename) // Upload the file to specific dst. c.SaveUploadedFile(file, dst) } c.String(http.StatusOK, fmt.Sprintf(\"%d files uploaded!\", len(files))) }) router.Run(\":8080\") } How to curl: curl -X POST http://localhost:8080/upload \\ -F \"upload[]=@/Users/appleboy/test1.zip\" \\ -F \"upload[]=@/Users/appleboy/test2.zip\" \\ -H \"Content-Type: multipart/form-data\" ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:8","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Grouping routes func main() { router := gin.Default() // Simple group: v1 v1 := router.Group(\"/v1\") { v1.POST(\"/login\", loginEndpoint) v1.POST(\"/submit\", submitEndpoint) v1.POST(\"/read\", readEndpoint) } // Simple group: v2 v2 := router.Group(\"/v2\") { v2.POST(\"/login\", loginEndpoint) v2.POST(\"/submit\", submitEndpoint) v2.POST(\"/read\", readEndpoint) } router.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:9","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Blank Gin without middleware by default Use r := gin.New() instead of // Default With the Logger and Recovery middleware already attached r := gin.Default() ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:10","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Using middleware func main() { // Creates a router without any middleware by default r := gin.New() // Global middleware // Logger middleware will write the logs to gin.DefaultWriter even if you set with GIN_MODE=release. // By default gin.DefaultWriter = os.Stdout r.Use(gin.Logger()) // Recovery middleware recovers from any panics and writes a 500 if there was one. r.Use(gin.Recovery()) // Per route middleware, you can add as many as you desire. r.GET(\"/benchmark\", MyBenchLogger(), benchEndpoint) // Authorization group // authorized := r.Group(\"/\", AuthRequired()) // exactly the same as: authorized := r.Group(\"/\") // per group middleware! in this case we use the custom created // AuthRequired() middleware just in the \"authorized\" group. authorized.Use(AuthRequired()) { authorized.POST(\"/login\", loginEndpoint) authorized.POST(\"/submit\", submitEndpoint) authorized.POST(\"/read\", readEndpoint) // nested group testing := authorized.Group(\"testing\") testing.GET(\"/analytics\", analyticsEndpoint) } // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:11","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Custom Recovery behavior func main() { // Creates a router without any middleware by default r := gin.New() r.Use(gin.Logger()) // Recovery middleware recovers from any panics and writes a 500 if there was one. r.Use(gin.CustomRecovery(func(c *gin.Context, recovered interface{}) { if err, ok := recovered.(string); ok { c.String(http.StatusInternalServerError, fmt.Sprintf(\"error: %s\", err)) } c.AbortWithStatus(http.StatusInternalServerError) })) r.GET(\"/panic\", func(c *gin.Context) { // panic with a string -- the custom middleware could save this to a database or report it to the user panic(\"foo\") }) r.GET(\"/\", func(c *gin.Context) { c.String(http.StatusOK, \"ohai\") }) // Listen and serve on 0.0.0.0:8080 r.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:12","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"How to write log file func main() { // Disable Console Color, you don't need console color when writing the logs to file. gin.DisableConsoleColor() // Logging to a file. f, _ := os.Create(\"gin.log\") gin.DefaultWriter = io.MultiWriter(f) // Use the following code if you need to write the logs to file and console at the same time. // gin.DefaultWriter = io.MultiWriter(f, os.Stdout) router := gin.Default() router.GET(\"/ping\", func(c *gin.Context) { c.String(200, \"pong\") }) router.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:13","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Custom log file func main() { router := gin.New() // LoggerWithFormatter middleware will write the logs to gin.DefaultWriter // By default gin.DefaultWriter = os.Stdout router.Use(gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string { // your custom format return fmt.Sprintf(\"%s - [%s] \\\"%s %s %s %d %s \\\"%s\\\" %s\\\"\\n\", param.ClientIP, param.TimeStamp.Format(time.RFC1123), param.Method, param.Path, param.Request.Proto, param.StatusCode, param.Latency, param.Request.UserAgent(), param.ErrorMessage, ) })) router.Use(gin.Recovery()) router.GET(\"/ping\", func(c *gin.Context) { c.String(200, \"pong\") }) router.Run(\":8080\") } Sample Output ::1 - [Fri, 07 Dec 2018 17:04:38 JST] \"GET /ping HTTP/1.1 200 122.767µs \"Mozilla/5.0 (Macint ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:14","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Controlling Log output coloring By default, logs output on console should be colorized depending on the detected TTY. Never colorize logs: func main() { // Disable log's color gin.DisableConsoleColor() // Creates a gin router with default middleware: // logger and recovery (crash-free) middleware router := gin.Default() router.GET(\"/ping\", func(c *gin.Context) { c.String(200, \"pong\") }) router.Run(\":8080\") } Always colorize logs: func main() { // Force log's color gin.ForceConsoleColor() // Creates a gin router with default middleware: // logger and recovery (crash-free) middleware router := gin.Default() router.GET(\"/ping\", func(c *gin.Context) { c.String(200, \"pong\") }) router.Run(\":8080\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:15","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Model binding and validation To bind a request body into a type, use model binding. We currently support binding of JSON, XML, YAML and standard form values (foo=bar\u0026boo=baz). Gin uses go-playground/validator/v10 for validation. Check the full docs on tags usage here. Note that you need to set the corresponding binding tag on all fields you want to bind. For example, when binding from JSON, set json:\"fieldname\". Also, Gin provides two sets of methods for binding: Type - Must bind Methods - Bind, BindJSON, BindXML, BindQuery, BindYAML Behavior - These methods use MustBindWith under the hood. If there is a binding error, the request is aborted with c.AbortWithError(400, err).SetType(ErrorTypeBind). This sets the response status code to 400 and the Content-Type header is set to text/plain; charset=utf-8. Note that if you try to set the response code after this, it will result in a warning [GIN-debug] [WARNING] Headers were already written. Wanted to override status code 400 with 422. If you wish to have greater control over the behavior, consider using the ShouldBind equivalent method. Type - Should bind Methods - ShouldBind, ShouldBindJSON, ShouldBindXML, ShouldBindQuery, ShouldBindYAML Behavior - These methods use ShouldBindWith under the hood. If there is a binding error, the error is returned and it is the developer’s responsibility to handle the request and error appropriately. When using the Bind-method, Gin tries to infer the binder depending on the Content-Type header. If you are sure what you are binding, you can use MustBindWith or ShouldBindWith. You can also specify that specific fields are required. If a field is decorated with binding:\"required\" and has an empty value when binding, an error will be returned. // Binding from JSON type Login struct { User string `form:\"user\" json:\"user\" xml:\"user\" binding:\"required\"` Password string `form:\"password\" json:\"password\" xml:\"password\" binding:\"required\"` } func main() { router := gin.Default() // Example for binding JSON ({\"user\": \"manu\", \"password\": \"123\"}) router.POST(\"/loginJSON\", func(c *gin.Context) { var json Login if err := c.ShouldBindJSON(\u0026json); err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } if json.User != \"manu\" || json.Password != \"123\" { c.JSON(http.StatusUnauthorized, gin.H{\"status\": \"unauthorized\"}) return } c.JSON(http.StatusOK, gin.H{\"status\": \"you are logged in\"}) }) // Example for binding XML ( // \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e // \u003croot\u003e // \u003cuser\u003emanu\u003c/user\u003e // \u003cpassword\u003e123\u003c/password\u003e // \u003c/root\u003e) router.POST(\"/loginXML\", func(c *gin.Context) { var xml Login if err := c.ShouldBindXML(\u0026xml); err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } if xml.User != \"manu\" || xml.Password != \"123\" { c.JSON(http.StatusUnauthorized, gin.H{\"status\": \"unauthorized\"}) return } c.JSON(http.StatusOK, gin.H{\"status\": \"you are logged in\"}) }) // Example for binding a HTML form (user=manu\u0026password=123) router.POST(\"/loginForm\", func(c *gin.Context) { var form Login // This will infer what binder to use depending on the content-type header. if err := c.ShouldBind(\u0026form); err != nil { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) return } if form.User != \"manu\" || form.Password != \"123\" { c.JSON(http.StatusUnauthorized, gin.H{\"status\": \"unauthorized\"}) return } c.JSON(http.StatusOK, gin.H{\"status\": \"you are logged in\"}) }) // Listen and serve on 0.0.0.0:8080 router.Run(\":8080\") } Sample request $ curl -v -X POST \\ http://localhost:8080/loginJSON \\ -H 'content-type: application/json' \\ -d '{ \"user\": \"manu\" }' \u003e POST /loginJSON HTTP/1.1 \u003e Host: localhost:8080 \u003e User-Agent: curl/7.51.0 \u003e Accept: */* \u003e content-type: application/json \u003e Content-Length: 18 \u003e * upload completely sent off: 18 out of 18 bytes \u003c HTTP/1.1 400 Bad Request \u003c Content-Type: application/json; charset=utf-8 \u003c Date: Fri, 04 Aug 2017 03:51:31 GMT \u003c Content-Length: 100 \u003c {\"error\":\"Key: 'Login.Password' Error:Field validation for ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:16","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Custom validators It is also possible to register custom validators. See the example code. package main import ( \"net/http\" \"time\" \"github.com/gin-gonic/gin\" \"github.com/gin-gonic/gin/binding\" \"github.com/go-playground/validator/v10\" ) // Booking contains binded and validated data. type Booking struct { CheckIn time.Time `form:\"check_in\" binding:\"required,bookabledate\" time_format:\"2006-01-02\"` CheckOut time.Time `form:\"check_out\" binding:\"required,gtfield=CheckIn,bookabledate\" time_format:\"2006-01-02\"` } var bookableDate validator.Func = func(fl validator.FieldLevel) bool { date, ok := fl.Field().Interface().(time.Time) if ok { today := time.Now() if today.After(date) { return false } } return true } func main() { route := gin.Default() if v, ok := binding.Validator.Engine().(*validator.Validate); ok { v.RegisterValidation(\"bookabledate\", bookableDate) } route.GET(\"/bookable\", getBookable) route.Run(\":8085\") } func getBookable(c *gin.Context) { var b Booking if err := c.ShouldBindWith(\u0026b, binding.Query); err == nil { c.JSON(http.StatusOK, gin.H{\"message\": \"Booking dates are valid!\"}) } else { c.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()}) } } $ curl \"localhost:8085/bookable?check_in=2118-04-16\u0026check_out=2118-04-17\" {\"message\":\"Booking dates are valid!\"} $ curl \"localhost:8085/bookable?check_in=2118-03-10\u0026check_out=2118-03-09\" {\"error\":\"Key: 'Booking.CheckOut' Error:Field validation for 'CheckOut' failed on the 'gtfield' tag\"} Struct level validations can also be registered this way. See the struct-lvl-validation example to learn more. ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:17","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Only bind query string ShouldBindQuery function only binds the query params and not the post data. See the detail information. package main import ( \"log\" \"github.com/gin-gonic/gin\" ) type Person struct { Name string `form:\"name\"` Address string `form:\"address\"` } func main() { route := gin.Default() route.Any(\"/testing\", startPage) route.Run(\":8085\") } func startPage(c *gin.Context) { var person Person if c.ShouldBindQuery(\u0026person) == nil { log.Println(\"====== Only Bind By Query String ======\") log.Println(person.Name) log.Println(person.Address) } c.String(200, \"Success\") } ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:18","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Bind query string or post data See the detail information. package main import ( \"log\" \"time\" \"github.com/gin-gonic/gin\" ) type Person struct { Name string `form:\"name\"` Address string `form:\"address\"` Birthday time.Time `form:\"birthday\" time_format:\"2006-01-02\" time_utc:\"1\"` } func main() { route := gin.Default() route.GET(\"/testing\", startPage) route.Run(\":8085\") } func startPage(c *gin.Context) { var person Person // If `GET`, only `Form` binding engine (`query`) used. // If `POST`, first checks the `content-type` for `JSON` or `XML`, then uses `Form` (`form-data`). // See more at https://github.com/gin-gonic/gin/blob/master/binding/binding.go#L48 if c.ShouldBind(\u0026person) == nil { log.Println(person.Name) log.Println(person.Address) log.Println(person.Birthday) } c.String(200, \"Success\") } Test it with: $ curl -X GET \"localhost:8085/testing?name=appleboy\u0026address=xyz\u0026birthday=1992-03-15\" ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:19","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Bind Uri See the detail information. package main import \"github.com/gin-gonic/gin\" type Person struct { ID string `uri:\"id\" binding:\"required,uuid\"` Name string `uri:\"name\" binding:\"required\"` } func main() { route := gin.Default() route.GET(\"/:name/:id\", func(c *gin.Context) { var person Person if err := c.ShouldBindUri(\u0026person); err != nil { c.JSON(400, gin.H{\"msg\": err}) return } c.JSON(200, gin.H{\"name\": person.Name, \"uuid\": person.ID}) }) route.Run(\":8088\") } Test it with: $ curl -v localhost:8088/thinkerou/987fbc97-4bed-5078-9f07-9141ba07c9f3 $ curl -v localhost:8088/thinkerou/not-uuid ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:20","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["Golang"],"content":"Bind Header package main import ( \"fmt\" \"github.com/gin-gonic/gin\" ) type testHeader struct { Rate int `header:\"Rate\"` Domain string `header:\"Domain\"` } func main() { r := gin.Default() r.GET(\"/\", func(c *gin.Context) { h := testHeader{} if err := c.ShouldBindHeader(\u0026h); err != nil { c.JSON(200, err) } fmt.Printf(\"%#v\\n\", h) c.JSON(200, gin.H{\"Rate\": h.Rate, \"Domain\": h.Domain}) }) r.Run() // client // curl -H \"rate:300\" -H \"domain:music\" 127.0.0.1:8080/ // output // {\"Domain\":\"music\",\"Rate\":300} // ","date":"2022-02-15","objectID":"/Notes/posts/golang/webbackend/gin/:4:21","tags":["后端","框架"],"title":"Go Gin","uri":"/Notes/posts/golang/webbackend/gin/"},{"categories":["数据库"],"content":"MongoDB ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:0:0","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"认识 MongoDB 是由 C++ 语言编写的，是一个基于分布式文件存储的开源数据库系统 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:1:0","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"一些概念 QL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接，MongoDB 不支持 primary key primary key 主键，MongoDB 自动将 _id 字段设置为主键 数据库 数据库名可以是满足以下条件的任意 UTF-8 字符串。 不能是空字符串 \"\" 不得含有 ’ ‘（空格)、.、$、/、\\和\\0 (空字符) 应全部小写 最多 64 字节 有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。 admin：从权限的角度来看，这是 “root” 数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。 local: 这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合 config: 当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片的相关信息。 文档 （Document） 文档是一组键值 (key-value) 对 (即 BSON)。MongoDB 的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是 MongoDB 非常突出的特点。 注意 文档中的键/值对是有序的。 文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。 MongoDB 区分类型和大小写。 文档不能有重复的键。 文档的键是字符串。除了少数例外情况，键可以使用任意 UTF-8 字符。 命名规范 键不能含有 \\0 (空字符)。这个字符用来表示键的结尾。 . 和 $ 有特别的意义，只有在特定环境下才能使用。 以下划线 _ 开头的键是保留的 (不严格要求)。 集合 （Collections） 集合就是 MongoDB 文档组，类似于 RDBMS （关系数据库管理系统：Relational Database Management System) 中的表格。 集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性 数据类型 数据类型 描述 String 字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。 Integer 整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。 Boolean 布尔值。用于存储布尔值（真/假）。 Double 双精度浮点值。用于存储浮点值。 Min/Max keys 将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。 Array 用于将数组或列表或多个值存储为一个键。 Timestamp 时间戳。记录文档修改或添加的具体时间。 Object 用于内嵌文档。 Null 用于创建空值。 Symbol 符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。 Date 日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。 Object ID 对象 ID。用于创建文档的 ID。 Binary Data 二进制数据。用于存储二进制数据。 Code 代码类型。用于在文档中存储 JavaScript 代码。 Regular expression 正则表达式类型。用于存储正则表达式。 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:1:1","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"Mongo Shell 常用命令 显示所有数据库 show dbs 显示当前数据库 db 连接到指定数据库 use DB_NAME ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:1:2","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"数据库 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:2:0","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"创建数据库 use DATABASE_NAME 在 MongoDB 中，集合只有在内容插入后才会创建! 也就是说，创建集合(数据表)后要再插入一个文档(记录)，集合才会真正创建。 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:2:1","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"删除数据库 必须先用 use 命令选择要删除的数据库 db.dropDatabase() 删除当前数据库，默认为 test ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:2:2","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"集合 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:3:0","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"创建集合 db.createCollection(name, options) name: 要创建的集合名称 options: 可选参数，指定有关内存大小及索引的选项 字段 类型 描述 capped 布尔 （可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。 当该值为 true 时，必须指定 size 参数。 autoIndexId 布尔 3.2 之后不再支持该参数。（可选）如为 true，自动在 _id 字段创建索引。默认为 false。 size 数值 （可选）为固定集合指定一个最大值，即字节数。 如果 capped 为 true，也需要指定该字段。 max 数值 （可选）指定固定集合中包含文档的最大数量。 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:3:1","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"删除 删除集合 必须要先用 use 命令选择待删除集合的数据库 db.collection.drop() 如 db.createCollection(\"mycol\") db.createCollection(\"mycol\", { capped : true, autoIndexId : true, size : 6142800, max : 10000 } ) 在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。 清空集合 db.collectionName.remove({}) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:3:2","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"查看现有集合 show collections ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:3:3","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"文档 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:4:0","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"插入 插入单个文档 db.collection.insertOne() 返回一个文档，其中包含新插入的文档的_id字段值 如果文档未指定 _id 字段，则 MongoDB 将具有 ObjectId 值的 _id 字段添加到新文档中 参数 writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。 例 db.inventory.insertOne( { item: \"canvas\", qty: 100, tags: [\"cotton\"], size: { h: 28, w: 35.5, uom: \"cm\" } } ) 插入多个文档 db.collection.insertMany() 参数 writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求。 ordered：指定是否按顺序写入，默认 true，按顺序写入。 例 db.inventory.insertMany([ { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], size: { h: 14, w: 21, uom: \"cm\" } }, { item: \"mat\", qty: 85, tags: [\"gray\"], size: { h: 27.9, w: 35.5, uom: \"cm\" } }, { item: \"mousepad\", qty: 25, tags: [\"gel\", \"blue\"], size: { h: 19, w: 22.85, uom: \"cm\" } } ]) 如果欲插入到的集合当前不存在，则插入操作将创建该集合。 ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:4:1","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"删除 db.collection.deleteMany() db.collection.deleteOne() 有例 db.inventory.insertMany( [ { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }, ] ); 删除所有文档 db.inventory.deleteMany({}) 删除符合条件的文档 指定标准或过滤器，以标识要删除的文档：使用 \u003cfield\u003e:\u003cvalue\u003e 表达式 以下示例从状态字段等于 “A” 的 inventory 集合中删除所有文档 db.inventory.deleteMany({ status : \"A\" }) 下面的示例删除状态为 “D” 的第一个文档 db.inventory.deleteOne( { status: \"D\" } ) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:4:2","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"查询 bd.collectionName.find(query, projection) query ：可选，使用查询操作符指定查询条件 projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值，只需省略该参数即可（默认省略） 若要以易读的方式读取数据，可以用 db.collectionName.find().pretty() 选择集合中的所有文档 将空文档作为查询过滤器参数传递给 find 方法 db.collectionName.find( {} ) 对应于 SELECT*FROMcollectionName 仅返回指定的字段（和_id字段） 将投影文档中的 \u003cfield\u003e 设置为 1 db.collectionName.find( { status: \"A\" }, { item: 1, status: 1 } ) 对应于 SELECT _id, item, status from collectionName WHERE status = \"A\" 若要禁止返回默认的 _id_，添加 _id: 0 db.collectionName.find( { status: \"A\" }, { item: 1, status: 1, _id: 0 } ) 返回除了被排除的字段之外的所有字段 db.collectionName.find( { status: \"A\" }, { status: 0, instock: 0 } ) 可以使用 projection 来排除特定的字段，而不是列出要在匹配的文档中返回的字段 条件操作符 操作 格式 范例 RDBMS中的类似语句 等于 {\u003ckey\u003e:\u003cvalue\u003e} db.col.find({\"name\":\"Loulou\"}) where by = 'name' 小于 {\u003ckey\u003e:{$lt:\u003cvalue\u003e}} db.col.find({\"likes\":{$lt:50}}) where likes \u003c 50 小于或等于 {\u003ckey\u003e:{$lte:\u003cvalue\u003e}} db.col.find({\"likes\":{$lte:50}}) where likes \u003c= 50 大于 {\u003ckey\u003e:{$gt:\u003cvalue\u003e}} db.col.find({\"likes\":{$gt:50}}) where likes \u003e 50 大于或等于 {\u003ckey\u003e:{$gte:\u003cvalue\u003e}} db.col.find({\"likes\":{$gte:50}}) where likes \u003e= 50 不等于 {\u003ckey\u003e:{$ne:\u003cvalue\u003e}} db.col.find({\"likes\":{$ne:50}}) where likes != 50 AND 条件：条件间以逗号隔开即可 OR 条件：使用关键字 $or 例子 db.inventory.find( { status: \"D\" } ) db.inventory.find( { status: { $in: [ \"A\", \"D\" ] } } ) db.inventory.find( { status: \"A\", qty: { $lt: 30 } } ) db.inventory.find( { $or: [ { status: \"A\" }, { qty: { $lt: 30 } } ] } ) db.inventory.find( { status: \"A\", $or: [ { qty: { $lt: 30 } }, { item: /^p/ } ] } ) $type 操作符 类型 数字 备注 Double 1 String 2 Object 3 Array 4 Binary data 5 Undefined 6 已废弃。 Object id 7 Boolean 8 Date 9 Null 10 Regular Expression 11 JavaScript 13 Symbol 14 JavaScript (with scope) 15 32-bit integer 16 Timestamp 17 64-bit integer 18 Min key 255 Query with -1. Max key 127 db.collection.find({\"title\" : {$type : 2}}) 查询数组 有例 db.inventory.insertMany([ { item: \"journal\", qty: 25, tags: [\"blank\", \"red\"], dim_cm: [ 14, 21 ] }, { item: \"notebook\", qty: 50, tags: [\"red\", \"blank\"], dim_cm: [ 14, 21 ] }, { item: \"paper\", qty: 100, tags: [\"red\", \"blank\", \"plain\"], dim_cm: [ 14, 21 ] }, { item: \"planner\", qty: 75, tags: [\"blank\", \"red\"], dim_cm: [ 22.85, 30 ] }, { item: \"postcard\", qty: 45, tags: [\"blue\"], dim_cm: [ 10, 15.25 ] } ]); 查询指定数组匹配的文档 使用查询文档 {\u003cfield\u003e：\u003cvalue\u003e}，其中 value 为要匹配的精确数组（元素顺序也要一致） db.inventory.find( { tags: [\"red\", \"blank\"] } ) 查询包含指定元素的数组匹配的文档 此时查询数组字段是否包含至少一个具有指定值的元素 db.inventory.find( { tags: \"red\" } ) db.inventory.find( { dim_cm: { $gt: 25 } } ) 查询包含指定元素集合的数组匹配的文档 使用 $all 运算符，此时无需考虑元素顺序 db.inventory.find( { tags: { $all: [\"red\", \"blank\"] } } ) 使用复合条件查询 下面的示例查询一个元素可以满足大于 15 的条件，而另一个元素可以满足小于 20 的条件，或者单个元素可以满足以下两个条件 db.inventory.find( { dim_cm: { $gt: 15, $lt: 20 } } ) 另外，使用 $elemMatch 运算符可在数组的元素上指定多个条件，以使至少一个数组元素满足所有指定的条件 以下示例查询在 dim_cm 数组中包含至少一个同时大于 22 和小于 30 的元素的文档 db.inventory.find( { dim_cm: { $elemMatch: { $gt: 22, $lt: 30 } } } ) 通过数组索引位置查询 使用点表示法 db.inventory.find( { \"dim_cm.1\": { $gt: 25 } } ) 使用点符号查询时，字段和嵌套字段必须在引号内 通过数组长度查询数组 使用 $size 运算符可按元素数量查询数组 db.inventory.find( { \"tags\": { $size: 3 } } ) 查询嵌入文档 有例 db.inventory.insertMany( [ { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"A\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" } ]); 精准查询 请使用查询筛选文档 {\u003cfield\u003e：\u003cvalue\u003e} 例如，以下查询选择字段大小等于文档 {h：14，w：21，uom：“ cm”} 的所有文档 db.inventory.find( { size: { h: 14, w: 21, uom: \"cm\" } } ) 部分查询 要在嵌套文档中的字段上指定查询条件，请使用点符号（“ field.nestedField”） 以下示例选择嵌套在 size 字段中的 uom 字段等于 “in” 的所有文档： db.inventory.find( { \"size.uom\": \"in\" } ) 使用点符号查询时，字段和嵌套字段必须在引号内 以下查询在 **size **字段中嵌入的字段 h 上使用小于运算符 db.inventory.find( { \"size.h\": { $lt: 15 } } ) 以下查询选择嵌套字段 h 小于 15，嵌套字段 uom 等于 “in”，状态字段等于 “D” 的所有文档 db.inventory.find( { \"size.h\": { $lt: 15 }, \"size.uom\": \"in\", status: \"D\" } ) 查询嵌入式文档数组 有","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:4:3","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"更新 db.collection.updateOne(\u003cfilter\u003e, \u003cupdate\u003e, \u003coptions\u003e`) db.collection.updateMany(\u003cfilter\u003e, \u003cupdate\u003e,\u003coptions\u003e`) db.collection.replaceOne(\u003cfilter\u003e, \u003cupdate\u003e, guo) 有例 db.inventory.insertMany( [ { item: \"canvas\", qty: 100, size: { h: 28, w: 35.5, uom: \"cm\" }, status: \"A\" }, { item: \"journal\", qty: 25, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"mat\", qty: 85, size: { h: 27.9, w: 35.5, uom: \"cm\" }, status: \"A\" }, { item: \"mousepad\", qty: 25, size: { h: 19, w: 22.85, uom: \"cm\" }, status: \"P\" }, { item: \"notebook\", qty: 50, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"P\" }, { item: \"paper\", qty: 100, size: { h: 8.5, w: 11, uom: \"in\" }, status: \"D\" }, { item: \"planner\", qty: 75, size: { h: 22.85, w: 30, uom: \"cm\" }, status: \"D\" }, { item: \"postcard\", qty: 45, size: { h: 10, w: 15.25, uom: \"cm\" }, status: \"A\" }, { item: \"sketchbook\", qty: 80, size: { h: 14, w: 21, uom: \"cm\" }, status: \"A\" }, { item: \"sketch pad\", qty: 95, size: { h: 22.85, w: 30.5, uom: \"cm\" }, status: \"A\" } ] ); 更新单个文档 db.inventory.updateOne() 下面的示例下面的示例在 inventory 集合上更新项目等于 “paper” 的第一个文档 使用 $set 运算符将 size.uom 字段的值更新为 “cm”，将状态字段的值更新为 “P”， 使用 $currentDate 运算符将 lastModified 字段的值更新为当前日期。 如果 lastModified 字段不存在，则 $currentDate 将创建该字段。 db.inventory.updateOne( { item: \"paper\" }, { $set: { \"size.uom\": \"cm\", status: \"P\" }, $currentDate: { lastModified: true } } ) 更新多个文档 db.inventory.updateMany() 以下示例更新数量小于 50 的所有文档 db.inventory.updateMany( { \"qty\": { $lt: 50 } }, { $set: { \"size.uom\": \"in\", status: \"P\" }, $currentDate: { lastModified: true } } ) 更换整个文档 要替换 _id 字段以外的文档的全部内容，将一个全新的文档作为第二参数传递给 db.collection.replaceOne() 当替换一个文档时，替换文档必须只包含字段 / 值对，即不包括更新操作符表达式 下面的示例替换了 inventory 集合中的第一个文件，其中项为 “paper”: db.inventory.replaceOne( { item: \"paper\" }, { item: \"paper\", instock: [ { warehouse: \"A\", qty: 60 }, { warehouse: \"B\", qty: 40 } ] } ) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:4:4","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"PyMongo ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:0","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"连接 连接数据库 import pymongo client = pymongo.MongoClient(host='localhost', port=27017) # or client = pymongo.MongoClient('mongodb://localhost:27017/') 有密码连接 import pymongo mongo_client = pymongo.MongoClient('127.0.0.1', 26666) mongo_auth = mongo_client.admin # admin 为 authenticationDatabase # or mongo_client['admin'] mongo_auth.authenticate('username', 'password') 判断是否连接成功： print(mongo_client.server_info()) # 判断是否连接成功 获取 Database 和 Collection 如果没有会自动创建 mongo_db = mongo_client['db_name'] mongo_collection = mongo_db['your_collection'] # or mongo_db = mongo_client.db_name mongo_collection = mongo_db.your_collection ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:1","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"插入 插入单条数据 insert_one() import datetime info = { 'name' : 'Zarten', 'text' : 'Inserting a Document', 'tags' : ['a', 'b', 'c'], 'date' : datetime.datetime.now() } mongo_collection.insert_one(info) 插入多条数据 insert_many() import datetime info_1 = { 'name' : 'Zarten_1', 'text' : 'Inserting a Document', 'tags' : ['a', 'b', 'c'], 'date' : datetime.datetime.now() } info_2 = { 'name' : 'Zarten_2', 'text' : 'Inserting a Document', 'tags' : [1, 2, 3], 'date' : datetime.datetime.now() } insert_list = [info_1, info_2] mongo_collection.insert_many(insert_list) 插入字符串时间时，mongodb 自动将其转成了 ISOdate 类型，若需要时间在 mongdb 也是字符串类型，只需这样操作即可： datetime.datetime.now().isoformat() ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:2","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"删除 删除单条数据 delete_one() 若删除条件相同匹配到多条数据，默认删除第一条 mongo_collection.delete_one({'text' : 'a'}) 删除多条数据 delete_many() 删除满足条件的所有数据 mongo_collection.delete_many({'text' : 'a'}) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:3","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"更新 更新单条数据 update_one(filter,update,upsert=False) 更新满足条件的第一条数据 filter：更新的条件 update ： 更新的内容，必须用 $ 操作符 upsert ： 默认 False。若为 True，更新条件没找到的情况会插入更新的内容 info = { 'name': '桃子 ', 'text': 'peach', 'tags': [1, 2, 3], 'date': datetime.datetime.now() } update_condition = {'name' : 'Zarten_2'} # 更新的条件，也可以为多个条件 # 更新条件多个时，需要同时满足时才会更新 # update_condition = {'name' : 'Pear', # 'text' : '梨子'} mongo_collection.update_one(update_condition, {'$set' : info}) 更新多条数据 update_many(filter,update,upsert=False) filter：更新的条件 update ： 更新的内容，必须用 $ 操作符 upsert ： 默认 False。若为 True，更新条件没找到的情况会插入更新的内容 info = { 'name': 'Zarten', 'text': 'a', 'tags': [1, 2, 3], 'date': datetime.datetime.now() } update_condition = {'text' : 'a'} # 更新的条件 # 更新条件多个时，需要同时满足时才会更新 # update_condition = {'name' : 'Pear', # 'text' : '梨子'} mongo_collection.update_many(update_condition, {'$set' : info}) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:4","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"查询 查询一条数据 find_one() 匹配第一条满足的条件的结果，这条结果以 dict 字典形式返回，若没有查询到，则返回 None find_condition = { 'name' : 'Banana', 'text' : 'peach' } find_result = mongo_collection.find_one(find_condition) 可以通过 projection 参数来指定需要查询的字段，包括是否显示 _id find_condition = { 'name' : 'Zarten_3', } select_item = mongo_collection.find_one(find_condition, projection= {'_id':False, 'name':True, 'num':True}) print(select_item) 可以指定查询范围 import datetime find_condition = { 'date' : {'$gte':datetime.datetime(2018,12,1), '$lt':datetime.datetime(2018,12,3)} } select_item = mongo_collection.find_one(find_condition) print(select_item) 查询多条数据 find() 返回满足条件的所有结果，返回类型为 Cursor ，通过迭代获取每个查询结果，每个结果类型为 dict 字典 find_condition = { 'name' : 'Banana', 'text' : '香蕉' } find_result_cursor = mongo_collection.find(find_condition) for find_result in find_result_cursor: print(find_result) 插入文档时会返回一个 _id ，是 ObjectId 类型，可以通过它来查询 若 _id 提供的是 str 类型的，我们需要转成 ObjectId 类型 from bson.objectid import ObjectId query_id_str = '5c00f60b20b531196c02d657' find_condition = { '_id' : ObjectId(query_id_str), } find_result = mongo_collection.find_one(find_condition) print(find_result) 查询一条数据同时删除 find_one_and_delete( filter,projection=None,sort=None ) filter：查询条件 projection：选择返回和不返回的字段 sort：list 类型，当查询匹配到多条数据时，根据某个条件排序，函数返回时返回第一条数据 以字典形式返回被删除的信息 find_condition = { 'name' : 'Banana', } deleted_item = mongo_collection.find_one_and_delete(find_condition) print(deleted_item) 有选择地返回某条数据 find_condition = { 'name' : 'Zarten_2', } deleted_item = mongo_collection.find_one_and_delete(find_condition, sort= [('num', pymongo.DESCENDING)]) print(deleted_item) 排序 find().sort().skip().limit() 直接调用 sort() 方法，并在其中传入排序的字段及升降序标志 results = collection.find().sort('name', pymongo.ASCENDING) print([result['name'] for result in results]) # 偏移2，即忽略前两个元素，得到第三个及以后的元素 results = collection.find().sort('name', pymongo.ASCENDING).skip(2) print([result['name'] for result in results]) # 用limit()方法指定要取的结果个数 results = collection.find().sort('name', pymongo.ASCENDING).skip(2).limit(2) print([result['name'] for result in results]) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:5","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"其他操作 计数 count_documents() find_condition = { 'name' : 'Zarten_1' } select_count = mongo_collection.count_documents(find_condition) print(select_count) 获取索引信息 list_indexes() index_information() # list_indexs = mongo_collection.list_indexes() # for index in list_indexs: # print(index) index_info = mongo_collection.index_information() print(index_info) 删除集合 mongo_collection.drop() 查看数据库下的所有集合名 db.collection_names() ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:6","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"常用操作 根据 _id 查询数据插入时间排序 col.find().sort('_id',-1) # 根据插入时间降序 根据 _id 查询某个日期插入的数据 # 查询今天插入的所有数据 import datetime from bson.objectid import ObjectId today_zero = datetime.datetime.strptime(datetime.datetime.now().strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\") dummy_id = ObjectId.from_datetime(today_zero) results = col.find({\"_id\": {\"$gte\": dummy_id}}).limit(10) for result in results: print(result) # 查询15天前的那天日期的所有插入数据 import datetime from bson.objectid import ObjectId start_day_time = datetime.datetime.today() - datetime.timedelta(15) end_day_time = datetime.datetime.today() - datetime.timedelta(14) start_day_zero = datetime.datetime.strptime(start_day_time.strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\") end_day_zero = datetime.datetime.strptime(end_day_time.strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\") start_dummy_id = ObjectId.from_datetime(start_day_zero) end_dummy_id = ObjectId.from_datetime(end_day_zero) results_count = col.find({\"_id\": {\"$gte\": start_dummy_id,\"$lte\":end_dummy_id}}).count() print(results_count) # 查询昨天插入数据 start_day_time = datetime.datetime.today() - datetime.timedelta(1) end_day_time = datetime.datetime.today() - datetime.timedelta(0) start_day_zero = datetime.datetime.strptime(start_day_time.strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\") end_day_zero = datetime.datetime.strptime(end_day_time.strftime(\"%Y-%m-%d\"), \"%Y-%m-%d\") start_dummy_id = ObjectId.from_datetime(start_day_zero) end_dummy_id = ObjectId.from_datetime(end_day_zero) results_count = col.find({\"_id\": {\"$gte\": start_dummy_id,\"$lte\":end_dummy_id}}).count() print(results_count) ","date":"2021-10-23","objectID":"/Notes/posts/database/mongodb/:5:7","tags":["数据库","快速入门"],"title":"MongoDB","uri":"/Notes/posts/database/mongodb/"},{"categories":["数据库"],"content":"SQLite ","date":"2021-10-23","objectID":"/Notes/posts/database/sqlite/:0:0","tags":["数据库","快速入门"],"title":"SQLite","uri":"/Notes/posts/database/sqlite/"},{"categories":["数据库"],"content":"认识 SQLite 是一个进程内的库，实现了自给自足的、无服务器的、零配置的、事务性的 SQL 数据库引擎。 就像其他数据库，SQLite 引擎不是一个独立的进程，且可以按应用程序需求进行静态或动态连接。SQLite 直接访问其存储文件。 ","date":"2021-10-23","objectID":"/Notes/posts/database/sqlite/:1:0","tags":["数据库","快速入门"],"title":"SQLite","uri":"/Notes/posts/database/sqlite/"},{"categories":["数据库"],"content":"特性 不需要一个单独的服务器进程或操作的系统（无服务器的）。 不需要配置，这意味着不需要安装或管理。 一个完整的 SQLite 数据库是存储在一个单一的跨平台的磁盘文件。 SQLite 是非常小的，是轻量级的，完全配置时小于 400KiB，省略可选功能配置时小于250KiB。 SQLite 是自给自足的，这意味着不需要任何外部的依赖。 SQLite 事务是完全兼容 ACID 的，允许从多个进程或线程安全访问。 SQLite 支持 SQL92（SQL2）标准的大多数查询语言的功能。 SQLite 使用 ANSI-C 编写的，并提供了简单和易于使用的 API。 SQLite 可在 UNIX（Linux, Mac OS-X, Android, iOS）和 Windows（Win32, WinCE, WinRT）中运行。 ","date":"2021-10-23","objectID":"/Notes/posts/database/sqlite/:1:1","tags":["数据库","快速入门"],"title":"SQLite","uri":"/Notes/posts/database/sqlite/"},{"categories":["数据库"],"content":"命令 与关系数据库进行交互的标准 SQLite 命令类似于 SQL。命令包括 CREATE、SELECT、INSERT、UPDATE、DELETE 和 DROP。这些命令基于它们的操作性质可分为以下几种： DDL - 数据定义语言 命令 描述 CREATE 创建一个新的表，一个表的视图，或者数据库中的其他对象。 ALTER 修改数据库中的某个已有的数据库对象，比如一个表。 DROP 删除整个表，或者表的视图，或者数据库中的其他对象。 DML - 数据操作语言 命令 描述 INSERT 创建一条记录。 UPDATE 修改记录。 DELETE 删除记录。 DQL - 数据查询语言 命令 描述 SELECT 从一个或多个表中检索某些记录。 ","date":"2021-10-23","objectID":"/Notes/posts/database/sqlite/:1:2","tags":["数据库","快速入门"],"title":"SQLite","uri":"/Notes/posts/database/sqlite/"},{"categories":["CPP"],"content":"STL ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:0:0","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["CPP"],"content":"list ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:1:0","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["CPP"],"content":"概述 list 由双向链表（doubly linked list）实现而成，元素也存放在堆中，每个元素都是放在一块内存中，他的内存空间可以是不连续的，通过指针来进行数据的访问，这个特点使得它的随机存取变得非常没有效率，因此它没有提供 [] 操作符的重载。但是由于链表的特点，它可以很有效率的支持任意地方的插入和删除操作。 ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:1:1","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["CPP"],"content":"定义及初始化 使用之前必须加相应容器的头文件： #include \u003clist\u003e // list属于std命名域的，因此需要通过命名限定，例如using std::list; 定义的代码如下： list\u003cint\u003e a; // 定义一个int类型的列表a list\u003cint\u003e a(10); // 定义一个int类型的列表a，并设置初始大小为10 list\u003cint\u003e a(10, 1); // 定义一个int类型的列表a，并设置初始大小为10且初始值都为1 list\u003cint\u003e b(a); // 定义并用列表a初始化列表b deque\u003cint\u003e b(a.begin(), ++a.end()); // 将列表a中的第1个元素作为列表b的初始值 除此之外，还可以直接使用数组来初始化向量： int n[] = { 1, 2, 3, 4, 5 }; list\u003cint\u003e a(n, n + 5); // 将数组n的前5个元素作为列表a的初值 ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:1:2","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["CPP"],"content":"基本操作 容量函数 容器大小：lst.size(); 容器最大容量：lst.max_size(); 更改容器大小：lst.resize(); 容器判空：lst.empty(); #include \u003ciostream\u003e#include \u003clist\u003e using namespace std; int main(int argc, char* argv[]) { list\u003cint\u003e lst; for (int i = 0; i\u003c6; i++) { lst.push_back(i); } cout \u003c\u003c lst.size() \u003c\u003c endl; // 输出：6 cout \u003c\u003c lst.max_size() \u003c\u003c endl; // 输出：357913941 lst.resize(0); // 更改元素大小 cout \u003c\u003c lst.size() \u003c\u003c endl; // 输出：0 if (lst.empty()) cout \u003c\u003c \"元素为空\" \u003c\u003c endl; // 输出：元素为空 return 0; } 添加函数 头部添加元素：lst.push_front(const T\u0026 x); 末尾添加元素：lst.push_back(const T\u0026 x); 任意位置插入一个元素：lst.insert(iterator it, const T\u0026 x); 任意位置插入 n 个相同元素：lst.insert(iterator it, int n, const T\u0026 x); 插入另一个向量的 [forst,last] 间的数据：lst.insert(iterator it, iterator first, iterator last); #include \u003ciostream\u003e#include \u003clist\u003e using namespace std; int main(int argc, char* argv[]) { list\u003cint\u003e lst; // 头部增加元素 lst.push_front(4); // 末尾添加元素 lst.push_back(5); // 任意位置插入一个元素 list\u003cint\u003e::iterator it = lst.begin(); lst.insert(it, 2); // 任意位置插入n个相同元素 lst.insert(lst.begin(), 3, 9); // 插入另一个向量的[forst,last]间的数据 list\u003cint\u003e lst2(5, 8); lst.insert(lst.begin(), lst2.begin(), ++lst2.begin()); // 遍历显示 for (it = lst.begin(); it != lst.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：8 9 9 9 2 4 5 cout \u003c\u003c endl; return 0; } 删除函数 头部删除元素：lst.pop_front(); 末尾删除元素：lst.pop_back(); 任意位置删除一个元素：lst.erase(iterator it); 删除 [first,last] 之间的元素：lst.erase(iterator first, iterator last); 清空所有元素：lst.clear(); #include \u003ciostream\u003e#include \u003clist\u003e using namespace std; int main(int argc, char* argv[]) { list\u003cint\u003e lst; for (int i = 0; i \u003c 8; i++) lst.push_back(i); // 头部删除元素 lst.pop_front(); // 末尾删除元素 lst.pop_back(); // 任意位置删除一个元素 list\u003cint\u003e::iterator it = lst.begin(); lst.erase(it); // 删除[first,last]之间的元素 lst.erase(lst.begin(), ++lst.begin()); // 遍历显示 for (it = lst.begin(); it != lst.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：3 4 5 6 cout \u003c\u003c endl; // 清空所有元素 lst.clear(); // 判断list是否为空 if (lst.empty()) cout \u003c\u003c \"元素为空\" \u003c\u003c endl; // 输出：元素为空 return 0; } 访问函数 访问第一个元素：lst.front(); 访问最后一个元素：lst.back(); #include \u003ciostream\u003e#include \u003clist\u003e using namespace std; int main(int argc, char* argv[]) { list\u003cint\u003e lst; for (int i = 0; i \u003c 6; i++) lst.push_back(i); // 访问第一个元素 cout \u003c\u003c lst.front() \u003c\u003c endl; // 输出：0 // 访问最后一个元素 cout \u003c\u003c lst.back() \u003c\u003c endl; // 输出：5 return 0; } 其他函数 多个元素赋值：lst.assign(int nSize, const T\u0026 x); // 类似于初始化时用数组进行赋值 交换两个同类型容器的元素：swap(list\u0026, list\u0026); 或 lst.swap(list\u0026); 合并两个列表的元素（默认升序排列）：lst.merge(); 在任意位置拼接入另一个list：lst.splice(iterator it, list\u0026); 删除容器中相邻的重复元素：lst.unique(); #include \u003ciostream\u003e#include \u003clist\u003e using namespace std; int main(int argc, char* argv[]) { // 多个元素赋值s list\u003cint\u003e lst1; lst1.assign(3, 1); list\u003cint\u003e lst2; lst2.assign(3, 2); // 交换两个容器的元素 // swap(lst1, lst2); // ok lst1.swap(lst2); // 遍历显示 cout \u003c\u003c \"交换后的lst1: \"; list\u003cint\u003e::iterator it; for (it = lst1.begin(); it!=lst1.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：2 2 2 cout \u003c\u003c endl; // 遍历显示 cout \u003c\u003c \"交换后的lst2: \"; for (it = lst2.begin(); it != lst2.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：1 1 1 cout \u003c\u003c endl; list\u003cint\u003e lst3; lst3.assign(3, 3); list\u003cint\u003e lst4; lst4.assign(3, 4); // 合并两个列表的元素 lst4.merge(lst3); // 不是简单的拼接，而是会升序排列 cout \u003c\u003c \"合并后的lst4: \"; for (it = lst4.begin(); it != lst4.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：3 3 3 4 4 4 cout \u003c\u003c endl; list\u003cint\u003e lst5; lst5.assign(3, 5); list\u003cint\u003e lst6; lst6.assign(3, 6); // 在lst6的第2个元素处，拼接入lst5 lst6.splice(++lst6.begin(), lst5); cout \u003c\u003c \"拼接后的lst6: \"; for (it = lst6.begin(); it != lst6.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：6 5 5 5 6 6 cout \u003c\u003c endl; // 删除容器中相邻的重复元素 list\u003cint\u003e lst7; lst7.push_back(1); lst7.push_back(1); lst7.push_back(2); lst7.push_back(2); lst7.push_back(3); lst7.push_back(2); lst7.unique(); cout \u003c\u003c \"删除容器中相邻的重复元素后的lst7: \"; for (it = lst7.begin(); it != lst7.end(); it++) cout \u003c\u003c *it \u003c\u003c \" \"; // 输出：1 2 3 2 cout \u003c\u003c endl; return 0; } 回到顶部 ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:1:3","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["CPP"],"content":"迭代器与算法 1. 迭代器 开始迭代器指针：lst.begin(); 末尾迭代器指针：lst.end(); // 指向最后一个元素的下一个位置 指向常量的开始迭代器指针：lst.cbegin(); // 意思就是不能通过这个指针来修改所指的内容，但还是可以通过其他方式修改的，而且指针也是可以移动的。 指向常量的末尾迭代器指针：lst.cend(); 反向迭代器指针，指向最后一个元素：lst.rbegin(); 反向迭代器指针，指向第一个元素的前一个元素：lst.rend(); #include \u003ciostream\u003e#include \u003clist\u003e using namespace std; int main(int argc, char* argv[]) { list\u003cint\u003e lst; lst.push_back(1); lst.push_back(2); lst.push_back(3); cout \u003c\u003c *(lst.begin()) \u003c\u003c endl; // 输出：1 cout \u003c\u003c *(--lst.end()) \u003c\u003c endl; // 输出：3 cout \u003c\u003c *(lst.cbegin()) \u003c\u003c endl; // 输出：1 cout \u003c\u003c *(--lst.cend()) \u003c\u003c endl; // 输出：3 cout \u003c\u003c *(lst.rbegin()) \u003c\u003c endl; // 输出：3 cout \u003c\u003c *(--lst.rend()) \u003c\u003c endl; // 输出：1 cout \u003c\u003c endl; return 0; } 2. 算法 遍历元素 list\u003cint\u003e::iterator it; for (it = lst.begin(); it != lst.end(); it++) cout \u003c\u003c *it \u003c\u003c endl; 元素翻转 #include \u003calgorithm\u003ereverse(lst.begin(), lst.end()); 元素排序 #include \u003calgorithm\u003esort(lst.begin(), lst.end()); // 采用的是从小到大的排序 // 如果想从大到小排序，可以采用先排序后反转的方式，也可以采用下面方法: // 自定义从大到小的比较器，用来改变排序方式 bool Comp(const int\u0026 a, const int\u0026 b) { return a \u003e b; } sort(lst.begin(), lst.end(), Comp); ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:1:4","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["CPP"],"content":"总结 可以看到，list 与 vector、deque 的用法基本一致，除了以下几处不同： list 为双向迭代器，故不支持it+=i； list 不支持下标访问和at方法访问。 ","date":"2022-01-25","objectID":"/Notes/posts/cpp/stl/:1:5","tags":["C++"],"title":"STL","uri":"/Notes/posts/cpp/stl/"},{"categories":["专业课"],"content":"数字图像处理 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:0:0","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":["专业课"],"content":"数字图像基础 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:1:0","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":["专业课"],"content":"图像取样和量化 概念 一幅图像的 x 和 y 坐标及幅度可能都是连续的。为将它转换为数字形式，必须对坐标和幅度都进行取样操作。 对坐标值进行数字化称为取样 对幅值（灰度值）数字化称为量化 数字图像表示 令 f(s, t) 表示一幅具有两个连续变量 s 和 t 的连续图像函数。 通过取样和量化，可以把该函数转换为数字图像。 假设把这幅连续图像取样为一个二维阵列 f(x, y) ，其中 (x, y) 是离散坐标。 通常，图像在任何坐标 (x, y) 处的值记为 f(x, y)，其中 x 和 y 都是整数。 由一幅图像的坐标张成的实平面部分称为空间域，x 和 y 称为空间变量或空间坐标。 f(x, y) 的表示方法 图像显示（如图 b）允许我们快速地观察结果。数值阵列（如图 c）用于处理和算法开发 数字图像的原点位于左上角，其中正 x 轴向下延伸，正 y 轴向右延申 一些规定 M 和 N（行和列）规定为整数 灰度级数通常取为 2 的整数次幂 $$ L=2^k $$ 多数情形下，灰度值都会被缩放到用于图像存储和显示的整数区间 [0, L-1] 动态范围 灰度跨越的值域被称为动态范围（这里，将图像系统的动态范围定义为系统中最大可度量灰度与最小可检测灰度之比） 动态范围上限取决于饱和度，下限取决于噪声。基本上，动态范围由系统能表示的最低和最高灰度级来确定 将一幅图像中最高和最低灰度级间的灰度差定义为对比度。当一幅图像中像素可感知的数值具有高动态范围时，那么我们认为该图像具有高对比度。 存储数字图像所需的比特数 b 为 $$ b=M\\times N\\times k $$ 当一幅图像有 2^k^ 个灰度级时，实际上通常称该图像为一幅 “k 比特图像”。例如，有 256 个可能的离散灰度值的图像称为 8 比特图像 空间分辨率 空间分辨率是图像中可辩别的最小细节的度量。在数量上，空间分辨率可以有很多方法来说明，其中单位距离的线对数和单位距离的点数（像素数） 是最通用的度量 灰度分辨率 类似地，灰度分辨率是指在灰度级中可分辨的最小变化，是主观指标 数字图像的平滑区域中的灰度级数不足引起的轮廓形状常称为伪轮廓 伪轮廓通常在以 16 或更少级数均匀设置的灰度级显示的图像中十分明显。 例如：当原图的灰度级是 256 时，两个位置的像素值只差 1 ， 则在图像显示上不会有太大的差异，依旧观察不出来；但是当灰度级变为 8 时，两个位置的像素值相差 1 ，则会有明显的差异，因此也就产生了伪轮廓 放大和收缩数字图像 采用复制行/列可以实现整数倍的放大图像，采用删除行/列可以实现整数倍的缩小图像，但两种方法都无法实现任意倍数和任意位置的放大和缩小图像 步骤 计算新的像素在原图的对应位置； 为这些对应位置赋灰度值。 计算新像素在原图的对应位置 f(x,y) 表示输出图像，g(u,v) 表示输入图像。几何运算（图像的放大或缩小也是图像的几何运算）可定义为： 如果令：$u_0 = a(x,y) = x$; $v_0 = b(x,y) = y$ 那么仅仅是把 g 拷贝到 f 而不加任何改动的恒等运算。 如果令：$u_0 = a(x,y) = x + x_0$; $v_0 = b(x,y) = y + y_0$ 那么得到平移运算，其中点 (x~0~,y~0~) 被平移到原点 如果令：$u_0 = a(x,y) = x/c$; $v_0 = b(x,y) = y/d$ 那么会使图像在 x 轴方向放大 c 倍，在 y 轴放大 d 倍。 例如：将一幅 200x200 的图像 g(u,v) 放大 1.5 倍，那么将得到 300x300 的新图像 f(x,y)。 产生新图像的过程，实际就是为 300x300 的像素赋值的过程。 假如为 f(150,150) 赋值 $f(150,150) = g(150/1.5,150/1.5) = g(100,100)$; 假如为 f(100,100) 赋值 $f(100,100) = g(100/1.5,100/1.5) = g(66.7,66.7)$ 由于图像像素都是在整数坐标中，所以没有坐标值为 (66.7,66.7) 的像素。所以要采用插值的方法给其赋值。 为这些对应位置赋灰度值 因为 (u~0~, v~0~) 不一定要在坐标点上，故需要插值求 g(u~0~, v~0~)； 最近邻内插 取点 (u~0~, v~0~) 最近的整数坐标 (u, v)。在上述例子中，为了求 (66.7, 66.7) 的灰度值，则用 (67, 67) 的灰度值来做插值 双线性插值 根据四个邻点的灰度值通过插值计算 g(u~0~, v~0~) 更多邻点的内插 更高次内插，这种方法往往能取得更为精确的结果，但是相应的计算量也会更大） 图像内插 我他妈也不知道到底考不考 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:1:1","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":["专业课"],"content":"像素间的一些基本关系 相邻像素 p 的水平垂直相邻像素，称为 p 的 4 邻域，记为 N~4~(p) p 的 4 个对角邻像素，称为 p 的 D 邻域，记为 N~D~(p) 4 邻域和 D 邻域合在一起称为 p 的 8 邻域，记为 N~8~(p) 邻接性 令 V 是用于定义邻接性的灰度值集合，V 中可能定义了很多灰度值，例如，在灰度值范围为 0 到 255 的邻接像素中，集合 V 可能是这 256 个值的任何一个子集。考虑三种类型的邻接： 4 邻接：如果 q 在 N~4~(p) 集中，具有 V 中数值的两个像素 p 和 q 是 4 邻接的 8 邻接：如果 q 在 N~8~(p) 集中，具有 V 中数值的两个像素 p 和 q 是 8 邻接的 m 邻接（混合邻接）：有两种情况 q 在 N~4~(p) 中， q 在 N~D~(p) 中且集合 N~4~(p) ∩ N~4~(q) 中没有 V 值的像素， 混合邻接是 8 邻接的改进。混合邻接的引入是为了消除 8 邻接常常发生的二义性。 连通性 通路 从具有坐标 (x, y) 的像素 p 到具有坐标 (s, t) 的像素 q 的 通路（或曲线） 是特定的像素序列，通路上任意相邻的两个像素点满足某种邻接性 连通、连通分量和连通集 令 S 是图像中的一个像素子集。如果在 S 中，p 和 q 之间存在一个全部由 S 中的元素组成的通路 则可以说两个像素 p 和 q 在 S 中是连通的 对于 S 中的任何像素 p，S 中连通到该像素的像素集叫做 S 的连通分量 如果 S 仅有一个连通分量，则集合 S 叫做连通集 区域 令 R 是图像中的一个像素子集。 如果 R 是连通集，则称 R 为一个区域 两个区域，如果它们联合形成一个连通集，则区域 Ri 和 Rj 称为邻接区域，不邻接的区域称为 不连接区域 一个区域 R 的边界（也称为边缘或轮廓）是区域中像素的集合，该区域有一个或多个不在 R 中的邻点 前景和背景 假设一幅图像包含有 K 个不连接的区域，即 R~k~，k = 1, 2, ··· , K ，且它们都不接触图像的边界。令 R~u~ 代表所有 K 个区域的并集，并且令 (R~u~)^c^ 代表其补集（集合 S 的补集是不在 S 中的点的集合）。我们称 R~u~ 中的所有点为图像的前景，而称 (R~u~)^c^ 中的所有点为图像的背景 距离 欧几里得（欧式）距离 p 和 q 间的欧几里得（欧式）距离定义如下： $$ D_e(p,q)=[(x−s)^2+(y−t)^2]^{\\frac{1}{2}} $$ 对于距离度量，距点 (x, y) 的距离 D~e~ 小于等于某个值 r 的像素，是中心在 (x, y) 且半径为 r 的圆平面 D~4~ 距离 又叫城市街区距离（曼哈顿距离） p 和 q 间的 D~4~ 距离定义如下： $$ D_4(p,q)=|x-s|+|y-t| $$ 此情况下，距 (x, y) 的距离 D~4~ 小于等于某个值 r 的像素形成一个中心在 (x, y) 的菱形。 其中 D~4~ = 1 的像素是 (x, y) 的 4 邻域。 D~8~ 距离 又叫棋盘距离（切比雪夫距离） p 和 q 间的 D~8~ 距离定义如下： $$ D_8(p,q)=max(|x-s|,|y-t|) $$ 此情况下，距 (x, y) 的 D8 距离小于等于某个值 r 的像素形成中心在 (x, y) 的 方形 其中 D~8~ = 1 的像素是 (x, y) 的 8 邻域。 D~m~ 距离 p 和 q 间的距离 D~m~ 定义为最短 m 通路的长度 注意，p 和 q 之间的 D~4~ 距离和 D~8~ 距离与任何通路无关。 例题  如下图所示，对于 V={1}，求像素点 p 和像素点 q 的城市街区距离、棋盘距离和 D~m~ 距离 由于 D~4~ 距离和 D~8~ 距离与任何通路无关，所以： $$ D_4(p, q) = |x - s| + |y - t| = 2 + 3 = 5 \\ D_8(p, q) = max(|x - s|, |y - t|) = max(2, 3) = 3 $$ 求 D~m~ 距离首先要找到像素点 p 和像素点 q 之间的一条 m 通路，如图中虚线所示： 故 D~m~(p, q) = 4 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:1:2","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":["专业课"],"content":"灰度变换与空间滤波 术语空间域指图像平面本身，这类图像处理方法直接操作图像中的像素。 变换域的图像处理首先把一幅图像变换到变换域，在变换域中进行处理，然后通过反变换把处理结果返回到空间域。 空间域处理主要分为灰度变换和空间滤波两类。 灰度变换对图像的单个像素进行操作，主要以对比度和阈值处理为目的。 空间滤波涉及改善性能的操作，如通过图像中每个像素的邻域处理来锐化图像 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:2:0","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":["专业课"],"content":"背景知识 空间域是包含图像像素的简单平面。空间域技术直接操作图像的像素。 例如，频率域的操作在图像的傅里叶变换上执行，而不是在图像本身上执行。 通常，空间域技术在计算上更有效，且执行所需的处理资源较少。 空间域处理 可由下式表示： $$ g(x, y) = T[f(x,y)] $$ 式中，f(x, y) 是输入图像，g(x, y) 是处理后的图像，T 是在点 (x, y) 的邻域上定义的关于 f 的一种算子。 算子可以应用于单幅图像或图像集合。邻域一般选择矩形邻域，这样更方便计算机实现。 空间滤波 邻域原点从一个像素向另一个像素移动，对邻域中的像素应用算子 T ，并在该位置产生输出。 这样，对于任意指定的位置 (x, y) ：图像 g 在这些坐标处的值，等于对 f 中以 (x, y) 为原点的邻域应用算子 T 的结果。 例如，假如该邻域是大小为 3 × 3 的正方形，算子 T 定义为 “计算该邻域的平均灰度”。 考虑图像中的任意位置，譬如 (100, 150)。 假设该邻域的原点位于其中心处，则在该位置的结果 g(100, 150) 是计算 f(100, 150) 和其 8 个邻点的和，再除以 9（即由邻域包围的像素灰度的平均值） 然后，邻域原点移到下一个位置，并重复前面的过程，产生下一个输出图像 g 的值。 该处理通常从输入图像的左上角开始，以水平扫描的方式逐像素地处理，每次一行。 当该邻域的原点位于图像的边界上时，部分邻域将位于图像的外部。 此时，一种方法是用 T 做指定的计算时忽略外侧邻点 或者用 0 或其他指定的灰度值填充图像的边缘。 被填充边界的厚度取决于邻域的大小。 以上过程称为空间滤波，其中邻域与预定义的操作一起称为空间滤波器（也成为空间掩膜、核、模板或窗口） 最小邻域的大小为 1 × 1 在这种情况下，g 仅取决于点 (x, y) 处的 f 值，而 T 则成为一个形如下式的灰度 (也称为灰度级或映射或强度映射) 变换函数： $$ s = T(r) $$ 式中，令 r 和 s 分别表示变量，即 g 和 f 在任意点 (x, y) 处的灰度 T(r) 有多种形式： 左图中，这种变换将会产生比原始图像更高的对比度（灰度级低于 m 时变暗，而灰度级在 m 以上时变亮），这种技术有时称为对比度拉伸。 在极限情况下，如右图所示，T( r ) 产生了一幅两级（二值）图像。这种形式的映射称为阈值处理函数。 结果仅取决于一个点的灰度的方法，有时称为点处理技术，与之相对的有邻域处理技术。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:2:1","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":["专业课"],"content":"一些基本的灰度变换函数 灰度变换是所有图像处理技术中最简单的技术，是一种点处理技术 由于处理的是数字量，变换函数的值通常存储在一个一维阵列中，并且从 r 到 s 的映射通过查表得到。对于 8 比特环境，一个包含 T 值的可查阅的表需要有 256 个记录 如上图显示了图像增强常用的三类基本函数：线性函数（反转和恒等变换）、对数函数（对数和反对数变换）和幂律函数（n 次幂和 n 次根变换）。 图像反转 对于灰度级范围为 [0, L-1] 的一幅图像，该图像的反转由下式给出： $$ s=L-1-r $$ 使用这种方式反转一幅图像的灰度级，可得到等效的照片底片。这种类型的处理特别适用于增强嵌入图像暗色区域中的白色或灰色细节，特别是当黑色面积在尺寸上占主导地位时。 对数变换 $$ s=c\\times log(1+r) $$ 式中 c 是常数，并假设 r\u003e=0 此变换将输入中范围较窄的低灰度值映射为输出中范围较宽的灰度值，或将输入中范围较宽的高灰度值映射为输出中范围较窄的灰度值。 使用这种类型的变换来扩展图像中的暗像素值，同时压缩更高灰度级的值。反对数变换的作用与此相反。 对数函数压缩像素值变化较大的图像的动态范围，如傅里叶频谱 幂律（伽马）变换 $$ s=cr^\\gamma $$ 其中 c 和 γ 为正常数。对于不同的 γ 值，s 与 r 的关系曲线如下图所示。与对数变换情况类似，部分 γ 值的幂律曲线将较窄范围的暗色输入值映射为较宽范围的输出值，或将较宽范围的高灰度级输入值映射为较窄范围的输出值。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/digitalimageprocessing/:2:2","tags":["Python"],"title":"数字图像整理","uri":"/Notes/posts/courses/digitalimageprocessing/"},{"categories":null,"content":"实验二 ​ 孙天野 19120198 对 school 数据库做如下查询： 验证在 1000 万个以上记录时在索引和不索引时的查询时间区别。 没有索引的情况： 建立索引的过程： 建立索引后： 用以插入记录的脚本： import pymysql import string from pymysql import cursors conn = pymysql.connect(host= 'localhost',user='root',passwd='',db='school',charset='utf8') cursor = conn.cursor() cursor.execute(\"delete from a\") conn.commit for j in range(0,100): values = [] i=0 for i in range(100000*j,100000*(j+1)): values.append((i)) cursor.executemany('insert into a values(%s)',values) print(\"insert\"+str((j+1)*100000)) conn.commit() cursor.close conn.close() 查询 2011 年进校年龄大于 20 岁的男学生的学号与姓名。 SELECTxh,xmFROMsWHERE2011-YEAR(csrq)\u003e20ANDxb='男'; 检索刘晓明不学的课程的课程号。 SELECTkhFROMcWHEREkhNOTIN(SELECTkhFROMeINNERJOINsONe.xh=s.xhWHERExm='刘晓明'); SELECTc.khFROMcWHERE'刘晓明'notin(selectxmfromsinnerjoineons.xh=e.xhwheree.kh=c.kh); SELECTc.khFROMcWHEREnotexists(select*fromsinnerjoineons.xh=e.xhwheree.kh=c.khands.xm='刘晓明'); 查询计算机学院男生成绩及格、教授开设的课程的课程号、课名、开课教师姓名，按开课教师升序，课程号降序排序。 SELECTe.kh,c.km,t.xmFROMeINNERJOINsONe.xh=s.xhINNERJOINtONe.gh=t.ghINNERJOINcONe.kh=c.khWHEREs.xb='男'ANDt.xl='教授'ANDzpcj\u003e=60ORDERBYt.ghASC,c.khDESC 检索学号比张颖同学大，年龄比张颖同学小的同学学号、姓名。 SELECTxh,xmFROMsWHERExh\u003e(SELECTxhFROMsWHERExm='张颖')ANDcsrq\u003c(SELECTcsrqFROMsWHERExm='张颖') 检索同时选修了“08305001”和“08305002”的学生学号和姓名。 SELECTxh,xmFROMsWHERExhIN(SELECTa.xhFROMeASa,eASbWHEREa.kh='08305001'ANDb.kh='08305002'ANDa.xh=b.xh) 查询每个学生选课情况（包括没有选修课程的学生）。 SELECTs.xm,c.kmFROMsLEFTJOINeONs.xh=e.xhLEFTJOINcONe.kh=c.kh ","date":"0001-01-01","objectID":"/Notes/posts/homework/database/ex2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/database/ex2/"},{"categories":null,"content":"实验三 ​ 孙天野 19120198 查询每门课程中分数最高的学生学号和学生姓名。 SELECTe.kh,s.xh,s.xmFROMsINNERJOINeONs.xh=e.xhWHERE(e.kh,e.zpcj)IN(SELECTe.kh,max(zpcj)FROMeGROUPBYe.kh) 查询年龄小于本学院平均年龄，所有课程总评成绩都高于所选课程平均总评成绩的学生学号、姓名和平均总评成绩，按年龄排序。 SELECTs.xh,s.xm,avg(e.zpcj)FROMsINNERJOINeONs.xh=e.xhWHERE(2021-year(s.csrq))\u003c(SELECTavg(2021-year(c.csrq))FROMsAScWHEREc.yxh=s.yxh)ANDNOTEXISTS(SELECT*FROMeASaWHEREa.xh=e.xhANDa.zpcj\u003c(SELECTavg(b.zpcj)FROMeASbWHEREb.kh=a.kh))GROUPBYs.xh,s.xmORDERBY(2021-year(s.csrq)) 求年龄大于所有女同学年龄的男学生姓名和年龄。 SELECTxm,2021-year(csrq)FROMsWHERExb='男'AND2021-year(csrq)\u003e(SELECTmax(2021-year(a.csrq))FROMsasaWHERExb='女') 检索每学期每门课的学生排名情况，输出学期，课程号，学号，成绩，排名；按学期降序，相同按课程号升序，课程相同按排名从高到低。 SELECTe1.xq,e1.kh,e1.xh,e1.zpcj,count(*)ASpmFROMeASe1,eASe2WHERE(e2.zpcj\u003ee1.zpcjOR(e1.zpcj=e2.zpcjANDe1.xh=e2.xh))ANDe1.kh=e2.khANDe1.xq=e2.xqGROUPBYe1.xq,e1.kh,e1.xh,e1.zpcjORDERBYe1.xqDESC,e1.khASC,e1.zpcjDESC; 查询计算机学院男生选修本学院教授开设的课不及格的且还未重修的课，输出学生的学期，学号，课号，按学期升序，学期相同按学号升序排列。 SELECTe.xq,s.xh,e.khFROMeINNERJOINsONe.xh=s.xhINNERJOINtONe.gh=t.ghINNERJOINcONe.kh=c.khWHEREs.xb='男'ANDs.yxh=1ANDt.xl='教授'ANDt.yxh=1ANDe.zpcj\u003c60ORDERBYe.xq,s.xh ","date":"0001-01-01","objectID":"/Notes/posts/homework/database/ex3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/database/ex3/"},{"categories":null,"content":"实验四 ​ 孙天野 19120198 对 school 数据库做如下操作： 建立计算机学院总评不及格成绩学生的视图，包括学生学号、姓名、性别、手机、所选课程和成绩 CREATEVIEWview1(xh,xm,xb,sjhm,km,zpcj)AS(SELECTe.xh,xm,xb,sjhm,km,zpcjFROMeINNERJOINsONe.xh=s.xhINNERJOINcONe.kh=c.khWHEREe.zpcj\u003c60ANDs.yxh=1) 求年龄大于所有女同学年龄的男学生姓名和年龄 SELECTxm,2021-year(s.csrq)ASageFROMsWHEREs.xb=\"男\"ANDs.csrq\u003c(SELECTmin(s.csrq)FROMsWHEREs.xb=\"女\") 在 E 表中修改 08305001 课程的平时成绩，若成绩小于等于 75 分时提高 5%，若成绩大于 75 分时提高 4% UPDATEeSETpscj=pscj*1.05WHEREpscj\u003c=75;UPDATEeSETpscj=pscj*1.04WHEREpscj\u003e75; 删除没有开课的学院 DELETEFROMdWHERENOTEXISTS(SELECT*FROMoINNERJOINcONo.kh=c.khWHEREc.yxh=d.yxh) ","date":"0001-01-01","objectID":"/Notes/posts/homework/database/ex4/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/database/ex4/"},{"categories":null,"content":"ex1 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex1/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex1/"},{"categories":null,"content":"思考题 思考：你的用户名、用户标识、组名、组标识是什么？当前你处在系统的哪个位置中？现在有哪些用户和你一块儿共享系统？ ​ 当前处于 /mnt/d/Repo 目录下。loulou 与 root 用户一起共享系统文件操作命令 思考：文件链接是什么意思？有什么作用？ 文件链接指在文件之间创建链接。以此来给某个文件指定一个可以访问它的名称。对于这个新文件名，我们可以指定不同的访问权限来控制对信息的共享和安全性的问题。如果是目录链接，用户则可以直接进入被链接的目录，省去路径操作。此外，删除链接也不会破坏原先的目录 思考：Linux 文件类型有哪几种？文件的存取控制模式如何描述？ 主要有普通文件（~）、目录文件（d）、块设备特别文件（b）、字符设备特别文件（c）、命令管道文件（p）这几类。存取控制模式指对不同用户分配不同的操作权。分为三种：写、读、执行。 思考：执行了上述操作后，若想再修该文件，看能不能执行。为什么？ 不能执行。因为文件所属用户不是当前登录的用户。 思考：系统如何管理系统中的多个进程？进程的家族关系是怎样体现的？有什么用？ Linux 使用 task_struct 数据结构表示每个进程，利用任务向量这个指针数组来指向每一个 task。进程的家族关系是进程家族树来体现，通过继承体系从系统的任何一个进程发现并查找到指定的其它进程，通过不断指向子进程即可遍历所有进程。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex1/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex1/"},{"categories":null,"content":"讨论 Linux 系统命令很多，在手头资料不全时，如何查看命令格式？ 命令名 --help 或 man 命令名 Linux 系统用什么方式管理多个用户操作？如何管理用户文件，隔离用户空间？用命令及结果举例说明。 用户是 Linux 系统最底层的安全设备，属于权限问题，系统要回收权力。系统用户即系统的使用者，用户管理是对文件进行管理，用户的存在是为了回收权力。利用用户和用户组管理实现不同用户分配不同权限 利用 chown 来修改文件权限，使得只有指定的用户才可以访问。 用什么方式查看你的进程的管理参数？这些参数怎样体现父子关系？当结束一个父 进程后其子进程如何处理？用命令及结果举例说明。 一个父进程后其子进程如何处理？用命令及结果举例说明。 ps -ef 根据 PID 和 PPID 可以得知其父子关系。若父进程比子进程先终止，则该父进程的所有子进程的父进程都变为 init 进程。其执行顺序大致如下：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止的进程的子进程，如果是，则该进程的父进程 ID 就更改为 1（init 进程的 ID) Linux 系统“文件”的含义是什么？它的文件有几种类型？如何标识的？ Linux 世界中的所有、任意、一切东西都可以通过文件的方式访问、管理，这种文件的设计是一种面向对象的设计思想。普通文件（~）、目录文件（d）、块设备特别文件（b）、字符设备特别文件（c）、命令管道文件（p）、链接文件（l）、套接字文件（s）等。 Linux 系统的可执行命令主要放在什么地方？找出你的计算机中所有存放系统的可 执行命令的目录位置。 /bin 一般用户即可使用 /usr/bin /usr/sbin/ /usr/local/sbin 管理员可以使用 Linux 系统得设备是如何管理的？在什么地方可以找到描述设备的信息？ fdisk -l ##列出磁盘分区信息(真实存在的设备) blkid ##列出系统中可以使用的设备id cat /proc/partition ##系统内核可以识别的设备 df ##系统正在挂载的设备（显示挂载点） 画出 Linux 根文件系统的框架结构。描述各目录的主要作用。你的用户主目录在哪里？ / ：linux 系统目录树的起点 bin：命令文件目录，也称二进制目录 boot：存放系统的内核文件和引导装载程序文件 dev：设备文件目录，存放所有的设备文件，例如 cdrom 为光盘设备 etc：存放系统配置文件，如 password 文件 home：包含系统中各个用户的主目录，子目录名即为各用户名 lib：存放各种编程语言库 media：系统设置的自动挂载点，如u盘的自动挂载点 opt：表示可选择的意思，有些软件包会被安装在这里; usr：最大的目录之一，很多系统中，该目录是作为独立的分区挂载的，该目录中主要存放不经常变化的数据，以及系统下安装的应用程序目录 mnt：主要用来临时挂载文件系统，为某些设备默认提供挂载点 （WSL 中 windows 系统的文件会被挂载在这个目录） proc：虚拟文件系统，该目录中的文件是内存中的映像。 sbin：保存系统管理员或者 root 用户的命令文件。 tmp：存放临时文件 var：通常保存经常变化的内容，如系统日志、邮件文件等 root：系统管理员主目录 Linux 系统的 Shell 是什么？请查找这方面的资料，说明不同版本的Shell的特点。 下面每一项说明的是哪类文件。 Shell 是脚本中命令的解释器，Linux 系统的 shell 作为操作系统的外壳，为用户提供使用操作系统的接口。它是命令语言、命令解释程序及程序设计语言的统称。shell 是用户和 Linux 内核之间的接口程序，当从 shell 或其他程序向 Linux 传递命令时，内核会做出相应的反应。shell是一个命令语言解释器，它拥有自己内建的 shell 命令集，shell 也能被系统中其他应用程序所调用。用户在提示符下输入的命令都由 shell 先解释然后传给 Linux 核心。 ① bash 是 Linux 标准默认的 shell，内部命令一共有 40 个。它可以使用类似 DOS 下面的 doskey 的功能，用方向键查阅和快速输入并修改命令。自动通过查找匹配的方式给出以某字符串开头的命令。包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。 ② sh 是 Unix 标准默认的 shell。 ③ ash 是 Linux中 占用系统资源最少的一个小 shell，它只包含 24 个内部命令，因而使用起来很不方便。 ④ csh 是 Linux 比较大的内核，共有 52 个内部命令。该 shell 其实是指向 /bin/tcsh 这样的一个 shell，也就是说，csh 其实就是 tcsh。 ⑤ ksh 共有 42 条内部命令。该 shell 最大的优点是几乎和商业发行版的 ksh 完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。 目录文件：5、7 字设备特别文件：3、6 块设备特别文件：4 普通文件：1、8 链接文件：2 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex1/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex1/"},{"categories":null,"content":"实验三 第八组 19120198 孙天野 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"函数详解 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"fork() 创建一个子进程 返回 在子进程中，返回 0 在父进程中，返回新创建子进程的进程 ID 创建失败则返回 -1 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"wait() pid_t wait(int *stat_loc); // 获取子进程退出状态并返回死掉的子进程ID 父进程调用 wait() 后，将发生堵塞，直到它的一个子进程退出或收到信号为止 如果只有一个子进程被终止，那么 wait() 返回被终止的子进程的进程 ID。 如果多个子进程被终止，那么 wait() 将获取任意子进程的进程 ID 子进程可能由于以下原因而终止： 调用 exit()； 接收到 main 进程的 return 值； 接收一个信号（来自操作系统或另一个进程），该信号的默认操作是终止。 父进程调用 wait() 时传一个整型变量地址给函数。内核将子进程的退出状态保存在这个变量中。 如果子进程调用 exit() 退出，那么内核把 exit() 的返回值存放到这个整数变量中； 如果进程是被杀死的，那么内核将信号序号存放在这个变量中。 这个整数由 3 部分组成，8 个 bit 记录子进程 exit() 值，7 个 bit 记录信号序号，另一个 bit 用来指明发生错误并产生了内核映像（core dump） 如果进程没有子进程，那么 wait() 返回 -1 // C program to demonstrate working of wait() #include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e#include\u003csys/wait.h\u003e#include\u003cunistd.h\u003e int main() { pid_t cpid; int status; int high_8, low_7, bit_7; if (fork()== 0) { printf(\"this is child process, the id is %d\\n\", getpid()); exit(18); /* terminate child */ } else { printf(\"status is %d\\n\", status); cpid = wait(\u0026status); /* reaping parent */ high_8 = status \u003e\u003e 8; /* 1111 1111 0000 0000 */ low_7 = status \u0026 0x7F; /* 0000 0000 0111 1111 */ bit_7 = status \u0026 0x80; /* 0000 0000 1000 0000 */ printf(\"status is %d\\n\", status); printf(\"high_8 is %d, low_7 is %d, bit_7 is %d\\n\", high_8, low_7, bit_7); } printf(\"Parent pid = %d\\n\", getpid()); printf(\"Child pid = %d\\n\", cpid); return 0; } 输出 status is 0 this is child process, the id is 5412 status is 4608 high_8 is 18, low_7 is 0, bit_7 is 0 Parent pid = 5411 Child pid = 5412 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"setbuf() void setbuf(FILE *stream, char *buffer) 定义流 stream 应如何缓冲。该函数应在与流 stream 相关的文件被打开时，且还未发生任何输入或输出操作之前被调用一次。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"perror() void perror ( const char * str ); 头文件 #include\u003cstdio.h\u003e 将上一个函数发生错误的原因输出到标准设备 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:4","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"exec 头文件 \u003cunistd.h\u003e execl() int execl(const char *path, const char *arg, ...); 参数 path：要启动程序的名称，包括路径名 arg：启动程序所带的参数，一般第一个参数为要执行命令名，不是带路径且 arg 必须以 NULL 结束（(char *)0) 也可） 返回值 成功返回 0，失败返回 -1 execl(\"/bin/ls\", \"ls\", \"-l\", NULL); execlp() 多了个 p，表示第一个参数 path 不用输入完整路径，只有给出命令名即可，它会在环境变量 PATH 当中查找命令 execlp(\"ls\", \"ls\", NULL); ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:5","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"宏 WEXITSTATUS(status)：子级退出时的返回代码 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:6","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"管道操作 头文件 #include\u003cunistd.h\u003e pipe() int pipe(int fd[2]); 用于创建一个管道，以实现进程间的通信 参数 fd：大小为 2 的一个数组类型的指针 返回 成功时返回 0，并将一对打开的文件描述符值填入 fd 参数指向的数组 失败时返回 -1 并设置 errno 通过 pipe 函数创建的这两个文件描述符 fd[0] 和 fd[1] 分别构成管道的两端，往 fd[1] 写入的数据可以从 fd[0] 读出。并且 fd[1] 一端只能进行写操作，fd[0] 一端只能进行读操作，不能反过来使用。要实现双向数据传输，可以使用两个管道。 wirte() char buf[] = \"I am mike\"; // 往管道写端写数据 write(fd[1], buf, strlen(buf)); read() char str[50] = {0}; // 从管道里读数据 read(fd_pipe[0], str, sizeof(str)); lockf() int lockf(int fd, int cmd, off_t len); 参数 fd：打开文件的文件描述符 cmd：指定要采取的操作的控制值 # define F_ULOCK 0 //解锁 # define F_LOCK 1 //互斥锁定区域 # define F_TLOCK 2 //测试互斥锁定区域 # define F_TEST 3 //测试区域 len：要锁定或解锁的连续字节数 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:1:7","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第一题 显示进程标识、组标识、用户标识 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { printf(\"Pid: %d\\n\", getpid()); printf(\"Gid: %d\\n\", getgid()); printf(\"Uid: %d\\n\", getuid()); sleep(2); char ch; while (1) { printf(\"quit? [Y/N]\\n\"); fflush(stdin); scanf(\"%c\", \u0026ch); if (ch == 'Y' || ch == 'y') { break; } } } 输出 Pid: 1075 Gid: 1000 Uid: 1000 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第二题 创建子进程 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cstdlib.h\u003e#include \u003cstdio.h\u003e#include \u003cunistd.h\u003eint main() { int status; int ppid; if (fork()) { pid = wait(\u0026status); printf(\"It's a parent process.\\n\"); printf(\"The child process, ID number %d, is finished.\\n\", pid); } else { printf(\"It's a child process.\\n\"); sleep(2); exit(0); } } 输出： It's a child process. It's a parent process. The child process, ID number -1, is finished. ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 子进程是如何产生的？ 又是如何结束的？ 父进程调用 fork() 来创建子进程，此时两个进程同时进行； 在父进程中，fork() 返回子进程的 pid，故运行 if 语句内的代码块，wait() 函数使父进程阻塞（直到子进程结束）并且返回子进程 pid； 在子进程中，fork() 返回 0，故运行 else 语句内的代码块，exit() 函数终止子进程 父进程收到子进程结束的信号后，继续执行剩余的代码段 子进程被创建后它的运行环境是怎样建立的？ fork() 调用后，内核会为子进程分配对应的虚拟内存空间，同时它的正文段，数据段，堆栈端都是指向了父进程的物理空间，实现物理空间共享，并且内容可读，一旦某个进程修改这个共享的物理空间的内容，就会复制到子进程自己的物理空间。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第三题 循环创建子进程 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cunistd.h\u003eint main() { int i, j, status; printf(\"My pid is %d, my father’s pid is % d\\n\", getpid(), getppid()); for (i = 0; i \u003c 3; i++) if (fork()) { j = wait(\u0026status); printf(\"Pid %d: The child %d is finished.\\n\", getpid(), j); } else { printf(\"Loop %d: pid = %d ppid = %d\\n\", i + 1, getpid(), getppid()); exit(0); //如果只想通过循环建立三个子进程，加上这句话 } } 输出结果： My pid is 9690, my father’s pid is 296 Loop 1: pid = 9691 ppid = 9690 Pid 9690: The child 9691 is finished. Loop 2: pid = 9692 ppid = 9690 Pid 9690: The child 9692 is finished. Loop 3: pid = 9693 ppid = 9690 Pid 9690: The child 9693 is finished. ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:4:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 画出进程家族树 296───9690─┬─9691─┬─9692───9693 │ └─9694 ├─9695───9696 │ └─9697 子进程的运行环境是怎样建立的？ 父进程调用fork() 后，内核会为子进程分配对应的虚拟内存空间。 反复运行此程序会出现什么情况？ 进程号在递增 原因：Linux 的缓存机制。但是 pid 不会一直递增下去，通常在 /proc/sys/kernel/pid_max 里会存储一个最大值；如果达到这个最大值，系统会重复使用较小的 pid 修改程序，是运行结果呈单分支结构 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/wait.h\u003e#include \u003cunistd.h\u003eint main() { int i, j, status; printf(\"My pid is %d, my father’s pid is % d\\n\", getpid(), getppid()); i = 0; for (i = 0; i \u003c 3; i++) { if (fork()) { j = wait(\u0026status); i = WEXITSTATUS(status); printf(\"Pid %d: The child %d is finished.\\n\", getpid(), j); } else { printf(\"Loop %d: pid = %d ppid = %d\\n\", i + 1, getpid(), getppid()); } } exit(i); } 输出 My pid is 9690, my father’s pid is 296 Loop 1: pid = 9691 ppid = 9690 Loop 2: pid = 9692 ppid = 9691 Loop 3: pid = 9693 ppid = 9692 Pid 9692: The child 29003 is finished. Pid 9691: The child 29002 is finished. Pid 9690: The child 29001 is finished. 进程树 296───9690───9691───9692───9693 解释： exit(i); 语句使得子进程结束时，将循环次数标志 i 返回 i = WEXITSTATUS(status); 接收了子进程的 i 值，帮助父进程跳出循环 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:4:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第四题 子进程系统调用执行不同程序 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:5:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e int main() { int childPid1, childPid2, childPid3; int pid, status; setbuf(stdout, NULL); // 创建子进程1 childPid1 = fork(); if (childPid1 == 0) // 运行子进程1的内容 { execlp(\"echo\", \"echo\", \"Child process 1 is running~\", NULL); // 启动其他程序 perror(\"exec1 error.\\n\"); exit(1); } // 创建子进程2 childPid2 = fork(); if (childPid2 == 0) // 运行子进程2的内容 { execlp(\"date\", \"date\", NULL); // 启动其他程序 perror(\"exec2 error.\\n\"); exit(2); } // 创建子进程3 childPid3 = fork(); if (childPid3 == 0) // 运行子进程2的内容 { execlp(\"ls\", \"ls\", \"-l\", NULL); // 启动其他程序 perror(\"exec3 error.\\n\"); exit(3); } puts(\"Parent process is waiting for child process return!\"); while ((pid = wait(\u0026status)) != -1) // 等待子进程结束 { if (childPid1 == pid) // 若子进程1结束 printf(\"Child process 1 terminated with status %d\\n\", (status \u003e\u003e 8)); else if (childPid2 == pid) // 若子进程2结束 printf(\"Child process 2 terminated with status %d\\n\", (status \u003e\u003e 8)); else if (childPid3 == pid) // 若子进程3结束 printf(\"Child process 3 terminated with status %d\\n\", (status \u003e\u003e 8)); else printf(\"Wrong!\\n\"); } puts(\"All child processes terminated.\"); puts(\"Parent proccess terminated.\"); exit(0); } 输出： Parent process is waiting for child process return! Child process 1 is running~ Sat Sep 25 13:18:42 CST 2021 Child process 1 terminated with status 0 Child process 2 terminated with status 0 total 40 -rw-r--r-- 1 loulou loulou 176 Sep 24 15:25 t1.c -rw-r--r-- 1 loulou loulou 377 Sep 24 15:25 t2.c -rw-r--r-- 1 loulou loulou 505 Sep 24 17:38 t3.c -rw-r--r-- 1 loulou loulou 552 Sep 24 17:44 t3_1.c -rw-r--r-- 1 loulou loulou 1606 Sep 25 13:18 t4.c -rwxr-xr-x 1 loulou loulou 17040 Sep 25 13:18 t4.o Child process 3 terminated with status 0 All child processes terminated. Parent proccess terminated. ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:5:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 子进程运行其他程序后，进程运行环境怎样变化？ 子进程运行其他程序后，此进程被程序替代，因此进程号不会改变 反复运行程序的情况？ 三个子进程结束的顺序不确定；尽管子进程的开始顺序是写死在代码里的，它们的结束顺序却由程序运行时间所决定 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:5:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第五题 子进程继承父进程 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:6:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003csys/types.h\u003eint global = 4; void main() { pid_t pid; int vari = 5; printf(\"Before fork.\\n\"); if ((pid = fork()) \u003c 0) // 若创建失败 { printf(\"Fork error!\\n\"); exit(0); } else if (pid == 0) // 子进程执行 { global++; vari--; printf(\"Child %d changed the vari and gobal.\\n\", getpid()); } else // 父进程执行 { printf(\"Parent %d did not change the vari and global.\\n\", getpid()); } printf(\"pid=%d, global=%d, vari=%d\\n\", getpid(), global, vari); exit(0); } 输出 Before fork. Parent 1463 did not change the vari and global. pid=1463, global=4, vari=5 Child 1464 changed the vari and gobal. pid=1464, global=5, vari=4 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:6:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 子进程被创建后，对父进程的运行环境有影响吗？ 没有影响。子进程在创建时，从父进程复制了代码段与数据段，相互独立。可以看到子进程的局部变量和全局变量修改后，父进程并没有发生相应的改动 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:6:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第六题 父进程创建两个子进程，父子之间利用管道进行通信 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:7:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003evoid main() { int i, r, j, k, l, p1, p2, fd[2]; char buf[50], s[50]; pipe(fd); // 建立一个管道fd while ((p1 = fork()) == -1) // 创建子进程1 ; if (p1 == 0) // 子进程1执行 { lockf(fd[1], 1, 0); // 管道写入端加锁 sprintf(buf, \"Child process p1 is sending messages!\\n\"); printf(\"Child process p1!\\n\"); write(fd[1], buf, 50); // 写入管道 lockf(fd[1], 0, 0); // 管道写入端解锁 sleep(4); j = getpid(); k = getppid(); printf(\"P1 %d is waken up. My parent procees ID is %d.\\n\", j, k); exit(0); } else { while ((p2 = fork()) == -1) ; if (p2 == 0) { lockf(fd[1], 1, 0); // 管道写入端加锁 sprintf(buf, \"Child process p2 is sending messages!\\n\"); printf(\"Child process p2!\\n\"); write(fd[1], buf, 50); // 写入管道 lockf(fd[1], 0, 0); // 管道写入端解锁 sleep(4); j = getpid(); k = getppid(); printf(\"P2 %d is waken up. My parent procees ID is %d.\\n\", j, k); exit(0); } else { l = getpid(); wait(0); // 父进程等待被唤醒 if ((r = read(fd[0], s, 50)) == -1) printf(\"Can't read pipe.\\n\"); else printf(\"Parent %d: %s \\n\", l, s); wait(0); if ((r = read(fd[0], s, 50)) == -1) printf(\"Can't read pipe.\\n\"); else printf(\"Parent %d: %s \\n\", l, s); exit(0); } } } 输出： Child process p1! Child process p2! P1 2186 is waken up. My parent procees ID is 2185. P2 2187 is waken up. My parent procees ID is 2185. Parent 2185: Child process p1 is sending messages! Parent 2185: Child process p2 is sending messages! ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:7:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 什么是管道？ 能够连接一个写进程和一个读进程，并允许他们能够互相通信的一个共享文件 进程如何利用管道进行通信？ 用写进程从管道的入端将数据写入管道，用读进程从管道的出端读取数据 修改睡眠时机、睡眠长度，会有什么变化？ 进程唤醒的时间会被改变。因为睡眠时机、睡眠长度影响进程开始与结束时间 加锁、解锁起什么作用？不用它行吗？ 加锁、解锁避免资源共享冲突问题，不用它会导致数据读写发生冲突 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:7:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第七题 父子进程利用管道通信；父进程撤销进程，先于子进程结束 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:8:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003evoid main() { int i, r, j, k, l, p1, p2, fd[2]; char buf[50], s[50]; pipe(fd); // 建立一个管道fd lockf(fd[1], 1, 0); // 管道写入端加锁 sprintf(buf, \"Parent process is sending messages!\\n\"); printf(\"Parent process!\\n\"); write(fd[1], buf, 50); // 写入管道 lockf(fd[1], 0, 0); // 管道写入端解锁 while ((p1 = fork()) == -1) // 创建子进程1 ; if (p1 == 0) // 子进程1执行 { l = getpid(); if ((r = read(fd[0], s, 50)) == -1) printf(\"Can't read pipe.\\n\"); else printf(\"Child %d: %s \\n\", l, s); sleep(5); printf(\"Child process terminated!\"); exit(0); } else // 父进程 { printf(\"Parent process terminated!\"); exit(0); // 撤销父进程 } } 输出 Parent process! Child 2542: Parent process is sending messages! Parent process terminated! Child process terminated! ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:8:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 系统如何处理孤儿进程？ 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:8:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第八题 客户进程向服务器进程发出信号，服务器进程接受作出应答，再向客户返回消息 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:9:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"Client #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/types.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/msg.h\u003e #define MSGKEY 75 struct msgform { long mtype; char mtext[256]; } msg; void main() { struct msgform msg; int msgqid, pid, *pint; msgqid = msgget(MSGKEY, 0777); pid = getpid(); pint = (int *)msg.mtext; *pint = pid; msg.mtype = 1; msgsnd(msgqid, \u0026msg, sizeof(int), 0); msgrcv(msgqid, \u0026msg, 256, pid, 0); printf(\"Client: receive from pid %d.\\n\", *pint); } ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:9:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"Server #include \u003cstdio.h\u003e#include \u003cunistd.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/types.h\u003e#include \u003csys/ipc.h\u003e#include \u003csys/msg.h\u003e #define MSGKEY 75 struct msgform { long mtype; char mtext[256]; } msg; int msgqid; void main() { int i, pid, *pint; extern cleanup(); for (i = 0; i \u003c 20; i++) // 设置软中断信号的处理程序 signal(i, cleanup); msgqid = msgget(MSGKEY, 0777 | IPC_CREAT); for (;;) { msgrcv(msgqid, \u0026msg, 256, 1, 0); pint = (int *)msg.mtext; pid = *pint; printf(\"Server: receive from pid %d.\\n\", pid); msg.mtype = pid; *pint = getpid(); msgsnd(msgqid, \u0026msg, sizeof(int), 0); } } cleanup() { msgctl(msgqid, IPC_RMID, 0); exit(0); } ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:9:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 服务者程序和客户程序还可以用什么机制来实现？ 服务者程序和客户程序还可以利用 socket 进行通信 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:9:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第九题 父进程设定软中断信号处理程序，向子进程发软中断信号；子进程收到信号后执行相应处理程序。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:10:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实现 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csys/types.h\u003e#include \u003csys/wait.h\u003e#include \u003cunistd.h\u003e int main() { int i, j, k; int func(); signal(18, func()); // 设置18号信号的处理程序 if (i = fork()) // 父进程 { j = kill(i, 18); // 向子进程发送信号 printf(\"Parent: signal 18 has been sent to child %d,returned %d.\\n\", i, j); k = wait(0); printf(\"After wait %d,Parent %d: finished.\\n\", k, getpid()); } else // 子进程 { sleep(10); printf(\"Child %d: A signal from my parent is received.\\n\", getpid()); } } func() /*处理程序*/ { int m; m = getpid(); printf(\"I am Process %d: This is signal 18 processing function.\\n\", m); } 输出 I am Process 4465: This is signal 18 processing function. Parent: signal 18 has been sent to child 4466,returned 0. After wait 4466,Parent 4465: finished. signal 函数将 18 号处理程序与 func 函数绑定；在父进程调用 j = kill(i, 18);，表示向子进程发送 18 号处理程序的中断信号，子进程响应信号，直接打断 sleep() 并执行相应 func 程序 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:10:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考 软中断与硬中断有什么区别？ 硬中断由外部硬件产生；软中断由执行中断指令产生的 硬中断可以直接中断 CPU，它会引起内核中相关的代码被触发；软中断并不会直接的中断 CPU，也只有当前正在运行的代码（或者是进程）才会产生软中断 硬中断可以被屏蔽；软中断不可被屏蔽 Linux 内核将中断函数需要处理的任务分为两部分，一部分在中断处理函数中执行，此时系统关闭中断；另外一部分在软件中断中执行，此时开启中断，允许系统响应外部中断。当中断发生时，使用硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断来完成。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:10:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"第十题 用信号量机制编写一个解决生产者——消费者问题的程序 #include \u003cstdio.h\u003e#include \u003cwindows.h\u003e #define BUFFER_SIZE 10 int buffer[BUFFER_SIZE]; int in = 0; int out = 0; typedef int Semaphore; Semaphore full = 0; Semaphore empty = BUFFER_SIZE; Semaphore mutex = 1; #define PRODUCER 0 #define CONSUMER 1 int count=0; //记录型信号量的wait操作 void waitS(int type, Semaphore *s) { while (*s == 0) { if (type == PRODUCER) { printf(\"Producer is waiting for empty\\n\\n\"); } else if (type == CONSUMER) { printf(\"Consumer is waiting for full\\n\\n\"); } Sleep(30); } (*s)--; } //互斥型信号量的wait操作，number用于指示是生产者还是消费者 void waitM(int type, Semaphore *s) { if (*s == 1) { (*s) = 0; } else { if (type == PRODUCER) { printf(\"Producer is waiting for mutex\\n\\n\"); } else if (type == CONSUMER) { printf(\"Consumer is waiting for mutex\\n\\n\"); } Sleep(30); } } //记录型信号量的signal操作 void signalS(Semaphore *s) { (*s)++; } //互斥型信号量的signal操作 void signalM(Semaphore *s) { *s = 1; } //生产者 int producer(LPVOID lpThreadParameter) { int nextp; while(1) { nextp = count++; printf(\"Produce an item.\\n\"); waitS(PRODUCER,\u0026empty); waitM(PRODUCER,\u0026mutex); printf(\"Producer write to buffer.\\n\"); buffer[in] = nextp; in = (++in) % BUFFER_SIZE; printf(\"After producing: in = %d, out = %d, full = %d, empty = %d.\\n\",in,out,full+1,empty); signalM(\u0026mutex); signalS(\u0026full); printf(\"Producer left critical section.\\n\\n\"); } return 0; } //消费者 int consumer(LPVOID lpThreadParameter) { int nextc; while(1) { waitS(CONSUMER,\u0026full); waitM(CONSUMER,\u0026mutex); printf(\"Consumer read from buffer.\\n\"); nextc = buffer[out]; out = (++out) % BUFFER_SIZE; printf(\"After consemer leaves critical section in = %d, out = %d, full = %d, empty = %d.\\n\",in,out,full,empty+1); signalM(\u0026mutex); signalS(\u0026empty); printf(\"Consume an item: %d.\\n\\n\",nextc); } return 0; } int main() { HANDLE hProducer,hConsumer; //创建生产者和消费者线程并立即运行 hProducer = CreateThread(NULL,0,producer,NULL,0,NULL); hConsumer = CreateThread(NULL,0,consumer,NULL,0,NULL); Sleep(500); TerminateThread(hProducer,0); TerminateThread(hConsumer,0); return 0; } ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:11:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"研究并讨论 讨论 Linux 系统进程运行时的机制和特点，系统通过什么来管理进程？ Linux 中将进程抽象为文件，一个进程被描述为一类数据结构；系统通过优先级决定进程运行顺序，通过 pid 标记所有进程，提供 ps、top 等命令接口供用户修改进程状态，使用用户堆栈和系统堆栈控制用户态和核心态之间的互相转换，使用管道、信号量等传统的进程通信方式 C 语言中是如何使用 Linux 提供的功能的？ Linux 在 C 语言中提供了一系列系统调用接口给编程人员使用 如 fork() 函数用来创建子进程；execl() 函数用来使用 shell 命令等 什么是进程？它是如何产生的？ 进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位 执行程序时，会产生相应的进程 进程控制如何实现？ 系统为了控制进程，设计出一种数据结构——进程控制块 PCB，其中记录了操作系统所需的、用于描述进程当前情况以及控制进程运行的全部信息。 进程通信方式各有什么特点？ 共享存储器系统 基于共享数据结构、共享存储区的通信方式 仅适用于传递相对少量的数据，通信效率低，属于低级通信） 管道通信系统 互斥：当一个进程正在对 pipe 执行读/写操作时，其它进程必须等待 同步，当一个进程将一定数量的数据写入，然后就去睡眠等待，直到读进程将数据取走，再去唤醒。读进程与之类似 需要确定对方是否存在 消息传递系统 进程间的数据交换以格式化的消息为单位 客户机服务器系统 基于 socket 协议 管道通信如何实现？该通信方式可以用在何处？ 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据。 管道通信通常用于两个进程之间的相互通信 什么是软中断？软中断信号通信如何实现？ 软中断是 CPU 根据软件的某条指令或者软件对标志寄存器的某个标志位的设置而产生 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:12:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实验一题目 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:13:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"思考题 思考：你的用户名、用户标识、组名、组标识是什么？当前你处在系统的哪个位置中？现在有哪些用户和你一块儿共享系统？ ​ 当前处于 /mnt/d/Repo 目录下。loulou 与 root 用户一起共享系统文件操作命令 思考：文件链接是什么意思？有什么作用？ 文件链接指在文件之间创建链接。以此来给某个文件指定一个可以访问它的名称。对于这个新文件名，我们可以指定不同的访问权限来控制对信息的共享和安全性的问题。如果是目录链接，用户则可以直接进入被链接的目录，省去路径操作。此外，删除链接也不会破坏原先的目录 思考：Linux 文件类型有哪几种？文件的存取控制模式如何描述？ 主要有普通文件（~）、目录文件（d）、块设备特别文件（b）、字符设备特别文件（c）、命令管道文件（p）这几类。存取控制模式指对不同用户分配不同的操作权。分为三种：写、读、执行。 思考：执行了上述操作后，若想再修该文件，看能不能执行。为什么？ 不能执行。因为文件所属用户不是当前登录的用户。 思考：系统如何管理系统中的多个进程？进程的家族关系是怎样体现的？有什么用？ Linux 使用 task_struct 数据结构表示每个进程，利用任务向量这个指针数组来指向每一个 task。进程的家族关系是进程家族树来体现，通过继承体系从系统的任何一个进程发现并查找到指定的其它进程，通过不断指向子进程即可遍历所有进程。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:13:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"讨论题 Linux 系统命令很多，在手头资料不全时，如何查看命令格式？ 命令名 --help 或 man 命令名 Linux 系统用什么方式管理多个用户操作？如何管理用户文件，隔离用户空间？用命令及结果举例说明。 用户是 Linux 系统最底层的安全设备，属于权限问题，系统要回收权力。系统用户即系统的使用者，用户管理是对文件进行管理，用户的存在是为了回收权力。利用用户和用户组管理实现不同用户分配不同权限 利用 chown 来修改文件权限，使得只有指定的用户才可以访问。 用什么方式查看你的进程的管理参数？这些参数怎样体现父子关系？当结束一个父 进程后其子进程如何处理？用命令及结果举例说明。 一个父进程后其子进程如何处理？用命令及结果举例说明。 ps -ef 根据 PID 和 PPID 可以得知其父子关系。若父进程比子进程先终止，则该父进程的所有子进程的父进程都变为 init 进程。其执行顺序大致如下：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止的进程的子进程，如果是，则该进程的父进程 ID 就更改为 1（init 进程的 ID) Linux 系统“文件”的含义是什么？它的文件有几种类型？如何标识的？ Linux 世界中的所有、任意、一切东西都可以通过文件的方式访问、管理，这种文件的设计是一种面向对象的设计思想。普通文件（~）、目录文件（d）、块设备特别文件（b）、字符设备特别文件（c）、命令管道文件（p）、链接文件（l）、套接字文件（s）等。 Linux 系统的可执行命令主要放在什么地方？找出你的计算机中所有存放系统的可 执行命令的目录位置。 /bin 一般用户即可使用 /usr/bin /usr/sbin/ /usr/local/sbin 管理员可以使用 Linux 系统得设备是如何管理的？在什么地方可以找到描述设备的信息？ fdisk -l ##列出磁盘分区信息(真实存在的设备) blkid ##列出系统中可以使用的设备id cat /proc/partition ##系统内核可以识别的设备 df ##系统正在挂载的设备（显示挂载点） 画出 Linux 根文件系统的框架结构。描述各目录的主要作用。你的用户主目录在哪里？ / ：linux 系统目录树的起点 bin：命令文件目录，也称二进制目录 boot：存放系统的内核文件和引导装载程序文件 dev：设备文件目录，存放所有的设备文件，例如 cdrom 为光盘设备 etc：存放系统配置文件，如 password 文件 home：包含系统中各个用户的主目录，子目录名即为各用户名 lib：存放各种编程语言库 media：系统设置的自动挂载点，如u盘的自动挂载点 opt：表示可选择的意思，有些软件包会被安装在这里; usr：最大的目录之一，很多系统中，该目录是作为独立的分区挂载的，该目录中主要存放不经常变化的数据，以及系统下安装的应用程序目录 mnt：主要用来临时挂载文件系统，为某些设备默认提供挂载点 （WSL 中 windows 系统的文件会被挂载在这个目录） proc：虚拟文件系统，该目录中的文件是内存中的映像。 sbin：保存系统管理员或者 root 用户的命令文件。 tmp：存放临时文件 var：通常保存经常变化的内容，如系统日志、邮件文件等 root：系统管理员主目录 Linux 系统的 Shell 是什么？请查找这方面的资料，说明不同版本的Shell的特点。 下面每一项说明的是哪类文件。 Shell 是脚本中命令的解释器，Linux 系统的 shell 作为操作系统的外壳，为用户提供使用操作系统的接口。它是命令语言、命令解释程序及程序设计语言的统称。shell 是用户和 Linux 内核之间的接口程序，当从 shell 或其他程序向 Linux 传递命令时，内核会做出相应的反应。shell是一个命令语言解释器，它拥有自己内建的 shell 命令集，shell 也能被系统中其他应用程序所调用。用户在提示符下输入的命令都由 shell 先解释然后传给 Linux 核心。 ① bash 是 Linux 标准默认的 shell，内部命令一共有 40 个。它可以使用类似 DOS 下面的 doskey 的功能，用方向键查阅和快速输入并修改命令。自动通过查找匹配的方式给出以某字符串开头的命令。包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。 ② sh 是 Unix 标准默认的 shell。 ③ ash 是 Linux中 占用系统资源最少的一个小 shell，它只包含 24 个内部命令，因而使用起来很不方便。 ④ csh 是 Linux 比较大的内核，共有 52 个内部命令。该 shell 其实是指向 /bin/tcsh 这样的一个 shell，也就是说，csh 其实就是 tcsh。 ⑤ ksh 共有 42 条内部命令。该 shell 最大的优点是几乎和商业发行版的 ksh 完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。 目录文件：5、7 字设备特别文件：3、6 块设备特别文件：4 普通文件：1、8 链接文件：2 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex3/:13:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex3/"},{"categories":null,"content":"实验六 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"实验步骤 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第一题 三种工作方式各用在何时？ 正常模式（转义命令模式）用于浏览文件、复制粘贴等操作 命令模式（末行命令模式）用于执行一些特殊指令，如查找、定位等 插入模式用于编辑文件 用什么命令进入插入方式？ 在命令模式下按下 i 就进入了插入模式 怎样退出插入方式？ 按 \u003cEsc\u003e 键进入正常模式 文件怎样存盘？ wq：表示保存退出 wq!：表示强制保存退出 x：表示保存退出 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第四题 #!/bin/bash # Name display program echo \"The program's name is $0\" if [ $# == 0 ] then echo \"Parameter not provided\" else echo \"The number of parameters is $#\" echo \"Params are: $@\" fi 输出 $ ./t4.sh 1 2 3 4 The program's name is ./t4.sh The number of parameters is 4 Params are: 1 2 3 4 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第五题 #!/bin/bash echo \"Type sth\" while read param do if [ -z \"$param\" ] # 判断param是否为空串 then echo \"You type nothing\" else echo \"Param you typed is $param\" fi done 输出 $ ./t5.sh Type sth hello Param you typed is hello You type nothing ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第七题 #!/bin/bash compare(){ string1=$1 string2=$2 if [ $string1 = $string2 ] then echo \"string1 equal to string2\" else echo \"string1 not equal to string2\" fi if [ $string1 ] then echo \"string1 not empty\" else echo \"string1 is empty\" fi if [ -n $string2 ] then echo \"string2 has a length greater than zero\" else echo \"string2 has a length equal to zero\" fi } while [ 1 ] do echo \"Input str1: \" read str1 echo \"Input str2: \" read str2 compare $str1 $str2 done 将字符比较逻辑封装到一个函数中 openssl rand -base64 6 命令通过 OpenSSL 协议间接地生成 base64 编码的六位随机字符串 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:4","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第八题 #!/bin/bash compare(){ dir=$1 file=$2 if [ -d $dir ] then echo \"dir is a directory\" else echo \"dir is not a directory\" fi if [ -f $file ] then echo \"file is a regular file\" else echo \"file is not a regular file\" fi if [ -r $file ] then echo \"file has read permissions\" else echo \"file does not have read permissions\" fi if [ -w $file ] then echo \"file has write permissions\" else echo \"file does not have write permissions\" fi if [ -x $dir ] then echo \"dir has execute permissions\" else echo \"dir does not have execute permissions\" fi } while [ 1 ] do echo \"Input dir name: \" read dir echo \"Input file name: \" read file compare $dir $file done ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:5","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第十一题 什么叫 “显示由位置参数指定的文件类型和操作权限”？ #!/bin/bash # 用户主目录 home=~ echo \"HOME is $home\" # 环境变量 IFS=$IFS':' IFS=':' # 将\":\"视为分隔符 echo \"PATH are: \" for folder in $PATH do echo \" $folder:\" done judge_file_type(){ if [ -d $1 ] then echo \"$1is a directory\" else echo \"$1is not a directory\" fi if [ -f $1 ] then echo \"$1is a regular file\" else echo \"$1is not a regular file\" fi } judge_file_permission(){ if [ -r $1 ] then echo \"$1has read permissions\" else echo \"$1does not have read permissions\" fi if [ -w $1 ] then echo \"$1has write permissions\" else echo \"$1does not have write permissions\" fi if [ -x $1 ] then echo \"$1has execute permissions\" else echo \"$1does not have execute permissions\" fi } for filename in $@ do echo \"checking $filename...\" if [ -e $filename ] then judge_file_type $filename judge_file_permission $filename else echo \"$filenamedoes not exist\" fi done 输出 $ ./t11.sh t4.sh t8.sh abc HOME is /home/ubuntu PATH are: /home/ubuntu/.vscode-server/bin/6cba118ac49a1b88332f312a8f67186f7f3c1643/bin: /home/ubuntu/.local/bin: /home/ubuntu/.vscode-server/bin/6cba118ac49a1b88332f312a8f67186f7f3c1643/bin: /usr/local/sbin: /usr/local/bin: /usr/sbin: /usr/bin: /sbin: /bin: /usr/games: /usr/local/games: checking t4.sh... t4.sh is not a directory t4.sh is a regular file t4.sh has read permissions t4.sh has write permissions t4.sh has execute permissions checking t8.sh... t8.sh is not a directory t8.sh is a regular file t8.sh has read permissions t8.sh has write permissions t8.sh has execute permissions checking abc... abc does not exist ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:1:6","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"讨论 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第一题 Linux 的 shell 有什么特点？ Shell 是一种弱类型的脚本语言，需要一个能解释执行的脚本解释器 Shell 提供了顺序流程控制、条件控制、循环控制等功能，可以把已有命令组合构成新的命令 Shell 提供了许多内置命令，不需要创建新的进程 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第二题 怎样进行 shell 编程？如何运行？有什么条件？ Shell 编程只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以进行 运行 shell 脚本前，需要设置脚本的运行权限 chmod +x ./test.sh # 使脚本具有执行权限 ./test.sh # 执行脚本 或者作为解释器的一个参数运行解释器 /bin/sh test.sh shell 脚本的后缀名几乎是可以任意的或者没有后缀名，一般命名为 xxx.sh 是为了看起来更直观 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第三题 vi 编辑程序有几种工作方式？查找有关的详细资料，熟练掌握屏幕编辑方式、转移命令方式以及末行命令的操作。学习搜索、替换字符、字和行，行的复制、移动以及在 vi 中执行 Shell 命令的方式 工作方式 正常模式（Normal-mode) 正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作 插入模式（Insert-mode) 在命令模式下按下 i 就进入了插入模式，进入编辑状态，通过键盘输入内容 可视模式（Visual-mode） 在正常模式按下 v, V, \u003cCtrl\u003e+v，可以进入可视模式。 可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便 操作 命令操作整理：https://trouvaille0198.github.io/Notes/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/Vim.html 在 vi 中执行 shell 命令 :!command :r !command（将命令结果插入到当前行的下一行） ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:2:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"第四题 编写一个具有以下功能的 Shell 程序 把当前目录下的文件目录信息输出到文件 filedir.txt 中； 在当前目录下建立一个子目录，目录名为 testdir2 ； 把当前目录下的所有扩展名为 c 的文件以原文件名复制到子目录 testdir2 中； 把子目录中的所有文件的存取权限改为不可读。（提示：用 for 循环控制语句实现，循环的控制列表用 ’ls’ 产生。） 再把子目录 testdir2 中所有文件的目录信息追加到文件 filedir.txt 中； 把你的用户信息追加到文件 filedir.txt 中； 分屏显示文件 filedir.txt #!/bin/bash # 创建filedir.txt if [ -f \"filedir.txt\" ] then rm -f filedir.txt fi touch filedir.txt # 把当前目录下的文件目录信息输出到文件 filedir.txt 中 echo \"current files: \" \u003e\u003e filedir.txt ls -l \u003e\u003e filedir.txt # 创建testdir2 if [ -d \"testdir2\" ] then rm -rf testdir2 fi mkdir testdir2 # 把当前目录下的所有扩展名为c的文件以原文件名复制到子目录testdir2中 cp ./*c testdir2/ # 把子目录中的所有文件的存取权限改为不可读 for filename in `ls testdir2` do chmod -r \"testdir2/$filename\" done # echo \"Check file permissions\" # ls -lh testdir2/ # 把子目录testdir2中所有文件的目录信息追加到文件filedir.txt中 echo -e \"\\nfiles in testdir2: \" \u003e\u003e filedir.txt ls -l testdir2/ \u003e\u003e filedir.txt # 把用户信息追加到文件 filedir.txt 中 echo -e \"\\nUser info: \" \u003e\u003e filedir.txt who -a \u003e\u003e filedir.txt # 分页显示 cat filedir.txt | less ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/ex6/:2:4","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/ex6/"},{"categories":null,"content":"实验一 import enum import random from typing import List class State(str, enum.Enum): W = 'W' R = 'R' F = 'F' class PCB(): def __init__(self, pid): self.pid: int = pid # 进程标识数 self.priority: int = random.randint(1, 10) # 优先数/轮转时间片数，越大越优先 self.run_time: int = 0 # 已占用CPU的时间片数 self.total_time: int = random.randint(1, 20) # 总共需要的时间片数 self.state: State = State.W # 进程状态 @property def need_time(self) -\u003e int: return self.total_time - self.run_time class Dispatcher(): def __init__(self, process_num: int): self.process_num = process_num self.processes: List[PCB] = [PCB(i+1) for i in range(process_num)] @property def active_processes(self): return [p for p in self.processes if p.state != State.F] @property def active_processes_sort_by_pid(self): \"\"\" 进程按pid升序排序 \"\"\" return sorted(self.active_processes, key=lambda p: p.pid) @property def active_processes_sort_by_priority(self): \"\"\" 进程按优先级降序排序 \"\"\" return sorted(self.active_processes, key=lambda p: p.priority, reverse=True) def show_table_PSA(self): if not self.active_processes: return print('-----------------------------------------------------') print(\"{:15}\\t{}\".format('ID', '\\t'.join([str(p.pid) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Priority', '\\t'.join([str(p.priority) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Run time', '\\t'.join([str(p.run_time) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Need time', '\\t'.join([str(p.need_time) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('State', '\\t'.join([p.state for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Next', '\\t'.join([str(p.pid) for p in self.active_processes_sort_by_priority]))) def show_table_RR(self): if not self.active_processes: return print('-----------------------------------------------------') print(\"{:15}\\t{}\".format('ID', '\\t'.join([str(p.pid) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Priority', '\\t'.join([str(p.priority) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Run time', '\\t'.join([str(p.run_time) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Need time', '\\t'.join([str(p.need_time) for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('State', '\\t'.join([p.state for p in self.active_processes_sort_by_pid]))) print(\"{:15}\\t{}\".format('Next', '\\t'.join([str(p.pid) for p in self.active_processes]))) def PSA_dispatch(self): \"\"\" 可抢占优先级调度，每运行一个时间片优先数减3 \"\"\" print(\"{:15}\\t{}\".format('Waiting queue', '\\t'.join([str(p.pid) for p in self.active_processes_sort_by_priority]))) time_chip: int = 0 while self.active_processes: time_chip += 1 p: PCB = self.active_processes_sort_by_priority[0] # 取优先级最高者 p.state = State.R p.run_time += 1 p.priority -= 3 # 运行次数越多优先级越小 self.show_table_PSA() if p.need_time == 0: p.state = State.F else: p.state = State.W def RR_dispatch(self): \"\"\" 轮转调度 \"\"\" print(\"{:15}\\t{}\".format('Waiting queue', '\\t'.join([str(p.pid) for p in self.active_processes_sort_by_pid]))) time_chip: int = 0 while self.active_processes: p: PCB = self.active_processes[0] # 取优先级最高者 p.state = State.R time_chip += 1 p.run_time += 1 if p.need_time == 0: p.state = State.F elif len(self.active_processes) != 1 and p.run_time % p.priority == 0: p.state = State.W self.processes.remove(p) self.processes.append(p) self.show_table_RR() if __name__ == \"__main__\": dispatcher = Dispatcher(3) dispatcher.PSA_dispatch() dispatcher.RR_dispatch() // PSA'n RR // How to compile: g++ -o ex1.o ex1.cpp #include \u003ccstdio\u003e#include \u003ccstdlib\u003e#include \u003clist\u003e#include \u003ciostream\u003e using namespace std; enum Status { W, R, F }; struct PCB { int pid; //进程标识数 int priority; //优先数/轮转时间片数 int runTime; //已占用CPU的时间片数 int needTime; //需要的时间片数 Status status; //进程状态 }; list\u003cPCB\u003e init(int n) { list\u003cPCB\u003e proList; for (int i = 1; i \u003c= n; i++) { // 随机生成进程 PCB process; process.pid = i; process.priority = rand() % 10 + 1; process.runTime = 0; //已运","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex1/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex1/"},{"categories":null,"content":"实验二 import random from functools import reduce from typing import List import copy MAX_RESOURCE_SIZE: int = 10 class Process(): def __init__(self, index: int, resource_type_num: int, max: List[int], requests: List[List[int]]): self.index = index self.resource_type_num = resource_type_num # 最大需求 self.max: list[int] = max # 已分配 self.allocation: list[int] = [0 for _ in range(resource_type_num)] # 是否完成 self.is_done = False self.is_blocked = False self.requests: List[List[int]] = requests self.step = 0 # 请求步骤 @property def need(self) -\u003e List[int]: \"\"\" 需求 \"\"\" return list(map(lambda x, y: x-y, self.max, self.allocation)) def request(self) -\u003e List[int]: \"\"\" 发出资源请求 \"\"\" return self.requests[self.step] def release_all_resources(self): self.allocation = [0 for _ in range(self.resource_type_num)] class AllocationApp(): \"\"\" 分配模拟程序 \"\"\" def __init__(self, resource_type_num: int, process_num: int, available: List[int], p_max: List[List[int]], p_requests: List[List[List[int]]]): # 进程实例列表 self.ori_processes: List[Process] = [ Process(i, resource_type_num, p_max[i], p_requests[i]) for i in range(process_num)] # 初始资源总量列表 self.ori_available: List[int] = available @property def processes(self) -\u003e List[Process]: \"\"\" 未完成的资源实例列表 \"\"\" return [p for p in self.ori_processes if not p.is_done] @property def not_blocked_processes(self) -\u003e List[Process]: \"\"\" 未完成且未阻塞的资源实例列表 \"\"\" return [p for p in self.ori_processes if not p.is_done and not p.is_blocked] @property def max(self) -\u003e List[List[int]]: \"\"\" 最大需求 \"\"\" return [process.max for process in self.processes] @property def need(self) -\u003e List[List[int]]: \"\"\" 需求 \"\"\" return [process.need for process in self.processes] @property def allocation(self) -\u003e List[List[int]]: \"\"\" 已分配 \"\"\" return [process.allocation for process in self.processes] @property def available(self) -\u003e List[int]: \"\"\" 剩余资源 \"\"\" if self.allocation: allocated = reduce(lambda x, y: list( map(lambda a, b: a+b, x, y)), self.allocation) return list(map(lambda x, y: x-y, self.ori_available, allocated)) else: return self.ori_available def is_all_finished(self) -\u003e bool: \"\"\" 进程是否全部结束 \"\"\" return True if len(self.processes) == 0 else False def is_all_blocked(self) -\u003e bool: \"\"\" 进程是否全部阻塞 \"\"\" return True if False not in [p.is_blocked for p in self.processes] else False def judge_request_n_need(self, process: Process, request: list[int]) -\u003e bool: \"\"\" 判断请求是否小于需求 \"\"\" difference = list(map(lambda x, y: True if x \u003e= y else False, process.need, request)) if False not in difference: return True else: return False def judge_request_n_available(self, request: list[int]) -\u003e bool: \"\"\" 判断请求是否小于资源量 \"\"\" difference = list(map(lambda x, y: True if x \u003e= y else False, self.available, request)) if False not in difference: return True else: return False def try_allocate(self, p: Process, request: list[int]): \"\"\" 试分配 \"\"\" p.allocation = list( map(lambda x, y: x+y, p.allocation, request)) available = copy.deepcopy(self.available) allocation = copy.deepcopy(self.allocation) need = copy.deepcopy(self.need) p.allocation = list( map(lambda x, y: x-y, p.allocation, request)) # # 减少已有资源 # available = list(map(lambda x, y: x-y, available, request)) # # 增加进程 p的已有资源 # allocation[p.index] = list( # map(lambda x, y: x+y, allocation[p.index], request)) # # 减少进程 p的需求 # need[p.index] = list( # map(lambda x, y: x-y, need[p.index], request)) return available, allocation, need def allocate(self, p: Process, request: list[int]): \"\"\" 正式为请求分配资源 \"\"\" # 增加进程 p的已有资源 p.allocation = list( map(lambda x, y: x+y, p.allocation, request)) # 进程 p的需求need会自动减少 # 修改进程实例参数 p.step += 1 if p.step == len(p.requests): print(\"进程 {}运行结束\".format(p.index+1)) p.is_done = True p.release_all_resources() def banker_check(self, available: List[List[int]], allocation: List[List[int]], need: List[List[int]]) -\u003e bool: \"\"\" 银行家算法，判断系统是否处于安全状态 \"\"\" work = copy.deepcopy(available) finish = [False for _ in range(len(self.processes))] while True: for i in range(len(self.processes)): # 找到一个可分配进程 if finish[i] == False \\ and False not in map(lambd","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex2/"},{"categories":null,"content":"实验三 请求页式存储管理 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"实验目的与要求 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"目的 近年来，由于大规模集成电路（LSI）和超大规模集成电路（VLSI）技术的发展，使存储器的容量不断扩大， 价格大幅度下降。但从使用角度看，存储器的容量和成本总受到一定的限制。 所以，提高存储器的效率始终是操作 系统研究的重要课题之一。虚拟存储技术是用来扩大内存容量的一种重要方法。学生应独立地用高级语言编写几个常用的存储分配算法，并设计一个存储管理的模拟程序，对各种算法进行分析比较，评测其性能优劣，从而加深对 这些算法的了解。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:1:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"要求 为了比较真实地模拟存储管理，可预先生成一个大致符合实际情况的指令地址流。然后模拟这样一种指令序列的执行来计算和分析各种算法的访问命中率。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:1:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"实验环境 操作系统：windows 10 编程语言：GoLang 1.17.5 IDE：JetBrain GoLand 2021.3.1 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"实验内容及其设计与实现 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"指令地址流生成 模拟生成 按以下规则模拟真实情况的指令地址流： 50% 的指令顺序执行。 25% 的指令均匀散布在前地址部分。 25% 的指令均匀散布在后地址部分 // getWeightedChooser // @Description: 获取指令地址分布权重表 // @return *utils.Chooser func getWeightedChooser() *utils.Chooser { chooser, _ := utils.NewChooser( utils.NewChoice(\"front\", 25), utils.NewChoice(\"end\", 25), utils.NewChoice(\"prev\", 50), ) return chooser } // AddressStream // @description 地址流 type AddressStream struct { length int addresses []int } // NewAddressStream // @param addressNum 指令个数 // @param virtualMemorySize 虚存大小 以k为单位 func NewAddressStream(addressNum int, virtualMemorySize int) *AddressStream { virtualMemorySize *= 1024 rs := rand.New(rand.NewSource(time.Now().UTC().UnixNano())) // 随机数种子 addresses := make([]int, addressNum) chooser := getWeightedChooser() addresses[0] = rs.Intn(virtualMemorySize) for i := 1; i \u003c addressNum; i++ { initForm := chooser.PickSource(rs) // 按照权重选择一项生成策略 switch initForm { case \"front\": randAddress := rs.Intn(virtualMemorySize / 2) addresses[i] = randAddress case \"end\": randAddress := rs.Intn(virtualMemorySize/2) + virtualMemorySize/2 addresses[i] = randAddress case \"prev\": addresses[i] = addresses[i-1] + 1 } } return \u0026AddressStream{length: addressNum, addresses: addresses} } // GetAddressPages // @description 获取指令地址对应的页号 // @receiver a // @param pageSize 页大小 以k为单位 // @return []int 指令的页号列表 func (a *AddressStream) GetAddressPages(pageSize int) []int { addressPages := make([]int, len(a.addresses)) for i, address := range a.addresses { addressPages[i] = address/(pageSize*1024) + 1 } return addressPages } 顺序生成的指令地址流，大都处于同一页中，符合现实情况 使用真实地址流 为了体现局部性原理，我们编写了 python 脚本，获取计算机中真实运行的进程地址 # made by 王启隆 import os import re import time import string import psutil # 统计某一个进程名所占用的内存，同一个进程名，可能有多个进程 def countProcessMemoey(processName): pattern = re.compile(r'([^\\s]+)\\s+(\\d+)\\s.*\\s([^\\s]+\\sK)') cmd = 'tasklist /fi \"imagename eq ' + processName + \\ '\"' + ' | findstr.exe ' + '\"' + processName + '\"' # findstr后面的程序名加上引号防止出现程序带有空格 result = os.popen(cmd).read() resultList = result.split(\"\\n\") pids = [] for srcLine in resultList: srcLine = \"\".join(srcLine.split('\\n')) if len(srcLine) == 0: break m = pattern.search(srcLine) if m == None: continue # 由于是查看python进程所占内存，因此通过pid将本程序过滤掉 if str(os.getpid()) == m.group(2): continue ori_mem = m.group(3).replace(',', '') ori_mem = ori_mem.replace(' K', '') ori_mem = ori_mem.replace(r'\\sK', '') memEach = int(ori_mem) pids.append(m.group(2)) return pids if __name__ == '__main__': lis = [] pids = psutil.pids() for pid in pids: p = psutil.Process(pid) lis.append(str(p.name())) results = [] for i in lis[:50]: ProcessName = i # 进程名 results.extend(countProcessMemoey(ProcessName)) with open(\"./addrs.txt\", \"w\") as f_b: f_b.write(\",\".join(results)) 脚本最终将进程地址流保存到文件里，以便在 Go 中读取 // 采用真实地址流 f, err := ioutil.ReadFile(\"./as.txt\") if err != nil { return \u0026AddressStream{}, err } for i, addr := range strings.Split(string(f), \",\")[:addressNum] { addresses[i], err = strconv.Atoi(addr) if err != nil { panic(\"error when reading address file\") } } ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"页面置换算法 事先准备 定义一个页式管理器，接收指定的指令个数、虚存大小、页大小和内存容量，生成指令地址流 // PageReplacer // @description 请求页式管理 其中实现了多种页面置换算法 type PageReplacer struct { pageSize int internalSize int addressPage []int } // NewPageReplacer // @param addressNum 指令个数 // @param virtualMemorySize 虚存大小 以k为单位 // @param pageSize 页大小 以k为单位 // @param internalSize 内存能容纳页的个数 func NewPageReplacer( addressNum int, virtualMemorySize int, pageSize int, internalSize int) *PageReplacer { addressStream := NewAddressStream(addressNum, virtualMemorySize) addressPage := addressStream.GetAddressPages(pageSize) return \u0026PageReplacer{pageSize: pageSize, addressPage: addressPage, internalSize: internalSize} } OPT 算法 最佳置换算法，发生缺页时，淘汰以后永不使用或是在未来最迟被访问到的页面。OPT 算法要求事先知晓未来所有的指令流顺序，是一种最优算法，但是在实际情况中不可能实现。 模拟实现下，发生缺页且内存已满时，程序将遍历之后的地址流，在驻留内存页号中选择一个于未来最迟被访问（或永不访问）的页号，将其置换出内存。 func (r PageReplacer) OPT() float32 { internalPages := make([]int, 0) // 记录内存中的页面 failCount := 0 // 未命中次数 for i, pageNo := range r.addressPage { if !utils.IsContainInt(internalPages, pageNo) { // 未命中 failCount++ if len(internalPages) == r.internalSize { // 内存已满 欲淘汰一页 latestPageIndex := -1 // 记录内存页号列表中在未来最迟访问的页号索引 internalPagesCopy := make([]int, r.internalSize) copy(internalPagesCopy, internalPages) for _, afterPageNo := range r.addressPage[i+1:] { if utils.IsContainInt(internalPagesCopy, afterPageNo) { latestPageIndex, _ = utils.GetIndexInt(internalPages, afterPageNo) // 记录当前最迟访问到的页号索引 internalPagesCopy, _ = utils.DeleteByElemInt(internalPagesCopy, afterPageNo) } } if len(internalPagesCopy) != 0 { // 内存中存在一页 其之后都不会被访问到 internalPages, _ = utils.DeleteByElemInt(internalPages, internalPagesCopy[0]) } else { internalPages, _ = utils.DeleteByIndexInt(internalPages, latestPageIndex) } } internalPages = append(internalPages, pageNo) } } return 1 - float32(failCount)/float32(len(r.addressPage)) } LRU 算法 最近最久未使用算法，该算法选择最近最久未使用的页面予以淘汰。 模拟程序采用栈来实现页面的置换。命中时，将命中页从栈中移出（这显然不符合严格的栈操作），放入栈顶；当缺页发生且栈满时，将栈底页弹出，放入新页面至栈顶。 func (r PageReplacer) LRU() float32 { internalPages := make([]int, 0) // 记录内存中的页面 failCount := 0 // 未命中次数 for _, pageNo := range r.addressPage { if !utils.IsContainInt(internalPages, pageNo) { // 未命中 failCount++ if len(internalPages) == r.internalSize { // 内存已满 将栈底页面淘汰 internalPages, _ = utils.DeleteByIndexInt(internalPages, 0) } internalPages = append(internalPages, pageNo) } else { // 命中 将命中页面提升至栈顶 internalPages, _ = utils.DeleteByElemInt(internalPages, pageNo) internalPages = append(internalPages, pageNo) } } return 1 - float32(failCount)/float32(len(r.addressPage)) } FIFO 算法 先进先出方法，比较简单，使用队列实现即可 func (r PageReplacer) FIFO() float32 { internalPages := make([]int, 0) // 记录内存中的页面 failCount := 0 // 未命中次数 for _, pageNo := range r.addressPage { if !utils.IsContainInt(internalPages, pageNo) { // 未命中 failCount++ if len(internalPages) == r.internalSize { // 内存已满 将队头页面淘汰 internalPages, _ = utils.DeleteByIndexInt(internalPages, 0) } internalPages = append(internalPages, pageNo) } } return 1 - float32(failCount)/float32(len(r.addressPage)) } ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"算法命中率比较 内存容量从 4 页到 32 页，页面尺寸从 1k 到 8k，模拟页面置换的过程，得出三种算法的命中率 func TestAlphaReader(t *testing.T) { virtualMemorySize := 32 addressNum := 255 fmt.Printf( \"%-10s %-12s %-10s %-10s %-10s \\n\", \"PageSize\", \"MemorySize\", \"OPT\", \"LRU\", \"FIFO\") for i := 0; i \u003c 7; i++ { internalSize := (i + 1) * 4 // 每次翻四倍 for j := 0; j \u003c 8; j++ { pageSize := j + 1 r := NewPageReplacer( addressNum, virtualMemorySize, pageSize, internalSize) r.DisplayResult() } fmt.Println() } } 可以看到，LRU 算法的命中率代表了算法上限，LRU 与 FIFO 算法效率相近。 随着内存容量和单页大小的增大，命中率通常也是越来越高的。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:3:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"收获与体会 本次实验模拟了三种页面置换算法，我对请求页式管理的原理内容有了进一步的理解与体会。我首先使用 Python 编写程序，随后尝试使用 GoLang 重构代码。GoLang 相对来说更加精简，但是不那么“面向对象”，同时缺乏优质的语法糖，许多细节（如切片的查询、插入、删除，根据权重选择条目的算法）需要自己来实现，这花了我不少精力，这也对这门语言有了更深刻的理解。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex3/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex3/"},{"categories":null,"content":"实验四 文件操作与管理 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"实验目的与要求 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"目的 随着社会信息量的极大增长，要求计算机处理的信息与日俱增，涉及到社会生活的各个方面。因此，文件管理是操作系统的一个极为重要的组成部分。 学生应独立地用高级语言编写和调试一个简单的文件系统，模拟文件管理的工作过程。从而对各种文件操作命令的实质内容和执行过程有比较深入的了解，掌握它们的实施方法，加深理解课堂上讲授过的知识。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:1:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"要求 设计一个 n 个用户的文件系统，每个用户最多可保存 m 个文件。 限制用户在一次运行中只能打开 l 个文件。 系统应能检查打入命令的正确性，出错要能显示出错原因。 对文件必须设置保护措施，如只能执行，允许读、允许写等。在每次打开文件时，根据本次打开的要求，再次设置保护级别，即可有二级保护。 对文件的操作至少应有下述几条命令： creat 建立文件。 delete 删除文件。 open 打开文件。 close 关闭文件。 read 读文件。 write 写文件。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:1:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"实验环境 操作系统：windows 11 编程语言：GoLang 1.17.5 IDE：JetBrain GoLand 2021.3.1 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"实验内容及其设计与实现 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"设计思路 实验的文件系统应有如下特点 文件系统应拥有多用户模式 文件的打开数量应有限制 文件的读写应被保护码所限制；文件在打开时应用有用户额外设置的二级保护码 文件的修改信息最终在退出后应保存于外存；程序异常退出不应保存修改结果 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"数据结构 针对单个文件的管理，本实验设计了 UserFileDir 用户文件目录来记录一个文件的基本信息 // UserFileDir 用户文件目录 type UserFileDir struct { Name string `json:\"name\"` ProCode string `json:\"proCode\"` // 保护码 Len int `json:\"len\"` } 结构体的设计倾向于 json 格式，这方便了文件的保存 针对单个用户的文件管理，本实验设计了 MainFileDir 文件主目录来存放一个用户的文件列表 // MainFileDir 主文件目录 type MainFileDir struct { Owner string `json:\"owner\"` UserFileDirs []*UserFileDir `json:\"userFileDirs\"` } 可以看到 MainFileDir 中记录着指向用户文件的指针数组 针对多个用户的文件管理，本实验设计了 FileSystem 文件系统来保存多个用户的信息 type FileSystem struct { // 记录当前用户的信息 UserName string // 用户名 OwnerMainFileDir *MainFileDir // 用户的mfd AccessFileDirs []*AccessFileDir // 正在运行的文件目录 // 记录一些全局信息 MainFileDirs []*MainFileDir // 所有mfd 用于程序退出时更新外存内容 FilePath string // 外存地址 } 由于一次程序运行时的所有操作皆在内存中进行，这保证了当程序异常退出时，修改结果将不会保存到外存中去。 程序开始时，需要新建一个 FileSystem 实例并等待用户登录，这通过 NewFileSystem() 来实现。 // NewFileSystem 新建文件管理系统 读取用户与用户文件 func NewFileSystem(filePath string) (*FileSystem, error) { // 读取用户和文件信息 fh, err := os.Open(filePath) jsonData, err := ioutil.ReadAll(fh) ... // 解析json数据到MFD中 err = json.Unmarshal(jsonData, \u0026mainFileDirs) ... // 获取来自标准输入的用户名 并判断用户名是否注册 var userName string ... return ... } 一次进程将只对一个用户的文件进行操作。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"操作实现 所有操作都提供了类命令行语法，便于执行。 查看文件 case SHOW: if mode == \"-o\" { f.ShowOpeningFiles() } else { f.ShowFiles() } 打印文件的基本信息 打印处于打开状态的文件信息 创建 case CREATE: err = f.Create() if err != nil { fmt.Println(err) } 用户拥有的最大文件数量被设置为 10 个，在此被检测。 if len(f.OwnerMainFileDir.UserFileDirs) \u003e 10 { return errors.New(\"the amount of files is up to 10, cannot create new file\") } 删除 case DELETE: err = f.Delete() if err != nil { fmt.Println(err) } 删除仅仅删除指针，外存的删除在程序正常退出时执行 需要注意的是，如果删除的文件处于打开状态，那么 FileSystem 中的 AccessFileDirs 中的相关内容也要被删除 // 文件可能被打开 故要遍历一遍afd for i, afd := range f.AccessFileDirs { if afd.FileDir.Name == name { f.AccessFileDirs = append(f.AccessFileDirs[:i], f.AccessFileDirs[i+1:]...) break } } 打开 case OPEN: err = f.Open() if err != nil { fmt.Println(err) } 打开操作将 检查已打开文件的数量，超过 5 则不允许打开 在 FileSystem 中 AccessFileDirs 添加被打开文件 ufd 的指针 等待用户提供二级保护码 返回打开文件的编号 Number 关闭 case CLOSE: err = f.Close() if err != nil { fmt.Println(err) } 成功关闭 失败关闭 读 case READ: err = f.Read() if err != nil { fmt.Println(err) } 文件读取的限制条件 文件处于打开状态 文件二级保护码的允许读标志为 1 写 case WRITE: err = f.Write() if err != nil { fmt.Println(err) } 文件写入的限制条件与读取类似 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:3:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"收获与体会 本次实验设计了一个多用户文件系统。通过学习和实践，我对文件管理的原理有了进一步的理解与体会。文件系统的实现相对简单，但是对异常处理的要求很高，我也花了一定的功夫让各个命令互不影响地独立运行，让所有可能出现的命令排列都能完美执行。Golang 优秀的异常处理机制在很大程度上帮助了我，所有的 err 都可以上抛到顶层被检测，这样的设计虽然在某种意义上增加了代码的臃肿程度，但是换取了较高的可读性和较低的维护成本，利大于弊，这样的实践也使我对这门语言有了更深刻的理解。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/ex4/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/ex4/"},{"categories":null,"content":"基本操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"导入 from bs4 import BeautifulSoup html_doc = \"\"\" \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca href=\"http://example.com/elsie\" class=\"sister\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca href=\"http://example.com/lacie\" class=\"sister\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca href=\"http://example.com/tillie\" class=\"sister\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e \"\"\" soup = BeautifulSoup(html_doc,\"html.parser\") 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, \"html.parser\") Python的内置标准库执行速度适中文档容错能力强 Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差 lxml HTML 解析器 BeautifulSoup(markup, \"lxml\") 速度快文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, [\"lxml-xml\"])``BeautifulSoup(markup, \"xml\") 速度快唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, \"html5lib\") 最好的容错性以浏览器的方式解析文档生成HTML5格式的文档 速度慢不依赖外部扩展 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"标准缩进格式 print(soup.prettify()) 输出 \u003chtml\u003e \u003chead\u003e \u003ctitle\u003e The Dormouse's story \u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"\u003e \u003cb\u003e The Dormouse's story \u003c/b\u003e \u003c/p\u003e \u003cp class=\"story\"\u003e Once upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003e Elsie \u003c/a\u003e , \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003e Lacie \u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003e Tillie \u003c/a\u003e ; and they lived at the bottom of a well. \u003c/p\u003e \u003cp class=\"story\"\u003e ... \u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"Tag 每个标签节点就是一个Tag对象 soup.head soup.a #输出soup中的第一个a标签 soup.p.b #p下的b标签 输出 \u003chead\u003e\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e\u003c/head\u003e \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e \u003cb\u003eThe Dormouse's story\u003c/b\u003e 以下是Tag对象的部分属性 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".name 标签名属性 soup.head.name soup.a.name 输出 head a ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".string 文本内容属性 soup.head.string soup.a.string 输出 The Dormouse's story Elsie ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"[‘attributes’] 标签指定属性属性 soup.a['id'] #返回字符串 soup.a['class'] #多值属性返回list 返回列表 link1 ['sister'] 如果转换的文档是XML格式,那么tag中不包含多值属性 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:3:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".attrs soup.a.attrs 输出字典 {'href': 'http://example.com/elsie', 'class': ['sister'], 'id': 'link1'} ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:3:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"NavigableString 字符串常被包含在tag内.Beautiful Soup用 NavigableString 类来包装tag中的字符串 直接使用 .stirng 即可获取 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"将其转换为 unicode 字符串 uni_str = unicode(soup.head.string) #在python3中不适用 uni_str = str(soup.head.string) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"replace_with() tag中包含的字符串不能编辑,但是可以被替换成其它的字符串 soup.head.string.replace_with('Harry potter') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"BeautifulSoup BeautifulSoup 对象表示的是一个文档的全部内容 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".name BeautifulSoup 对象包含了一个值为 “[document]” 的特殊属性，用.name调用 soup.name 输出 '[document]' ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"Comment Comment 对象是一个特殊类型的 NavigableString 对象，是文档的注释部分 markup = \"\u003cb\u003e\u003c!--Hey, buddy. Want to buy a used parser?--\u003e\u003c/b\u003e\" soup = BeautifulSoup(markup) comment = soup.b.string type(comment) 当它出现在HTML文档中时, Comment 对象会使用特殊的格式输出 bs4.element.Comment 遍历文档树 遍历文档树，就是是从根节点 html 标签开始遍历，直到找到目标元素为止， 通过遍历文档树的方式获取标签节点可以直接通过 .标签名的方式获取 缺陷 如果要找的内容在文档的末尾，那要遍历整个文档才能找到它，速度上就慢了 只能获取到与之匹配的第一个子节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"子节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".contents Tag Tag的 .contents` 属性可以将tag的子节点以列表的方式输出 soup.body.contents soup.body.contents[1] 以列表输出 ['\\n', \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e, '\\n', \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e, '\\n', \u003cp class=\"story\"\u003e...\u003c/p\u003e, '\\n'] \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e NavigableString 字符串NavigableString没有 .contents 属性,因为字符串没有子节点 soup.head.string.cotents 报错 AttributeError: 'NavigableString' object has no attribute 'cotents' BeautifulSoup BeautifulSoup 对象本身一定会包含子节点,也就是说\u003chtml\u003e标签也是 BeautifulSoup 对象的子节点 soup.contents 输出 ['\\n', \u003chtml\u003e\u003chead\u003e\u003ctitle\u003eHarry potter\u003c/title\u003e\u003c/head\u003e \u003cbody\u003e \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e \u003c/body\u003e\u003c/html\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:7:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".children 通过tag的 .children 生成器,可以对tag的子节点进行循环 for child in soup.body.children: print(child) 输出 \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e \u003cp class=\"story\"\u003e...\u003c/p\u003e ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:7:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".descendants .contents 和 .children 属性仅包含tag的直接子节点，而.descendants 生成器可以对所有tag的子孙节点进行递归循环 for child in soup.body.descendants: print(child) 输出 \u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e \u003cb\u003eThe Dormouse's story\u003c/b\u003e The Dormouse's story \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e Once upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e Elsie , \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e Lacie and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e Tillie ; and they lived at the bottom of a well. \u003cp class=\"story\"\u003e...\u003c/p\u003e ... ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:7:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"父节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".parent 通过 .parent 属性来获取某个元素的父节点 soup.title.parent soup.title.string.parent #字符串也有父节点 type(soup.html.parent) #文档的顶层节点比如\u003chtml\u003e的父节点是 BeautifulSoup 对象 print(soup.parent) #BeautifulSoup 对象的 .parent 是None 输出 \u003chead\u003e\u003ctitle\u003eHarry potter\u003c/title\u003e\u003c/head\u003e \u003ctitle\u003eHarry potter\u003c/title\u003e bs4.BeautifulSoup None ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:8:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".parents 通过元素的 .parents 生成器可以递归得到元素的所有父辈节点 for parent in soup.b.parents: print(parent.name) 输出 p body html [document] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:8:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"兄弟节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".next_sibling 和 .previous_sibling soup.a.next_sibling #真实结果是第一个\u003ca\u003e标签和第二个\u003ca\u003e标签之间的顿号和换行符 soup.a.next_sibling.next_sibling 输出 ',\\n' \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:9:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":".next_siblings 和 .previous_siblings 通过 .next_siblings 和 .previous_siblings 生成器可以对当前节点的兄弟节点迭代输出 for sibling in soup.a.next_siblings: print(repr(sibling)) 输出 ',\\n' \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e ' and\\n' \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e ';\\nand they lived at the bottom of a well.' 搜索文档树 搜索文档树是通过指定标签名来搜索元素，另外还可以通过指定标签的属性值来精确定位某个节点元素 最常用的两个方法就是 find 和 find_all。这两个方法在 BeatifulSoup 和 Tag 对象上都可以被调用 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:9:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"过滤器 过滤器贯穿整个搜索的API。过滤器可以被用在tag的name中,节点的属性中,字符串中或他们的混合中 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"字符串 在搜索方法中传入一个字符串参数,Beautiful Soup会查找与字符串完整匹配的内容 soup.find_all('a') 输出 [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:10:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"正则表达式 Beautiful Soup会通过正则表达式的 match() 来匹配内容 下面代码找出所有名字中包含”t”的标签 import re for tag in soup.find_all(re.compile(\"t\")): print(tag.name) 输出 html title ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:10:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"列表 Beautiful Soup会将与列表中任一元素匹配的内容返回 下面代码找到文档中所有\u003ca\u003e标签和\u003cb\u003e标签 soup.find_all([\"a\", \"b\"]) 输出 [\u003cb\u003eThe Dormouse's story\u003c/b\u003e, \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:10:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"True True 可以匹配任何值 下面代码查找到所有的tag名 for tag in soup.find_all(True): print(tag.name) 输出 html head title body p b p a a a p ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:10:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"方法 如果没有合适过滤器,那么还可以定义一个方法,方法只接受一个元素参数 [4] ,如果这个方法返回 True 表示当前元素匹配并且被找到,如果不是则反回 False 下面方法校验了当前元素,如果包含 class 属性却不包含 id 属性,那么将返回 True def has_class_but_no_id(tag): return tag.has_attr('class') and not tag.has_attr('id') soup.find_all(has_class_but_no_id) 输出 [\u003cp class=\"title\"\u003e\u003cb\u003eThe Dormouse's story\u003c/b\u003e\u003c/p\u003e, \u003cp class=\"story\"\u003eOnce upon a time there were three little sisters; and their names were \u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e and \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e; and they lived at the bottom of a well.\u003c/p\u003e, \u003cp class=\"story\"\u003e...\u003c/p\u003e] 通过一个方法来过滤一类标签属性的时候, 这个方法的参数是要被过滤的属性的值, 而不是这个标签 下面的例子是找出 href 属性不符合指定正则的 a 标签 def not_lacie(href): return href and not re.compile(\"lacie\").search(href) soup.find_all(href=not_lacie) 输出 [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:10:5","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"find_all() find_all( name , attrs , recursive , string , **kwargs ) find_all() 方法搜索当前tag的所有tag子节点,并判断是否符合过滤器的条件 任意参数的值可以是任一类型的过滤器，字符串，正则表达式，列表，方法或是 True 返回列表 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"name name 参数可以查找所有名字为 name 的tag，字符串对象会被自动忽略掉 soup.find_all(\"a\") 输出 [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"keyword 如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字tag的属性来搜索 soup.find_all(id='link2') soup.find_all(\"a\",'sister',href=re.compile('^.*?la')) soup.find_all(id=True) 输出 [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] [\u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] 有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性，但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag 标识CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag soup.find_all(\"a\", class_=\"sister\") def has_six_characters(css_class): return css_class is not None and len(css_class) == 6 soup.find_all(class_=has_six_characters) #与第一种方法输出相同结果 输出 [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/tillie\" id=\"link3\"\u003eTillie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"string 通过 string 参数可以搜搜文档中的字符串内容 soup.find_all(string=\"Elsie\") #单独使用时，返回字符串 soup.find_all(\"a\", string=\"Elsie\") #与其他参数混合使用时，返回对应的Tag 输出 ['Elsie'] [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"limit find_all() 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果我们不需要全部结果,可以使用 limit 参数限制返回结果的数量 soup.find_all(\"a\", limit=2) 文档树中有3个tag符合搜索条件,但结果只返回了2个,因为我们限制了返回数量 [\u003ca class=\"sister\" href=\"http://example.com/elsie\" id=\"link1\"\u003eElsie\u003c/a\u003e, \u003ca class=\"sister\" href=\"http://example.com/lacie\" id=\"link2\"\u003eLacie\u003c/a\u003e] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"recursive 调用tag的 find_all() 方法时,Beautiful Soup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数 recursive=False soup.html.find_all(\"title\") # [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] soup.html.find_all(\"title\", recursive=False) # [] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:5","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"attrs 传入字典 css_class = soup.find_all(attrs={'class':'primaryconsumers'}) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:6","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"简写方式 find_all() 几乎是Beautiful Soup中最常用的搜索方法,所以我们定义了它的简写方法. BeautifulSoup 对象和 tag 对象可以被当作一个方法来使用,这个方法的执行结果与调用这个对象的 find_all() 方法相同 下面代码是等价的 soup.find_all(\"a\") soup(\"a\") soup.title.find_all(string=True) soup.title(string=True) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:11:7","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"find() find( name , attrs , recursive , string, **kwargs ) find() 方法将返回文档中符合条件的第一个tag 下面两行代码是等价的 soup.find_all('title', limit=1) # [\u003ctitle\u003eThe Dormouse's story\u003c/title\u003e] soup.find('title') # \u003ctitle\u003eThe Dormouse's story\u003c/title\u003e 唯一的区别是 find_all() 方法的返回结果是值包含一个元素的列表,而 find() 方法直接返回结果 find_all() 方法没有找到目标是返回空列表, find() 方法找不到目标时,返回 None soup.head.title 是tag的名字方法的简写.这个简写的原理就是多次调用当前tag的 find() 方法 soup.head.title # \u003ctitle\u003eThe Dormouse's story\u003c/title\u003e soup.find(\"head\").find(\"title\") # \u003ctitle\u003eThe Dormouse's story\u003c/title\u003e ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:12:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"其他方法 find_parents()和find_parent() 前者返回所有祖先节点，后者返回直接父节点。 p_story = soup.find(class_='story') for i in p_story.find_parents(): print(i.name) 输出 body html [document] find_next_siblings()和find_next_sibling() 前者返回后面所有的兄弟节点，后者返回后面第一个兄弟节点。 find_previous_siblings()和find_previous_sibling() 前者返回前面所有的兄弟节点，后者返回前面第一个兄弟节点。 find_all_next()和find_next() 前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点。 find_all_previous()和find_previous() 前者返回节点后所有符合条件的节点，后者返回第一个符合条件的节点 CSS选择器 在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag 其他 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:13:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"复制Beautiful Soup对象 copy.copy() 方法可以复制任意 Tag 或 NavigableString 对象 import copy p_copy = copy.copy(soup.p) 复制后的对象跟与对象是相等的, 但指向不同的内存地址 print soup.p == p_copy # True print soup.p is p_copy # False ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:14:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"get_text() 获取标签里面内容，除了可以使用 .string 之外，还可以使用 get_text 方法，不同的地方在于前者返回的一个 NavigableString 对象，后者返回的是 unicode 类型的字符串。 实际场景中我们一般使用 get_text 方法获取标签中的内容。 soup.head.get_text() # 'Harry potter' ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/beautifulsoup4/:15:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/beautifulsoup4/"},{"categories":null,"content":"初始化 from pyquery import PyQuery as pq ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"字符初始化 html = ''' \u003cdiv class=\"wrap\"\u003e \u003cdiv id=\"container\"\u003e \u003cul class=\"list\"\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e \u003c/div\u003e ''' doc = pq(html) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"URL初始化 doc = pq(url=\"http://www.baidu.com\",encoding='utf-8') # 或 doc = pq(requests.get('http://cuiqingcai.com').text) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"文件初始化 doc = pq(filename='demo.html') 最常用的初始化方式还是以字符串形式传递 CSS选择器 名称 例子 说明 .class .color 选择class=‘color’的所有元素 #id #info 选择id=‘info’的所有元素 * * 选择所有元素 element p 选择所有的p元素 element, element div, p 选择所有的div元素和p元素 element element div p 选择div标签内的所有p元素 element \u003e element div \u003e p 选择所有父级是 div 元素的 p 元素 [attribute] [target] 选择带有target属性的所有元素 [attribute=value] [target=_blank] 选择target=_blank的所有元素 查找节点 pyquery 的选择结果可能是多个节点，也可能是单个节点，类型都是 PyQuery 类型，并没有返回像 Beautiful Soup 那样的列表。 所有查找结点的方法都可以加入CSS选择器 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"子节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"子孙节点 items.find() 首先，我们选取 class 为 list 的节点，然后调用了 find() 方法，传入 CSS 选择器，选取其内部的 li 节点，最后打印输出。 find() 方法会将符合条件的所有节点选择出来，结果的类型是 PyQuery 类型。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"直接子节点 items.children() ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"父节点 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"直接父节点 用 parent 方法来获取某个节点的父节点 items.parent() ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"祖先节点 items.parents() ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:5:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"兄弟节点 选择 class 为 list 的节点内部 class 为 item-0 和 active 的节点 items.siblings() 遍历节点 对于单个节点来说，可以直接打印输出，也可以直接转成字符串 doc = pq(html) li = doc('.item-0.active') print(li) print(str(li)) 输出 \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e 对于多个节点的结果，需要遍历来获取 doc = pq(html) lis = doc('li').items() print(type(lis)) for li in lis: print(li, type(li)) 输出 \u003cclass 'generator'\u003e \u003cli class=\"item-0\"\u003efirst item\u003c/li\u003e \u003cclass 'pyquery.pyquery.PyQuery'\u003e \u003cli class=\"item-1\"\u003e\u003ca href=\"link2.html\"\u003esecond item\u003c/a\u003e\u003c/li\u003e \u003cclass 'pyquery.pyquery.PyQuery'\u003e \u003cli class=\"item-0 active\"\u003e\u003ca href=\"link3.html\"\u003e\u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e\u003c/a\u003e\u003c/li\u003e \u003cclass 'pyquery.pyquery.PyQuery'\u003e \u003cli class=\"item-1 active\"\u003e\u003ca href=\"link4.html\"\u003efourth item\u003c/a\u003e\u003c/li\u003e \u003cclass 'pyquery.pyquery.PyQuery'\u003e \u003cli class=\"item-0\"\u003e\u003ca href=\"link5.html\"\u003efifth item\u003c/a\u003e\u003c/li\u003e \u003cclass 'pyquery.pyquery.PyQuery'\u003e 调用 items() 方法后，会得到一个生成器，遍历一下，就可以逐个得到 li 节点对象了，它的类型也是 PyQuery 类型 获取信息 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"获取属性 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"单个节点 attr() a = doc('.item-0.active a') print(a.attr('href')) 选中 class 为 item-0 和 active 的 li 节点内的 a 节点,调用 attr 方法。在这个方法中传入属性的名称，就可以得到这个属性值了 link3.html attr属性 print(a.attr.href) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:7:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"多个节点 当返回结果包含多个节点时，调用 attr 方法，只会得到第一个节点的属性。需要遍历获得 for item in a.items(): print(item.attr('href')) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:7:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"获取文本 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"单个节点 text() a = doc('.item-0.active a') print(a.text()) 首先选中一个 a 节点，然后调用 text 方法，就可以获取其内部的文本信息 third item html() 获取这个节点内部的 HTML 文本， print(li.html()) 输出 \u003cspan class=\"bold\"\u003ethird item\u003c/span\u003e ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:8:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"多个节点 若结果是多个节点： html 方法返回的是第一个 节点的内部 HTML 文本（需要遍历每个节点） text 则返回了所有的 li 节点内部的纯文本，中间用一个空格分割开，即返回结果是一个字符串（不需要遍历） DOM操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:8:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"addClass()、removeClass() 添加，移除class标签 items.removeClass('active') items.addClass('active') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"attr、text、html items.attr('name', 'link') #属性名，属性值 items.text('changed item') items.html('\u003cspan\u003echanged item\u003c/span\u003e') ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"remove 例如，想提取 Hello, World 这个字符串，而不要 p 节点内部的字符串 html = ''' \u003cdiv class=\"wrap\"\u003e Hello, World \u003cp\u003eThis is a paragraph.\u003c/p\u003e \u003c/div\u003e ''' from pyquery import PyQuery as pq doc = pq(html) wrap = doc('.wrap') wrap.find('p').remove() print(wrap.text()) 首先选中 p 节点，然后调用了 remove() 方法将其移除，然后这时 wrap 内部就只剩下 Hello, World 这句话了，然后再利用 text() 方法提取即可 Hello, World ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/pyquery/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/pyquery/"},{"categories":null,"content":"正则表达式 清晰易懂版 单字符匹配 字符 功能 . 匹配任意1个字符（除了\\n） [ ] 匹配[ ]中列举的字符 \\d 匹配数字，即0-9 \\D 匹配非数字，即不是数字 \\s 匹配空白，即 空格，tab键 \\S 匹配非空白 \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 匹配多个字符的相关格式 字符 功能 * 匹配前一个字符出现0次或者无限次，即可有可无 + 匹配前一个字符出现1次或者无限次，即至少有1次 ? 匹配前一个字符出现1次或者0次，即要么有1次，要么没有 {m} 匹配前一个字符出现m次 {m,n} 匹配前一个字符出现从m到n次 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"概念 正则表达式 (regular expression) 描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"符号 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号 字符 描述 [ABC] 匹配 […] 中的所有字符，例如 [aeiou] 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。 [^ABC] 匹配除了 […] 中字符的所有字符，例如 [^aeiou] 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母 [A-Z] [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母 . 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于 [^\\n\\r] [\\s\\S] 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，包括换行。 \\w 匹配字母、数字、下划线。等价于 [A-Za-z0-9_] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"非打印字符 字符 描述 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"特殊字符 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符\"转义\"，即，将反斜杠字符**\\** 放在它们前面 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。 * 匹配前面的子表达式零次或多次。 + 匹配前面的子表达式一次或多次。 . 匹配除换行符 \\n 之外的任何单字符。 [ 标记一个中括号表达式的开始。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ’n’ 匹配字符 ’n’。’\\n’ 匹配换行符。序列 ‘\\’ 匹配 “\"，而 ‘(’ 则匹配 “(\"。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。 { 标记限定符表达式的开始。 | 指明两项之间的一个选择。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 ***** 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n \u003c= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"定位符 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意 不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 \\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项 对于 \\B 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:5","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"选择 用圆括号 () 将所有选择项括起来，相邻的选择项之间用 | 分隔。 () 表示捕获分组，() 会把每个分组里的匹配的值保存起来， 多个匹配值可以通过数字 n 来查看(n 是一个数字，表示第 n 个捕获组的内容) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:2:6","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"re 常用方法 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"match() re.match(pattern, string, flags=0) match() 尝试从字符串的起始位置匹配正则表达式，若匹配，就返回匹配成功的结果；若不匹配，返回 None import re content = 'Hello 123 4567 World_This is a Regex Demo' print(len(content)) result = re.match('^Hello\\s\\d\\d\\d\\s\\d{4}\\s\\w{10}', content) print(result) print(result.group()) print(result.span()) 输出 41 \u003c_sre.SRE_Match object; span=(0, 25), match='Hello 123 4567 World_This'\u003e Hello 123 4567 World_This (0, 25) 步骤 在match()方法中，第一个参数传入了正则表达式，第二个参数传入了要匹配的字符串 group()方法可以输出匹配到的内容，结果是Hello 123 4567 World_This span()方法可以输出匹配的范围，结果是(0, 25) 也可这样写 result = re.match('^Hello.*Demo$', content) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"group() 使用 () 括号将想提取的子字符串括起来 import re content = 'Hello 1234567 World_This is a Regex Demo' result = re.match('^Hello\\s(\\d+)\\sWorld', content) print(result) print(result.group()) print(result.group(1)) print(result.span()) 输出 \u003c_sre.SRE_Match object; span=(0, 19), match='Hello 1234567 World'\u003e Hello 1234567 World 1234567 (0, 19) 若想把字符串中的1234567提取出来，此时可以将数字部分的正则表达式用()括起来，然后调用了group(1)获取匹配结果 也可这样写 result = re.match('^He.*?(\\d+).*Demo$', content) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"匹配对象的方法 start([group]) 获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引） end([group]) 获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引 +1） group() group() 同 group(0) 返回匹配正则表达式整体结果（字符串） group(n) 列出第 n 个括号匹配部分 span([group]) 返回 (start(group), end(group)) \u003e\u003e\u003eimport re \u003e\u003e\u003e pattern = re.compile(r'\\d+') m = pattern.match('one12twothree34four', 3, 10) # 从'1'的位置开始匹配，正好匹配 \u003e\u003e\u003e print m # 返回一个 Match 对象 \u003c_sre.SRE_Match object at 0x10a42aac0\u003e \u003e\u003e\u003e m.group(0) # 可省略 0 '12' \u003e\u003e\u003e m.start(0) # 可省略 0 3 \u003e\u003e\u003e m.end(0) # 可省略 0 5 \u003e\u003e\u003e m.span(0) # 可省略 0 (3, 5) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:3","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"修饰符 遇到换行符时，使用修饰符re.S进行匹配，即可用“.”匹配换行符 result = re.match('^He.*?(\\d+).*?Demo$', content, re.S) 其他常用修饰符 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:4","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"search() match()方法是从字符串的开头开始匹配的，一旦开头不匹配，那么整个匹配就失败了 search()，它在匹配时会扫描整个字符串，然后返回第一个成功匹配的结果，搜索完了还没有找到，就返回None 为了匹配方便，尽量使用search()方法 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:5","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"findall() 在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意**：** match 和 search 是匹配一次；findall 匹配所有。 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:6","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"sub() 替换指定文本 如要将文本中的数字去掉 import re content = '54aK54yr5oiR54ix5L2g' content = re.sub('\\d+', '', content) print(content) 输出 aKyroiRixLg 只需要给第一个参数传入\\d+来匹配所有的数字，第二个参数为替换成的字符串（如果去掉该参数的话，可以赋值为空），第三个参数是原字符串 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:7","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"compile() 编译正则表达式，生成一个正则表达式 (Pattern) 对象，供 match() 和 search() 使用 import re content1 = '2016-12-15 12:00' content2 = '2016-12-17 12:55' content3 = '2016-12-22 13:21' pattern = re.compile('\\d{2}:\\d{2}') result1 = re.sub(pattern, '', content1) result2 = re.sub(pattern, '', content2) result3 = re.sub(pattern, '', content3) # or result3 = pattern.sub('',content3) print(result1, result2, result3) 输出 2016-12-15 2016-12-17 2016-12-22 例如，这里有3个日期，我们想分别将3个日期中的时间去掉，这时可以借助sub()方法。该方法的第一个参数是正则表达式，但是这里没有必要重复写3个同样的正则表达式，此时可以借助compile()方法将正则表达式编译成一个正则表达式对象，以便复用 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:3:8","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"split() ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"escape() 常用模板 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/regularexpression/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/regularexpression/"},{"categories":null,"content":"request API ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"模块 *requests.request(method, url, *kwargs) *requests.get(url, params=None, *kwargs) *requests.options(url, *kwargs) *requests.head(url, *kwargs) *requests.post(url, data=None, json=None, *kwargs) *requests.put(url, data=None, *kwargs) *requests.patch(url, data=None, *kwargs) *requests.delete(url, *kwargs) 除了requests.request()外，其余7个方法与http协议中的请求方法一一对应。这7个方法其实都是在调用requests.request()方法 method 简述 url 请求的url params 请求携带的params data 请求body中的data json 请求body中的json格式的data headers 请求携带的headers cookies 请求携带的cookies files 上传文件时使用 auth 身份认证时使用 timeout 设置请求的超时时间，可以设置连接超时和读取超时 allow_redirects 是否允许重定向，默认True，即允许重定向 proxies 设置请求的代理，支持http代理以及socks代理（需要安装第三方库\"pip install requests[socks]\"） verify 用于https请求时的ssl证书验证，默认是开启的，如果不需要则设置为False即可 stream 是否立即下载响应内容，默认是False，即立即下载响应内容 cert 用于指定本地文件用作客户端证书 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"基本调用 import requests r = requests.request('get','https://api.github.com/events') r = requests.get('https://api.github.com/events') r = requests.post('http://httpbin.org/post', data = {'key':'value'}) r = requests.put('http://httpbin.org/put', data = {'key':'value'}) r = requests.delete('http://httpbin.org/delete') r = requests.head('http://httpbin.org/get') r = requests.options('http://httpbin.org/get') 返回Response对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"param 接受一个字典，用于传递URL参数 payload = {'key1': 'value1', 'key2': 'value2'} r = requests.get(\"http://httpbin.org/get\", params=payload) print(r.url) 输出 http://httpbin.org/get?key1=value1\u0026key2=value2 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"headers 接受一个字典，用于传递header参数（请求头） url = 'https://tophub.today/n/mproPpoq6O' headers = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36' } s = requests.get(url,headers=headers) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"data 用于POST请求中，传递请求体中的data参数 该网站可以判断如果请求是POST方式，就把相关请求信息返回 data = {'name': 'germey', 'age': '22'} r = requests.post(\"http://httpbin.org/post\", data=data) print(r.text) 输出 { \"args\": {}, \"data\": \"\", \"files\": {}, \"form\": { \"age\": \"22\", \"name\": \"germey\" }, \"headers\": { \"Accept\": \"*/*\", \"Accept-Encoding\": \"gzip, deflate\", \"Content-Length\": \"18\", \"Content-Type\": \"application/x-www-form-urlencoded\", \"Host\": \"httpbin.org\", \"User-Agent\": \"python-requests/2.25.0\", \"X-Amzn-Trace-Id\": \"Root=1-5fe43f55-5d4750b76935f7515662c3b3\" }, \"json\": null, \"origin\": \"59.79.2.148\", \"url\": \"http://httpbin.org/post\" } ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"json 用于POST请求中，传递请求体中json格式的的data参数 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"files 上传文件 import requests files = {'file': open('favicon.ico', 'rb')} r = requests.post(\"http://httpbin.org/post\", files=files) print(r.text) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"cookies 用于传递cookies参数，不过将cookies写在headers中比较方便 import requests r = requests.get(\"https://www.baidu.com\") print(r.cookies) for key, value in r.cookies.items(): print(key + '=' + value) 输出 \u003cRequestsCookieJar[\u003cCookie BDORZ=27315 for .baidu.com/\u003e]\u003e BDORZ=27315 步骤 调用cookies属性，得到Cookies，可以发现它是RequestCookieJar类型 用items()方法将其转化为元组组成的列表，遍历输出每一个Cookie的名称和值，实现Cookie的遍历解析 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"verify 用于https请求时的ssl证书验证，默认是开启的，如果不需要则设置为False即可 例：请求一个HTTPS站点，但是证书验证错误的页面时，把verify参数设置为False import requests response = requests.get('https://www.12306.cn', verify=False) print(response.status_code) 输出 D:\\Application\\Anaconda\\lib\\site-packages\\urllib3\\connectionpool.py:988: InsecureRequestWarning: Unverified HTTPS request is being made to host 'www.12306.cn'. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings InsecureRequestWarning, 200 报了一个警告，它建议我们给它指定证书 可以通过设置忽略警告的方式来屏蔽这个警告 from requests.packages import urllib3 urllib3.disable_warnings() 或者通过捕获警告到日志的方式忽略警告 import logging logging.captureWarnings(True) 可以指定一个本地证书用作客户端证书 import requests response = requests.get('https://www.12306.cn', cert=('/path/server.crt', '/path/key')) print(response.status_code) 我们需要有crt和key文件，并且指定它们的路径。注意，本地私有证书的key必须是解密状态，加密状态的key是不支持的 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"proxies 设置请求的代理，支持http代理以及socks代理（需要安装第三方库\"pip install requests[socks]\"） import requests proxies = { \"http\": \"http://10.10.1.10:3128\", \"https\": \"http://10.10.1.10:1080\", } requests.get(\"https://www.taobao.com\", proxies=proxies) 若代理需要使用HTTP Basic Auth，可以使用类似http://user:password@host:port这样的语法来设置代理 proxies = { \"http\": \"http://user:password@10.10.1.10:3128/\", } 使用SOCKS协议代理 proxies = { 'http': 'socks5://user:password@host:port', 'https': 'socks5://user:password@host:port' } ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"timeout 设置请求的超时时间，（发出请求到服务器返回响应的时间），可以设置连接超时和读取超时 import requests r = requests.get(\"https://www.taobao.com\", timeout=1) print(r.status_code) 请求分为两个阶段，即连接（connect）和读取（read）。上面设置的timeout将用作连接和读取这二者的timeout总和 如果想永久等待，可以直接将timeout设置为None，或者不设置直接留空，因为默认是None ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"auth 身份认证时使用 import requests from requests.auth import HTTPBasicAuth r = requests.get('http://localhost:5000', auth=HTTPBasicAuth('username', 'password')) print(r.status_code) 如果用户名和密码正确的话，请求时就会自动认证成功，会返回200状态码，如果认证失败，则返回401状态码 直接传一个元组 它会默认使用HTTPBasicAuth这个类来认证 r = requests.get('http://localhost:5000', auth=('username', 'password')) 使用OAuth1认证 import requests from requests_oauthlib import OAuth1 url = 'https://api.twitter.com/1.1/account/verify_credentials.json' auth = OAuth1('YOUR_APP_KEY', 'YOUR_APP_SECRET', 'USER_OAUTH_TOKEN', 'USER_OAUTH_TOKEN_SECRET') requests.get(url, auth=auth) ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:12:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"allow_redirects 是否允许重定向，默认True，即允许重定向 response对象 response类故名思议，它包含了服务器对http请求的响应。每次调用requests去请求之后，均会返回一个response对象，通过调用该对象，可以查看具体的响应信息 以下是response对象的部分属性 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:13:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".url 请求的最终地址 print(type(r.url), r.url) \u003e\u003e\u003e \u003cclass 'str'\u003e https://static1.scrape.center/ ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:14:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".request PreparedRequest对象，可以用于查看发送请求时的信息，比如r.request.headers查看请求头 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:15:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".text 响应的内容，unicode类型 print(type(r.text), r.text) \u003e\u003e\u003e \u003cclass 'str'\u003e \"HTML的内容\" ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:16:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".content 响应的内容，byte类型（二进制） 一般在抓取图像时有用 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:17:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".status_code 响应的http状态码 print(type(r.status_code), r.status_code) \u003e\u003e\u003e \u003cclass 'int'\u003e 500 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:18:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".links 响应的解析头链接 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:19:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".history 请求的历史记录，可以用于查看重定向信息，以列表形式展示，排序方式是从最旧到最新的请求 print(type(r.history), r.history) \u003e\u003e\u003e \u003cclass 'list'\u003e [] ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:20:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".reason 响应状态的描述，比如 “Not Found” or “OK” ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:21:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".cookies 服务器发回的cookies，RequestsCookieJar类型 print(type(r.cookies), r.cookies) \u003e\u003e\u003e \u003cclass 'requests.cookies.RequestsCookieJar'\u003e \u003cRequestsCookieJar[]\u003e ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:22:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".json() 用于将响应解析成JSON格式，即将返回结果是JSON格式的字符串转化为字典 如果返回结果不是JSON格式，便会出现解析错误，抛出json.decoder.JSONDecodeError异常 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:23:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":".headers() 响应头，可单独取出某个字段的值，比如(r.headers)[‘content-type’] print(type(r.headers), r.headers) \u003e\u003e\u003e \u003cclass 'requests.structures.CaseInsensitiveDict'\u003e {'Server': 'nginx/1.17.8', 'Date': 'Tue, 27 Oct 2020 15:10:32 GMT', 'Content-Type': 'text/html', 'Content-Length': '145', 'Connection': 'keep-alive', 'X-Frame-Options': 'DENY', 'Vary': 'Cookie', 'X-Content-Type-Options': 'nosniff', 'Strict-Transport-Security': 'max-age=15724800; includeSubDomains'} session对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:24:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"会话维持 requests 中的 session 对象能够让我们跨http请求保持某些参数，即让同一个 session 对象发送的请求头携带某个指定的参数。当然，最常见的应用是它可以让 cookie 保持在后续的一串请求中 即，利用 Session 对象，可以方便地维护一个会话 import requests # tips: http://httpbin.org能够用于测试http请求和响应 s = requests.Session() s.get('http://httpbin.org/cookies/set/sessioncookie/123456789') #第一步：发送一个请求，用于设置请求中的cookies r = s.get(\"http://httpbin.org/cookies\") #第二步：再发送一个请求，用于查看当前请求中的cookies print(r.text) 输出 { \"cookies\": { \"sessioncookie\": \"123456789\" } } 第二次请求已经携带上了第一次请求所设置的cookie，即通过session达到了保持cookie的目的 session让请求之间具有了连贯性 ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:25:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":null,"content":"s.cookies.update() 用于设置请求中的cookies，方便实现跨参数请求，即能够在前后请求之间保持cookie 传入参数：字典 import requests s = requests.session() s.cookies.update({'cookies_are': 'cookie'}) r = s.get(url='http://httpbin.org/cookies') print(r.text) 输出 { \"cookies\": { \"cookies_are\": \"cookie\" } } 状态码查询对象 requests.codes exit() if not r.status_code == requests.codes.ok else print('Request Successfully!') 返回码和相应的查询条件 # 信息性状态码 100: ('continue',), 101: ('switching_protocols',), 102: ('processing',), 103: ('checkpoint',), 122: ('uri_too_long', 'request_uri_too_long'), # 成功状态码 200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\\\o/', '✓'), 201: ('created',), 202: ('accepted',), 203: ('non_authoritative_info', 'non_authoritative_information'), 204: ('no_content',), 205: ('reset_content', 'reset'), 206: ('partial_content', 'partial'), 207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'), 208: ('already_reported',), 226: ('im_used',), # 重定向状态码 300: ('multiple_choices',), 301: ('moved_permanently', 'moved', '\\\\o-'), 302: ('found',), 303: ('see_other', 'other'), 304: ('not_modified',), 305: ('use_proxy',), 306: ('switch_proxy',), 307: ('temporary_redirect', 'temporary_moved', 'temporary'), 308: ('permanent_redirect', 'resume_incomplete', 'resume',), # These 2 to be removed in 3.0 # 客户端错误状态码 400: ('bad_request', 'bad'), 401: ('unauthorized',), 402: ('payment_required', 'payment'), 403: ('forbidden',), 404: ('not_found', '-o-'), 405: ('method_not_allowed', 'not_allowed'), 406: ('not_acceptable',), 407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'), 408: ('request_timeout', 'timeout'), 409: ('conflict',), 410: ('gone',), 411: ('length_required',), 412: ('precondition_failed', 'precondition'), 413: ('request_entity_too_large',), 414: ('request_uri_too_large',), 415: ('unsupported_media_type', 'unsupported_media', 'media_type'), 416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'), 417: ('expectation_failed',), 418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'), 421: ('misdirected_request',), 422: ('unprocessable_entity', 'unprocessable'), 423: ('locked',), 424: ('failed_dependency', 'dependency'), 425: ('unordered_collection', 'unordered'), 426: ('upgrade_required', 'upgrade'), 428: ('precondition_required', 'precondition'), 429: ('too_many_requests', 'too_many'), 431: ('header_fields_too_large', 'fields_too_large'), 444: ('no_response', 'none'), 449: ('retry_with', 'retry'), 450: ('blocked_by_windows_parental_controls', 'parental_controls'), 451: ('unavailable_for_legal_reasons', 'legal_reasons'), 499: ('client_closed_request',), # 服务端错误状态码 500: ('internal_server_error', 'server_error', '/o\\\\', '✗'), 501: ('not_implemented',), 502: ('bad_gateway',), 503: ('service_unavailable', 'unavailable'), 504: ('gateway_timeout',), 505: ('http_version_not_supported', 'http_version'), 506: ('variant_also_negotiates',), 507: ('insufficient_storage',), 509: ('bandwidth_limit_exceeded', 'bandwidth'), 510: ('not_extended',), 511: ('network_authentication_required', 'network_auth', 'network_authentication') 异常处理 requests.exceptions.ConnectionError http 的连接数超过最大限制，默认的情况下连接是 Keep-alive 的，所以这就导致了服务器保持了太多连接而不能再新建连接。 ip 被封 程序请求速度过快。 try: response = requests.get(url) except requests.exceptions.ConnectionError: print('error!') continue ","date":"0001-01-01","objectID":"/Notes/posts/python/crawler/requests/:26:0","tags":null,"title":"","uri":"/Notes/posts/python/crawler/requests/"},{"categories":["有用的东东"],"content":"八股文 未看：https://blog.csdn.net/u012027907/article/details/56908268?spm=1001.2014.3001.5502 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:0:0","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"计算机网络 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:0","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"HTTP 相关 常见的 HTTP 状态码有哪些? 1×× : 请求处理中，请求已被接受，正在处理 2×× : 请求成功，请求被成功处理 200 OK 200-OK：成功。如果是非 HEAD 请求，响应头会有 body 数据 202-Accepted 已接受。已经接受请求，但未处理完成 204-No Content：与 200 基本相同，但响应没有 body 数据 206-Partial Content：应用于 HTTP 断点续传，返回的 body 是资源的一部分 3×× : 重定向，要完成请求必须进行进一步处理 301-Moved Permanently：永久重定向 302-Found：临时重定向 304-Not Modified：已缓存（资源没修改，用之前缓存就行） 4×× : 客户端错误，请求报文不合法 400-Bad Request：请求有语法问题 401-Unauthorized：需要通过HTTP认证 403-Forbidden：服务器禁止访问资源，不是客户端的问题 404-Not Found：请求的资源在服务器上找不到 5×× : 服务器端错误，服务器不能处理合法请求 500-Internal Server Error：发生错误（比较笼统） 501-Not Implemented：该功能还不支持 502-Bad Gateway：服务器作为网关/代理返回，表示服务器自身工作正常，但访问后端服务器发送错误 503-Service Unavailable：当前忙，暂时无法响应 此响应代码表明 HTTP 服务器正常，只是下层 web 服务不能正常工作 最可能的理由是资源不足：服务器突然收到太多请求，以至于无法全部处理 由于此问题多半由客户端反复发送请求造成，因此 HTTP 服务器可以选择拒绝客户端请求并返回 503 重试 服务器可以在响应头的 Retry-After 字段告知客户端何时可以重试 504-Gateway Timeout：网关超时 502 和 504 的区别 从网络角度，502已经与后端建立了连接，但超时（电话打通了，但没人接）；504与后端连接未建立，超时（电话没打通）。 http 中常见的 header 字段有哪些？ 通用首部字段 请求/响应报文都会使用的首部 Cache-Control 字段 控制缓存的工作机制 no-cache/max-age=…/public/private Connection 字段 控制不再转发给代理的首部字段 管理持久连接 Date 字段 创建 HTTP 报文的日期和时间 请求首部字段 Accept 字段 客户端接受的媒体类型和优先级（加权） text/html q=0.3,text/plain Accept-Encoding 字段 客户端接受的内容编码和优先级（加权） gzip Authorization 字段 客户端的认证信息 Host 字段 请求的资源所处的互联网主机名和端口号 HTTP1.1 规定的唯一一个必须包含的请求首部字段 Range 字段 获取指定资源范围 Referer 字段 可以用来防御 CSRF 攻击 告知服务器请求的原始资源 URI，可以知道 URI 是从哪个 Web 页面发起的 User-Agent 字段 浏览器/用户代理等信息 Cookie 字段 告知服务端，想获取 Cookie 支持 Status=enable 响应首部字段 Accept-Ranges 字段 能否处理范围请求 bytes–能，none–不能 Age 字段 源服务器多少秒前创建响应，单位为秒 Location 字段 引导至指定 URL（重定向） Set-Cookie 字段 告知客户端信息 NAME, expires, path, domain, HttpOnly HttpOnly 使得 JavaScript 脚本无法获得 Cookie，从而防止了跨站脚本攻击（XSS） 实体首部字段 针对请求/响应报文的实体部分使用的首部 Allow 字段 服务端允许的 HTTP 方法 Content-Encoding 字段 服务端内容编码格式 Content-Length 字段 实体主题部分大小，单位字节 Content-Range 字段 针对范围请求，指定返回实体的部分 Content-Type 字段 实体主题内对象的媒体类型 请求方式 GET 与 POST 的区别 GET 一般用来从服务器上获取资源，POST 一般用来创建资源； GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的。 从请求参数形式上看，GET 请求的数据会附在URL之后；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的请求体中。 POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而 POST 请求参数则被包装到请求体中，相对更安全。 GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:1","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"说说 OSI 七层、TCP/IP 四层的关系和区别？ OSI 七层从下往上依次是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP/IP 四层从下往上依次是：网络接口层、网络层、传输层、应用层 特点： 层与层之间相互独立又相互依靠 上层依赖于下层，下层为上层提供服务 TCP/IP 四层是 OSI 七层的简化版，已经成为事实国际标准 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:2","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"说说 TCP 与 UDP 的区别？ ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:3","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"TCP 是如何实现数据的可靠性？ 一句话：通过校验和、序列号、确认应答、超时重传、连接管理、流量控制、拥塞控制等机制来保证可靠性。 校验和 在数据传输过程中，将发送的数据段都当做一个 16 位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。 发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。 序列号 TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。 确认应答 TCP 传输过程中，每次接收方接收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。 超时重传 在进行 TCP 传输时，由于存在确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟都没有接收到接收方传来的 ACK 报文，那么就对刚刚发送的数据进行重发。 连接管理 就是指三次握手、四次挥手的过程。 流量控制 如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。 具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。 拥塞控制 TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了慢启动机制，在开始发送数据的时候，先发少量的数据探探路。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:4","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"说说 TCP 协议如何提高传输效率？ 一句话：TCP 协议提高效率的方式有滑动窗口、快重传、延迟应答、捎带应答等。 滑动窗口 如果每一个发送的数据段，都要收到 ACK 应答之后再发送下一个数据段，这样的话我们效率很低，大部分时间都用在了等待 ACK 应答上了。 为了提高效率我们可以一次发送多条数据，这样就能使等待时间大大减少，从而提高性能。 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。 快重传 快重传 也叫 高速重发控制。 那么如果出现了丢包，需要进行重传。一般分为两种情况： 情况一：数据包已经抵达，ACK 被丢了。这种情况下，部分 ACK 丢了并不影响，因为可以通过后续的 ACK 进行确认； 情况二：数据包直接丢了。发送端会连续收到多个相同的 ACK 确认，发送端立即将对应丢失的数据重传。 延迟应答 如果接收数据的主机立刻返回 ACK 应答，这时候返回的窗口大小可能比较小。 假设接收端缓冲区为 1M，一次收到了 512K 的数据；如果立刻应答，返回的窗口就是 512K； 但实际上可能处理端处理速度很快，10ms 之内就把 512K 的数据从缓存区消费掉了； 在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来； 如果接收端稍微等一会在应答，比如等待 200ms 再应答，那么这个时候返回的窗口大小就是 1M； 窗口越大，网络吞吐量就越大，传输效率就越高；我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。 捎带应答 在延迟应答的基础上，很多情况下，客户端服务器在应用层也是一发一收的。这时候常常采用捎带应答的方式来提高效率，而 ACK 响应常常伴随着数据报文共同传输。如：三次握手。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:5","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"你知道 TCP 如何处理拥塞吗？ 拥塞避免机制 慢开始 设置门限变量 区分不同的丢包事件 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:6","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"讲一下三次握手和四次挥手全过程 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:7","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"为什么 TCP 链接需要三次握手，两次不可以么，为什么？ 两次握手只能保证单向连接是畅通的 第一步，客户端给服务端发送一条消息：你好，服务端。 第二步，服务端收到消息，同时给客户端回复一条消息：收到！你好客户端。 这样的两次握手过程， 客户端给服务端打招呼，服务端收到了，说明客户端可以正常给服务端发送数据。但是服务端给客户端打招呼，服务端没有收到反馈，也就不能确保服务端是否能正常给客户端发送消息。 只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据 第三步，客户端收到服务端发送的消息，回复：收到！这样就证明了客户端能正常收到服务端的消息。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:8","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"IP 地址是怎样分类的，你知道吗？ 先说一下 IP 的基本特点： IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。 IP 地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。 IP 地址主要分为 A、B、C 三类及特殊地址 D、E 这五类，甩一张图： A 类：(1.0.0.0-126.0.0.0) 一般用于大型网络。 B 类：(128.0.0.0-191.255.0.0) 一般用于中等规模网络。 C 类：(192.0.0.0-223.255.255.0) 一般用于小型网络。 D 类：是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。 E 类：是保留地址。地址的网络号取值于 240~255 之间。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:9","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"讲一下 http1.1 和 http2 有什么区别？ HTTP1.1 持久连接 在一个 TCP 连接上可以传送多个 HTTP 请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。 请求管道化 增加缓存处理（新的字段如 cache-control） 增加 Host 字段、支持断点传输等 HTTP2.0 二进制分帧 引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列 id，服务器就可以进行并行传输数据。 头部压缩 多路复用（或连接共享） 多路复用前，文件时串行传输的，请求 a 文件，b 文件只能等待，并且连接数过多。引入多路复用，a 文件 b 文件可以同时传输。 服务器推送 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:10","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"说说 HTTP 和 HTTPS 的区别？ HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。 HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 SSL 加密传输协议 HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443 HTTP 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:11","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"你知道对称加密和非对称加密的区别和原理吗？ 对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方; 而非对称加密是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性；但是和对称加密比起来，它比较慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:12","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"DNS 的寻址过程你知道吗？ 1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器 2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找 3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器 4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址 5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器 6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息 7、客户机的本地的dns服务器会将查询结果返回给我们的客户机 8、客户机根据得到的ip信息访问目标主机，完成解析过程 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:13","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"在浏览器中输入一个 http://www.baidu.com 后执行的全部过程？ 域名解析 -\u003e 建立 TCP 连接（三次握手）-\u003e 发起 http 请求 -\u003e 服务器响应 http 请求，浏览器得到 html 代码 -\u003e 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）-\u003e 浏览器对页面进行渲染呈献给用户。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:14","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"Session、Cookie 的区别 session 存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号 sessionId，通常存放于 cookie 中。服务器收到 cookie 后解析出 sessionId，再去 session 列表中查找，才能找到相应 session。 cookie 类似一个令牌，装有 sessionId，存储在客户端，浏览器通常会自动添加。 token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。 jwt 只是一个跨域认证的方案 补充 JWT JWT 就是 token 的一种实现方式，并且基本是 java web 领域的事实标准。 JWT 全称是 JSON Web Token。基本可以看出是使用 JSON 格式传输 token JWT 由 3 部分构成: Header：描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。 Payload（负载）：用来存放实际需要传递的数据 Signature（签名）：服务器通过 Payload、Header 和一个密钥 (secret) 使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。 流程： 在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过 Payload、Header 和一个密钥(secret) 创建令牌（Token）并将 Token 发送给客户端， 然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization 字段中 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:15","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"有哪些 web 性能优化技术? DNS 查询优化 客户端缓存 优化 TCP 连接 避免重定向 网络边缘的缓存 条件缓存 压缩和代码极简化 图片优化 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:16","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"什么是 XSS 攻击？ XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。 XSS 的重点不在于跨站点，而在于脚本的执行。 XSS的原理是：恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。 XSS 攻击最主要有如下分类：反射型、存储型、及 DOM-based 型。 反射性和 DOM-baseed 型可以归类为非持久性 XSS 攻击。存储型可以归类为持久性 XSS 攻击。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:17","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"什么是跨站攻击 CSRF？ CSRF（Cross Site Request Forgery，跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一，也被称为『One Click Attack』或者 『Session Riding』，通常缩写为CSRF或者XSRF，是一种对网站的恶意利用。 听起来像跨站脚本（XSS），但它与 XSS 非常不同，并且攻击方式几乎相左。 XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。 与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:18","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"简述 TCP 粘包现象 TCP 是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个 tcp 报文中发出去的可能性。 可以简单的理解成客户端调用了两次 send，服务器端一个 recv 就把信息都读出来了。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:19","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"TCP 粘包现象处理方法 固定发送信息长度，或在两个信息之间加入分隔符。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:20","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"简述半连接队列 TCP 握手中，当服务器处于 SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:21","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"简述 SYN 攻击 泛洪攻击 SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费 CPU 和内存资源。 优化方式： 缩短 SYN Timeout 时间 记录 IP，若连续受到某个IP的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:22","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"https 的连接过程 浏览器将支持的加密算法信息发给服务器 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为 client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端对称密钥发送给服务器 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。 服务器将加密后的密文发送给客户端 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:23","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"了解 REST API 吗 REST API 全称为表述性状态转移（Representational State Transfer，REST）即利用 HTTP 中 get、post、put、delete 以及其他的 HTTP 方法构成 REST 中数据资源的增删改查操作： Create ： POST Read ： GET Update ： PUT/PATCH Delete： DELETE ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:24","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"转发和重定向的区别 转发是服务器行为。 服务器直接向目标地址访问 URL，将相应内容读取之后发给浏览器，用户浏览器地址栏 URL 不变，转发页面和转发到的页面可以共享 request 里面的数据。 重定向是利用服务器返回的状态码来实现的，如果服务器返回 301 或者 302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。 用户的地址栏 url 会发生改变，而且不能共享数据。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:1:25","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"操作系统 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:0","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"操作系统有哪些分类？ 批处理操作系统、分时操作系统、实时操作系统。 若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:1","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"什么是内核态和用户态？ 都是处理机的执行状态 用户程序运行在用户态，操作系统内核运行在内核态。 用户态 非特权状态、目态 在此状态下，执行的代码被硬件限定，不能执行特权指令 内核态 特权状态、管态 核心态是操作系统内核所运行的模式，运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:2","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"如何实现内核态和用户态的切换？ 处理器从用户态切换到内核态的方法有三种：系统调用、异常和外部中断。 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。 异常，也叫做内中断，是由错误引起的，如文件损坏、缺页故障等。 外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:3","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"并发和并行的区别 并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核 cpu 上的多任务。但是从微观上看两个程序的指令是交织着运行的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。 并行（parallelism）：指严格物理意义上的同时运行，比如多核 cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:4","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"进程和线程的区别 进程 进程是进程实体的运行过程，是系统进行资源分配和独立调度的基本单位 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。 进程是资源分配的最小单位，线程是程序执行的最小单位。 进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。 而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很位。 线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据。而进程之间的通信需要以通信的方式 (IPC) 进行。不过如何处理好同步与互斥是编写多线程程序的难点。 但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:5","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"进程间通信方法 进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。 管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字 socket。（socket 会比较常用） ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:6","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"线程间通信方式 锁机制：包括互斥锁、条件变量、读写锁。 互斥锁：提供了以排他方式防止数据结构被并发修改的方法。 读写锁：允许多个线程同时读共享数据，而对写操作是互斥的。 条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。 条件变量始终与互斥锁一起使用。 信号量机制 (Semaphore)：包括无名线程信号量和命名线程信号量。 信号机制 (Signal)：类似进程间的信号处理。 线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:7","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"进程调度的时机 当前运行的进程运行结束。 当前运行的进程由于某种原因阻塞。 执行完系统调用等系统程序后返回用户进程。 在使用抢占调度的系统中，具有更高优先级的进程就绪时。 分时系统中，分给当前进程的时间片用完。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:8","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"不能进行进程调度的情况 在中断处理程序执行时。 在操作系统的内核程序临界区内。 其它需要完全屏蔽中断的原子操作过程中。、 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:9","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"进程的调度策略 先到先服务调度算法 短作业优先调度算法 优先级调度算法 时间片轮转调度算法 高响应比优先调度算法 多级队列调度算法 多级反馈队列调度算法 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:10","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"什么是信号 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的 30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因： 内核检测到一个系统事件，比如除零错误或者子进程终止。 —个进程调用了 kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序 (signal handler) 的用户层函数捕获这个信号。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:11","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"进程调度策略的基本设计指标 CPU 利用率 系统吞吐率，即单位时间内 CPU 完成的作业的数量。 响应时间。 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键 平均周转时间 带权周转时间 平均带权周转时间 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:12","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"进程的状态与状态转换 进程在运行时有三种基本状态：就绪态、运行态和阻塞态。 运行（running）态：进程占有处理器正在运行的状态。进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。 阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。 各状态之间的转换： 就绪 → 执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。 执行 → 就绪：处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。 执行 → 阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。 阻塞 → 就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:13","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"什么是孤儿进程？僵尸进程? 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程（1 号进程）所收养，并由 init 进程对他们完成状态收集工作。 僵尸进程： 进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 获 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这些进程是僵尸进程。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:14","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"多线程模型 多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。 一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:15","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"死锁是怎样产生的？ 死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。 产生死锁需要满足下面四个条件： 互斥条件（Mutual Exclusion） 资源要求互斥访问 请求和保持条件（Hold and wait） 提出的请求得不到满足，手头的资源释放不出来 不可抢占条件（No preemption） 资源只能由占有者资源释放 循环等待条件（Circular wait） 必有一个进程-资源的环形链，环路中的进程形成等待链 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:16","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"如何解决死锁问题？ 解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下: 不让死锁发生 预防死锁：静态策略，破坏死锁产生的必要条件 避免死锁：动态策略，不限制必要条件，而去防止系统进入不安全状态（银行家算法） 让死锁发生 检测死锁：通过检测机构及时发现死锁，再采取措施（资源分配图） 解除死锁：当死锁发生，撤销一些进程，回收资源再分配 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:17","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"优先级反转是什么？如何解决 由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转 (Priority Inversion)。其实，优先级反转是在高优级 (假设为 A) 的任务要访问一个被低优先级任务 (假设为 C) 占有的资源时，被阻塞；而此时又有优先级高于占有资源的任务(C) 而低于被阻塞的任务 (A) 的优先级的任务 (假设为 B) 时,于是，占有资源的任务就被挂起 (占有的资源仍为它占有)，因为占有资源的任务优先级很低，所以,它可能一直被另外的任务挂起；而它占有的资源也就一直不能释放；这样，引起任务 A 一直没办法执行，而比它优先低的任务却可以执行。 目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承 (priority inheritance)；另一种被称作优先级极限 (priority ceilings)。 优先级继承 (priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。 优先级天花板 (priority ceilings) 优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级. (这个优先级称为该资源的优先级天花板)。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:18","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"什么是死锁 死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象 产生死锁的必要条件 互斥条件：一个资源每次只能被一个进程使用。 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:2:19","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"数据库 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:3:0","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"事务并发可能出现的情况 脏读（Dirty Read） 一个事务读到了另一个未提交事务修改过的数据 脏读只在读未提交隔离级别才会出现 不可重复读（Non-Repeatable Read） 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。 不可重复读在读未提交和读已提交隔离级别都可能会出现 幻读（Phantom） 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。 幻读在读未提交、读已提交、可重复读隔离级别都可能会出现 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:3:1","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"事务的隔离级别 MySQL 的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。 MySQL 默认的隔离级别是可重复读 读未提交（READ UNCOMMITTED） 事务 A 可以读取到事务 B 修改过但未提交的数据。 可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。 读已提交（READ COMMITTED） 事务 A 只能在事务 B 修改过并且已提交后才能读取到事务 B 修改后的数据。 读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。 可重复读（REPEATABLE READ） 事务 A 只能在事务 B 修改过数据并提交后，自己也提交事务后，才能读取到事务 B 修改的数据。 可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。 可串行化（SERIALIZABLE） 读读操作不会阻塞 读写操作会阻塞 写读操作会阻塞 写写操作会阻塞 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:3:2","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"数据库优化 https://www.cnblogs.com/jiajialeps/p/10162767.html ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:3:3","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"事务的四个特性 原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） 原子性是指事务是一个不可再分割的工作单元，事务中的操作要么都发生，要么都不发生。 一致性是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。 隔离性是指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久地保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持） ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:3:4","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"测试开发 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:4:0","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"定位测试方法 确认网络环境是否正常 抓包看接口返回 查看服务端日志 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:4:1","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"其他 ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:5:0","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["有用的东东"],"content":"爬虫 url 去重方法 https://blog.csdn.net/weixin_42425970/article/details/102532185 放到列表中（烂中之烂） 放到数据库中（利用唯一性索引） 放到 HashSet 中 md5 编码后放到 HashSet 中 位图 Bitmap ","date":"2022-02-25","objectID":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/:5:1","tags":["面试"],"title":"面试八股文","uri":"/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"},{"categories":["刷题"],"content":"技巧 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:0:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"输入输出 笔试可能会遇到牛客网 ACM 模式的题目，所以要熟悉一下各种语言的输入输出 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:1:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"Golang 基本格式 基本写法：用一个 for 循环包着，用 Scan 函数接收用空白分隔符分开来的参数。 package main import \"fmt\" func main() { var a, b int for { // 循环获取输入 if _, err := fmt.Scan(\u0026a, \u0026b); err == nil { fmt.Println(a + b) } else { break } } } 另一种写法，判断 err 是否是 io.EOF 类型 package main import ( \"fmt\" \"io\" ) func main() { var a, b int for { if _, err := fmt.Scan(\u0026a,\u0026b); err != io.EOF { fmt.Println(a + b) } else { break } } } 包含输入个数 如果题目提供了输入参数的个数 t，那就在循环外提前接收： package main import \"fmt\" func main() { var t, a, b int fmt.Scan(\u0026t) // 返回的参数都省略掉了 for t \u003e 0 { fmt.Scan(\u0026a, \u0026b) fmt.Println(a + b) t-- } } 包含退出条件 如果题目提供了退出的条件，也不用接受 io.EOF 了，在循环内判断退出条件即可： package main import \"fmt\" func main() { var a, b int for { fmt.Scan(\u0026a, \u0026b) if a == 0 \u0026\u0026 b == 0 { // 退出条件就是两者均为0 break } fmt.Println(a + b) } } 不固定参数个数 如果题目的一行输入个数是不固定的，并且每行第一个数代表了参数个数： package main import \"fmt\" func main() { var n, num int for { fmt.Scan(\u0026n) // 先取每行第一个数，确定个数 if n == 0 { // 退出条件，总会给你的 break } sum := 0 for n \u003e 0 { // 再套个循环，写真正的业务逻辑 fmt.Scan(\u0026num) sum += num n-- } fmt.Println(sum) } } 这种情况还可以用 bufio 来做： package main import ( \"fmt\" \"os\" \"bufio\" \"strings\" \"strconv\" ) func main() { input := bufio.NewScanner(os.Stdin) //创建并返回一个从os.Stdin读取数据的Scanner for input.Scan(){ // Scan方法获取当前位置的token（该token可以通过Bytes或Text方法获得）， // 并让Scanner的扫描位置移动到下一个token。 // 当扫描因为抵达输入流结尾或者遇到错误而停止时，本方法会返回false nums := strings.Split(input.Text(), \" \") // 分割字符串 if nums[0] == \"0\" { // 判断是否结束 break } res := 0 for i := 1; i \u003c len(nums); i++ { num, _ := strconv.Atoi(nums[i]) // 字符串转数字 res += num } fmt.Println(res) } } 这种方法比较麻烦。。。在接收字符串类型的情况时会比较好用 有时候不会给你退出条件，而是在开头提供了行数： package main import ( \"fmt\" ) func main() { var t, n, num int fmt.Scan(\u0026t) for ; t \u003e 0; t-- { fmt.Scan(\u0026n) res := 0 for ; n \u003e 0; n-- { fmt.Scan(\u0026num) res += num } fmt.Println(res) } } 不固定参数个数，且不提供个数 只能用 bufio 了。。。 package main import ( \"bufio\" \"fmt\" \"os\" \"strconv\" \"strings\" ) func main() { input := bufio.NewScanner(os.Stdin) for input.Scan() { nums := strings.Split(input.Text(), \" \") if len(nums) == 0 { break } res := 0 for _, num := range nums { tmp, _ := strconv.Atoi(num) res += tmp } fmt.Println(res) } } 希望这种题远离我 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:1:1","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"Python nums = list(map(int, input().split())) ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:1:2","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"数组 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:2:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"双指针 计算过程仅与两端点相关的称为双指针。 这种方法通过一个快指针和慢指针在一个 for 循环下完成两个 for 循环的工作。 快慢指针：都从头开始，遍历条件不同，所以速度不同 头尾指针：一个从头，一个从尾；二分法就是一种头尾指针；也叫对撞指针 题目 头尾指针：[offer 57](array\\剑指 Offer 57. 和为s的两个数字.md) 快慢指针： ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:2:1","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"滑动窗口 计算过程与两端点表示的区间相关的称为滑动窗口。 滑动窗口本身并不是解决问题的一种方法（或者说算法），它其实就是问题本身。 滑动窗口一定是同向移动的。 一些经验之谈 while 循环的条件一般都是 j\u003clen(nums) （右边界不超出） while 循环内的 j 不断右移；如果 j 右移到一定程度满足了题目的要求后，i 开始右移（一般在 while 循环里的嵌套 while 中运行） 滑动窗口给我一种蠕动的感觉。。。 有时候为了方便，i 会是左边界左一位，从 -1 开始；j 会是右边界右一位，从 1 开始 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:2:2","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"二分 二分搜索有 4 大基础变种题： 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素 package leetcode // 二分查找第一个与 target 相等的元素，时间复杂度 O(logn) func searchFirstEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := low + (high - low) \u003e\u003e 1 // or (low + high) \u003e\u003e 1 if nums[mid] \u003e target { high = mid - 1 } else if nums[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (nums[mid-1] != target) { // 找到第一个与 target 相等的元素 return mid } high = mid - 1 } } return -1 } // 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn) func searchLastEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if nums[mid] \u003e target { high = mid - 1 } else if nums[mid] \u003c target { low = mid + 1 } else { if (mid == len(nums)-1) || (nums[mid+1] != target) { // 找到最后一个与 target 相等的元素 return mid } low = mid + 1 } } return -1 } // 二分查找第一个大于等于 target 的元素，时间复杂度 O(logn) func searchFirstGreaterElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if nums[mid] \u003e= target { if (mid == 0) || (nums[mid-1] \u003c target) { // 找到第一个大于等于 target 的元素 return mid } high = mid - 1 } else { low = mid + 1 } } return -1 } // 二分查找最后一个小于等于 target 的元素，时间复杂度 O(logn) func searchLastLessElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if nums[mid] \u003c= target { if (mid == len(nums)-1) || (nums[mid+1] \u003e target) { // 找到最后一个小于等于 target 的元素 return mid } low = mid + 1 } else { high = mid - 1 } } return -1 } ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:2:3","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"模拟行为 这类题目不怎么涉及到算法，就是纯粹的模拟行为。。。 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:2:4","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"单调栈 单调栈的作用是：用 O(n) 的时间得知所有位置两边第一个比他大 (或小) 的数的位置。 最经典的就是接雨水了 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:2:5","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"链表 链表他妈的就是双指针！！！ 有时候递归也可以 虚拟头节点是一个很好的东西 链表的一大问题就是操作当前节点必须要找前一个节点才能操作。这就造成了，头结点的尴尬，因为头结点没有前一个节点了。 每次对应头结点的情况都要单独处理，所以使用虚拟头结点的技巧，就可以解决这个问题 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:3:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"栈 匹配问题都是栈的强项 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:4:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"字符串 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:5:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"KMP 多复习…… // strStr KMP算法 时间复杂度O(N+M),空间复杂度O(M) func strStrSimple(haystack string, needle string) int { n, m := len(haystack), len(needle) if m == 0 { return 0 } next := make([]int, m) GetNext(next, needle) // 因为next数组里记录的起始位置为0 j := 0 // i从0开始匹配 for i := 0; i \u003c n; i++ { // 如果不匹配，就寻找之前匹配的位置 for j \u003e 0 \u0026\u0026 haystack[i] != needle[j] { j = next[j-1] } // 如果匹配，i和j同时向后移动 if haystack[i] == needle[j] { j++ } // 如果j从0移动到m的位置，意味着模式串needle与文本串haystack匹配成功 if j == m { return i - m + 1 } } return -1 } func GetNext(next []int, s string) { // next[j]就是记录着j（包括j）之前的子串的相同前后缀的长度。 j := 0 next[0] = 0 // j指向前缀起始位置，i指向后缀起始位置 for i := 1; i \u003c len(s); i++ { // 如果前后缀不相同，那么j就要向前回退 for j \u003e 0 \u0026\u0026 s[i] != s[j] { j = next[j-1] } // 说明找到了相同的前后缀, j++，同时记录next[i] if s[i] == s[j] { j++ } next[i] = j } } ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:5:1","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"哈希表 遇到字符串问题，而且字符范围都是小写/大写字母的时候，可以用 [26]hash int32 来代替一个 map[byte]int32 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:6:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"树 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:7:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"二叉树的遍历 先序遍历 最简单 初始头节点入栈 每次从栈中取一个节点，打印之，再把它的右节点、左节点先后入栈 // 非递归 func preorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } result := make([]int, 0) stack := list.New() stack.PushBack(root) var curNode *TreeNode for stack.Len() != 0 { curNode = stack.Back().Value.(*TreeNode) stack.Remove(stack.Back()) result = append(result, curNode.Val) if curNode.Right != nil { stack.PushBack(curNode.Right) } if curNode.Left != nil { stack.PushBack(curNode.Left) } } return result } 后序遍历 跟先序很像，相当于反着的先序 区别： 从栈中取出的节点放进一个数组中；最后数组反着输出 入栈顺序是先右后左 // 非递归 func postorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } result := make([]int, 0) stack := list.New() stack.PushBack(root) var curNode *TreeNode for stack.Len() != 0 { curNode = stack.Back().Value.(*TreeNode) stack.Remove(stack.Back()) result = append([]int{curNode.Val}, result...) // 将结果放在最前面 // 入栈顺序先左后右 if curNode.Left != nil { stack.PushBack(curNode.Left) } if curNode.Right != nil { stack.PushBack(curNode.Right) } } return result } // 非递归2 func postorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } result := make([]int, 0) stack := list.New() stack.PushBack(root) var curNode *TreeNode for stack.Len() != 0 { curNode = stack.Back().Value.(*TreeNode) stack.Remove(stack.Back()) result = append(result, curNode.Val) // 入栈顺序先左后右 if curNode.Left != nil { stack.PushBack(curNode.Left) } if curNode.Right != nil { stack.PushBack(curNode.Right) } } reverse := func(nums []int) []int { i, j := 0, len(nums)-1 for i \u003c j { nums[i], nums[j] = nums[j], nums[i] i++ j-- } return nums } return reverse(result) // 反转 } 中序遍历 相对难一点，在使用迭代法写中序遍历时，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。 cur 指向根节点 cur 一直左移，一直将 cur 的左节点入栈，直到左节点为空 若左节点为空，出栈并赋值为 cur，打印；cur 转到其右节点，再重复步骤 2 func inorderTraversal(root *TreeNode) []int { if root == nil { return []int{} } stack := list.New() result := make([]int, 0) curNode := root // 指针 for stack.Len() != 0 || curNode != nil { if curNode != nil { stack.PushBack(curNode) curNode = curNode.Left } else { // 左边没有了 curNode = stack.Back().Value.(*TreeNode) // 出栈 stack.Remove(stack.Back()) result = append(result, curNode.Val) curNode = curNode.Right } } return result } ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:7:1","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"回溯 回溯是递归的副产品，只要有递归就会有回溯。 虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。 回溯法解决的问题都可以抽象为树形结构。因为回溯法解决的都是在集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度构成了树的深度。 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:8:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"问题分类 组合问题：N 个数里面按一定规则找出 k 个数的集合 切割问题：一个字符串按一定规则有几种切割方式 子集问题：一个 N 个数的集合里有多少符合条件的子集 排列问题：N 个数按一定规则全排列，有几种排列方式 棋盘问题：N 皇后，解数独等等 组合不强调元素顺序的，排列强调元素顺序 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:8:1","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"模板 回溯函数模板返回值以及参数 习惯性将函数起名为 backtracking 回溯算法中函数一般无返回值 再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。 回溯函数伪代码如下： void backtracking(参数) 回溯函数终止条件 遍历树形结构一定要有终止条件，所以回溯也有要终止条件。 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。 所以回溯函数终止条件伪代码如下： if (终止条件) { 存放结果; return; } 回溯搜索的遍历过程 在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。 如图： 特意举例：集合大小和孩子的数量是相等的！ 回溯函数遍历过程伪代码如下： for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } for 循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个 for 循环就执行多少次。 backtracking 这里自己调用自己，实现递归。 大家可以从图中看出 for 循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。 分析完过程，回溯算法模板框架如下： void backtracking(参数) { if (终止条件) { 存放结果; // y return; } for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) { 处理节点; backtracking(路径，选择列表); // 递归 回溯，撤销处理结果 } } ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:8:2","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"回溯与分治的区别 不一定对 回溯更多的是 DFS，自底向上；类似于后序遍历 分治更多的先解决了当前层的问题，再去解决下一层的子问题，自顶向下；类似于先序遍历 回溯有一种回到当前层来解决问题的感觉，解决当前层的问题需要依赖更深层所提供的信息；而分治的上层则不依赖下层 回溯更多的是找到一个集合（路径、排列…），需要遍历空间集，实质上是一种很笨的方法（DFS 嘛）。分治更多的是改变一个序列的排序等等 回溯的特色是剪枝；分治的特色是分解后的合并 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:8:3","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"排序模板 ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:9:0","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"快排 var quickSort func(nums []int, l, r int) quickSort = func(nums []int, l, r int) { pivotPos := true // 基准值位置 true为前 i, j := l, r for i \u003c j { if !compare(nums[i], nums[j]) { // 逆序 pivotPos = !pivotPos nums[i], nums[j] = nums[j], nums[i] } if pivotPos { j-- } else { i++ } } if l \u003c i-1 { quickSort(nums, l, i-1) } if i+1 \u003c r { quickSort(nums, i+1, r) } } ","date":"2022-02-25","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/:9:1","tags":["算法"],"title":"算法技巧","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/"},{"categories":["刷题"],"content":"1546. 和为目标值且不重叠的非空子数组的最大数目 mid 给你一个数组 nums 和一个整数 target 。 请你返回 非空不重叠 子数组的最大数目，且每个子数组中数字和都为 target 。 示例 1： 输入：nums = [1,1,1,1,1], target = 2 输出：2 解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 示例 2： 输入：nums = [-1,3,5,1,4,2,-9], target = 6 输出：2 解释：总共有 3 个子数组和为 6 。 ([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。 ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1546.-%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E9%9D%9E%E7%A9%BA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/:0:0","tags":["算法","数组","贪心","前缀和"],"title":"1546. 和为目标值且不重叠的非空子数组的最大数目","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1546.-%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E9%9D%9E%E7%A9%BA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"},{"categories":["刷题"],"content":"贪心 + 前缀和 贪心：由于题目要求所有的子数组互不重叠，因此对于某个满足条件的子数组，如果其右端点是所有满足条件的子数组的右端点中最小的那一个，则该子数组一定会被选择。 前缀和见 560 题 // 贪心 + 前缀和 func maxNonOverlapping(nums []int, target int) int { count, curSum := 0, 0 hash := map[int]int{0: 1} for i := 0; i \u003c len(nums); i++ { curSum += nums[i] if hash[curSum-target] \u003e 0 { count++ // 只记录一个 // 清空前缀和记录 hash = map[int]int{} curSum = 0 } hash[curSum]++ } return count } ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1546.-%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E9%9D%9E%E7%A9%BA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/:1:0","tags":["算法","数组","贪心","前缀和"],"title":"1546. 和为目标值且不重叠的非空子数组的最大数目","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1546.-%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E4%B8%94%E4%B8%8D%E9%87%8D%E5%8F%A0%E7%9A%84%E9%9D%9E%E7%A9%BA%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/"},{"categories":["刷题"],"content":"560. 和为 K 的子数组 给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。 示例 1： 输入：nums = [1,1,1], k = 2 输出：2 示例 2： 输入：nums = [1,2,3], k = 3 输出：2 ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/:0:0","tags":["算法","数组","前缀和"],"title":"560. 和为 K 的子数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"前缀和 前缀和：nums 的第 0 项到 当前项 的和。 定义 prefixSum 数组，prefixSum[x]：第 0 项到 第 x 项 的和。 nums 的 第 i 到 j 项 的和，即为 prefixSum[j] − prefixSum[i−1] 当 i 为 0，此时 i-1 为 -1，我们故意让 prefixSum[-1] 为 0，使得通式在 i=0 时也成立 // 前缀和 func subarraySum(nums []int, k int) int { count := 0 curSum := 0 // 记录每次循环当前的前缀和 hash := map[int]int{ 0: 1, // 前缀和为0 出现过1次了 } for i := 0; i \u003c len(nums); i++ { curSum += nums[i] if hash[curSum-k] \u003e 0 { // 当前前缀和减去k的结果也在之前的前缀和表中 代表找到一个和为k的连续子数组 count += hash[curSum-k] } hash[curSum]++ // 记录一个前缀和 } return count } ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/:1:0","tags":["算法","数组","前缀和"],"title":"560. 和为 K 的子数组","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"},{"categories":["刷题"],"content":"904. 水果成篮 mid ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/:0:0","tags":["算法","数组","动态规划","滑动窗口"],"title":"904. 水果成篮","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"},{"categories":["刷题"],"content":"DP 每次都分别记录两种水果最后一次出现时的索引 aIndex 和 bIndex func totalFruit(fruits []int) int { if len(fruits) == 0 { return 0 } a, b, aIndex, bIndex := -1, fruits[0], -1, 0 pre, curResult, maxResult := 1, 1, 1 // 记录dp[i-1] dp[i] max(dp[i]) for i := 1; i \u003c len(fruits); i++ { if fruits[i] == a || fruits[i] == b { // 加老果子 if fruits[i] == a { aIndex = i } if fruits[i] == b { bIndex = i } curResult = pre + 1 } else { // 换新果子 var length int // 计算最近一类果实的长度 并覆盖掉丢弃果子的种类 if aIndex \u003e bIndex { length = aIndex - bIndex b = fruits[i] bIndex = i } else { length = bIndex - aIndex a = fruits[i] aIndex = i } curResult = length + 1 } pre = curResult if maxResult \u003c curResult { maxResult = curResult } } return maxResult } ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/:1:0","tags":["算法","数组","动态规划","滑动窗口"],"title":"904. 水果成篮","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"},{"categories":["刷题"],"content":"滑动窗口 思想跟 DP 类似 // 滑动窗口 func totalFruit3(fruits []int) int { if len(fruits) == 0 { return 0 } a, b, aIndex, bIndex := -1, fruits[0], -1, 0 i, j := -1, 0 // i为左边界 保证i+1到j maxLen := 0 for j \u003c len(fruits) { if fruits[j] != a \u0026\u0026 fruits[j] != b { // j是新果子 if aIndex \u003e bIndex { // 将i移至淘汰的旧果子最后的位置 i = bIndex // 替换旧果子 b = fruits[j] bIndex = j } else { i = aIndex a = fruits[j] aIndex = j } } else { // j是老果子 if fruits[j] == a { aIndex = j } if fruits[j] == b { bIndex = j } } if j-i \u003e maxLen { maxLen = j - i } j++ } return maxLen } ","date":"2022-02-24","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/:2:0","tags":["算法","数组","动态规划","滑动窗口"],"title":"904. 水果成篮","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/904.-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/"},{"categories":["算法"],"content":"141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 ","date":"2022-02-23","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:0:0","tags":["算法","链表"],"title":"141. 环形链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["算法"],"content":"哈希表 // 非常朴素的哈希表 func hasCycle(head *ListNode) bool { hash := make(map[*ListNode]bool) for head != nil { if _, ok := hash[head]; ok { return true } hash[head] = true head = head.Next } return false } ","date":"2022-02-23","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:1:0","tags":["算法","链表"],"title":"141. 环形链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["算法"],"content":"快慢指针 fast 每次走两步，slow 每次走一步，若是循环链表一定会相遇 // 非常高级的双指针 func hasCycle2(head *ListNode) bool { slow, fast := head, head for slow != nil \u0026\u0026 fast != nil \u0026\u0026 fast.Next != nil { slow = slow.Next fast = fast.Next.Next if slow == fast { return true } } return false } ","date":"2022-02-23","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/:2:0","tags":["算法","链表"],"title":"141. 环形链表","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/141.-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/"},{"categories":["Golang"],"content":"进阶 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:0:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"编译原理 Token -\u003e 语法树 AST -\u003e 中间码 -\u003e 机器码 词法与语法分析 词法分析的作用就是解析源代码文件，它将文件中的字符串序列转换成 Token 序列，方便后面的处理和解析 语法分析器会按照顺序解析 Token 序列，并转换成语法树 该过程会将词法分析生成的 Token 按照编程语言定义好的文法（Grammar）自下而上或者自上而下的规约，每一个 Go 的源代码文件最终会被归纳成一个 SourceFile 结构 SourceFile = PackageClause \";\" { ImportDecl \";\" } { TopLevelDecl \";\" } . 词法分析会返回一个不包含空格、换行等字符的 Token 序列，例如：package, json, import, (, io, ), …，而语法分析会把 Token 序列转换成有意义的结构体，即语法树： \"json.go\": SourceFile { PackageName: \"json\", ImportDecl: []Import{ \"io\", }, TopLevelDecl: ... } 语法解析的过程中发生的任何语法错误都会被语法解析器发现并将消息打印到标准输出上，整个编译过程也会随着错误的出现而被中止。 类型检查 Go 语言的编译器会对语法树中定义和使用的类型进行检查，类型检查会按照以下的顺序分别验证和处理不同类型的节点： 常量、类型和函数名及类型； 变量的赋值和初始化； 函数和闭包的主体； 哈希键值对的类型； 导入函数体； 外部的声明； 通过对整棵抽象语法树的遍历，我们在每个节点上都会对当前子树的类型进行验证，以保证节点不存在类型错误，所有的类型错误和不匹配都会在这一个阶段被暴露出来，其中包括：结构体对接口的实现。 类型检查阶段不止会对节点的类型进行验证，还会展开和改写一些内建的函数，例如 make 关键字在这个阶段会根据子树的结构被替换成 runtime.makeslice 或者 runtime.makechan 等函数。 中间代码生成 当我们将源文件转换成了抽象语法树、对整棵树的语法进行解析并进行类型检查之后，就可以认为当前文件中的代码不存在语法错误和类型错误的问题了，Go 语言的编译器就会将输入的抽象语法树转换成中间代码。 在类型检查之后，编译器会通过 cmd/compile/internal/gc.compileFunctions 编译整个 Go 语言项目中的全部函数，这些函数会在一个编译队列中等待几个 Goroutine 的消费，并发执行的 Goroutine 会将所有函数对应的抽象语法树转换成中间代码。 由于 Go 语言编译器的中间代码使用了 SSA 的特性，所以在这一阶段我们能够分析出代码中的无用变量和片段并对代码进行优化 机器码生成 Go 语言源代码的 src/cmd/compile/internal 目录中包含了很多机器码生成相关的包，不同类型的 CPU 分别使用了不同的包生成机器码，其中包括 amd64、arm、arm64、mips、mips64、ppc64、s390x、x86 和 wasm ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:1:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"数据结构 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"chan src/runtime/chan.go:hchan 定义了 channel 的数据结构： type hchan struct { qcount uint // 当前队列中剩余元素个数 dataqsiz uint // 环形队列长度，即可以存放的元素个数 buf unsafe.Pointer // 环形队列指针 elemsize uint16 // 每个元素的大小 closed uint32 // 标识关闭状态 elemtype *_type // 元素类型 sendx uint // 队列下标，指示元素写入时存放到队列中的位置 recvx uint // 队列下标，指示元素从队列的该位置读出 recvq waitq // 等待读消息的goroutine队列 sendq waitq // 等待写消息的goroutine队列 lock mutex // 互斥锁，chan不允许并发读写 } 结构 环形队列 chan 内部实现了一个环形队列作为其缓冲区，队列的长度是创建 chan 时指定的。 dataqsiz 指示了队列长度为 6，即可缓存 6 个元素； buf 指向队列的内存，队列中还剩余两个元素； qcount 表示队列中还有两个元素； sendx 指示后续写入的数据存储的位置，取值 [0, 6)； recvx 指示从该位置读取数据, 取值 [0, 6) 等待队列 从 channel 读数据，如果 channel 缓冲区为空或者没有缓冲区，当前 goroutine 会被阻塞。 向 channel 写数据，如果 channel 缓冲区已满或者没有缓冲区，当前 goroutine 会被阻塞。 被阻塞的 goroutine 将会挂在 channel 的等待队列中： 因读阻塞的 goroutine 会被向 channel 写入数据的 goroutine 唤醒； 因写阻塞的 goroutine 会被从 channel 读数据的 goroutine 唤醒； 下图展示了一个没有缓冲区的 channel，有几个 goroutine 阻塞等待读数据： 注意，一般情况下 recvq 和 sendq 至少有一个为空。只有一个例外，那就是同一个 goroutine 使用 select 语句向 channel 一边写数据，一边读数据（？ 类型信息 一个 channel 只能传递一种类型的值，类型信息存储在 hchan 数据结构中。 elemtype 代表类型，用于数据传递过程中的赋值； elemsize 代表类型大小，用于在 buf 中定位元素位置。 锁 channel 不支持并发读写，一个 channel 同时仅允许被一个 goroutine 读写，为简单起见，后续部分说明读写过程时不再涉及加锁和解锁。 channel 操作 创建 创建 channel 的过程实际上是初始化 hchan 结构。其中类型信息和缓冲区长度由 make 语句传入，buf 的大小则与元素大小和缓冲区长度共同决定。 创建 channel 的伪代码如下所示： func makechan(t *chantype, size int) *hchan { var c *hchan c = new(hchan) c.buf = malloc(元素类型大小*size) c.elemsize = 元素类型大小 c.elemtype = 元素类型 c.dataqsiz = size return c } 向 channel 中写 向一个 channel 中写数据简单过程如下： 如果等待接收队列 recvq 不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从 recvq 取出 G，并把数据写入，最后把该 G 唤醒，结束发送过程； 如果缓冲区中有空余位置，将数据写入缓冲区，结束发送过程； 如果缓冲区中没有空余位置，将待发送数据写入 G，将当前 G 加入 sendq，进入睡眠，等待被读 goroutine 唤醒； 简单流程图如下： 向 channel 中读 从一个 channel 读数据简单过程如下： 如果等待发送队列 sendq 不为空，且没有缓冲区，直接从 sendq 中取出 G，把 G 中数据读出，最后把 G 唤醒，结束读取过程； 如果等待发送队列 sendq 不为空，此时说明缓冲区已满，从缓冲区中首部读出数据，把 G 中数据写入缓冲区尾部，把 G 唤醒，结束读取过程； 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程； 将当前 goroutine 加入 recvq，进入睡眠，等待被写 goroutine 唤醒； 简单流程图如下： 关闭 关闭 channel 时会把 recvq 中的 G 全部唤醒，本该写入 G 的数据位置为 nil。 把 sendq 中的 G 全部唤醒，但这些 G 会 panic。 除此之外，panic 出现的常见场景还有： 关闭值为 nil 的 channel 关闭已经被关闭的 channel 向已经关闭的 channel 写数据 常见用法 单项 channel 顾名思义，单向 channel 指只能用于发送或接收数据，实际上也没有单向 channel。 我们知道 channel 可以通过参数传递，所谓单向 channel 只是对 channel 的一种使用限制，这跟 C 语言使用 const 修饰函数参数为只读是一个道理。 func readChan(chanName \u003c-chan int)： 通过形参限定函数内部只能从 channel 中读取数据 func writeChan(chanName chan\u003c- int)： 通过形参限定函数内部只能向 channel 中写入数据 一个简单的示例程序如下： func readChan(chanName \u003c-chan int) { \u003c- chanName } func writeChan(chanName chan\u003c- int) { chanName \u003c- 1 } func main() { var mychan = make(chan int, 10) writeChan(mychan) readChan(mychan) } mychan 是个正常的 channel，而 readChan() 参数限制了传入的 channel 只能用来读，writeChan() 参数限制了传入的 channel 只能用来写。 select 使用 select 可以监控多 channel，比如监控多个 channel，当其中某一个 channel 有数据时，就从其读出数据。 一个简单的示例程序如下： package main import ( \"fmt\" \"time\" ) func addNumberToChan(chanName chan int) { for { chanName \u003c- 1 time.Sleep(1 * time.Second) } } func main() { var chan1 = make(chan int, 10) var chan2 = make(chan int, 10) go addNumberToChan(chan1) go addNumberToChan(chan2) for { select { case e := \u003c- chan1 : fmt.Printf(\"Get element from chan1: %d\\n\", e) case e := \u003c- chan2 : fmt.Printf(\"Get element from chan2: %d\\n\", e) default: fmt.Printf(\"No element in chan1 and chan2.\\n\") time.Sleep(1 * time.Second) } } } 程序中创建两个 channel： chan1 和 chan2。函数 addNumberToChan() 函数会向两个 channel 中周期性写入数据。通过 select 可以监控两个 channel，任意一个可读时就从其中读出数据。 程序输出如下： D:\\SourceCode\\GoExpert\\src\u003ego run main.go Get element from chan1: 1 Get element from chan2: 1 No element in chan1 and chan2. Get element from chan2: 1 Get element from chan1: 1 No element in chan1 and chan2. Get element from chan2: 1 Get element from chan1: 1 No element in chan1 and chan2. 从输出可见，从 channel 中读出数据的顺序是随机的，事实上 select 语句的多个 case 执行顺序是随机的。 通过这个示例想说的是：select 的 case 语句读 channel 不会阻塞，尽管 channel 中没有数据。这是由于 case 语句编译后调用读 channel 时会明确传入不阻塞的参数，此时读不到数据时不会将当前 goroutine 加入到等待队列，而是直接返回。 range 通过 range 可以持续从 channel 中读出数据，好像在遍历一个数组一样，当 channel 中没有数据时会阻塞当前 goroutine，与读 channel 时阻塞处理机制一样。 func chanRange(chanName chan int) {","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"slice Slice 依托数组实现，底层数组对用户屏蔽，在底层数组容量不足时可以实现自动重分配并生成新的 Slice。 源码包中 src/runtime/slice.go:slice 定义了 Slice 的数据结构： type slice struct { array unsafe.Pointer len int cap int } 从数据结构看 Slice 很清晰，array 指针指向底层数组，len 表示切片长度，cap 表示底层数组容量。 使用 make 创建 Slice 使用 make 来创建 Slice 时，可以同时指定长度和容量，创建时底层会分配一个数组，数组的长度即容量。 例如，语句 slice := make([]int, 5, 10) 所创建的 Slice，结构如下图所示： 该 Slice 长度为 5，即可以使用下标 slice[0] ~ slice[4] 来操作里面的元素，capacity 为 10，表示后续向 slice 添加新的元素时可以不必重新分配内存，直接使用预留内存即可。 使用数组创建 Slice 使用数组来创建 Slice 时，Slice 将与原数组共用一部分内存。 例如，语句 slice := array[5:7] 所创建的 Slice，结构如下图所示： 切片从数组 array[5] 开始，到数组 array[7] 结束（不含 array[7]），即切片长度为 2，数组后面的内容都作为切片的预留内存，即 capacity 为 5。 数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。 Slice 扩容 使用 append 向 Slice 追加元素时，如果 Slice 空间不足，将会触发 Slice 扩容 扩容实际上重新一配一块更大的内存，将原 Slice 数据拷贝进新 Slice，然后返回新 Slice，扩容后再将数据追加进去。 例如，当向一个 capacity 为 5，且 length 也为 5 的 Slice 再次追加 1 个元素时，就会发生扩容，如下图所示： 扩容操作只关心容量，会把原 Slice 数据拷贝到新 Slice，追加数据由 append() 在扩容结束后完成。 上图可见，扩容后新的 Slice 长度仍然是 5，但容量由 5 提升到了 10，原 Slice 的数据也都拷贝到了新 Slice 指向的数组中。 扩容容量的选择遵循以下规则： 如果原 Slice 容量小于 1024，则新 Slice 容量将扩大为原来的 2 倍； 如果原 Slice 容量大于等于 1024，则新 Slice 容量将扩大为原来的 1.25 倍； 使用 append() 向 Slice 添加一个元素的实现步骤如下： 假如 Slice 容量够用，则将新元素追加进去，Slice.len++，返回原 Slice 原 Slice 容量不够，则 将 Slice 先扩容，扩容后得到新 Slice 将新元素追加进新 Slice，Slice.len++，返回新的Slice。 Slice Copy 使用 copy() 内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。 例如长度为 10 的切片拷贝到长度为 5 的切片时，将会拷贝 5 个元素。 也就是说，copy 过程中不会发生扩容。 特殊切片 跟据数组或切片生成新的切片一般使用 slice := array[start:end] 方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从 start 开始直至 array 的结束。 比如下面两个切片，长度和容量都是一致的，使用共同的内存地址： sliceA := make([]int, 5, 10) sliceB := sliceA[0:5] 根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即 slice[start🔚cap], 其中 cap 即为新切片的容量，当然容量不能超过原切片实际值，如下所示： sliceA := make([]int, 5, 10) //length = 5; capacity = 10 sliceB := sliceA[0:5] //length = 5; capacity = 10 sliceC := sliceA[0:5:5] //length = 5; capacity = 5 这切片方法不常见，在 Golang 源码里能够见到，不过非常利于切片的理解。 Tips 创建切片时可跟据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能； 切片拷贝时需要判断实际拷贝的元素个数 谨慎使用多个切片操作同一个数组，以防读写冲突 总结 每个切片都指向一个底层数组 每个切片都保存了当前切片的长度、底层数组可用容量 使用 len() 计算切片长度时间复杂度为 O(1)，不需要遍历切片 使用 cap() 计算切片容量时间复杂度为 O(1)，不需要遍历切片 通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已 使用 append() 向切片追加元素时有可能触发扩容，扩容后将会生成新的切片 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"map Golang 的 map 使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即 bucket，而每个 bucket 就保存了 map 中的一个或一组键值对。 map 数据结构由 runtime/map.go/hmap 定义: type hmap struct { count int // 当前保存的元素个数 ... B uint8 // 指示bucket数组的大小 ... buckets unsafe.Pointer // bucket数组指针，数组的大小为2^B ... } 下图展示一个拥有 4 个 bucket 的 map： 本例中, hmap.B=2， 而 hmap.buckets 长度是 2^B^ 为 4。元素经过哈希运算后会落到某个 bucket 中进行存储。查找过程类似。 bucket 很多时候被翻译为桶，所谓的哈希桶实际上就是 bucket。 bucket 数据结构 bucket 数据结构由 runtime/map.go/bmap 定义： type bmap struct { tophash [8]uint8 // 存储哈希值的高8位 data byte[1] // key value数据:key/key/key/.../value/value/value... overflow *bmap // 溢出bucket的地址 } 每个 bucket 可以存储 8 个键值对。 tophash 是个长度为 8 的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前 bucket 时会将哈希值的高位存储在该数组中，以方便后续匹配。 data 区存放的是 key-value 数据，存放顺序是 key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。 overflow 指针指向的是下一个 bucket，据此将所有冲突的键连接起来。 注意：上述中 data 和 overflow 并不是在结构体中显示定义的，而是直接通过指针运算（计算内存地址）进行访问的。我们能根据编译期间的 cmd/compile/internal/gc.bmap 函数重建它的结构： type bmap struct { topbits [8]uint8 keys [8]keytype values [8]valuetype pad uintptr overflow uintptr } 下图展示 bucket 存放 8 个 key-value 对： 哈希冲突 当有两个或以上数量的键被哈希到了同一个 bucket 时，我们称这些键发生了冲突。Go 使用链地址法（拉链法）来解决键冲突。 由于每个 bucket 可以存放 8 个键值对，所以同一个 bucket 存放超过 8 个键值对时就会再创建一个键值对，用类似链表的方式将 bucket 连接起来。 下图展示产生冲突后的map： bucket 数据结构指示下一个 bucket 的指针称为 overflow bucket（溢出桶），意为当前 bucket 盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。 负载因子 负载因子用于衡量一个哈希表冲突情况，公式为： 负载因子 = 键数量/bucket数量 例如，对于一个 bucket 数量为 4，包含 4 个键值对的哈希表来说，这个哈希表的负载因子为 1. 哈希表需要将负载因子控制在合适的大小，超过其阀值需要进行 rehash，也即键值对重新组织： 哈希因子过小，说明空间利用率低 哈希因子过大，说明冲突严重，存取效率低 每个哈希表的实现对负载因子容忍程度不同 比如 Redis 实现中负载因子大于 1 时就会触发 rehash，而 Go 则在在负载因子达到 6.5 时才会触发 rehash， 因为 Redis 的每个 bucket 只能存 1 个键值对，而 Go 的 bucket 可能存 8 个键值对，所以 Go 可以容忍更高的负载因子。 渐进式扩容 扩容的前提条件 为了保证访问效率，当新元素将要添加进 map 时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。 触发扩容的条件有二个： 负载因子 \u003e 6.5 时，也即平均每个 bucket 存储的键值对达到 6.5 个。 overflow 数量 \u003e 2^15^ 时，也即 overflow 数量超过 32768 时。 增量扩容 当负载因子过大时，就新建一个 bucket，新的 bucket 长度是原来的 2 倍，然后旧 bucket 数据搬迁到新的 bucket。 考虑到如果 map 存储了数以亿计的 key-value，一次性搬迁将会造成比较大的延时，Go 采用逐步搬迁策略，即每次访问 map 时都会触发一次搬迁，每次搬迁 2 个键值对。 下图展示了包含一个 bucket 满载的 map (为了描述方便，图中 bucket 省略了 value 区域): 当前 map 存储了 7 个键值对，只有 1 个 bucket。此时负载因子为 7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的 bucket。 当第 8 个键值对插入时，将会触发扩容，扩容后示意图如下： hmap 数据结构中 oldbuckets 成员指身原 bucket，而 buckets 指向了新申请的 bucket。新的键值对被插入新的bucket 中。 后续对 map 的访问操作会触发迁移，将 oldbuckets 中的键值对逐步的搬迁过来。当 oldbuckets 中的键值对全部搬迁完毕后，删除 oldbuckets。 搬迁完成后的示意图如下： 数据搬迁过程中原 bucket 中的键值对将存在于新 bucket 的前面，新插入的键值对将存在于新 bucket 的后面。 实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。 等量扩容 所谓等量扩容，实际上并不是扩大容量，buckets 数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使 bucket 的使用率更高，进而保证更快的存取。 在极端场景下，比如不断的增删，而键值对正好集中在一小部分的 bucket，这样会造成 overflow 的 bucket 数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示： 上图可见，overflow 的 buckt 中大部分是空的，访问效率会很差。此时进行一次等量扩容，即 buckets 数量不变，经过重新组织后 overflow 的 bucket 数量会减少，即节省了空间又会提高访问效率。 查找过程 查找过程如下： 跟据 key 值算出哈希值 取哈希值低位与 hmpa.B 取模确定 bucket 位置 取哈希值高位在 tophash 数组中查询 如果 tophash[i] 中存储值也哈希值相等，则去找到该 bucket 中的 key 值进行比较 当前 bucket 没有找到，则继续从下个 overflow 的 bucket 中查找。 如果当前处于搬迁过程，则优先从 oldbuckets 查找 注：如果查找不到，也不会返回空值，而是返回相应类型的 0 值。 插入过程 新员素插入过程如下： 跟据 key 值算出哈希值 取哈希值低位与 hmap.B 取模确定 bucket 位置 查找该 key 是否已经存在，如果存在则直接更新值 如果没找到将 key，将 key 插入 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:3","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"struct Go 的 struct 声明允许字段附带 Tag 来对字段做一些标记。 该 Tag 不仅仅是一个字符串那么简单，因为其主要用于反射场景，reflect 包中提供了操作 Tag 的方法，所以 Tag 写法也要遵循一定的规则。 常见的 tag 用法，主要是 JSON 数据解析、ORM 映射等。 Tag 的本质 Tag 规则 Tag 本身是一个字符串，但字符串中却是：以空格分隔的 key:value 对。 key：必须是非空字符串，字符串不能包含控制字符、空格、引号、冒号。 value：以双引号标记的字符串 注意：冒号前后不能有空格 如下代码所示，如此写没有实际意义，仅用于说明 Tag 规则 type Server struct { ServerName string `key1: \"value1\" key11:\"value11\"` ServerIP string `key2: \"value2\"` } 上述代码 ServerName 字段的 Tag 包含两个 key-value 对。ServerIP 字段的 Tag 只包含一个 key-value 对。 Tag 是 Struct 的一部分 前面说过，Tag 只有在反射场景中才有用，而反射包中提供了操作 Tag 的方法。在说方法前，有必要先了解一下 Go 是如何管理 struct 字段的。 以下是 reflect 包中的类型声明，省略了部分与本文无关的字段。 // A StructField describes a single field in a struct. type StructField struct { // Name is the field name. Name string ... Type Type // field type Tag StructTag // field tag string ... } type StructTag string 可见，描述一个结构体成员的结构中包含了 StructTag，而其本身是一个 string。也就是说 Tag 其实是结构体字段的一个组成部分。 获取 Tag StructTag 提供了 Get(key string) string 方法来获取 Tag，示例如下： package main import ( \"reflect\" \"fmt\" ) type Server struct { ServerName string `key1:\"value1\" key11:\"value11\"` ServerIP string `key2:\"value2\"` } func main() { s := Server{} st := reflect.TypeOf(s) field1 := st.Field(0) fmt.Printf(\"key1:%v\\n\", field1.Tag.Get(\"key1\")) fmt.Printf(\"key11:%v\\n\", field1.Tag.Get(\"key11\")) filed2 := st.Field(1) fmt.Printf(\"key2:%v\\n\", filed2.Tag.Get(\"key2\")) } 程序输出如下： key1:value1 key11:value11 key2:value2 Tag 存在的意义 本文示例中 tag 没有任何实际意义，这是为了阐述 tag 的定义与操作方法，也为了避免与你之前见过的诸如 json:xxx 混淆。 使用反射可以动态的给结构体成员赋值，正是因为有 tag，在赋值前可以使用 tag 来决定赋值的动作。 比如，官方的 encoding/json 包，可以将一个JSON数据 Unmarshal 进一个结构体，此过程中就使用了 Tag。该包定义一些规则，只要参考该规则设置 tag 就可以将不同的 JSON 数据转换成结构体。 总之：正是基于 struct 的 tag 特性，才有了诸如 json、orm 等等的应用。理解这个关系是至关重要的。或许，你可以定义另一种 tag 规则，来处理你特有的数据。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:4","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"iota 我们知道 iota 常用于 const 表达式中，我们还知道其值是从零开始，const 声明块中每增加一行 iota 值自增 1。 使用 iota 可以简化常量定义，但其规则必须要牢牢掌握，否则在阅读别人源码时可能会造成误解或障碍。 规则 很多书上或博客描述的规则是这样的： iota 在 const 关键字出现时被重置为 0 const 声明块中每新增一行 iota 值自增 1 其实规则只有一条： iota 代表了 const 声明块的行索引（下标从 0 开始） 下面再来根据这个规则看下这段代码： const ( bit0, mask0 = 1 \u003c\u003c iota, 1\u003c\u003ciota - 1 // const声明第0行，即iota==0 bit1, mask1 // const声明第1行，即iota==1, 表达式继承上面的语句 _, _ // const声明第2行，即iota==2 bit3, mask3 // const声明第3行，即iota==3 ) 第 0 行的表达式展开即 bit0, mask0 = 1 \u003c\u003c 0, 1\u003c\u003c0 - 1，所以 bit0 == 1，mask0 == 0； 第 1 行没有指定表达式，则继承第一行，即 bit1, mask1 = 1 \u003c\u003c 1, 1\u003c\u003c1 - 1，所以 bit1 == 2，mask1 == 1； 第 2 行没有定义常量 第 3 行没有指定表达式，则继承第一行，即 bit3, mask3 = 1 \u003c\u003c 3, 1\u003c\u003c3 - 1，所以 bit0 == 8，mask0 == 7； 编译原理 const 块中每一行在 GO 中使用 spec 数据结构描述，spec 声明如下： // A ValueSpec node represents a constant or variable declaration // (ConstSpec or VarSpec production). // ValueSpec struct { Doc *CommentGroup // associated documentation; or nil Names []*Ident // value names (len(Names) \u003e 0) Type Expr // value type; or nil Values []Expr // initial values; or nil Comment *CommentGroup // line comments; or nil } 这里我们只关注 ValueSpec.Names， 这个切片中保存了一行中定义的常量，如果一行定义 N 个常量，那么ValueSpec.Names 切片长度即为N。 const 块实际上是 spec 类型的切片，用于表示 const 中的多行。 所以编译期间构造常量时的伪算法如下： for iota, spec := range ValueSpecs { for i, name := range spec.Names { obj := NewConst(name, iota...) //此处将iota传入，用于构造常量 ... } } 从上面可以更清晰的看出 iota 实际上是遍历 const 块的索引，每行中即便多次使用 iota，其值也不会递增。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:5","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"string string 标准概念 Go 标准库 builtin 给出了所有内置类型的定义。 源代码位于 src/builtin/builtin.go，其中关于 string 的描述如下: // string is the set of all strings of 8-bit bytes, conventionally but not // necessarily representing UTF-8-encoded text. A string may be empty, but // not nil. Values of string type are immutable. type string string 所以 string 是 8 比特字节的集合，通常但并不一定是 UTF-8 编码的文本。 另外，还提到了两点，非常重要： string 可以为空（长度为 0），但不会是 nil； string 对象不可以修改。 string 数据结构 源码包 src/runtime/string.go:stringStruct 定义了 string 的数据结构： type stringStruct struct { str unsafe.Pointer len int } 其数据结构很简单： stringStruct.str：字符串的首地址； stringStruct.len：字符串的长度； string 数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上 string 和切片，准确的说是 byte 切片经常发生转换。 string 操作 声明 如下代码所示，可以声明一个 string 变量变赋予初值： var str string str = \"Hello World\" 字符串构建过程是先跟据字符串构建 stringStruct，再转换成 string。转换的源码如下： func gostringnocopy(str *byte) string { // 跟据字符串地址构建string ss := stringStruct{str: unsafe.Pointer(str), len: findnull(str)} // 先构造stringStruct s := *(*string)(unsafe.Pointer(\u0026ss)) // 再将stringStruct转换成string return s } string 在 runtime 包中就是 stringStruct，对外呈现叫做 string。 []byte 转 string byte 切片可以很方便的转换成 string，如下所示： func GetStringBySlice(s []byte) string { return string(s) } 需要注意的是这种转换需要一次内存拷贝。 转换过程如下： 跟据切片的长度申请内存空间，假设内存地址为 p，切片长度为 len(b)； 构建 string（string.str = p；string.len = len；） 拷贝数据 (切片中数据拷贝到新申请的内存空间) 转换示意图： string 转 []byte string 也可以方便的转成 byte 切片，如下所示： func GetSliceByString(str string) []byte { return []byte(str) } string 转换成 byte 切片，也需要一次内存拷贝，其过程如下： 申请切片内存空间 将 string 拷贝到切片 转换示意图： 字符串拼接 字符串可以很方便的拼接，像下面这样： str := \"Str1\" + \"Str2\" + \"Str3\" 即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。 一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。 字符串拼接伪代码如下： func concatstrings(a []string) string { // 字符串拼接 length := 0 // 拼接后总的字符串长度 for _, str := range a { length += length(str) } s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间 for _, str := range a { copy(b, str) // string无法修改，只能通过切片修改 b = b[len(str):] } return s } 因为 string 是无法直接修改的，所以这里使用 rawstring() 方法初始化一个指定大小的 string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了 string。 rawstring() 源代码如下： func rawstring(size int) (s string, b []byte) { // 生成一个新的string，返回的string和切片共享相同的空间 p := mallocgc(uintptr(size), nil, false) stringStructOf(\u0026s).str = p stringStructOf(\u0026s).len = size *(*slice)(unsafe.Pointer(\u0026b)) = slice{p, size, size} return } 思考 为什么字符串不允许修改？ 像 C++ 语言中的 string，其本身拥有内存空间，修改 string 是支持的。但 Go 的实现中，string 不包含内存空间，只有一个内存的指针，这样做的好处是 string 变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。 因为 string 通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了 string 不可修改的约定。 []byte 转换成 string 一定会拷贝内存吗？ byte 切片转换成 string 的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte 切片转换成string 时并不会拷贝内存，而是直接返回一个 string，这个 string 的指针 (string.str) 指向切片的内存。 比如，编译器会识别如下临时场景： 使用 m[string(b)] 来查找 map（map 是 string 为 key，临时把切片 b 转成 string）； 字符串拼接，如 \"\u003c\" + \"string(b)\" + \"\u003e\"； 字符串比较：string(b) == \"foo\" 因为是临时把 byte 切片转换成 string，也就避免了因 byte 切片扩容改成而导致 string 引用失败的情况，所以此时可以不必拷贝内存新建一个 string。 string 和 []byte 如何取舍 string 和 []byte 都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要跟据实际应用场景来选择。 string 擅长的场景： 需要字符串比较的场景； 不需要 nil 字符串的场景； []byte 擅长的场景： 修改字符串的场景，尤其是修改粒度为1个字节； 函数返回值，需要用 nil 表示含义的场景； 需要切片操作的场景； 虽然看起来 string 适用的场景不如 []byte 多，但因为 string 直观，在实际应用中还是大量存在，在偏底层的实现中 []byte 使用更多。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:2:6","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"常用控制结构实现原理 本章主要介绍常见的控制结构，比如 defer、select、range 等，通过对其底层实现原理的分析，来加深认识，以此避免一些使用过程中的误区。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"defer defer 语句用于延迟函数的调用，每次 defer 都会把一个函数压入栈中，函数返回前再把延迟的函数取出并执行。 为了方便描述，我们把创建 defer 的函数称为主函数，defer 语句后面的函数称为延迟函数。 延迟函数可能有输入参数，这些参数可能来源于定义 defer 的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为，这些场景下，如果不了解 defer 的规则很容易出错。 其实官方说明的 defer 的三个原则很清楚，本节试图汇总 defer 的使用场景并做简单说明。 例子 例一 下面函数输出结果是什么？ func deferFuncParameter() { var aInt = 1 defer fmt.Println(aInt) aInt = 2 return } 输出 1。 延迟函数 fmt.Println(aInt) 的参数在 defer 语句出现时就已经确定了，所以无论后面如何修改 aInt 变量都不会影响延迟函数。 例二 package main import \"fmt\" func printArray(array *[3]int) { for i := range array { fmt.Println(array[i]) } } func deferFuncParameter() { var aArray = [3]int{1, 2, 3} defer printArray(\u0026aArray) aArray[0] = 10 return } func main() { deferFuncParameter() } 输出 10、2、3 三个值。 延迟函数 printArray() 的参数在defer语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在 return 语句之前，所以对数组的最终修改值会被打印出来。 例三 下面函数输出什么？ func deferFuncReturn() (result int) { i := 1 defer func() { result++ }() return i } 输出 2。 函数的 return 语句并不是原子的，实际执行分为 设置返回值 ret defer 语句实际执行在返回前，即拥有 defer 的函数返回过程是： 设置返回值 执行 defer ret。 所以 return 语句先把 result 设置为 i 的值，即 1，defer 语句中又把 result 递增 1，所以最终返回 2。 defer 规则 Golang 官方博客里总结了 defer 的行为规则，只有三条，我们围绕这三条进行说明。 规则一 延迟函数的参数在 defer 语句出现时就已经确定下来了 官方给出一个例子，如下所示： func a() { i := 0 defer fmt.Println(i) i++ return } defer 语句中的 fmt.Println() 参数 i 值在 defer 出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响 fmt.Println() 函数的执行，仍然打印 “0”。 注意：对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，defer后面的语句对变量的修改可能会影响延迟函数。 规则二 延迟函数执行按后进先出顺序执行，即先出现的 defer 最后执行 这个规则很好理解，定义 defer 类似于入栈操作，执行 defer 类似于出栈操作。 设计 defer 的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请 A 资源，再跟据 A 资源申请 B 资源，跟据 B 资源申请 C 资源，即申请顺序是：A–\u003eB–\u003eC，释放时往往又要反向进行。 每申请到一个用完需要释放的资源时，立即定义一个 defer 来释放资源是个很好的习惯。 规则三 延迟函数可能操作主函数的具名返回值 定义 defer 的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer 所作用的函数，即延迟函数可能会影响到返回值。 若要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回的就足够了。 函数返回过程 有一个事实必须要了解，关键字 return 不是一个原子操作，实际上 return 只代理汇编指令 ret，即将跳转程序执行。 比如语句 return i，实际上分两步进行，即 将 i 值存入栈中作为返回值 执行跳转 而 defer 的执行时机正是跳转前，所以说 defer 执行时还是有机会操作返回值的。 举个实际的例子进行说明这个过程： func deferFuncReturn() (result int) { i := 1 defer func() { result++ }() return i } 该函数的return语句可以拆分成下面两行： result = i return 而延迟函数的执行正是在return之前，即加入defer后的执行过程如下： result = i result++ return 所以上面函数实际返回 i++ 值。 关于主函数有不同的返回方式，但返回机制就如上机介绍所说，只要把 return 语句拆开都可以很好的理解，下面分别举例说明 主函数拥有匿名返回值，返回字面值 一个主函数拥有一个匿名的返回值，返回时使用字面值，比如返回 “1”、“2”、“Hello” 这样的值，这种情况下 defer 语句是无法操作返回值的。 一个返回字面值的函数，如下所示： func foo() int { var i int defer func() { i++ }() return 1 } 上面的 return 语句，直接把 1 写入栈中作为返回值，延迟函数无法操作该返回值，所以就无法影响返回值。 主函数拥有匿名返回值，返回变量 一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下 defer 语句可以引用到返回值，但不会改变返回值。 一个返回本地变量的函数，如下所示： func foo() int { var i int defer func() { i++ }() return i } 上面的函数，返回一个局部变量，同时 defer 函数也会操作这个局部变量。 对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量为 “anony”，上面的返回语句可以拆分成以下过程： anony = i i++ return 由于 i 是整型，会将值拷贝给 anony，所以 defer 语句中修改i值，对函数返回值不造成影响。 主函数拥有具名返回值 主函声明语句中带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。如果defer 语句操作该返回值，可能会改变返回结果。 一个影响函返回值的例子： func foo() (ret int) { defer func() { ret++ }() return 0 } 上面的函数拆解出来，如下所示： ret = 0 ret++ return 函数真正返回前，在 defer 中对返回值做了 +1 操作，所以函数最终返回 1 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"defer 实现原理 本节我们尝试了解一些 defer 的实现机制。 defer 数据结构 源码包 src/src/runtime/runtime2.go:_defer 定义了 defer 的数据结构： type _defer struct { sp uintptr //函数栈指针 pc uintptr //程序计数器 fn *funcval //函数地址 link *_defer //指向自身结构的指针，用于链接多个defer } 我们知道 defer 后面一定要接一个函数的，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等等。 与函数不同的一点是它含有一个指针，可用于指向另一个 defer 每个 goroutine 数据结构中实际上也有一个 defer 指针，该指针指向一个 defer 的单链表 每次声明一个 defer 时就将 defer 插入到单链表表头 每次执行 defer 时就从单链表表头取出一个 defer 执行。 函数返回前执行 defer 则是从链表首部依次取出执行，不再赘述。 一个 goroutine 可能连续调用多个函数，defer 添加过程跟上述流程一致，进入函数时添加 defer，离开函数时取出 defer，所以即便调用多个函数，也总是能保证 defh后进先出方式执行的。 defer 的创建和执行 源码包 src/runtime/panic.go 定义了两个方法分别用于创建 defer 和执行 defer。 deferproc()： 在声明 defer 处调用，其将 defer 函数存入 goroutine 的链表中； deferreturn()：在 return 指令，准确的讲是在 ret 指令前调用，其将 defer 从 goroutine 链表中取出并执行。 可以简单这么理解：在编译阶段，声明 defer 处插入了函数 deferproc()；在函数 return 前插入了函数 deferreturn() ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"总结 defer 定义的延迟函数参数在 defer 语句出时就已经确定下来了 defer 定义顺序与实际执行顺序相反 return 不是原子操作，执行过程是：保存返回值(若有) –\u003e 执行 defer（若有）–\u003e 执行 ret 跳转 申请资源后立即使用 defer 关闭资源是好习惯 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:3","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"recover 项目中，有时为了让程序更健壮，也即不 panic，我们或许会使用 recover() 来接收异常并处理。 比如以下代码： func NoPanic() { if err := recover(); err != nil { fmt.Println(\"Recover success...\") } } func Dived(n int) { defer NoPanic() fmt.Println(1/n) } func NoPanic() 会自动接收异常，并打印相关日志，算是一个通用的异常处理函数。 业务处理函数中只要使用了 defer NoPanic()，那么就不会再有 panic 发生。 关于是否应该使用 recover 接收异常，以及什么场景下使用等问题不在本节讨论范围内。 本节关注的是这种用法的一个变体，在该变体下，recover 再也无法接收异常。 recover 使用误区 在项目中，有众多的数据库更新操作，正常的更新操作需要提交，而失败的就需要回滚，如果异常分支比较多， 就会有很多重复的回滚代码，所以有人尝试了一个做法：即在 defer 中判断是否出现异常，有异常则回滚，否则提交。 简化代码如下所示： func IsPanic() bool { if err := recover(); err != nil { fmt.Println(\"Recover success...\") return true } return false } func UpdateTable() { // defer中决定提交还是回滚 defer func() { if IsPanic() { // Rollback transaction } else { // Commit transaction } }() // Database update operation... } func IsPanic() bool 用来接收异常，返回值用来说明是否发生了异常。func UpdateTable() 函数中，使用 defer 来判断最终应该提交还是回滚。 上面代码初步看起来还算合理，但是此处的 IsPanic() 再也不会返回 true，不是 IsPanic() 函数的问题，而是其调用的位置不对。 recover 失效的条件 上面代码 IsPanic() 失效了，其原因是违反了 recover 的一个限制，导致 recover() 失效（永远返回 nil）。 以下三个条件会让 recover() 返回 nil: panic 时指定的参数为 nil；（一般 panic 语句如panic(\"xxx failed...\")） 当前协程没有发生 panic； recover 没有被 defer 方法直接调用； 前两条都比较容易理解，上述例子正是匹配第3个条件。 本例中，recover() 调用栈为 “defer （匿名）函数” --\u003e IsPanic() --\u003e recover()。也就是说，recover 并没有被defer 方法直接调用。符合第 3 个条件，所以 recover() 永远返回 nil ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:4","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"select select 是 Golang 在语言层面提供的多路 IO 复用的机制，其可以检测多个 channel 是否 ready (即是否可读或可写)，使用起来非常方便。 实现原理 Golang 实现 select 时，定义了一个数据结构表示每个 case 语句 (含 defaut，default 实际上是一种特殊的 case)，select 执行过程可以类比成一个函数，函数输入 case 数组，输出选中的 case，然后程序流程转到选中的 case 块。 case 数据结构 源码包 src/runtime/select.go:scase 定义了表示 case 语句的数据结构： type scase struct { c *hchan // chan kind uint16 elem unsafe.Pointer // data element } scase.c 为当前 case 语句所操作的 channel 指针，这也说明了一个 case 语句只能操作一个 channel。 scase.kind 表示该 case 的类型，分为读 channel、写 channel 和 default，三种类型分别由常量定义： caseRecv：case 语句中尝试读取 scase.c 中的数据； caseSend：case 语句中尝试向 scase.c 中写入数据； caseDefault： default 语句 scase.elem 表示缓冲区地址，跟据 scase.kind 不同，有不同的用途： scase.kind == caseRecv ： scase.elem 表示读出 channel 的数据存放地址； scase.kind == caseSend ： scase.elem 表示将要写入 channel 的数据存放地址； select 实现逻辑 源码包 src/runtime/select.go:selectgo() 定义了 select 选择 case 的函数： func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) 函数参数： cas0 为 scase 数组的首地址，selectgo() 就是从这些 scase 中找出一个返回。 order0 为一个两倍 cas0 数组长度的 buffer，保存 scase 随机序列 pollorder 和 scase 中 channel 地址序列 lockorder pollorder：每次 selectgo 执行都会把 scase 序列打乱，以达到随机检测 case 的目的。 lockorder：所有 case 语句中 channel 序列，以达到去重防止对 channel 加锁时重复加锁的目的。 ncases 表示 scase 数组的长度 函数返回值： int： 选中 case 的编号，这个 case 编号跟代码一致 bool: 是否成功从 channle 中读取了数据，如果选中的 case 是从 channel 中读数据，则该返回值表示是否读取成功。 selectgo() 实现伪代码如下： func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool) { //1. 锁定scase语句中所有的channel //2. 按照随机顺序检测scase中的channel是否ready // 2.1 如果case可读，则读取channel中数据，解锁所有的channel，然后返回(case index, true) // 2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index, false) // 2.3 所有case都未ready，则解锁所有的channel，然后返回（default index, false） //3. 所有case都未ready，且没有default语句 // 3.1 将当前协程加入到所有channel的等待队列 // 3.2 当将协程转入阻塞，等待被唤醒 //4. 唤醒后返回channel对应的case index // 4.1 如果是读操作，解锁所有的channel，然后返回(case index, true) // 4.2 如果是写操作，解锁所有的channel，然后返回(case index, false) } 特别说明：对于读 channel 的 case 来说，如 case elem, ok := \u003c-chan1:，如果 channel 有可能被其他协程关闭的情况下，一定要检测读取是否成功，因为 close 的 channel 也有可能返回，此时 ok == false。 总结 select 语句中除 default 外，每个 case 操作一个 channel，要么读要么写 select 语句中除 default 外，各 case 执行顺序是随机的 select 语句中如果没有 default 语句，则会阻塞等待任一 case select 语句中读操作要判断是否成功读取，关闭的 channel 也可以读取 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:5","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"range range 是 Golang 提供的一种迭代遍历手段，可操作的类型有数组、切片、Map、channel 等，实际使用频率非常高。 探索 range 的实现机制是很有意思的事情，这可能会改变你使用 range 的习惯。 例子 切片遍历 下面函数通过遍历切片，打印切片的下标和元素值，请问性能上有没有可优化的空间？ func RangeSlice(slice []int) { for index, value := range slice { _, _ = index, value } } 遍历过程中每次迭代会对 index 和 value 进行赋值 如果数据量大或者 value 类型为 string 时，对 value 的赋值操作可能是多余的 可以在 for-range 中忽略 value 值，使用 slice[index] 引用 value 值。 Map 遍历 下面函数通过遍历 Map，打印 Map 的 key 和 value，请问性能上有没有可优化的空间？ func RangeMap(myMap map[int]string) { for key, _ := range myMap { _, _ = key, myMap[key] } } 函数中 for-range 语句中只获取 key 值，然后跟据 key 值获取 value 值 虽然看似减少了一次赋值，但通过 key 值查找 value 值的性能消耗可能高于赋值消耗。能否优化取决于 map 所存储数据结构特征、结合实际情况进行。 动态遍历 请问如下程序是否能正常结束？ func main() { v := []int{1, 2, 3} for i:= range v { v = append(v, i) } } 能够正常结束。循环内改变切片的长度，不影响循环次数，循环次效在循环开始前就已经确定了。 实现原理 对于 for-range 语句的实现，可以从编译器源码中找到答案。 编译器源码 gofrontend/go/statements.cc/For_range_statement::do_lower() 方法中有如下注释。 // Arrange to do a loop appropriate for the type. We will produce // for INIT ; COND ; POST { // ITER_INIT // INDEX = INDEX_TEMP // VALUE = VALUE_TEMP // If there is a value // original statements // } 可见 range 实际上是一个 C 风格的循环结构。range 支持数组、数组指针、切片、map 和 channel 类型，对于不同类型有些细节上的差异。 range for slice 下面的注释解释了遍历 slice 的过程： // The loop we generate: // for_temp := range // len_temp := len(for_temp) // for index_temp = 0; index_temp \u003c len_temp; index_temp++ { // value_temp = for_temp[index_temp] // index = index_temp // value = value_temp // original body // } 遍历 slice 前会先获取以 slice 的长度 len_temp 作为循环次数，循环体中，每次循环会先获取元素值，如果 for-range 中接收 index 和 value 的话，则会对 index 和 value 进行一次赋值。 由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是没办法遍历到的。 另外，数组与数组指针的遍历过程与 slice 基本一致，不再赘述。 range for map 下面的注释解释了遍历 map 的过程： // The loop we generate: // var hiter map_iteration_struct // for mapiterinit(type, range, \u0026hiter); hiter.key != nil; mapiternext(\u0026hiter) { // index_temp = *hiter.key // value_temp = *hiter.val // index = index_temp // value = value_temp // original body // } 遍历 map 时没有指定循环次数，循环体与遍历 slice 类似。由于 map 底层实现与 slice 不同，map 底层使用 hash 表实现，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。 range for channel 遍历 channel 是最特殊的，这是由 channel 的实现机制决定的： // The loop we generate: // for { // index_temp, ok_temp = \u003c-range // if !ok_temp { // break // } // index = index_temp // original body // } channel 遍历是依次从 channel 中读取数据；读取前是不知道里面有多少个元素的。如果 channel 中没有元素，则会阻塞等待，如果 channel 已被关闭，则会解除阻塞并退出循环。 注： 上述注释中 index_temp 实际上描述是有误的，应该为 value_temp，因为 index 对于 channel 是没有意义的。 使用 for-range 遍历 channel 时只能获取一个返回值。 编程 Tips 遍历过程中可以适情况放弃接收 index 或 value，可以一定程度上提升性能 遍历 channel 时，如果 channel 中没有数据，可能会阻塞 尽量避免遍历过程中修改原数据 总结 for-range 的实现实际上是 C 风格的 for 循环 使用 index, value 接收 range 返回值会发生一次数据拷贝 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:6","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"mutex 互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此 Go 语言提供了非常简单易用的 Mutex，Mutex 为一结构体类型，对外暴露两个方法 Lock() 和 Unlock() 分别用于加锁和解锁。 Mutex 使用起来非常方便，但其内部实现却复杂得多，这包括 Mutex 的几种状态。另外，我们也想探究一下 Mutex 重复解锁引起 panic 的原因。 按照惯例，本节内容从源码入手，提取出实现原理，又不会过分纠结于实现细节。 Mutex 数据结构 Mutex 结构体 源码包 src/sync/mutex.go:Mutex 定义了互斥锁的数据结构： type Mutex struct { state int32 sema uint32 } Mutex.state 表示互斥锁的状态，比如是否被锁定等。 Mutex.sema 表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。 我们看到 Mutex.state 是 32 位的整型变量，内部实现时把该变量分成四份，用于记录 Mutex 的四种状态。 下图展示 Mutex 的内存布局： Locked: 表示该 Mutex 是否已被锁定 0：没有锁定 1：已被锁定。 Woken: 表示是否有协程已被唤醒 0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。 Starving：表示该 Mutex 是否处理饥饿状态 0：没有饥饿 1：饥饿状态，说明有协程阻塞了超过 1ms。 Waiter: 表示阻塞等待锁的协程个数，协程解锁时根据此值来判断是否需要释放信号量。 协程之间抢锁实际上是抢给 Locked 赋值的权利 能给 Locked 域置 1，就说明抢锁成功。 抢不到的话就阻塞等待Mutex.sema 信号量 一旦持有锁的协程解锁，等待的协程会依次被唤醒。 Woken 和 Starving 主要用于控制协程间的抢锁过程，后面再进行了解。 Mutex 方法 Mutext 对外提供两个方法，实际上也只有这两个方法： Lock()：加锁方法 Unlock()：解锁方法 下面我们分析一下加锁和解锁的过程，加锁分成功和失败两种情况，成功的话直接获取锁，失败后当前协程被阻塞，同样，解锁时跟据是否有阻塞协程也有两种处理。 加解锁过程 简单加锁 假定当前只有一个协程在加锁，没有其他协程干扰，那么过程如下图所示： 加锁过程会去判断 Locked 标志位是否为 0，如果是 0 则把 Locked 位置 1，代表加锁成功。 从上图可见，加锁成功后，只是 Locked 位置 1，其他状态位没发生变化。 加锁被阻塞 假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示： 从上图可看到，当协程 B 对一个已被占用的锁再次加锁时，Waiter 计数器增加了 1，此时协程 B 将被阻塞，直到Locked 值变为 0 后才会被唤醒。 简单解锁 假定解锁时，没有其他协程阻塞，此时解锁过程如下图所示： 由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把 Locked 位置为 0 即可，不需要释放信号量。 解锁并唤醒协程 假定解锁时，有 1 个或多个协程阻塞，此时解锁过程如下图所示： 协程 A 解锁过程分为两个步骤 Locked 位置 0 查看到 Waiter\u003e0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程 B 把 Locked 位置 1，于是协程 B 获得锁。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:7","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"自旋过程 加锁时，如果当前 Locked 位为 1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续地探测 Locked 位是否变为 0，这个过程即为自旋过程。 自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。 自旋的好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程的切换。 什么是自旋 自旋对应于 CPU 的 “PAUSE” 指令，CPU 对该指令什么都不做，相当于 CPU 空转，对程序而言相当于 sleep 了一小段时间，时间非常短，当前实现是 30 个时钟周期。 自旋过程中会持续探测 Locked 是否变为 0，连续两次探测间隔就是执行这些 PAUSE 指令，它不同于 sleep，不需要将协程转为睡眠状态。 自旋条件 加锁时程序会自动判断是否可以自旋，无限制的自旋将会给 CPU 带来巨大压力，所以判断是否可以自旋就很重要了。 自旋必须满足以下所有条件： 自旋次数要足够小，通常为 4，即自旋最多 4 次 CPU 核数要大于 1，否则自旋没有意义，因为此时不可能有其他协程释放锁 协程调度机制中的 Process 数量要大于 1，比如使用 GOMAXPROCS() 将处理器设置为 1 就不能启用自旋 协程调度机制中的可运行队列必须为空，否则会延迟协程调度 可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。 自旋的优势 自旋的优势是更充分地利用 CPU，尽量避免协程切换。 因为当前申请加锁的协程拥有 CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。 自旋的问题 如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进程将很难获得锁，从而进入饥饿状态。 为了避免协程长时间无法获取锁，自 1.8 版本以来增加了一个状态，即 Mutex 的 Starving 状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:8","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Mutex 模式 前面分析加锁和解锁过程中只关注了 Waiter 和 Locked 位的变化，现在我们看一下 Starving 位的作用。 每个 Mutex 都有两个模式，称为 Normal 和 Starving。下面分别说明这两个模式。 normal 模式 默认情况下，Mutex 的模式为 normal。 该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。 starvation 模式 自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们知道释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到 CPU 后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过了多长时间，如果超过 1ms 的话，会将 Mutex 标记为\"饥饿\"模式，然后再阻塞。 处于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减 1。 Woken 状态 Woken 状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把 Woken 标记为 1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:9","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"为什么重复解锁要 panic 可能你会想，为什么 Go 不能实现得更健壮些，多次执行 Unlock() 也不要 panic？ 仔细想想 Unlock 的逻辑就可以理解，这实际上很难做到。Unlock 过程分为将 Locked 置为 0，然后判断 Waiter 值，如果值 \u003e0，则释放信号量。 如果多次 Unlock()，那么可能每次都释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在 Lock() 的逻辑里抢锁，势必会增加 Lock() 实现的复杂度，也会引起不必要的协程切换。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:10","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"编程 Tips 使用 defer 避免死锁 加锁后立即使用 defer 对其解锁，可以有效的避免死锁。 加锁和解锁应该成对出现 加锁和解锁最好出现在同一个层次的代码块中，比如同一个函数。 重复解锁会引起 panic，应避免这种操作的可能性。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:11","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"rwmutex 所谓读写锁 RWMutex，完整的表述应该是读写互斥锁，可以说是 Mutex 的一个改进版，在某些场景下可以发挥更加灵活的控制能力，比如：读取数据频率远远大于写数据频率的场景。 例如，程序中写操作少而读操作多，简单的说，如果执行过程是 1 次写然后 N 次读的话，使用 Mutex，这个过程将是串行的，因为即便 N 次读操作互相之间并不影响，但也都需要持有 Mutex 后才可以操作。如果使用读写锁，多个读操作可以同时持有锁，并发能力将大大提升。 实现读写锁需要解决如下几个问题： 写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞 写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞 读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞 读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁 下面我们将按照这个思路，即读写锁如何解决这些问题的，来分析读写锁的实现。 读写锁基于 Mutex 实现，实现源码非常简单和简洁，又有一定的技巧在里面。 读写锁数据结构 类型定义 源码包 src/sync/rwmutex.go:RWMutex 定义了读写锁数据结构： type RWMutex struct { w Mutex //用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此 writerSem uint32 //写阻塞等待的信号量，最后一个读者释放锁时会释放信号量 readerSem uint32 //读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量 readerCount int32 //记录读者个数 readerWait int32 //记录写阻塞时读者个数 } 由以上数据结构可见，读写锁内部仍有一个互斥锁，用于将两个写操作隔离开来，其他的几个都用于隔离读操作和写操作。 下面我们简单看下 RWMutex 提供的 4 个接口，后面再跟据使用场景具体分析这几个成员是如何配合工作的。 接口定义 RWMutex 提供 4 个简单的接口来提供服务： RLock()：读锁定 RUnlock()：解除读锁定 Lock()：写锁定，与 Mutex 完全一致 Unlock()：解除写锁定，与 Mutex 完全一致 Lock() 实现逻辑 写锁定操作需要做两件事： 获取互斥锁 阻塞等待所有读操作结束（如果有的话） 所以 func (rw *RWMutex) Lock() 接口实现流程如下图所示： Unlock() 实现逻辑 解除写锁定要做两件事： 唤醒因读锁定而被阻塞的协程（如果有的话） 解除互斥锁 所以 func (rw *RWMutex) Unlock() 接口实现流程如下图所示： RLock() 实现逻辑 读锁定需要做两件事： 增加读操作计数，即 readerCount++ 阻塞等待写操作结束（如果有的话） 所以 func (rw *RWMutex) RLock() 接口实现流程如下图所示： RUnlock() 实现逻辑 解除读锁定需要做两件事： 减少读操作计数，即 readerCount-- 唤醒等待写操作的协程（如果有的话） 所以func (rw *RWMutex) RUnlock()接口实现流程如下图所示： 注意：即便有协程阻塞等待写操作，并不是所有的解除读锁定操作都会唤醒该协程，而是最后一个解除读锁定的协程才会释放信号量将该协程唤醒，因为只有当所有读操作的协程释放锁后才可以唤醒协程。 场景分析 上面我们简单看了下 4 个接口实现原理，接下来我们看一下是如何解决前面提到的几个问题的。 写操作是如何阻止写操作的 读写锁包含一个互斥锁 (Mutex)，写锁定必须要先获取该互斥锁，如果互斥锁已被协程 A 获取（或者协程 A 在阻塞等待读结束），意味着协程 A 获取了互斥锁，那么协程 B 只能阻塞等待该互斥锁。 所以，写操作依赖互斥锁阻止其他的写操作。 写操作是如何阻止读操作的 这个是读写锁实现中最精华的技巧。 我们知道 RWMutex.readerCount 是个整型值，用于表示读者数量，不考虑写操作的情况下，每次读锁定将该值 +1，每次解除读锁定将该值 -1，所以 readerCount 取值为 [0, N]，N 为读者个数，实际上最大可支持 2^30^ 个并发读者。 当写锁定进行时，会先将 readerCount 减去 2^30^，从而 readerCount 变成了负值，此时再有读锁定到来时检测到readerCount 为负值，便知道有写操作在进行，只好阻塞等待。而真实的读操作个数并不会丢失，只需要将readerCount 加上 2^30^ 即可获得。 所以，写操作将 readerCount 变成负值来阻止读操作的。 读操作是如何阻止写操作的 读锁定会先将 RWMutext.readerCount 加 1，此时写操作到来时发现读者数量不为 0，会阻塞等待所有读操作结束。 所以，读操作通过 readerCount 来将来阻止写操作的。 为什么写锁定不会被饿死 我们知道，写操作要等待读操作结束后才可以获得锁，写操作等待期间可能还有新的读操作持续到来，如果写操作等待所有读操作结束，很可能被饿死。然而，通过 RWMutex.readerWait 可完美解决这个问题。 写操作到来时，会把 RWMutex.readerCount 值拷贝到 RWMutex.readerWait 中，用于标记排在写操作前面的读者个数。 前面的读操作结束后，除了会递减 RWMutex.readerCount，还会递减 RWMutex.readerWait 值，当 RWMutex.readerWait 值变为 0 时唤醒写操作。 所以以，写操作就相当于把一段连续的读操作划分成两部分，前面的读操作结束后唤醒写操作，写操作结束后唤醒后面的读操作。如下图所示： 关于源码 源码地址注解：https://github.com/RainbowMango/GoComments ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:3:12","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Goroutine 本章主要介绍协程及其调度机制。 协程是 GO 语言最大的特色之一，本章我们从协程的概念、GO 协程的实现、GO 协程调度机制等角度来分析。 Goroutine 调度是一个很复杂的机制，尽管 Go 源码中提供了大量的注释，但对其原理没有一个好的理解的情况下去读源码收获不会很大。下面尝试用简单的语言描述一下 Goroutine 调度机制，在此基础上再去研读源码效果可能更好一些。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:4:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"线程池的缺陷 我们知道，在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池。线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中的线程不断的从任务队列中取出任务并执行，可以有效的减少线程创建和销毁所带来的开销。 下图展示一个典型的线程池： 为了方便下面的叙述，我们把任务队列中的每一个任务称作 G，而 G 往往代表一个函数。 线程池中的 worker 线程不断的从任务队列中取出任务并执行。而 worker 线程的调度则交给操作系统进行调度。 如果 worker 线程执行的 G 任务中发生系统调用，则操作系统会将该线程置为阻塞状态，也意味着该线程在怠工，也意味着消费任务队列的 worker 线程变少了，也就是说线程池消费任务队列的能力变弱了。 如果任务队列中的大部分任务都会进行系统调用，则会让这种状态恶化，大部分 worker 线程进入阻塞状态，从而任务队列中的任务产生堆积。 解决这个问题的一个思路就是重新审视线程池中线程的数量，增加线程池中线程数量可以一定程度上提高消费能力，但随着线程数量增多，由于过多线程争抢 CPU，消费能力会有上限，甚至出现消费能力下降。 如下图所示： ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:4:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Goroutine 调度器 线程数过多，意味着操作系统会不断的切换线程，频繁的上下文切换就成了性能瓶颈。 Go 提供一种机制，可以在线程中自己实现调度，上下文切换更轻量，从而达到了线程数少，而并发数并不少的效果。而线程中调度的就是 Goroutine. 早期 Go 版本，比如 1.9.2 版本的源码注释中有关于调度器的解释。 Goroutine 调度器的工作就是把 “ready-to-run” 的 goroutine 分发到线程中。 Goroutine 主要概念如下： G (Goroutine)： 即 Go 协程，每个 go 关键字都会创建一个协程。 本质上也是一种轻量级的线程。 M (Machine)： 工作线程，在 Go 中称为 Machine。 一个 M 直接关联了一个内核线程. P (Processor) 代表了 M 所需的上下文环境，也是处理用户级代码逻辑的处理器 它包含运行 Go 代码的必要资源，也有调度 goroutine 的能力。 M 必须拥有 P 才可以执行 G 中的代码，P 含有一个包含多个 G 的队列，P 可以调度 G 交由 M 执行。 换句话来说：一个 M 会对应一个内核线程，一个 M 也会连接一个上下文 P，一个上下文 P 相当于一个“处理器”，一个上下文连接一个或者多个 Goroutine。 其关系如下图所示： 称为 MPG 模型 图中 M 是交给操作系统调度的线程，M 持有一个 P，P 将 G 调度进 M 中执行。P 同时还维护着一个包含 G 的队列（图中灰色部分），可以按照一定的策略将 G 调度到 M 中执行。 P 的个数在程序启动时决定，默认情况下等同于 CPU 的核数，由于 M 必须持有一个 P 才可以运行 Go 代码，所以同时运行的 M 个数，也即线程数一般等同于 CPU 的个数，以达到尽可能的使用 CPU 而又不至于产生过多的线程切换开销。 程序中可以使用 runtime.GOMAXPROCS() 设置 P 的个数，在某些 IO 密集型的场景下可以在一定程度上提高性能。这个后面再详细介绍。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:4:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Goroutine 调度策略 队列轮转 上图中可见每个 P 维护着一个包含 G 的队列，不考虑 G 进入系统调用或 IO 操作的情况下，P 周期性的将 G 调度到 M 中执行，执行一小段时间，将上下文保存下来，然后将 G 放到队列尾部，然后从队列中重新取出一个 G 进行调度。 除了每个 P 维护的 G 队列以外，还有一个全局的队列，每个 P 会周期性的查看全局队列中是否有 G 待运行并将其调度到 M 中执行，全局队列中 G 的来源，主要有从系统调用中恢复的 G。之所以 P 会周期性的查看全局队列，也是为了防止全局队列中的 G 被饿死。 系统调用 上面说到 P 的个数默认等于 CPU 核数，每个 M 必须持有一个 P 才可以执行 G，一般情况下 M 的个数会略大于 P 的个数，这多出来的 M 将会在 G 产生系统调用时发挥作用。 类似线程池，Go 也提供一个 M 的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。 当 M 运行的某个 G 产生系统调用时，如下图所示： 如图所示，M0 中的 G0 执行了 syscall，然后就创建了一个 M1(也有可能本身就存在，没创建)，当 G0 即将进入系统调用时，M0 将释放 P，进而某个空闲的 M1 获取 P，继续执行 P 队列中剩下的 G。而 M0 由于陷入系统调用而进被阻塞，M1接管 M0 的工作，只要 P 不空闲，就可以保证充分利用 CPU。 M1 的来源有可能是 M 的缓存池，也可能是新建的。当 G0 系统调用结束后，跟据 M0 是否能获取到 P，将会将 G0 做不同的处理： 如果有空闲的 P，则获取一个 P，继续执行 G0。 如果没有空闲的 P，则将 G0 放入全局队列，等待被其他的 P 调度。然后 M0 将进入缓存池睡眠。 工作量窃取 多个 P 中维护的 G 队列有可能是不均衡的，比如下图： 竖线左侧中右边的 P 已经将 G 全部执行完，然后去查询全局队列，全局队列中也没有 G，而另一个 M 中除了正在运行的 G 外，队列中还有 3 个 G 待运行。此时，空闲的 P 会将其他 P 中的 G 偷取一部分过来，一般每次偷取一半。偷取完如右图所示。 GOMAXPROCS 设置对性能的影响 一般来讲，程序运行时就将 GOMAXPROCS 大小设置为 CPU 核数，可让 Go 程序充分利用 CPU。 在某些 IO 密集型的应用里，这个值可能并不意味着性能最好。 理论上当某个 Goroutine 进入系统调用时，会有一个新的 M 被启用或创建，继续占满 CPU。 但由于 Go 调度器检测到 M 被阻塞是有一定延迟的，也即旧的 M 被阻塞和新的M得到运行之间是有一定间隔的，所以在 IO 密集型应用中不妨把 GOMAXPROCS 设置的大一些，或许会有好的效果。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:4:3","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"内存管理 本章主要介绍 GO 语言的自动垃圾回收机制。 自动垃圾回收是 GO 语言最大的特色之一，也是很有争议的话题。因为自动垃圾回收解放了程序员，使其不用担心内存泄露的问题，争议在于垃圾回收的性能，在某些应用场景下垃圾回收会暂时停止程序运行。 本章从内存分配原理讲起，然后再看垃圾回收原理，最后再聊一些与垃圾回收性能优化相关的话题。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:5:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"内存分配原理 编写过 C 语言程序的肯定知道通过 malloc() 方法动态申请内存，其中内存分配器使用的是 glibc 提供的ptmalloc2。 除了 glibc，业界比较出名的内存分配器有 Google 的 tcmalloc 和 Facebook 的 jemalloc。二者在避免内存碎片和性能上均比 glic 有比较大的优势，在多线程环境中效果更明显。 Golang 中也实现了内存分配器，原理与 tcmalloc 类似，简单的说就是维护一块大的全局内存，每个线程 (Golang中为 P) 维护一块小的私有内存，私有内存不足再从全局申请。 另外，内存分配与 GC（垃圾回收）关系密切，所以了解 GC 前有必要了解内存分配的原理。 TCMalloc 引入虚拟内存后，让内存的并发访问问题的粒度从多进程级别，降低到多线程级别。 然而同一进程下的所有线程共享相同的内存空间，它们申请内存时需要加锁，如果不加锁就存在同一块内存被 2 个线程同时访问的问题。 TCMalloc 的做法是什么呢？为每个线程预分配一块缓存，线程申请小内存时，可以从缓存分配内存，这样有2个好处： 为线程预分配缓存需要进行 1 次系统调用，后续线程申请小内存时直接从缓存分配，都是在用户态执行的，没有了系统调用，缩短了内存总体的分配和释放时间，这是快速分配内存的第二个层次。 多个线程同时申请小内存时，从各自的缓存分配，访问的是不同的地址空间，从而无需加锁，把内存并发访问的粒度进一步降低了，这是快速分配内存的第三个层次。 下面就简单介绍下 TCMalloc，细致程度够我们理解 Go 的内存管理即可。 结合上图，介绍 TCMalloc 的几个重要概念： Page 操作系统对内存管理以页为单位，TCMalloc 也是这样，只不过 TCMalloc 里的 Page 大小与操作系统里的大小并不一定相等，而是倍数关系。《TCMalloc 解密》里称 x64 下 Page 大小是 8KB。 Span 一组连续的 Page 被称为 Span，比如可以有 2 个页大小的 Span，也可以有 16 页大小的 Span，Span 比 Page 高一个层级，是为了方便管理一定大小的内存区域，Span 是 TCMalloc 中内存管理的基本单位。 ThreadCache ThreadCache 是每个线程各自的 Cache，一个 Cache 包含多个空闲内存块链表，每个链表连接的都是内存块，同一个链表上内存块的大小是相同的，也可以说按内存块大小，给内存块分了个类，这样可以根据申请的内存大小，快速从合适的链表选择空闲内存块。 由于每个线程有自己的 ThreadCache，所以 ThreadCache 访问是无锁的。 CentralCache CentralCache 是所有线程共享的缓存，也是保存的空闲内存块链表，链表的数量与 ThreadCache 中链表数量相同。 当 ThreadCache 的内存块不足时，可以从 CentralCache 获取内存块； 当 ThreadCache 内存块过多时，可以放回 CentralCache。 由于 CentralCache 是共享的，所以它的访问是要加锁的。 PageHeap PageHeap 是对堆内存的抽象，PageHeap 存的也是若干链表，链表保存的是 Span。 当 CentralCache 的内存不足时，会从 PageHeap 获取空闲的内存 Span，然后把 1 个 Span 拆成若干内存块，添加到对应大小的链表中并分配内存； 当 CentralCache 的内存过多时，会把空闲的内存块放回 PageHeap 中。 如下图所示，分别是 1 页 Page 的 Span 链表，2 页 Page 的 Span 链表等，最后是 large span set，这个是用来保存中大对象的。 毫无疑问，PageHeap 也是要加锁的。 前文提到了小、中、大对象，Go 内存管理中也有类似的概念，我们看一眼 TCMalloc 的定义： 小对象大小：0~256KB 中对象大小：257~1MB 大对象大小：\u003e1MB 小对象的分配流程：ThreadCache -\u003e CentralCache -\u003e HeapPage，大部分时候，ThreadCache 缓存都是足够的，不需要去访问 CentralCache 和 HeapPage，无系统调用配合无锁分配，分配效率是非常高的。 中对象分配流程：直接在 PageHeap 中选择适当的大小即可，128 Page 的 Span 所保存的最大内存是 1MB。 大对象分配流程：从 large span set 选择合适数量的页面组成 span，用来存储数据。 通过本节的介绍，你应当对 TCMalloc 主要思想有一定了解了，我建议再回顾一下上面的内容。 基本概念 Page 与 TCMalloc 中的 Page 相同，x64 架构下 1 个 Page 的大小是 8KB。上图的最下方，1 个浅蓝色的长方形代表 1 个 Page。 Span Span 与 TCMalloc 中的 Span 相同，Span 是内存管理的基本单位，代码中为 mspan，一组连续的 Page 组成 1 个 Span，所以上图最下方，一组连续的浅蓝色长方形代表的是一组 Page 组成的 1 个 Span，另外，1 个淡紫色长方形为 1 个 Span。 mcache mcache 与 TCMalloc 中的 ThreadCache 类似，mcache 保存的是各种大小的 Span，并按 Span class 分类，小对象直接从 mcache 分配内存，它起到了缓存的作用，并且可以无锁访问。 但是 mcache 与 ThreadCache 也有不同点，TCMalloc 中是每个线程 1 个 ThreadCache，Go 中是每个 P 拥有 1 个 mcache（其实是一样的）。因为在 Go 程序中，当前最多有 GOMAXPROCS 个线程在运行，所以最多需要 GOMAXPROCS 个mcache 就可以保证各线程对 mcache 的无锁访问，线程的运行又是与 P 绑定的，把 mcache 交给 P 刚刚好。 mcentral mcentral 与 TCMalloc 中的 CentralCache 类似，是所有线程共享的缓存，需要加锁访问。 它按 Span 级别对 Span 分类，然后串联成链表，当 mcache 的某个级别 Span 的内存被分配光时，它会向mcentral 申请 1 个当前级别的 Span。 但是 mcentral 与 CentralCache 也有不同点，CentralCache 是每个级别的 Span 有 1个 链表，mcache是每个级别的 Span 有 2 个链表，这和 mcache 申请内存有关，稍后再解释。 mheap mheap 与 TCMalloc 中的 PageHeap 类似，它是堆内存的抽象，把从 OS 申请出的内存页组织成 Span，并保存起来。 当 mcentral 的 Span 不够用时会向 mheap 申请内存，而 mheap 的 Span 不够用时会向 OS 申请内存。mheap 向 OS 的内存申请是按页来的，然后把申请来的内存页生成 Span 组织起来，同样也是需要加锁访问的。 但是 mheap 与 PageHeap也有不同点：mheap 把 Span 组织成了树结构，而不是链表，并且还是 2 棵树，然后把 Span 分配到 heapArena 进行管理，它包含地址映射和 span 是否包含指针等位图，这样做的主要原因是为了更高效的利用内存：分配、回收和再利用。 object size：代码里简称 size，指申请内存的对象大小。 size class：代码里简称 class，它是 size 的级别，相当于把 size 归类到一定大小的区间段，比如 size[1,8] 属于 size class 1，size(8,16] 属于 size class 2。 span class：指 span 的级别，但 span class 的大小与 span 的大小并没有正比关系。span class 主要用来和 size class 做对应，1 个 size class 对应 2 个 span class，2 个 span class 的 span 大小相同，只是功能不同，1 个用来存放包含指针的对象，一个用来存放不包含指针的对象，不包含指针对象的 Span 就无需 GC 扫描了。 num of page：代码里简称 npage，代表 Page 的数量，其实就是 Span 包含的页数，用来分配内存。 内存分配 Go 中的内存分类并不像 TCMalloc 那样分成小、中、大对象，但是它的小对象里又细分了一个 Tiny 对象，Tiny 对象指大小在 1Byte 到 16Byte 之间并且不包含指针的对象。 小对象和大对象只用大小划定，无其他区分。 小对象是在 mcache 中分配的，而大对象是直接从 mheap 分配的，从小对象的内存分配看起。 概览 针对待分配对象的大小不同有不同的分配逻辑： (0, 16B) 且不包含指针的对象： Tiny 分配 (0, 16B) 包含指针的对象：正常分配 [16B, 32KB] : 正常分配 (32KB, -) : 大对象分配 以申请 size 为 n 的内存为例，分配步骤如下： 获取当前线程的私有缓存 mcache 跟据 size 计算出适合的 class 的 ID 从 mcache 的 alloc[class","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:5:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"垃圾回收原理 所谓垃圾就是不再需要的内存块，这些垃圾如果不清理就没办法再次被分配使用，在不支持垃圾回收的编程语言里，这些垃圾内存就是泄露的内存。 Golang 的垃圾回收（GC）也是内存管理的一部分，了解垃圾回收最好先了解前面介绍的内存分配原理。 垃圾回收算法 业界常见的垃圾回收算法有以下几种： 引用计数：对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0是回收该对象。 优点：对象可以很快的被回收，不会出现内存耗尽或达到某个阀值时才回收。 缺点：不能很好的处理循环引用，而且实时维护引用计数，有也一定的代价。 代表语言：Python、PHP、Swift 标记-清除：从根变量开始遍历所有引用的对象，引用的对象标记为\"被引用\"，没有被标记的进行回收。 优点：解决了引用计数的缺点。 缺点：需要STW，即要暂时停掉程序运行。 代表语言：Golang(其采用三色标记法) 分代收集：按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代有不能的回收算法和回收频率。 优点：回收性能好 缺点：算法复杂 代表语言： JAVA Golang 垃圾回收 垃圾回收原理 简单的说，垃圾回收的核心就是以供后续内存分配时使用。 下图展示了一段内存，内存中即有已分配掉的内存，也有未分配的内存，垃圾回收的目标就是把那些已经分配的但没有对象引用的内存找出来并回收掉： 上图中，内存块 1、2、4 号位上的内存块已被分配（数字 1 代表已被分配，0 未分配）。 变量 a, b 为一指针，指向内存的 1、2 号位。内存块的 4 号位曾经被使用过，但现在没有任何对象引用了，就需要被回收掉。 垃圾回收开始时从 root 对象开始扫描，把 root 对象引用的内存标记为\"被引用\"，考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，全部标记完成后，只保留被标记的内存，未被标记的全部标识为未分配即完成了回收。 内存标记 (Mark) 前面介绍内存分配时，介绍过 span 数据结构，span 中维护了一个个内存块，并由一个位图 allocBits 表示每个内存块的分配情况。在 span 数据结构中还有另一个位图 gcmarkBits 用于标记内存块被引用情况。 如上图所示，allocBits 记录了每块内存分配情况，而 gcmarkBits 记录了每块内存标记情况。标记阶段对每块内存进行标记，有对象引用的的内存标记为 1 (如图中灰色所示)，没有引用到的保持默认为 0。 allocBits 和 gcmarkBits 数据结构是完全一样的，标记结束就是内存回收，回收时将 allocBits 指向 gcmarkBits，则代表标记过的才是存活的，gcmarkBits 则会在下次标记时重新分配内存，非常的巧妙。 三色标记法 前面介绍了对象标记状态的存储方式，还需要有一个标记队列来存放待标记的对象，可以简单想象成把对象从标记队列中取出，将对象的引用状态标记在 span 的 gcmarkBits，把对象引用到的其他对象再放入队列中。 三色只是为了叙述上方便抽象出来的一种说法，实际上对象并没有颜色之分。这里的三色，对应了垃圾回收过程中对象的三种状态： 灰色：对象还在标记队列中等待 黑色：对象已被标记，gcmarkBits 对应的位为 1（该对象不会在本次 GC 中被清理） 白色：对象未被标记，gcmarkBits 对应的位为 0（该对象将会在本次 GC 中被清理） 例如，当前内存中有 A~F 一共 6 个对象，根对象 a，b 本身为栈上分配的局部变量，根对象a、b分别引用了对象A、B, 而 B 对象又引用了对象 D，则 GC 开始前各对象的状态如下图所示: 初始状态下所有对象都是白色的。 接着开始扫描根对象 a、b: 由于根对象引用了对象 A、B，那么 A、B 变为灰色对象，接下来就开始分析灰色对象，分析 A 时，A 没有引用其他对象很快就转入黑色，B 引用了 D，则 B 转入黑色的同时还需要将 D 转为灰色，进行接下来的分析。如下图所示： 上图中灰色对象只有 D，由于 D 没有引用其他对象，所以 D 转入黑色。标记过程结束： 最终，黑色的对象会被保留下来，白色对象会被回收掉。 Stop The World 印度电影《苏丹》中有句描述摔跤的一句台词是：“所谓摔跤，就是把对手控制住，然后摔倒他。” 对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。 Golang 中的 STW（Stop The World）就是停掉所有的 goroutine，专心做垃圾回收，待垃圾回收结束后再恢复 goroutine。 STW 时间的长短直接影响了应用的执行，时间过长对于一些 web 应用来说是不可接受的，这也是广受诟病的原因之一。 为了缩短 STW 的时间，Golang 不断优化垃圾回收算法，这种情况得到了很大的改善。 垃圾回收优化 写屏障 (Write Barrier) 前面说过 STW 目的是防止 GC 扫描时内存变化而停掉 goroutine，而写屏障就是让 goroutine 与 GC 同时运行的手段。虽然写屏障不能完全消除 STW，但是可以大大减少 STW 的时间。 写屏障类似一种开关，在 GC 的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次 GC 时再确定。 GC 过程中新分配的内存会被立即标记，用的并不是写屏障技术，也即 GC 过程中分配的内存不会在本轮 GC 中回收。 辅助 GC (Mutator Assist) 为了防止内存分配过快，在 GC 执行过程中，如果 goroutine 需要分配内存，那么这个 goroutine 会参与一部分 GC 的工作，即帮助 GC 做一部分工作，这个机制叫作 Mutator Assist。 垃圾回收触发时机 内存分配量达到阀值触发 GC 每次内存分配时都会检查当前内存分配量是否已达到阀值，如果达到阀值则立即启动 GC。 阀值 = 上次GC内存分配量 * 内存增长率 内存增长率由环境变量 GOGC 控制，默认为 100，即每当内存扩大一倍时启动 GC。 定期触发 GC 默认情况下，最长 2 分钟触发一次 GC，这个间隔在 src/runtime/proc.go:forcegcperiod 变量中被声明： // forcegcperiod is the maximum time in nanoseconds between garbage // collections. If we go this long without a garbage collection, one // is forced to run. // // This is a variable for testing purposes. It normally doesn't change. var forcegcperiod int64 = 2 * 60 * 1e9 手动触发 程序代码中也可以使用 runtime.GC() 来手动触发 GC。这主要用于 GC 性能测试和统计。 GC 性能优化 GC 性能与对象数量负相关，对象越多 GC 性能越差，对程序影响越大。 所以 GC 性能优化的思路之一就是减少对象分配个数，比如对象复用或使用大对象组合多个小对象等等。 另外，由于内存逃逸现象，有些隐式的内存分配也会产生，也有可能成为 GC 的负担。 关于 GC 性能优化的具体方法，后面单独介绍。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:5:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"逃逸分析 所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。 函数中申请一个新的对象 如果分配在栈中，则函数执行结束可自动将内存回收； 如果分配在堆中，则函数执行结束可交给 GC（垃圾回收）处理; 有了逃逸分析，返回函数局部变量将变得可能，除此之外，逃逸分析还跟闭包息息相关，了解哪些场景下对象会逃逸至关重要。 逃逸策略 每当函数中申请新的对象，编译器会跟据该对象是否被函数外部引用来决定是否逃逸： 如果函数外部没有引用，则优先放到栈中； 如果函数外部存在引用，则必定放到堆中； 注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。 逃逸场景 指针逃逸 我们知道 Go 可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下： package main type Student struct { Name string Age int } func StudentRegister(name string, age int) *Student { s := new(Student) //局部变量s逃逸到堆 s.Name = name s.Age = age return s } func main() { StudentRegister(\"Jim\", 18) } 函数 StudentRegister() 内部 s 为局部变量，其值通过函数返回值返回，s 本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。 通过编译参数 -gcflag=-m 可以查询编译过程中的逃逸分析： D:\\SourceCode\\GoExpert\\src\u003ego build -gcflags=-m # _/D_/SourceCode/GoExpert/src .\\main.go:8: can inline StudentRegister .\\main.go:17: can inline main .\\main.go:18: inlining call to StudentRegister .\\main.go:8: leaking param: name .\\main.go:9: new(Student) escapes to heap .\\main.go:18: main new(Student) does not escape 可见在 StudentRegister() 函数中，也即代码第9行显示 “escapes to heap”，代表该行内存分配发生了逃逸现象。 栈空间不足逃逸 看下面的代码，是否会产生逃逸呢？ package main func Slice() { s := make([]int, 1000, 1000) for index, _ := range s { s[index] = index } } func main() { Slice() } 上面代码 Slice() 函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。 直接查看编译提示，如下： D:\\SourceCode\\GoExpert\\src\u003ego build -gcflags=-m # _/D_/SourceCode/GoExpert/src .\\main.go:4: Slice make([]int, 1000, 1000) does not escape 我们发现此处并没有发生逃逸。那么把切片长度扩大 10 倍即 10000 会如何呢? D:\\SourceCode\\GoExpert\\src\u003ego build -gcflags=-m # _/D_/SourceCode/GoExpert/src .\\main.go:4: make([]int, 10000, 10000) escapes to heap 我们发现当切片长度扩大到 10000 时就会逃逸。 实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。 动态类型逃逸 很多函数参数为 interface 类型，比如 fmt.Println(a ...interface{})，编译期间很难确定其参数的具体类型，也容易产生逃逸。 如下代码所示： package main import \"fmt\" func main() { s := \"Escape\" fmt.Println(s) } 上述代码 s 变量只是一个 string 类型变量，调用 fmt.Println() 时会产生逃逸： D:\\SourceCode\\GoExpert\\src\u003ego build -gcflags=-m # _/D_/SourceCode/GoExpert/src .\\main.go:7: s escapes to heap .\\main.go:7: main ... argument does not escape 闭包引用对象逃逸 某著名的开源框架实现了某个返回 Fibonacci 数列的函数： func Fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } 该函数返回一个闭包，闭包引用了函数的局部变量 a 和 b，使用时通过该函数获取该闭包，然后每次执行闭包都会依次输出 Fibonacci 数列。 完整的示例程序如下所示： package main import \"fmt\" func Fibonacci() func() int { a, b := 0, 1 return func() int { a, b = b, a+b return a } } func main() { f := Fibonacci() for i := 0; i \u003c 10; i++ { fmt.Printf(\"Fibonacci: %d\\n\", f()) } } 上述代码通过 Fibonacci() 获取一个闭包，每次执行闭包就会打印一个 Fibonacci 数值。输出如下所示： D:\\SourceCode\\GoExpert\\src\u003esrc.exe Fibonacci: 1 Fibonacci: 1 Fibonacci: 2 Fibonacci: 3 Fibonacci: 5 Fibonacci: 8 Fibonacci: 13 Fibonacci: 21 Fibonacci: 34 Fibonacci: 55 Fibonacci() 函数中原本属于局部变量的 a 和 b 由于闭包的引用，不得不将二者放到堆上，以致产生逃逸： D:\\SourceCode\\GoExpert\\src\u003ego build -gcflags=-m # _/D_/SourceCode/GoExpert/src .\\main.go:7: can inline Fibonacci.func1 .\\main.go:7: func literal escapes to heap .\\main.go:7: func literal escapes to heap .\\main.go:8: \u0026a escapes to heap .\\main.go:6: moved to heap: a .\\main.go:8: \u0026b escapes to heap .\\main.go:6: moved to heap: b .\\main.go:17: f() escapes to heap .\\main.go:17: main ... argument does not escape 逃逸总结 栈上分配内存比在堆中分配内存有更高的效率 栈上分配的内存不需要 GC 处理 堆上分配的内存使用完毕会交给 GC 处理 逃逸分析目的是决定内分配地址是栈还是堆 逃逸分析在编译阶段完成 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:5:3","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"编程 Tips 思考一下这个问题：函数传递指针真的比传值效率高吗？ 我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:5:4","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"并发控制 本章主要介绍 GO 语言开发过程中经常使用的并发控制手段。 我们考虑这么一种场景，协程 A 执行过程中需要创建子协程 A1、A2、A3…An，协程 A 创建完子协程后就等待子协程退出。 针对这种场景，GO 提供了三种解决方案： Channel：使用 channel 控制子协程 WaitGroup：使用信号量机制控制子协程 Context：使用上下文控制子协程 三种方案各有优劣，比如 Channel 优点是实现简单，清晰易懂，WaitGroup 优点是子协程个数动态可调整，Context 优点是对子协程派生出来的孙子协程的控制。 缺点是相对而言的，要结合实例应用场景进行选择。 channel一般用于协程之间的通信，channel也可以用于并发控制。比如主协程启动N个子协程，主协程等待所有子协程退出后再继续后续流程，这种场景下channel也可轻易实现。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:6:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"channel 下面程序展示一个使用 channel 控制子协程的例子： package main import ( \"time\" \"fmt\" ) func Process(ch chan int) { // Do some work... time.Sleep(time.Second) ch \u003c- 1 // 管道中写入一个元素表示当前协程已结束 } func main() { channels := make([]chan int, 10) //创建一个10个元素的切片，元素类型为channel for i:= 0; i \u003c 10; i++ { channels[i] = make(chan int) //切片中放入一个channel go Process(channels[i]) //启动协程，传一个管道用于通信 } for i, ch := range channels { //遍历切片，等待子协程结束 \u003c-ch fmt.Println(\"Routine \", i, \" quit!\") } } 上面程序通过创建 N 个 channel 来管理 N 个协程，每个协程都有一个 channel 用于跟父协程通信，父协程创建完所有协程中等待所有协程结束。 这个例子中，父协程仅仅是等待子协程结束，其实父协程也可以向管道中写入数据通知子协程结束，这时子协程需要定期的探测管道中是否有消息出现。 总结 使用 channel 来控制子协程的优点是实现简单，缺点是当需要大量创建协程时就需要有相同数量的 channel，而且对于子协程继续派生出来的协程不方便控制。 后面继续介绍的 WaitGroup、Context 看起来比 channel 优雅一些，在各种开源组件中使用频率比 channel 高得多。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:6:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"WaitGroup WaitGroup 是 Golang 应用开发过程中经常使用的并发控制技术。 WaitGroup，可理解为 Wait-Goroutine-Group，即等待一组 goroutine 结束。比如某个 goroutine 需要等待其他几个 goroutine 全部完成，那么使用 WaitGroup 可以轻松实现。 下面程序展示了一个 goroutine 等待另外两个 goroutine 结束的例子： package main import ( \"fmt\" \"time\" \"sync\" ) func main() { var wg sync.WaitGroup wg.Add(2) //设置计数器，数值即为goroutine的个数 go func() { //Do some work time.Sleep(1*time.Second) fmt.Println(\"Goroutine 1 finished!\") wg.Done() //goroutine执行结束后将计数器减1 }() go func() { //Do some work time.Sleep(2*time.Second) fmt.Println(\"Goroutine 2 finished!\") wg.Done() //goroutine执行结束后将计数器减1 }() wg.Wait() //主goroutine阻塞等待计数器变为0 fmt.Printf(\"All Goroutine finished!\") } 简单的说，上面程序中 wg 内部维护了一个计数器： 启动 goroutine 前将计数器通过 Add(2) 将计数器设置为待启动的 goroutine 个数。 启动 goroutine 后，使用 Wait() 方法阻塞自己，等待计数器变为 0。 每个 goroutine 执行结束通过 Done() 方法将计数器减 1。 计数器变为 0 后，阻塞的 goroutine 被唤醒。 其实 WaitGroup 也可以实现一组 goroutine 等待另一组 goroutine，这有点像玩杂技，很容易出错，如果不了解其实现原理更是如此。实际上，WaitGroup 的实现源码非常简单。 基础知识 信号量 信号量是 Unix 系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。 可简单理解为信号量为一个数值： 当信号量 \u003e 0 时，表示资源可用，获取信号量时系统自动将信号量减 1； 当信号量 == 0 时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒； 由于 WaitGroup 实现中也使用了信号量，在此做个简单介绍。 WaitGroup 数据结构 源码包中 src/sync/waitgroup.go:WaitGroup 定义了其数据结构： type WaitGroup struct { state1 [3]uint32 } state1 是个长度为 3 的数组，其中包含了 state 和一个信号量，而 state 实际上是两个计数器： counter：当前还未执行结束的 goroutine 计数器 waiter count：等待 goroutine-group 结束的 goroutine 数量，即有多少个等候者 semaphore：信号量 考虑到字节是否对齐，三者出现的位置不同，为简单起见，依照字节已对齐情况下，三者在内存中的位置如下所示： WaitGroup 对外提供三个接口： Add(delta int)：将 delta 值加到 counter 中 Wait()：waiter 递增 1，并阻塞等待信号量 semaphore Done()：counter 递减 1，按照 waiter 数值释放相应次数信号量 下面分别介绍这三个函数的实现细节。 Add(delta int) Add() 做了两件事，一是把 delta 值累加到 counter 中，因为 delta 可以为负值，也就是说 counter 有可能变成 0 或负值，所以第二件事就是当 counter 值变为 0 时，跟据 waiter 数值释放等量的信号量，把等待的 goroutine 全部唤醒，如果 counter 变为负值，则 panic。 Add() 伪代码如下： func (wg *WaitGroup) Add(delta int) { statep, semap := wg.state() // 获取state和semaphore地址指针 state := atomic.AddUint64(statep, uint64(delta)\u003c\u003c32) // 把delta左移32位累加到state，即累加到counter中 v := int32(state \u003e\u003e 32) // 获取counter值 w := uint32(state) // 获取waiter值 if v \u003c 0 { // 经过累加后counter值变为负值，panic panic(\"sync: negative WaitGroup counter\") } // 经过累加后，此时，counter \u003e= 0 // 如果counter为正，说明不需要释放信号量，直接退出 // 如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出 if v \u003e 0 || w == 0 { return } // 此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况）， // 先把counter置为0，再释放waiter个数的信号量 *statep = 0 for ; w != 0; w-- { runtime_Semrelease(semap, false) // 释放信号量，执行一次释放一个，唤醒一个等待者 } } Wait() Wait() 方法也做了两件事，一是累加 waiter，二是阻塞等待信号量 func (wg *WaitGroup) Wait() { statep, semap := wg.state() // 获取state和semaphore地址指针 for { state := atomic.LoadUint64(statep) // 获取state值 v := int32(state \u003e\u003e 32) // 获取counter值 w := uint32(state) // 获取waiter值 if v == 0 { // 如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回 return } // 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试 if atomic.CompareAndSwapUint64(statep, state, state+1) { runtime_Semacquire(semap) // 累加成功后，等待信号量唤醒自己 return } } } 这里用到了 CAS 算法保证有多个 goroutine 同时执行 Wait() 时也能正确累加 waiter。 Done() Done() 只做一件事，即把 counter 减 1，我们知道 Add() 可以接受负值，所以 Done() 实际上只是调用了Add(-1)。 源码如下： func (wg *WaitGroup) Done() { wg.Add(-1) } Done() 的执行逻辑就转到了 Add()，实际上也正是最后一个完成的 goroutine 把等待者唤醒的。 编程 Tips Add() 操作必须早于 Wait()，否则会 panic Add() 设置的值必须与实际等待的 goroutine 个数一致，否则会 panic ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:6:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Context Context 也叫作“上下文”，是一个比较抽象的概念，一般理解为程序单元的一个运行状态、现场、快照。其中上下是指存在上下层的传递，上会把内容传递给下，程序单元则指的是 Goroutine。 Golang context 是 Golang 应用开发常用的并发控制技术，它与 WaitGroup 最大的不同点是 context 对于派生 goroutine 有更强的控制力，它可以控制多级的 goroutine。 每个 Goroutine 在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个 Context 变量中，传递给要执行的 Goroutine 中。 context 实际上只定义了接口，凡是实现该接口的类都可称为是一种 context，官方包中实现了几个常用的 context，分别可用于不同的场景。 典型的使用场景如下图所示： 上图中由于 goroutine派生出子 goroutine，而子 goroutine 又继续派生新的 goroutine，这种情况下使用 WaitGroup 就不太容易，因为子 goroutine 个数不容易确定。而使用 context 就可以很容易实现。 接口定义 源码包中 src/context/context.go:Context 定义了该接口： type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } 基础的 context 接口只定义了 4 个方法，下面分别简要说明一下： Deadline() 该方法返回一个 deadline 和标识是否已设置 deadline 的 bool 值，如果没有设置 deadline，则 ok == false，此时 deadline 为一个初始值的 time.Time 值 Done() 该方法返回一个 channel，需要在 select-case 语句中使用，如 case \u003c-context.Done() 当 context 关闭后，Done() 返回一个被关闭的管道，关闭的管理仍然是可读的，据此 goroutine 可以收到关闭请求； 当 context 还未关闭时，Done() 返回 nil。 Err() 该方法描述 context 关闭的原因。关闭原因由 context 实现控制，不需要用户设置。比如 Deadline context，关闭原因可能是因为 deadline，也可能提前被主动关闭，那么关闭原因就会不同: 因 deadline 关闭：“context deadline exceeded”； 因主动关闭： “context canceled”。 当 context 关闭后，Err() 返回 context 的关闭原因； 当 context 还未关闭时，Err() 返回 nil； Value() 有一种 context，它不是用于控制呈树状分布的 goroutine，而是用于在树状分布的 goroutine 间传递信息。 Value() 方法就是用于此种类型的 context，该方法根据 key 值查询 map 中的 value。具体使用后面示例说明。 空 context context 包中定义了一个空的 context， 名为 emptyCtx，用于 context 的根节点，空的 context 只是简单的实现了 Context，本身不包含任何值，仅用于其他 context 的父节点。 它是一个不可取消，没有设置截止时间，没有携带任何值的 Context。 emptyCtx 类型定义如下代码所示： type emptyCtx int func (*emptyCtx) Deadline() (deadline time.Time, ok bool) { return } func (*emptyCtx) Done() \u003c-chan struct{} { return nil } func (*emptyCtx) Err() error { return nil } func (*emptyCtx) Value(key interface{}) interface{} { return nil } context 包中定义了一个公用的 emptCtx 全局变量，名为 background，可以使用 context.Background() 获取它，实现代码如下所示： var background = new(emptyCtx) func Background() Context { return background } context 包提供了 4 个方法创建不同类型的 context，使用这四个方法时如果没有父 context，都需要传入 backgroud，即 backgroud 作为其父节点： WithCancel() WithDeadline() WithTimeout() WithValue() context 包中实现 Context 接口的 struct，除了 emptyCtx 外，还有 cancelCtx、timerCtx 和 valueCtx 三种，正是基于这三种 context 实例，实现了上述 4 种类型的 context。 context 包中各 context 类型之间的关系，如下图所示： struct cancelCtx、timerCtx、valueCtx 都继承于 Context，下面分别介绍这三个 struct。 cancelCtx 源码包中 src/context/context.go:cancelCtx 定义了该类型 context： type cancelCtx struct { Context mu sync.Mutex // protects following fields done chan struct{} // created lazily, closed by first cancel call children map[canceler]struct{} // set to nil by the first cancel call err error // set to non-nil by the first cancel call } children 中记录了由此 context 派生的所有 child，此 context 被 cancle 时会把其中的所有 child 都 cancle 掉。 cancelCtx 与 deadline 和 value 无关，所以只需要实现 Done() 和 Err() 接口外露接口即可。 Done() 接口实现 按照 Context 定义，Done() 接口只需要返回一个 channel 即可，对于 cancelCtx 来说只需要返回成员变量 done 即可。 这里直接看下源码，非常简单： func (c *cancelCtx) Done() \u003c-chan struct{} { c.mu.Lock() if c.done == nil { c.done = make(chan struct{}) } d := c.done c.mu.Unlock() return d } 由于 cancelCtx 没有指定初始化函数，所以 cancelCtx.done 可能还未分配，所以需要考虑初始化。 cancelCtx.done 会在 context 被 cancel 时关闭，所以 cancelCtx.done 的值一般经历如三个阶段： nil –\u003e chan struct{} –\u003e closed chan。 Err() 接口实现 按照 Context 定义，Err() 只需要返回一个 error 告知 context 被关闭的原因。对于 cancelCtx 来说只需要返回成员变量 err 即可。 还是直接看下源码： func (c *cancelCtx) Err() error { c.mu.Lock() err := c.err c.mu.Unlock() return err } cancelCtx.err 默认是 nil，在 context 被 cancel 时指定一个 error 变量： var Canceled = errors.New(\"context canceled\")。 cancel() 接口实现 cancel() 内部方法是理解 cancelCtx 的最关键的方法，其作用是关闭自己和其后代，其后代存储在cancelCtx.children 的 map 中，其中 key 值即后代对象，value 值并没有意义，这里使用 map 只是为了方便查询而已。 cancel 方法实现伪代码如下所示： func (c *cancelCtx) cancel(removeFromParent bool, err error) { c.mu.Lock() c.err = err // 设置一个error，说明关闭原因 close(c.done) // 将channel关闭，以此通知派生的context for child := range c.children { // 遍历所有children，逐个调用cancel方法 child.cancel(false, err) } c.children = nil c.mu.Unlock() ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:6:3","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"反射概念 官方对此有个非常简明的介绍，两句话耐人寻味： 反射提供一种让程序检查自身结构的能力 反射是困惑的源泉 第 1 条，再精确点的描述是 “反射是一种检查 interface 变量的底层类型和值的机制”。 第 2 条，很有喜感的自嘲，不过往后看就笑不出来了，因为你很可能产生困惑. 想深入了解反射，必须深入理解类型和接口概念。下面开始复习一下这些基础概念。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:7:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"关于静态类型 你肯定知道 Go 是静态类型语言，比如 “int”、“float32”、\"[]byte\" 等等。每个变量都有一个静态类型，且在编译时就确定了。 那么考虑一下如下一种类型声明: type Myint int var i int var j Myint Q: i 和 j 类型相同吗？ A：i 和 j 类型是不同的。 二者拥有不同的静态类型，没有类型转换的话是不可以互相赋值的，尽管二者底层类型是一样的。 特殊的静态类型 interface interface 类型是一种特殊的类型，它代表方法集合。 它可以存放任何实现了其方法的值。 经常被拿来举例的是 io 包里的这两个接口类型： // Reader is the interface that wraps the basic Read method. type Reader interface { Read(p []byte) (n int, err error) } // Writer is the interface that wraps the basic Write method. type Writer interface { Write(p []byte) (n int, err error) } 任何类型，比如某 struct，只要实现了其中的 Read() 方法就被认为是实现了 Reader 接口，只要实现了 Write() 方法，就被认为是实现了 Writer 接口，不过方法参数和返回值要跟接口声明的一致。 接口类型的变量可以存储任何实现该接口的值。 特殊的 interface 类型 最特殊的 interface 类型为空 interface 类型，即 interface {} interface 类型的方法集合为空，也就是说所有类型都可以认为是实现了该接口。 一个类型实现空 interface 并不重要，重要的是一个空 interface 类型变量可以存放所有值，记住是所有值，这才是最最重要的。 这也是有些人认为 Go 是动态类型的原因，这是个错觉。 interface 类型是如何表示的 前面讲了，interface 类型的变量可以存放任何实现了该接口的值。还是以上面的 io.Reader 为例进行说明，io.Reader 是一个接口类型，os.OpenFile() 方法返回一个 File 结构体类型变量，该结构体类型实现了io.Reader 的方法，那么 io.Reader 类型变量就可以用来接收该返回值。如下所示： var r io.Reader tty, err := os.OpenFile(\"/dev/tty\", os.O_RDWR, 0) if err != nil { return nil, err } r = tty 那么问题来了。 Q： r 的类型是什么？ A: r 的类型始终是 io.Reader interface 类型，无论其存储什么值。 Q：那 File 类型体现在哪里？ A：r 保存了一个 (value, type) 对来表示其所存储值的信息。 value 即为 r 所持有元素的值，type 即为所持有元素的底层类型 Q：如何将 r 转换成另一个类型结构体变量？比如转换成 io.Writer A：使用类型断言，如 w = r.(io.Writer). 意思是如果 r 所持有的元素如果同样实现了 io.Writer 接口，那么就把值传递给 w。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:7:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"反射三定律 前面之所以讲类型，是为了引出 interface，之所以讲 interface 是想说 interface 类型有个 (value，type) 对，而反射就是检查 interface 的这个 (value, type) 对的。 具体一点说就是 Go 提供一组方法提取 interface 的 value，提供另一组方法提取 interface 的 type. 官方提供了三条定律来说明反射，比较清晰，下面也按照这三定律来总结。 反射包里有两个接口类型要先了解一下. reflect.Type 提供一组接口处理 interface 的类型，即（value, type）中的 type reflect.Value 提供一组接口处理 interface 的值，即 (value, type) 中的 value 下面会提到反射对象，所谓反射对象即反射包里提供的两种类型的对象。 reflect.Type 类型对象 reflect.Value 类型对象 反射第一定律：反射可以将 interface 类型变量转换成反射对象 下面示例，看看是如何通过反射获取一个变量的值和类型的： package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 t := reflect.TypeOf(x) //t is reflext.Type fmt.Println(\"type:\", t) v := reflect.ValueOf(x) //v is reflext.Value fmt.Println(\"value:\", v) } 程序输出如下： type: float64 value: 3.4 注意：反射是针对 interface 类型变量的，其中 TypeOf() 和 ValueOf() 接受的参数都是 interface{} 类型的，也即 x 值是被转成了 interface 传入的。 除了 reflect.TypeOf() 和 reflect.ValueOf()，还有其他很多方法可以操作，本文先不过多介绍，否则一不小心会会引起困惑。 反射第二定律：反射可以将反射对象还原成 interface 对象 之所以叫’反射’，反射对象与 interface 对象是可以互相转化的。看以下例子： package main import ( \"fmt\" \"reflect\" ) func main() { var x float64 = 3.4 v := reflect.ValueOf(x) //v is reflext.Value var y float64 = v.Interface().(float64) fmt.Println(\"value:\", y) } 对象 x 转换成反射对象 v，v 又通过 Interface() 接口转换成 interface 对象，interface 对象通过 .(float64) 类型断言获取 float64 类型的值。 反射第三定律：反射对象可修改，value 值必须是可设置的 通过反射可以将 interface 类型变量转换成反射对象，可以使用该反射对象设置其持有的值。在介绍何谓反射对象可修改前，先看一下失败的例子： package main import ( \"reflect\" ) func main() { var x float64 = 3.4 v := reflect.ValueOf(x) v.SetFloat(7.1) // Error: will panic. } 如下代码，通过反射对象 v 设置新值，会出现 panic。报错如下： panic: reflect: reflect.Value.SetFloat using unaddressable value 错误原因即是 v 是不可修改的。 反射对象是否可修改取决于其所存储的值，回想一下函数传参时是传值还是传址就不难理解上例中为何失败了。 上例中，传入 reflect.ValueOf() 函数的其实是 x 的值，而非 x 本身。即通过 v 修改其值是无法影响 x 的，也即是无效的修改，所以 golang 会报错。 想到此处，即可明白，如果构建 v 时使用 x 的地址就可实现修改了，但此时 v 代表的是指针地址，我们要设置的是指针所指向的内容，也即我们想要修改的是 *v。 那怎么通过 v 修改 x 的值呢？ reflect.Value 提供了 Elem() 方法，可以获得指针向指向的 value。看如下代码： package main import ( \"reflect\" \"fmt\" ) func main() { var x float64 = 3.4 v := reflect.ValueOf(\u0026x) v.Elem().SetFloat(7.1) fmt.Println(\"x :\", v.Elem().Interface()) } 输出为： x : 7.1 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:7:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"总结 结合官方博客及本文，至少可以对反射理解个大概，还有很多方法没有涉及。 对反射的深入理解，个人觉得还需要继续看的内容： 参考业界，尤其是开源框架中是如何使用反射的 研究反射实现原理，探究其性能优化的手段 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:7:3","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"语法糖 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:8:0","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"简短变量声明 := 题目 一 问：下面代码输出什么？ func fun1() { i := 0 i, j := 1, 2 fmt.Printf(\"i = %d, j = %d\\n\", i, j) } 程序输出如下： i = 1, j = 2 再进一步想一下，前一个语句中已经声明了 i, 为什么还可以再次声明呢？ 二 问：下面代码为什么不能通过编译？ func fun2(i int) { i := 0 fmt.Println(i) } 不能通过编译原因是形参已经声明了变量 i，使用 := 再次声明是不允许的。 再进一步想一下，编译时会报 “no new variable on left side of :=” 错误，该怎么理解？ 三 问：下面代码输出什么？ func fun3() { i, j := 0, 0 if true { j, k := 1, 1 fmt.Printf(\"j = %d, k = %d\\n\", j, k) } fmt.Printf(\"i = %d, j = %d\\n\", i, j) } 程序输出如下： j = 1, k = 1 i = 0, j = 0 这里要注意的是，block if 中声明的 j，与上面的 j 属于不同的作用域。 规则 多变量赋值可能会重新声明 我们知道使用 := 一次可以声明多个变量，像下面这样： field1, offset := nextField(str, 0) 上面代码定义了两个变量，并用函数返回值进行赋值。 如果这两个变量中的一个再次出现在 := 左侧就会重新声明。像下面这样，offset 被重新声明： field1, offset := nextField(str, 0) field2, offset := nextField(str, offset) 重新声明并没有什么问题，它并没有引入新的变量，只是把变量的值改变了，但要明白，这是 Go 提供的一个语法糖。 当 := 左侧存在新变量时（如 field2），那么已声明的变量（如 offset）则会被重新声明，不会有其他额外副作用。 当 := 左侧没有新变量是不允许的，编译会提示 no new variable on left side of :=。 我们所说的重新声明不会引入问题要满足一个前提，变量声明要在同一个作用域中出现。 如果出现在不同的作用域，那很可能就创建了新的同名变量，同一函数不同作用域的同名变量往往不是预期做法，很容易引入缺陷。关于作用域的这个问题，我们在本节后面介绍。 不能用于函数外部 简短变量场景只能用于函数中，使用 := 来声明和初始化全局变量是行不通的。 比如，像下面这样： package sugar import fmt rule := \"Short variable declarations\" // syntax error: non-declaration statement outside function body 这里的编译错误提示 syntax error: non-declaration statement outside function body，表示非声明语句不能出现在函数外部。可以理解成 := 实际上会拆分成两个语句，即声明和赋值。赋值语句不能出现在函数外部的。 变量作用域 几乎所有的工程师都了解变量作用域，但是由于 := 使用过于频繁的话，还是有可能掉进陷阱里。 func Redeclare() { field, err:= nextField() // 1号err if field == 1{ field, err:= nextField() //　2号err newField, err := nextField() // 3号err ... } ... } 注意上面声明的三个 err 变量。 2 号 err 与 1 号 err 不属于同一个作用域，:= 声明了新的变量，所以 2 号 err 与 1 号 err 属于两个变量。 2 号 err 与 3 号 err 属于同一个作用域，:= 重新声明了 err 但没创建新的变量，所以 2 号err 与 3 号 err 是同一个变量。 如果误把 2 号 err 与 1 号 err 混淆，就很容易产生意想不到的错误。 ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:8:1","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"可变参函数 可变参函数是指函数的某个参数可有可无，即这个参数个数可以是 0 个或多个。 声明可变参数函数的方式是在参数类型前加上 ... 前缀。 比如 fmt 包中的 Println: func Println(a ...interface{}) 函数特征 我们先写一个可变参函数： func Greeting(prefix string, who ...string) { if who == nil { fmt.Printf(\"Nobody to say hi.\") return } for _, people := range who{ fmt.Printf(\"%s %s\\n\", prefix, people) } } Greeting 函数负责给指定的人打招呼，其参数 who 为可变参数。 这个函数几乎把可变参函数的特征全部表现出来了： 可变参数必须在函数参数列表的尾部，即最后一个（如放前面会引起编译时歧义）； 可变参数在函数内部是作为切片来解析的； 可变参数可以不填，不填时函数内部当成 nil 切片处理； 可变参数必须是相同类型的（如果需要是不同类型的可以定义为 interface{} 类型）； 使用举例 我们使用 testing 包中的 Example 函数来说明上面 Greeting 函数（函数位于 sugar 包中）用法。 不传值 调用可变参函数时，可变参部分是可以不传值的，例如： func ExampleGreetingWithoutParameter() { sugar.Greeting(\"nobody\") // OutPut: // Nobody to say hi. } 这里没有传递第二个参数。可变参数不传递的话，默认为 nil。 传递多个参数 调用可变参函数时，可变参数部分可以传递多个值，例如： func ExampleGreetingWithParameter() { sugar.Greeting(\"hello:\", \"Joe\", \"Anna\", \"Eileen\") // OutPut: // hello: Joe // hello: Anna // hello: Eileen } 可变参数可以有多个。多个参数将会生成一个切片传入，函数内部按照切片来处理。 传递切片 调用可变参函数时，可变参数部分可以直接传递一个切片。参数部分需要使用 slice... 来表示切片。例如： func ExampleGreetingWithSlice() { guest := []string{\"Joe\", \"Anna\", \"Eileen\"} sugar.Greeting(\"hello:\", guest...) // OutPut: // hello: Joe // hello: Anna // hello: Eileen } 此时需要注意的一点是，切片传入时不会生成新的切片，也就是说函数内部使用的切片与传入的切片共享相同的存储空间。 说得再直白一点就是，如果函数内部修改了切片，可能会影响外部调用的函数。 总结 可变参数必须要位于函数列表尾部； 可变参数是被当作切片来处理的； 函数调用时，可变参数可以不填； 函数调用时，可变参数可以填入切片； ","date":"2022-02-23","objectID":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/:8:2","tags":["进阶"],"title":"Go 专家编程","uri":"/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"},{"categories":["刷题"],"content":"剑指 Offer 53 - I. 在排序数组中查找数字 I easy 统计一个数字在排序数组中出现的次数。 示例 1: 输入: nums = [5,7,7,8,8,10], target = 8 输出: 2 示例 2: 输入: nums = [5,7,7,8,8,10], target = 6 输出: 0 ","date":"2022-02-22","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/:0:0","tags":["算法","数组","二分"],"title":"剑指 Offer 53 - I. 在排序数组中查找数字 I","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/"},{"categories":["刷题"],"content":"二分 跟 34 题差不多 func search(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := (high + low) \u003e\u003e 1 if nums[mid] \u003e target { high = mid - 1 } else if nums[mid] \u003c target { low = mid + 1 } else { count := 1 i := mid for i-1 \u003e= 0 \u0026\u0026 nums[i] == nums[i-1] { count++ i-- } i = mid for i+1 \u003c= len(nums)-1 \u0026\u0026 nums[i] == nums[i+1] { count++ i++ } return count } } return 0 } ","date":"2022-02-22","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/:1:0","tags":["算法","数组","二分"],"title":"剑指 Offer 53 - I. 在排序数组中查找数字 I","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-i.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/"},{"categories":["专业课"],"content":"数据库原理一 30分 客观 填空选择判断 3 个大题 第三四章至少 40 分，表多，关系复杂 1.1 数据库发展几个阶段 1.1.3 文件系统缺陷（3 个） 2.2 数据模型 几个模型的特点/缺点 （p21 网状模型 p49 层次模型） 2.3 三级结构、两级映像 2.4 2.4.2 DBMS 主要功能 3.1 关系定义、性质 外键含义 3.1.4 完整性 3.1.5 关系模式三要素 3.2 3.2.1 关系操作、关系演算 五个基本操作 3.3 关系演算不需要会写 3.3.3 安全性、等价性 3.4 3.4.3 一般策略 4.1 4.1.2 SQL 体系结构 4.1.3 SQL 组成 4.2 数据定义 少用的语句也要会写 4.3 查询 重点 集合操作不怎么考 4.5 不考 6.1 ER图会画 会转化成关系模式 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:0:0","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"第四章 结构化查询语言 （第四章） ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:0","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"SQL 概述 SQL：结构化查询语言，一种介于关系代数和关系演算之间的语言。 关键码： 超键：能唯一标识元组的属性组合（可能多余） 候选键：能唯一标识元组的最小属性组合 主键：候选键中的一个 外键：若关系 R 包含关系 S 的主键对应的属性组 F，则 F 为 R 的外键。S 为参照关系，R 为依赖关系 SQL 体系结构（三级体系结构对应关系）： 内模式：对应存储文件 模式：对应基本表（元组称为行、属性称为列） 外模式：对应视图 SQL 体系结构的特征 SQL模式是表和约束的集合 表是行的集合 表可以是基本表，也可以是视图。视图只存放定义不存放数据 表可以存放在多个存储文件中，存储文件可以存放多个表 用户使用SQL语句对视图和表进行操作。表和视图对用户而言都是关系 用户可以是程序也可以是终端 SQL的组成： 数据定义：定义 SQL模式、基本表、视图和索引 数据操纵：数据查询、数据更新（插入删除修改） 数据控制 -\u003e 第八章：对基本表和视图的授权、完整性规则描述、事务控制语句 嵌入式 SQL：嵌入 SQL 的规则 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:1","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"SQL 数据定义 SQL 模式的创建和撤销 创建 CREATESCHEMA\u003c模式名\u003eAUTHORIZATION\u003c拥有者\u003e; 撤销 DROPSCHEMA\u003c模式名\u003e[CASECADE|RESTRICT]; CASECADE（级联）连锁式 RESTRICT 约束式：只有当模式中没有任何下属元素时允许撤销 基本数据类型： 数值型：INTEGER、DOUBLE PRECISION 双精度、DECEMIAL(p,d) p.d 位定点小数 字符串型：CHAR(n) 定长、VACHAR(n) 最大长度n 位串型：BIT(n) 定长、BIT VARYING(n) 最大长度n 时间型：DATE(YYYY-MM-DD)、TIME(HH:MM:SS) **基本表创建 **☆ 列级约束 + 表级约束 三个子句：主键子句、外键子句、检查子句 CREATETABLES(SNOCHAR(4)NOTNULL,PRIMARYKEY(SNO,PNO),-- 主键子句 FOREIGNKEY(JNO)REFERENCESJ(JNO)-- 外键子句 CHECK(QTYBETWEEN0AND10000)-- 检查子句 ); 基本表修改：（增删属性） 增加属性：ALTER TABLE S ADD NAME VACHAR(12); 删除属性：ALTER TABLE S DROP NAME [CASCADE(连锁)|RESTRICT(约束)]; 基本表删除：DROP TABLE S [CASCADE(连锁)|RESTRICT(约束)]; 视图创建： CREATEVIEWJSP_NAME(JNO,JNAME)ASSELECT(J.JNO,J.JNAME)FROMS,JWHERE… 视图撤销：DROP VIEW JSP_NAME 索引创建： CREATEUNIQUEINDEXSPJ_INDEXONSPJ(SNOASC,PNO,ASC,JONDESC); 索引撤销： DROPINDEXJNO_INDEX,SPJ_INDEX; ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:2","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"SQL 数据查询 ☆ SQL 查询语句 select 投影、from 笛卡尔积、where 选择（条件） SELECT[DISTINCT]列名序列FROM表名[WHERE行条件表达式]-- 行条件子句 [GROUPBY列名序列[HAVING组条件表达式]]-- 分组子句 [ORDERBY列名[ASC|DESC]序列]-- 排序子句 多表查询与联接操作 INNER JOIN：内联接 -\u003e 匹配行 LEFT JOIN：左外联接 -\u003e 匹配行+左表；保证左边所有行都存在 RIGHT JOIN：右外联接 -\u003e 匹配行+右表 FULL JOIN：完全外联接 -\u003e 匹配行+左表+右表；左右不匹配的行也保留 CROSS JOIN：交叉联接 -\u003e 笛卡尔积 以下五者等价：查询选修 2 号课程的学生姓名 联接查询 from 表1 联接类型 表2 on 联接条件 SELECTSNAMEFROMSCINNERJOINSONS.SNO=SC.SNO-- 注意 ON WHERECNO=’2’; 多表查询 SELECTSNAMEFROMS,SCWHERES.SNO=SC.SNOANDCNO=’2’; 嵌套操作 不相关子查询：子查询条件不依赖父查询，效率最高 SELECTSNAMEFROMSWHERESNOIN(SELECTSNOFROMSCWHERECNO=’2’); 相关子查询：子查询条件依赖父查询 SELECTSNAMEFROMSWHERE‘2’IN(SELECTCNOFROMSCWHERESNO=S.SNO); EXISTS：也是相关子查询 SELECTSNAMEFROMSWHEREEXISTS(SELECT*FROMSCWHERESNO=S.SNOANDCNO=’2’); ANY、ALL 谓词 ANY、ALL 用于单属性表前以聚合，MAX、MIN 用于 SELECT 后以聚合。 查询非信息系中比信息系至少某一个学生年龄小的学生姓名年龄： SELECTSname,SageFROMSWHERESdept!=’IS’ANDSage\u003cANY(SELECTSageFROMSWHERESdept=’IS’);SELECTSname,SageFROMSWHERESdept!=’IS’ANDSage\u003c(SELECTMAX(Sage)FROMSWHERESdept=’IS’); EXISTS 存在谓词 存在表任意关系：$\\forall x \\left( p \\right) \\equiv \\neg \\exists x \\left( \\neg p \\right)$ 查询选修全部课程的学生姓名：（也就是不存在一门课它没选） SELECTSnameFROMSWHERENOTEXISTS(SELECTCnoFROMCWHERENOTEXISTS(SELECTSnoFROMSCWHERECno=C.CnoANDSno=S.Sno));SELECTSnameFROMSWHERENOTEXISTS(/*查询S没选的课*/SELECTCnoFROMCINNERJOINSCONC.Cno=SC.CnoWHERENOTEXISTSSno=S.sno); 存在表蕴含关系： $ \\forall y \\left( p \\rightarrow q \\right) \\equiv \\neg \\exists y \\left( \\neg \\left( \\neg p \\vee q \\right) \\right) \\equiv \\neg \\exists y \\left( p \\wedge \\neg q \\right) $ 查询选过学生 A（学号95002）选过的全部课程的学生B学号：（不存在 A 选的课它没选） SELECTDISTINCTSnoFROMSCASXWHERENOTEXISTS(/*不存在这样一个课程号*/SELECTCnoFROMSCASYWHEREY.Sno=’95002’/*95002选了*/ANDNOTEXISTS(/*B没选*/SELECT*FROMSCASZWHEREZ.Cno=Y.CnoANDZ.Sno=X.Sno)); 聚合函数 逻辑：先用 where 筛选，再 having，最后运行聚合函数 COUNT(*) 元组个数 COUNT(列名) 列中非空值个数 COUNT(DISTINCT 列名) 列中元素种数 SUM(列)、AVG(列) MAX(列)、MIN(列) DISTINCT 查询每门课的选课人数： Group By 属性必须在 SELECT 后出现； 在 SELECT 中指定的字段要么就要包含在 Group By 语句中，作为分组的依据；要么就要被包含在聚合函数中 SELECTCno,COUNT(Sno)FROMSCGROUPBYCno; 数据分组、集合操作 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:3","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"SQL 数据更新 ☆ 数据插入 插入单个元组： INSERTINTOtable_nameVALUES(‘…’,’…’) 插入子查询结果： INSERTINTOtable_nameSELECT…FROM…WHERE… 数据删除 DELETEFROMtable_nameWHERE… 数据修改 UPDATEtable_nameSET列名=值表达式[,列名=值表达式…]WHERE… 例：把课程名为”数据库原理”的成绩提高10%. UPDATESCSETGRADE=1.1*GRADEWHERECNOIN(SELECTCNOFROMCWHERECNAME='数据库原理'); ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:4","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"视图操作 视图：虚表，只存定义，不存数据。 在 SQL 中，外模式一级数据结构的基本单位是视图（View） 视图是从若干基本表和（或）其他视图构造出来的表。 在创建一个视图时，系统把视图的定义存放在数据字典中，而不存储视图对应的数据，在用户使用视图时才去求对应的数据。 视图被称为“虚表” 创建 CREATEVIEW\u003c视图名\u003e(列名表)AS\u003cSELECT查询语句\u003e 在基本表 SC 上，建立一个学生学习情况视图，内容包括：学号、选修课程门数、平均成绩。 CREATEVIEWS_GRADE(SNO,C_NUM,AVG_GRADE)AS(SELECTSNO,COUNT(CNO),AVG(GRADE)FROMSCGROUPBYSNO); 撤销 DROPVIEW\u003c视图名\u003e 查询 系统会根据数据字典的定义将视图查询转换为对基本表的查询 HAVING：组条件 WHERE：行条件 CREATEVIEWS_GRADE(sno,c_num,avg_grade)AS(SELECTsno,COUNT(cno),AVG(grade)FROMSCGROUPBYsno);SELECTsno,avg_gradeFROMS_GRADEWHEREc_num\u003e(SELECTc_numFROMS_GRADEWHEREsno=’S4’); 会转变成： SELECTsno,AVG(grade)ASavg_gradeFROMSCGROUPBYsnoHAVINGCOUNT(cno)\u003e(SELECTCOUNT(cno)FROMSCWHEREsno=’S4’GROUPBYsno); 更新 只有行列子集视图可以进行更新 行列子集视图：当视图是从单个基本表仅使用选择和投影导出，并包含了基本表的主键或某个候选键，则可以进行更新操作。 拒绝更新的视图： 视图从多个基本表联结导出 视图有分组或聚合操作 /* 以下更新会被拒绝： ** 因为视图包含分组聚合操作COUNT(cno), AVG(grade) **/UPDATES_GRADESETsno=’S3’WHEREsno=’S4’ ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:5","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"嵌入式 SQL 为区分 SQL 语句与宿主语言语句，在所有的 SQL 语句前必须加上前缀标识 EXEC SQL，并以 END EXEC 作为语句结束标志 通过共享变量进行数据交互 通过游标统一 SQL 中一次一集合的和程序中一次一记录工作方式 只有查询结果是多条记录、或需要对当前记录进行操作时才需要使用游标 使用嵌入式的目标：统一 SQL 中一次一集合的和程序中一次一记录工作方式 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:1:6","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"第一章 数据库发展史 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:2:0","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"数据管理技术发展三个阶段 人工管理阶段：磁带、卡片、纸带 数据不保存在计算机内 没有专用软件管理数据（逻辑结构 = 物理结构，数据和程序不具有独立性） 只有程序的概念，没有文件的概念 数据面向程序 文件系统阶段： 数据以文件形式保存 操作系统接管读写细节 优点： 数据以文件形式存在磁盘上 逻辑结构和物理结构有简单区别，程序和数据间有设备独立性（程序只和文件打交道） 文件组织多样化（索引、链接、直接存取文件） 数据面向应用（且可复用） 对数据操作以记录为单位 文件系统三个缺点： 数据冗余：同样数据在多个文件中重复 不一致性：更新操作导致重复数据不统一 数据联系弱：文件相互独立，缺乏联系 倒排文件系统阶段： 推广索引文件，为每个字段提供单独索引 优点：允许用户按字段的任何组合检索记录 缺点：占用很多存储空间，数据更新复杂 数据库系统阶段： 数据库系统的**三个阶段：**层次、网状、关系 -\u003e 1.2 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:2:1","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"数据库技术的产生和发展 数据库技术的三个阶段 （三件大事）（又见 -\u003e 2.2） IMS 系统： 层次模型 树形结构 表示一对多关系 表达多对多关系需要冗余节点 通过指针导航 查询速度快，但需要程序员掌握数据结构 DBTG 报告： 网状模型 图形结构 表示多对多关系 通过指针导航 查询速度快，但需要程序员掌握数据结构 E.F.Codd 文章： 关系模型 -\u003e 第三章 数据库阶段的特点 三级结构两级映像 面向全组织的复杂的数据结构，实现了数据的结构化（采用数据模型表示复杂的数据结构：存储数据和数据间的关系） 有较高的数据独立性：用户只操作逻辑结构，物理结构对用户透明 提供方便的用户接口：终端/程序方式 提供数据控制功能：并发控制、恢复、完整性、安全性 增加系统灵活性：可以以数据项而非记录为单位 数据库术语 数据库 DB：长期存储在计算机内，有组织的、统一管理的相关数据的组合。 用户共享、冗余度小、数据联系紧密、独立性强 数据库管理系统 DBMS：介于 OS 和用户之间，为用户提供数据管理的软件。 层次型、网状型、关系型、面向对象型 数据库技术：研究数据库结构、存储、设计、管理、使用的一门学科 数据库系统 DBS：采用数据库技术的计算机系统 数据库技术的发展 分布式数据库技术 面向对象数据库技术 集中式 DB、C/S 架构、B/S 架构 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:2:2","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"第二章 数据库系统结构 （第二章） ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:3:0","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"数据描述 信息的三个领域 现实世界（需求分析） 信息世界（用概念设计描述数据库的概念结构） 机器世界（在计算机中展示出来） 概念设计中的数据描述：代表 E-R 模型 实体：客观存在，一个具体或抽象的对象 实体集：性质相同实体的集合 属性：实体的一个特性 实体标识符：唯一标识实体的属性或属性集 逻辑设计中的数据描述：代表关系模型等 字段（数据项）：标记实体属性的命名单位 -\u003e 属性 记录：字段的有序集合 -\u003e 实体 文件：同一类记录的集合 -\u003e 实体集 关键码：唯一确定文件中每个记录的字段或字段集 -\u003e 实体标识符 数据联系的描述： 联系：实体间的相互关系。 联系的元数：一元、二元、多元 二元联系：两个不同实体集实体之间的联系 一对一联系（1:1）、一对多联系（1:n）、多对多联系（m:n） ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:3:1","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"数据模型 定义：表示实体类型和实体间联系的模型 分类 概念模型（实体联系模型） 逻辑模型（结构数据模型） 概念数据模型——实体联系模型（ER 模型） 独立于计算机系统的模型，用于建立信息世界的数据模型，语义表达能力丰富 矩形表示实体类型 菱形表示实体间联系 椭圆形表示实体或联系的属性 优点： 简单、容易理解，真实反映用户需求 与计算机无关，用户容易接受 缺点：只能说明实体间的语义联系，不能说明数据结构 逻辑数据模型——面向数据库逻辑结构的模型 包含 数据结构：对实体类型和实体间联系的表达和实现 数据操作：对数据库的检索和更新（包括插入、删除、 修改）两类操作的实现 完整性约束：数据及其联系应具有的制约和依赖 规则 层次模型 用树型结构表示实体类型及实体之间联系的模型 使用有根树型结构、记录间联系通过指针、只能表示 1:n 联系 优点 记录之间通过指针实现，查询效率高 逻辑和数据转换由 DBMS 完成 缺点 只能表示 1:n 联系，M:N 联系表示复杂 层次顺序的严格和复杂引起查询更新很复杂，程序编写困难 网状模型 用有向图结构表示实体类型及实体间联系的模型 使用有向图结构、记录间联系通过指针、能表示 m:n 联系 优点 容易实现M：N联系，查询效率高。 缺点 程序员必须熟悉数据库的逻辑结构才能编写相应的应用程序 关系模型 用二维表格结构来表示实体集，用外键表示实体间联系的模型 关系模型是由若干个关系模式组成的集合，关系模式相当于记录类型，它的每一个实例称为关系。每个关系实际上就是一张二维表格。 关系模型和层次、网络模型的最大差别是用关键码而不是用指针导航数据，表格简单，用户易懂，编写程序是并不涉及存储结构、访问技术等问题。 特征 -\u003e 3.1：每列不可分、没有两行完全相同、没有行序、没有列序 关系模式三要素：数据结构、数据操纵、完整性约束 完整性约束 -\u003e 3.1：实体完整性、参照完整性、用户自定义完整性 面向对象模型 完整地描述现实世界的数据结构，具有丰富的表达力，但需要的知识较多 解决现实中更复杂的联系（嵌套、递归） ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:3:2","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"数据库的体系结构 （三级结构两级映像） 三级模式结构 外模式 （可以有很多）用户与数据库系统的接口，外模式可以有很多 （概念）模式 （只有一个）数据库中全部数据的整体逻辑结构描述，模式只有一个 内模式 数据库在物理存储方面的描述，最贴近物理结构 记录的存储方式 索引的组织方式 文件的组织方式 两级映像 两级映像：确保数据独立性 外模式/模式映像：体现逻辑数据独立性（数据的逻辑独立性） 模式/内模式映像：体现物理数据独立性（数据的物理独立性） 两级数据的独立性 物理数据独立性：修改内模式不影响模式 逻辑数据独立性：修改模式不影响外模式 DML：数据操纵语言（用户使用） DDL：外模式、模式、内模式中数据定义语言 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:3:3","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"数据库管理系统 DBMS DMBS 是 DBS 的核心，一切对 DB 的操作都通过 DBMS 进行 事物是 DBMS 的基本工作单位，是由用户定义的一个操作序列，这些操作要么全做要么全不做，是不可分割的 工作模式：接受用户请求，转换，对数据库操作，接受结果，转换，返回用户 主要功能：数据库的定义、操纵、保护、维护，管理数据字典（DD） 模块组成： 查询处理器：DML 编译器、DDL 编译器、嵌入式 DML 预编译器、查询运行核心程序 存储处理器：权限和完整性管理器、事务管理器、文件管理器、缓冲区管理器 数据库系统 DBS： **组成：**数据库、硬件、软件、数据库管理员 DBA 分类：集中式 DBS、客户服务器式 DBS、分布式 DBS ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:3:4","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"第三章 关系运算 第三章 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:4:0","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"关系模型 关系(数据)模型 定义：用二维表格表示实体集，用关键码（外键）表示实体间联系的数据模型 形式定义：关系是域的笛卡尔积的子集，元组的集合 属性：表格中的列 域：值的集合，即属性的取值范围 元组：表格中的行，域的笛卡尔积的元素 关系：二维表格，域的笛卡尔积的子集，（集合论）元组的集合，表示一个实体集 关系模型特征： 可以看做二维表格 表中的一行成为一个元组 列为属性 列的取值范围为域 任意两行不相同 关系模式性质： 本质是一个二维表格 属性值是原子的，不可分解 没有重复的元组 没有行序 理论上没有列序（为方便设置列序） 关键码：超键、候选键、主键、外键 -\u003e 4.1 主键使用下划线、外键使用下划波浪线 关系模式的三级体系结构： 关系子模式 -\u003e 外模式：从若干关系中抽出满足一定条件的数据 关系模式 -\u003e 概念模式：定义模式名、属性名、值域名、模式的主键 存储模式 -\u003e 内模式：描述了关系如何在物理设备上存储 完整性规则： 实体完整性：主键非空 参照完整性：外键为空或为对应关系的某个主键值 用户定义完整性：由应用环境决定数据需要符合的约束条件 关系模型的形式定义：（关系模型三个组成） 关系模型由数据结构、数据操作、完整性规则组成 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:4:1","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"关系代数 ☆ 数据操纵语言 DML：查询语句、更新语句 关系查询语言：非过程性语言 关系代数语言：查询操作以集合操作为基础 关系演算语言：查询操作以谓词演算（一阶逻辑）为基础，非过程性更强一些 关系代数的基本运算 要求参与运算的两个集合是同种性质 并 $ \\bigcup $ 、差 — 、笛卡尔积 $ \\times $、投影$ \\pi $ 、选择 $ \\sigma $ 并：$ R\\bigcup S = \\left{ t|t \\in R \\vee t \\in S \\right } $ 列要一样 or 差： $ R-S=\\left { t|t \\in R \\wedge t \\notin S \\right } $ 列要一样 not exists 笛卡尔积：$ R \\times S = \\left { t|t=\\left\\langle t^r, t^s \\right\\rangle \\wedge t^r \\in R \\wedge t^s\\in S \\right } $ from A, B 投影：$ {\\pi_{i_1,\\cdots ,i_m}}\\left( R \\right)=\\left{ t|t=\\left\\langle t_{i_1},\\cdots ,t_{i_m} \\right\\rangle \\wedge \\left\\langle t_1,\\cdots ,t_k \\right\\rangle \\in R \\right} $ ，自动去重 select distinct 选择： $ \\sigma_f\\left( R \\right)=\\left{ t|t\\in R\\wedge f\\left( t \\right)=\\text{true} \\right} $ ，如 $\\sigma _{\\text{age=18}}\\left( S \\right)$ where 关系代数的组合运算 交 $\\bigcap$ 、联接 $\\triangleright \\triangleleft $ 、自然联接 $\\triangleright \\triangleleft $ 、除 $\\div$ 交： $R\\bigcap S=R-\\left( R-S \\right)=S-\\left( S-R \\right)$ and 联接：$R\\underset{i\\ \\theta \\ j}{\\mathop \\triangleright \\triangleleft },S={\\sigma }_{i\\ \\theta \\ \\left( r+j \\right)}\\left( R\\times S \\right)$ 其中 i，j 为下标，i，j 列都保留（笛卡尔积后选择） 自然联接：$R\\triangleright \\triangleleft S=\\pi \\left( \\sigma \\left( R\\times S \\right) \\right)$ 先笛卡尔积，再选择，再投影掉重复的列 inner join 除：$R\\div S=\\pi_{1,2,…,r-s} \\left( R \\right)-\\pi_{1,2,…,r-s} \\left( \\pi_{1,2,…,r-s} \\left( R \\right)\\times S-R \\right)$ R 中满足 S 中所有条件的元组的剩余信息 not exists(not exists) 扩充的关系代数操作： 外联接：（左、右、全）（级联左右带双横线 =）哪边有 = 哪边有表对面有空 外部并：把两表并起来，并填上 null（普通并要求属性一致） 半联接：⋉ 自然联接的投影左表属性 S⋉SC 为选了课的学生 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:4:2","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"例子 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:4:3","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"关系演算 关系代数和关系演算的区别：关系代数以集合操作为基础，关系演算以谓词演算为基础（谓词即离散数学中的一阶逻辑） 元组关系演算 $\\left{ t|P\\left( t \\right) \\right}$ ，$t$ 代表一个元组（一行） 域关系演算 $\\left{ t_1\\cdots t_k|P\\left( t_1\\cdots t_k \\right) \\right}$ ，$t_1\\cdots t_k$ 代表一个元组 关系运算的安全性 关系代数操作结果不应包括无限关系和无穷验证 关系运算的等价性 关系代数 = 安全的元组关系演算 = 安全的域关系演算 例子 元组关系演算 域关系演算 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:4:4","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"查询优化 关键：如何花费较少的时间和空间，有效地执行笛卡尔积操作 等价变换规则：书P58 投影串联： $\\pi _{L_1}\\left( \\pi _{L_2}\\left( E \\right) \\right)=\\pi _{L_1}\\left( E \\right)$ 选择串联：$\\sigma _{F_1}\\left( \\sigma _{F_2}\\left( E \\right) \\right)=\\sigma _{F_1\\wedge F_2}\\left( E \\right)$ 选择投影交换：$\\pi _{L}\\left( \\sigma _{F}\\left( E \\right) \\right)=\\sigma _{F}\\left( \\pi _{L}\\left( E \\right) \\right)$ 前提是后者依然可执行 选择对笛卡尔积分配： $\\sigma _F\\left( E_1\\times E_2 \\right)=\\sigma _{F_1}\\left( E_1\\times \\sigma _{F_2}\\left( E_2 \\right) \\right)$ 选择对并分配： $\\sigma _F\\left( E_1\\bigcup E_2 \\right)=\\sigma _F\\left( E_1 \\right)\\bigcup \\sigma _F\\left( E_2 \\right)$ 选择对差分配： $\\sigma _F\\left( E_1-E_2 \\right)=\\sigma _F\\left( E_1 \\right)-\\sigma _F\\left( E_2 \\right)=\\sigma _F\\left( E_1 \\right)-E_2$ 投影对笛卡尔积分配： $\\pi _L\\left( E_1\\times E_2 \\right)=\\pi _{L_1}\\left( E_1 \\right)\\times \\pi _{L_2}\\left( E_2 \\right)$ 投影对并分配： $\\pi _L\\left( E_1\\bigcup E_2 \\right)=\\pi _L\\left( E_1 \\right)\\bigcup \\pi _L\\left( E_2 \\right)$ 优化的一般策略 尽早执行选择操作 笛卡尔积和其后的选择、投影合并运算 同时计算选择和投影 预处理多次出现的子表达式 如在一个表达式中多次出现某个子表达式，可先对该子表达式进行计算并保存结果，以免重复计算 预处理建立合理的索引方式 优化表达式的计算方法，如选择哪个作为外层循环 优化算法☆ 由 DBMS 中的 DML 编译器完成 将自然联接转为笛卡尔积 + 选择 + 投影 逆用选择串联，将选择拆开 将每个选择和投影尽可能移向树叶 将相邻的投影和选择转化为 (0/1 个) 选择 + (0/1 个) 投影 按二元运算分组，每组只有一个二元运算 例 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:4:5","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"第六章 实体联系模型 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:5:0","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"ER 模型的基本元素 基本元素：实体、联系、属性 实体：一个数据对象 -\u003e 方框 联系：表示实体间的关系 -\u003e 菱形框，用线段和实体相连 属性：表示实体的特性 -\u003e 椭圆形框，实体标识符加下划线，用线段和实体相连 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:5:1","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"属性的分类 基本属性和复合属性：地址包含邮政编码、街道 属性连向属性（双圆圈），产生属性的层次结构 单值属性和多值属性（双线椭圆）：产品的多个价格 添加新的属性：将多值属性展开成多个单值属性 添加弱实体：通过双菱形连双方框，属性为销售性质和价格 导出属性：可由其他信息推导的属性，出生日期推算年龄 用虚线和虚椭圆连接 空值的三种意义： 占位空值：表示无意义（未婚则配偶名无意义） 未知空值：表示未知（已婚但配偶名未知） 员工是否已婚未知 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:5:2","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"联系的设计 联系的元数： 一元联系：员工管理员工，零件使用零件 在同一个实体内部存在的联系 一对一、一对多做外键 多对多单独建表 二元联系：零件构成产品 一对一：双方表选一个建对方的外键 一对多：多的一方加入外键 多对多：单独建表（SC） 三元联系：学生选老师开设的课，单独建表（SPJ） 联系的联通词：1:1, 1:N, M:N, M:N:P 等 联系的基数：写在联系两侧，格式为 $\\left( \\min ,\\max \\right)$ ，靠近一侧做主语 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:5:3","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["专业课"],"content":"ER 模型的扩充 依赖联系：一个实体的存在以另一个实体的存在为前提 弱实体：两个实体依赖联系，且主键全部由父实体中获得 子类、超类：有继承性，且实体标识符相同。超类用两端双线的矩形框表示，联系中间加圈 子类继承超类的所有属性，但可以包含更多属性 通过子类实体和超类实体有相同的实体标识符实现（即子类和超类主键相同） 填空题 TLB： SQL 三个阶段：人工管理、文件系统、数据库系统 数据库技术三个阶段：层次模型、网状模型、关系模型 数据控制四功能：并发控制、恢复、完整性、安全性 三个世界：现实世界、信息世界、机器世界 数据模型分类：概念模型、逻辑模型 数据模型三要素：数据结构、数据操纵、完整性约束 完整性约束：实体完整性、参照完整性、用户自定义完整性 三级模式：外模式、模式、内模式 两级映像：外模式模式映像、模式内模式映像 完整性规则：实体完整性、参照完整性、用户自定义完整性 空值三个意义：占位空值、未知空值、未知 ","date":"2022-02-22","objectID":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/:5:4","tags":["数据库"],"title":"数据库原理（1）","uri":"/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%B8%80/"},{"categories":["刷题"],"content":"剑指 Offer 45. 把数组排成最小的数 mid sort 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 示例 1: 输入: [10,2] 输出: \"102\" 示例 2: 输入: [3,30,34,5,9] 输出: \"3033459\" ","date":"2022-02-21","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/:0:0","tags":["算法","数组","排序"],"title":"剑指 Offer 45. 把数组排成最小的数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"},{"categories":["刷题"],"content":"自定义排序 // 获取两个数字拼接后的结果 func plusNum(a, b int) (res int) { res, _ = strconv.Atoi(strconv.Itoa(a) + strconv.Itoa(b)) return } func compare(a, b int) bool { return plusNum(a, b) \u003c plusNum(b, a) } // 获取两个数字拼接后的结果 func plusNum(a, b int) (res int) { res, _ = strconv.Atoi(strconv.Itoa(a) + strconv.Itoa(b)) return } func minNumber(nums []int) string { var res string // 选择排序 sort.Slice(nums, func(i, j int) bool { return plusNum(nums[i], nums[j]) \u003c plusNum(nums[j], nums[i]) }) for _, item := range nums { res += strconv.Itoa(item) } return res } ","date":"2022-02-21","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/:1:0","tags":["算法","数组","排序"],"title":"剑指 Offer 45. 把数组排成最小的数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"},{"categories":["刷题"],"content":"自己写个快排 func minNumber2(nums []int) string { var quickSort func(nums []int, l, r int) quickSort = func(nums []int, l, r int) { pivotPos := true // 基准值位置 true为前 i, j := l, r for i \u003c j { if !compare(nums[i], nums[j]) { // 逆序 pivotPos = !pivotPos nums[i], nums[j] = nums[j], nums[i] } if pivotPos { j-- } else { i++ } } if l \u003c i-1 { quickSort(nums, l, i-1) } if i+1 \u003c r { quickSort(nums, i+1, r) } } quickSort(nums, 0, len(nums)-1) var res string for _, item := range nums { res += strconv.Itoa(item) } return res } ","date":"2022-02-21","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/:2:0","tags":["算法","数组","排序"],"title":"剑指 Offer 45. 把数组排成最小的数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-45.-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/"},{"categories":["刷题"],"content":"11. 盛最多水的容器 mid 给出一个非负整数数组 a1，a2，a3，…… an，每个整数标识一个竖立在坐标轴 x 位置的一堵高度为 ai 的墙，选择两堵墙，和 x 轴构成的容器可以容纳最多的水。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/:0:0","tags":["算法","数组","双指针"],"title":"11. 盛最多水的容器","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["刷题"],"content":"对撞指针 func maxArea(height []int) int { start, end := 0, len(height) curResult, maxResult := 0, 0 for start \u003c end { curWidth := end - start curHeight := 0 // 因为高度取矮者 矮的一边的指针就可以往中间移动 因为反过来的移法面积必定更小 if height[start] \u003c height[end] { curHeight = height[start] start++ } else { curHeight = height[end] end-- } curResult = curWidth * curHeight if curResult \u003e maxResult { maxResult = curResult } } return maxResult } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/:1:0","tags":["算法","数组","双指针"],"title":"11. 盛最多水的容器","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/11.-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"categories":["刷题"],"content":"15. 三数之和 mid 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 注意：答案中不可以包含重复的三元组。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["算法","数组","双指针"],"title":"15. 三数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"排序 + 对撞指针 l 和 r 双指针从头/尾向中间移动 func threeSum(nums []int) [][]int { if len(nums) \u003c 3 { return [][]int{} } sort.Ints(nums) res := make([][]int, 0) for i := 0; i \u003c len(nums)-2; i++ { a := nums[i] if a \u003e 0 { break } if i \u003e 0 \u0026\u0026 nums[i] == nums[i-1] { // 避免i重复 continue } l, r := i+1, len(nums)-1 for l \u003c r { b, c := nums[l], nums[r] if a+b+c \u003e 0 { r-- } else if a+b+c \u003c 0 { l++ } else { res = append(res, []int{a, b, c}) // 避免l或r重复 for l \u003c r \u0026\u0026 nums[l] == b { l++ } for r \u003e l \u0026\u0026 nums[r] == c { r-- } } } } return res } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["算法","数组","双指针"],"title":"15. 三数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/15.-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"16. 最接近的三数之和 mid 给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，使它们的和与 target 最接近。 返回这三个数的和。 假定每组输入只存在恰好一个解。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/16.-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["算法","数组","双指针"],"title":"16. 最接近的三数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/16.-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"排序 + 对撞指针 func abs(x int) int { if x \u003c 0 { return -x } return x } // 排序+双指针 func threeSumClosest(nums []int, target int) int { sort.Ints(nums) minDiff := math.MaxInt32 resultSum := math.MaxInt32 for index := 1; index \u003c len(nums)-1; index++ { start, end := 0, len(nums)-1 for start \u003c index \u0026\u0026 end \u003e index { curSum := nums[start] + nums[index] + nums[end] curDiff := curSum - target if abs(curDiff) \u003c minDiff { minDiff = abs(curDiff) resultSum = curSum } switch { case curDiff == 0: return resultSum case curDiff \u003c 0: start++ default: end-- } } } return resultSum } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/16.-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["算法","数组","双指针"],"title":"16. 最接近的三数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/16.-%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"18. 四数之和 mid 给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）： 0 \u003c= a, b, c, d \u003c n a、b、c 和 d 互不相同 nums[a] + nums[b] + nums[c] + nums[d] == target 你可以按任意顺序返回答案 。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/18.-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["算法","数组","双指针"],"title":"18. 四数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/18.-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"排序 + 双指针 在三数之和的基础上，再套一层循环 // fourSum 排序+双指针 外加一层循环 func fourSum(nums []int, target int) [][]int { sort.Ints(nums) curNums := make([][]int, 0) for j := 0; j \u003c len(nums); j++ { if j \u003e 0 \u0026\u0026 nums[j] == nums[j-1] { continue } for i := j + 2; i \u003c len(nums); i++ { start, end := j+1, len(nums)-1 // 考虑i跟前一个i相同的情况 if i \u003e j+2 \u0026\u0026 nums[i] == nums[i-1] { start = i - 1 } for start \u003c i \u0026\u0026 end \u003e i { // 去重 if start \u003e j+1 \u0026\u0026 nums[start] == nums[start-1] { start++ continue } if end \u003c len(nums)-1 \u0026\u0026 nums[end] == nums[end+1] { end-- continue } curSum := nums[j] + nums[start] + nums[i] + nums[end] switch { case curSum == target: curNums = append(curNums, []int{nums[j], nums[start], nums[i], nums[end]}) start++ end-- case curSum \u003c target: start++ default: end-- } } } } return curNums } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/18.-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["算法","数组","双指针"],"title":"18. 四数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/18.-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"22. 括号生成 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 示例 2： 输入：n = 1 输出：[\"()\"] ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:0:0","tags":["算法","回溯","DP"],"title":"22. 括号生成","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["刷题"],"content":"DFS 维护一个 leftNum 来表示之前剩余的、没有被匹配到的左括号个数 func generateParenthesis(n int) []string { count := n * 2 res := make([]string, 0) var dfs func(quotes []byte, layer, leftNum int) // leftNum 表示之前剩余多少个没有被匹配到的左括号 dfs = func(quotes []byte, layer, leftNum int) { if layer == count { if leftNum == 0 { res = append(res, string(quotes)) } return } if leftNum \u003e= 1 { dfs(append(quotes, ')'), layer+1, leftNum-1) } dfs(append(quotes, '('), layer+1, leftNum+1) } dfs([]byte{}, 0, 0) return res } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:1:0","tags":["算法","回溯","DP"],"title":"22. 括号生成","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["刷题"],"content":"⭐ 更加标准的 DFS 回溯 回溯法还原变量 func generateParenthesis(n int) []string { count := n * 2 res := make([]string, 0) var dfs func(quotes []byte, layer, leftNum int) // leftNum 表示之前剩余多少个没有被匹配到的左括号 dfs = func(quotes []byte, layer, leftNum int) { if layer == count { if leftNum == 0 { // 这里不用 copy, 因为 string 函数直接深拷贝了 res = append(res, string(quotes)) } return } if leftNum \u003e= 1 { quotes = append(quotes, ')') dfs(quotes, layer+1, leftNum-1) quotes = quotes[:len(quotes)-1] } quotes = append(quotes, '(') dfs(quotes, layer+1, leftNum+1) quotes = quotes[:len(quotes)-1] } dfs([]byte{}, 0, 0) return res } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:2:0","tags":["算法","回溯","DP"],"title":"22. 括号生成","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["刷题"],"content":"DP 题解：https://leetcode-cn.com/problems/generate-parentheses/solution/zui-jian-dan-yi-dong-de-dong-tai-gui-hua-bu-lun-da/ 好屌！ func generateParenthesis(n int) []string { if n == 1 { return []string{\"()\"} } dp := [][]string{{\"\"}, {\"()\"}} for i := 2; i \u003c= n; i++ { dpi := make([]string, 0) // dp[i] for p := 0; p \u003c= i-1; p++ { q := i - 1 - p // 遍历dp[p]和dp[q]中的所有组合 for _, quotes1 := range dp[p] { for _, quotes2 := range dp[q] { dpi = append(dpi, \"(\"+quotes1+\")\"+quotes2) } } } dp = append(dp, dpi) } return dp[n] } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/:3:0","tags":["算法","回溯","DP"],"title":"22. 括号生成","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/22.-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"categories":["刷题"],"content":"26. 删除有序数组中的重复项 easy 给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次 ，返回删除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/:0:0","tags":["算法","数组","双指针"],"title":"26. 删除有序数组中的重复项","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"categories":["刷题"],"content":"原地删除 append 函数看起来蛮耗时的。。。 // removeDuplicates 比较蠢的 一次遍历 func removeDuplicates(nums []int) int { dupLen := 0 oriLen := len(nums) for i := 0; i \u003c len(nums)-1; { if nums[i] == nums[i+1] { nums = append(nums[:i+1], nums[i+2:]...) // 删除 i+1 dupLen++ // 此处不执行 i++ } else { i++ } } return oriLen - dupLen } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/:1:0","tags":["算法","数组","双指针"],"title":"26. 删除有序数组中的重复项","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"categories":["刷题"],"content":"双指针（重复元素后移） 一个指针 i 进行数组遍历，另外一个指针 j 指向有效数组的最后一个位置。 // removeDuplicates 把重复的元素移到最后面 （其实是覆盖掉） func removeDuplicates(nums []int) int { if len(nums) == 0 { return 0 } i, j := 0, 0 for i \u003c len(nums)-1 { for nums[j] == nums[i] { // 右移j至与i不同处 j++ if j == len(nums) { return i + 1 } } nums[i+1] = nums[j] // 覆盖 跟替换一个意思 i++ } return i + 1 } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/:2:0","tags":["算法","数组","双指针"],"title":"26. 删除有序数组中的重复项","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/26.-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/"},{"categories":["刷题"],"content":"4. 寻找两个正序数组的中位数 hard 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数。 算法的时间复杂度应该为 $O(log (m+n))$。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:0:0","tags":["算法","数组"],"title":"4. 寻找两个正序数组的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["刷题"],"content":"Python 的奇技淫巧 有排序，有合并数组，显然没有达到指定的时间复杂度。。。 class Solution: def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -\u003e float: nums=sorted(nums1+nums2) if len(nums)%2==0: return (nums[len(nums)//2]+nums[len(nums)//2-1])/2.0 else: return nums[len(nums)//2] ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:1:0","tags":["算法","数组"],"title":"4. 寻找两个正序数组的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["刷题"],"content":"二分查找 这道题让我们求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用二分查找法来求解。 那么回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。 这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为 m 和 n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。 为了简化代码，不分情况讨论，我们使用一个小 trick，我们分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。加入 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。 这里我们需要定义一个函数来在两个有序数组中找到第 K 个元素，下面重点来看如何实现找到第K个元素。 首先，为了避免产生新的数组从而增加时间复杂度，我们使用两个变量i和j分别来标记数组nums1和nums2的起始位置。然后来处理一些边界问题 比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。 还有就是如果K=1的话，那么我们只要比较 nums1 和 nums2 的起始位置i和j上的数字就可以了。 难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第 K 个元素，为了加快搜索的速度，我们要使用二分法，对K二分，意思是我们需要分别在nums1和nums2中查找第K/2个元素，注意这里由于两个数组的长度不定，所以有可能某个数组没有第K/2个数字，所以我们需要先检查一下，数组中到底存不存在第K/2个数字，如果存在就取出来，否则就赋值上一个整型最大值。 如果某个数组没有第K/2个数字，那么我们就淘汰另一个数字的前K/2个数字即可。 有没有可能两个数组都不存在第K/2个数字呢，这道题里是不可能的，因为我们的K不是任意给的，而是给的m+n 的中间值，所以必定至少会有一个数组是存在第K/2个数字的。 最后就是二分法的核心啦，比较这两个数组的第K/2小的数字midVal1和midVal2的大小，如果第一个数组的第K/2个数字小的话，那么说明我们要找的数字肯定不在nums1中的前K/2个数字，所以我们可以将其淘汰，将nums1的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归。反之，我们淘汰nums2中的前K/2个数字，并将nums2的起始位置向后移动K/2个，并且此时的K也自减去K/2，调用递归即可。 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { length := len(nums1)+len(nums2) if length%2 == 1{ return float64(getKthElement(nums1, nums2, length/2+1)) } k1, k2 := length/2, length/2+1 return float64(getKthElement(nums1,nums2,k1)+getKthElement(nums1,nums2,k2))/2.0 } // 二分查找 找到第k小的元素 func getKthElement(nums1, nums2 []int, k int)int{ m, n := len(nums1), len(nums2) index1, index2 := 0, 0 for { if m == index1{ return nums2[index2+k-1] } if n == index2{ return nums1[index1+k-1] } if k == 1{ return Min(nums1[index1], nums2[index2]) } half := k/2 l1 := Min(index1+half, m)-1 l2 := Min(index2+half, n)-1 pivot1, pivot2 := nums1[l1], nums2[l2] if pivot1 \u003c= pivot2{ k -= l1-index1+1 index1 = l1+1 }else{ k -= l2-index2+1 index2 = l2+1 } } } func Min(a, b int)int{ if a \u003c b{ return a } return b } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:2:0","tags":["算法","数组"],"title":"4. 寻找两个正序数组的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["刷题"],"content":"归并排序 将这两个有序数组合并后找中位数。 func FindMedianSortedArrays(nums1, nums2 []int) float64 { var res []int m, n := len(nums1), len(nums2) l1, l2 := 0, 0 for l1 \u003c m \u0026\u0026 l2 \u003c n{ if nums1[l1] \u003c nums2[l2]{ res = append(res, nums1[l1]) l1++ }else{ res = append(res, nums2[l2]) l2++ } } res = append(res, nums1[l1:]...) res = append(res, nums2[l2:]...) length := m + n if length % 2 == 1{ return float64(res[length/2]) } mid1 := res[length/2] mid2 := res[length/2-1] return float64(mid1 + mid2)/2.0 } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:3:0","tags":["算法","数组"],"title":"4. 寻找两个正序数组的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["刷题"],"content":"双指针 本质上还是归并 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { m, n := len(nums1), len(nums2) length := m + n left, right := 0, 0 l1, l2 := 0, 0 // 如果length为奇数，那问题转换为求第k小的数(k=length/2+1) // 所以循环k-1次，迭代right即可得到第k小的数 // 如果length为偶数，那么问题转换为求第k-1小的数和第k小的数两个数的平均值 for i := 0; i \u003c= length/2; i++ { left = right if l1 \u003c m \u0026\u0026 (l2 \u003e= n || nums1[l1] \u003c nums2[l2]) { right = nums1[l1] l1++ } else { right = nums2[l2] l2++ } } if length%2 == 1 { return float64(right) } return float64(left+right) / 2.0 } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/:4:0","tags":["算法","数组"],"title":"4. 寻找两个正序数组的中位数","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/4.-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/"},{"categories":["Python"],"content":"CV2 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:0:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"认识 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:1:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"安装 pip install opencv-python pip install opencv-contrib-python ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:1:1","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图片的基本操作 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图片的加载、显示与保存 import cv2 # 生成图片 img = cv2.imread(\"1.jpg\") # 生成灰色图片 imgGrey = cv2.imread(\"1.jpg\", 0) # 展示原图 cv2.imshow(\"img\", img) # 展示灰色图片 cv2.imshow(\"imgGrey\", imgGrey) # 等待图片的关闭 cv2.waitKey() # 保存灰色图片 cv2.imwrite(\"Copy.jpg\", imgGrey) cv2.imread(filepath, flags) 读入一张图像 filepath：图片路径 flags：读入图片的标志 cv2.IMREAD_COLOR：默认参数，读入一副彩色图片，忽略 alpha 通道 cv2.IMREAD_GRAYSCALE：读入灰度图片 cv2.IMREAD_UNCHANGED：顾名思义，读入完整图片，包括 alpha 通道 cv2.imshow(wname, img) 显示图像 wname：显示图像的窗口的名字 img：要显示的图像（imread 读入的图像），窗口大小自动调整为图片大小 cv2.imwrite(file, img, num) 保存一张图像 file：是要保存的文件名 img：要保存的图像。 num：压缩级别。默认为 3 cv2.waitKey(time) 等待指定时间内是否有键盘输入 若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行 若没有按下任何键，超时后返回 -1。参数为 0 表示无限等待（只显示第一帧） 不调用此函数的话，窗口会一闪而逝，看不到显示的图片 time：时间，单位为毫秒 img.copy() 图像复制 np.zeros(img.shape, np.uint8) 返回指定大小的空图像 import cv2 import numpy as np img = cv2.imread(\"1.jpg\") imgZero = np.zeros(img.shape, np.uint8) imgFix = np.zeros((300, 500, 3), np.uint8) # imgFix = np.zeros((300,500),np.uint8) cv2.imshow(\"img\", img) cv2.imshow(\"imgZero\", imgZero) cv2.imshow(\"imgFix\", imgFix) cv2.waitKey() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:1","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图像显示窗口创建与销毁 import cv2 img = cv2.imread(\"1.jpg\") cv2.namedWindow(\"img\", cv2.WINDOW_NORMAL) cv2.imshow(\"img\", img) cv2.waitKey() cv2.destroyAllWindows() cv2.namedWindow(wname, flag) 创建一个窗口 wname：窗口名 flag：指定窗口大小模式 cv2.WINDOW_AUTOSIZE：默认值，根据图像大小自动创建大小 cv2.WINDOW_NORMAL：窗口大小可调整 cv2.destoryAllWindows（窗口名）：删除任何建立的窗口 cv2.destroyAllWindow() 销毁所有窗口 cv2.destroyWindow(wname) 销毁指定窗口 wname：窗口名 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:2","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图像对象的属性 img.shape 返回图像高（图像矩阵的行数）、宽（图像矩阵的列数）和通道数 3 个属性组成的元组 若图像是非彩色图，则只返回高和宽组成的元组。 import cv2 img = cv2.imread(\"1.jpg\") imgGrey = cv2.imread(\"1.jpg\", 0) sp1 = img.shape sp2 = imgGrey.shape print(sp1) print(sp2) # ======输出======= #(1200, 1920, 3) #(1200, 1920) img.size 图像像素总数目 img.dtype 图像数据类型，一般情况下都是 uint8 img[B, G, R] 访问图像对应位置的像素 #获取图像的三通道 blue,green,red = cv2.split(f) #或者 blue = f[:,:,0] green = f[:,:,1] red = f[:,:,2] OpenCV 中图像矩阵的顺序是B、G、R。可以直接通过坐标位置访问和操作图像像素。 import cv2 img = cv2.imread(\"01.jpg\") numb = img[50,100] print(numb) img[50,100] = (0,0,255)#将50，100处的像素点改为红色 cv2.imshow(\"img\",img) cv2.waitKey() 分开访问图像某一通道像素值 import cv2 img = cv2.imread(\"01.jpg\") img[0:100,100:200,0] = 255 img[100:200,200:300,1] = 255 img[200:300,300:400,2] = 255 cv2.imshow(\"img\",img) cv2.waitKey() 更改某一矩阵中的像素值 import cv2 img = cv2.imread(\"01.jpg\") img[0:50,1:100] = (0,0,255) cv2.imshow(\"img\",img) cv2.waitKey() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:3","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图像颜色空间 cv2.cvtColor(img, cv2.COLOR_X2Y) 图像颜色空间转换 img：图像对象 cv2.COLOR_X2Y：从 X 图像转为 Y 图像 其中 X, Y = RGB, BGR, GRAY, HSV, YCrCb, XYZ, Lab, Luv, HLS img2 = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY) #灰度化：彩色图像转为灰度图像 img3 = cv2.cvtColor(img,cv2.COLOR_GRAY2RGB) #彩色化：灰度图像转为彩色图像 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:4","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图像的几何变换 平移 height, width, _ = img.shape moving_matrix = np.float64([[1, 0, x_offset], [0, 1, y_offset]]) moved_img = cv2.warpAffine(img, moving_matrix, (height, width)) 缩放 cv2.resize(image, dsize, fx, fy, interpolation) 图像缩放，返回缩放后的图像 img：原始图像 dsize：图像大小，宽度在前，高度在后，如 (200, 100) fx：代表水平方向上（图像宽度）的缩放系数 fy：代表竖直方向上（图像高度）的缩放系数 interpolation 选项 所用的插值方法 INTER_NEAREST 最近邻插值 INTER_LINEAR 双线性插值（默认设置） INTER_AREA 使用像素区域关系进行重采样。 它可能是图像抽取的首选方法，因为它会产生无云纹理的结果。 但是当图像缩放时，它类似于INTER_NEAREST方法。 INTER_CUBIC 4x4像素邻域的双三次插值 INTER_LANCZOS4 8x8像素邻域的Lanczos插值 在缩小时推荐使用 cv2.INTER_AREA，扩大时推荐使用 cv2.INTER_CUBIC 和 cv2.INTER_LINEAR。 将图片放大一倍 img = cv2.resize(img, dsize=None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR) # or img = cv2.resize(img, (int(2*width), int(2*height)), interpolation=cv2.INTER_AREA) 翻转 cv2.flip(img, flipCode) 图像翻转 img：原始图像 flipCode：控制翻转效果 flipCode = 0：沿 x 轴翻转； flipCode \u003e 0：沿 y 轴翻转； flipCode \u003c 0：x, y 轴同时翻转 仿射变化 cv2.getRotationMarix2D(center, angle, scale) 获得仿射变化矩阵 center：旋转中心 angle：旋转角度 scale：缩放倍数 cv2.warpAffine(img,M,dsize,flags,borderMode,borderValue) 进行仿射变化 img：图像 M：变换矩阵 dsize：输出图像的大小，格式为 (rows,cols) flags：插值方法的组合，默认为 cv2.INTER_LINEAR borderMode：边界像素模式，默认为 cv2.BORDER_REFLECT borderValue：边界填充值; 默认为 0，可设成 (255,255,255) 日常进行仿射变换时，在只设置前三个参数的情况下，如 cv2.warpAffine(img,M,(rows,cols)) 可以实现基本的仿射变换效果，但可能出现“黑边”现象 旋转 import cv2 img = cv2.imread('4.jpg') rows, cols = img.shape[:2] # 第一个参数是旋转中心，第二个参数是旋转角度，第三个参数是缩放比例 M1 = cv2.getRotationMatrix2D((cols/2, rows/2), 45, 0.5) M2 = cv2.getRotationMatrix2D((cols/2, rows/2), 45, 2) M3 = cv2.getRotationMatrix2D((cols/2, rows/2), 45, 1) res1 = cv2.warpAffine(img, M1, (cols, rows)) res2 = cv2.warpAffine(img, M2, (cols, rows)) res3 = cv2.warpAffine(img, M3, (cols, rows)) cv2.imshow('res1', res1) cv2.imshow('res2', res2) cv2.imshow('res3', res3) cv2.waitKey(0) cv2.destroyAllWindows() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:5","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图像三通道分离和合并 cv2.split(img) 分离图像三通道，返回包含被分离的三个图像的元组 img：原始图像 cv2.merge(img_list) 合并图像三通道，返回合并后的图像 img_list：包含三个图像的数组 import cv2 img = cv2.imread(\"01.jpg\") b , g , r = cv2.split(img) # b = cv2.split(img)[0] # g = cv2.split(img)[1] # r = cv2.split(img)[2] merged = cv2.merge([b,g,r]) cv2.imshow(\"Blue\",b) cv2.imshow(\"Green\",g) cv2.imshow(\"Red\",r) cv2.imshow(\"Merged\",merged) cv2.waitKey() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:6","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"颜色空间转换 cv2.cvtColor(img, cv2.COLOR_BGR2HSV) 从 RGB 转换为 HSV ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:7","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"实现正常退出 cv2.waitkey(delaytime) -\u003ereturnvalue 在 delaytime 时间内，按键盘，返回所按键的ASCII值 若未在 delaytime 时间内按任何键，返回 -1 当 delaytime 为 0 时，表示永不退回 当按 ecs 键时，因为其 ASCII 值为 27，而所有returnvalue的值为27，故可用此机制实现在 delaytime 内正常退出 推荐使用 if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() # ord('q')返回q对应的Unicode码对应的值 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:2:8","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"滤波 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:3:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"均值滤波 均值滤波只取内核区域下所有像素的平均值并替换中心元素。3x3 标准化的盒式过滤器如下所示： cv2.blur(img,ksize) 参数 ksize：核大小，如 (5, 5) 特征：核中区域贡献率相同。 作用：对于椒盐噪声的滤除效果比较好。 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:3:1","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"中值滤波 中值滤波是一种典型的非线性滤波，是基于排序统计理论的一种能够有效抑制噪声的非线性信号处理技术 中值滤波将图像的每个像素用邻域（以当前像素为中心的正方形区域）像素的中值代替 。与邻域平均法类似，但计算的是中值。 特征：中心点的像素被核中中位数的像素值代替 作用：对于椒盐噪声有效 cv2.medianBlur(img, ksize) 参数 ksize：滤波模板的尺寸大小，必须是大于1的奇数，如3、5、7 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:3:2","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"高斯滤波 对整幅图像进行加权平均，每个像素的值尤其本身和邻域内的其他像素值经过加权平均后得到 cv2.GuassianBlur(img, ksize,sigmaX,sigmaY) 参数 sigmaX，sigmaY：分别表示 X，Y 方向的标准偏差 如果仅指定了 sigmaX，则 sigmaY 与 sigmaX 相同 如果两者都为零，则根据内核大小计算它们 特征：核中区域贡献率与距离区域中心成正比，权重与高斯分布相关。 作用：高斯模糊在从图像中去除高斯噪声方面非常有效 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:3:3","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"图像提取 SIFT 的全称是 Scale Invariant Feature Transform，尺度不变特征变换。是在不同的尺度空间上查找关键点（特征点），并计算出关键点的方向。 SIFT所查找到的关键点是一些十分突出、不会因光照、仿射变换和噪音等因素而变化的点，如角点、边缘点、暗区的亮点及亮区的暗点等。 SIFT 特征对旋转、尺度缩放、亮度变化等保持不变性，是一种非常稳定的局部特征。 环境 pip install opencv-contrib-python 例 import cv2 import matplotlib.pyplot as plt img = cv2.imread( r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\selina.jpg', 0) # 输入灰度图 # 构造生成器 sift = cv2.xfeatures2d.SIFT_create() # 检测图片 kp, des = sift.detectAndCompute(img, None) # 关键点（Keypoint）和描述子（Descriptor） # 绘出关键点 img2 = cv2.drawKeypoints(img, kp, None, (255, 0, 0), 4) # 显示 plt.figure(figsize=(10, 10)) # 画布放大10倍 plt.axis('off') # 隐藏坐标轴 plt.imshow(img2) # 打印图像 plt.show() # 显示画布 if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:4:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"阈值分割 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:5:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"二值阈值分割 cv2.threshold(src, thresh, maxval, type[, dst]) 参数 thresh：阈值 maxval：最大阈值，一般为 255 type：阈值方式，最主要有五种 阈值 小于阈值的像素点 大于阈值的像素点 0 置 0 置填充色 1 置填充色 置 0 2 保持原色 置灰色 3 置 0 保持原色 4 保持原色 置 0 返回值 ret dst：阈值分割后的图像 例： import cv2 import matplotlib.pyplot as plt # 灰度图读入 img = cv2.imread(r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\gradient.png', 0) # 5种不同的阈值方法 ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) ret, th2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV) ret, th3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC) ret, th4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO) ret, th5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV) titles = ['Original', 'BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV'] images = [img, th1, th2, th3, th4, th5] # 使用Matplotlib显示 # 两行三列图 for i in range(6): plt.subplot(2, 3, i + 1) plt.imshow(images[i], 'gray') plt.title(titles[i], fontsize=8) plt.xticks([]), plt.yticks([]) # 隐藏坐标轴 plt.show() 输出 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:5:1","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"自适应阈值分割 固定阈值将整幅图片分成两类值，它并不适用于明暗分布不均的图片。而自适应阈值会每次取图片的一小部分计算阈值。这样图片不同区域的阈值就不尽相同 cv2.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C) 参数 maxValue：当 thresholdType 采用 cv2.THRESH_BINARY 和 cv2.THRESH_BINARY_INV 时像素点被赋予的新值 adaptiveMethod：自适应阈值的计算方法 cv2.ADPTIVE_THRESH_MEAN_C：阈值取自相邻区域（也就是小区域）的平均值 cv2.ADPTIVE_THRESH_GAUSSIAN_C：阈值取值相邻区域的加权和，权重为一个高斯窗口 thresholdType：阈值分割类型，共 5 种，同 cv2.threshold() 的阈值分割类型参数 blockSize：用来计算阈值的邻域大小（小区域的面积，如 11 就是 11 * 11 的小块） C：常数，最终阈值 = 小区域计算出的阈值 - C 例 import cv2 import matplotlib.pyplot as plt # 灰度图读入 img = cv2.imread(r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\selina.jpg', 0) # 固定阈值 ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) # 自适应阈值 th2 = cv2.adaptiveThreshold( img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 4) th3 = cv2.adaptiveThreshold( img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 17, 6) titles = ['Original', 'Global(v = 127)', 'Adaptive Mean', 'Adaptve Gaussian'] images = [img, th1, th2, th3] for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], 'gray') plt.title(titles[i], fontsize=8) plt.xticks([]), plt.yticks([]) # 隐藏坐标轴 plt.show() 输出 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:5:2","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"标记 cv2.drawKeypoints(img, keypoints, outputimage, color, flags) 参数 keypoints：从原图中获得的关键点，这也是画图时所用到的数据 outputimage：输出（可以是原始图片） color：颜色设置，格式为 (r, g, b) flags：绘图功能的标识设置 cv2.DRAW_MATCHES_FLAGS_DEFAULT：创建输出图像矩阵，使用现存的输出图像绘制匹配对和特征点，对每一个关键点只绘制中间点 cv2.DRAW_MATCHES_FLAGS_DRAW_OVER_OUTIMG：不创建输出图像矩阵，而是在输出图像上绘制匹配对 cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS：对每一个特征点绘制带大小和方向的关键点图形 cv2.DRAW_MATCHES_FLAGS_NOT_DRAW_SINGLE_POINTS：单点的特征点不被绘制 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:6:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"其他图片操作 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:7:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"添加文字 import cv2 img = cv2.imread('caijian.jpg') font = cv2.FONT_HERSHEY_SIMPLEX imgzi = cv2.putText(img, '000', (50, 300), font, 1.2, (255, 255, 255), 2) cv2.putText(img, text, org, fontFace, fontScale, color, thickness=None, lineType=None, bottomLeftOrigin=None) text：str，文字 org：tuple[2]，图像中文本字符串的左下角 fontFace：字体类型，请参见 #HersheyFonts fontScale：字体比例因子乘以特定于字体的基本大小 color：字体颜色 thickness：线条粗细 lineType：线型。 请参阅 #LineTypes bottomLeftOrigin：如果为 true，则图像数据原点位于左下角。 否则，它位于左上角 进行 putText 操作之后，读取原图像也是具有文字显示的 但是原图的文件并没有被改变 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:7:1","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"视频的基本操作 import numpy as np import cv2 cap = cv2.VideoCapture('video1.mp4') while(cap.isOpened()): ret, frame = cap.read() cv2.imshow('frame',frame) # 按下 q 退出播放 if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cap.release() cv2.destroyAllWindows() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:8:0","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"获取视频 获取本地视频 cap = cv2.VideoCapture('video1.mp4') cv2.VideoCapture(path) 获取视频的逐帧进行 cap 返回值如下： \u003cVideoCapture 000001B6734E1310\u003e 获取摄像头 cap = cv2.VideoCapture(0) ... cap.release() VideoCapture() 由摄像头输入视频，默认摄像头为 0 在使用 cv2.VideoCapture() 时习惯性在最后使用 cap.release() 释放视频。 ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:8:1","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"读入视频 ret, frame = cap.read() print(ret,frame.shape) cap.read() 返回值为 retval 和 image，分别是一个布尔值和读取的一帧图片。 frame.shape 返回一个布尔值和数组每个维度的值。显示 True 表示这一帧被成功获取，1920 和 1080 是视频每一帧图片的高和宽，3 是图片的三原色。 True (1920, 1080, 3) 可使用 cap.get(3) 和 cap.get(4) 验证一下视频宽度和高度： cap.get(3) # Out put: 1080.0 一般在使用 cap.read() 时，为避免获取未开始而出现错误，可以使用 cap.isOpened() 检查，实现只有在 cap 已经开始的情况下读取。 while cap.isOpened(): ret,frame = cap.read() ... ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:8:2","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"播放视频 cv2.imshow('frame',frame) # 按下 q 退出播放 if cv2.waitKey(1) \u0026 0xFF == ord('q'): break cv2.imshow(text, video) 这里播放时也可将视频转换为任意模式，如改变去除颜色或 RGB，再进行播放 gray = cv2.cvtColor(frame,code = cv2.COLOR_BGR2GRAY) cv2.imshow('gray_frame',gray) RGB_mode = cv2.cvtColor(frame,code = cv2.COLOR_BGR2RGB) cv2.imshow('RGB_frame',RGB_mode) ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:8:3","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"保存视频 import numpy as np import cv2 cap = cv2.VideoCapture(0) cv2.VideoWriter_fourcc('M','J','P','G') #设置输出文件的名称格式，指定FourCC编码，帧数，尺寸 out = cv2.VideoWriter('output.avi',fourcc, 20.0, (640,480)) # 视频MP4 while(cap.isOpened()): ret, frame = cap.read() if ret==True: #参数为0时竖直方向翻转图片，-1时水平竖直均翻转，1时水平翻转 frame = cv2.flip(frame,1) out.write(frame) cv2.imshow('frame',frame) if cv2.waitKey(1) \u0026 0xFF == ord('q'): break else: break cap.release() out.release() cv2.destroyAllWindows() cv2.imwrite() ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:8:4","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["Python"],"content":"保存帧图像 def video2image(video_dir,save_dir): cap = cv2.VideoCapture(video_dir) #生成读取视频对象 n = 1 #计数 width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)) #获取视频的宽度 height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)) #获取视频的高度 fps = cap.get(cv2.CAP_PROP_FPS) #获取视频的帧率 fourcc = int(cap.get(cv2.CAP_PROP_FOURCC)) #视频的编码 # 定义视频输出 #writer = cv2.VideoWriter(\"teswellvideo_02_result.mp4\", fourcc, fps, (width, height)) i = 0 timeF = int(fps) #视频帧计数间隔频率 while cap.isOpened(): ret,frame = cap.read() #按帧读取视频 #到视频结尾时终止 if ret is False : break #每隔timeF帧进行存储操作 if (n % timeF == 0) : i += 1 print('保存第 %s张图像' % i) save_image_dir = os.path.join(save_dir,'%s.jpg' % i) print('save_image_dir: ', save_image_dir) cv2.imwrite(save_image_dir,frame) #保存视频帧图像 n = n + 1 cv2.waitKey(1) #延时1ms ","date":"2022-02-20","objectID":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/:8:5","tags":["快速开始","Python","cv2"],"title":"CV2","uri":"/Notes/posts/python/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/cv2/"},{"categories":["刷题"],"content":"剑指 Offer 03. 数组中重复的数字 easy https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/ 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["算法","数组","查找"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"散列表 其实用哈希集合更好，但 Go 里没有… // 散列表 func findRepeatNumber(nums []int) int { existNum := map[int]int{} for _, num := range nums { if _, ok := existNum[num]; !ok { existNum[num] = 0 } else { return num } } return -1 } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:1:0","tags":["算法","数组","查找"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"排序 // 排序 func findRepeatNumber2(nums []int) int { sort.Ints(nums) for i := 1; i \u003c len(nums); i++ { if nums[i] == nums[i-1] { return nums[i] } } return -1 } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:2:0","tags":["算法","数组","查找"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"原地交换 把数组的索引利用起来 从头到尾扫描这个数组中的数字，当扫描到下标为 i 的数字时，首先比较这个数字（用 m 表示）是不是等于 i 如果是则接着扫描下一个数字； 如果不是，则拿它和第 m 个数字进行比较 如果它和第 m 个数字相等，就找到了一个重复的数字（该数字在下标为 i 和 m 的位置都出现了）； 如果它和第 m 个数字不相等，就把第 i 个数字和第 m 个数字交换，把 m 放到属于它的位置。 接下来再重复这个比较、交换的过程，直到我们发现一个重复的数字 // 原地交换 func findRepeatNumber3(nums []int) int { i := 0 for i \u003c len(nums) { if nums[i] == i { // 数字即在对应的索引位置 i++ continue } if nums[nums[i]] == nums[i] { // 重复 return nums[i] } // 交换到正确的位置 nums[nums[i]], nums[i] = nums[i], nums[nums[i]] } return -1 } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/:3:0","tags":["算法","数组","查找"],"title":"剑指 Offer 03. 数组中重复的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-03.-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"剑指 Offer 04. 二维数组中的查找 mid search 在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。 请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] 给定 target = 5，返回 true。 给定 target = 20，返回 false。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:0:0","tags":["算法","数组","查找"],"title":"剑指 Offer 04. 二维数组中的查找","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["刷题"],"content":"行二分 每行都来个二分；没有利用到列递增这个特点 // 行二分 func findNumberIn2DArray(matrix [][]int, target int) bool { for _, nums := range matrix { low, high := 0, len(nums)-1 for low \u003c= high { mid := (low + high) \u003e\u003e 1 if nums[mid] \u003e target { high = mid - 1 } else if nums[mid] \u003c target { low = mid + 1 } else { return true } } } return false } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:1:0","tags":["算法","数组","查找"],"title":"剑指 Offer 04. 二维数组中的查找","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["刷题"],"content":"标志位 如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。 算法流程： 从矩阵 matrix 左下角元素（索引设为 (i, j) ）开始遍历，并与目标值对比： 当 matrix[i][j] \u003e target 时，执行 i– ，即消去第 i 行元素； 当 matrix[i][j] \u003c target 时，执行 j++ ，即消去第 j 列元素； 当 matrix[i][j] = target 时，返回 truetrue ，代表找到目标值。 若行索引或列索引越界，则代表矩阵中无目标值，返回 falsefalse 。 // 标志数 func findNumberIn2DArray2(matrix [][]int, target int) bool { row, col := len(matrix)-1, 0 // 从左下角开始 for row \u003e= 0 \u0026\u0026 col \u003c len(matrix[0]) { if matrix[row][col] \u003e target { row-- } else if matrix[row][col] \u003c target { col++ } else { return true } } return false } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/:2:0","tags":["算法","数组","查找"],"title":"剑指 Offer 04. 二维数组中的查找","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-04.-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"},{"categories":["刷题"],"content":"剑指 Offer 09. 用两个栈实现队列 easy stack https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/ 用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 ) 示例 1： 输入： [\"CQueue\",\"appendTail\",\"deleteHead\",\"deleteHead\"] [[],[3],[],[]] 输出：[null,null,3,-1] ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:0:0","tags":["算法","栈与队列"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["刷题"],"content":"双栈 根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。 为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。 如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。 type CQueue struct { stack1 []int // 主栈 stack2 []int // 副栈 } func Constructor() CQueue { return CQueue{stack1: []int{}, stack2: []int{}} } func (this *CQueue) AppendTail(value int) { this.stack1 = append(this.stack1, value) } func (this *CQueue) DeleteHead() int { // 只有stack2为空时，stack1中的元素c倒入stack2中 if len(this.stack2) == 0 { if len(this.stack1) == 0 { return -1 } // 逆序传给stack2 for i := len(this.stack1) - 1; i \u003e= 0; i-- { this.stack2 = append(this.stack2, this.stack1[i]) } this.stack1 = []int{} } result := this.stack2[len(this.stack2)-1] this.stack2 = this.stack2[:len(this.stack2)-1] // 去掉stack2栈顶元素 return result } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/:1:0","tags":["算法","栈与队列"],"title":"剑指 Offer 09. 用两个栈实现队列","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-09.-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"},{"categories":["刷题"],"content":"剑指 Offer 11. 旋转数组的最小数字 easy 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 给你一个可能存在重复元素值的数组 numbers ，它原来是一个升序排列的数组，并按上述情形进行了一次旋转。请返回旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一次旋转，该数组的最小值为1。 示例 1： 输入：[3,4,5,1,2] 输出：1 示例 2： 输入：[2,2,2,0,1] 输出：0 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/:0:0","tags":["算法","数组","二分"],"title":"剑指 Offer 11. 旋转数组的最小数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"二分 middle \u003e high：代表最小值一定在 middle 右侧，所以 low 移到 middle + 1 的位置。 middle \u003c high：代表最小值一定在 middle 左侧或者就是 middle，所以 high移到 middle 的位置。 middle 既不大于 low 指针的值，也不小于 high 指针的值，代表着 middle 可能等于 low 指针的值，或者 high 指针的值，我们这时候只能让 high 指针递减，来一个一个找最小值了。 // 二分 func minArray2(numbers []int) int { low := 0 high := len(numbers) - 1 for low \u003c high { pivot := low + (high-low)/2 if numbers[pivot] \u003c numbers[high] { high = pivot // z } else if numbers[pivot] \u003e numbers[high] { low = pivot + 1 } else { high-- } } return numbers[low] } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/:1:0","tags":["算法","数组","二分"],"title":"剑指 Offer 11. 旋转数组的最小数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-11.-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"剑指 Offer 12. 矩阵中的路径 mid 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。 示例 1： 输入：board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\" 输出：true 示例 2： 输入：board = [[\"a\",\"b\"],[\"c\",\"d\"]], word = \"abcd\" 输出：false ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/:0:0","tags":["算法","回溯"],"title":"剑指 Offer 12. 矩阵中的路径","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"categories":["刷题"],"content":"DFS 约束条件 超出边界 回到上一层（可以并到 1） 字符不同 func exist(board [][]byte, word string) bool { m, n := len(board), len(board[0]) var backtracking func(i, j, layer int) bool // i,j为board指针 layer为层数 从0开始 backtracking = func(i, j, layer int) bool { if i \u003c 0 || i \u003e m-1 || j \u003c 0 || j \u003e n-1 { // 超出边界或回到了上一层 return false } if board[i][j] != word[layer] { // 字符不同 return false } if layer == len(word)-1 { return true } board[i][j] = ' ' // 用来防止回到上一层 res := backtracking(i+1, j, layer+1) || backtracking(i-1, j, layer+1) || backtracking(i, j+1, layer+1) || backtracking(i, j-1, layer+1) board[i][j] = word[layer] return res } for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { if backtracking(i, j, 0) { return true } } } return false } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/:1:0","tags":["算法","回溯"],"title":"剑指 Offer 12. 矩阵中的路径","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-12.-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"categories":["刷题"],"content":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面 easy 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数在数组的前半部分，所有偶数在数组的后半部分。 示例： 输入：nums = [1,2,3,4] 输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。 ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/:0:0","tags":["算法","双指针"],"title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"categories":["刷题"],"content":"快慢指针 func exchange(nums []int) []int { // i始终在第一个偶数上 j往前探索找奇数 slow, fast := 0, 0 for fast \u003c len(nums) { if nums[fast]%2 == 1 { nums[slow], nums[fast] = nums[fast], nums[slow] slow++ } fast++ } return nums } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/:1:0","tags":["算法","双指针"],"title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"categories":["刷题"],"content":"头尾指针 func exchange(nums []int) []int { low, high := 0, len(nums)-1 for low \u003c= high { for low \u003c len(nums) \u0026\u0026 nums[low]%2 == 1 { // low往前走 直到遇到偶数 low++ } for high \u003e= 0 \u0026\u0026 nums[high]%2 == 0 { // high往后退 直到遇到奇数 high-- } if low \u003c high { nums[low], nums[high] = nums[high], nums[low] } } return nums } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/:2:0","tags":["算法","双指针"],"title":"剑指 Offer 21. 调整数组顺序使奇数位于偶数前面","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-21.-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/"},{"categories":["刷题"],"content":"剑指 Offer 30. 包含 min 函数的栈 easy stack https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/ 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.min(); --\u003e 返回 -3. minStack.pop(); minStack.top(); --\u003e 返回 0. minStack.min(); --\u003e 返回 -2. ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/:0:0","tags":["算法","栈与队列"],"title":"剑指 Offer 30. 包含 min 函数的栈","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"categories":["刷题"],"content":"双栈 将 min() 函数复杂度降为 O(1)，可通过建立辅助栈实现； 数据栈 A： 栈 A 用于存储所有元素，保证入栈 push() 函数、出栈 pop() 函数、获取栈顶 top() 函数的正常逻辑。 辅助栈 B： 栈 B 中存储栈 A 中所有非严格降序的元素，则栈 A 中的最小元素始终对应栈 B 的栈顶元素，即 min() 函数只需返回栈 B 的栈顶元素即可 package stack import ( \"container/list\" ) type MinStack struct { stack *list.List // 主栈 minStack *list.List // 记录最小元素的栈 } /** initialize your data structure here. */ func Constructor() MinStack { oriList := list.New() oriMinList := list.New() return MinStack{stack: oriList, minStack: oriMinList} } func (this *MinStack) Push(x int) { this.stack.PushBack(x) if this.minStack.Len() == 0 || x \u003c= this.minStack.Back().Value.(int) { this.minStack.PushBack(x) } } func (this *MinStack) Pop() { deletedVal := this.stack.Remove(this.stack.Back()) if deletedVal == this.minStack.Back().Value.(int) { this.minStack.Remove(this.minStack.Back()) } } func (this *MinStack) Top() int { return this.stack.Back().Value.(int) } func (this *MinStack) Min() int { return this.minStack.Back().Value.(int) } /** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.Min(); */ ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/:1:0","tags":["算法","栈与队列"],"title":"剑指 Offer 30. 包含 min 函数的栈","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/%E5%89%91%E6%8C%87-offer-30.-%E5%8C%85%E5%90%AB-min-%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"},{"categories":["刷题"],"content":"剑指 Offer 57. 和为 s 的两个数字 easy 输入一个递增排序的数组和一个数字 s，在数组中查找两个数，使得它们的和正好是 s。 如果有多对数字的和等于 s，则输出任意一对即可。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[2,7] 或者 [7,2] 示例 2： 输入：nums = [10,26,30,31,47,60], target = 40 输出：[10,30] 或者 [30,10] ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/:0:0","tags":["算法","数组","双指针"],"title":"剑指 Offer 57. 和为 s 的两个数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"对撞指针 func twoSum(nums []int, target int) []int { if len(nums) \u003c= 1 { return []int{} } i, j := 0, len(nums)-1 for i \u003c j { if nums[i]+nums[j] \u003c target { i++ } else if nums[i]+nums[j] \u003e target { j-- } else { return []int{nums[i], nums[j]} } } return []int{} } ","date":"2022-02-20","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/:1:0","tags":["算法","数组","双指针"],"title":"剑指 Offer 57. 和为 s 的两个数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-57.-%E5%92%8C%E4%B8%BA-s-%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"剑指 Offer 53 - II. 0～n-1 中缺失的数字 easy 一个长度为 n-1 的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围 0～n-1 之内。在范围 0～n-1 内的 n 个数字中有且只有一个数字不在该数组中，请找出这个数字。 示例 1: 输入: [0,1,3] 输出: 2 示例 2: 输入: [0,1,2,3,4,5,6,7,9] 输出: 8 ","date":"2022-02-19","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/:0:0","tags":["算法","数组","二分"],"title":"剑指 Offer 53 - II. 0～n-1中缺失的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"遍历 遍历，当前后差为 2 时返回。边界条件比较麻烦。时间复杂度 O(n) // 遍历 出现前后差为2则返回 func missingNumber(nums []int) int { for i := 0; i \u003c len(nums); i++ { if i+1 \u003c len(nums) \u0026\u0026 nums[i+1]-nums[i] \u003e 1 { return i + 1 } } if nums[len(nums)-1] == len(nums)-1 { return len(nums) } else { return 0 } } ","date":"2022-02-19","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/:1:0","tags":["算法","数组","二分"],"title":"剑指 Offer 53 - II. 0～n-1中缺失的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"等差数列求和 很骚，两者之差即为空缺值。时间复杂度 O(n) // 等差数列求和 func missingNumber2(nums []int) int { n := len(nums) totalSum := n * (n + 1) / 2 sum := 0 for i := 0; i \u003c len(nums); i++ { sum += nums[i] } return totalSum - sum } ","date":"2022-02-19","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/:2:0","tags":["算法","数组","二分"],"title":"剑指 Offer 53 - II. 0～n-1中缺失的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["刷题"],"content":"二分 有规律：当 nums[i]==i 时，缺失值在 i 右边；否则在 i 左边。于是就有了二分分半的条件 // 二分 func missingNumber3(nums []int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := (low + high) \u003e\u003e 1 if mid == nums[mid] { // 缺失值在右边 if mid == len(nums)-1 || nums[mid+1]-nums[mid] \u003e 1 { return nums[mid] + 1 } low = mid + 1 } else { // 缺失值在左边 if mid == 0 || nums[mid]-nums[mid-1] \u003e 1 { return nums[mid] - 1 } high = mid - 1 } } return -1 } ","date":"2022-02-19","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/:3:0","tags":["算法","数组","二分"],"title":"剑指 Offer 53 - II. 0～n-1中缺失的数字","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/%E5%89%91%E6%8C%87-offer-53-ii.-0n-1-%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["Golang"],"content":"gorm 官方文档：https://gorm.io/zh_CN/docs package main import ( \"gorm.io/gorm\" \"gorm.io/driver/sqlite\" ) type Product struct { gorm.Model Code string Price uint } func main() { db, err := gorm.Open(sqlite.Open(\"test.db\"), \u0026gorm.Config{}) if err != nil { panic(\"failed to connect database\") } // 迁移 schema db.AutoMigrate(\u0026Product{}) // Create db.Create(\u0026Product{Code: \"D42\", Price: 100}) // Read var product Product db.First(\u0026product, 1) // 根据整型主键查找 db.First(\u0026product, \"code = ?\", \"D42\") // 查找 code 字段值为 D42 的记录 // Update - 将 product 的 price 更新为 200 db.Model(\u0026product).Update(\"Price\", 200) // Update - 更新多个字段 db.Model(\u0026product).Updates(Product{Price: 200, Code: \"F42\"}) // 仅更新非零值字段 db.Model(\u0026product).Updates(map[string]interface{}{\"Price\": 200, \"Code\": \"F42\"}) // Delete - 删除 product db.Delete(\u0026product, 1) } 若要打开 MySQL package main import ( \"fmt\" \"time\" \"github.com/jinzhu/gorm\" _ \"github.com/jinzhu/gorm/dialects/mysql\" ) // 定义一个数据模型(user表) // 列名是字段名的蛇形小写(PassWd-\u003epass_word) type User struct { Id uint `gorm:\"AUTO_INCREMENT\"` Name string `gorm:\"size:50\"` Age int `gorm:\"size:3\"` Birthday *time.Time Email string `gorm:\"type:varchar(50);unique_index\"` PassWord string `gorm:\"type:varchar(25)\"` } var db *gorm.DB func main() { db,err := gorm.Open(\"mysql\",\"root:bgbiao.top@(127.0.0.1:13306)/test_api?charset=utf8\u0026parseTime=True\u0026loc=Local\") if err != nil { fmt.Errorf(\"创建数据库连接失败:%v\",err) } // defer db.Close() // GORM v2 不需要此步 // 自动迁移数据结构(table schema) // 注意:在gorm中，默认的表名都是结构体名称的复数形式，比如User结构体默认创建的表为users // db.SingularTable(true) 可以取消表名的复数形式，使得表名和结构体名称一致 db.AutoMigrate(\u0026User{}) // 添加唯一索引 db.Model(\u0026User{}).AddUniqueIndex(\"name_email\", \"id\", \"name\",\"email\") // 插入记录 db.Create(\u0026User{Name:\"bgbiao\",Age:18,Email:\"bgbiao@bgbiao.top\"}) db.Create(\u0026User{Name:\"xxb\",Age:18,Email:\"xxb@bgbiao.top\"}) var user User var users []User // 查看插入后的全部元素 fmt.Printf(\"插入后元素:\\n\") db.Find(\u0026users) fmt.Println(users) // 查询一条记录 db.First(\u0026user,\"name = ?\",\"bgbiao\") fmt.Println(\"查看查询记录:\",user) // 更新记录(基于查出来的数据进行更新) db.Model(\u0026user).Update(\"name\",\"biaoge\") fmt.Println(\"更新后的记录:\",user) // 删除记录 db.Delete(\u0026user) // 查看全部记录 fmt.Println(\"查看全部记录:\") db.Find(\u0026users) fmt.Println(users) } # 运行gorm实例 $ go run gorm-mysql-example.go 插入后元素: [{1 bgbiao 18 \u003cnil\u003e bgbiao@bgbiao.top } {2 xxb 18 \u003cnil\u003e xxb@bgbiao.top }] 查看查询记录: {1 bgbiao 18 \u003cnil\u003e bgbiao@bgbiao.top } 更新后的记录: {1 biaoge 18 \u003cnil\u003e bgbiao@bgbiao.top } 查看全部记录: [{2 xxb 18 \u003cnil\u003e xxb@bgbiao.top }] ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:0:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"快速开始 https://zhuanlan.zhihu.com/p/113251066 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:1:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"安装 支持的数据库以及导入路径如下: mysql: github.com/jinzhu/gorm/dialects/mysql postgres: github.com/jinzhu/gorm/dialects/postgres sqlite: github.com/jinzhu/gorm/dialects/sqlite sqlserver: github.com/jinzhu/gorm/dialects/mssql gorm 框架只是简单封装了数据库的驱动包，在安装时仍需要下载原始的驱动包 $ go get -u github.com/jinzhu/gorm $ go get -u github.com/go-sql-driver/mysql $ go get -u gorm.io/driver/mysql ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:1:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"模型 模型是标准的 struct，由 Go 的基本数据类型、实现了 Scanner 和 Valuer 接口的自定义类型及其指针或别名组成 type User struct { ID uint Name string Email *string Age uint8 Birthday *time.Time MemberNumber sql.NullString ActivatedAt sql.NullTime CreatedAt time.Time UpdatedAt time.Time } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"约定 GORM 倾向于约定，而不是配置。 默认情况下，Gorm： 使用 ID 作为主键 使用结构体名的 蛇形复数 作为表名 字段名的 蛇形 作为列名 使用 CreatedAt、UpdatedAt 字段追踪创建、更新时间 遵循 GORM 已有的约定，可以减少您的配置和代码量。如果约定不符合您的需求，GORM 允许您自定义配置它们 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"gorm.Model GORM 定义一个 gorm.Model 结构体，其包括字段 ID、CreatedAt、UpdatedAt、DeletedAt // gorm.Model 的定义 type Model struct { ID uint `gorm:\"primaryKey\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\"index\"` } 您可以将它嵌入到您的结构体中，以包含这几个字段 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"字段标签 声明 model 时，tag 是可选的，GORM 支持以下 tag： tag 名大小写不敏感，但建议使用 camelCase 风格 标签名 说明 column 指定 db 列名 type 列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INCREMENT size 指定列大小，例如：size:256 primaryKey 指定列为主键 unique 指定列为唯一 default 指定列的默认值 precision 指定列的精度 scale 指定列大小 not null 指定列为 NOT NULL autoIncrement 指定列为自动增长 autoIncrementIncrement 自动步长，控制连续记录之间的间隔 embedded 嵌套字段 embeddedPrefix 嵌入字段的列名前缀 autoCreateTime 创建时追踪当前时间，对于 int 字段，它会追踪秒级时间戳，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano autoUpdateTime 创建/更新时追踪当前时间，对于 int 字段，它会追踪秒级时间戳，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli index 根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情 uniqueIndex 与 index 相同，但创建的是唯一索引 check 创建检查约束，例如 check:age \u003e 13，查看 约束 获取详情 \u003c- 设置字段写入的权限， \u003c-:create 只创建、\u003c-:update 只更新、\u003c-:false 无写入权限、\u003c- 创建和更新权限 -\u003e 设置字段读的权限，-\u003e:false 无读权限 - 忽略该字段，- 无读写权限 comment 迁移时为字段添加注释 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"字段级权限控制 可导出的字段在使用 GORM 进行 CRUD 时拥有全部的权限，此外，GORM 允许您用标签控制字段级别的权限。这样您就可以让一个字段的权限是只读、只写、只创建、只更新或者被忽略 注意： 使用 GORM Migrator 创建表时，不会创建被忽略的字段 type User struct { Name string `gorm:\"\u003c-:create\"` // 允许读和创建 Name string `gorm:\"\u003c-:update\"` // 允许读和更新 Name string `gorm:\"\u003c-\"` // 允许读和写（创建和更新） Name string `gorm:\"\u003c-:false\"` // 允许读，禁止写 Name string `gorm:\"-\u003e\"` // 只读（除非有自定义配置，否则禁止写） Name string `gorm:\"-\u003e;\u003c-:create\"` // 允许读和写 Name string `gorm:\"-\u003e:false;\u003c-:create\"` // 仅创建（禁止从 db 读） Name string `gorm:\"-\"` // 通过 struct 读写会忽略该字段 } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"创建/更新时间追踪（纳秒、毫秒、秒、Time） GORM 约定使用 CreatedAt、UpdatedAt 追踪创建/更新时间。如果您定义了这种字段，GORM 在创建、更新时会自动填充 当前时间 要使用不同名称的字段，您可以配置 autoCreateTime、autoUpdateTime 标签 如果您想要保存 UNIX（毫/纳）秒时间戳，而不是 time，您只需简单地将 time.Time 修改为 int 即可 type User struct { CreatedAt time.Time // Set to current time if it is zero on creating UpdatedAt int // Set to current unix seconds on updating or if it is zero on creating Updated int64 `gorm:\"autoUpdateTime:nano\"` // Use unix nano seconds as updating time Updated int64 `gorm:\"autoUpdateTime:milli\"`// Use unix milli seconds as updating time Created int64 `gorm:\"autoCreateTime\"` // Use unix seconds as creating time } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"嵌入结构体 对于匿名字段，GORM 会将其字段包含在父结构体中，例如： type User struct { gorm.Model Name string } // 等效于 type User struct { ID uint `gorm:\"primaryKey\"` CreatedAt time.Time UpdatedAt time.Time DeletedAt gorm.DeletedAt `gorm:\"index\"` Name string } 对于正常的结构体字段，你也可以通过标签 embedded 将其嵌入，例如： type Author struct { Name string Email string } type Blog struct { ID int Author Author `gorm:\"embedded\"` Upvotes int32 } // 等效于 type Blog struct { ID int64 Name string Email string Upvotes int32 } 并且，您可以使用标签 embeddedPrefix 来为 db 中的字段名添加前缀，例如： type Blog struct { ID int Author Author `gorm:\"embedded;embeddedPrefix:author_\"` Upvotes int32 } // 等效于 type Blog struct { ID int64 AuthorName string AuthorEmail string Upvotes int32 } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:6","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"关联标签 GORM 允许通过标签为关联配置外键、约束、many2many 表 标签 描述 foreignKey 指定当前模型的列作为连接表的外键 references 指定引用表的列名，其将被映射为连接表外键 polymorphic 指定多态类型，比如模型名 polymorphicValue 指定多态值、默认表名 many2many 指定连接表表名 joinForeignKey 指定连接表的外键列名，其将被映射到当前表 joinReferences 指定连接表的外键列名，其将被映射到引用表 constraint 关系约束，例如：OnUpdate、OnDelete ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:2:7","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"连接到数据库 GORM 官方支持的数据库类型有： MySQL, PostgreSQL, SQlite, SQL Server ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:3:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"MySQL import ( \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) func main() { // 参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name 获取详情 dsn := \"user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4\u0026parseTime=True\u0026loc=Local\" db, err := gorm.Open(mysql.Open(dsn), \u0026gorm.Config{}) } MySQl 驱动程序提供了 一些高级配置 可以在初始化过程中使用，例如： db, err := gorm.Open(mysql.New(mysql.Config{ DSN: \"gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8\u0026parseTime=True\u0026loc=Local\", // DSN data source name DefaultStringSize: 256, // string 类型字段的默认长度 DisableDatetimePrecision: true, // 禁用 datetime 精度，MySQL 5.6 之前的数据库不支持 DontSupportRenameIndex: true, // 重命名索引时采用删除并新建的方式，MySQL 5.7 之前的数据库和 MariaDB 不支持重命名索引 DontSupportRenameColumn: true, // 用 `change` 重命名列，MySQL 8 之前的数据库和 MariaDB 不支持重命名列 SkipInitializeWithVersion: false, // 根据当前 MySQL 版本自动配置 }), \u0026gorm.Config{}) 自定义驱动 GORM 允许通过 DriverName 选项自定义 MySQL 驱动，例如： import ( _ \"example.com/my_mysql_driver\" \"gorm.io/gorm\" ) db, err := gorm.Open(mysql.New(mysql.Config{ DriverName: \"my_mysql_driver\", DSN: \"gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8\u0026parseTime=True\u0026loc=Local\", // Data Source Name，参考 https://github.com/go-sql-driver/mysql#dsn-data-source-name }), \u0026gorm.Config{}) 现有的数据库连接 GORM 允许通过一个现有的数据库连接来初始化 *gorm.DB import ( \"database/sql\" \"gorm.io/driver/mysql\" \"gorm.io/gorm\" ) sqlDB, err := sql.Open(\"mysql\", \"mydb_dsn\") gormDB, err := gorm.Open(mysql.New(mysql.Config{ Conn: sqlDB, }), \u0026gorm.Config{}) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:3:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"SQLite import ( \"gorm.io/driver/sqlite\" \"gorm.io/gorm\" ) // github.com/mattn/go-sqlite3 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), \u0026gorm.Config{}) 注意： 您也可以使用 file::memory:?cache=shared 替代文件路径。 这会告诉 SQLite 在系统内存中使用一个临时数据库。 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:3:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"连接池 GORM 使用 database/sql 维护连接池 sqlDB, err := db.DB() // SetMaxIdleConns 设置空闲连接池中连接的最大数量 sqlDB.SetMaxIdleConns(10) // SetMaxOpenConns 设置打开数据库连接的最大数量。 sqlDB.SetMaxOpenConns(100) // SetConnMaxLifetime 设置了连接可复用的最大时间。 sqlDB.SetConnMaxLifetime(time.Hour) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:4:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"创建 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"创建记录 user := User{Name: \"Jinzhu\", Age: 18, Birthday: time.Now()} result := db.Create(\u0026user) // 通过数据的指针来创建 user.ID // 返回插入数据的主键 result.Error // 返回 error result.RowsAffected // 返回插入记录的条数 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"筛选指定字段来创建记录 创建记录并更新给出的字段。 db.Select(\"Name\", \"Age\", \"CreatedAt\").Create(\u0026user) // INSERT INTO `users` (`name`,`age`,`created_at`) VALUES (\"jinzhu\", 18, \"2020-07-04 11:05:21.775\") 创建一个记录且一同忽略传递给略去的字段值。 db.Omit(\"Name\", \"Age\", \"CreatedAt\").Create(\u0026user) // INSERT INTO `users` (`birthday`,`updated_at`) VALUES (\"2020-01-01 00:00:00.000\", \"2020-07-04 11:05:21.775\") ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"批量插入 要有效地插入大量记录，请将一个 slice 传递给 Create 方法。 GORM 将生成单独一条 SQL 语句来插入所有数据，并回填主键的值，钩子方法也会被调用。 var users = []User{{Name: \"jinzhu1\"}, {Name: \"jinzhu2\"}, {Name: \"jinzhu3\"}} db.Create(\u0026users) for _, user := range users { user.ID // 1,2,3 } 使用 CreateInBatches 分批创建时，你可以指定每批的数量，例如： var users = []User{{name: \"jinzhu_1\"}, ...., {Name: \"jinzhu_10000\"}} // 数量为 100 db.CreateInBatches(users, 100) Upsert 和 Create With Associations 也支持批量插入 注意 使用 CreateBatchSize 选项初始化 GORM 时，所有的创建 \u0026 关联 INSERT 都将遵循该选项 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), \u0026gorm.Config{ CreateBatchSize: 1000, }) db := db.Session(\u0026gorm.Session{CreateBatchSize: 1000}) users = [5000]User{{Name: \"jinzhu\", Pets: []Pet{pet1, pet2, pet3}}...} db.Create(\u0026users) // INSERT INTO users xxx (5 batches) // INSERT INTO pets xxx (15 batches) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"创建钩子 GORM 允许用户定义的钩子有 BeforeSave, BeforeCreate, AfterSave, AfterCreate 创建记录时将调用这些钩子方法 func (u *User) BeforeCreate(tx *gorm.DB) (err error) { u.UUID = uuid.New() if u.Role == \"admin\" { return errors.New(\"invalid role\") } return } 如果您想跳过 钩子 方法，您可以使用 SkipHooks 会话模式，例如： DB.Session(\u0026gorm.Session{SkipHooks: true}).Create(\u0026user) DB.Session(\u0026gorm.Session{SkipHooks: true}).Create(\u0026users) DB.Session(\u0026gorm.Session{SkipHooks: true}).CreateInBatches(users, 100) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"根据 Map 创建 GORM 支持根据 map[string]interface{} 和 []map[string]interface{}{} 创建记录，例如： db.Model(\u0026User{}).Create(map[string]interface{}{ \"Name\": \"jinzhu\", \"Age\": 18, }) // batch insert from `[]map[string]interface{}{}` db.Model(\u0026User{}).Create([]map[string]interface{}{ {\"Name\": \"jinzhu_1\", \"Age\": 18}, {\"Name\": \"jinzhu_2\", \"Age\": 20}, }) 注意： 根据 map 创建记录时，association 不会被调用，且主键也不会自动填充 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"使用 SQL 表达式、Context Valuer 创建记录 GORM 允许使用 SQL 表达式插入数据，有两种方法实现这个目标。根据 map[string]interface{} 或 自定义数据类型 创建，例如： // 通过 map 创建记录 db.Model(User{}).Create(map[string]interface{}{ \"Name\": \"jinzhu\", \"Location\": clause.Expr{SQL: \"ST_PointFromText(?)\", Vars: []interface{}{\"POINT(100 100)\"}}, }) // INSERT INTO `users` (`name`,`location`) VALUES (\"jinzhu\",ST_PointFromText(\"POINT(100 100)\")); // 通过自定义类型创建记录 type Location struct { X, Y int } // Scan 方法实现了 sql.Scanner 接口 func (loc *Location) Scan(v interface{}) error { // Scan a value into struct from database driver } func (loc Location) GormDataType() string { return \"geometry\" } func (loc Location) GormValue(ctx context.Context, db *gorm.DB) clause.Expr { return clause.Expr{ SQL: \"ST_PointFromText(?)\", Vars: []interface{}{fmt.Sprintf(\"POINT(%d %d)\", loc.X, loc.Y)}, } } type User struct { Name string Location Location } db.Create(\u0026User{ Name: \"jinzhu\", Location: Location{X: 100, Y: 100}, }) // INSERT INTO `users` (`name`,`location`) VALUES (\"jinzhu\",ST_PointFromText(\"POINT(100 100)\")) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:6","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"高级选项 关联创建 创建关联数据时，如果关联值是非零值，这些关联会被 upsert，且它们的 Hook 方法也会被调用 type CreditCard struct { gorm.Model Number string UserID uint } type User struct { gorm.Model Name string CreditCard CreditCard } db.Create(\u0026User{ Name: \"jinzhu\", CreditCard: CreditCard{Number: \"411111111111\"} }) // INSERT INTO `users` ... // INSERT INTO `credit_cards` ... 您也可以通过 Select、 Omit 跳过关联保存，例如： db.Omit(\"CreditCard\").Create(\u0026user) // 跳过所有关联 db.Omit(clause.Associations).Create(\u0026user) 默认值 您可以通过标签 default 为字段定义默认值，如： type User struct { ID int64 Name string `gorm:\"default:galeone\"` Age int64 `gorm:\"default:18\"` } 插入记录到数据库时，默认值 会被用于 填充值为 零值 的字段 注意 对于声明了默认值的字段，像 0、''、false 等零值是不会保存到数据库。您需要使用指针类型或 Scanner/Valuer 来避免这个问题，例如： type User struct { gorm.Model Name string Age *int `gorm:\"default:18\"` Active sql.NullBool `gorm:\"default:true\"` } 注意 若要数据库有默认、虚拟/生成的值，你必须为字段设置 default 标签。若要在迁移时跳过默认值定义，你可以使用 default:(-)，例如： type User struct { ID string `gorm:\"default:uuid_generate_v3()\"` // db func FirstName string LastName string Age uint8 FullName string `gorm:\"-\u003e;type:GENERATED ALWAYS AS (concat(firstname,' ',lastname));default:(-);\"` } 使用虚拟/生成的值时，你可能需要禁用它的创建、更新权限，查看 字段级权限 获取详情 Upsert 及冲突 GORM 为不同数据库提供了兼容的 Upsert 支持 import \"gorm.io/gorm/clause\" // 在冲突时，什么都不做 db.Clauses(clause.OnConflict{DoNothing: true}).Create(\u0026user) // 在`id`冲突时，将列更新为默认值 db.Clauses(clause.OnConflict{ Columns: []clause.Column{{Name: \"id\"}}, DoUpdates: clause.Assignments(map[string]interface{}{\"role\": \"user\"}), }).Create(\u0026users) // MERGE INTO \"users\" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET ***; SQL Server // INSERT INTO `users` *** ON DUPLICATE KEY UPDATE ***; MySQL // 使用SQL语句 db.Clauses(clause.OnConflict{ Columns: []clause.Column{{Name: \"id\"}}, DoUpdates: clause.Assignments(map[string]interface{}{\"count\": gorm.Expr(\"GREATEST(count, VALUES(count))\")}), }).Create(\u0026users) // INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `count`=GREATEST(count, VALUES(count)); // 在`id`冲突时，将列更新为新值 db.Clauses(clause.OnConflict{ Columns: []clause.Column{{Name: \"id\"}}, DoUpdates: clause.AssignmentColumns([]string{\"name\", \"age\"}), }).Create(\u0026users) // MERGE INTO \"users\" USING *** WHEN NOT MATCHED THEN INSERT *** WHEN MATCHED THEN UPDATE SET \"name\"=\"excluded\".\"name\"; SQL Server // INSERT INTO \"users\" *** ON CONFLICT (\"id\") DO UPDATE SET \"name\"=\"excluded\".\"name\", \"age\"=\"excluded\".\"age\"; PostgreSQL // INSERT INTO `users` *** ON DUPLICATE KEY UPDATE `name`=VALUES(name),`age=VALUES(age); MySQL // 在冲突时，更新除主键以外的所有列到新值。 db.Clauses(clause.OnConflict{ UpdateAll: true, }).Create(\u0026users) // INSERT INTO \"users\" *** ON CONFLICT (\"id\") DO UPDATE SET \"name\"=\"excluded\".\"name\", \"age\"=\"excluded\".\"age\", ...; 您还可以查看 高级查询 中的 FirstOrInit、FirstOrCreate ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:5:7","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"查询 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"检索单个对象 GORM 提供了 First、Take、Last 方法，以便从数据库中检索单个对象。当查询数据库时它添加了 LIMIT 1 条件，且没有找到记录时，它会返回 ErrRecordNotFound 错误 // 获取第一条记录（主键升序） db.First(\u0026user) // SELECT * FROM users ORDER BY id LIMIT 1; // 获取一条记录，没有指定排序字段 db.Take(\u0026user) // SELECT * FROM users LIMIT 1; // 获取最后一条记录（主键降序） db.Last(\u0026user) // SELECT * FROM users ORDER BY id DESC LIMIT 1; result := db.First(\u0026user) result.RowsAffected // 返回找到的记录数 result.Error // returns error or nil // 检查 ErrRecordNotFound 错误 errors.Is(result.Error, gorm.ErrRecordNotFound) 如果你想避免 ErrRecordNotFound 错误，你可以使用 Find，比如 db.Limit(1).Find(\u0026user)，Find方法可以接受 struct 和 slice 的数据。 只有在目标 struct 是指针或者通过 db.Model() 指定 model 时，该方法才有效。 此外，如果相关 model 没有定义主键，那么将按 model 的第一个字段进行排序。 例如: var user User var users []User // 有效，因为目标 struct 是指针 db.First(\u0026user) // SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1 // 有效，因为通过 `db.Model()` 指定了 model result := map[string]interface{}{} db.Model(\u0026User{}).First(\u0026result) // SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1 // 无效 result := map[string]interface{}{} db.Table(\"users\").First(\u0026result) // 配合 Take 有效 result := map[string]interface{}{} db.Table(\"users\").Take(\u0026result) // 未指定主键，会根据第一个字段排序(即：`Code`) type Language struct { Code string Name string } db.First(\u0026Language{}) // SELECT * FROM `languages` ORDER BY `languages`.`code` LIMIT 1 用主键检索 如果主键是数字类型，您可以使用 内联条件 来检索对象。 传入字符串参数时，需要特别注意 SQL 注入问题 db.First(\u0026user, 10) // SELECT * FROM users WHERE id = 10; db.First(\u0026user, \"10\") // SELECT * FROM users WHERE id = 10; db.Find(\u0026users, []int{1,2,3}) // SELECT * FROM users WHERE id IN (1,2,3); 如果主键是字符串（例如像 uuid），查询将被写成这样： db.First(\u0026user, \"id = ?\", \"1b74413f-f3b8-409f-ac47-e8c062e3472a\") // SELECT * FROM users WHERE id = \"1b74413f-f3b8-409f-ac47-e8c062e3472a\"; ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"检索全部对象 // 获取全部记录 result := db.Find(\u0026users) // SELECT * FROM users; result.RowsAffected // 返回找到的记录数，相当于 `len(users)` result.Error // returns error ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"条件 String 条件 // 获取第一条匹配的记录 db.Where(\"name = ?\", \"jinzhu\").First(\u0026user) // SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1; // 获取全部匹配的记录 db.Where(\"name \u003c\u003e ?\", \"jinzhu\").Find(\u0026users) // SELECT * FROM users WHERE name \u003c\u003e 'jinzhu'; // IN db.Where(\"name IN ?\", []string{\"jinzhu\", \"jinzhu 2\"}).Find(\u0026users) // SELECT * FROM users WHERE name IN ('jinzhu','jinzhu 2'); // LIKE db.Where(\"name LIKE ?\", \"%jin%\").Find(\u0026users) // SELECT * FROM users WHERE name LIKE '%jin%'; // AND db.Where(\"name = ? AND age \u003e= ?\", \"jinzhu\", \"22\").Find(\u0026users) // SELECT * FROM users WHERE name = 'jinzhu' AND age \u003e= 22; // Time db.Where(\"updated_at \u003e ?\", lastWeek).Find(\u0026users) // SELECT * FROM users WHERE updated_at \u003e '2000-01-01 00:00:00'; // BETWEEN db.Where(\"created_at BETWEEN ? AND ?\", lastWeek, today).Find(\u0026users) // SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00'; Struct \u0026 Map 条件 // Struct db.Where(\u0026User{Name: \"jinzhu\", Age: 20}).First(\u0026user) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 20 ORDER BY id LIMIT 1; // Map db.Where(map[string]interface{}{\"name\": \"jinzhu\", \"age\": 20}).Find(\u0026users) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 20; // 主键切片条件 db.Where([]int64{20, 21, 22}).Find(\u0026users) // SELECT * FROM users WHERE id IN (20, 21, 22); 注意 当使用结构作为条件查询时，GORM 只会查询非零值字段。这意味着如果您的字段值为 0、''、false 或其他 零值，该字段不会被用于构建查询条件，例如： db.Where(\u0026User{Name: \"jinzhu\", Age: 0}).Find(\u0026users) // SELECT * FROM users WHERE name = \"jinzhu\"; 如果想要包含零值查询条件，你可以使用 map，其会包含所有 key-value 的查询条件，例如： db.Where(map[string]interface{}{\"Name\": \"jinzhu\", \"Age\": 0}).Find(\u0026users) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 0; 或者使用 6.3.3 的方法 指定结构体查询字段 当使用 struct 进行查询时，你可以通过向 Where() 传入 struct 来指定查询条件的字段、值、表名，例如： db.Where(\u0026User{Name: \"jinzhu\"}, \"name\", \"Age\").Find(\u0026users) // SELECT * FROM users WHERE name = \"jinzhu\" AND age = 0; db.Where(\u0026User{Name: \"jinzhu\"}, \"Age\").Find(\u0026users) // SELECT * FROM users WHERE age = 0; 内联条件 查询条件也可以被内联到 First 和 Find 之类的方法中，其用法类似于 Where。 // 根据主键获取记录，如果是非整型主键 db.First(\u0026user, \"id = ?\", \"string_primary_key\") // SELECT * FROM users WHERE id = 'string_primary_key'; // Plain SQL db.Find(\u0026user, \"name = ?\", \"jinzhu\") // SELECT * FROM users WHERE name = \"jinzhu\"; db.Find(\u0026users, \"name \u003c\u003e ? AND age \u003e ?\", \"jinzhu\", 20) // SELECT * FROM users WHERE name \u003c\u003e \"jinzhu\" AND age \u003e 20; // Struct db.Find(\u0026users, User{Age: 20}) // SELECT * FROM users WHERE age = 20; // Map db.Find(\u0026users, map[string]interface{}{\"age\": 20}) // SELECT * FROM users WHERE age = 20; Not 条件 构建 NOT 条件，用法与 Where 类似 db.Not(\"name = ?\", \"jinzhu\").First(\u0026user) // SELECT * FROM users WHERE NOT name = \"jinzhu\" ORDER BY id LIMIT 1; // Not In db.Not(map[string]interface{}{\"name\": []string{\"jinzhu\", \"jinzhu 2\"}}).Find(\u0026users) // SELECT * FROM users WHERE name NOT IN (\"jinzhu\", \"jinzhu 2\"); // Struct db.Not(User{Name: \"jinzhu\", Age: 18}).First(\u0026user) // SELECT * FROM users WHERE name \u003c\u003e \"jinzhu\" AND age \u003c\u003e 18 ORDER BY id LIMIT 1; // 不在主键切片中的记录 db.Not([]int64{1,2,3}).First(\u0026user) // SELECT * FROM users WHERE id NOT IN (1,2,3) ORDER BY id LIMIT 1; Or 条件 db.Where(\"role = ?\", \"admin\").Or(\"role = ?\", \"super_admin\").Find(\u0026users) // SELECT * FROM users WHERE role = 'admin' OR role = 'super_admin'; // Struct db.Where(\"name = 'jinzhu'\").Or(User{Name: \"jinzhu 2\", Age: 18}).Find(\u0026users) // SELECT * FROM users WHERE name = 'jinzhu' OR (name = 'jinzhu 2' AND age = 18); // Map db.Where(\"name = 'jinzhu'\").Or(map[string]interface{}{\"name\": \"jinzhu 2\", \"age\": 18}).Find(\u0026users) // SELECT * FROM users WHERE name = 'jinzhu' OR (name = 'jinzhu 2' AND age = 18); 更复杂的 SQL 查询， 请查看 高级查询中的组条件。 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"选择特定字段 Select 允许您指定从数据库中检索哪些字段， 默认情况下，GORM 会检索所有字段。 db.Select(\"name\", \"age\").Find(\u0026users) // SELECT name, age FROM users; db.Select([]string{\"name\", \"age\"}).Find(\u0026users) // SELECT name, age FROM users; db.Table(\"users\").Select(\"COALESCE(age,?)\", 42).Rows() // SELECT COALESCE(age,'42') FROM users; 还可以看一看 [智能选择字段](https://gorm.io/ zh_CN/docs/advanced_query.html#smart_select) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Order 指定从数据库检索记录时的排序方式 db.Order(\"age desc, name\").Find(\u0026users) // SELECT * FROM users ORDER BY age desc, name; // 多个 order db.Order(\"age desc\").Order(\"name\").Find(\u0026users) // SELECT * FROM users ORDER BY age desc, name; db.Clauses(clause.OrderBy{ Expression: clause.Expr{SQL: \"FIELD(id,?)\", Vars: []interface{}{[]int{1, 2, 3}}, WithoutParentheses: true}, }).Find(\u0026User{}) // SELECT * FROM users ORDER BY FIELD(id,1,2,3) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Limit \u0026 Offset Limit 指定获取记录的最大数量 Offset 指定在开始返回记录之前要跳过的记录数量 db.Limit(3).Find(\u0026users) // SELECT * FROM users LIMIT 3; // 通过 -1 消除 Limit 条件 db.Limit(10).Find(\u0026users1).Limit(-1).Find(\u0026users2) // SELECT * FROM users LIMIT 10; (users1) // SELECT * FROM users; (users2) db.Offset(3).Find(\u0026users) // SELECT * FROM users OFFSET 3; db.Limit(10).Offset(5).Find(\u0026users) // SELECT * FROM users OFFSET 5 LIMIT 10; // 通过 -1 消除 Offset 条件 db.Offset(10).Find(\u0026users1).Offset(-1).Find(\u0026users2) // SELECT * FROM users OFFSET 10; (users1) // SELECT * FROM users; (users2) 查看 Pagination 学习如何写一个分页器 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:6","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"GroupBy \u0026 Having type result struct { Date time.Time Total int } db.Model(\u0026User{}).Select(\"name, sum(age) as total\").Where(\"name LIKE ?\", \"group%\").Group(\"name\").First(\u0026result) // SELECT name, sum(age) as total FROM `users` WHERE name LIKE \"group%\" GROUP BY `name` LIMIT 1 db.Model(\u0026User{}).Select(\"name, sum(age) as total\").Group(\"name\").Having(\"name = ?\", \"group\").Find(\u0026result) // SELECT name, sum(age) as total FROM `users` GROUP BY `name` HAVING name = \"group\" rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Rows() for rows.Next() { ... } rows, err := db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) \u003e ?\", 100).Rows() for rows.Next() { ... } type Result struct { Date time.Time Total int64 } db.Table(\"orders\").Select(\"date(created_at) as date, sum(amount) as total\").Group(\"date(created_at)\").Having(\"sum(amount) \u003e ?\", 100).Scan(\u0026results) Distinct 从模型中选择不相同的值 db.Distinct(\"name\", \"age\").Order(\"name, age desc\").Find(\u0026results) Distinct 也可以配合 Pluck, Count 使用 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:7","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Joins 指定 Joins 条件 type result struct { Name string Email string } db.Model(\u0026User{}).Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(\u0026result{}) // SELECT users.name, emails.email FROM `users` left join emails on emails.user_id = users.id rows, err := db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Rows() for rows.Next() { ... } db.Table(\"users\").Select(\"users.name, emails.email\").Joins(\"left join emails on emails.user_id = users.id\").Scan(\u0026results) // 带参数的多表连接 db.Joins(\"JOIN emails ON emails.user_id = users.id AND emails.email = ?\", \"jinzhu@example.org\").Joins(\"JOIN credit_cards ON credit_cards.user_id = users.id\").Where(\"credit_cards.number = ?\", \"411111111111\").Find(\u0026user) Joins 预加载 您可以使用 Joins 实现单条 SQL 预加载关联记录，例如： db.Joins(\"Company\").Find(\u0026users) // SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id`; Join with conditions db.Joins(\"Company\", DB.Where(\u0026Company{Alive: true})).Find(\u0026users) // SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id` AND `Company`.`alive` = true; For more details, please refer to Preloading (Eager Loading). ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:8","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Scan Scanning results into a struct works similarly to the way we use Find Find 中只能传递 gorm 模型，但 Scan 中可以传递任意结构体，用以接收只含有部分字段的查询结果 type Result struct { Name string Age int } var result Result db.Table(\"users\").Select(\"name\", \"age\").Where(\"name = ?\", \"Antonio\").Scan(\u0026result) // Raw SQL db.Raw(\"SELECT name, age FROM users WHERE name = ?\", \"Antonio\").Scan(\u0026result) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:6:9","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"更新 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"保存所有字段 Save 会保存所有的字段，即使字段是零值 db.First(\u0026user) user.Name = \"jinzhu 2\" user.Age = 100 db.Save(\u0026user) // UPDATE users SET name='jinzhu 2', age=100, birthday='2016-01-01', updated_at = '2013-11-17 21:34:10' WHERE id=111; ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"更新单个列 当使用 Update 更新单个列时，你需要指定条件，否则会返回 ErrMissingWhereClause 错误，查看 Block Global Updates 获取详情。当使用了 Model 方法，且该对象主键有值，该值会被用于构建条件，例如： // 条件更新 db.Model(\u0026User{}).Where(\"active = ?\", true).Update(\"name\", \"hello\") // UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE active=true; // User 的 ID 是 `111` db.Model(\u0026user).Update(\"name\", \"hello\") // UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111; // 根据条件和 model 的值进行更新 db.Model(\u0026user).Where(\"active = ?\", true).Update(\"name\", \"hello\") // UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true; ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"更新多列 Updates 方法支持 struct 和 map[string]interface{} 参数。 当使用 struct 更新时，默认情况下，GORM 只会更新非零值的字段 // 根据 `struct` 更新属性，只会更新非零值的字段 db.Model(\u0026user).Updates(User{Name: \"hello\", Age: 18, Active: false}) // UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111; // 根据 `map` 更新属性 db.Model(\u0026user).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) // UPDATE users SET name='hello', age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111; 注意 当通过 struct 更新时，GORM 只会更新非零字段。 如果您想确保指定字段被更新，你应该使用 Select 更新选定字段，或使用 map 来完成更新操作 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"更新选定字段 如果您想要在更新时选定、忽略某些字段，您可以使用 Select、Omit // 使用 Map 进行 Select // User's ID is `111`: db.Model(\u0026user).Select(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) // UPDATE users SET name='hello' WHERE id=111; db.Model(\u0026user).Omit(\"name\").Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18, \"active\": false}) // UPDATE users SET age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111; // 使用 Struct 进行 Select（会 select 零值的字段） db.Model(\u0026user).Select(\"Name\", \"Age\").Updates(User{Name: \"new_name\", Age: 0}) // UPDATE users SET name='new_name', age=0 WHERE id=111; // Select 所有字段（查询包括零值字段的所有字段） db.Model(\u0026user).Select(\"*\").Update(User{Name: \"jinzhu\", Role: \"admin\", Age: 0}) // Select 除 Role 外的所有字段（包括零值字段的所有字段） db.Model(\u0026user).Select(\"*\").Omit(\"Role\").Update(User{Name: \"jinzhu\", Role: \"admin\", Age: 0}) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"更新 Hook 对于更新操作，GORM 支持 BeforeSave、BeforeUpdate、AfterSave、AfterUpdate 钩子，这些方法将在更新记录时被调用，详情请参阅 钩子 func (u *User) BeforeUpdate(tx *gorm.DB) (err error) { if u.Role == \"admin\" { return errors.New(\"admin user not allowed to update\") } return } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"批量更新 如果您尚未通过 Model 指定记录的主键，则 GORM 会执行批量更新 // 根据 struct 更新 db.Model(User{}).Where(\"role = ?\", \"admin\").Updates(User{Name: \"hello\", Age: 18}) // UPDATE users SET name='hello', age=18 WHERE role = 'admin'; // 根据 map 更新 db.Table(\"users\").Where(\"id IN ?\", []int{10, 11}).Updates(map[string]interface{}{\"name\": \"hello\", \"age\": 18}) // UPDATE users SET name='hello', age=18 WHERE id IN (10, 11); 阻止全局更新 如果在没有任何条件的情况下执行批量更新，默认情况下，GORM 不会执行该操作，并返回 ErrMissingWhereClause 错误 对此，你必须加一些条件，或者使用原生 SQL，或者启用 AllowGlobalUpdate 模式，例如： db.Model(\u0026User{}).Update(\"name\", \"jinzhu\").Error // gorm.ErrMissingWhereClause db.Model(\u0026User{}).Where(\"1 = 1\").Update(\"name\", \"jinzhu\") // UPDATE users SET `name` = \"jinzhu\" WHERE 1=1 db.Exec(\"UPDATE users SET name = ?\", \"jinzhu\") // UPDATE users SET name = \"jinzhu\" db.Session(\u0026gorm.Session{AllowGlobalUpdate: true}).Model(\u0026User{}).Update(\"name\", \"jinzhu\") // UPDATE users SET `name` = \"jinzhu\" 更新的记录数 获取受更新影响的行数 // 通过 `RowsAffected` 得到更新的记录数 result := db.Model(User{}).Where(\"role = ?\", \"admin\").Updates(User{Name: \"hello\", Age: 18}) // UPDATE users SET name='hello', age=18 WHERE role = 'admin'; result.RowsAffected // 更新的记录数 result.Error // 更新的错误 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:6","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"高级选项 使用 SQL 表达式更新 GORM 允许使用 SQL 表达式更新列，例如： // product 的 ID 是 `3` db.Model(\u0026product).Update(\"price\", gorm.Expr(\"price * ? + ?\", 2, 100)) // UPDATE \"products\" SET \"price\" = price * 2 + 100, \"updated_at\" = '2013-11-17 21:34:10' WHERE \"id\" = 3; db.Model(\u0026product).Updates(map[string]interface{}{\"price\": gorm.Expr(\"price * ? + ?\", 2, 100)}) // UPDATE \"products\" SET \"price\" = price * 2 + 100, \"updated_at\" = '2013-11-17 21:34:10' WHERE \"id\" = 3; // 不会更新 updated_at 字段 db.Model(\u0026product).UpdateColumn(\"quantity\", gorm.Expr(\"quantity - ?\", 1)) // UPDATE \"products\" SET \"quantity\" = quantity - 1 WHERE \"id\" = 3; db.Model(\u0026product).Where(\"quantity \u003e 1\").UpdateColumn(\"quantity\", gorm.Expr(\"quantity - ?\", 1)) // UPDATE \"products\" SET \"quantity\" = quantity - 1 WHERE \"id\" = 3 AND quantity \u003e 1; 并且 GORM 也允许使用 SQL 表达式、自定义数据类型的 Context Valuer 来更新，例如： // 根据自定义数据类型创建 type Location struct { X, Y int } func (loc Location) GormValue(ctx context.Context, db *gorm.DB) clause.Expr { return clause.Expr{ SQL: \"ST_PointFromText(?)\", Vars: []interface{}{fmt.Sprintf(\"POINT(%d %d)\", loc.X, loc.Y)}, } } db.Model(\u0026User{ID: 1}).Updates(User{ Name: \"jinzhu\", Location: Location{X: 100, Y: 100}, }) // UPDATE `user_with_points` SET `name`=\"jinzhu\",`location`=ST_PointFromText(\"POINT(100 100)\") WHERE `id` = 1 根据子查询进行更新 使用子查询更新表 db.Model(\u0026user).Update(\"company_name\", db.Model(\u0026Company{}).Select(\"name\").Where(\"companies.id = users.company_id\")) // UPDATE \"users\" SET \"company_name\" = (SELECT name FROM companies WHERE companies.id = users.company_id); db.Table(\"users as u\").Where(\"name = ?\", \"jinzhu\").Update(\"company_name\", db.Table(\"companies as c\").Select(\"name\").Where(\"c.id = u.company_id\")) // UPDATE \"users as u\" SET \"company_name\" = (SELECT name FROM companies as c WHERE c.id = u.company_id) WHERE name = \"jinzhu\" db.Table(\"users as u\").Where(\"name = ?\", \"jinzhu\").Updates(map[string]interface{}{}{\"company_name\": db.Table(\"companies as c\").Select(\"name\").Where(\"c.id = u.company_id\")}) 不使用 Hook 和时间追踪 如果您想在更新时跳过 Hook 方法且不追踪更新时间，可以使用 UpdateColumn、UpdateColumns，其用法类似于 Update、Updates // 更新单个列 db.Model(\u0026user).UpdateColumn(\"name\", \"hello\") // UPDATE users SET name='hello' WHERE id = 111; // 更新多个列 db.Model(\u0026user).UpdateColumns(User{Name: \"hello\", Age: 18}) // UPDATE users SET name='hello', age=18 WHERE id = 111; // 更新选中的列 db.Model(\u0026user).Select(\"name\", \"age\").UpdateColumns(User{Name: \"hello\", Age: 0}) // UPDATE users SET name='hello', age=0 WHERE id = 111; 返回修改行的数据 返回被修改的数据，仅适用于支持 Returning 的数据库，例如： // 返回所有列 var users []User DB.Model(\u0026users).Clauses(clause.Returning{}).Where(\"role = ?\", \"admin\").Update(\"salary\", gorm.Expr(\"salary * ?\", 2)) // UPDATE `users` SET `salary`=salary * 2,`updated_at`=\"2021-10-28 17:37:23.19\" WHERE role = \"admin\" RETURNING * // users =\u003e []User{{ID: 1, Name: \"jinzhu\", Role: \"admin\", Salary: 100}, {ID: 2, Name: \"jinzhu.2\", Role: \"admin\", Salary: 1000}} // 返回指定的列 DB.Model(\u0026users).Clauses(clause.Returning{Columns: []clause.Column{{Name: \"name\"}, {Name: \"salary\"}}}).Where(\"role = ?\", \"admin\").Update(\"salary\", gorm.Expr(\"salary * ?\", 2)) // UPDATE `users` SET `salary`=salary * 2,`updated_at`=\"2021-10-28 17:37:23.19\" WHERE role = \"admin\" RETURNING `name`, `salary` // users =\u003e []User{{ID: 0, Name: \"jinzhu\", Role: \"\", Salary: 100}, {ID: 0, Name: \"jinzhu.2\", Role: \"\", Salary: 1000}} 检查字段是否有变更 GORM 提供了 Changed 方法，它可以被用在 Before Update Hook 里，它会返回字段是否有变更的布尔值 Changed 方法只能与 Update、Updates 方法一起使用，并且它只是检查 Model 对象字段的值与 Update、Updates 的值是否相等，如果值有变更，且字段没有被忽略，则返回 true func (u *User) BeforeUpdate(tx *gorm.DB) (err error) { // 如果 Role 字段有变更 if tx.Statement.Changed(\"Role\") { return errors.New(\"role not allowed to change\") } if tx.Statement.Changed(\"Name\", \"Admin\") { // 如果 Name 或 Role 字段有变更 tx.Statement.SetColumn(\"Age\", 18) } // 如果任意字段有变更 if tx.Statement.Changed() { tx.Statement.SetColumn(\"RefreshedAt\", time.Now()) } return nil } db.Model(\u0026User{ID: 1, Name: \"jinzhu\"}).Updates(map[string]interface{\"name\": \"jinzhu2\"}) // Changed(\"Name\") =\u003e true db.Model(\u0026User{ID: 1, Name: \"jinzhu\"}","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:7:7","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"删除 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:8:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"删除一条记录 删除一条记录时，删除对象需要指定主键，否则会触发 批量 Delete，例如： // Email 的 ID 是 `10` db.Delete(\u0026email) // DELETE from emails where id = 10; // 带额外条件的删除 db.Where(\"name = ?\", \"jinzhu\").Delete(\u0026email) // DELETE from emails where id = 10 AND name = \"jinzhu\"; ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:8:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"根据主键删除 GORM 允许通过主键 (可以是复合主键) 和内联条件来删除对象，它可以使用数字（如以下例子。也可以使用字符串——译者注）。查看 查询-内联条件（Query Inline Conditions） 了解详情。 db.Delete(\u0026User{}, 10) // DELETE FROM users WHERE id = 10; db.Delete(\u0026User{}, \"10\") // DELETE FROM users WHERE id = 10; db.Delete(\u0026users, []int{1,2,3}) // DELETE FROM users WHERE id IN (1,2,3); ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:8:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Delete Hook 对于删除操作，GORM 支持 BeforeDelete、AfterDelete Hook，在删除记录时会调用这些方法，查看 Hook 获取详情 func (u *User) BeforeDelete(tx *gorm.DB) (err error) { if u.Role == \"admin\" { return errors.New(\"admin user not allowed to delete\") } return } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:8:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"批量删除 如果指定的值不包括主属性，那么 GORM 会执行批量删除，它将删除所有匹配的记录 db.Where(\"email LIKE ?\", \"%jinzhu%\").Delete(Email{}) // DELETE from emails where email LIKE \"%jinzhu%\"; db.Delete(Email{}, \"email LIKE ?\", \"%jinzhu%\") // DELETE from emails where email LIKE \"%jinzhu%\"; 阻止全局删除 如果在没有任何条件的情况下执行批量删除，GORM 不会执行该操作，并返回 ErrMissingWhereClause 错误 对此，你必须加一些条件，或者使用原生 SQL，或者启用 AllowGlobalUpdate 模式，例如： db.Delete(\u0026User{}).Error // gorm.ErrMissingWhereClause db.Where(\"1 = 1\").Delete(\u0026User{}) // DELETE FROM `users` WHERE 1=1 db.Exec(\"DELETE FROM users\") // DELETE FROM users db.Session(\u0026gorm.Session{AllowGlobalUpdate: true}).Delete(\u0026User{}) // DELETE FROM users 返回删除行的数据 返回被删除的数据，仅适用于支持 Returning 的数据库，例如： // 返回所有列 var users []User DB.Clauses(clause.Returning{}).Where(\"role = ?\", \"admin\").Delete(\u0026users) // DELETE FROM `users` WHERE role = \"admin\" RETURNING * // users =\u003e []User{{ID: 1, Name: \"jinzhu\", Role: \"admin\", Salary: 100}, {ID: 2, Name: \"jinzhu.2\", Role: \"admin\", Salary: 1000}} // 返回指定的列 DB.Clauses(clause.Returning{Columns: []clause.Column{{Name: \"name\"}, {Name: \"salary\"}}}).Where(\"role = ?\", \"admin\").Delete(\u0026users) // DELETE FROM `users` WHERE role = \"admin\" RETURNING `name`, `salary` // users =\u003e []User{{ID: 0, Name: \"jinzhu\", Role: \"\", Salary: 100}, {ID: 0, Name: \"jinzhu.2\", Role: \"\", Salary: 1000}} ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:8:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"软删除 如果您的模型包含了一个 gorm.deletedat 字段（gorm.Model 已经包含了该字段)，它将自动获得软删除的能力！ 拥有软删除能力的模型调用 Delete 时，记录不会被数据库。但 GORM 会将 DeletedAt 置为当前时间， 并且你不能再通过普通的查询方法找到该记录。 // user 的 ID 是 `111` db.Delete(\u0026user) // UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE id = 111; // 批量删除 db.Where(\"age = ?\", 20).Delete(\u0026User{}) // UPDATE users SET deleted_at=\"2013-10-29 10:23\" WHERE age = 20; // 在查询时会忽略被软删除的记录 db.Where(\"age = 20\").Find(\u0026user) // SELECT * FROM users WHERE age = 20 AND deleted_at IS NULL; 如果您不想引入 gorm.Model，您也可以这样启用软删除特性： type User struct { ID int Deleted gorm.DeletedAt Name string } 查找被软删除的记录 您可以使用 Unscoped 找到被软删除的记录 db.Unscoped().Where(\"age = 20\").Find(\u0026users) // SELECT * FROM users WHERE age = 20; 永久删除 您也可以使用 Unscoped 永久删除匹配的记录 db.Unscoped().Delete(\u0026order) // DELETE FROM orders WHERE id=10; Delete Flag 将 unix 时间戳作为 delete flag import \"gorm.io/plugin/soft_delete\" type User struct { ID uint Name string DeletedAt soft_delete.DeletedAt } // 查询 SELECT * FROM users WHERE deleted_at = 0; // 删除 UPDATE users SET deleted_at = /* current unix second */ WHERE ID = 1; INFO 在配合 unique 字段使用软删除时，您需要使用这个基于 unix 时间戳的 DeletedAt 字段创建一个复合索引，例如： import \"gorm.io/plugin/soft_delete\" type User struct { ID uint Name string `gorm:\"uniqueIndex:udx_name\"` DeletedAt soft_delete.DeletedAt `gorm:\"uniqueIndex:udx_name\"` } 使用 1 / 0 作为 delete flag import \"gorm.io/plugin/soft_delete\" type User struct { ID uint Name string IsDel soft_delete.DeletedAt `gorm:\"softDelete:flag\"` } // 查询 SELECT * FROM users WHERE is_del = 0; // 删除 UPDATE users SET is_del = 1 WHERE ID = 1; ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:8:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"关联 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Belongs to belongs to 会与另一个模型建立了一对一的连接。 这种模型的每一个实例都“属于”另一个模型的一个实例。 例如，您的应用包含 user 和 company，并且每个 user 能且只能被分配给一个 company。下面的类型就表示这种关系。 注意，在 User 对象中，有一个和 Company 一样的 CompanyID。 默认情况下， CompanyID 被隐含地用来在 User 和 Company 之间创建一个外键关系， 因此必须包含在 User 结构体中才能填充 Company 内部结构体。 // `User` 属于 `Company`，`CompanyID` 是外键 type User struct { gorm.Model Name string CompanyID int Company Company } type Company struct { ID int Name string } 重写外键 要定义一个 belongs to 关系，数据库的表中必须存在外键。 默认情况下，外键的名字，使用拥有者的类型名称加上表的主键的字段名字 例如，定义一个 User 实体属于 Company 实体，那么外键的名字一般使用 CompanyID。 GORM 同时提供自定义外键名字的方式，如下例所示。 type User struct { gorm.Model Name string CompanyRefer int Company Company `gorm:\"foreignKey:CompanyRefer\"` // 使用 CompanyRefer 作为外键 } type Company struct { ID int Name string } 重写引用 对于 belongs to 关系，GORM 通常使用数据库表，主表（拥有者）的主键值作为外键参考。 正如上面的例子，我们使用主表 Company 中的主键字段 ID 作为外键的参考值。 如果在 Company 实体中设置了 User 实体，那么 GORM 会自动把 Company 中的 ID 属性保存到 User 的 CompanyID 属性中。 同样的，您也可以使用标签 references 来更改它，例如： type User struct { gorm.Model Name string CompanyID string Company Company `gorm:\"references:Code\"` // 使用 Code 作为引用 } type Company struct { ID int Code string Name string } 外键约束 你可以通过 OnUpdate, OnDelete 配置标签来增加关联关系的级联操作，如下面的例子，通过 GORM 可以完成用户和公司的级联更新和级联删除操作： type User struct { gorm.Model Name string CompanyID int Company Company `gorm:\"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type Company struct { ID int Name string } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Has One has one 与另一个模型建立一对一的关联，但它和一对一关系有些许不同。 这种关联表明一个模型的每个实例都包含或拥有另一个模型的一个实例。 例如，您的应用包含 user 和 credit card 模型，且每个 user 只能有一张 credit card。 // User 有一张 CreditCard，UserID 是外键 type User struct { gorm.Model CreditCard CreditCard } type CreditCard struct { gorm.Model Number string UserID uint } 重写外键 对于 has one 关系，同样必须存在外键字段。拥有者将把属于它的模型的主键保存到这个字段。 这个字段的名称通常由 has one 模型的类型加上其 主键 生成，对于上面的例子，它是 UserID。 为 user 添加 credit card 时，它会将 user 的 ID 保存到自己的 UserID 字段。 如果你想要使用另一个字段来保存该关系，你同样可以使用标签 foreignKey 来更改它，例如： type User struct { gorm.Model CreditCard CreditCard `gorm:\"foreignKey:UserName\"` // 使用 UserName 作为外键 } type CreditCard struct { gorm.Model Number string UserName string } 重写引用 默认情况下，拥有者实体会将 has one 对应模型的主键保存为外键，您也可以修改它，用另一个字段来保存，例如下个这个使用 Name 来保存的例子。 您可以使用标签 references 来更改它，例如： type User struct { gorm.Model Name string `gorm:\"index\"` CreditCard CreditCard `gorm:\"foreignkey:UserName;references:name\"` } type CreditCard struct { gorm.Model Number string UserName string } 多态关联 GORM 为 has one 和 has many 提供了多态关联支持，它会将拥有者实体的表名、主键值都保存到多态类型的字段中。 type Cat struct { ID int Name string Toy Toy `gorm:\"polymorphic:Owner;\"` } type Dog struct { ID int Name string Toy Toy `gorm:\"polymorphic:Owner;\"` } type Toy struct { ID int Name string OwnerID int OwnerType string } db.Create(\u0026Dog{Name: \"dog1\", Toy: Toy{Name: \"toy1\"}}) // INSERT INTO `dogs` (`name`) VALUES (\"dog1\") // INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (\"toy1\",\"1\",\"dogs\") 您可以使用标签 polymorphicValue 来更改多态类型的值，例如： type Dog struct { ID int Name string Toy Toy `gorm:\"polymorphic:Owner;polymorphicValue:master\"` } type Toy struct { ID int Name string OwnerID int OwnerType string } db.Create(\u0026Dog{Name: \"dog1\", Toy: Toy{Name: \"toy1\"}}) // INSERT INTO `dogs` (`name`) VALUES (\"dog1\") // INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (\"toy1\",\"1\",\"master\") 自引用 Has One type User struct { gorm.Model Name string ManagerID *uint Manager *User } 外键约束 你可以通过为标签 constraint 配置 OnUpdate、OnDelete 实现外键约束，在使用 GORM 进行迁移时它会被创建，例如： type User struct { gorm.Model CreditCard CreditCard `gorm:\"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type CreditCard struct { gorm.Model Number string UserID uint } 你也可以在删除记录时通过 Select 来删除关联的记录 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Has Many has many 与另一个模型建立了一对多的连接。 不同于 has one，拥有者可以有零或多个关联模型。 例如，您的应用包含 user 和 credit card 模型，且每个 user 可以有多张 credit card。 // User 有多张 CreditCard，UserID 是外键 type User struct { gorm.Model CreditCards []CreditCard } type CreditCard struct { gorm.Model Number string UserID uint } 重写外键 要定义 has many 关系，同样必须存在外键。 默认的外键名是拥有者的类型名加上其主键字段名 例如，要定义一个属于 User 的模型，则其外键应该是 UserID。 此外，想要使用另一个字段作为外键，您可以使用 foreignKey 标签自定义它： type User struct { gorm.Model CreditCards []CreditCard `gorm:\"foreignKey:UserRefer\"` } type CreditCard struct { gorm.Model Number string UserRefer uint } 重写引用 GORM 通常使用拥有者的主键作为外键的值。 对于上面的例子，它是 User 的 ID 字段。 为 user 添加 credit card 时，GORM 会将 user 的 ID 字段保存到 credit card 的 UserID 字段。 同样的，您也可以使用标签 references 来更改它，例如： type User struct { gorm.Model MemberNumber string CreditCards []CreditCard `gorm:\"foreignKey:UserNumber;references:MemberNumber\"` } type CreditCard struct { gorm.Model Number string UserNumber string } 多态关联 GORM 为 has one 和 has many 提供了多态关联支持，它会将拥有者实体的表名、主键都保存到多态类型的字段中。 type Dog struct { ID int Name string Toys []Toy `gorm:\"polymorphic:Owner;\"` } type Toy struct { ID int Name string OwnerID int OwnerType string } db.Create(\u0026Dog{Name: \"dog1\", Toys: []Toy{{Name: \"toy1\"}, {Name: \"toy2\"}}}) // INSERT INTO `dogs` (`name`) VALUES (\"dog1\") // INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (\"toy1\",\"1\",\"dogs\"), (\"toy2\",\"1\",\"dogs\") 您可以使用标签 polymorphicValue 来更改多态类型的值，例如： type Dog struct { ID int Name string Toys []Toy `gorm:\"polymorphic:Owner;polymorphicValue:master\"` } type Toy struct { ID int Name string OwnerID int OwnerType string } db.Create(\u0026Dog{Name: \"dog1\", Toys: []Toy{{Name: \"toy1\"}, {Name: \"toy2\"}}}) // INSERT INTO `dogs` (`name`) VALUES (\"dog1\") // INSERT INTO `toys` (`name`,`owner_id`,`owner_type`) VALUES (\"toy1\",\"1\",\"master\"), (\"toy2\",\"1\",\"master\") 自引用 Has Many type User struct { gorm.Model Name string ManagerID *uint Team []User `gorm:\"foreignkey:ManagerID\"` } 外键约束 你可以通过为标签 constraint 配置 OnUpdate、OnDelete 实现外键约束，在使用 GORM 进行迁移时它会被创建，例如： type User struct { gorm.Model CreditCards []CreditCard `gorm:\"constraint:OnUpdate:CASCADE,OnDelete:SET NULL;\"` } type CreditCard struct { gorm.Model Number string UserID uint } 你也可以在删除记录时通过 Select 来删除 has many 关联的记录 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Many To Many Many to Many 会在两个 model 中添加一张连接表。 例如，您的应用包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language。 // User 拥有并属于多种 language，`user_languages` 是连接表 type User struct { gorm.Model Languages []Language `gorm:\"many2many:user_languages;\"` } type Language struct { gorm.Model Name string } 当使用 GORM 的 AutoMigrate 为 User 创建表时，GORM 会自动创建连接表 反向引用 // User 拥有并属于多种 language，`user_languages` 是连接表 type User struct { gorm.Model Languages []*Language `gorm:\"many2many:user_languages;\"` } type Language struct { gorm.Model Name string Users []*User `gorm:\"many2many:user_languages;\"` } 重写外键 对于 many2many 关系，连接表会同时拥有两个模型的外键，例如： type User struct { gorm.Model Languages []Language `gorm:\"many2many:user_languages;\"` } type Language struct { gorm.Model Name string } // 连接表：user_languages // foreign key: user_id, reference: users.id // foreign key: language_id, reference: languages.id 若要重写它们，可以使用标签 foreignKey、references、joinforeignKey、joinReferences。当然，您不需要使用全部的标签，你可以仅使用其中的一个重写部分的外键、引用。 type User struct { gorm.Model Profiles []Profile `gorm:\"many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer\"` Refer uint `gorm:\"index:,unique\"` } type Profile struct { gorm.Model Name string UserRefer uint `gorm:\"index:,unique\"` } // 会创建连接表：user_profiles // foreign key: user_refer_id, reference: users.refer // foreign key: profile_refer, reference: profiles.user_refer 注意： 某些数据库只允许在唯一索引字段上创建外键，如果您在迁移时会创建外键，则需要指定 unique index 标签。 自引用 Many2Many 自引用 many2many 关系 type User struct { gorm.Model Friends []*User `gorm:\"many2many:user_friends\"` } // 会创建连接表：user_friends // foreign key: user_id, reference: users.id // foreign key: friend_id, reference: users.id 自定义连接表 连接表 可以是一个全功能的模型，支持 Soft Delete、钩子、更多的字段，就跟其它模型一样。您可以通过 SetupJoinTable 指定它，例如： 注意： 自定义连接表要求外键是复合主键或复合唯一索引 type Person struct { ID int Name string Addresses []Address `gorm:\"many2many:person_addresses;\"` } type Address struct { ID uint Name string } type PersonAddress struct { PersonID int `gorm:\"primaryKey\"` AddressID int `gorm:\"primaryKey\"` CreatedAt time.Time DeletedAt gorm.DeletedAt } func (PersonAddress) BeforeCreate(db *gorm.DB) error { // ... } // 修改 Person 的 Addresses 字段的连接表为 PersonAddress // PersonAddress 必须定义好所需的外键，否则会报错 err := db.SetupJoinTable(\u0026Person{}, \"Addresses\", \u0026PersonAddress{}) 外键约束 你可以通过为标签 constraint 配置 OnUpdate、OnDelete 实现外键约束，在使用 GORM 进行迁移时它会被创建，例如： type User struct { gorm.Model Languages []Language `gorm:\"many2many:user_speaks;\"` } type Language struct { Code string `gorm:\"primarykey\"` Name string } // CREATE TABLE `user_speaks` (`user_id` integer,`language_code` text,PRIMARY KEY (`user_id`,`language_code`),CONSTRAINT `fk_user_speaks_user` FOREIGN KEY (`user_id`) REFERENCES `users`(`id`) ON DELETE SET NULL ON UPDATE CASCADE,CONSTRAINT `fk_user_speaks_language` FOREIGN KEY (`language_code`) REFERENCES `languages`(`code`) ON DELETE SET NULL ON UPDATE CASCADE); 你也可以在删除记录时通过 Select 来删除 many2many 关系的记录，查看 Delete with Select 获取详情 复合外键 如果您的模型使用了 复合主键，GORM 会默认启用复合外键。 您也可以覆盖默认的外键、指定多个外键，只需用逗号分隔那些键名，例如： type Tag struct { ID uint `gorm:\"primaryKey\"` Locale string `gorm:\"primaryKey\"` Value string } type Blog struct { ID uint `gorm:\"primaryKey\"` Locale string `gorm:\"primaryKey\"` Subject string Body string Tags []Tag `gorm:\"many2many:blog_tags;\"` LocaleTags []Tag `gorm:\"many2many:locale_blog_tags;ForeignKey:id,locale;References:id\"` SharedTags []Tag `gorm:\"many2many:shared_blog_tags;ForeignKey:id;References:id\"` } // 连接表：blog_tags // foreign key: blog_id, reference: blogs.id // foreign key: blog_locale, reference: blogs.locale // foreign key: tag_id, reference: tags.id // foreign key: tag_locale, reference: tags.locale // 连接表：locale_blog_tags // foreign key: blog_id, reference: blogs.id // foreign key: blog_locale, reference: blogs.locale // foreign key: tag_id, reference: tags.id // 连接表：shared_blog_tags // foreign key: blog_id, reference: blogs.id // foreign key: tag_id, reference: tags.id ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"关联模式 自动创建、更新 在创建、更新记录时，GORM 会通过 Upsert 自动保存关联及其引用记录。 user := User{ Name: \"jinzhu\", BillingAddress: Address{Address1: \"Billing Address - Address 1\"}, ShippingAddress: Address{Address1: \"Shipping Address - Address 1\"}, Emails: []Email{ {Email: \"jinzhu@example.com\"}, {Email: \"jinzhu-2@example.com\"}, }, Languages: []Language{ {Name: \"ZH\"}, {Name: \"EN\"}, }, } db.Create(\u0026user) // BEGIN TRANSACTION; // INSERT INTO \"addresses\" (address1) VALUES (\"Billing Address - Address 1\"), (\"Shipping Address - Address 1\") ON DUPLICATE KEY DO NOTHING; // INSERT INTO \"users\" (name,billing_address_id,shipping_address_id) VALUES (\"jinzhu\", 1, 2); // INSERT INTO \"emails\" (user_id,email) VALUES (111, \"jinzhu@example.com\"), (111, \"jinzhu-2@example.com\") ON DUPLICATE KEY DO NOTHING; // INSERT INTO \"languages\" (\"name\") VALUES ('ZH'), ('EN') ON DUPLICATE KEY DO NOTHING; // INSERT INTO \"user_languages\" (\"user_id\",\"language_id\") VALUES (111, 1), (111, 2) ON DUPLICATE KEY DO NOTHING; // COMMIT; db.Save(\u0026user) 如果您想要更新关联的数据，您应该使用 FullSaveAssociations 模式： db.Session(\u0026gorm.Session{FullSaveAssociations: true}).Updates(\u0026user) // ... // INSERT INTO \"addresses\" (address1) VALUES (\"Billing Address - Address 1\"), (\"Shipping Address - Address 1\") ON DUPLICATE KEY SET address1=VALUES(address1); // INSERT INTO \"users\" (name,billing_address_id,shipping_address_id) VALUES (\"jinzhu\", 1, 2); // INSERT INTO \"emails\" (user_id,email) VALUES (111, \"jinzhu@example.com\"), (111, \"jinzhu-2@example.com\") ON DUPLICATE KEY SET email=VALUES(email); // ... 跳过自动创建、更新 若要在创建、更新时跳过自动保存，您可以使用 Select 或 Omit，例如： user := User{ Name: \"jinzhu\", BillingAddress: Address{Address1: \"Billing Address - Address 1\"}, ShippingAddress: Address{Address1: \"Shipping Address - Address 1\"}, Emails: []Email{ {Email: \"jinzhu@example.com\"}, {Email: \"jinzhu-2@example.com\"}, }, Languages: []Language{ {Name: \"ZH\"}, {Name: \"EN\"}, }, } db.Select(\"Name\").Create(\u0026user) // INSERT INTO \"users\" (name) VALUES (\"jinzhu\", 1, 2); db.Omit(\"BillingAddress\").Create(\u0026user) // Skip create BillingAddress when creating a user db.Omit(clause.Associations).Create(\u0026user) // Skip all associations when creating a user NOTE: 对于 many2many 关联，GORM 在创建连接表引用之前，会先 upsert 关联。如果你想跳过关联的 upsert，你可以这样做： db.Omit(\"Languages.*\").Create(\u0026user) 下面的代码将跳过创建关联及其引用 db.Omit(\"Languages\").Create(\u0026user) Select/Omit 关联字段 user := User{ Name: \"jinzhu\", BillingAddress: Address{Address1: \"Billing Address - Address 1\", Address2: \"addr2\"}, ShippingAddress: Address{Address1: \"Shipping Address - Address 1\", Address2: \"addr2\"}, } // 创建 user 及其 BillingAddress、ShippingAddress // 在创建 BillingAddress 时，仅使用其 address1、address2 字段，忽略其它字段 db.Select(\"BillingAddress.Address1\", \"BillingAddress.Address2\").Create(\u0026user) db.Omit(\"BillingAddress.Address2\", \"BillingAddress.CreatedAt\").Create(\u0026user) 关联模式 关联模式包含一些在处理关系时有用的方法 // 开始关联模式 var user User db.Model(\u0026user).Association(\"Languages\") // `user` 是源模型，它的主键不能为空 // 关系的字段名是 `Languages` // 如果匹配了上面两个要求，会开始关联模式，否则会返回错误 db.Model(\u0026user).Association(\"Languages\").Error 查找关联 查找所有匹配的关联记录 db.Model(\u0026user).Association(\"Languages\").Find(\u0026languages) 查找带条件的关联 select*fromcoursesasc,selectionsasscwheresc.student_id=1andc.id=sc.co codes := []string{\"zh-CN\", \"en-US\", \"ja-JP\"} db.Model(\u0026user).Where(\"code IN ?\", codes).Association(\"Languages\").Find(\u0026languages) db.Model(\u0026user).Where(\"code IN ?\", codes).Order(\"code desc\").Association(\"Languages\").Find(\u0026languages) 添加关联 为 many to many、has many 添加新的关联；为 has one, belongs to 替换当前的关联 db.Model(\u0026user).Association(\"Languages\").Append([]Language{languageZH, languageEN}) db.Model(\u0026user).Association(\"Languages\").Append(\u0026Language{Name: \"DE\"}) db.Model(\u0026user).Association(\"CreditCard\").Append(\u0026CreditCard{Number: \"411111111111\"}) 替换关联 用一个新的关联替换当前的关联 db.Model(\u0026user).Association(\"Languages\").Replace([]Language{languageZH, languageEN}) db.Model(\u0026user).Association(\"Languages\").Replace(Language{Name: \"DE\"}, languageEN) 删除关联 如果存在，则删除源模型与参数之间的关系，只会删除引用，不会从数据库中删除这些对象。 db.Model(\u0026user).Association(\"Languages\").Delete([]Language{languageZH, lan","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"预加载 GORM 允许在 Preload 的其它 SQL 中直接加载关系，例如： type User struct { gorm.Model Username string Orders []Order } type Order struct { gorm.Model UserID uint Price float64 } // 查找 user 时预加载相关 Order db.Preload(\"Orders\").Find(\u0026users) // SELECT * FROM users; // SELECT * FROM orders WHERE user_id IN (1,2,3,4); db.Preload(\"Orders\").Preload(\"Profile\").Preload(\"Role\").Find(\u0026users) // SELECT * FROM users; // SELECT * FROM orders WHERE user_id IN (1,2,3,4); // has many // SELECT * FROM profiles WHERE user_id IN (1,2,3,4); // has one // SELECT * FROM roles WHERE id IN (4,5,6); // belongs to Joins 预加载 Preload 在一个单独查询中加载关联数据。而 Join Preload 会使用 inner join 加载关联数据，例如： db.Joins(\"Company\").Joins(\"Manager\").Joins(\"Account\").First(\u0026user, 1) db.Joins(\"Company\").Joins(\"Manager\").Joins(\"Account\").First(\u0026user, \"users.name = ?\", \"jinzhu\") db.Joins(\"Company\").Joins(\"Manager\").Joins(\"Account\").Find(\u0026users, \"users.id IN ?\", []int{1,2,3,4,5}) 带条件的 Join db.Joins(\"Company\", DB.Where(\u0026Company{Alive: true})).Find(\u0026users) // SELECT `users`.`id`,`users`.`name`,`users`.`age`,`Company`.`id` AS `Company__id`,`Company`.`name` AS `Company__name` FROM `users` LEFT JOIN `companies` AS `Company` ON `users`.`company_id` = `Company`.`id` AND `Company`.`alive` = true; 注意 Join Preload 适用于一对一的关系，例如： has one, belongs to 预加载全部 与创建、更新时使用 Select 类似，clause.Associations 也可以和 Preload 一起使用，它可以用来 预加载 全部关联，例如： type User struct { gorm.Model Name string CompanyID uint Company Company Role Role Orders []Order } db.Preload(clause.Associations).Find(\u0026users) clause.Associations 不会预加载嵌套的关联，但你可以使用嵌套预加载 例如： db.Preload(\"Orders.OrderItems.Product\").Preload(clause.Associations).Find(\u0026users) 带条件的预加载 GORM 允许带条件的 Preload 关联，类似于内联条件 // 带条件的预加载 Order db.Preload(\"Orders\", \"state NOT IN (?)\", \"cancelled\").Find(\u0026users) // SELECT * FROM users; // SELECT * FROM orders WHERE user_id IN (1,2,3,4) AND state NOT IN ('cancelled'); db.Where(\"state = ?\", \"active\").Preload(\"Orders\", \"state NOT IN (?)\", \"cancelled\").Find(\u0026users) // SELECT * FROM users WHERE state = 'active'; // SELECT * FROM orders WHERE user_id IN (1,2) AND state NOT IN ('cancelled'); 自定义预加载 SQL 您可以通过 func(db *gorm.DB) *gorm.DB 实现自定义预加载 SQL，例如： db.Preload(\"Orders\", func(db *gorm.DB) *gorm.DB { return db.Order(\"orders.amount DESC\") }).Find(\u0026users) // SELECT * FROM users; // SELECT * FROM orders WHERE user_id IN (1,2,3,4) order by orders.amount DESC; 嵌套预加载 GORM 支持嵌套预加载，例如： db.Preload(\"Orders.OrderItems.Product\").Preload(\"CreditCard\").Find(\u0026users) // 自定义预加载 `Orders` 的条件 // 这样，GORM 就不会加载不匹配的 order 记录 db.Preload(\"Orders\", \"state = ?\", \"paid\").Preload(\"Orders.OrderItems\").Find(\u0026users) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:9:6","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"高级查询 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:0","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"智能选择字段 GORM 允许通过 Select 方法选择特定的字段，如果您在应用程序中经常使用此功能，你也可以定义一个较小的结构体，以实现调用 API 时自动选择特定的字段，例如： type User struct { ID uint Name string Age int Gender string // 假设后面还有几百个字段... } type APIUser struct { ID uint Name string } // 查询时会自动选择 `id`, `name` 字段 db.Model(\u0026User{}).Limit(10).Find(\u0026APIUser{}) // SELECT `id`, `name` FROM `users` LIMIT 10 注意 QueryFields 模式会根据当前 model 的所有字段名称进行 select。 db, err := gorm.Open(sqlite.Open(\"gorm.db\"), \u0026gorm.Config{ QueryFields: true, }) db.Find(\u0026user) // SELECT `users`.`name`, `users`.`age`, ... FROM `users` // 带上这个选项 // Session Mode db.Session(\u0026gorm.Session{QueryFields: true}).Find(\u0026user) // SELECT `users`.`name`, `users`.`age`, ... FROM `users` ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:1","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Locking (FOR UPDATE) GORM 支持多种类型的锁，例如： db.Clauses(clause.Locking{Strength: \"UPDATE\"}).Find(\u0026users) // SELECT * FROM `users` FOR UPDATE db.Clauses(clause.Locking{ Strength: \"SHARE\", Table: clause.Table{Name: clause.CurrentTable}, }).Find(\u0026users) // SELECT * FROM `users` FOR SHARE OF `users` db.Clauses(clause.Locking{ Strength: \"UPDATE\", Options: \"NOWAIT\", }).Find(\u0026users) // SELECT * FROM `users` FOR UPDATE NOWAIT 查看 原生 SQL 及构造器 获取详情 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:2","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"子查询 子查询可以嵌套在查询中，GORM 允许在使用 *gorm.DB 对象作为参数时生成子查询 db.Where(\"amount \u003e (?)\", db.Table(\"orders\").Select(\"AVG(amount)\")).Find(\u0026orders) // SELECT * FROM \"orders\" WHERE amount \u003e (SELECT AVG(amount) FROM \"orders\"); subQuery := db.Select(\"AVG(age)\").Where(\"name LIKE ?\", \"name%\").Table(\"users\") db.Select(\"AVG(age) as avgage\").Group(\"name\").Having(\"AVG(age) \u003e (?)\", subQuery).Find(\u0026results) // SELECT AVG(age) as avgage FROM `users` GROUP BY `name` HAVING AVG(age) \u003e (SELECT AVG(age) FROM `users` WHERE name LIKE \"name%\") ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:3","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"From 子查询 GORM 允许您在 Table 方法中通过 FROM 子句使用子查询，例如： db.Table(\"(?) as u\", db.Model(\u0026User{}).Select(\"name\", \"age\")).Where(\"age = ?\", 18}).Find(\u0026User{}) // SELECT * FROM (SELECT `name`,`age` FROM `users`) as u WHERE `age` = 18 subQuery1 := db.Model(\u0026User{}).Select(\"name\") subQuery2 := db.Model(\u0026Pet{}).Select(\"name\") db.Table(\"(?) as u, (?) as p\", subQuery1, subQuery2).Find(\u0026User{}) // SELECT * FROM (SELECT `name` FROM `users`) as u, (SELECT `name` FROM `pets`) as p ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:4","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Group 条件 使用 Group 条件可以更轻松的编写复杂 SQL db.Where( db.Where(\"pizza = ?\", \"pepperoni\").Where(db.Where(\"size = ?\", \"small\").Or(\"size = ?\", \"medium\")), ).Or( db.Where(\"pizza = ?\", \"hawaiian\").Where(\"size = ?\", \"xlarge\"), ).Find(\u0026Pizza{}).Statement // SELECT * FROM `pizzas` WHERE (pizza = \"pepperoni\" AND (size = \"small\" OR size = \"medium\")) OR (pizza = \"hawaiian\" AND size = \"xlarge\") ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:5","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"带多个列的 in 带多个列的 in 查询 db.Where(\"(name, age, role) IN ?\", [][]interface{}{{\"jinzhu\", 18, \"admin\"}, {\"jinzhu2\", 19, \"user\"}}).Find(\u0026users) // SELECT * FROM users WHERE (name, age, role) IN ((\"jinzhu\", 18, \"admin\"), (\"jinzhu 2\", 19, \"user\")); ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:6","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"命名参数 GORM 支持 sql.NamedArg 和 map[string]interface{}{} 形式的命名参数，例如： db.Where(\"name1 = @name OR name2 = @name\", sql.Named(\"name\", \"jinzhu\")).Find(\u0026user) // SELECT * FROM `users` WHERE name1 = \"jinzhu\" OR name2 = \"jinzhu\" db.Where(\"name1 = @name OR name2 = @name\", map[string]interface{}{\"name\": \"jinzhu\"}).First(\u0026user) // SELECT * FROM `users` WHERE name1 = \"jinzhu\" OR name2 = \"jinzhu\" ORDER BY `users`.`id` LIMIT 1 查看 原生 SQL 及构造器 获取详情 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:7","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Find 至 map GORM 允许扫描结果至 map[string]interface{} 或 []map[string]interface{}，此时别忘了指定 Model 或 Table，例如： result := map[string]interface{}{} db.Model(\u0026User{}).First(\u0026result, \"id = ?\", 1) var results []map[string]interface{} db.Table(\"users\").Find(\u0026results) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:8","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"FirstOrInit 获取第一条匹配的记录，或者根据给定的条件初始化一个实例（仅支持 sturct 和 map 条件） // 未找到 user，则根据给定的条件初始化一条记录 db.FirstOrInit(\u0026user, User{Name: \"non_existing\"}) // user -\u003e User{Name: \"non_existing\"} // 找到了 `name` = `jinzhu` 的 user db.Where(User{Name: \"jinzhu\"}).FirstOrInit(\u0026user) // user -\u003e User{ID: 111, Name: \"Jinzhu\", Age: 18} // 找到了 `name` = `jinzhu` 的 user db.FirstOrInit(\u0026user, map[string]interface{}{\"name\": \"jinzhu\"}) // user -\u003e User{ID: 111, Name: \"Jinzhu\", Age: 18} 如果没有找到记录，可以使用包含更多的属性的结构体初始化 user，Attrs 不会被用于生成查询 SQL // 未找到 user，则根据给定的条件以及 Attrs 初始化 user db.Where(User{Name: \"non_existing\"}).Attrs(User{Age: 20}).FirstOrInit(\u0026user) // SELECT * FROM USERS WHERE name = 'non_existing' ORDER BY id LIMIT 1; // user -\u003e User{Name: \"non_existing\", Age: 20} // 未找到 user，则根据给定的条件以及 Attrs 初始化 user db.Where(User{Name: \"non_existing\"}).Attrs(\"age\", 20).FirstOrInit(\u0026user) // SELECT * FROM USERS WHERE name = 'non_existing' ORDER BY id LIMIT 1; // user -\u003e User{Name: \"non_existing\", Age: 20} // 找到了 `name` = `jinzhu` 的 user，则忽略 Attrs db.Where(User{Name: \"Jinzhu\"}).Attrs(User{Age: 20}).FirstOrInit(\u0026user) // SELECT * FROM USERS WHERE name = jinzhu' ORDER BY id LIMIT 1; // user -\u003e User{ID: 111, Name: \"Jinzhu\", Age: 18} 不管是否找到记录，Assign 都会将属性赋值给 struct，但这些属性不会被用于生成查询 SQL，也不会被保存到数据库 // 未找到 user，根据条件和 Assign 属性初始化 struct db.Where(User{Name: \"non_existing\"}).Assign(User{Age: 20}).FirstOrInit(\u0026user) // user -\u003e User{Name: \"non_existing\", Age: 20} // 找到 `name` = `jinzhu` 的记录，依然会更新 Assign 相关的属性 db.Where(User{Name: \"Jinzhu\"}).Assign(User{Age: 20}).FirstOrInit(\u0026user) // SELECT * FROM USERS WHERE name = jinzhu' ORDER BY id LIMIT 1; // user -\u003e User{ID: 111, Name: \"Jinzhu\", Age: 20} ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:9","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"FirstOrCreate 获取第一条匹配的记录，或者根据给定的条件创建一条新纪录（仅支持 sturct 和 map 条件） // 未找到 user，则根据给定条件创建一条新纪录 db.FirstOrCreate(\u0026user, User{Name: \"non_existing\"}) // INSERT INTO \"users\" (name) VALUES (\"non_existing\"); // user -\u003e User{ID: 112, Name: \"non_existing\"} // 找到了 `name` = `jinzhu` 的 user db.Where(User{Name: \"jinzhu\"}).FirstOrCreate(\u0026user) // user -\u003e User{ID: 111, Name: \"jinzhu\", \"Age\": 18} 如果没有找到记录，可以使用包含更多的属性的结构体创建记录，Attrs 不会被用于生成查询 SQL 。 // 未找到 user，根据条件和 Assign 属性创建记录 db.Where(User{Name: \"non_existing\"}).Attrs(User{Age: 20}).FirstOrCreate(\u0026user) // SELECT * FROM users WHERE name = 'non_existing' ORDER BY id LIMIT 1; // INSERT INTO \"users\" (name, age) VALUES (\"non_existing\", 20); // user -\u003e User{ID: 112, Name: \"non_existing\", Age: 20} // 找到了 `name` = `jinzhu` 的 user，则忽略 Attrs db.Where(User{Name: \"jinzhu\"}).Attrs(User{Age: 20}).FirstOrCreate(\u0026user) // SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1; // user -\u003e User{ID: 111, Name: \"jinzhu\", Age: 18} 不管是否找到记录，Assign 都会将属性赋值给 struct，并将结果写回数据库 // 未找到 user，根据条件和 Assign 属性创建记录 db.Where(User{Name: \"non_existing\"}).Assign(User{Age: 20}).FirstOrCreate(\u0026user) // SELECT * FROM users WHERE name = 'non_existing' ORDER BY id LIMIT 1; // INSERT INTO \"users\" (name, age) VALUES (\"non_existing\", 20); // user -\u003e User{ID: 112, Name: \"non_existing\", Age: 20} // 找到了 `name` = `jinzhu` 的 user，依然会根据 Assign 更新记录 db.Where(User{Name: \"jinzhu\"}).Assign(User{Age: 20}).FirstOrCreate(\u0026user) // SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1; // UPDATE users SET age=20 WHERE id = 111; // user -\u003e User{ID: 111, Name: \"jinzhu\", Age: 20} ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:10","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"优化器、索引提示 优化器提示用于控制查询优化器选择某个查询执行计划，GORM 通过 gorm.io/hints 提供支持，例如： import \"gorm.io/hints\" db.Clauses(hints.New(\"MAX_EXECUTION_TIME(10000)\")).Find(\u0026User{}) // SELECT * /*+ MAX_EXECUTION_TIME(10000) */ FROM `users` 索引提示允许传递索引提示到数据库，以防查询计划器出现混乱。 import \"gorm.io/hints\" db.Clauses(hints.UseIndex(\"idx_user_name\")).Find(\u0026User{}) // SELECT * FROM `users` USE INDEX (`idx_user_name`) db.Clauses(hints.ForceIndex(\"idx_user_name\", \"idx_user_id\").ForJoin()).Find(\u0026User{}) // SELECT * FROM `users` FORCE INDEX FOR JOIN (`idx_user_name`,`idx_user_id`)\" 参考 优化器提示、索引、备注 获取详情 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:11","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"迭代 GORM 支持通过行进行迭代 rows, err := db.Model(\u0026User{}).Where(\"name = ?\", \"jinzhu\").Rows() defer rows.Close() for rows.Next() { var user User // ScanRows 方法用于将一行记录扫描至结构体 db.ScanRows(rows, \u0026user) // 业务逻辑... } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:12","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"FindInBatches 用于批量查询并处理记录 // 每次批量处理 100 条 result := db.Where(\"processed = ?\", false).FindInBatches(\u0026results, 100, func(tx *gorm.DB, batch int) error { for _, result := range results { // 批量处理找到的记录 } tx.Save(\u0026results) tx.RowsAffected // 本次批量操作影响的记录数 batch // Batch 1, 2, 3 // 如果返回错误会终止后续批量操作 return nil }) result.Error // returned error result.RowsAffected // 整个批量操作影响的记录数 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:13","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"查询钩子 对于查询操作，GORM 支持 AfterFind 钩子，查询记录后会调用它，详情请参考 钩子 func (u *User) AfterFind(tx *gorm.DB) (err error) { if u.Role == \"\" { u.Role = \"user\" } return } ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:14","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Pluck Pluck 用于从数据库查询单个列，并将结果扫描到切片。如果您想要查询多列，您应该使用 Select 和 Scan var ages []int64 db.Model(\u0026users).Pluck(\"age\", \u0026ages) var names []string db.Model(\u0026User{}).Pluck(\"name\", \u0026names) db.Table(\"deleted_users\").Pluck(\"name\", \u0026names) // Distinct Pluck db.Model(\u0026User{}).Distinct().Pluck(\"Name\", \u0026names) // SELECT DISTINCT `name` FROM `users` // 超过一列的查询，应该使用 `Scan` 或者 `Find`，例如： db.Select(\"name\", \"age\").Scan(\u0026users) db.Select(\"name\", \"age\").Find(\u0026users) ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:15","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Scope Scopes 允许你指定常用的查询，可以在调用方法时引用这些查询 func AmountGreaterThan1000(db *gorm.DB) *gorm.DB { return db.Where(\"amount \u003e ?\", 1000) } func PaidWithCreditCard(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } func PaidWithCod(db *gorm.DB) *gorm.DB { return db.Where(\"pay_mode_sign = ?\", \"C\") } func OrderStatus(status []string) func (db *gorm.DB) *gorm.DB { return func (db *gorm.DB) *gorm.DB { return db.Where(\"status IN (?)\", status) } } db.Scopes(AmountGreaterThan1000, PaidWithCreditCard).Find(\u0026orders) // 查找所有金额大于 1000 的信用卡订单 db.Scopes(AmountGreaterThan1000, PaidWithCod).Find(\u0026orders) // 查找所有金额大于 1000 的货到付款订单 db.Scopes(AmountGreaterThan1000, OrderStatus([]string{\"paid\", \"shipped\"})).Find(\u0026orders) // 查找所有金额大于 1000 且已付款或已发货的订单 查看 Scopes 获取详情 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:16","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"Count Count 用于获取匹配的记录数 var count int64 db.Model(\u0026User{}).Where(\"name = ?\", \"jinzhu\").Or(\"name = ?\", \"jinzhu 2\").Count(\u0026count) // SELECT count(1) FROM users WHERE name = 'jinzhu' OR name = 'jinzhu 2' db.Model(\u0026User{}).Where(\"name = ?\", \"jinzhu\").Count(\u0026count) // SELECT count(1) FROM users WHERE name = 'jinzhu'; (count) db.Table(\"deleted_users\").Count(\u0026count) // SELECT count(1) FROM deleted_users; // Count with Distinct db.Model(\u0026User{}).Distinct(\"name\").Count(\u0026count) // SELECT COUNT(DISTINCT(`name`)) FROM `users` db.Table(\"deleted_users\").Select(\"count(distinct(name))\").Count(\u0026count) // SELECT count(distinct(name)) FROM deleted_users // Count with Group users := []User{ {Name: \"name1\"}, {Name: \"name2\"}, {Name: \"name3\"}, {Name: \"name3\"}, } // data in sql db.Model(\u0026User{}).Group(\"name\").Count(\u0026count) count // =\u003e 3 ","date":"2022-02-14","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/:10:17","tags":["数据库","后端"],"title":"Go GORM","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/gorm/"},{"categories":["Golang"],"content":"strings 由于 string 类型可以看成是一种特殊的 slice 类型，因此获取长度可以用内置的函数 len；同时支持 切片 操作，因此，子串获取很容易。 这里说的字符，指得是 rune 类型，即一个 UTF-8 字符（Unicode 代码点） ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:0:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符串比较 不推荐 Compare()，用运算符更直观 // Compare 函数，用于比较两个字符串的大小，如果两个字符串相等，返回为 0。如果 a 小于 b ，返回 -1 ，反之返回 1 。不推荐使用这个函数，直接使用 == != \u003e \u003c \u003e= \u003c= 等一系列运算符更加直观。 func Compare(a, b string) int // EqualFold 函数，计算 s 与 t 忽略字母大小写后是否相等。 func EqualFold(s, t string) bool 示例： a := \"gopher\" b := \"hello world\" fmt.Println(strings.Compare(a, b)) fmt.Println(strings.Compare(a, a)) fmt.Println(strings.Compare(b, a)) fmt.Println(strings.EqualFold(\"GO\", \"go\")) fmt.Println(strings.EqualFold(\"壹\", \"一\")) 输出结果： -1 0 1 true false ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:1:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"是否存在某个字符或子串 有三个函数做这件事： // 子串 substr 在 s 中，返回 true func Contains(s, substr string) bool // chars 中任何一个 Unicode 代码点在 s 中，返回 true func ContainsAny(s, chars string) bool // Unicode 代码点 r 在 s 中，返回 true func ContainsRune(s string, r rune) bool 这里对 ContainsAny 函数进行一下说明，看如下例子： fmt.Println(strings.ContainsAny(\"team\", \"i\")) fmt.Println(strings.ContainsAny(\"failure\", \"u \u0026 i\")) fmt.Println(strings.ContainsAny(\"in failure\", \"s g\")) fmt.Println(strings.ContainsAny(\"foo\", \"\")) fmt.Println(strings.ContainsAny(\"\", \"\")) 输出： false true true false false 也就是说，第二个参数 chars 中任意一个字符（Unicode Code Point）如果在第一个参数 s 中存在，则返回 true。 查看这三个函数的源码，发现它们只是调用了相应的 Index 函数（子串出现的位置），然后和 0 作比较返回 true 或 fale。如，Contains： func Contains(s, substr string) bool { return Index(s, substr) \u003e= 0 } ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:2:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"子串出现次数 ( 字符串匹配 ) 在 Go 中，查找子串出现次数即字符串模式匹配，实现的是 Rabin-Karp 算法。Count 函数的签名如下： func Count(s, sep string) int 在 Count 的实现中，处理了几种特殊情况，属于字符匹配预处理的一部分。这里要特别说明一下的是当 sep 为空时，Count 的返回值是：utf8.RuneCountInString(s) + 1 fmt.Println(strings.Count(\"cheese\", \"e\")) fmt.Println(len(\"谷歌中国\")) fmt.Println(strings.Count(\"谷歌中国\", \"\")) 输出： 3 12 5 另外，Count 是计算子串在字符串中出现的无重叠的次数，比如： fmt.Println(strings.Count(\"fivevev\", \"vev\")) 输出： 1 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:3:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符串分割为 []string 这个需求很常见，倒不一定是为了得到 []string。 该包提供了六个三组分割函数：Fields 和 FieldsFunc、Split 和 SplitAfter、SplitN 和 SplitAfterN。 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:4:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"Fields func Fields(s string) []string Fields 用一个或多个连续的空格分隔字符串 s，返回子字符串的数组（slice）。 如果字符串 s 只包含空格，则返回空列表 ([]string 的长度为 0）。其中，空格的定义是 unicode.IsSpace 常见间隔符包括：’\\t’, ‘\\n’, ‘\\v’, ‘\\f’, ‘\\r’, ’ ‘, U+0085 (NEL), U+00A0 (NBSP) 由于是用空格分隔，因此结果中不会含有空格或空子字符串，例如： fmt.Printf(\"Fields are: %q\", strings.Fields(\" foo bar baz \")) 输出结果： Fields are: [\"foo\" \"bar\" \"baz\"] ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:4:1","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"FieldsFunc func FieldsFunc(s string, f func(rune) bool) []string FieldsFunc 用这样的 Unicode 代码点 c 进行分隔：满足 f(c) 返回 true。该函数返回 []string。 如果字符串 s 中所有的代码点 (unicode code points) 都满足 f(c) 或者 s 是空，则 FieldsFunc 返回空 slice。 也就是说，我们可以通过实现一个回调函数来指定分隔字符串 s 的字符。比如上面的例子，我们通过 FieldsFunc 来实现： fmt.Println(strings.FieldsFunc(\" foo bar baz \", unicode.IsSpace)) 实际上，Fields 函数就是调用 FieldsFunc 实现的： func Fields(s string) []string { return FieldsFunc(s, unicode.IsSpace) } ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:4:2","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"Split 和 SplitAfter、 SplitN 和 SplitAfterN 之所以将这四个函数放在一起讲，是因为它们都是通过一个同一个内部函数来实现的。它们的函数签名及其实现： // 结果不包含分隔符本身 func Split(s, sep string) []string { return genSplit(s, sep, 0, -1) } // 结果包含分隔符本身 func SplitAfter(s, sep string) []string { return genSplit(s, sep, len(sep), -1) } func SplitN(s, sep string, n int) []string { return genSplit(s, sep, 0, n) } func SplitAfterN(s, sep string, n int) []string { return genSplit(s, sep, len(sep), n) } 它们都调用了 genSplit 函数。 这四个函数都是通过 sep 进行分割，返回 []string。如果 sep 为空，相当于分成一个个的 UTF-8 字符，如 Split(\"abc\",\"\")，得到的是 [a b c]。 Split(s, sep) 和 SplitN(s, sep, -1) 等价；SplitAfter(s, sep) 和 SplitAfterN(s, sep, -1) 等价。 那么，Split 和 SplitAfter 有啥区别呢？通过这两句代码的结果就知道它们的区别了： fmt.Printf(\"%q\\n\", strings.Split(\"foo,bar,baz\", \",\")) fmt.Printf(\"%q\\n\", strings.SplitAfter(\"foo,bar,baz\", \",\")) 输出： [\"foo\" \"bar\" \"baz\"] [\"foo,\" \"bar,\" \"baz\"] 也就是说，Split 会将 s 中的 sep 去掉，而 SplitAfter 会保留 sep。 带 N 的方法可以通过最后一个参数 n 控制返回的结果中的 slice 中的元素个数，当 n \u003c 0 时，返回所有的子字符串；当 n == 0 时，返回的结果是 nil；当 n \u003e 0 时，表示返回的 slice 中最多只有 n 个元素，其中，最后一个元素不会分割，比如： fmt.Printf(\"%q\\n\", strings.SplitN(\"foo,bar,baz\", \",\", 2)) 输出： [\"foo\" \"bar,baz\"] 另外看一下官方文档提供的例子，注意一下输出结果： fmt.Printf(\"%q\\n\", strings.Split(\"a,b,c\", \",\")) fmt.Printf(\"%q\\n\", strings.Split(\"a man a plan a canal panama\", \"a \")) fmt.Printf(\"%q\\n\", strings.Split(\" xyz \", \"\")) fmt.Printf(\"%q\\n\", strings.Split(\"\", \"Bernardo O'Higgins\")) 输出： [\"a\" \"b\" \"c\"] [\"\" \"man \" \"plan \" \"canal panama\"] [\" \" \"x\" \"y\" \"z\" \" \"] [\"\"] ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:4:3","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符串是否有某个前缀或后缀 这两个函数比较简单，源码如下： // s 中是否以 prefix 开始 func HasPrefix(s, prefix string) bool { return len(s) \u003e= len(prefix) \u0026\u0026 s[0:len(prefix)] == prefix } // s 中是否以 suffix 结尾 func HasSuffix(s, suffix string) bool { return len(s) \u003e= len(suffix) \u0026\u0026 s[len(s)-len(suffix):] == suffix } 如果 prefix 或 suffix 为 \"\" , 返回值总是 true。 示例： fmt.Println(strings.HasPrefix(\"Gopher\", \"Go\")) fmt.Println(strings.HasPrefix(\"Gopher\", \"C\")) fmt.Println(strings.HasPrefix(\"Gopher\", \"\")) fmt.Println(strings.HasSuffix(\"Amigo\", \"go\")) fmt.Println(strings.HasSuffix(\"Amigo\", \"Ami\")) fmt.Println(strings.HasSuffix(\"Amigo\", \"\")) 输出结果： true false true true false true ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:5:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符或子串在字符串中出现的位置 有一序列函数与该功能有关： // 在 s 中查找 sep 的第一次出现，返回第一次出现的索引 func Index(s, sep string) int // 在 s 中查找字节 c 的第一次出现，返回第一次出现的索引 func IndexByte(s string, c byte) int // chars 中任何一个 Unicode 代码点在 s 中首次出现的位置 func IndexAny(s, chars string) int // 查找字符 c 在 s 中第一次出现的位置，其中 c 满足 f(c) 返回 true func IndexFunc(s string, f func(rune) bool) int // Unicode 代码点 r 在 s 中第一次出现的位置 func IndexRune(s string, r rune) int // 有三个对应的查找最后一次出现的位置 func LastIndex(s, sep string) int func LastIndexByte(s string, c byte) int func LastIndexAny(s, chars string) int func LastIndexFunc(s string, f func(rune) bool) int 举 IndexFunc 的例子： han := func(c rune) bool { return unicode.Is(unicode.Han, c) // 汉字 } fmt.Println(strings.IndexFunc(\"Hello, world\", han)) fmt.Println(strings.IndexFunc(\"Hello, 世界\", han)) 输出： -1 7 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:6:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符串 JOIN 操作 将字符串数组（或 slice）连接起来可以通过 Join 实现，函数签名如下： func Join(a []string, sep string) string 假如没有这个库函数，我们自己实现一个，我们会这么实现： func Join(str []string, sep string) string { // 特殊情况应该做处理 if len(str) == 0 { return \"\" } if len(str) == 1 { return str[0] } buffer := bytes.NewBufferString(str[0]) for _, s := range str[1:] { buffer.WriteString(sep) buffer.WriteString(s) } return buffer.String() } 这里，我们使用了 bytes 包的 Buffer 类型，避免大量的字符串连接操作（因为 Go 中字符串是不可变的）。我们再看一下标准库的实现： func Join(a []string, sep string) string { if len(a) == 0 { return \"\" } if len(a) == 1 { return a[0] } n := len(sep) * (len(a) - 1) for i := 0; i \u003c len(a); i++ { n += len(a[i]) } b := make([]byte, n) bp := copy(b, a[0]) for _, s := range a[1:] { bp += copy(b[bp:], sep) bp += copy(b[bp:], s) } return string(b) } 标准库的实现没有用 bytes 包，当然也不会简单的通过 + 号连接字符串。Go 中是不允许循环依赖的，标准库中很多时候会出现代码拷贝，而不是引入某个包。这里 Join 的实现方式挺好， 不直接使用 bytes 包，可能也是不想依赖 bytes 包（其实 bytes 中的实现也是 copy 方式）。 简单使用示例： fmt.Println(Join([]string{\"name=xxx\", \"age=xx\"}, \"\u0026\")) 输出结果: name=xxx\u0026age=xx ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:7:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符串重复几次 func Repeat(s string, count int) string 将 s 重复 count 次，如果 count 为负数或返回值长度 len(s)*count 超出 string 上限会导致 panic，这个函数使用很简单： fmt.Println(\"ba\" + strings.Repeat(\"na\", 2)) 输出结果： banana ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:8:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符替换 func Map(mapping func(rune) rune, s string) string Map 函数，将 s 的每一个字符按照 mapping 的规则做映射替换，如果 mapping 返回值 \u003c0 ，则舍弃该字符。 该方法只能对每一个字符做处理，但处理方式很灵活，可以方便的过滤，筛选汉字等。 示例： mapping := func(r rune) rune { switch { case r \u003e= 'A' \u0026\u0026 r \u003c= 'Z': // 大写字母转小写 return r + 32 case r \u003e= 'a' \u0026\u0026 r \u003c= 'z': // 小写字母不处理 return r case unicode.Is(unicode.Han, r): // 汉字换行 return '\\n' } return -1 // 过滤所有非字母、汉字的字符 } fmt.Println(strings.Map(mapping, \"Hello你#￥%……\\n（'World\\n,好Hello^(\u0026(*界gopher...\")) 输出结果： hello world hello gopher ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:9:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"字符串子串替换 进行字符串替换时，考虑到性能问题，能不用正则尽量别用，应该用这里的函数。 // 用 new 替换 s 中的 old，一共替换 n 个。 // 如果 n \u003c 0，则不限制替换次数，即全部替换 func Replace(s, old, new string, n int) string // 该函数内部直接调用了函数 Replace(s, old, new , -1) func ReplaceAll(s, old, new string) string 使用示例： fmt.Println(strings.Replace(\"oink oink oink\", \"k\", \"ky\", 2)) fmt.Println(strings.Replace(\"oink oink oink\", \"oink\", \"moo\", -1)) fmt.Println(strings.ReplaceAll(\"oink oink oink\", \"oink\", \"moo\")) 输出： oinky oinky oink moo moo moo moo moo moo 如果我们希望一次替换多个，比如我们希望替换 This is \u003cb\u003eHTML\u003c/b\u003e 中的 \u003c 和 \u003e 为 \u003c 和 \u003e，可以调用上面的函数两次。但标准库提供了另外的方法进行这种替换。 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:10:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"大小写转换 func ToLower(s string) string func ToLowerSpecial(c unicode.SpecialCase, s string) string func ToUpper(s string) string func ToUpperSpecial(c unicode.SpecialCase, s string) string 大小写转换包含了 4 个相关函数，ToLower,ToUpper 用于大小写转换。ToLowerSpecial,ToUpperSpecial 可以转换特殊字符的大小写。 举个例子： fmt.Println(strings.ToLower(\"HELLO WORLD\")) fmt.Println(strings.ToLower(\"Ā Á Ǎ À\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"壹\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"HELLO WORLD\")) fmt.Println(strings.ToLower(\"Önnek İş\")) fmt.Println(strings.ToLowerSpecial(unicode.TurkishCase, \"Önnek İş\")) fmt.Println(strings.ToUpper(\"hello world\")) fmt.Println(strings.ToUpper(\"ā á ǎ à\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"一\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"hello world\")) fmt.Println(strings.ToUpper(\"örnek iş\")) fmt.Println(strings.ToUpperSpecial(unicode.TurkishCase, \"örnek iş\")) 输出结果: hello world ā á ǎ à 壹 hello world önnek iş önnek iş HELLO WORLD Ā Á Ǎ À // 汉字拼音有效 一 // 汉字无效 HELLO WORLD ÖRNEK IŞ ÖRNEK İŞ // 有细微差别 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:11:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"标题处理 func Title(s string) string func ToTitle(s string) string func ToTitleSpecial(c unicode.SpecialCase, s string) string Title 会将 s 每个单词的首字母大写，不处理该单词的后续字符。 ToTitle 将 s 的每个字母大写。 ToTitleSpecial 将 s 的每个字母大写，并且会将一些特殊字母转换为其对应的特殊大写字母。 举个例子： fmt.Println(strings.Title(\"hElLo wOrLd\")) fmt.Println(strings.ToTitle(\"hElLo wOrLd\")) fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, \"hElLo wOrLd\")) fmt.Println(strings.Title(\"āáǎà ōóǒò êēéěè\")) fmt.Println(strings.ToTitle(\"āáǎà ōóǒò êēéěè\")) fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, \"āáǎà ōóǒò êēéěè\")) fmt.Println(strings.Title(\"dünyanın ilk borsa yapısı Aizonai kabul edilir\")) fmt.Println(strings.ToTitle(\"dünyanın ilk borsa yapısı Aizonai kabul edilir\")) fmt.Println(strings.ToTitleSpecial(unicode.TurkishCase, \"dünyanın ilk borsa yapısı Aizonai kabul edilir\")) 输出结果： HElLo WOrLd HELLO WORLD HELLO WORLD Āáǎà Ōóǒò Êēéěè ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ ĀÁǍÀ ŌÓǑÒ ÊĒÉĚÈ Dünyanın Ilk Borsa Yapısı Aizonai Kabul Edilir DÜNYANIN ILK BORSA YAPISI AIZONAI KABUL EDILIR DÜNYANIN İLK BORSA YAPISI AİZONAİ KABUL EDİLİR ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:12:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"修剪 // 将 s 左侧和右侧中匹配 cutset 中的任一字符的字符去掉 func Trim(s string, cutset string) string // 将 s 左侧的匹配 cutset 中的任一字符的字符去掉 func TrimLeft(s string, cutset string) string // 将 s 右侧的匹配 cutset 中的任一字符的字符去掉 func TrimRight(s string, cutset string) string // 如果 s 的前缀为 prefix 则返回去掉前缀后的 string , 否则 s 没有变化。 func TrimPrefix(s, prefix string) string // 如果 s 的后缀为 suffix 则返回去掉后缀后的 string , 否则 s 没有变化。 func TrimSuffix(s, suffix string) string // 将 s 左侧和右侧的间隔符去掉。常见间隔符包括：'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL) func TrimSpace(s string) string // 将 s 左侧和右侧的匹配 f 的字符去掉 func TrimFunc(s string, f func(rune) bool) string // 将 s 左侧的匹配 f 的字符去掉 func TrimLeftFunc(s string, f func(rune) bool) string // 将 s 右侧的匹配 f 的字符去掉 func TrimRightFunc(s string, f func(rune) bool) string 包含了 9 个相关函数用于修剪字符串。 举个例子： x := \"!!!@@@你好,!@#$ Gophers###$$$\" fmt.Println(strings.Trim(x, \"@#$!%^\u0026*()_+=-\")) fmt.Println(strings.TrimLeft(x, \"@#$!%^\u0026*()_+=-\")) fmt.Println(strings.TrimRight(x, \"@#$!%^\u0026*()_+=-\")) fmt.Println(strings.TrimSpace(\" \\t\\n Hello, Gophers \\n\\t\\r\\n\")) fmt.Println(strings.TrimPrefix(x, \"!\")) fmt.Println(strings.TrimSuffix(x, \"$\")) f := func(r rune) bool { return !unicode.Is(unicode.Han, r) // 非汉字返回 true } fmt.Println(strings.TrimFunc(x, f)) fmt.Println(strings.TrimLeftFunc(x, f)) fmt.Println(strings.TrimRightFunc(x, f)) 输出结果： 你好,!@#$ Gophers 你好,!@#$ Gophers###$$$ !!!@@@你好,!@#$ Gophers Hello, Gophers !!@@@你好,!@#$ Gophers###$$$ !!!@@@你好,!@#$ Gophers###$$ 你好 你好,!@#$ Gophers###$$$ !!!@@@你好 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:13:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"Replacer 类型 这是一个结构，没有导出任何字段，实例化通过 func NewReplacer(oldnew ...string) *Replacer 函数进行，其中不定参数 oldnew 是 old-new 对，即进行多个替换。如果 oldnew 长度与奇数，会导致 panic. 示例： r := strings.NewReplacer(\"\u003c\", \"\u0026lt;\", \"\u003e\", \"\u0026gt;\") fmt.Println(r.Replace(\"This is \u003cb\u003eHTML\u003c/b\u003e!\")) 输出结果： This is \u0026lt;b\u0026gt;HTML\u0026lt;/b\u0026gt;! 另外，Replacer 还提供了另外一个方法，它在替换之后将结果写入 io.Writer 中。 func (r *Replacer) WriteString(w io.Writer, s string) (n int, err error) ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:14:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"Reader 类型 看到名字就能猜到，这是实现了 io 包中的接口。 它实现了 io.Reader（Read 方法），io.ReaderAt（ReadAt 方法），io.Seeker（Seek 方法），io.WriterTo（WriteTo 方法），io.ByteReader（ReadByte 方法），io.ByteScanner（ReadByte 和 UnreadByte 方法），io.RuneReader（ReadRune 方法） 和 io.RuneScanner（ReadRune 和 UnreadRune 方法）。 Reader 结构如下： type Reader struct { s string // Reader 读取的数据来源 i int // current reading index（当前读的索引位置） prevRune int // index of previous rune; or \u003c 0（前一个读取的 rune 索引位置） } 可见 Reader 结构没有导出任何字段，而是提供一个实例化方法： func NewReader(s string) *Reader 该方法接收一个字符串，返回的 Reader 实例就是从该参数字符串读数据。在后面学习了 bytes 包之后，可以知道 bytes.NewBufferString 有类似的功能，不过，如果只是为了读取，NewReader 会更高效。 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:15:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["Golang"],"content":"Builder 类型 type Builder struct { addr *Builder // of receiver, to detect copies by value buf []byte } 该类型实现了 io 包下的 Writer, ByteWriter, StringWriter 等接口，可以向该对象内写入数据，Builder 没有实现 Reader 等接口，所以该类型不可读，但提供了 String 方法可以获取对象内的数据。 // 该方法向 b 写入一个字节 func (b *Builder) WriteByte(c byte) error // WriteRune 方法向 b 写入一个字符 func (b *Builder) WriteRune(r rune) (int, error) // WriteRune 方法向 b 写入字节数组 p func (b *Builder) Write(p []byte) (int, error) // WriteRune 方法向 b 写入字符串 s func (b *Builder) WriteString(s string) (int, error) // Len 方法返回 b 的数据长度。 func (b *Builder) Len() int // Cap 方法返回 b 的 cap。 func (b *Builder) Cap() int // Grow 方法将 b 的 cap 至少增加 n (可能会更多)。如果 n 为负数，会导致 panic。 func (b *Builder) Grow(n int) // Reset 方法将 b 清空 b 的所有内容。 func (b *Builder) Reset() // String 方法将 b 的数据以 string 类型返回。 func (b *Builder) String() string Builder 有 4 个与写入相关的方法，这 4 个方法的 error 都总是为 nil. Builder 的 cap 会自动增长，一般不需要手动调用 Grow 方法。 String 方法可以方便的获取 Builder 的内容。 举个例子： b := strings.Builder{} _ = b.WriteByte('7') n, _ := b.WriteRune('夕') fmt.Println(n) n, _ = b.Write([]byte(\"Hello, World\")) fmt.Println(n) n, _ = b.WriteString(\"你好，世界\") fmt.Println(n) fmt.Println(b.Len()) fmt.Println(b.Cap()) b.Grow(100) fmt.Println(b.Len()) fmt.Println(b.Cap()) fmt.Println(b.String()) b.Reset() fmt.Println(b.String()) 输出结果： 3 12 15 31 32 31 164 7夕Hello, World你好，世界 ","date":"2022-02-11","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/:16:0","tags":["Go 库"],"title":"Go strings 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strings/"},{"categories":["刷题"],"content":"剑指 Offer 05. 替换空格 请实现一个函数，把字符串 s 中的每个空格替换成\"%20\"。 示例 1： 输入：s = \"We are happy.\" 输出：\"We%20are%20happy.\" ","date":"2022-02-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/:0:0","tags":["算法","字符串"],"title":"剑指 Offer 05. 替换空格","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"categories":["刷题"],"content":"遍历添加 // 遍历添加 时间复杂度O(N),空间复杂度O(N) func replaceSpace(s string) string { b := make([]byte, 0) for i := 0; i \u003c len(s); i++ { if s[i] == ' ' { b = append(b, []byte(\"%20\")...) } else { b = append(b, s[i]) } } return string(b) } ","date":"2022-02-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/:1:0","tags":["算法","字符串"],"title":"剑指 Offer 05. 替换空格","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"categories":["刷题"],"content":"原地修改 扩充然后逆序填入 其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后再从后向前进行操作。 // 原地修改 时间复杂度O(N),空间复杂度O(1) func replaceSpace2(s string) string { b := []byte(s) length := len(b) spaceCount := 0 // 计算空格数量 for _, v := range b { if v == ' ' { spaceCount++ } } // 扩展原有切片 tmp := make([]byte, spaceCount*2) b = append(b, tmp...) i := length - 1 // 指向原来最后一位 j := len(b) - 1 // 指向现在zui'hou'yi // 从后向前填充 for i \u003e= 0 { if b[i] != ' ' { b[j] = b[i] i-- j-- } else { b[j] = '0' b[j-1] = '2' b[j-2] = '%' i-- j = j - 3 } } return string(b) } ","date":"2022-02-11","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/:2:0","tags":["算法","字符串"],"title":"剑指 Offer 05. 替换空格","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-05.-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"},{"categories":["刷题"],"content":"27. 移除元素 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 ","date":"2022-02-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/:0:0","tags":["算法","数组","双指针"],"title":"27. 移除元素","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"},{"categories":["刷题"],"content":"双指针 快慢指针，j 遍历，i 等 j 匹配到与 val 不同的元素后与 j 交换，然后右移；这样可以保证 i 之前的所有元素都不是 val // removeDuplicates 将重复元素与当前指针交换 func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } i := 0 for j := 0; j \u003c len(nums); j++ { if nums[j] != val { nums[j], nums[i] = nums[i], nums[j] i++ } } return i } 头尾指针，一个道理 func removeElement(nums []int, val int) int { if len(nums) == 0 { return 0 } l,r:=0,len(nums)-1 for l\u003c=r{ if nums[l]==val{ nums[l],nums[r]=nums[r],nums[l] r-- }else{ l++ } } return r+1 } ","date":"2022-02-10","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/:1:0","tags":["算法","数组","双指针"],"title":"27. 移除元素","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/27.-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"},{"categories":["Golang"],"content":"cobra cobra既是一个用于创建强大现代 CLI 应用程序的库，也是一个生成应用程序和命令文件的程序。cobra 被用在很多 go 语言的项目中，比如 Kubernetes、Docker、Istio、ETCD、Hugo、Github CLI 等等 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/:0:0","tags":["Go 库"],"title":"Go cobra 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/"},{"categories":["Golang"],"content":"概念 cobra 中有个重要的概念，分别是 commands、arguments 和 flags。 commands 代表行为 arguments 就是命令行参数 (或者称为位置参数) flags 代表对行为的改变 (也就是常说的命令行选项)。 执行命令行程序时的一般格式为： APPNAME COMMAND ARG --FLAG 比如下面的例子： # server是 commands，port 是 flag hugo server --port=1313 # clone 是 commands，URL 是 arguments，brae 是 flag git clone URL --bare 如果是一个简单的程序 (功能单一的程序)，使用 commands 的方式可能会很啰嗦，但是像 git、docker 等应用，把这些本就很复杂的功能划分为子命令的形式，会方便使用 (对程序的设计者来说又何尝不是如此)。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/:1:0","tags":["Go 库"],"title":"Go cobra 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/"},{"categories":["Golang"],"content":"创建 cobra 应用 安装 cobra 包： $ go get -u github.com/spf13/cobra/cobra 然后就可以用 cobra 程序生成应用程序框架了： $ cobra init \u003cappname\u003e 此时的程序并没有什么功能，执行它只会输出一些默认的提示信息 cobra 推荐的项目结构如下： + cmd/ root.go add.go your.go commands.go here.go main.go 所有命令放在项目根目录下的 cmd 目录中。其中，默认命令（即不输入任何命令）为 root.go cobra 应用的 main.go 非常简单，通常如下： package main import ( \"{pathToYourApp}/cmd\" ) func main() { cmd.Execute() } ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/:2:0","tags":["Go 库"],"title":"Go cobra 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/"},{"categories":["Golang"],"content":"创建 rootCmd root.go的内容如下： package cmd import ( \"fmt\" \"os\" \"github.com/spf13/cobra\" ) var rootCmd = \u0026cobra.Command{ Use: \"demo\", Short: \"A cobra demo\", Long: `A cobra demo. xxx...`, Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"execute root cmd.\") }, } func Execute() { if err := rootCmd.Execute(); err != nil { fmt.Fprintln(os.Stderr, err) os.Exit(1) } } 此时，执行 go run main.go --help，可以看到以下输出： A cobra demo. xxx... Usage: demo [flags] Flags: -h, --help help for demo 直接执行 go run main.go 会打印 execute root cmd.。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/:3:0","tags":["Go 库"],"title":"Go cobra 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/"},{"categories":["Golang"],"content":"创建其他命令 我们再创建一个 print 命令。一般每个命令在 cmd 下都有一个自己的文件。只需要在 cmd 下再新建一个 print.go，内容如下： package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) func init() { rootCmd.AddCommand(printCmd) } var printCmd = \u0026cobra.Command{ Use: \"print\", Short: \"print something\", Long: \"print something, xxx\", Run: func(cmd *cobra.Command, args []string) { fmt.Println(\"execute print cmd\") }, } 此时再执行 go run main.go --help 可以看到已经增加了 print 命令： A cobra demo. xxx... Usage: demo [flags] demo [command] Available Commands: help Help about any command print print something Flags: -h, --help help for demo Use \"demo [command] --help\" for more information about a command. ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/:4:0","tags":["Go 库"],"title":"Go cobra 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/"},{"categories":["Golang"],"content":"创建 flag 在执行 print 命令时，我们想传递一些参数，来指定打印的内容，这时我们就需要增加 flags。 flags 分为 persistent flag 和 local flags。persistent flag 可以分配给当前命令及其所有子命令，而local flags 只应用于当前命令。 这里给 print 命令增加一个 local flags： package cmd import ( \"fmt\" \"github.com/spf13/cobra\" ) func init() { rootCmd.AddCommand(printCmd) printCmd.Flags().StringVarP(\u0026Msg, \"message\", \"m\", \"default message\", \"message to be printed\") } var Msg string var printCmd = \u0026cobra.Command{ Use: \"print\", Short: \"print something\", Long: \"print something, xxx\", Run: func(cmd *cobra.Command, args []string) { fmt.Println(Msg) }, } 这时再使用 go run main.go print 会打印默认内容default message，也可以使用 -m 或 --message 来指定要打印的内容了。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/:5:0","tags":["Go 库"],"title":"Go cobra 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/cobra/"},{"categories":["Golang"],"content":"log Go 语言内置的 log 包实现了简单的日志服务。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:0:0","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"使用 Logger log 包定义了 Logger 类型，该类型提供了一些格式化输出的方法。 本包也提供了一个预定义的 “标准” logger，可以通过调用函数 Print 系列 (Print|Printf|Println）、Fatal 系列（Fatal|Fatalf|Fatalln）、和 Panic 系列（Panic|Panicf|Panicln）来使用，比自行创建一个 logger 对象更容易使用。 例如，我们可以像下面的代码一样直接通过 log 包来调用上面提到的方法，默认它们会将日志信息打印到终端界面： package main import ( \"log\" ) func main() { log.Println(\"这是一条很普通的日志。\") v := \"很普通的\" log.Printf(\"这是一条%s日志。\\n\", v) log.Fatalln(\"这是一条会触发fatal的日志。\") log.Panicln(\"这是一条会触发panic的日志。\") } 编译并执行上面的代码会得到如下输出： 2019/10/11 14:04:17 这是一条很普通的日志。 2019/10/11 14:04:17 这是一条很普通的日志。 2019/10/11 14:04:17 这是一条会触发fatal的日志。 logger 会打印每条日志信息的日期、时间，默认输出到系统的标准错误。 Fatal系列函数会在写入日志信息后调用 os.Exit(1)。 Panic 系列函数会在写入日志信息后 panic。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:1:0","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"配置 logger 默认情况下的 logger 只会提供日志的时间信息，但是很多情况下我们希望得到更多信息，比如记录该日志的文件名和行号等。log 标准库中为我们提供了定制这些设置的方法。 log 标准库中的 Flags 函数会返回标准 logger 的输出配置，而 SetFlags 函数用来设置标准 logger 的输出配置。 func Flags() int func SetFlags(flag int) ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:2:0","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"flag 选项 log 标准库提供了如下的 flag 选项，它们是一系列定义好的常量。 const ( // 控制输出日志信息的细节，不能控制输出的顺序和格式。 // 输出的日志在每一项后会有一个冒号分隔：例如2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message Ldate = 1 \u003c\u003c iota // 日期：2009/01/23 Ltime // 时间：01:23:23 Lmicroseconds // 微秒级别的时间：01:23:23.123123（用于增强Ltime位） Llongfile // 文件全路径名+行号： /a/b/c/d.go:23 Lshortfile // 文件名+行号：d.go:23（会覆盖掉Llongfile） LUTC // 使用UTC时间 LstdFlags = Ldate | Ltime // 标准logger的初始值 ) 下面我们在记录日志之前先设置一下标准logger的输出选项如下： func main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(\"这是一条很普通的日志。\") } 编译执行后得到的输出结果如下： 2019/10/11 14:05:17.494943 .../log_demo/main.go:11: 这是一条很普通的日志。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:2:1","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"配置日志前缀 log 标准库中还提供了关于日志信息前缀的两个方法： func Prefix() string func SetPrefix(prefix string) 其中 Prefix 函数用来查看标准 logger 的输出前缀，SetPrefix 函数用来设置输出前缀。 func main() { log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(\"这是一条很普通的日志。\") log.SetPrefix(\"[pprof]\") log.Println(\"这是一条很普通的日志。\") } 上面的代码输出如下： [pprof]2019/10/11 14:05:57.940542 .../log_demo/main.go:13: 这是一条很普通的日志。 这样我们就能够在代码中为我们的日志信息添加指定的前缀，方便之后对日志信息进行检索和处理。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:2:2","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"配置日志输出位置 func SetOutput(w io.Writer) SetOutput 函数用来设置标准 logger 的输出目的地，默认是标准错误输出。 例如，下面的代码会把日志输出到同目录下的 xx.log 文件中。 func main() { logFile, err := os.OpenFile(\"./xx.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\"open log file failed, err:\", err) return } log.SetOutput(logFile) log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) log.Println(\"这是一条很普通的日志。\") log.SetPrefix(\"[噜啦啦]\") log.Println(\"这是一条很普通的日志。\") } 如果你要使用标准的 logger，我们通常会把上面的配置操作写到 init 函数中。 func init() { logFile, err := os.OpenFile(\"./xx.log\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\"open log file failed, err:\", err) return } log.SetOutput(logFile) log.SetFlags(log.Llongfile | log.Lmicroseconds | log.Ldate) } ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:2:3","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"创建 logger log 标准库中还提供了一个创建新 logger 对象的构造函数 New，支持我们创建自己的 logger 示例。New 函数的签名如下： func New(out io.Writer, prefix string, flag int) *Logger New 创建一个 Logger 对象。 参数 out 设置日志信息写入的目的地。 参数 prefix 会添加到生成的每一条日志前面。 参数 flag 定义日志的属性（时间、文件等等）。 举个例子： func main() { logger := log.New(os.Stdout, \"\u003cNew\u003e\", log.Lshortfile|log.Ldate|log.Ltime) logger.Println(\"这是自定义的logger记录的日志。\") } 将上面的代码编译执行之后，得到结果如下： \u003cNew\u003e2019/10/11 14:06:51 main.go:34: 这是自定义的logger记录的日志。 总结 : Go 内置的 log 库功能有限，例如无法满足记录不同级别日志的情况，我们在实际的项目中根据自己的需要选择使用第三方的日志库，如 logrus、zap 等。 ","date":"2022-02-08","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/:3:0","tags":["Go 库"],"title":"Go log 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/log/"},{"categories":["Golang"],"content":"context ","date":"2022-02-07","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/:0:0","tags":["Go 库"],"title":"Go context 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/"},{"categories":["Golang"],"content":"什么是 Context Context 也叫作“上下文”，是一个比较抽象的概念，一般理解为程序单元的一个运行状态、现场、快照。其中上下是指存在上下层的传递，上会把内容传递给下，程序单元则指的是 Goroutine。 每个 Goroutine 在执行之前，都要先知道程序当前的执行状态，通常将这些执行状态封装在一个 Context 变量中，传递给要执行的 Goroutine 中。 在网络编程下，当接收到一个网络请求 Request，在处理 Request 时，我们可能需要开启不同的 Goroutine 来获取数据与逻辑处理，即一个请求 Request，会在多个 Goroutine 中处理。 而这些 Goroutine 可能需要共享 Request 的一些信息，同时当 Request 被取消或者超时的时候，所有从这个 Request 创建的所有 Goroutine 也应该被结束。 ","date":"2022-02-07","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/:1:0","tags":["Go 库"],"title":"Go context 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/"},{"categories":["Golang"],"content":"Context 接口 Context 包的核心就是 Context 接口，其定义如下： type Context interface { Deadline() (deadline time.Time, ok bool) Done() \u003c-chan struct{} Err() error Value(key interface{}) interface{} } 其中： Deadline 方法需要返回当前 Context 被取消的时间，也就是完成工作的截止时间（deadline）； Done 方法需要返回一个 Channel，这个 Channel 会在当前工作完成或者上下文被取消之后关闭，多次调用 Done 方法会返回同一个Channel； Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值： 如果当前 Context 被取消就会返回 Canceled 错误； 如果当前 Context 超时就会返回 DeadlineExceeded 错误； Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，该方法仅用于传递跨 API 和进程间跟请求域的数据。 ","date":"2022-02-07","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/:2:0","tags":["Go 库"],"title":"Go context 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/"},{"categories":["Golang"],"content":"Background() 和 TODO() Go语言内置两个函数：Background() 和 TODO()，这两个函数分别返回一个实现了 Context 接口的 background 和 todo。 Background() 主要用于 main 函数、初始化以及测试代码中，作为 Context 这个树结构的最顶层的 Context，也就是根 Context。 TODO()，在不知道该使用什么 Context 的时候，可以使用这个。 background 和 todo 本质上都是 emptyCtx 结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的 Context。 ","date":"2022-02-07","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/:2:1","tags":["Go 库"],"title":"Go context 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/"},{"categories":["Golang"],"content":"With 系列函数 此外，Context 包中还定义了四个 With 系列函数。 WithCancel WithCancel 的函数签名如下： func WithCancel(parent Context) (ctx Context, cancel CancelFunc) WithCancel 返回带有新 Done 通道的父节点的副本，当调用返回的 cancel 函数或当关闭父上下文的 Done 通道时，将关闭返回上下文的 Done 通道，无论先发生什么情况。 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下： package main import ( \"context\" \"fmt\" ) func main() { gen := func(ctx context.Context) \u003c-chan int { dst := make(chan int) n := 1 go func() { for { select { case \u003c-ctx.Done(): return // return结束该goroutine，防止泄露 case dst \u003c- n: n++ } } }() return dst } ctx, cancel := context.WithCancel(context.Background()) defer cancel() // 当我们取完需要的整数后调用cancel for n := range gen(ctx) { fmt.Println(n) if n == 5 { break } } } 上面的代码中，gen 函数在单独的 Goroutine 中生成整数并将它们发送到返回的通道，gen 的调用者在使用生成的整数之后需要取消上下文，以免 gen 启动的内部 Goroutine 发生泄漏。 运行结果如下： go run main.go 1 2 3 4 5 WithDeadline WithDeadline 的函数签名如下： func WithDeadline(parent Context, deadline time.Time) (Context, CancelFunc) WithDeadline 函数会返回父上下文的副本，并将 deadline 调整为不迟于 d。 如果父上下文的 deadline 已经早于 d，则 WithDeadline(parent, d) 在语义上等同于父上下文。 当截止日过期时，当调用返回的 cancel 函数时，或者当父上下文的 Done 通道关闭时，返回上下文的 Done 通道将被关闭，以最先发生的情况为准。 取消此上下文将释放与其关联的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下： package main import ( \"context\" \"fmt\" \"time\" ) func main() { d := time.Now().Add(50 * time.Millisecond) ctx, cancel := context.WithDeadline(context.Background(), d) // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。 // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。 defer cancel() select { case \u003c-time.After(1 * time.Second): fmt.Println(\"overslept\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) } } 运行结果如下： go run main.go context deadline exceeded 上面的代码中，定义了一个 50 毫秒之后过期的 deadline，然后我们调用 context.WithDeadline(context.Background(), d) 得到一个上下文（ctx）和一个取消函数（cancel），然后使用一个 select 让主程序陷入等待，等待 1 秒后打印 overslept 退出或者等待 ctx 过期后退出。因为 ctx 50 秒后就过期，所以 ctx.Done() 会先接收到值，然后打印 ctx.Err() 取消原因。 WithTimeout WithTimeout 的函数签名如下： func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) WithTimeout 函数返回 WithDeadline(parent, time.Now().Add(timeout))。 取消此上下文将释放与其相关的资源，因此代码应该在此上下文中运行的操作完成后立即调用 cancel，示例代码如下： package main import ( \"context\" \"fmt\" \"time\" ) func main() { // 传递带有超时的上下文 // 告诉阻塞函数在超时结束后应该放弃其工作。 ctx, cancel := context.WithTimeout(context.Background(), 50*time.Millisecond) defer cancel() select { case \u003c-time.After(1 * time.Second): fmt.Println(\"overslept\") case \u003c-ctx.Done(): fmt.Println(ctx.Err()) // 终端输出\"context deadline exceeded\" } } 运行结果如下： go run main.go context deadline exceeded WithValue WithValue 函数能够将请求作用域的数据与 Context 对象建立关系。函数声明如下： func WithValue(parent Context, key, val interface{}) Context WithValue 函数接收 context 并返回派生的 context，其中值 val 与 key 关联，并通过 context 树与 context 一起传递。这意味着一旦获得带有值的 context，从中派生的任何 context 都会获得此值。 不建议使用 context 值传递关键参数，函数应接收签名中的那些值，使其显式化。 所提供的键必须是可比较的，并且不应该是 string 类型或任何其他内置类型，以避免使用上下文在包之间发生冲突。WithValue 的用户应该为键定义自己的类型，为了避免在分配给接口 { } 时进行分配，上下文键通常具有具体类型 struct{}。或者，导出的上下文关键变量的静态类型应该是指针或接口。 package main import ( \"context\" \"fmt\" ) func main() { type favContextKey string // 定义一个key类型 // f:一个从上下文中根据key取value的函数 f := func(ctx context.Context, k favContextKey) { if v := ctx.Value(k); v != nil { fmt.Println(\"found value:\", v) return } fmt.Println(\"key not found:\", k) } k := favContextKey(\"language\") // 创建一个携带key为k，value为\"Go\"的上下文 ctx := context.WithValue(context.Background(), k, \"Go\") f(ctx, k) f(ctx, favContextKey(\"color\")) } 运行结果如下： go run main.go found value: Go key not found: color 使用 Context 的注意事项： 不要把 Context 放在结构体中，要以参数的方式显示传递； 以 Context 作为参数的函数方法，应该把 Context 作为第一个参数； 给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO； Context 的 Value 相关方法应该传递请求域的必要数据，不应该用于传递可选参数； Context 是线程安全的，可以放心的在多个 Goroutine 中传递。 ","date":"2022-02-07","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/:2:2","tags":["Go 库"],"title":"Go context 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/"},{"categories":["Golang"],"content":"总结 Go 语言中的 Context 的主要作用还是在多个 Goroutine 或者模块之间同步取消信号或者截止日期，用于减少对资源的消耗和长时间占用，避免资源浪费，虽然传值也是它的功能之一，但是这个功能我们还是很少用到。 在真正使用传值的功能时我们也应该非常谨慎，不能将请求的所有参数都使用 Context 进行传递，这是一种非常差的设计，比较常见的使用场景是传递请求对应用户的认证令牌以及用于进行分布式追踪的请求 ID。 ","date":"2022-02-07","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/:3:0","tags":["Go 库"],"title":"Go context 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/context/"},{"categories":["Golang"],"content":"gopacket go get github.com/google/gopacket ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:0:0","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"pcap 处理 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:0","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"查看版本 version := pcap.Version() fmt.Println(version) 测试（Win10 x64） Npcap version 1.00, based on libpcap version 1.9.1 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:1","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"网络接口 类型：pcap.Interface type Interface struct { Name string Description string Flags uint32 Addresses []InterfaceAddress } type InterfaceAddress struct { IP net.IP Netmask net.IPMask // Netmask may be nil if we were unable to retrieve it. Broadaddr net.IP // Broadcast address for this IP may be nil P2P net.IP // P2P destination address for this IP may be nil } 查找网络设备 var devices []pcap.Interface devices, _ = pcap.FindAllDevs() fmt.Println(devices) ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:2","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"实时捕获 handle, err := pcap.OpenLive(\"\\\\Device\\\\NPF_{5C9384EF-DEBA-43A6-AE6A-5D10C952C481}\", int32(65535), true, -1 * time.Second) if err != nil { log.Fatal(err) } defer handle.Close() pcap.OpenLive 参数： 设备名：pcap.FindAllDevs() 返回的设备的 Name snaplen：捕获一个数据包的多少个字节，一般来说对任何情况 65535 是一个好的实践，如果不关注全部内容，只关注数据包头，可以设置成 1024 promisc：设置网卡是否工作在混杂模式，即是否接收目的地址不为本机的包 timeout：设置抓到包返回的超时。如果设置成 30s，那么每 30s 才会刷新一次数据包；设置成负数，会立刻刷新数据包，即不做等待 要记得释放掉 handle ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:3","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"打开 pcap handle, _ = pcap.OpenOffline(\"dump.pcap\") defer handle.Close() ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:4","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"创建一个数据包源 通过监听设备的实时流量或者来自文件的数据包，我们可以得到一个 handle，通过这个 handle 得到一个数据包源 packetSource。 packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) 利用 handle.LinkType() 就不用知道链路类型了。 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:5","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"读取数据包 读取一个数据包：packet, _ := packetSource.NextPacket() 获得一个可以读取数据包的 channel 来读取全部数据包 packet := packetSource.Packets() for packet := range packet{ fmt.Println(packet) } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:6","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"设置过滤器 使用 BPF 语法即可。 handle.SetBPFFilter(\"tcp and port 80\") ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:7","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"创建一个 pcap 用于写入 dumpFile, _ := os.Create(\"dump.pcap\") defer dumpFile.Close() packetWriter := pcapgo.NewWriter(dumpFile) packetWriter.WriteFileHeader(65535, layers.LinkTypeEthernet) packetWriter.WriteFileHeader 的参数是 snaplen 和链路类型 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:8","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"写入数据包 packet := packetSource.Packets() for packet := range packet{ packetWriter.WritePacket(packet.Metadata().CaptureInfo, packet.Data()) } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:1:9","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"packet 处理 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:2:0","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"列出所有层 for _, layer := range packet.Layers() { fmt.Println(layer.LayerType()) fmt.Println(layer.LayerContents()) fmt.Println(layer.LayerPayload()) } layer.LayerType()：这层的类型 layer.LayerContents()：当前层的内容 layer.LayerPayload()：当前层承载的 payload（不包括当前层） ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:2:1","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"分析某层的数据 IPv4 ipLayer := packet.Layer(layers.LayerTypeIPv4) if ipLayer != nil { ip, _ := ipLayer.(*layers.IPv4) fmt.Println(ip.SrcIP, ip.DstIP) fmt.Println(ip.Protocol) } TCP tcpLayer := packet.Layer(layers.LayerTypeTCP) if tcpLayer != nil { ip, _ := tcpLayer.(*layers.TCP) fmt.Println(ip.SrcPort, ip.DstPort) } 这里有一些需要注意的： tcpLayer 是通过接口 packet.Layer 返回的一个 Layer，一个指向 layers.TCP 的指针 tcp 是 layers.TCP 这个具体类型的指针，也可以说 tcp 是真实的 tcp 层数据 单独的解码器 可以从多个起点对数据包进行解码。可以解码没有完整数据的数据包。 // Decode an ethernet packet ethP := gopacket.NewPacket(packet, layers.LayerTypeEthernet, gopacket.Default) // Decode an IPv6 header and everything it contains ipP := gopacket.NewPacket(packet, layers.LayerTypeIPv6, gopacket.Default) // Decode a TCP header and its payload tcpP := gopacket.NewPacket(packet, layers.LayerTypeTCP, gopacket.Default) 懒惰解码（Lazy Decoding） 创建一个 packet 包，但是不立刻解码，只有后面需要用的时候再解码。 比如第二行解码 IPv4 层，如果有的话，就解码 IPv4 层，然后不做进一步处理（不解码后续的层）；如果没有会解码整个 packet 来寻找 IPv4 层。 packet.Layers() 会解码所有层并且返回，已经解码的层不会再次做解码。 注意：这种方式并不是并发安全的，对 Layers 的每次调用可能会改变数据包。 packet := gopacket.NewPacket(myPacketData, layers.LayerTypeEthernet, gopacket.Lazy) ip4 := packet.Layer(layers.LayerTypeIPv4) // Decode all layers and return them. The layers up to the first IPv4 layer // are already decoded, and will not require decoding a second time. layers := packet.Layers() NoCopy 解码 上述两种解码方式会复制切片，对切片的字节进行更改不会影响数据包本身。如果可以保证不修改切片，可以使用 NoCopy。 for data := range myByteSliceChannel { p := gopacket.NewPacket(data, layers.LayerTypeEthernet, gopacket.NoCopy) doSomethingWithPacket(p) } 快速解码 不会创建新的内存结构。会重用内存结构，所以只能用于预定义好层的结构。 for packet := range packetSource.Packets() { var eth layers.Ethernet var ip4 layers.IPv4 var tcp layers.TCP parser := gopacket.NewDecodingLayerParser(layers.LayerTypeEthernet, \u0026eth, \u0026ip4, \u0026tcp) var decodedLayers []gopacket.LayerType parser.DecodeLayers(packet.Data(), \u0026decodedLayers) for _, layerType := range decodedLayers { fmt.Println(layerType) } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:2:2","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"自定义层数据 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:3:0","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"注册自定义的层 gopacket.RegisterLayerType()：传入一个独有的 id，和层类型对应的 Metadata，包括有名字和对应的解码器。 var MyLayerType = gopacket.RegisterLayerType(12345, gopacket.LayerTypeMetadata{Name: \"MyLayerType\", Decoder: gopacket.DecodeFunc(decodeMyLayer)}) ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:3:1","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"定义层的结构 要实现三个方法。 type MyLayer struct { MyHeader []byte MyPayload []byte } func (m MyLayer) LayerType() gopacket.LayerType { return MyLayerType } func (m MyLayer) LayerContents() []byte { return m.MyHeader } func (m MyLayer) LayerPayload() []byte { return m.MyPayload } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:3:2","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"定义解码器 func decodeMyLayer(data []byte, p gopacket.PacketBuilder) error { p.AddLayer(\u0026MyLayer{data[:4], data[4:]}) return p.NextDecoder(layers.LayerTypeEthernet) } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:3:3","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"对自定义的层进行解码 pkt := gopacket.NewPacket(packet.Data(), MyLayerType, gopacket.Default) ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:3:4","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"创建与发送 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:4:0","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"创建 创建一个新的序列化缓冲区；然后把所有层序列化到缓冲区中。 buffer := gopacket.NewSerializeBuffer() options := gopacket.SerializeOptions{} gopacket.SerializeLayers(buffer, options, \u0026layers.Ethernet{}, \u0026layers.IPv4{}, \u0026layers.TCP{}, gopacket.Payload([]byte{65, 66, 67})) ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:4:1","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"发送数据包 handle.WritePacketData(buffer.Bytes()) ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:4:2","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"流和端点（Flow and Endpoint） 注意：这个地方官方文档感觉有坑 pkt.NetworkLayer().NetworkFlow()：取网络层，网络流，IP 地址 pkt.TransportLayer().TransportFlow()：取传输层，传输端点，端口 interestingFlow：定义好端点，对网络数据做匹配 pkt := gopacket.NewPacket(packet.Data(), layers.LayerTypeEthernet, gopacket.Lazy) netFlow := pkt.NetworkLayer().NetworkFlow() src, dst := netFlow.Endpoints() fmt.Println(src, dst) fmt.Println(\"Done.\") tcpFlow := pkt.TransportLayer().TransportFlow() fmt.Println(tcpFlow.Endpoints()) interestingFlow, _ := gopacket.FlowFromEndpoints(layers.NewUDPPortEndpoint(1000), layers.NewUDPPortEndpoint(500)) if t := pkt.TransportLayer(); t != nil \u0026\u0026 t.TransportFlow() == interestingFlow { fmt.Println(\"Found that UDP flow I was looking for!\") } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:4:3","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"例子 ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:0","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"枚举本地网络设备 package main import ( \"fmt\" \"log\" \"github.com/google/gopacket/pcap\" ) func main() { // 得到所有的(网络)设备 devices, err := pcap.FindAllDevs() if err != nil { log.Fatal(err) } // 打印设备信息 fmt.Println(\"Devices found:\") for _, device := range devices { fmt.Println(\"\\nName: \", device.Name) fmt.Println(\"Description: \", device.Description) fmt.Println(\"Devices addresses: \", device.Description) for _, address := range device.Addresses { fmt.Println(\"- IP address: \", address.IP) fmt.Println(\"- Subnet mask: \", address.Netmask) } } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:1","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"打开一个设备进行实时捕获 package main import ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/pcap\" \"log\" \"time\" ) var ( device string = \"eth0\" snapshot_len int32 = 1024 promiscuous bool = false err error timeout time.Duration = 30 * time.Second handle *pcap.Handle ) func main() { // Open device handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout) if err != nil {log.Fatal(err) } defer handle.Close() // Use the handle as a packet source to process all packets packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { // Process packet here fmt.Println(packet) } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:2","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"写入到 pcap 文件 为了写入到 pcap 格式的文件中，我们需要 gopacket/pcapgo，它包含一个 Writer，还有两个有用的辅助函数：WriteFileHeader() 和 WritePacket()。 package main import ( \"fmt\" \"os\" \"time\" \"github.com/google/gopacket\" \"github.com/google/gopacket/layers\" \"github.com/google/gopacket/pcap\" \"github.com/google/gopacket/pcapgo\" ) var ( deviceName string = \"eth0\" snapshotLen int32 = 1024 promiscuous bool = false err error timeout time.Duration = -1 * time.Second handle *pcap.Handle packetCount int = 0 ) func main() { // Open output pcap file and write header f, _ := os.Create(\"test.pcap\") w := pcapgo.NewWriter(f) w.WriteFileHeader(snapshotLen, layers.LinkTypeEthernet) defer f.Close() // Open the device for capturing handle, err = pcap.OpenLive(deviceName, snapshotLen, promiscuous, timeout) if err != nil { fmt.Printf(\"Error opening device %s: %v\", deviceName, err) os.Exit(1) } defer handle.Close() // Start processing packets packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { // Process packet here fmt.Println(packet) w.WritePacket(packet.Metadata().CaptureInfo, packet.Data()) packetCount++ // Only capture 100 and then stop if packetCount \u003e 100 { break } } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:3","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"打开 pcap 文件 除了打开一个设备实时捕获以外，我们还可以读取 pcap 文件进行离线分析。你可以通过 tcpdump 捕获一个文件来测试。 # Capture packets to test.pcap file sudo tcpdump -w test.pcap 打开这个文件，遍历其中的 packet package main // Use tcpdump to create a test file // tcpdump -w test.pcap // or use the example above for writing pcap files import ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/pcap\" \"log\" ) var ( pcapFile string = \"test.pcap\" handle *pcap.Handle err error ) func main() { // Open file instead of device handle, err = pcap.OpenOffline(pcapFile) if err != nil { log.Fatal(err) } defer handle.Close() // Loop through packets in file packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { fmt.Println(packet) } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:4","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"设置过滤器 下面的代码仅仅返回端口 80 上的 packet package main import ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/pcap\" \"log\" \"time\" ) var ( device string = \"eth0\" snapshot_len int32 = 1024 promiscuous bool = false err error timeout time.Duration = 30 * time.Second handle *pcap.Handle ) func main() { // Open device handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() // Set filter var filter string = \"tcp and port 80\" err = handle.SetBPFFilter(filter) if err != nil { log.Fatal(err) } fmt.Println(\"Only capturing TCP port 80 packets.\") packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { // Do something with a packet here. fmt.Println(packet) } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:5","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"解码 packet 的各层 我们可以获取原始数据包，并尝试将其强制转换为已知格式。它与不同的层兼容，因此我们可以轻松访问ethernet、IP 和 TCP 层。 layers 包是 gopacket 的 Go 库中的新功能，在底层 libpcap 库中不存在。它是 gopacket 库的非常有用的一部分。它允许我们轻松地识别数据包是否包含特定类型的层。这个代码示例将演示如何使用 layers 包来查看包是否是 ethernet、IP 和 TCP，以及如何轻松访问这些头中的元素。 找到 payload (有效载荷) 取决于涉及的所有层。每个协议都是不同的，必须相应地进行处理。这就是 layers 包的强大之处。gopacket 的作者花了很多时间为许多已知层（ethernet、IP、UDP和TCP）创建 layer 类型。其中payload (有效负载) 是应用程序层的一部分。 package main import ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/layers\" \"github.com/google/gopacket/pcap\" \"log\" \"strings\" \"time\" ) var ( device string = \"eth0\" snapshotLen int32 = 1024 promiscuous bool = false err error timeout time.Duration = 30 * time.Second handle *pcap.Handle ) func main() { // Open device handle, err = pcap.OpenLive(device, snapshotLen, promiscuous, timeout) if err != nil {log.Fatal(err) } defer handle.Close() packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { printPacketInfo(packet) } } func printPacketInfo(packet gopacket.Packet) { // Let's see if the packet is an ethernet packet ethernetLayer := packet.Layer(layers.LayerTypeEthernet) if ethernetLayer != nil { fmt.Println(\"Ethernet layer detected.\") ethernetPacket, _ := ethernetLayer.(*layers.Ethernet) fmt.Println(\"Source MAC: \", ethernetPacket.SrcMAC) fmt.Println(\"Destination MAC: \", ethernetPacket.DstMAC) // Ethernet type is typically IPv4 but could be ARP or other fmt.Println(\"Ethernet type: \", ethernetPacket.EthernetType) fmt.Println() } // Let's see if the packet is IP (even though the ether type told us) ipLayer := packet.Layer(layers.LayerTypeIPv4) if ipLayer != nil { fmt.Println(\"IPv4 layer detected.\") ip, _ := ipLayer.(*layers.IPv4) // IP layer variables: // Version (Either 4 or 6) // IHL (IP Header Length in 32-bit words) // TOS, Length, Id, Flags, FragOffset, TTL, Protocol (TCP?), // Checksum, SrcIP, DstIP fmt.Printf(\"From %s to %s\\n\", ip.SrcIP, ip.DstIP) fmt.Println(\"Protocol: \", ip.Protocol) fmt.Println() } // Let's see if the packet is TCP tcpLayer := packet.Layer(layers.LayerTypeTCP) if tcpLayer != nil { fmt.Println(\"TCP layer detected.\") tcp, _ := tcpLayer.(*layers.TCP) // TCP layer variables: // SrcPort, DstPort, Seq, Ack, DataOffset, Window, Checksum, Urgent // Bool flags: FIN, SYN, RST, PSH, ACK, URG, ECE, CWR, NS fmt.Printf(\"From port %d to %d\\n\", tcp.SrcPort, tcp.DstPort) fmt.Println(\"Sequence number: \", tcp.Seq) fmt.Println() } // Iterate over all layers, printing out each layer type fmt.Println(\"All packet layers:\") for _, layer := range packet.Layers() { fmt.Println(\"- \", layer.LayerType()) } // When iterating through packet.Layers() above, // if it lists Payload layer then that is the same as // this applicationLayer. applicationLayer contains the payload applicationLayer := packet.ApplicationLayer() if applicationLayer != nil { fmt.Println(\"Application layer/Payload found.\") fmt.Printf(\"%s\\n\", applicationLayer.Payload()) // Search for a string inside the payload if strings.Contains(string(applicationLayer.Payload()), \"HTTP\") { fmt.Println(\"HTTP found!\") } } // Check for errors if err := packet.ErrorLayer(); err != nil { fmt.Println(\"Error decoding some part of the packet:\", err) } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:6","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"创建和发送 packet 下面这个例子做了几个事情。首先，它将演示如何使用网络设备发送原始字节。这样，您就可以像串行连接(serial connection) 一样使用它来发送数据。这对于真正的低层的数据传输很有用，但是如果你想与一个应用程序交互，你可能想建立硬件和软件都能识别的包。 接下来，它将演示如何使用 ethernet、IP 和 TCP 层创建数据包。所有的东西都是默认的和空的，所以它实际上不做任何事情。 为了完成它，我们创建了另一个数据包，但实际上为 ethernet 层填充了一些 MAC 地址，为 IPv4 填充了一些 IP 地址，为 TCP 层填充了一些端口号。您应该看到如何用它伪造数据包和模拟设备。 TCP 层结构具有可读取或设置的 SYN, FIN, and ACK 布尔标志。这有利于控制和模糊 TCP 握手、会话和端口扫描。 pcap 库提供了一个发送字节的简单方法，但是 gopacket 中的 layers 包帮助我们为各个层创建字节结构。 package main import ( \"github.com/google/gopacket\" \"github.com/google/gopacket/layers\" \"github.com/google/gopacket/pcap\" \"log\" \"net\" \"time\" ) var ( device string = \"eth0\" snapshot_len int32 = 1024 promiscuous bool = false err error timeout time.Duration = 30 * time.Second handle *pcap.Handle buffer gopacket.SerializeBuffer options gopacket.SerializeOptions ) func main() { // Open device handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout) if err != nil {log.Fatal(err) } defer handle.Close() // Send raw bytes over wire rawBytes := []byte{10, 20, 30} err = handle.WritePacketData(rawBytes) if err != nil { log.Fatal(err) } // Create a properly formed packet, just with // empty details. Should fill out MAC addresses, // IP addresses, etc. buffer = gopacket.NewSerializeBuffer() gopacket.SerializeLayers(buffer, options, \u0026layers.Ethernet{}, \u0026layers.IPv4{}, \u0026layers.TCP{}, gopacket.Payload(rawBytes), ) outgoingPacket := buffer.Bytes() // Send our packet err = handle.WritePacketData(outgoingPacket) if err != nil { log.Fatal(err) } // This time lets fill out some information ipLayer := \u0026layers.IPv4{ SrcIP: net.IP{127, 0, 0, 1}, DstIP: net.IP{8, 8, 8, 8}, } ethernetLayer := \u0026layers.Ethernet{ SrcMAC: net.HardwareAddr{0xFF, 0xAA, 0xFA, 0xAA, 0xFF, 0xAA}, DstMAC: net.HardwareAddr{0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD}, } tcpLayer := \u0026layers.TCP{ SrcPort: layers.TCPPort(4321), DstPort: layers.TCPPort(80), } // And create the packet with the layers buffer = gopacket.NewSerializeBuffer() gopacket.SerializeLayers(buffer, options, ethernetLayer, ipLayer, tcpLayer, gopacket.Payload(rawBytes), ) outgoingPacket = buffer.Bytes() } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:7","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"更多创建和解码 packet 的例子 package main import ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/layers\" ) func main() { // If we don't have a handle to a device or a file, but we have a bunch // of raw bytes, we can try to decode them in to packet information // NewPacket() takes the raw bytes that make up the packet as the first parameter // The second parameter is the lowest level layer you want to decode. It will // decode that layer and all layers on top of it. The third layer // is the type of decoding: default(all at once), lazy(on demand), and NoCopy // which will not create a copy of the buffer // Create an packet with ethernet, IP, TCP, and payload layers // We are creating one we know will be decoded properly but // your byte source could be anything. If any of the packets // come back as nil, that means it could not decode it in to // the proper layer (malformed or incorrect packet type) payload := []byte{2, 4, 6} options := gopacket.SerializeOptions{} buffer := gopacket.NewSerializeBuffer() gopacket.SerializeLayers(buffer, options, \u0026layers.Ethernet{}, \u0026layers.IPv4{}, \u0026layers.TCP{}, gopacket.Payload(payload), ) rawBytes := buffer.Bytes() // Decode an ethernet packet ethPacket := gopacket.NewPacket( rawBytes, layers.LayerTypeEthernet, gopacket.Default, ) // with Lazy decoding it will only decode what it needs when it needs it // This is not concurrency safe. If using concurrency, use default ipPacket := gopacket.NewPacket( rawBytes, layers.LayerTypeIPv4, gopacket.Lazy, ) // With the NoCopy option, the underlying slices are referenced // directly and not copied. If the underlying bytes change so will // the packet tcpPacket := gopacket.NewPacket( rawBytes, layers.LayerTypeTCP, gopacket.NoCopy, ) fmt.Println(ethPacket) fmt.Println(ipPacket) fmt.Println(tcpPacket) } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:8","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"定制层 下一个程序将演示如何创建您自己的层。这有助于实现当前不包含在 gopacket layers 包中的协议。如果您想创建自己的 l33t 协议，甚至不使用 TCP/IP 或 ethernet，那么它也很有用。 package main import ( \"fmt\" \"github.com/google/gopacket\" ) // Create custom layer structure type CustomLayer struct { // This layer just has two bytes at the front SomeByte byte AnotherByte byte restOfData []byte } // Register the layer type so we can use it // The first argument is an ID. Use negative // or 2000+ for custom layers. It must be unique var CustomLayerType = gopacket.RegisterLayerType( 2001, gopacket.LayerTypeMetadata{ \"CustomLayerType\", gopacket.DecodeFunc(decodeCustomLayer), }, ) // When we inquire about the type, what type of layer should // we say it is? We want it to return our custom layer type func (l CustomLayer) LayerType() gopacket.LayerType { return CustomLayerType } // LayerContents returns the information that our layer // provides. In this case it is a header layer so // we return the header information func (l CustomLayer) LayerContents() []byte { return []byte{l.SomeByte, l.AnotherByte} } // LayerPayload returns the subsequent layer built // on top of our layer or raw payload func (l CustomLayer) LayerPayload() []byte { return l.restOfData } // Custom decode function. We can name it whatever we want // but it should have the same arguments and return value // When the layer is registered we tell it to use this decode function func decodeCustomLayer(data []byte, p gopacket.PacketBuilder) error { // AddLayer appends to the list of layers that the packet has p.AddLayer(\u0026CustomLayer{data[0], data[1], data[2:]}) // The return value tells the packet what layer to expect // with the rest of the data. It could be another header layer, // nothing, or a payload layer. // nil means this is the last layer. No more decoding // return nil // Returning another layer type tells it to decode // the next layer with that layer's decoder function // return p.NextDecoder(layers.LayerTypeEthernet) // Returning payload type means the rest of the data // is raw payload. It will set the application layer // contents with the payload return p.NextDecoder(gopacket.LayerTypePayload) } func main() { // If you create your own encoding and decoding you can essentially // create your own protocol or implement a protocol that is not // already defined in the layers package. In our example we are just // wrapping a normal ethernet packet with our own layer. // Creating your own protocol is good if you want to create // some obfuscated binary data type that was difficult for others // to decode // Finally, decode your packets: rawBytes := []byte{0xF0, 0x0F, 65, 65, 66, 67, 68} packet := gopacket.NewPacket( rawBytes, CustomLayerType, gopacket.Default, ) fmt.Println(\"Created packet out of raw bytes.\") fmt.Println(packet) // Decode the packet as our custom layer customLayer := packet.Layer(CustomLayerType) if customLayer != nil { fmt.Println(\"Packet was successfully decoded with custom layer decoder.\") customLayerContent, _ := customLayer.(*CustomLayer) // Now we can access the elements of the custom struct fmt.Println(\"Payload: \", customLayerContent.LayerPayload()) fmt.Println(\"SomeByte element:\", customLayerContent.SomeByte) fmt.Println(\"AnotherByte element:\", customLayerContent.AnotherByte) } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:9","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"更快地解码 packet 如果我们知道需要什么层，我们可以使用已有的结构来存储 packet 信息，而不是为每个 packet 创建新的结构，既浪费内存又浪费时间。使用 DecodingLayerParser 可以更快一点。这就像 marshalling/unmarshalling 数据一样。 package main import ( \"fmt\" \"github.com/google/gopacket\" \"github.com/google/gopacket/layers\" \"github.com/google/gopacket/pcap\" \"log\" \"time\" ) var ( device string = \"eth0\" snapshot_len int32 = 1024 promiscuous bool = false err error timeout time.Duration = 30 * time.Second handle *pcap.Handle // Will reuse these for each packet ethLayer layers.Ethernet ipLayer layers.IPv4 tcpLayer layers.TCP ) func main() { // Open device handle, err = pcap.OpenLive(device, snapshot_len, promiscuous, timeout) if err != nil { log.Fatal(err) } defer handle.Close() packetSource := gopacket.NewPacketSource(handle, handle.LinkType()) for packet := range packetSource.Packets() { parser := gopacket.NewDecodingLayerParser( layers.LayerTypeEthernet, \u0026ethLayer, \u0026ipLayer, \u0026tcpLayer, ) foundLayerTypes := []gopacket.LayerType{} err := parser.DecodeLayers(packet.Data(), \u0026foundLayerTypes) if err != nil { fmt.Println(\"Trouble decoding layers: \", err) } for _, layerType := range foundLayerTypes { if layerType == layers.LayerTypeIPv4 { fmt.Println(\"IPv4: \", ipLayer.SrcIP, \"-\u003e\", ipLayer.DstIP) } if layerType == layers.LayerTypeTCP { fmt.Println(\"TCP Port: \", tcpLayer.SrcPort, \"-\u003e\", tcpLayer.DstPort) fmt.Println(\"TCP SYN:\", tcpLayer.SYN, \" | ACK:\", tcpLayer.ACK) } } } } ","date":"2022-02-06","objectID":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/:5:10","tags":["Go 库"],"title":"Go gopacket 库","uri":"/Notes/posts/golang/%E5%B8%B8%E7%94%A8%E5%BA%93/gopacket/"},{"categories":["Golang"],"content":"flag Go 语言内置的 flag 包实现了命令行参数的解析，flag 包使得开发命令行工具更为简单。 ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:0:0","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"参数类型 flag 包支持的命令行参数类型有 bool、int、int64、uint、uint64、float、float64、string、duration，如下表所示： flag 参数 有效值 字符串 合法字符串 整数 1234、0664、0x1234 等类型，也可以是负数 浮点数 合法浮点数 bool 1、0、t、f、T、F、true、false、TRUE、FALSE、True、False 时间段 任何合法的时间段字符串，如 “300ms”、“-1.5h”、“2h45m”，合法的单位有 “ns”、“us”、“µs”、“ms”、“s”、“m”、“h” ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:1:0","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"基本使用 有以下两种常用的定义命令行 flag 参数的方法： ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:2:0","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"flag.Type() 基本格式如下： flag.Type(flag 名, 默认值, 帮助信息) *Type Type 可以是 Int、String、Bool 等，返回值为一个相应类型的指针 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义： name := flag.String(\"name\", \"张三\", \"姓名\") age := flag.Int(\"age\", 18, \"年龄\") married := flag.Bool(\"married\", false, \"婚否\") delay := flag.Duration(\"d\", 0, \"时间间隔\") 需要注意的是，此时 name、age、married、delay 均为对应类型的指针。 ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:2:1","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"flag.TypeVar() 基本格式如下： flag.TypeVar(Type 指针, flag 名, 默认值, 帮助信息) TypeVar 可以是 IntVar、StringVar、BoolVar 等，其功能为将 flag 绑定到一个变量上 例如我们要定义姓名、年龄、婚否三个命令行参数，我们可以按如下方式定义： var name string var age int var married bool var delay time.Duration flag.StringVar(\u0026name, \"name\", \"张三\", \"姓名\") flag.IntVar(\u0026age, \"age\", 18, \"年龄\") flag.BoolVar(\u0026married, \"married\", false, \"婚否\") flag.DurationVar(\u0026delay, \"d\", 0, \"时间间隔\") ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:2:2","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"flag.Parse() 通过以上两种方法定义好命令行 flag 参数后，需要通过调用 flag.Parse() 来对命令行参数进行解析。 支持的命令行参数格式有以下几种： -flag xxx （使用空格，一个-符号） --flag xxx （使用空格，两个-符号） -flag=xxx （使用等号，一个-符号） --flag=xxx （使用等号，两个-符号） 其中，布尔类型的参数必须使用等号的方式指定。 Flag 解析在第一个非 flag 参数（单个 ”-“ 不是 flag 参数）之前停止，或者在终止符”–“之后停止。 其中，布尔类型的参数必须使用等号的方式指定。 flag 包的其他函数： flag.Args() //返回命令行参数后的其他参数，以 []string 类型 flag.NArg() //返回命令行参数后的其他参数个数 flag.NFlag() //返回使用的命令行参数个数 结合上面的介绍知识，我们来看一个实例，代码如下： package main import ( \"flag\" \"fmt\" ) var Input_pstrName = flag.String(\"name\", \"gerry\", \"input ur name\") var Input_piAge = flag.Int(\"age\", 20, \"input ur age\") var Input_flagvar int func Init() { flag.IntVar(\u0026Input_flagvar, \"flagname\", 1234, \"help message for flagname\") } func main() { Init() flag.Parse() // After parsing, the arguments after the flag are available as the slice flag.Args() or individually as flag.Arg(i). The arguments are indexed from 0 through flag.NArg()-1 // Args returns the non-flag command-line arguments // NArg is the number of arguments remaining after flags have been processed fmt.Printf(\"args=%s, num=%d\\n\", flag.Args(), flag.NArg()) for i := 0; i != flag.NArg(); i++ { fmt.Printf(\"arg[%d]=%s\\n\", i, flag.Arg(i)) } fmt.Println(\"name=\", *Input_pstrName) fmt.Println(\"age=\", *Input_piAge) fmt.Println(\"flagname=\", Input_flagvar) } 运行结果如下： go run main.go -name \"aaa\" -age=123 -flagname=999 args=[], num=0 name= aaa age= 123 flagname= 999 ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:2:3","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"自定义 Value 另外，我们还可以创建自定义 flag，只要实现 flag.Value 接口即可（要求 receiver 是指针类型），这时候可以通过如下方式定义该 flag： flag.Var(\u0026flagVal, \"name\", \"help message for flagname\") 例：解析喜欢的编程语言，并直接解析到 slice 中，我们可以定义如下 sliceValue 类型，然后实现 Value 接口 package main import ( \"flag\" \"fmt\" \"strings\" ) // 定义一个类型，用于增加该类型方法 type sliceValue []string // new一个存放命令行参数值的slice func newSliceValue(vals []string, p *[]string) *sliceValue { *p = vals return (*sliceValue)(p) } /* Value接口： type Value interface { String() string Set(string) error } 实现flag包中的Value接口，将命令行接收到的值用,分隔存到slice里 */ func (s *sliceValue) Set(val string) error { *s = sliceValue(strings.Split(val, \",\")) return nil } // flag为slice的默认值default is me,和return返回值没有关系 func (s *sliceValue) String() string { *s = sliceValue(strings.Split(\"default is me\", \",\")) return \"It's none of my business\" } /* 可执行文件名 -slice=\"java,go\" 最后将输出[java,go] 可执行文件名 最后将输出[default is me] */ func main(){ var languages []string flag.Var(newSliceValue([]string{}, \u0026languages), \"slice\", \"I like programming `languages`\") flag.Parse() // 打印结果slice接收到的值 fmt.Println(languages) } 通过 -slice go,php 这样的形式传递参数，languages 得到的就是 [go, php]，如果不加 -slice 参数则打印默认值 [default is me]，如下所示： go run main.go -slice go,php,java [go php java] flag 中对 Duration 这种非基本类型的支持，使用的就是类似这样的方式，即同样实现了 Value 接口。 ","date":"2022-02-05","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/:3:0","tags":["Go 库"],"title":"Go flag 库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/flag/"},{"categories":["Golang"],"content":"fmt fmt 包实现了格式化 I/O 函数，类似于 C 的 printf 和 scanf；格式“占位符”衍生自 C，但比 C 更简单。 以下例子中用到的类型或变量定义： type Website struct { Name string } // 定义结构体变量 var site = Website{Name:\"studygolang\"} ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:0:0","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"输出 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:1:0","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"函数类型 Print Print 系列函数会将内容输出到系统的标准输出，区别在于 Print 函数直接输出内容 Printf 函数支持格式化输出字符串 Println 函数会在输出内容的结尾添加一个换行符。 func Print(a ...interface{}) (n int, err error) func Printf(format string, a ...interface{}) (n int, err error) func Println(a ...interface{}) (n int, err error) Fprint Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。 func Fprint(w io.Writer, a ...interface{}) (n int, err error) func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error) func Fprintln(w io.Writer, a ...interface{}) (n int, err error) 例 // 向标准输出写入内容 fmt.Fprintln(os.Stdout, \"向标准输出写入内容\") fileObj, err := os.OpenFile(\"./xx.txt\", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644) if err != nil { fmt.Println(\"打开文件出错，err:\", err) return } name := \"枯藤\" // 向打开的文件句柄中写入内容 fmt.Fprintf(fileObj, \"往文件中写如信息：%s\", name) Sprint Sprint系列函数会把传入的数据生成并返回一个字符串。 func Sprint(a ...interface{}) string func Sprintf(format string, a ...interface{}) string func Sprintln(a ...interface{}) string 例 s1 := fmt.Sprint(\"枯藤\") name := \"枯藤\" age := 18 s2 := fmt.Sprintf(\"name:%s,age:%d\", name, age) s3 := fmt.Sprintln(\"枯藤\") fmt.Println(s1, s2, s3) Errorf Errorf 函数根据 format 参数生成格式化字符串并返回一个包含该字符串的错误。 func Errorf(format string, a ...interface{}) error 通常使用这种方式来自定义错误类型，例如： err := fmt.Errorf(\"这是一个错误\") ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:1:1","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"格式化占位符 *printf 系列函数都支持 format 格式化参数 通用占位符 占位符 说明 %v 值的默认格式表示 %+v 类似 %v，但输出结构体时会添加字段名 %#v 值的 Go 语法表示 %T 打印值的类型 %% 百分号 例 fmt.Printf(\"%v\\n\", 100) fmt.Printf(\"%v\\n\", false) o := struct{ name string }{\"枯藤\"} fmt.Printf(\"%v\\n\", o) fmt.Printf(\"%#v\\n\", o) fmt.Printf(\"%T\\n\", o) fmt.Printf(\"100%%\\n\") 输出结果如下： 100 false {枯藤} struct { name string }{name:\"枯藤\"} struct { name string } 100% 布尔值 占位符 说明 %t true 或 false 整型 占位符 说明 %b 表示为二进制 %c 该值对应的 unicode 码值 %d 表示为十进制 %o 表示为八进制 %x 表示为十六进制，使用 a-f %X 表示为十六进制，使用 A-F %U 表示为 Unicode 格式：U+1234，等价于 ”U+%04X” %q 该值对应的单引号括起来的 go 语法字符字面值，必要时会采用安全的转义表示 例： n := 65 fmt.Printf(\"%b\\n\", n) fmt.Printf(\"%c\\n\", n) fmt.Printf(\"%d\\n\", n) fmt.Printf(\"%o\\n\", n) fmt.Printf(\"%x\\n\", n) fmt.Printf(\"%X\\n\", n) 输出结果如下： 1000001 A 65 101 41 41 浮点数与复数 占位符 说明 %b 无小数部分、二进制指数的科学计数法，如 -123456p-78 %e 科学计数法，如 -1234.456e+78 %E 科学计数法，如 -1234.456E+78 %f 有小数部分但无指数部分，如 123.456 %F 等价于 %f %g 根据实际情况采用 %e 或 %f 格式（以获得更简洁、准确的输出） %G 根据实际情况采用 %E 或 %F 格式（以获得更简洁、准确的输出） 例： f := 12.34 fmt.Printf(\"%b\\n\", f) fmt.Printf(\"%e\\n\", f) fmt.Printf(\"%E\\n\", f) fmt.Printf(\"%f\\n\", f) fmt.Printf(\"%g\\n\", f) fmt.Printf(\"%G\\n\", f) 输出结果如下： 6946802425218990p-49 1.234000e+01 1.234000E+01 12.340000 12.34 12.34 字符串和 byte[] 占位符 说明 %s 直接输出字符串或者 []byte %q 该值对应的双引号括起来的 go 语法字符串字面值，必要时会采用安全的转义表示 %x 每个字节用两字符十六进制数表示（使用 a-f） %X 每个字节用两字符十六进制数表示（使用 A-F） 例： s := \"枯藤\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%q\\n\", s) fmt.Printf(\"%x\\n\", s) fmt.Printf(\"%X\\n\", s) 输出结果如下： 枯藤 \"枯藤\" e69eafe897a4 E69EAFE897A4 指针 占位符 说明 %p 表示为十六进制，并加上前导的 0x 例： a := 18 fmt.Printf(\"%p\\n\", \u0026a) fmt.Printf(\"%#p\\n\", \u0026a) 输出结果如下： 0xc000054058 c000054058 宽度标识符 宽度通过一个紧跟在百分号后面的十进制数指定，如果未指定宽度，则表示值时除必需之外不作填充。 精度通过（可选的）宽度后跟点号后跟的十进制数指定。 如果未指定精度，会使用默认精度； 如果点号后没有跟数字，表示精度为0。举例如下 占位符 说明 %f 默认宽度，默认精度 %9f 宽度 9，默认精度 %.2f 默认宽度，精度 2 %9.2f 宽度 9，精度 2 %9.f 宽度 9，精度 0 例： n := 88.88 fmt.Printf(\"%f\\n\", n) fmt.Printf(\"%9f\\n\", n) fmt.Printf(\"%.2f\\n\", n) fmt.Printf(\"%9.2f\\n\", n) fmt.Printf(\"%9.f\\n\", n) 输出结果如下： 88.880000 88.880000 88.88 88.88 89 其他 占位符 说明 ’+’ 总是输出数值的正负号；对 %q（%+q）会生成全部是 ASCII 字符的输出（通过转义）； ’ ‘ 对数值，正数前加空格而负数前加负号；对字符串采用 %x 或 %X 时（% x 或 % X）会给各打印的字节之间加空格 ’-’ 在输出右边填充空白而不是默认的左边（即从默认的右对齐切换为左对齐）； ’#’ 八进制数前加 0（%#o），十六进制数前加 0x（%#x）或 0X（%#X），指针去掉前面的 0x（%#p）对 %q（%#q），对 %U（%#U）会输出空格和单引号括起来的 go 字面值； ‘0’ 使用 0 而不是空格填充，对于数值类型会把填充的 0 放在正负号后面； 例： s := \"枯藤\" fmt.Printf(\"%s\\n\", s) fmt.Printf(\"%5s\\n\", s) fmt.Printf(\"%-5s\\n\", s) fmt.Printf(\"%5.7s\\n\", s) fmt.Printf(\"%-5.7s\\n\", s) fmt.Printf(\"%5.2s\\n\", s) fmt.Printf(\"%05s\\n\", s) 输出结果如下： 枯藤 枯藤 枯藤 枯藤 枯藤 枯藤 000枯藤 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:1:2","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"输入 Go 语言 fmt 包下有 fmt.Scan、fmt.Scanf、fmt.Scanln 三个函数，可以在程序运行过程中从标准输入获取用户的输入。 Scanln 和 Scanf 都会吸收掉上次输入的回车符，所以使用时在前面加一个 fmt.Scanln() ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:0","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"scan fmt.Scan 从标准输入中扫描用户输入的数据，将以空白符分隔的数据分别存入指定的参数。 func Scan(a ...interface{}) (n int, err error) Scan 从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。 本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。 例如下： func main() { var ( name string age int married bool ) fmt.Scan(\u0026name, \u0026age, \u0026married) fmt.Printf(\"扫描结果 name:%s age:%d married:%t \\n\", name, age, married) } 将上面的代码编译后在终端执行，在终端依次输入枯藤、18和false使用空格分隔。 $ ./scan_demo 枯藤 18 false 扫描结果 name:枯藤 age:18 married:false ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:1","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"scanf func Scanf(format string, a ...interface{}) (n int, err error) Scanf 从标准输入扫描文本，根据 format 参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。 本函数返回成功扫描的数据个数和遇到的任何错误。 例如下： func main() { var ( name string age int married bool ) fmt.Scanf(\"1:%s 2:%d 3:%t\", \u0026name, \u0026age, \u0026married) fmt.Printf(\"扫描结果 name:%s age:%d married:%t \\n\", name, age, married) } 将上面的代码编译后在终端执行，在终端按照指定的格式依次输入枯藤、18 和 false。 $ ./scan_demo 1:枯藤 2:18 3:false 扫描结果 name:枯藤 age:18 married:false fmt.Scanf 不同于 fmt.Scan 简单的以空格作为输入数据的分隔符，fmt.Scanf 为输入数据指定了具体的输入内容格式，只有按照格式输入数据才会被扫描并存入对应变量。 例如，我们还是按照上个示例中以空格分隔的方式输入，fmt.Scanf 就不能正确扫描到输入的数据。 $ ./scan_demo 枯藤 18 false 扫描结果 name: age:0 married:false ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:2","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"scanln func Scanln(a ...interface{}) (n int, err error) Scanln 类似 Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。 本函数返回成功扫描的数据个数和遇到的任何错误。 具体代码示例如下： func main() { var ( name string age int married bool ) fmt.Scanln(\u0026name, \u0026age, \u0026married) fmt.Printf(\"扫描结果 name:%s age:%d married:%t \\n\", name, age, married) } 将上面的代码编译后在终端执行，在终端依次输入枯藤、18 和 false 使用空格分隔。 $ ./scan_demo 枯藤 18 false 扫描结果 name:枯藤 age:18 married:false fmt.Scanln 遇到回车就结束扫描了，这个比较常用。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:3","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"bufio.NewReader 有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用 bufio 包来实现。示例代码如下： func bufioDemo() { reader := bufio.NewReader(os.Stdin) // 从标准输入生成读对象 fmt.Print(\"请输入内容：\") text, _ := reader.ReadString('\\n') // 读到换行 text = strings.TrimSpace(text) fmt.Printf(\"%#v\\n\", text) } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:4","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"Fscan 系列 这几个函数功能类似于 fmt.Scan、fmt.Scanf、fmt.Scanln 三个函数，只不过它们从 io.Reader 中读取数据。 func Fscan(r io.Reader, a ...interface{}) (n int, err error) func Fscanln(r io.Reader, a ...interface{}) (n int, err error) func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err error) ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:5","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"Sscan系列 这几个函数功能类似于 fmt.Scan、fmt.Scanf、fmt.Scanln 三个函数，只不过它们从指定字符串中读取数据。 func Sscan(str string, a ...interface{}) (n int, err error) func Sscanln(str string, a ...interface{}) (n int, err error) func Sscanf(str string, format string, a ...interface{}) (n int, err error) ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/:2:6","tags":["Go 库","io"],"title":"Go fmt 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/fmt/"},{"categories":["Golang"],"content":"net ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:0:0","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"net 包 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:1:0","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"lookUp 地址信息查找 //InterfaceAddrs 返回该系统的网络接口的地址列表。 addr, _ := net.InterfaceAddrs() fmt.Println(addr) //Interfaces 返回该系统的网络接口列表 interfaces, _ := net.Interfaces() fmt.Println(interfaces) //LookupAddr 查询某个地址，返回映射到该地址的主机名序列 lt, _ := net.LookupAddr(\"www.alibaba.com\") fmt.Println(lt) //LookupCNAME函数查询name的规范DNS名（但该域名未必可以访问）。 cname, _ := net.LookupCNAME(\"www.baidu.com\") fmt.Println(cname) //LookupHost函数查询主机的网络地址序列。 host, _ := net.LookupHost(\"www.baidu.com\") fmt.Println(host) //LookupIP函数查询主机的ipv4和ipv6地址序列。 ip, _ := net.LookupIP(\"www.baidu.com\") fmt.Println(ip) fe80::f443:30bc:69ae:c20c/64 26.26.26.1/29 fe80::2862:dc98:645c:ca9b/64 172.28.224.1/20 fe80::9560:74e7:713e:fce1/64 169.254.252.225/16 {13 1500 LetsTAP 00:ff:ca:db:b8:7d 0} {56 1500 vEthernet (WSL) 00:15:5d:17:45:20 up|broadcast|multicast} {19 1500 本地连接* 1 dc:71:96:6f:ba:59 broadcast|multicast} {9 1500 本地连接* 2 de:71:96:6f:ba:58 broadcast|multicast} {3 1500 WLAN dc:71:96:6f:ba:58 up|broadcast|multicast} ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:1:1","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"地址操作 //函数将host和port合并为一个网络地址。一般格式为\"host:port\"；如果host含有冒号或百分号，格式为\"[host]:port\"。 //Ipv6的文字地址或者主机名必须用方括号括起来，如\"[::1]:80\"、\"[ipv6-host]:http\"、\"[ipv6-host%zone]:80\"。 hp := net.JoinHostPort(\"127.0.0.1\", \"8080\") fmt.Println(hp) //函数将格式为\"host:port\"、\"[host]:port\"或\"[ipv6-host%zone]:port\"的网络地址分割为host或ipv6-host%zone和port两个部分。 shp,port,_ := net.SplitHostPort(\"127.0.0.1:8080\") fmt.Println(shp,\" _ \",port) ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:1:2","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"错误说明 接口定义： type Error interface { error Timeout() bool // 错误是否为超时？ Temporary() bool // 错误是否是临时的？ } 读取主机 DNS 配置时出现的错误。 // DNSError represents a DNS lookup error. type DNSError struct { Err string // description of the error Name string // name looked for Server string // server used IsTimeout bool // if true, timed out; not all timeouts set this IsTemporary bool // if true, error is temporary; not all errors set this IsNotFound bool // if true, host could not be found } DNS 查询的错误。 // DNSError represents a DNS lookup error. type DNSError struct { Err string // description of the error Name string // name looked for Server string // server used IsTimeout bool // if true, timed out; not all timeouts set this IsTemporary bool // if true, error is temporary; not all errors set this IsNotFound bool // if true, host could not be found } 地址错误 type AddrError struct { Err string Addr string } 返回该错误的操作、网络类型和网络地址。 // OpError is the error type usually returned by functions in the net // package. It describes the operation, network type, and address of // an error. type OpError struct ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:1:3","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"TCP 连接 客户端 和服务端建立一个链接 进行数据的收发 关闭链接 package main import ( \"bufio\" \"fmt\" \"net\" \"os\" \"strings\" ) func main() { //1.建立一个链接（Dial拨号） conn, err := net.Dial(\"tcp\", \"0.0.0.0:20000\") if err != nil { fmt.Printf(\"dial failed, err:%v\\n\", err) return } fmt.Println(\"Conn Established...:\") //读入输入的信息 reader := bufio.NewReader(os.Stdin) for { data, err := reader.ReadString('\\n') if err != nil { fmt.Printf(\"read from console failed, err:%v\\n\", err) break } data = strings.TrimSpace(data) //传输数据到服务端 _, err = conn.Write([]byte(data)) if err != nil { fmt.Printf(\"write failed, err:%v\\n\", err) break } } } 服务端 监听端口 接受客户端的链接 创建 Goroutine，处理这个链接 (一个服务端要链接多个客户端，所以使用 Goroutine 非常简单) package main import ( \"fmt\" \"net\" ) func main() { //1.建立监听端口 listen, err := net.Listen(\"tcp\", \"0.0.0.0:20000\") if err != nil { fmt.Println(\"listen failed, err:\", err) return } fmt.Println(\"listen Start...:\") for { //2.接收客户端的链接 conn, err := listen.Accept() if err != nil { fmt.Printf(\"accept failed, err:%v\\n\", err) continue } //3.开启一个Goroutine，处理链接 go process(conn) } } //处理请求，类型就是net.Conn func process(conn net.Conn) { //处理结束后关闭链接 defer conn.Close() for { var buf [128]byte n, err := conn.Read(buf[:]) if err != nil { fmt.Printf(\"read from conn failed, err:%v\", err) break } fmt.Printf(\"recv from client, content:%v\\n\", string(buf[:n])) } } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:1:4","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"net/http 包 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:2:0","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"连接、监听 //get方法调用 resp, err := http.Get(\"http://example.com/\") //post方法调用 resp, err := http.Post(\"http://example.com/upload\", \"image/jpeg\", \u0026buf) //表单方式调用 resp, err := http.PostForm(\"http://example.com/form\", url.Values{\"key\": {\"Value\"}, \"id\": {\"123\"}}) //服务端进行监听端口 func (srv *Server) ListenAndServe() error ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:2:1","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"管理 HTTP 客户端的头域、重定向策略和其他设置 创建 Client，发送设置好的 request client := \u0026http.Client{CheckRedirect: redirectPolicyFunc,} resp, err := client.Get(\"http://example.com\") req, err := http.NewRequest(\"GET\", \"http://example.com\", nil) //创建一个request req.Header.Add(\"If-None-Match\", `W/\"wyzzy\"`) //设置头部 resp, err := client.Do(req) ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:2:2","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"管理代理、TLS 配置、keep-alive、压缩和其他设置 创建一个携带设置好的 Transport 信息的 Client，并进行通信 tr := \u0026http.Transport{ TLSClientConfig: \u0026tls.Config{RootCAs: pool}, DisableCompression: true, } client := \u0026http.Client{Transport: tr} resp, err := client.Get(\"https://example.com\") ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:2:3","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"完整例子 客户端 package test import ( \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { response, _ := http.Get(\"http://localhost:80/hello\") defer response.Body.Close() body, _ := ioutil.ReadAll(response.Body) fmt.Println(string(body)) } 服务端 package test import ( \"flag\" \"fmt\" \"io/ioutil\" \"net/http\" ) func main() { host := flag.String(\"host\", \"127.0.0.1\", \"listen host\") port := flag.String(\"port\", \"80\", \"listen port\") http.HandleFunc(\"/hello\", Hello) err := http.ListenAndServe(*host+\":\"+*port, nil) if err != nil { panic(err) } } func Hello(w http.ResponseWriter, req *http.Request) { _, _ = w.Write([]byte(\"Hello World\")) } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/:2:4","tags":["Go 库"],"title":"Go net 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E7%BD%91%E7%BB%9C/net/"},{"categories":["Golang"],"content":"并发编程 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:0:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"认识 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"协程的定义 进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 线程是进程的一个执行实体，是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。 协程拥有独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 一个线程上可以跑多个协程，协程是轻量级的线程。 协程有时也被称为绿色线程。绿色线程是由程序的运行时（runtime）维护的线程。一个绿色线程的内存开销和情景转换（context switching）时耗比一个系统线程常常小得多。 只要内存充足，一个程序可以轻松支持上万个并发协程。 Go 不支持创建系统线程，所以协程是一个 Go 程序内部唯一的并发实现方式。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:1","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"并发同步 concurrency synchronization 不同的并发计算可能共享一些资源，其中共享内存资源最为常见。 在一个并发程序中，常常会发生下面的情形： 在一个计算向一段内存写数据的时候，另一个计算从此内存段读数据，结果导致读出的数据的完整性得不到保证。 在一个计算向一段内存写数据的时候，另一个计算也向此段内存写数据，结果导致被写入的数据的完整性得不到保证。 这些情形被称为数据竞争（data race）。 并发编程的一大任务就是要调度不同计算，控制它们对资源的访问时段，以使数据竞争的情况不会发生。 此任务常称为并发同步（或者数据同步）。 并发编程中的其它任务包括： 决定需要开启多少计算； 决定何时开启、阻塞、解除阻塞和结束哪些计算； 决定如何在不同的计算中分担工作负载。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:2","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"协程的状态 当一个新协程被创建的时候，它将自动进入运行状态，一个协程只能从运行状态退出而不能从阻塞状态退出。 如果因为某种原因而导致某个协程一直处于阻塞状态，则此协程将永远不会退出。 除了极个别的应用场景，在编程时我们应该尽量避免出现这样的情形。 一个处于阻塞状态的协程不会自发结束阻塞状态，它必须被另外一个协程通过某种并发同步方法来被动地结束阻塞状态。 如果一个运行中的程序当前所有的协程都出于阻塞状态，则这些协程将永远阻塞下去，程序将被视为死锁了。 当一个程序死锁后，官方标准编译器的处理是让这个程序崩溃。 比如下面这个程序将在运行两秒钟后崩溃。 package main import ( \"sync\" \"time\" ) var wg sync.WaitGroup func main() { wg.Add(1) go func() { time.Sleep(time.Second * 2) wg.Wait() // 阻塞在此 }() wg.Wait() // 阻塞在此 } 它的输出： fatal error: all goroutines are asleep - deadlock! ... ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:3","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"协程的调度 并非所有处于运行状态的协程都在执行。在任一时刻，只能最多有和逻辑 CPU 数目一样多的协程在同时执行。 因为每个逻辑 CPU 在同一时刻只能最多执行一个协程。 我们可以调用 runtime.NumCPU 函数来查询当前程序可利用的逻辑CPU数目。 Go 运行时（runtime）必须让逻辑 CPU 频繁地在不同的处于运行状态的协程之间切换，从而每个处于运行状态的协程都有机会得到执行。 这和操作系统执行系统线程的原理是一样的。 下面这张图显示了一个协程的更详细的生命周期。在此图中，运行状态被细分成了多个子状态。 一个处于排队子状态的协程等待着进入执行子状态。一个处于执行子状态的协程在被执行一会儿（非常短的时间片）之后将进入排队子状态。 注意，睡眠和等待系统调用返回子状态被认为是运行状态，而不是阻塞状态。 标准编译器采纳了一种被称为 M-P-G 模型的算法来实现协程调度。 其中，M 表示系统线程，P 表示逻辑处理器（并非上述的逻辑 CPU），G 表示协程。具体原理详见 [Go 专家编程](./进阶/Go 专家编程.md) ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:1:4","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Goroutine goroutine 奉行通过通信来共享内存，而不是共享内存来通信 goroutine 的概念类似于线程，但 goroutine 是由 Go 的运行时（runtime）调度和管理的。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"启动 单个 goroutine func hello() { fmt.Println(\"Hello Goroutine!\") } func main() { go hello() fmt.Println(\"main goroutine done!\") } 执行结果：只打印了 main goroutine done!，并没有打印 Hello Goroutine!。 原因 在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine 当 main() 函数返回的时候该 goroutine 就结束了，所有在 main() 函数中启动的 goroutine 会一同结束 创建新的 goroutine 的时候需要花费一些时间，而此时 main 函数所在的 goroutine 是继续执行的 让 main() 等一等他的子协程 func main() { go hello() // 启动另外一个goroutine去执行hello函数 fmt.Println(\"main goroutine done!\") time.Sleep(time.Second) } 多个 goroutine 这里使用了sync.WaitGroup 来实现 goroutine 的同步 var wg sync.WaitGroup func hello(i int) { defer wg.Done() // goroutine结束就登记-1 fmt.Println(\"Hello Goroutine!\", i) } func main() { for i := 0; i \u003c 10; i++ { wg.Add(1) // 启动一个goroutine就登记+1 go hello(i) } wg.Wait() // 等待所有登记的goroutine都结束 } 多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为 10 个 goroutine 是并发执行的，而goroutine 的调度是随机的。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:2:1","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Channel 通过共享内存来通讯和通过通讯来共享内存是并发编程中的两种编程风格。 当通过共享内存来通讯的时候，我们需要一些传统的并发同步技术（比如互斥锁）来避免数据竞争。 Go提供了一种独特的并发同步技术来实现通过通讯来共享内存。此技术即为通道。 我们可以把一个通道看作是在一个程序内部的一个先进先出（FIFO：first in first out）数据队列。 一些协程可以向此通道发送数据，另外一些协程可以从此通道接收数据。 随着一个数据值的传递（发送和接收），一些数据值的所有权从一个协程转移到了另一个协程。 当一个协程发送一个值到一个通道，我们可以认为此协程释放了一些值的所有权。 当一个协程从一个通道接收到一个值，我们可以认为此协程获取了一些值的所有权。 当然，在通过通道传递数据的时候，也可能没有任何所有权发生转移。 所有权发生转移的值常常被传递的值所引用着，但有时候也并非如此。 在Go中，数据所有权的转移并非体现在语法上，而是体现在逻辑上。 Go 通道可以帮助程序员轻松地避免数据竞争，但不会防止程序员因为犯错而写出错误的并发代码的情况发生。 尽管 Go 也支持几种传统的数据同步技术，但是只有通道为一等公民。 通道是 Go 中的一种类型，所以我们可以无需引进任何代码包就可以使用通道。 几种传统的数据同步技术提供在 sync 和 sync/atomic 标准库包中。 实事求是地说，每种并发同步技术都有它们各自的最佳应用场景，但是通道的应用范围更广。 使用通道来做同步常常可以使得代码看上去更整洁和易于理解。不过通道的编程体验常常很有趣（？）以至于程序员们经常在并非是通道的最佳应用场景中仍坚持使用通道。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"channel 的类型和值 和数组、切片以及映射类型一样，每个通道类型也有一个元素类型。 一个通道只能传送它的（通道类型的）元素类型的值。 通道可以是双向的，也可以是单向的。 字面形式 chan T 表示一个元素类型为 T 的双向通道类型。 编译器允许从此类型的值中接收和向此类型的值中发送数据。 字面形式 chan\u003c- T 表示一个元素类型为 T 的单向发送通道类型。 编译器不允许从此类型的值中接收数据。 字面形式 \u003c-chan T 表示一个元素类型为 T 的单向接收通道类型。 编译器不允许向此类型的值中发送数据。 双向通道 chan T 的值可以被隐式转换为单向通道类型 chan\u003c- T 和 \u003c-chan T，但反之不行（即使显式也不行）。 类型 chan\u003c- T 和 \u003c-chan T 的值也不能相互转换。 每个通道值有一个容量属性。此属性的意义将在下一节中得到解释。 一个容量为 0 的通道值称为一个非缓冲通道（unbuffered channel） 一个容量不为 0 的通道值称为一个缓冲通道（buffered channel）。 通道类型的零值也使用预声明的 nil 来表示。 一个非零通道值必须通过内置的 make 函数来创建。 比如 make(chan int, 10) 将创建一个元素类型为 int 的通道值。 第二个参数指定了欲创建的通道的容量（可选的，默认值为 0）。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:1","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"channel 值的比较 所有通道类型均为可比较类型。 一个通道值可能含有底层部分。 当一个通道值被赋给另一个通道值后，这两个通道值将共享相同的底层部分。 换句话说，这两个通道引用着同一个底层的内部通道对象。 比较这两个通道的结果为 true。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:2","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"channel 操作 Go 中有五种通道相关的操作。假设一个通道（值）为 ch，下面列出了这五种操作的语法或者函数调用。 调用内置函数 close 来关闭一个通道： close(ch) 传给 close 函数调用的实参必须为一个通道值，并且此通道值不能为单向接收的。 使用下面的语法向通道 ch 发送一个值 v： ch \u003c- v v 必须能够赋值给通道 ch 的元素类型。 ch 不能为单向接收通道。 \u003c- 称为数据发送操作符。 使用下面的语法从通道 ch 接收一个值： \u003c-ch 如果一个通道操作不永久阻塞，它总会返回至少一个值，此值的类型为通道 ch 的元素类型。 ch 不能为单向发送通道。\u003c- 称为数据接收操作符，它和数据发送操作符的表示形式一样。 在大多数场合下，一个数据接收操作可以被认为是一个单值表达式。 但是，当一个数据接收操作被用做一个赋值语句中的唯一的源值的时候，它可以返回第二个可选的 “类型不确定的布尔值” 返回值从而成为一个多值表达式。；这个 “类型不确定的布尔值” 表示第一个接收到的值是否是在通道被关闭前发送的。 从后面的章节，我们将得知我们可以从一个已关闭的通道中接收到无穷个值。 数据接收操作在赋值中被用做源值的例子： v = \u003c-ch v, sentBeforeClosed = \u003c-ch 查询一个通道的容量： cap(ch) cap() 是一个内置函数。其返回值的类型为内置类型 int。 查询一个通道的长度： len(ch) len() 是一个内置函数。其返回值的类型也为内置类型 int。 一个通道的长度是指当前有多少个已被发送到此通道但还未被接收出去的元素值。 Go 中大多数的基本操作都是未同步的。换句话说，它们都不是并发安全的。 这些操作包括赋值、传参、和各种容器值操作等。 但是，上面列出的五种通道相关的操作都已经同步过了，因此它们可以在并发协程中安全运行而无需其它同步操作。 注意：通道的赋值和其它类型值的赋值一样，是未同步的。 同样，将刚从一个通道接收出来的值赋给另一个值也是未同步的。 如果被查询的通道为一个 nil 零值通道，则 cap 和 len 函数调用都返回 0。 这两个操作是如此简单，所以后面将不再对它们进行详解。 事实上，这两个操作在实践中很少使用。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:3","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"⭐ channel 操作详解 为了让解释简单清楚，在本文后续部分，通道将被归为三类： 零值（nil）通道； 非零值但已关闭的通道； 非零值并且尚未关闭的通道。 下表简单地描述了三种通道操作施加到三类通道的结果。 操作 一个零值 nil 通道 一个非零值但已关闭的通道 一个非零值且尚未关闭的通道 关闭 产生恐慌 产生恐慌 成功关闭 (C) 发送数据 永久阻塞 产生恐慌 阻塞或者成功发送 (B) 接收数据 永久阻塞 永不阻塞 (D) 阻塞或者成功接收 (A) 对于上表中的五种未打上标的情形，规则很简单： 关闭一个 nil 通道或者一个已经关闭的通道将产生一个恐慌。 向一个已关闭的通道发送数据也将导致一个恐慌。 向一个 nil 通道发送数据或者从一个 nil 通道接收数据将使当前协程永久阻塞。 下面将详细解释其它四种被打了上标（A/B/C/D）的情形。 channel 大致的内部实现 为了更好地理解通道和为了后续讲解方便，先了解一下通道类型的大致内部实现是很有帮助的。 我们可以认为一个通道内部维护了三个队列（均可被视为先进先出队列）： 接收数据协程队列（可以看做是先进先出队列但其实并不完全是，见下面解释）。此队列是一个没有长度限制的链表。 此队列中的协程均处于阻塞状态，它们正等待着从此通道接收数据。 发送数据协程队列（可以看做是先进先出队列但其实并不完全是，见下面解释）。此队列也是一个没有长度限制的链表。 此队列中的协程亦均处于阻塞状态，它们正等待着向此通道发送数据。 此队列中的每个协程将要发送的值（或者此值的指针，取决于具体编译器实现）和此协程一起存储在此队列中。 数据缓冲队列。这是一个循环队列（绝对先进先出），它的长度为此通道的容量。此队列中存放的值的类型都为此通道的元素类型。 如果此队列中当前存放的值的个数已经达到此通道的容量，则我们说此通道已经处于满槽状态。 如果此队列中当前存放的值的个数为零，则我们说此通道处于空槽状态。 对于一个非缓冲通道（容量为零），它总是同时处于满槽状态和空槽状态。 每个通道内部维护着一个互斥锁用来在各种通道操作中防止数据竞争。 channel 操作情形 通道操作情形 A： 当一个协程 R 尝试从一个非零且尚未关闭的通道接收数据的时候，此协程 R 将首先尝试获取此通道的锁，成功之后将执行下列步骤，直到其中一个步骤的条件得到满足。 如果此通道的缓冲队列不为空（这种情况下，接收数据协程队列必为空），此协程 R 将从缓冲队列取出（接收）一个值。 如果发送数据协程队列不为空，一个发送协程将从此队列中弹出，此协程欲发送的值将被推入缓冲队列。此发送协程将恢复至运行状态。 接收数据协程 R 继续运行，不会阻塞。对于这种情况，此数据接收操作为一个非阻塞操作。 否则（即此通道的缓冲队列为空），如果发送数据协程队列不为空（这种情况下，此通道必为一个非缓冲通道）， 一个发送数据协程将从此队列中弹出，此协程欲发送的值将被接收数据协程 R 接收。此发送协程将恢复至运行状态。 接收数据协程 R 继续运行，不会阻塞。对于这种情况，此数据接收操作为一个非阻塞操作。 对于剩下的情况（即此通道的缓冲队列和发送数据协程队列均为空），此接收数据协程 R 将被推入接收数据协程队列，并进入阻塞状态。 它以后可能会被另一个发送数据协程唤醒而恢复运行。 对于这种情况，此数据接收操作为一个阻塞操作。 通道操作情形 B： 当一个协程 S 尝试向一个非零且尚未关闭的通道发送数据的时候，此协程S将首先尝试获取此通道的锁，成功之后将执行下列步骤，直到其中一个步骤的条件得到满足。 如果此通道的接收数据协程队列不为空（这种情况下，缓冲队列必为空）， 一个接收数据协程将从此队列中弹出，此协程将接收到发送协程 S 发送的值。此接收协程将恢复至运行状态。 发送数据协程 S 继续运行，不会阻塞。对于这种情况，此数据发送操作为一个非阻塞操作。 否则（接收数据协程队列为空），如果缓冲队列未满（这种情况下，发送数据协程队列必为空）， 发送协程S 欲发送的值将被推入缓冲队列，发送数据协程 S 继续运行，不会阻塞。 对于这种情况，此数据发送操作为一个非阻塞操作。 对于剩下的情况（接收数据协程队列为空，并且缓冲队列已满），此发送协程 S 将被推入发送数据协程队列，并进入阻塞状态。 它以后可能会被另一个接收数据协程唤醒而恢复运行。 对于这种情况，此数据发送操作为一个阻塞操作。 上面已经提到过，一旦一个非零通道被关闭，继续向此通道发送数据将产生一个恐慌。 注意，向关闭的通道发送数据属于一个非阻塞操作。 通道操作情形 C： 当一个协程成功获取到一个非零且尚未关闭的通道的锁并且准备关闭此通道时，下面两步将依次执行： 如果此通道的接收数据协程队列不为空（这种情况下，缓冲队列必为空），此队列中的所有协程将被依个弹出，并且每个协程将接收到此通道的元素类型的一个零值，然后恢复至运行状态。 如果此通道的发送数据协程队列不为空，此队列中的所有协程将被依个弹出，并且每个协程中都将产生一个恐慌（因为向已关闭的通道发送数据）。 这就是我们在上面说并发地关闭一个通道和向此通道发送数据这种情形属于不良设计的原因。 事实上，在数据竞争侦测编译选项（-race）打开时，Go 官方标准运行时将很可能会对并发地关闭一个通道和向此通道发送数据这种情形报告成数据竞争。 注意：当一个缓冲队列不为空的通道被关闭之后，它的缓冲队列不会被清空，其中的数据仍然可以被后续的数据接收操作所接收到。详见下面的对情形 D 的解释。 通道操作情形 D： 一个非零通道被关闭之后，此通道上的后续数据接收操作将永不会阻塞。 此通道的缓冲队列中存储数据仍然可以被接收出来。 伴随着这些接收出来的缓冲数据的第二个可选返回（类型不确定布尔）值仍然是 true。 一旦此缓冲队列变为空，后续的数据接收操作将永不阻塞并且总会返回此通道的元素类型的零值和值为false 的第二个可选返回结果。 上面已经提到了，一个接收操作的第二个可选返回（类型不确定布尔）结果表示一个接收到的值是否是在此通道被关闭之前发送的。 如果此返回值为 false，则第一个返回值必然是一个此通道的元素类型的零值。 知道哪些通道操作是阻塞的和哪些是非阻塞的对正确理解后面将要介绍的 select 流程控制机制非常重要。 如果一个协程被从一个通道的某个队列中（不论发送数据协程队列还是接收数据协程队列）弹出，并且此协程是在一个 select 控制流程中推入到此队列的，那么此协程将在下面将要讲解的 select 控制流程的执行步骤中的第 9 步中恢复至运行状态，并且同时它会被从相应的 select 控制流程中的相关的若干通道的协程队列中移除掉。 一些结论 根据上面的解释，我们可以得出如下的关于一个通道的内部的三个队列的各种事实： 如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。 在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。 在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。 如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。 如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个 select 控制流程中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:4","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"一些 channel 的使用例子 来看一些通道的使用例子来加深一下对上一节中的解释的理解。 一个简单的通过一个非缓冲通道实现的请求/响应的例子： package main import ( \"fmt\" \"time\" ) func main() { c := make(chan int) // 一个非缓冲通道 go func(ch chan\u003c- int, x int) { time.Sleep(time.Second) // \u003c-ch // 此操作编译不通过 ch \u003c- x*x // 阻塞在此，直到发送的值被接收 }(c, 3) done := make(chan struct{}) go func(ch \u003c-chan int) { n := \u003c-ch // 阻塞在此，直到有值发送到c fmt.Println(n) // 9 // ch \u003c- 123 // 此操作编译不通过 time.Sleep(time.Second) done \u003c- struct{}{} }(c) \u003c-done // 阻塞在此，直到有值发送到done fmt.Println(\"bye\") } 输出结果： 9 bye 下面的例子使用了一个缓冲通道。此例子程序并非是一个并发程序，它只是为了展示缓冲通道的使用。 package main import \"fmt\" func main() { c := make(chan int, 2) // 一个容量为2的缓冲通道 c \u003c- 3 c \u003c- 5 close(c) fmt.Println(len(c), cap(c)) // 2 2 x, ok := \u003c-c fmt.Println(x, ok) // 3 true fmt.Println(len(c), cap(c)) // 1 2 x, ok = \u003c-c fmt.Println(x, ok) // 5 true fmt.Println(len(c), cap(c)) // 0 2 x, ok = \u003c-c fmt.Println(x, ok) // 0 false x, ok = \u003c-c fmt.Println(x, ok) // 0 false fmt.Println(len(c), cap(c)) // 0 2 close(c) // 此行将产生一个恐慌 c \u003c- 7 // 如果上一行不存在，此行也将产生一个恐慌。 } 一场永不休场的足球比赛： package main import ( \"fmt\" \"time\" ) func main() { var ball = make(chan string) kickBall := func(playerName string) { for { fmt.Print(\u003c-ball, \"传球\", \"\\n\") time.Sleep(time.Second) ball \u003c- playerName } } go kickBall(\"张三\") go kickBall(\"李四\") go kickBall(\"王二麻子\") go kickBall(\"刘大\") ball \u003c- \"裁判\" // 开球 var c chan bool // 一个零值nil通道 \u003c-c // 永久阻塞在此 } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:5","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"channel 的元素值的传递都是复制过程 在一个值被从一个协程传递到另一个协程的过程中，此值将被复制至少一次。 如果此传递值曾经在某个通道的缓冲队列中停留过，则它在此传递过程中将被复制两次。 一次复制发生在从发送协程向缓冲队列推入此值的时候，另一个复制发生在接收协程从缓冲队列取出此值的时候。 和赋值以及函数调用传参一样，当一个值被传递时，只有它的直接部分被复制。 对于官方标准编译器，最大支持的通道的元素类型的尺寸为 65535。 但是，一般说来，为了在数据传递过程中避免过大的复制成本，我们不应该使用尺寸很大的通道元素类型。 如果欲传送的值的尺寸较大，应该改用指针类型做为通道的元素类型。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:6","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"关于 channel 和协程的垃圾回收 注意，一个通道被其发送数据协程队列和接收数据协程队列中的所有协程引用着。因此，如果一个通道的这两个队列只要有一个不为空，则此通道肯定不会被垃圾回收。 另一方面，如果一个协程处于一个通道的某个协程队列之中，则此协程也肯定不会被垃圾回收，即使此通道仅被此协程所引用。 事实上，一个协程只有在退出后才能被垃圾回收。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:7","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"数据接收和发送操作都属于简单语句 数据接收和发送操作都属于简单语句。 另外一个数据接收操作总是可以被用做一个单值表达式。 简单语句和表达式可以被用在一些控制流程的某些部分。 在下面这个例子中，数据接收和发送操作被用在两个 for 循环的初始化和步尾语句。 package main import ( \"fmt\" \"time\" ) func main() { fibonacci := func() chan uint64 { c := make(chan uint64) go func() { var x, y uint64 = 0, 1 for ; y \u003c (1 \u003c\u003c 63); c \u003c- y { // 步尾语句 x, y = y, x+y } close(c) }() return c } c := fibonacci() for x, ok := \u003c-c; ok; x, ok = \u003c-c { // 初始化和步尾语句 time.Sleep(time.Second) fmt.Println(x) } } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:8","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"⭐ for-range 应用于 channel for-range 循环控制流程也适用于通道。 此循环将不断地尝试从一个通道接收数据，直到此通道关闭并且它的缓冲队列为空为止。 和应用于数组/切片/映射的 for-range 语法不同，应用于通道的 for-range 语法中最多只能出现一个循环变量，此循环变量用来存储接收到的值。 for v := range aChannel { // 使用v } 等价于 for { v, ok = \u003c-aChannel if !ok { break } // 使用v } 当然，这里的通道 aChannel 一定不能为一个单向发送通道。 如果它是一个 nil 零值，则此 for-range 循环将使当前协程永久阻塞。 上一节中的例子中的最后一个 for 循环可以改写为下面这样： for x := range c { time.Sleep(time.Second) fmt.Println(x) } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:9","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"⭐ select-case 分支流程控制代码块 Go 中有一个专门为通道设计的 select-case 分支流程控制语法。 此语法和 switch-case 分支流程控制语法很相似。 比如，select-case 流程控制代码块中也可以有若干 case 分支和最多一个 default 分支。 但是，这两种流程控制也有很多不同点。 在一个 select-case 流程控制中： select 关键字和 { 之间不允许存在任何表达式和语句。 fallthrough 语句不能被使用. 每个 case 关键字后必须跟随一个通道接收数据操作或者一个通道发送数据操作。 通道接收数据操作可以做为源值出现在一条简单赋值语句中。 以后，一个 case 关键字后跟随的通道操作将被称为一个 case 操作。 所有的非阻塞 case 操作中将有一个被随机选择执行（而不是按照从上到下的顺序），然后执行此操作对应的 case 分支代码块。 在所有的 case 操作均为阻塞的情况下，如果 default 分支存在，则 default 分支代码块将得到执行； 否则，当前协程将被推入所有阻塞操作中相关的通道的发送数据协程队列或者接收数据协程队列中，并进入阻塞状态。 按照上述规则，一个不含任何分支的 select-case 代码块 select{} 将使当前协程处于永久阻塞状态。 一些例子 在下面这个例子中，default 分支将铁定得到执行，因为两个 case 分支后的操作均为阻塞的。 package main import \"fmt\" func main() { var c chan struct{} // nil select { case \u003c-c: // 阻塞操作 case c \u003c- struct{}{}: // 阻塞操作 default: fmt.Println(\"Go here.\") } } 下面这个例子中实现了尝试发送（try-send）和尝试接收（try-receive）。 它们都是用含有一个 case 分支和一个 default 分支的 select-case 代码块来实现的。 package main import \"fmt\" func main() { c := make(chan string, 2) trySend := func(v string) { select { case c \u003c- v: default: // 如果c的缓冲已满，则执行默认分支。 } } tryReceive := func() string { select { case v := \u003c-c: return v default: return \"-\" // 如果c的缓冲为空，则执行默认分支。 } } trySend(\"Hello!\") // 发送成功 trySend(\"Hi!\") // 发送成功 trySend(\"Bye!\") // 发送失败，但不会阻塞。 // 下面这两行将接收成功。 fmt.Println(tryReceive()) // Hello! fmt.Println(tryReceive()) // Hi! // 下面这行将接收失败。 fmt.Println(tryReceive()) // - } 下面这个程序有 50% 的几率会因为恐慌而崩溃。 此程序中 select-case 代码块中的两个 case 操作均不阻塞，所以随机一个将被执行。 如果第一个 case 操作（向已关闭的通道发送数据）被执行，则一个恐慌将产生。 package main func main() { c := make(chan struct{}) close(c) select { case c \u003c- struct{}{}: // 若此分支被选中，则产生一个恐慌 case \u003c-c: } } select-case 流程控制的实现机理 select-case 流程控制是 Go 中的一个重要和独特的特性。 下面列出了官方标准运行时中 select-case 流程控制的实现步骤。 将所有 case 操作中涉及到的通道表达式和发送值表达式按照从上到下，从左到右的顺序一一估值。 在赋值语句中做为源值的数据接收操作对应的目标值在此时刻不需要被估值。 将所有分支随机排序。default 分支总是排在最后。 所有 case 操作中相关的通道可能会有重复的。 为了防止在下一步中造成（和其它协程互相）死锁，对所有 case 操作中相关的通道进行排序。（排序依据并不重要，官方 Go 标准编译器使用通道的地址顺序进行排序）。排序结果中前 N 个通道不存在重复的情况。 N 为所有 case 操作中涉及到的不重复的通道的数量。 下面，通道锁顺序是针对此排序结果中的前 N 个通道来说的，通道锁逆序是指此顺序的逆序。 按照上一步中的生成通道锁顺序获取所有相关的通道的锁。 按照第 2 步中生成的分支顺序检查相应分支： 如果这是一个 case 分支并且相应的通道操作是一个向关闭了的通道发送数据操作，则按照通道锁逆序解锁所有的通道并在当前协程中产生一个恐慌。 跳到第 12 步（完毕）。 如果这是一个 case 分支并且相应的通道操作是非阻塞的，则按照通道锁逆序解锁所有的通道并执行相应的 case 分支代码块。 （此相应的通道操作可能会唤醒另一个处于阻塞状态的协程。） 跳到第 12 步（完毕）。 如果这是 default 分支，则按照通道锁逆序解锁所有的通道并执行此 default 分支代码块。 跳到第 12 步（完毕）。 （到这里，default 分支肯定是不存在的，并且所有的 case 操作均为阻塞的。） 将当前协程（和对应 case 分支信息）推入到每个 case 操作中对应的通道的发送数据协程队列或接收数据协程队列中。 当前协程可能会被多次推入到同一个通道的这两个队列中，因为多个 case 操作中对应的通道可能为同一个。 使当前协程进入阻塞状态并且按照通道锁逆序解锁所有的通道。 …，当前协程处于阻塞状态，等待其它协程通过通道操作唤醒当前协程，… 当前协程被另一个协程中的一个通道操作唤醒。 此唤醒通道操作可能是一个通道关闭操作，也可能是一个数据发送/接收操作。 如果它是一个数据发送/接收操作，则（当前正被解释的 select-case 流程中）肯定有一个相应 case 操作与之配合传递数据。 在此配合过程中，当前协程将从相应 case 操作相关的通道的接收/发送数据协程队列中弹出。 按照第 3 步中的生成的通道锁顺序获取所有相关的通道的锁。 将当前协程从各个 case 操作中对应的通道的发送数据协程队列或接收数据协程队列中（可能以非弹出的方式）移除。 如果当前协程是被一个通道关闭操作所唤醒，则跳到第 5 步。 如果当前协程是被一个数据发送/接收操作所唤醒，则相应的 case 分支已经在第 9 步中知晓。 按照通道锁逆序解锁所有的通道并执行此 case 分支代码块。 完毕。 从此实现中，我们得知 一个协程可能同时多次处于同一个通道的发送数据协程队列或接收数据协程队列中。 当一个协程被阻塞在一个 select-case 流程控制中并在以后被唤醒时，它可能会从多个通道的发送数据协程队列和接收数据协程队列中被移除。 通道并非在任何场合总是最佳的并发同步方案 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:3:10","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"sync 标准库包中提供的并发同步技术 通道并不是 Go 支持的唯一的一种并发同步技术。而且对于一些特定的情形，通道并不是最有效和可读性最高的同步技术。 本文下面将介绍 sync 标准库包中提供的各种并发同步技术。相对于通道，这些技术对于某些情形更加适用。 sync 标准库包提供了一些用于实现并发同步的类型。这些类型适用于各种不同的内存顺序需求。 对于这些特定的需求，这些类型使用起来比通道效率更高，代码实现更简洁。 请注意：为了避免各种异常行为，最好不要复制 sync 标准库包中提供的类型的值。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:4:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"sync.WaitGroup（等待组）类型 每个 sync.WaitGroup 值在内部维护着一个计数，此计数的初始默认值为零。 *sync.WaitGroup 类型有三个方法：Add(delta int)、Done() 和 Wait()。 对于一个可寻址的 sync.WaitGroup 值 wg， 我们可以使用方法调用 wg.Add(delta) 来改变值 wg 维护的计数。 方法调用 wg.Done() 和 wg.Add(-1) 是完全等价的。 如果一个 wg.Add(delta) 或者 wg.Done() 调用将 wg 维护的计数更改成一个负数，一个恐慌将产生。 当一个协程调用了 wg.Wait() 时， 如果此时 wg 维护的计数为零，则此 wg.Wait() 此操作为一个空操作（no-op）； 否则（计数为一个正整数），此协程将进入阻塞状态。 当以后其它某个协程将此计数更改至 0 时（一般通过调用 wg.Done()），此协程将重新进入运行状态（即 wg.Wait() 将返回）。 请注意 wg.Add(delta)、wg.Done() 和 wg.Wait()分别是 (\u0026wg).Add(delta)、(\u0026wg).Done() 和 (\u0026wg).Wait() 的简写形式（省略了间址运算符） 一般，一个 sync.WaitGroup 值用来让某个协程等待其它若干协程都先完成它们各自的任务。 一个例子： package main import ( \"fmt\" \"math/rand\" \"sync\" \"time\" ) func main() { rand.Seed(time.Now().UnixNano()) const N = 5 var values [N]int32 var wg sync.WaitGroup wg.Add(N) for i := 0; i \u003c N; i++ { i := i go func() { values[i] = 50 + rand.Int31n(50) fmt.Println(\"Done:\", i) wg.Done() // \u003c=\u003e wg.Add(-1) }() } wg.Wait() // 所有的元素都保证被初始化了。 fmt.Println(\"values:\", values) } 在此例中，主协程等待着直到其它 5 个协程已经将各自负责的元素初始化完毕此会打印出各个元素值。 这里是一个可能的程序执行输出结果： Done: 4 Done: 1 Done: 3 Done: 0 Done: 2 values: [71 89 50 62 60] 我们可以将上例中的 Add 方法调用拆分成多次调用： ... var wg sync.WaitGroup for i := 0; i \u003c N; i++ { wg.Add(1) // 将被执行5次 i := i go func() { values[i] = 50 + rand.Int31n(50) wg.Done() }() } ... 一个 *sync.WaitGroup 值的 Wait 方法可以在多个协程中调用。 当对应的 sync.WaitGroup 值维护的计数降为 0，这些协程都将得到一个（广播）通知而结束阻塞状态。 func main() { rand.Seed(time.Now().UnixNano()) const N = 5 var values [N]int32 var wgA, wgB sync.WaitGroup wgA.Add(N) wgB.Add(1) for i := 0; i \u003c N; i++ { i := i go func() { wgB.Wait() // 等待广播通知 log.Printf(\"values[%v]=%v \\n\", i, values[i]) wgA.Done() }() } // 下面这个循环保证将在上面的任何一个 // wg.Wait调用结束之前执行。 for i := 0; i \u003c N; i++ { values[i] = 50 + rand.Int31n(50) } wgB.Done() // 发出一个广播通知 wgA.Wait() } 一个 WaitGroup 可以在它的一个 Wait 方法返回之后被重用。 但是请注意，当一个 WaitGroup 值维护的基数为零时，它的带有正整数实参的 Add 方法调用不能和它的 Wait 方法调用并发运行，否则将可能出现数据竞争。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:4:1","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"sync.Once 类型 每个 *sync.Once 值有一个 Do(f func()) 方法。 此方法只有一个类型为 func() 的参数。 对一个可寻址的 sync.Once 值 o，o.Do()（即 (\u0026o).Do() 的简写形式）方法调用可以在多个协程中被多次并发地执行， 这些方法调用的实参应该（但并不强制）为同一个函数值。 在这些方法调用中，有且只有一个调用的实参函数（值）将得到调用。 此被调用的实参函数保证在任何 o.Do() 方法调用返回之前退出。 换句话说，被调用的实参函数内的代码将在任何 o.Do() 方法返回调用之前被执行。 一般来说，一个 sync.Once 值被用来确保一段代码在一个并发程序中被执行且仅被执行一次。 一个例子： package main import ( \"log\" \"sync\" ) func main() { log.SetFlags(0) x := 0 doSomething := func() { x++ log.Println(\"Hello\") } var wg sync.WaitGroup var once sync.Once for i := 0; i \u003c 5; i++ { wg.Add(1) go func() { defer wg.Done() once.Do(doSomething) log.Println(\"world!\") }() } wg.Wait() log.Println(\"x =\", x) // x = 1 } 在此例中，Hello 将仅被输出一次，而 world! 将被输出 5 次，并且 Hello 肯定在所有的 5 个 world! 之前输出。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:4:2","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"sync.Mutex（互斥锁）和 sync.RWMutex（读写锁）类型 *sync.Mutex 和 *sync.RWMutex类型都实现了 sync.Locker 接口类型。 所以这两个类型都有两个方法：Lock() 和 Unlock()，用来保护一份数据不会被多个使用者同时读取和修改。 除了 Lock() 和 Unlock() 这两个方法，*sync.RWMutex 类型还有两个另外的方法：RLock() 和 RUnlock()，用来支持多个读取者并发读取一份数据但防止此份数据被某个数据写入者和其它数据访问者（包括读取者和写入者）同时使用。 （注意：这里的数据读取者和数据写入者不应该从字面上理解。有时候某些数据读取者可能修改数据，而有些数据写入者可能只读取数据。） 一个 Mutex 值常称为一个互斥锁。 一个 Mutex 零值为一个尚未加锁的互斥锁。 一个（可寻址的）Mutex 值 m 只有在未加锁状态时才能通过 m.Lock() 方法调用被成功加锁。 换句话说，一旦 m 值被加了锁（亦即某个 m.Lock() 方法调用成功返回）， 一个新的加锁试图将导致当前协程进入阻塞状态，直到此 Mutex 值被解锁为止（通过 m.Unlock() 方法调用）。 m.Lock() 和 m.Unlock()分别是 (\u0026m).Lock() 和 (\u0026m).Unlock() 的简写形式。 一个使用 sync.Mutex 的例子： package main import ( \"fmt\" \"runtime\" \"sync\" ) type Counter struct { m sync.Mutex n uint64 } func (c *Counter) Value() uint64 { c.m.Lock() defer c.m.Unlock() return c.n } func (c *Counter) Increase(delta uint64) { c.m.Lock() c.n += delta c.m.Unlock() } func main() { var c Counter for i := 0; i \u003c 100; i++ { go func() { for k := 0; k \u003c 100; k++ { c.Increase(1) } }() } // 此循环仅为演示目的。 for c.Value() \u003c 10000 { runtime.Gosched() } fmt.Println(c.Value()) // 10000 } 在上面这个例子中，一个 Counter 值使用了一个 Mutex 字段来确保它的字段 n 永远不会被多个协程同时使用。 一个 RWMutex 值常称为一个读写互斥锁，它的内部包含两个锁：一个写锁和一个读锁。 对于一个可寻址的 RWMutex 值 rwm，数据写入者可以通过方法调用 rwm.Lock() 对 rwm 加写锁，或者通过 rwm.RLock() 方法调用对 rwm 加读锁。 方法调用 rwm.Unlock() 和 rwm.RUnlock()用来解开 rwm 的写锁和读锁。 rwm 的读锁维护着一个计数。当 rwm.RLock() 调用成功时，此计数增 1；当 rwm.Unlock() 调用成功时，此计数减 1； 一个零计数表示 rwm 的读锁处于未加锁状态；反之，一个非零计数（肯定大于零）表示 rwm 的读锁处于加锁状态。 注意 rwm.Lock()、rwm.Unlock()、rwm.RLock() 和 rwm.RUnlock() 分别是 (\u0026rwm).Lock()、(\u0026rwm).Unlock()、(\u0026rwm).RLock() 和 (\u0026rwm).RUnlock() 的简写形式。 对于一个可寻址的 RWMutex 值 rwm，下列规则存在： rwm 的写锁只有在它的写锁和读锁都处于未加锁状态时才能被成功加锁。 换句话说，rwm 的写锁在任何时刻最多只能被一个数据写入者成功加锁，并且 rwm 的写锁和读锁不能同时处于加锁状态。 当 rwm 的写锁正处于加锁状态的时候，任何新的对之加写锁或者加读锁的操作试图都将导致当前协程进入阻塞状态，直到此写锁被解锁，这样的操作试图才有机会成功。 当 rwm 的读锁正处于加锁状态的时候，新的加写锁的操作试图将导致当前协程进入阻塞状态。 但是，一个新的加读锁的操作试图将成功，只要此操作试图发生在任何被阻塞的加写锁的操作试图之前（见下一条规则）。 换句话说，一个读写互斥锁的读锁可以同时被多个数据读取者同时加锁而持有。 当 rwm 的读锁维护的计数清零时，读锁将返回未加锁状态。 假设 rwm 的读锁正处于加锁状态的时候，为了防止后续数据写入者没有机会成功加写锁，后续发生在某个被阻塞的加写锁操作试图之后的所有加读锁的试图都将被阻塞。 假设 rwm 的写锁正处于加锁状态的时候，（至少对于标准编译器来说，）为了防止后续数据读取者没有机会成功加读锁，发生在此写锁下一次被解锁之前的所有加读锁的试图都将在此写锁下一次被解锁之后肯定取得成功，即使所有这些加读锁的试图发生在一些仍被阻塞的加写锁的试图之后。 后两条规则是为了确保数据读取者和写入者都有机会执行它们的操作，避免产生饥饿 请注意：一个锁并不会绑定到一个协程上，即一个锁并不记录哪个协程成功地加锁了它。 换句话说，一个锁的加锁者和此锁的解锁者可以不是同一个协程，尽管在实践中这种情况并不多见。 在上一个例子中，如果 Value 方法被十分频繁调用而 Increase 方法并不频繁被调用，则 Counter 类型的 m 字段的类型可以更改为 sync.RWMutex，从而使得执行效率更高，如下面的代码所示。 ... type Counter struct { //m sync.Mutex m sync.RWMutex n uint64 } func (c *Counter) Value() uint64 { //c.m.Lock() //defer c.m.Unlock() c.m.RLock() defer c.m.RUnlock() return c.n } ... sync.RWMutex 值的另一个应用场景是将一个写任务分隔成若干小的写任务。下一节中展示了一个这样的例子。 根据上面列出的后两条规则，下面这个程序最有可能输出 abdc。 package main import ( \"fmt\" \"time\" \"sync\" ) func main() { var m sync.RWMutex go func() { m.RLock() fmt.Print(\"a\") time.Sleep(time.Second) m.RUnlock() }() go func() { time.Sleep(time.Second * 1 / 4) m.Lock() fmt.Print(\"b\") time.Sleep(time.Second) m.Unlock() }() go func() { time.Sleep(time.Second * 2 / 4) m.Lock() fmt.Print(\"c\") m.Unlock() }() go func () { time.Sleep(time.Second * 3 / 4) m.RLock() fmt.Print(\"d\") m.RUnlock() }() time.Sleep(time.Second * 3) fmt.Println() } 请注意，上例这个程序仅仅是为了解释和验证上面列出的读写锁的后两条加锁规则。 此程序使用了 time.Sleep 调用来做协程间的同步。 sync.Mutex 和 sync.RWMutex 值也可以用来实现通知，尽管这不是 Go 中最优雅的方法来实现通知。 下面是一个使用了 Mutex 值来实现通知的例子。 package main import ( \"fmt\" \"sync\" \"time\" ) func main() { var m sync.Mutex m.Lock() go func() { time.Sleep(time.Second) fmt.Println(\"Hi\") m.Unlock() // 发出一个通知 }() m.Lock() // 等待通知 fmt.Println(\"Bye\") } 在此例中，Hi 将确保在 Bye 之前打印出来。 关于 sync.Mutex 和 sync.RWMutex 值相关的内存顺序保证，请阅读Go中的内存顺序保证一文。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:4:3","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"sync.Cond 类型 sync.Cond 类型提供了一种有效的方式来实现多个协程间的通知。 每个 sync.Cond 值拥有一个 sync.Locker 类型的名为 L 的字段。 此字段的具体值常常为一个 *sync.Mutex 值或者 *sync.RWMutex 值。 *sync.Cond 类型有三个方法：Wait()、Signal() 和 Broadcast()。 每个 Cond 值维护着一个先进先出等待协程队列。 对于一个可寻址的Cond值c， c.Wait() 必须在 c.L 字段值的锁处于加锁状态的时候调用；否则，c.Wait() 调用将造成一个恐慌。 一个 c.Wait() 调用将 首先将当前协程推入到 c 所维护的等待协程队列； 然后调用 c.L.Unlock() 对 c.L 的锁解锁； 然后使当前协程进入阻塞状态（当前协程将被另一个协程通过 c.Signal() 或 c.Broadcast() 调用唤醒而重新进入运行状态。）一旦当前协程重新进入运行状态，c.L.Lock() 将被调用以试图重新对 c.L 字段值的锁加锁。 此 c.Wait() 调用将在此试图成功之后退出。 一个 c.Signal() 调用将唤醒并移除 c 所维护的等待协程队列中的第一个协程（如果此队列不为空的话）。 一个 c.Broadcast() 调用将唤醒并移除 c 所维护的等待协程队列中的所有协程（如果此队列不为空的话）。 请注意：c.Wait()、c.Signal() 和 c.Broadcast() 分别为 (\u0026c).Wait()、(\u0026c).Signal() 和 (\u0026c).Broadcast() 的简写形式。 c.Signal() 和 c.Broadcast() 调用常用来通知某个条件的状态发生了变化。 一般说来，c.Wait() 应该在一个检查某个条件是否已经得到满足的循环中调用。 下面是一个典型的 sync.Cond 用例。 package main import ( \"fmt\" \"math/rand\" \"sync\" \"time\" ) func main() { rand.Seed(time.Now().UnixNano()) const N = 10 var values [N]string cond := sync.NewCond(\u0026sync.Mutex{}) for i := 0; i \u003c N; i++ { d := time.Second * time.Duration(rand.Intn(10)) / 10 go func(i int) { time.Sleep(d) // 模拟一个工作负载 cond.L.Lock() // 下面的修改必须在cond.L被锁定的时候执行 values[i] = string('a' + i) cond.Broadcast() // 可以在cond.L被解锁后发出通知 cond.L.Unlock() // 上面的通知也可以在cond.L未锁定的时候发出。 //cond.Broadcast() // 上面的调用也可以放在这里 }(i) } // 此函数必须在cond.L被锁定的时候调用。 checkCondition := func() bool { fmt.Println(values) for i := 0; i \u003c N; i++ { if values[i] == \"\" { return false } } return true } cond.L.Lock() defer cond.L.Unlock() for !checkCondition() { cond.Wait() // 必须在cond.L被锁定的时候调用 } } 一个可能的输出： [ ] [ f ] [ c f ] [ c f h ] [ b c f h ] [a b c f h j] [a b c f g h i j] [a b c e f g h i j] [a b c d e f g h i j] 因为上例中只有一个协程（主协程）在等待通知，所以其中的 cond.Broadcast() 调用也可以换为 cond.Signal()。 如上例中的注释所示，cond.Broadcast() 和 cond.Signal() 不必在 cond.L 的锁处于加锁状态时调用。 为了防止数据竞争，对自定义条件的修改必须在 cond.L 的锁处于加锁状态时才能执行。 另外，checkCondition 函数和 cond.Wait 方法也必须在 cond.L 的锁处于加锁状态时才可被调用。 事实上，对于上面这个特定的例子，cond.L 字段的也可以为一个 *sync.RWMutex 值。 对自定义条件的十个部分的修改可以在 RWMutex 值的读锁处于加锁状态时执行。这十个修改可以并发进行，因为它们是互不干扰的。 如下面的代码所示： ... cond := sync.NewCond(\u0026sync.RWMutex{}) cond.L.Lock() for i := 0; i \u003c N; i++ { d := time.Second * time.Duration(rand.Intn(10)) / 10 go func(i int) { time.Sleep(d) cond.L.(*sync.RWMutex).RLock() values[i] = string('a' + i) cond.L.(*sync.RWMutex).RUnlock() cond.Signal() }(i) } ... 在上面的代码中，此 sync.RWMutex 值的用法有些不符常规。 它的读锁被一些修改数组元素的协程所加锁并持有，而它的写锁被主协程加锁持有用来读取并检查各个数组元素的值。 Cond 值所表示的自定义条件可以是一个虚无。对于这种情况，此 Cond 值纯粹被用来实现通知。 比如，下面这个程序将打印出 abc 或者 bac。 package main import ( \"fmt\" \"sync\" ) func main() { wg := sync.WaitGroup{} wg.Add(1) cond := sync.NewCond(\u0026sync.Mutex{}) cond.L.Lock() go func() { cond.L.Lock() go func() { cond.L.Lock() cond.Broadcast() cond.L.Unlock() }() cond.Wait() fmt.Print(\"a\") cond.L.Unlock() wg.Done() }() cond.Wait() fmt.Print(\"b\") cond.L.Unlock() wg.Wait() fmt.Println(\"c\") } 如果需要，多个 sync.Cond 值可以共享一个 sync.Locker 值。但是这种情形在实践中并不多见。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:4:4","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"sync/atomic 标准库包中提供的原子操作 原子操作是比其它同步技术更基础的操作。原子操作是无锁的，常常直接通过 CPU 指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。 注意，本文中的很多例子并非并发程序。它们只是用来演示如何使用 sync/atomic 标准库包中提供的原子操作。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:5:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"Go 支持的原子操作概述 对于一个整数类型 T，sync/atomic 标准库包提供了下列原子操作函数。 其中 T 可以是内置 int32、int64、uint32、uint64 和 uintptr 类型。 func AddT(addr *T, delta T)(new T) func LoadT(addr *T) (val T) func StoreT(addr *T, val T) func SwapT(addr *T, new T) (old T) func CompareAndSwapT(addr *T, old, new T) (swapped bool) 比如，下列五个原子操作函数提供给了内置 int32 类型。 func AddInt32(addr *int32, delta int32)(new int32) func LoadInt32(addr *int32) (val int32) func StoreInt32(addr *int32, val int32) func SwapInt32(addr *int32, new int32) (old int32) func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool) 下列四个原子操作函数提供给了（安全）指针类型。因为 Go 目前（1.17）并不支持自定义泛型，所以这些函数是通过非类型安全指针 unsafe.Pointer 来实现的。 func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer) func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer) func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer) func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool) 因为 Go 指针不支持算术运算，所以相对于整数类型，指针类型的原子操作少了一个 AddPointer 函数。 sync/atomic 标准库包也提供了一个 Value 类型。以它为基的指针类型 *Value 拥有两个方法：Load 和 Store。 Value 值用来原子读取和修改任何类型的 Go 值。 func (v *Value) Load() (x interface{}) func (v *Value) Store(x interface{}) 本文的余下部分将通过一些示例来展示如何使用这些原子操作函数。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:5:1","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"整数原子操作 下面这个例子展示了如何使用 add 原子操作来并发地递增一个 int32 值。 在此例子中，主协程中创建了 1000 个新协程。每个新协程将整数 n 的值增加 1。 原子操作保证这 1000 个新协程之间不会发生数据竞争。此程序肯定打印出 1000。 package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) func main() { var n int32 var wg sync.WaitGroup for i := 0; i \u003c 1000; i++ { wg.Add(1) go func() { atomic.AddInt32(\u0026n, 1) wg.Done() }() } wg.Wait() fmt.Println(atomic.LoadInt32(\u0026n)) // 1000 } 如果我们将新协程中的语句 atomic.AddInt32(\u0026n, 1) 替换为 n++，则最后的输出结果很可能不是 1000。 StoreT 和 LoadT 原子操作函数经常被用来需要并发运行的实现 setter 和 getter 方法。下面是一个这样的例子： type Page struct { views uint32 } func (page *Page) SetViews(n uint32) { atomic.StoreUint32(\u0026page.views, n) } func (page *Page) Views() uint32 { return atomic.LoadUint32(\u0026page.views) } 如果 T 是一个有符号整数类型，比如 int32 或 int64，则 AddT 函数调用的第二个实参可以是一个负数，用来实现原子减法操作。 但是如果 T 是一个无符号整数类型，比如 uint32、uint64 或者 uintptr，则 AddT 函数调用的第二个实参需要为一个非负数，那么如何实现无符号整数类型 T 值的原子减法操作呢？ 毕竟 sync/atomic 标准库包没有提供 SubstractT 函数。 根据欲传递的第二个实参的特点，我们可以把T为一个无符号整数类型的情况细分为两类： 第二个实参为类型为 T 的一个变量值 v。 因为 -v 在 Go 中是合法的，所以 -v 可以直接被用做 AddT 调用的第二个实参。 第二个实参为一个正整数常量 c，这时 -c 在 Go 中是编译不通过的，所以它不能被用做 AddT 调用的第二个实参。 这时我们可以使用 ^T(c-1)（仍为一个正数）做为 AddT 调用的第二个实参。 此 ^T(v-1) 小技巧对于无符号类型的变量 v 也是适用的，但是 ^T(v-1) 比 T(-v) 的效率要低。 对于这个 ^T(c-1) 小技巧，如果 c 是一个类型确定值并且它的类型确实就是 T，则它的表示形式可以简化为 ^(c-1)。 一个例子： package main import ( \"fmt\" \"sync/atomic\" ) func main() { var ( n uint64 = 97 m uint64 = 1 k int = 2 ) const ( a = 3 b uint64 = 4 c uint32 = 5 d int = 6 ) show := fmt.Println atomic.AddUint64(\u0026n, -m) show(n) // 96 (97 - 1) atomic.AddUint64(\u0026n, -uint64(k)) show(n) // 94 (95 - 2) atomic.AddUint64(\u0026n, ^uint64(a - 1)) show(n) // 91 (94 - 3) atomic.AddUint64(\u0026n, ^(b - 1)) show(n) // 87 (91 - 4) atomic.AddUint64(\u0026n, ^uint64(c - 1)) show(n) // 82 (87 - 5) atomic.AddUint64(\u0026n, ^uint64(d - 1)) show(n) // 76 (82 - 6) x := b; atomic.AddUint64(\u0026n, -x) show(n) // 72 (76 - 4) atomic.AddUint64(\u0026n, ^(m - 1)) show(n) // 71 (72 - 1) atomic.AddUint64(\u0026n, ^uint64(k - 1)) show(n) // 69 (71 - 2) } SwapT 函数调用和 StoreT 函数调用类似，但是返回修改之前的旧值（因此称为置换操作）。 一个 CompareAndSwapT 函数调用传递的旧值和目标值的当前值匹配的情况下才会将目标值改为新值，并返回 true；否则立即返回 false。 一个例子： package main import ( \"fmt\" \"sync/atomic\" ) func main() { var n int64 = 123 var old = atomic.SwapInt64(\u0026n, 789) fmt.Println(n, old) // 789 123 swapped := atomic.CompareAndSwapInt64(\u0026n, 123, 456) fmt.Println(swapped) // false fmt.Println(n) // 789 swapped = atomic.CompareAndSwapInt64(\u0026n, 789, 456) fmt.Println(swapped) // true fmt.Println(n) // 456 } 请注意，到目前为止（Go 1.17），一个 64 位字（int64 或 uint64 值）的原子操作要求此 64 位字的内存地址必须是 8 字节对齐的。 请阅读关于 Go 值的内存布局一文获取详情。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:5:2","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"指针值的原子操作 上面已经提到了 sync/atomic 标准库包为指针值的原子操作提供了四个函数，并且指针值的原子操作是通过非类型安全指针来实现的。 从非类型安全指针一文，我们得知，在 Go 中， 任何指针类型的值可以被显式转换为非类型安全指针类型 unsafe.Pointer，反之亦然。 所以指针类型 *unsafe.Pointer 的值也可以被显式转换为类型unsafe.Pointer，反之亦然。 下面这个程序不是一个并发程序。它仅仅展示了如何使用指针原子操作。在这个例子中，类型 T 可以为任何类型。 package main import ( \"fmt\" \"sync/atomic\" \"unsafe\" ) type T struct {x int} var pT *T func main() { var unsafePPT = (*unsafe.Pointer)(unsafe.Pointer(\u0026pT)) var ta, tb = T{1}, T{2} // 修改 atomic.StorePointer( unsafePPT, unsafe.Pointer(\u0026ta)) fmt.Println(pT) // \u0026{1} // 读取 pa1 := (*T)(atomic.LoadPointer(unsafePPT)) fmt.Println(pa1 == \u0026ta) // true // 置换 pa2 := atomic.SwapPointer( unsafePPT, unsafe.Pointer(\u0026tb)) fmt.Println((*T)(pa2) == \u0026ta) // true fmt.Println(pT) // \u0026{2} // 比较置换 b := atomic.CompareAndSwapPointer( unsafePPT, pa2, unsafe.Pointer(\u0026tb)) fmt.Println(b) // false b = atomic.CompareAndSwapPointer( unsafePPT, unsafe.Pointer(\u0026tb), pa2) fmt.Println(b) // true } 是的，目前指针的原子操作使用起来是相当的啰嗦。 事实上，啰嗦还是次要的，更主要的是，因为指针的原子操作需要引入 unsafe 标准库包，所以这些操作函数不在 Go1兼容性保证之列。 感觉目前支持的这些指针原子操作在今后变为不合法的可能性很小。 即使它们变得不再合法，Go 官方工具链中的 go fix 命令应该会将它们转换为今后的新的合法形式。 如果你确实担忧这些指针原子操作在未来的合法性，你可以使用下一节将要介绍的原子操作。 但是下一节将要介绍的原子操作对于指针值来说比本节介绍的指针原子操作效率要低得多。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:5:3","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"任何类型值的原子操作 sync/atomic 标准库包中提供的 Value 类型可以用来读取和修改任何类型的值。 类型 *Value 有几个方法：Load、Store、Swap 和 CompareAndSwap（其中后两个方法是在 Go 1.17 中引入的）。 这些方法均以 interface{} 做为参数类型，所以传递给它们的实参可以是任何类型的值。 但是对于一个可寻址的 Value 类型的值 v，一旦 v.Store 方法（(\u0026v).Store 的简写形式）被曾经调用一次，则传递给值 v 的后续方法调用的实参的具体类型必须和传递给它的第一次调用的实参的具体类型一致； 否则，将产生一个恐慌。nil 接口类型实参也将导致 v.Store() 方法调用产生恐慌。 一个例子： package main import ( \"fmt\" \"sync/atomic\" ) func main() { type T struct {a, b, c int} var ta = T{1, 2, 3} var v atomic.Value v.Store(ta) var tb = v.Load().(T) fmt.Println(tb) // {1 2 3} fmt.Println(ta == tb) // true v.Store(\"hello\") // 将导致一个恐慌 } 另一个例子（针对Go 1.17+）： package main import ( \"fmt\" \"sync/atomic\" ) func main() { type T struct {a, b, c int} var x = T{1, 2, 3} var y = T{4, 5, 6} var z = T{7, 8, 9} var v atomic.Value v.Store(x) fmt.Println(v) // {{1 2 3}} old := v.Swap(y) fmt.Println(v) // {{4 5 6}} fmt.Println(old.(T)) // {1 2 3} swapped := v.CompareAndSwap(x, z) fmt.Println(swapped, v) // false {{4 5 6}} swapped = v.CompareAndSwap(y, z) fmt.Println(swapped, v) // true {{7 8 9}} } 事实上，我们也可以使用上一节介绍的指针原子操作来对任何类型的值进行原子读取和修改，不过需要多一级指针的间接引用。 两种方法有各自的好处和缺点。在实践中需要根据具体需要选择合适的方法。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:5:4","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"原子操作相关的内存顺序保证 为了便于理解和使用简单，Go 值的原子操作被设计的和内存顺序保证无关。 没有任何官方文档规定了原子操作应该保证的内存顺序。 详见 Go 中的内存顺序保证一文对此情况的说明。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:5:5","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"一些常见并发编程错误 Go 并不阻止程序员在并发编程中因为粗心或者经验不足而犯错。 本文的余下部分将展示一些常见的并发错误，来帮助 Go 程序员在实践中避免这些错误。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:0","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"当需要同步的时候没有同步 我们已经知道，源文件中的代码行在运行时刻并非总是按照它们的出现次序被执行。 下面这个示例程序犯了两个错误： 首先，主协程中对变量 b 的读取和匿名协程中的对变量 b 的写入可能会产生数据竞争； 其次，在主协程中，条件 b == true 成立并不能确保条件 a != nil 也成立。 编译器和 CPU 可能会对调整此程序中匿名协程中的某些指令的顺序已获取更快的执行速度。 所以，站在主协程的视角看，对变量 b 的赋值可能会发生在对变量 a 的赋值之前，这将造成在修改 a 的元素时 a 依然为一个 nil 切片。 package main import ( \"time\" \"runtime\" ) func main() { var a []int // nil var b bool // false // 一个匿名协程。 go func () { a = make([]int, 3) b = true // 写入b }() for !b { // 读取b time.Sleep(time.Second) runtime.Gosched() } a[0], a[1], a[2] = 0, 1, 2 // 可能会发生恐慌 } 上面这个程序可能在很多计算机上运行良好，但是可能会在某些计算机上因为恐慌而崩溃退出；或者使用某些编译器编译的时候运行良好，但使用另外的某个编译器编译的时候将造成程序运行时崩溃退出。 我们应该使用通道或者 sync 标准库包中的同步技术来确保内存顺序。比如： package main func main() { var a []int = nil c := make(chan struct{}) go func () { a = make([]int, 3) c \u003c- struct{}{} }() \u003c-c a[0], a[1], a[2] = 0, 1, 2 // 绝不会造成恐慌 } ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:1","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"使用 time.Sleep 调用来做同步 让我们看一个简单的例子： package main import ( \"fmt\" \"time\" ) func main() { var x = 123 go func() { x = 789 // 写入x }() time.Sleep(time.Second) fmt.Println(x) // 读取x } 我们期望着此程序打印出 789。 事实上，则其运行结果常常正如我们所期待的。 但是，此程序中的同步处理实现的正确吗？否！原因很简单，Go运行时并不能保证对 x 的写入一定发生在对 x 的读取之前。 在某些特定的情形下，比如 CPU 资源被很一些其它计算密集的程序所占用，则对 x 的写入有可能发生在对x的读取之后。 因此，我们不应该在正式的项目中使用 time.Sleep 调用来做同步。 让我们看另一个简单的例子： package main import ( \"fmt\" \"time\" ) var x = 0 func main() { var num = 123 var p = \u0026num c := make(chan int) go func() { c \u003c- *p + x }() time.Sleep(time.Second) num = 789 fmt.Println(\u003c-c) } 你觉得此程序会输出什么？123 还是 789？ 事实上，它的输出是和具体使用的编译器相关的。 对于标准编译器 1.17 版本来说，它很可能输出 123。 但是从理论上说，它输出 789 或者另外一个预想不到的值也是有可能的。 让我们将此例中的 c \u003c- *p + x 一行换成 c \u003c- *p，然后重新运行它，你将会发现它的输出变成了 789（如果它使用标准编译器1.17版本编译的话）。 重申一次，此结果是和具体使用的编译器和编译器的版本相关的。 是的，此程序中存在数据竞争。表达式 *p 的估值可能发生在赋值 num = 789 之前、之后、或者同时。 time.Sleep 调用并不能保证 *p 的估值发生在此赋值之后。 对于这个特定的例子，我们应该将欲发送的值在开启新协程之前存储在一个临时变量中来避免数据竞争。 ... tmp := *p go func() { c \u003c- tmp }() ... ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:2","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"使一些协程永久处于阻塞状态 有很多原因导致某个协程永久阻塞，比如： 从一个永远不会有其它协程向其发送数据的通道接收数据； 向一个永远不会有其它协程从中读取数据的通道发送数据； 被自己死锁了； 和其它协程相互死锁了； … 除了有时我们故意地将主协程永久阻塞以防止程序退出外，其它大多数造成协程永久阻塞的情况都不是我们所期待的。 Go 运行时很难分辨出一个处于阻塞状态的协程是否将永久阻塞下去，所以 Go 运行时不会释放永久处于阻塞状态的协程占用的资源。 在采用最快回应通道用例中，如果被当作 future/promise 来用的通道的容量不足够大，则较慢回应的协程在准备发送回应结果时将永久阻塞。 比如，下面的例子中，每个请求将导致 4 个协程永久阻塞。 func request() int { c := make(chan int) for i := 0; i \u003c 5; i++ { i := i go func() { c \u003c- i // 4个协程将永久阻塞在这里 }() } return \u003c-c } 为了防止有 4 个协程永久阻塞，被当作 future/promise 使用的通道的容量必须至少为 4. 在第二种“采用最快回应”实现方法中，如果被当作 future/promise 使用的通道是一个非缓冲通道（如下面的代码所示），则有可能导致其通道的接收者可能会错过所有的回应而导致处于永久阻塞状态。 func request() int { c := make(chan int) for i := 0; i \u003c 5; i++ { i := i go func() { select { case c \u003c- i: default: } }() } return \u003c-c // 有可能永久阻塞在此 } 接收者协程可能会永久阻塞的原因是如果 5 个尝试发送操作都发生在接收操作 \u003c-c 准备好之前，亦即 5 个尝试发送操作都失败了，则接收者协程将永远无值可接收（从而将处于永久阻塞状态）。 将通道 c 改为一个缓冲通道，则至少会有一个尝试发送将成功，从而接收者协程肯定不会永久阻塞。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:3","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"复制 sync 标准库包中的类型的值 在实践中，sync 标准库包中的类型（除了 Locker 接口类型）的值不应该被复制。 我们只应该复制它们的指针值。 下面是一个有问题的并发编程的例子。 在此例子中，当 Counter.Value 方法被调用时，一个 Counter 属主值将被复制，此属主值的字段 Mutex 也将被一同复制。 此复制并没有被同步保护，因此复制结果可能是不完整的，并非被复制的属主值的一个快照。 即使此 Mutex 字段得以侥幸完整复制，它的副本所保护的是对字段 n 的一个副本的访问，因此一般是没有意义的。 import \"sync\" type Counter struct { sync.Mutex n int64 } // 此方法实现是没问题的。 func (c *Counter) Increase(d int64) (r int64) { c.Lock() c.n += d r = c.n c.Unlock() return } // 此方法的实现是有问题的。当它被调用时， // 一个Counter属主值将被复制。 func (c Counter) Value() (r int64) { c.Lock() r = c.n c.Unlock() return } 我们应该将 Value 方法的属主参数类型更改为指针类型 *Counter 来避免复制 sync.Mutex 值。 Go 官方工具链中提供的 go vet 命令将提示此例中的 Value 方法的声明可能是一个潜在的逻辑错误。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:4","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"在错误的地方调用 sync.WaitGroup.Add 方法 每个 sync.WaitGroup 值内部维护着一个计数。此计数的初始值为 0。 如果一个 sync.WaitGroup 值的 Wait 方法在此计数为 0 的时候被调用，则此调用不会阻塞，否则此调用将一直阻塞到此计数变为 0 为止。 为了让一个 WaitGroup 值的使用有意义，在此值的计数为 0 的情况下，对它的下一次 Add 方法的调用必须出现在对它的下一次 Wait 方法的调用之前。 比如，在下面的例子中，Add 方法的调用位置是不合适的。 此例子程序的打印结果并不总是 100，而可能是 0 到 100 间的任何一个值。 原因是没有任何一个 Add 方法调用可以确保发生在唯一的 Wait 方法调用之前，结果导致没有任何一个 Done 方法调用可以确保发生在唯一的 Wait 方法调用返回之前。 package main import ( \"fmt\" \"sync\" \"sync/atomic\" ) func main() { var wg sync.WaitGroup var x int32 = 0 for i := 0; i \u003c 100; i++ { go func() { wg.Add(1) atomic.AddInt32(\u0026x, 1) wg.Done() }() } fmt.Println(\"等待片刻...\") wg.Wait() fmt.Println(atomic.LoadInt32(\u0026x)) } 我们应该将对 Add 方法的调用移出匿名协程之外，像下面这样，使得任何一个 Done 方法调用都确保发生在唯一的 Wait 方法调用返回之前。 ... for i := 0; i \u003c 100; i++ { wg.Add(1) go func() { atomic.AddInt32(\u0026x, 1) wg.Done() }() } ... ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:5","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"不当地使用用做 Future/Promise 的通道 从通道用例大全一文中，我们了解到一些函数可以返回用做 future/promise 的通道结果。 假设 fa 和 fb 是这样的两个函数，则下面的调用方式并没有体现出这两个函数的真正价值。 doSomethingWithFutureArguments(\u003c-fa(), \u003c-fb()) 在上面这行调用中，两个实参值（promise 回应结果）的生成实际上是串行进行的，future/promise 的价值没有体现出来。 我们应该像下面这样调用这两个函数来并发生成两个回应结果： ca, cb := fa(), fb() doSomethingWithFutureArguments(\u003c-ca, \u003c-cb) ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:6","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"没有让最后一个活跃的发送者关闭通道 Go 程序员常犯的一个错误是关闭一个后续可能还会有协程向其发送数据的通道。 当向一个已关闭的通道发送数据的时候，一个恐慌将产生。 这样的错误曾经发生在一些很有名的项目中，比如 Kubernetes 项目中的这个 bug 和这个 bug。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:7","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"对地址不保证为 8 字节对齐的值执行 64 位原子操作 截至目前（Go 1.17），64 位原子操作中涉及到的实参地址必须为 8 字节对齐的。不满足此条件的 64 位原子操作将造成一个恐慌。 对于标准编译器，这样的情形只可能发生在 32 位的架构中。 请阅读内存布局一文来获知如何确保让 64 位的整数值的地址在 32 位的架构中 8 字节对齐。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:8","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"没留意过多的 time.After 函数调用消耗了大量资源 time 标准库包中的 After 函数返回一个用做延迟通知的通道。 此函数给并发编程带来了很多便利，但是它的每个调用都需要创建一个 time.Timer 值，此新创建的 Timer 值在传递给 After 函数调用的时长（实参）内肯定不会被垃圾回收。 如果此函数在某个时段内被多次频繁调用，则可能导致积累很多尚未过期的 Timer 值从而造成大量的内存和计算消耗。 比如在下面这个例子中，如果 longRunning 函数被调用并且在一分钟内有一百万条消息到达， 那么在某个特定的很小时间段（大概若干秒）内将存在一百万个活跃的 Timer 值，即使其中只有一个是真正有用的。 import ( \"fmt\" \"time\" ) // 如果某两个连续的消息的间隔大于一分钟，此函数将返回。 func longRunning(messages \u003c-chan string) { for { select { case \u003c-time.After(time.Minute): return case msg := \u003c-messages: fmt.Println(msg) } } } 为了避免太多的 Timer 值被创建，我们应该只使用（并复用）一个 Timer 值，像下面这样： func longRunning(messages \u003c-chan string) { timer := time.NewTimer(time.Minute) defer timer.Stop() for { select { case \u003c-timer.C: // 过期了 return case msg := \u003c-messages: fmt.Println(msg) // 此if代码块很重要。 if !timer.Stop() { \u003c-timer.C } } // 必须重置以复用。 timer.Reset(time.Minute) } } 注意，此示例中的 if 代码块用来舍弃一个可能在执行第二个分支代码块的时候发送过来的超时通知。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:9","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["Golang"],"content":"不正确地使用 time.Timer 值 一个典型的 time.Timer 的使用已经在上一节中展示了。一些解释： 如果一个 Timer 值已经过期或者已经被终止（stopped），则相应的 Stop 方法调用返回 false。 在此Timer 值尚未终止的时候，Stop 方法调用返回 false 只能意味着此 Timer 值已经过期。 一个 Timer 值被终止之后，它的通道字段 C 最多只能含有一个过期的通知。 在一个 Timer 终止（stopped）之后并且在重置和重用此 Timer 值之前，我们应该确保此 Timer 值中肯定不存在过期的通知。 这就是上一节中的例子中的 if 代码块的意义所在。 一个 *Timer 值的 Reset 方法必须在对应 Timer 值过期或者终止之后才能被调用； 否则，此 Reset 方法调用和一个可能的向此 Timer 值的 C 通道字段的发送通知操作产生数据竞争。 如果上一节中的例子中的 select 流程控制代码块中的第一个分支被选中，则这表示相应的Timer值已经过期，所以我们不必终止它。 但是我们必须在第二个分支中通过终止此 Timer 以检查此 Timer 中是否存在一个过期的通知。 如果确实有一个过期的通知，我们必须在重用这个 Timer 之前将此过期的通知取出；否则，此过期的通知将下一个循环步导致在第一个分支立即被选中。 比如，下面这个程序将在运行后大概一秒钟（而不是十秒钟）后退出。 而且此程序存在着潜在的数据竞争。 package main import ( \"fmt\" \"time\" ) func main() { start := time.Now() timer := time.NewTimer(time.Second/2) select { case \u003c-timer.C: default: time.Sleep(time.Second) // 此分支被选中的可能性较大 } timer.Reset(time.Second * 10) // 可能数据竞争 \u003c-timer.C fmt.Println(time.Since(start)) // 大约1s } 当一个 time.Timer 值不再被使用后，我们不必（但是推荐）终止之。 在多个协程中使用同一个 time.Timer 值比较容易写出不当的并发代码，所以尽量不要跨协程使用一个 Timer 值。 我们不应该依赖于 time.Timer 的 Reset 方法的返回值。此返回值只要是为了历史兼容性而存在的。 ","date":"2022-02-04","objectID":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/:6:10","tags":["并发"],"title":"Go 并发编程","uri":"/Notes/posts/golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"categories":["刷题"],"content":"1. 两数之和 easy 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 ","date":"2022-01-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:0:0","tags":["算法","数组"],"title":"1. 两数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"两重循环 时间复杂度 O(n^2^)，空间复杂度 O(1) class Solution: def twoSum(self, nums: List[int], target: int) -\u003e List[int]: for i in range(len(nums)): for j in range(i+1,len(nums)): if nums[i] +nums[j]==target: return [i,j] func twoSum(nums []int, target int) []int { for i,num1:=range nums{ for j,num2:=range nums[i+1:]{ if num1+num2==target{ return []int{i,j+i+1} } } } return nil } ","date":"2022-01-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:1:0","tags":["算法","数组"],"title":"1. 两数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"哈希表 键为数组中各元素的值，哈希表的值为数组中该值出现的位置 在哈希表中是否存在 target - nums[i] 的键，若存在则说明这两数相加结果为 target，返回结果。 class Solution: def twoSum(self, nums: List[int], target: int) -\u003e List[int]: d={} for i,num in enumerate(nums): if target-num in d.keys(): return [i,d[target-num]] d[num]=i func twoSum(nums []int, target int) []int { prevNums := map[int]int{} for i, num1 := range nums { num2 := target - num1 j, ok := prevNums[num2] if ok { return []int{j, i} } else { prevNums[num1] = i } } return []int{} } ","date":"2022-01-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/:2:0","tags":["算法","数组"],"title":"1. 两数之和","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/1.-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"},{"categories":["刷题"],"content":"2. 两数相加 mid 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 ","date":"2022-01-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:0:0","tags":["算法","数组"],"title":"2. 两数相加","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["刷题"],"content":"解 将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00 比如 987 + 23 = 987 + 023 = 1010 每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值 如果两个链表全部遍历完毕后，若有进位制，则在新链表最前方添加包含进位制的节点 时间复杂度 O(n)，空间复杂度 O(n) # Definition for singly-linked list. # class ListNode: # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution: def addTwoNumbers(self, l1: ListNode, l2: ListNode) -\u003e ListNode: up = 0 # 进位 node = ListNode() head = node # 记录头结点的位置 while True: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 _sum = val1+val2+up up = _sum//10 % 10 # 取十位为进位 add = _sum % 10 # 取个位 node.val = add if l1: l1 = l1.next if l2: l2 = l2.next if not l1 and not l2: if up \u003e 0: node.next = ListNode(val=up) break next = ListNode() node.next = next node = next return head /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { up := 0 node := \u0026ListNode{} head := node var val1, val2 int for { if l1 != nil { val1 = l1.Val } else { val1 = 0 } if l2 != nil { val2 = l2.Val } else { val2 = 0 } sum := val1 + val2 + up up = sum / 10 % 10 add := sum % 10 node.Val = add if l1 != nil { l1 = l1.Next } if l2 != nil { l2 = l2.Next } if l1 == nil \u0026\u0026 l2 == nil { if up \u003e 0 { node.Next = \u0026ListNode{Val: up} } break } node.Next=\u0026ListNode{} node =node.Next } return head } ","date":"2022-01-26","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/:1:0","tags":["算法","数组"],"title":"2. 两数相加","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/2.-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"},{"categories":["专业课"],"content":"设计模式 Python 实现 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:0:0","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"认识 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:1:0","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"设计模式 定义 设计模式是对软件设计中普遍存在或反复出向的各种问题所提出的解决方案。每一个设计模式系统地被命名、解释和评价了面向对象系统中一个重要和重复出现的设计 分类 创建型模式 隐藏底层模块的逻辑，关注怎么创建对象 工厂方法模式、抽象工厂模式、创建者模式、原型模式、单例模式 结构型模式 类之间如何协同工作，应该组成什么结构 适配器模式、桥模式、组合模式、装饰模式、外观模式、享元模式、代理模式。 行为型模式 关注行为，也就是方法，应该怎样某些行为 解释器模式、责任链模式、命令模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、访问者模式、模板方法模式。 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:1:1","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"接口 定义：若干抽象方法的集合 作用：限制实现接口的类必须按照接口给定的调用方式实现这些方法，对高层模块隐藏了类的内部实现 from abc import ABCMeta, abstractmethod # 具有抽象方法的类就是接口类， class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): \"\"\" 抽象方法，在实现的类中必须实现的方法。限制实现接口的类必须按照接口给定的调用方式实现这些方法 \"\"\" pass # 不能说是继承接口类，应该说是实现接口 class Alipay(Payment): def pay(self, money): \"\"\" 实现接口类中的必须实现的方法 :param money: :return: \"\"\" print(\"支付宝支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): \"\"\" 实现接口类中的必须实现的方法 :param money: :return: \"\"\" print(\"微信支付了%d元!\" % (money)) # 下面是高层代码，在调用的时候是看不到底层类的内部实现 a = Alipay() w = WechatPay() a.pay(100) w.pay(100) ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:1:2","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"面向对象设计原则 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:2:0","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"开放封闭原则 一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 即软件实体应该在不修改原代码的情况下进行修改。 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:2:1","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"里氏替换原则 里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。 根据上述理解，对里氏替换原则的定义可以总结如下： 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入参数）要比父类的方法更宽松 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的的输出/返回值）要比父类的方法更严格或相等 所有引用父类的地方必须能透明地使用其子类的对象 class User(object): def print_name(self): pass class VipUser(User): def print_name(self): \"\"\" 保证参数和返回值类型需要和父类一样 :return: \"\"\" pass def print_name(u): \"\"\" 不论使用User还是继承User的VipUser，调用的方式是一样的。这就要求User和VipUser的方法参数和返回值类型是一样的 :param u: :return: \"\"\" u.print_name() ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:2:2","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"依赖倒置原则 高层模块不应该依赖底层模块，二者都应该依赖抽象。 抽象不应该依赖细节，细节应该应该依赖抽象。 要针对接口编程，而不是针对实现编程 from abc import ABCMeta, abstractmethod # 接口，抽象不应该依赖细节 class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass # 底层代码和高层代码都是细节，细节应该依赖抽象 # 底层代码 class Alipay(Payment): def pay(self, money): print(\"支付宝支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) # 高层代码，高层模块不应该依赖底层模块，二者都应该依赖抽象 a = Alipay() w = WechatPay() a.pay(100) w.pay(100) ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:2:3","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"接口隔离原则 使用多个专门的接口，而不使用单一的总接口 高层的代码不应该依赖那些它不需要的接口 from abc import ABCMeta, abstractmethod class LandAnimal(metaclass=ABCMeta): @abstractmethod def walk(self): pass class WaterAnimal(metaclass=ABCMeta): @abstractmethod def swim(self): pass class SkyAnimal(metaclass=ABCMeta): @abstractmethod def fly(self): pass # 高层的代码不应该依赖那些它不需要的接口 class Tiger(LandAnimal): def walk(self): pass # 高层的代码不应该依赖那些它不需要的接口 class Frog(LandAnimal, WaterAnimal): def walk(self): pass ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:2:4","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"单一职责原则 不要存在多于一个导致类变更的原因，一个类只负责一项职责，一个类只做一件事。 把面向过程的代码放到类中，虽然用到了类，但不是面向对象。 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:2:5","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"创建型模式 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:0","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"简单工厂模式 简单工厂模式不在 23 种设计模式之中，但很重要。 简单工厂模式不直接向客户端暴露对象创建的细节，而是通过一个工厂类来负责创建产品类的实例。 简单工程模式的角色有：工厂角色、抽象产品角色、具体产品角色 from abc import ABCMeta, abstractmethod # 抽象产品角色，以什么样的表现去使用 class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass # 产品角色 class Alipay(Payment): def __init__(self, use_huabei=False): self.use_huabei = use_huabei def pay(self, money): if self.use_huabei == True: print(\"花呗支付了{0}元!\".format(money)) else: print(\"支付宝余额支付了{0}元!\".format(money)) # 产品角色 class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) # 工厂类角色 class PaymentFactory: def create_payment(self, method): if method == 'Alipay': return Alipay() elif method == 'WechatPay': return WechatPay() elif method == 'HuabeiPay': return Alipay(use_huabei=True) else: raise TypeError('No such payment named %s' % method) # 客户端调用。不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例 pf = PaymentFactory() p = pf.create_payment('HuabeiPay') p.pay(100) ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:1","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"工厂方法模式 简单工厂模式只创建一个工厂类，当有新的产品时，需要修改工厂类代码。 而工厂方法模式的每个具体产品对应一个具体的工厂类，不需要修改工厂类代码，并且同时也能满足隐藏对象创建的细节。 但是工厂方法模式也是有缺点的：每增加一个具体产品类，就必须增加一个相应的具体方法。 工厂模式方法模式的概念是定义了一个用于创建对象的接口（工厂接口），让子类决定实例化哪一个产品类。 角色有抽象工厂角色、具体工厂角色、抽象产品角色和具体产品角色。 from abc import ABCMeta, abstractmethod # 抽象产品角色 class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass # 具体产品角色 class Alipay(Payment): def __init__(self, use_huabei=False): self.use_huabei = use_huabei def pay(self, money): if self.use_huabei == True: print(\"花呗支付了{0}元!\".format(money)) else: print(\"支付宝余额支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) # 抽象工厂角色 class PaymentFactory(metaclass=ABCMeta): @abstractmethod def create_payment(self): pass # 具体工厂角色 class AlipayFactory(PaymentFactory): def create_payment(self): return Alipay() class WechatPayFactory(PaymentFactory): def create_payment(self): return Alipay() class HuabeiFactory(PaymentFactory): def create_payment(self): return Alipay(use_huabei=True) hfp = HuabeiFactory().create_payment() hfp.pay(100) # 花呗支付了100元! 缺点是每增加一个具体产品类，就必须增加一个相应的具体方法： from abc import ABCMeta, abstractmethod class Payment(metaclass=ABCMeta): @abstractmethod def pay(self, money): pass class Alipay(Payment): def __init__(self, use_huabei=False): self.use_huabei = use_huabei def pay(self, money): if self.use_huabei == True: print(\"花呗支付了{0}元!\".format(money)) else: print(\"支付宝余额支付了{0}元!\".format(money)) class WechatPay(Payment): def pay(self, money): print(\"微信支付了%d元!\" % (money)) class BankPay(Payment): def pay(self, money): print(\"银行支付了%d元!\" % (money)) # 创建产品的工厂类的接口 class PaymentFactory(metaclass=ABCMeta): @abstractmethod def create_payment(self): pass # 工厂类 class AlipayFactory(PaymentFactory): def create_payment(self): return Alipay() # 工厂类 class WechatPayPayFactory(PaymentFactory): def create_payment(self): return Alipay() # 工厂类 class HuabeiPayFactory(PaymentFactory): def create_payment(self): return Alipay(use_huabei=True) # 新增加银行支付的工厂类 class BankPayFactory(PaymentFactory): def create_payment(self): return BankPay() bfp = BankPayFactory().create_payment() bfp.pay(100) # 银行支付了100元! ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:2","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"抽象工厂模式 定义一个工厂类的接口让工厂的子类来创建一系列相关或者相互依赖的对象。 相比工厂方法模式，抽象工厂模式中的每一个具体工厂都生产一套产品。 下面是生产厂商生产一部手机的例子：生产一部手机如果说只需要手机壳、CPU和操作系统这三个类对象，其中每个类对象都有不同的种类。对每个具体工厂，分别生产一部手机需要的三个对象。 from abc import ABCMeta, abstractmethod # ------抽象的产品------ class PhoneShell(metaclass=ABCMeta): @abstractmethod def show_shell(self): pass class PhoneCPU(metaclass=ABCMeta): @abstractmethod def show_cpu(self): pass class PhoneOS(metaclass=ABCMeta): @abstractmethod def show_os(self): pass # ------具体的产品------ class SmallShell(PhoneShell): def show_shell(self): print('普通手机小手机壳') class BigShell(PhoneShell): def show_shell(self): print('普通手机大手机壳') class AppleShell(PhoneShell): def show_shell(self): print('苹果手机壳') class SnapDragonCPU(PhoneCPU): def show_cpu(self): print('骁龙CPU') class HuaweiCPU(PhoneCPU): def show_cpu(self): print('化为CPU') class AppleCPU(PhoneCPU): def show_cpu(self): print('苹果CPU') class AndroidOS(PhoneOS): def show_os(self): print('IOS系统') class AppleOS(PhoneOS): def show_os(self): print('安卓系统') # ------抽象的工厂------ class PhoneFactory(metaclass=ABCMeta): @abstractmethod def make_shell(self): pass @abstractmethod def make_cpu(self): pass @abstractmethod def make_os(self): pass # ------具体的工厂------ class HuaweiFactory(PhoneFactory): def make_shell(self): return SmallShell() def make_cpu(self): return HuaweiCPU() def make_os(self): return AndroidOS() class AppleFactory(PhoneFactory): def make_shell(self): return AppleShell() def make_cpu(self): return AppleCPU() def make_os(self): return AppleOS() # ------客户端------ class Phone: def __init__(self, shell, cpu, os): self.shell = shell self.cpu = cpu self.os = os def show_info(self): print('手机信息：') self.shell.show_shell() self.cpu.show_cpu() self.os.show_os() def make_phone(factory): shell = factory.make_shell() cpu = factory.make_cpu() os = factory.make_os() return Phone(shell, cpu, os) p = make_phone(HuaweiFactory()) p.show_info() \"\"\" 手机信息： 普通手机小手机壳 华为CPU IOS系统 \"\"\" 抽象工厂模式的角色有：抽象工厂角色、具体工厂角色、抽象产品角色、具体产品角色和客户端。 优点 将客户端和类的具体实现相分离； 每个工厂创建了一个完整的产品系列，使得易于交换产品系列； 有利于产品的一致性，即产品之间的约束关系。 缺点 难以支持新种类抽象产品。 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:3","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"建造者模式 建造者模式是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 角色 抽象创建者 具体创建者 指挥者 产品 建造者模式与抽象工厂模式相似，也用来创建复杂的对象。主要区别是 建造者模式着重一步步构造一个复杂对象（控制顺序），而抽象工厂模式着重于多个系列的产品对象 from abc import ABCMeta, abstractmethod # ------产品------ class Player: def __init__(self, face=None, body=None, arms=None, legs=None): self.face = face self.body = body self.arms = arms self.legs = legs def __str__(self): return '%s,%s,%s,%s' % (self.face, self.body, self.arms, self.legs) # ------抽象建造者------ class PlayerBuilder(metaclass=ABCMeta): @abstractmethod def build_face(self): pass @abstractmethod def build_body(self): pass @abstractmethod def build_arms(self): pass @abstractmethod def build_legs(self): pass # ------具体建造者,隐藏了一个产品的内部结构------ class GirlBuilder(PlayerBuilder): def __init__(self): self.player = Player() def build_face(self): self.player.face = '漂亮的脸蛋' def build_body(self): self.player.body = '苗条的身材' def build_arms(self): self.player.arms = '细细的胳膊' def build_legs(self): self.player.legs = '大长腿' # ------具体建造者，表示代码------ class MonsterBuilder(PlayerBuilder): def __init__(self): self.player = Player() def build_face(self): self.player.face = '绿脸' def build_body(self): self.player.body = '魁梧的身体' def build_arms(self): self.player.arms = '粗壮的胳膊' def build_legs(self): self.player.legs = '粗壮的大腿' # ------指挥者，构造代码(构造代码和表示代码分开)，可以对构造过程进行更加精细地控制------ class PlayerDirectory(): def builder_player(self, builder): \"\"\" 隐藏了装配过程 :param builder: :return: \"\"\" builder.build_face() builder.build_body() builder.build_arms() builder.build_legs() return builder.player # ------客户端------ builder = GirlBuilder() director = PlayerDirectory() p = director.builder_player(builder) print(p) # 漂亮的脸蛋,苗条的身材,细细的胳膊,大长腿 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:4","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"单例模式 单例模式保证一个类只有一个实例，并提供一个访问它的全局访问点。 优点是对唯一实例的受控访问（只有一个实例），单例相当于全局变量，但防止了命名空间被污染（变量命名不会有冲突）。 class Singleton: def __new__(cls, *args, **kwargs): if not hasattr(cls, \"_instance\"): cls._instance = super(Singleton, cls).__new__(cls) return cls._instance class MyClass(Singleton): def __init__(self, a): self.a = a ms1 = MyClass(1) ms2 = MyClass(2) print(ms1.a, ms2.a) print(id(ms1), id(ms2)) \"\"\" 2 2 139843914173312 139843914173312 \"\"\" 如果实例只出现一次，如： 日志系统中只需要创建一个日志对象（否则两个日志对象同时操作一个文件就会造成操作冲突）； 数据库连接池只需要创建一个对象来操作数据库（否则增加系统开销，浪费系统资源）； 操作系统只需要创建一个文件系统对象来操作文件系统。 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:5","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"创建型模式概述 抽象工厂模式和建造者模式相比于简单工厂模式和工厂方法模式而言更加灵活也更加复杂。 通常情况下，软件设计以简单工厂模式或工厂方法模式开始，当发现设计需要更大的灵活性的时候，则向更加复杂的设计模式演化。 ","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:3:6","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"结构型模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口，适配器使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。实现适配器的两种方式，类适配器使用多继承，对象适配器使用组合。组合就是一个类中放入另一类的对象。 先来看下组合： class A: pass class B: def __init__(): self.a = A() 类适配器模式使用示例： # 类适配器模式使用示例： from abc import ABCMeta, abstractmethod # 目标接口 class Payment(object, metaclass=ABCMeta): @abstractmethod def pay(self, money): pass class Alipay(Payment): def pay(self, money): print('支付了%d' % money) # 待适配的类 class BankPay(): def cost(self, money): print('银联支付了%d' % money) # 类适配器 class PaymentAdapter(Payment, BankPay): \"\"\" 把不兼容cost转换成pay \"\"\" def pay(self, money): self.cost(money) p = PaymentAdapter() p.pay(100) \"\"\" 银联支付了100 \"\"\" 对象适配器模式使用示例： # 类适配器模式使用示例： from abc import ABCMeta, abstractmethod # 目标接口 class Payment(object, metaclass=ABCMeta): @abstractmethod def pay(self, money): pass class Alipay(Payment): def pay(self, money): print('支付了%d' % money) # 待适配的类 class BankPay(): def cost(self, money): print('银联支付了%d' % money) # 待适配的类 class ApplePay(): def cost(self, money): print('苹果支付了%d' % money) # 对象适配器 class PaymentAdapter(Payment): def __init__(self, payment): self.payment = payment def pay(self, money): self.payment.cost(money) p = PaymentAdapter(ApplePay()) p.pay(100) p = PaymentAdapter(BankPay()) p.pay(100) \"\"\" 苹果支付了100 银联支付了100 \"\"\" 适配器模式有三种角色，分别是目标接口、待适配的类和适配器。适用场景是：想使用一个已存在的类，而它的接口不符合你的要求。想使用一些已经存在的类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。 桥模式 桥模式是将一个事物的两个维度分离，使其都可以独立地变化。当事物有两个维度的表现，两个维度都可能扩展时使用。优点是：抽象和实现相分离，扩展能力强。如果不使用桥模式，在任何维度进行扩展，需要改好多代码，因为使用到了继承： class Shape: pass class Rectangle(Shape): pass class Circle(Shape): pass class RedRectangle(Rectangle): pass class GreenRectangle(Rectangle): pass class RedCircle(Circle): pass class GreenCircle(Circle): pass 以上代码形状和颜色两个维度是通过类的继承关系紧密结合在一起，是紧耦合。紧耦合是是不可取的，应用桥模式的思想，可以使用组合来实现（松耦合）。如果需要画直线，直接加上直线的类。需要新颜色，直接加上颜色的类。两个维度都可以自由扩展，不需要添加很多代码。这里的角色有抽象、细化抽象、实现者和具体实现者： from abc import ABCMeta, abstractmethod # 抽象 class Shape(metaclass=ABCMeta): def __init__(self, color): self.color = color @abstractmethod def draw(self): pass # 实现 class Color(metaclass=ABCMeta): @abstractmethod def paint(self, shape): pass # 细化抽象 class Rectangle(Shape): name = '长方形' def draw(self): self.color.paint(self) # 如果要扩展形状，只需要添加形状类 class Circle(Shape): name = '圆形' def draw(self): self.color.paint(self) # 细化实现 class Red(Color): def paint(self, shape): print('画红色的%s' % shape.name) # 如果要扩展颜色，只需要添加颜色类 class Green(Color): def paint(self, shape): print('画绿色的%s' % shape.name) rectangle = Rectangle(Red()) rectangle.draw() circle = Circle(Green()) circle.draw() \"\"\" 画红色的长方形 画绿色的圆形 \"\"\" 3. 组合模式 将对象组合成树形结构以表示“部分-整体”的层次结构(特别是结构是递归的)，组合模式使得用户对单个对象和组合对象的使用具有一致性。优点是定义了包含基本对象和组合对象的层次结构；简化客户端代码，客户端可以一致地使用组合对象和单个对象；更加容易增加新类型的组件。 from abc import ABCMeta, abstractmethod # 抽象组件 class Graphic(metaclass=ABCMeta): @abstractmethod def draw(self): pass # 叶子组件 class Point(Graphic): def __init__(self, x, y): self.x = x self.y = y def __str__(self): return '点(%s,%s)' % (self.x, self.y) def draw(self): print(self) # 叶子组件 class Line(Graphic): def __init__(self, p1, p2): self.p1 = p1 self.p2 = p2 def __str__(self): return '线段[(%s,%s)]' % (self.p1, self.p2) def draw(self): print(self) # 复合组件 class Picture(Graphic): def __init__(self, iterable): self.children = [] for g in iterable: self.add(g) def add(self, graphic): self.children.append(graphic) def draw(self): for g in self.children: g.draw() # 简单图形 print('------简单图形------') p = Point(1, 2) l1 = Line(Point(1, 2), Point(3, 4)) l2 = Line(Point(5, 6), Point(7, 8)) print(p) print(l1) print(l2) print('------复合图形(p,l1,l2)------') # 复合图形 pic = Picture([p, l1, l2]) pic.draw() 4. 外观模式 外观模式为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层的接口，这个接口使得这一子系统更加容易使用。外观模式下的角色有外观和子系统类，优点是：减少系统相互依赖，提高灵活性，提高了安全性。下面看一个例子： # 子系统类 class CPU: def run(self): print('CPU start to run...') def stop(self): print('CPU stop to run...') # 子系统类 class Disk: def run(self): print('Disk start to run...') def stop(self): print('Disk stop to run...') # 子系统类 class Memory: def run(self): print('Memory start to run...') def stop(self): print('Memory stop to ru","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:4:0","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["专业课"],"content":"行为型模式 责任链模式 ​ 责任链模式的内容：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链并沿着这条链传递该请求，直到有一个对象处理它为止。责任链的角色有抽象处理者、具体处理者和客户端。 from abc import ABCMeta, abstractmethod # 抽象的处理者 class Handler(metaclass=ABCMeta): @abstractmethod def handle_leave(self, day): pass # 具体的处理者 class GeneralManager(Handler): def handle_leave(self, day): if day \u003c= 30: print('总经理准假%d' % day) else: print('可以辞职了！') # 具体的处理者 class DepartmentManager(Handler): def __init__(self): self.next = GeneralManager() def handle_leave(self, day): if day \u003c= 7: print('项目主管准假%d' % day) else: print('部门经理职权不足') self.next.handle_leave(day) # 具体的处理者 class ProjectDirector(Handler): def __init__(self): self.next = DepartmentManager() def handle_leave(self, day): if day \u003c= 3: print('项目主管准假%d' % day) else: print('项目主管职权不足') self.next.handle_leave(day) day = 20 p = ProjectDirector() p.handle_leave(day) \"\"\" 项目主管职权不足 部门经理职权不足 总经理准假20 \"\"\" ​ 使用场景：有多个对象可以处理一个请求，哪个对象处理由运行时决定；在不明确接收者的情况下，向多个对象中的一个提交一个请求。优点是降低耦合度，一个对象无需知道是其它哪一个对象处理其请求。 2. 观察者模式 ​ 观察者模式应用比较广泛，又被称为“发布-订阅”模式。它用来定义对象间一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖它的对象都得到通知并被自动更新。观察者模式的角色有：抽象主题、具体主题（发布者）、抽象观察者和具体观察者（订阅者）。 from abc import ABCMeta, abstractmethod # 抽象的订阅者 class Observer(metaclass=ABCMeta): @abstractmethod def update(self, notice): \"\"\" :param notice: Notice类的对象 :return: \"\"\" pass # 抽象的发布者：可以是接口，子类不需要实现，所以不需要定义抽象方法！ class Notice: def __init__(self): self.observers = [] def attach(self, obs): self.observers.append(obs) def detach(self, obs): self.observers.remove(obs) def notify(self): \"\"\" 推送 :return: \"\"\" for obs in self.observers: obs.update(self) # 具体的发布者 class StaffNotice(Notice): def __init__(self, company_info): super().__init__() # 调用父类对象声明observers属性 self.__company_info = company_info @property def company_info(self): return self.__company_info @company_info.setter def company_info(self, info): self.__company_info = info self.notify() # 具体的订阅者 class Staff(Observer): def __init__(self): self.company_info = None def update(self, notice): self.company_info = notice.company_info staff_notice = StaffNotice('初始化公司信息') staff1 = Staff() staff2 = Staff() staff_notice.attach(staff1) staff_notice.attach(staff2) # print(staff1.company_info) None # print(staff2.company_info) None staff_notice.company_info = '假期放假通知！' print(staff1.company_info) print(staff2.company_info) staff_notice.detach(staff2) staff_notice.company_info = '明天开会！' print(staff1.company_info) print(staff2.company_info) \"\"\" 假期放假通知！ 假期放假通知！ 明天开会！ 假期放假通知！ \"\"\" ​ 使用场景：当一个抽象模型有两个方面，其中一个方面依赖另一个方面。将这两者封装在独立对象中以使它们可以各自独立地改变和复用；当对一个对象的改变需要同时改变其它对象，而不知道具体有多少对象待改变；当一个对象必须通知其它对象，而它又不能假定其它对象是谁。换言之，你不希望这些对象是紧耦合的。优点：目标和观察者之间的抽象耦合最小；支持广播通信。 3. 策略模式 ​ 定义一个个算法，把它们封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化。角色有：抽象策略、具体策略和上下文。 from abc import abstractmethod, ABCMeta from datetime import datetime # 抽象策略 class Strategy(metaclass=ABCMeta): @abstractmethod def execute(self, data): pass # 具体策略 class FastStrategy(Strategy): def execute(self, data): print(\"使用较快的策略处理%s\" % data) # 具体策略 class SlowStrategy(Strategy): def execute(self, data): print(\"使用较慢的策略处理%s\" % data) # 上下文 class Context: def __init__(self, strategy, data): self.data = data self.strategy = strategy # 可以定义用户不知道的东西 self.date = datetime.now() def set_strategy(self, strategy): self.strategy = strategy def do_strategy(self): self.strategy.execute(self.data) data = \"Hello!\" # 使用较快的策略处理 fast_strategy = FastStrategy() context = Context(fast_strategy, data) context.do_strategy() # 使用较慢的策略处理 slow_strategy = SlowStrategy() context = Context(slow_strategy, data) context.do_strategy() \"\"\" 使用较快的策略处理Hello! 使用较慢的策略处理Hello! \"\"\" ​ 优点：定义了一些列可重用的算法和行为；消除了一些条件语句；可以提供相同行为的不同实现；缺点：客户必须了解不同的策略。 4. 模板方法模式 ​ 内容：定义一个操作中的算法骨架，将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。使用模板方法，需要用到两种角色，分别是抽象类和具体类。抽象类的作用是是定义抽象类（钩子操作），实现一个模板方法作为算法的骨架。具体类的作用实现原子操作。 from abc import ABCMeta, abstractmethod from time import sleep # 抽象类 class Window(metaclass=ABCMeta): @abstractmethod def start(self): # 原子操作/钩子操作 pass @abstractmethod def repaint(self): # 原子操作/钩子操作 pass @abstractmethod def stop(self):","date":"2022-01-21","objectID":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/:5:0","tags":["设计模式"],"title":"设计模式 Python 实现","uri":"/Notes/posts/python/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-python-%E5%AE%9E%E7%8E%B0/"},{"categories":["Python"],"content":"特性 ","date":"2022-01-18","objectID":"/Notes/posts/python/%E7%89%B9%E6%80%A7/:0:0","tags":["Python"],"title":"Python 特性","uri":"/Notes/posts/python/%E7%89%B9%E6%80%A7/"},{"categories":["Python"],"content":"特殊方法 也叫魔术方法、双下方法（dunder method） ","date":"2022-01-18","objectID":"/Notes/posts/python/%E7%89%B9%E6%80%A7/:1:0","tags":["Python"],"title":"Python 特性","uri":"/Notes/posts/python/%E7%89%B9%E6%80%A7/"},{"categories":["Python"],"content":"迭代器 ","date":"2022-01-18","objectID":"/Notes/posts/python/%E7%89%B9%E6%80%A7/:2:0","tags":["Python"],"title":"Python 特性","uri":"/Notes/posts/python/%E7%89%B9%E6%80%A7/"},{"categories":["Python"],"content":"生成器 ","date":"2022-01-18","objectID":"/Notes/posts/python/%E7%89%B9%E6%80%A7/:2:1","tags":["Python"],"title":"Python 特性","uri":"/Notes/posts/python/%E7%89%B9%E6%80%A7/"},{"categories":["Golang"],"content":"ioutil 虽然 io 包提供了不少类型、方法和函数，但有时候使用起来不是那么方便。比如读取一个文件中的所有内容。为此，标准库中提供了一些常用、方便的 IO 操作函数。 ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:0:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"NopCloser 函数 有时候我们需要传递一个 io.ReadCloser 的实例，而我们现在有一个 io.Reader 的实例，比如：strings.Reader ，这个时候 NopCloser 就派上用场了。它包装一个 io.Reader，返回一个 io.ReadCloser ，而相应的 Close 方法啥也不做，只是返回 nil。 比如，在标准库 net/http 包中的 NewRequest，接收一个 io.Reader 的 body，而实际上，Request 的 Body 的类型是 io.ReadCloser，因此，代码内部进行了判断，如果传递的 io.Reader 也实现了 io.ReadCloser 接口，则转换，否则通过ioutil.NopCloser 包装转换一下。相关代码如下： rc, ok := body.(io.ReadCloser) if !ok \u0026\u0026 body != nil { rc = ioutil.NopCloser(body) } ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:1:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"ReadAll 函数 很多时候，我们需要一次性读取 io.Reader 中的数据。考虑到读取所有数据的需求比较多，Go 提供了 ReadAll 这个函数，用来从io.Reader 中一次读取所有数据。 func ReadAll(r io.Reader) ([]byte, error) 阅读该函数的源码发现，它是通过 bytes.Buffer 中的 ReadFrom 来实现读取所有数据的。该函数成功调用后会返回 err == nil 而不是 err == EOF。(成功读取完毕应该为 err == io.EOF，这里返回 nil 由于该函数成功期望 err == io.EOF，符合无错误不处理的理念) ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:2:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"ReadDir 函数 笔试题：编写程序输出某目录下的所有文件（包括子目录） 是否见过这样的笔试题？ 在 Go 中如何输出目录下的所有文件呢？首先，我们会想到查 os 包，看 File 类型是否提供了相关方法 在 ioutil 中提供了一个方便的函数：ReadDir，它读取目录并返回排好序的文件和子目录名（ []os.FileInfo ） func main() { dir := os.Args[1] listAll(dir,0) } func listAll(path string, curHier int){ fileInfos, err := ioutil.ReadDir(path) if err != nil{fmt.Println(err); return} for _, info := range fileInfos{ if info.IsDir(){ for tmpHier := curHier; tmpHier \u003e 0; tmpHier--{ fmt.Printf(\"|\\t\") } fmt.Println(info.Name(),\"\\\\\") listAll(path + \"/\" + info.Name(),curHier + 1) }else{ for tmpHier := curHier; tmpHier \u003e 0; tmpHier--{ fmt.Printf(\"|\\t\") } fmt.Println(info.Name()) } } } ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:3:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"ReadFile 函数 ReadFile 读取整个文件的内容，由于这种需求很常见，因此 Go 提供了 ReadFile 函数，方便使用。 ReadFile 的实现和 ReadAll 类似，不过，ReadFile 会先判断文件的大小，给 bytes.Buffer 一个预定义容量，避免额外分配内存。 func ReadFile(filename string) ([]byte, error) ReadFile 从 filename 指定的文件中读取数据并返回文件的内容。成功的调用返回的err 为 nil 而非 EOF。因为本函数定义为读取整个文件，它不会将读取返回的 EOF 视为应报告的错误。(同 ReadAll ) ReadFile 源码中先获取了文件的大小，当大小 \u003c 1e9 时，才会用到文件的大小。按源码中注释的说法是 FileInfo 不会很精确地得到文件大小。 ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:4:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"WriteFile 函数 func WriteFile(filename string, data []byte, perm os.FileMode) error WriteFile 将 data 写入 filename 文件中 当文件不存在时会根据 perm 指定的权限进行创建一个 文件存在时会先清空文件内容。 对于 perm 参数，一般可以指定为：0666 ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:5:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"TempDir 函数 操作系统中一般都会提供临时目录，比如 linux 下的 /tmp 目录（通过 os.TempDir() 可以获取到)。 有时候，我们自己需要创建临时目录，比如 Go 工具链源码中（src/cmd/go/build.go），通过 TempDir 创建一个临时目录，用于存放编译过程的临时文件： b.work, err = ioutil.TempDir(\"\", \"go-build\") 第一个参数如果为空，表明在系统默认的临时目录（ os.TempDir ）中创建临时目录；第二个参数指定临时目录名的前缀，该函数返回临时目录的路径。 ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:6:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"TempFile 函数 相应的，TempFile 用于创建临时文件。如 gofmt 命令的源码中创建临时文件： f1, err := ioutil.TempFile(\"\", \"gofmt\") 参数和 ioutil.TempDir 参数含义类似。 注意：创建者创建的临时文件和临时目录要负责删除这些临时目录和文件。如删除临时文件： defer func() { f.Close() os.Remove(f.Name()) }() ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:7:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"Discard 变量 Discard 对应的类型（type devNull int）实现了 io.Writer 接口，同时，为了优化 io.Copy 到 Discard，避免不必要的工作，它也实现了 io.ReaderFrom 接口。 devNull 在实现 io.Writer 接口时，只是简单的返回 func (devNull) Write(p []byte) (int, error) { return len(p), nil } 而 ReadFrom 的实现是读取内容到一个 buf 中，最大也就 8192 字节，其他的会丢弃（当然，这个也不会读取）。 又是一些我看不懂的东西。。 ","date":"2022-01-04","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/:8:0","tags":["Go 库","io"],"title":"Go ioutil 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/ioutil/"},{"categories":["Golang"],"content":"database Go 使用 SQL 与类 SQL 数据库的惯例是通过标准库 database/sql。这是一个对关系型数据库的通用抽象，它提供了标准的、轻量的、面向行的接口 import ( \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func main() { db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/hello\") if err != nil { log.Fatal(err) } defer db.Close() err = db.Ping() if err != nil { // do something here } } ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:0:0","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"快速开始 在 Go 中访问数据库需要用到 sql.DB 接口：它可以创建语句 (statement) 和事务 (transaction)，执行查询，获取结果。 sql.DB 并不是数据库连接，也并未在概念上映射到特定的数据库 (Database) 或模式 (schema)。它只是一个抽象的接口，不同的具体驱动有着不同的实现方式。 通常而言，sql.DB 会处理一些重要而麻烦的事情，例如操作具体的驱动打开/关闭实际底层数据库的连接，按需管理连接池。 sql.DB 这一抽象让用户不必考虑如何管理并发访问底层数据库的问题。当一个连接在执行任务时会被标记为正在使用。用完之后会放回连接池中。不过用户如果用完连接后忘记释放，就会产生大量的连接，极可能导致资源耗尽 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:0","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"导入驱动 Mysql：“github.com/go-sql-driver/mysql” sqlite：“github.com/mattn/go-sqlite3” ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:1","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"建立连接池 db, err := sql.Open(\"mysql\", \"user:password@tcp(127.0.0.1:3306)/hello\") sql.DB 刚开始建立时是懒加载的，不会自动创建新的连接，只有使用 Ping() 或者运行查询时才会自动生成一个新的连接然后去连接数据库，只有这个时候才能确定数据库是否真的OK，所以建议一定要在 sql.Open 后运行 Ping() 确定数据连接正常运行。 sql.DB 是连接后初始化的一个连接池，通常全局就初始化这一个连接池，并且长期运行，所有后续数据库操作都使用该连接池进行。 sql.DB 内部自动维护连接池，当需要连接时自动选择一个空闲的连接，如果没有空闲就建立一个新的连接，当连接不再使用时放回连接池中，内部会自动管理空闲回收。 数据库的连接是一个比较大的耗时和资源消耗操作，首选需要经典的 TCP 三次握手，tcp 连接后数据库需要分配连接资源，同时根据连接信息鉴权等，所以建议使用长连接。对应到我们的 go 中，sql.DB 会自动管理连接池，最好全局使用一个连接池，不要重复的 open 或者 close。 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:2","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"查询 sql.DB 支持 4 种查询： db.Query() db.QueryRow() db.Prepare(sql) stmt.Query(args) db.Exec() db.Query() 返回多行数据，需要依次遍历，并且需要自己关闭查询结果集 db.QueryRow() 是专门查询一行数据的一个语法糖，返回 ErrNoRow 或者一行数据，不需要自己关闭结果集 db.Prepare() 是预先将一个数据库连接（con）和一个条 sql 语句绑定并返回 stmt 结构体代表这个绑定后的连接，然后运行 stmt.Query() 或者 stmt.QueryRow()；stmt 是并发安全的。之所以这样设计，是因为每次直接调用 db.Prepare 都会自动选择一个可用的 con，每次选择的可能不是同一个 con db.Exec() 适用于执行 insert、update、delete 等不需要返回结果集的操作 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:3","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"结果集 只有 db.Query() 返回结果集 var ( id int name string ) rows, err := db.Query(\"select id, name from users where id = ?\", 1) if err != nil { log.Fatal(err) } defer rows.Close() for rows.Next() { err := rows.Scan(\u0026id, \u0026name) if err != nil { log.Fatal(err) } log.Println(id, name) } err = rows.Err() if err != nil { log.Fatal(err) } Close 是可以重复调用的，关闭已经关闭的结果集不会报错 使用 for rows.Next() 遍历结果集，这样迭代一行一行处理结果，节约内存分配，同时防止出现 OOM 的问题 使用 rows.Scan 将一行数据填入指定的变量中，scan 会自动根据目标变量的类型处理类型转换的问题，比如数据库中是 varchar，但目标变量是 int，那么 scan 会自动转换，当然如果转化出现 error 会返回 error ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:4","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"事务 tx := db.Begin() tx.Commit() tx.Rollback() 事务是使用 db.begin 开始，以 db.commit/db.rollback 结束 普通的 db.Query/db.QueryRow 自动从连接池中选择一个可用连接，运行结束后会自动将连接放回连接池，下次运行再次重复这个过程 db.begin 会自动从连接池中选择一个连接并返回一直持有该连接的 tx（和 db.Prepare 有点像），后续所有事务操作都用 tx，这样能保证是在用一个连接内运行事务，只有 commit/rollback 才会释放连接 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:5","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"错误处理 结果集遍历后 error，每次 for rows.Next 结束后要跟一个 rows.Err() 检测 for rows.Next() { // ... } if err = rows.Err(); err != nil { // handle the error here } 结果集遍历 close error if err = rows.Close(); err != nil { // but what should we do if there's an error? log.Println(err) } QueryRow() Error err = db.QueryRow(\"select name from users where id = ?\", 1).Scan(\u0026name) if err != nil { log.Fatal(err) } QueryRow 的结果是在 Scan 时才会出现 Mysql 特定 Error if driverErr, ok := err.(*mysql.MySQLError); ok { // Now the error number is accessible directly if driverErr.Number == 1045 { // Handle the permission-denied error } } 连接没释放问题 事务没有 commit 或者 rollback 查询集没有 close 查询参数问题 Mysql 使用？做参数，防止 sql 注入 既然是参数，就只能当参数，不可以用于其他部分，也不能做插值 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:6","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"标准库 sql 不支持但常用的特性 不支持多条 sql 执行 database/sql 并没有对在一次查询中执行多条 SQL 语句的显式支持，具体的行为以驱动的实现为准。所以对于 _, err := db.Exec(\"DELETE FROM tbl1; DELETE FROM tbl2\") // Error/unpredictable result 这样的查询，怎样执行完全由驱动说了算，用户并无法确定驱动到底执行了什么，又返回了什么。 不支持返回多个结果集 不支持存储过程（Mysql 驱动目前不支持） 不支持 Scan 到 map、struct 不建议 uint64 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:7","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"处理空值 可空列（Nullable Column）非常的恼人，容易导致代码变得丑陋。如果可以，在设计时就应当尽量避免。因为： Go 语言的每一个变量都有着默认零值，当数据的零值没有意义时，可以用零值来表示空值。但很多情况下，数据的零值和空值实际上有着不同的语义。单独的原子类型无法表示这种情况。 标准库只提供了有限的四种 Nullable type：NullInt64, NullFloat64, NullString, NullBool。并没有诸如NullUint64，NullYourFavoriteType，用户需要自己实现。 空值有很多麻烦的地方。例如用户认为某一列不会出现空值而采用基本类型接收时却遇到了空值，程序就会崩溃。这种错误非常稀少，难以捕捉、侦测、处理，甚至意识到。 database\\sql 提供了四种基本可空数据类型：使用基本类型和一个布尔标记的复合结构体表示可空值。例如： type NullInt64 struct { Int64 int64 Valid bool // Valid is true if Int64 is not NULL } 可空类型的使用方法与基本类型一致： for rows.Next() { var s sql.NullString err := rows.Scan(\u0026s) // check err if s.Valid { // use s.String } else { // handle NULL case } } ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:8","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"处理动态列 Scan() 函数要求传递给它的目标变量的数目，与结果集中的列数正好匹配，否则就会出错。 但总有一些情况，用户事先并不知道返回的结果到底有多少列，例如调用一个返回表的存储过程时。 在这种情况下，使用 rows.Columns() 来获取列名列表。在不知道列类型情况下，应当使用 sql.RawBytes 作为接受变量的类型。获取结果后自行解析。 cols, err := rows.Columns() if err != nil { // handle this.... } // 目标列是一个动态生成的数组 dest := []interface{}{ new(string), new(uint32), new(sql.RawBytes), } // 将数组作为可变参数传入Scan中。 err = rows.Scan(dest...) // ... ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:1:9","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"database/sql import \"database/sql\" sql 包提供了保证 SQL 或类 SQL 数据库的泛用接口。 使用 sql 包时必须注入（至少）一个数据库驱动。 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:0","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"type DB type DB struct { // 内含隐藏或非导出字段 } DB 是一个数据库（操作）句柄，代表一个具有零到多个底层连接的连接池。它可以安全的被多个 go 程同时使用。 sql.DB 不是一个连接，它是数据库的抽象接口。它可以根据 driver 驱动打开关闭数据库连接，管理连接池。 正在使用的连接被标记为繁忙，用完后回到连接池等待下次使用。所以，如果你没有把连接释放回连接池，会导致过多连接使系统资源耗尽。 sql 包会自动创建和释放连接；它也会维护一个闲置连接的连接池。如果数据库具有单连接状态的概念，该状态只有在事务中被观察时才可信。 一旦调用了 DB.Begin，返回的 Tx 会绑定到单个连接。当调用事务 Tx 的 Commit 或 Rollback 后，该事务使用的连接会归还到 DB 的闲置连接池中。 连接池的大小可以用 SetMaxIdleConns 方法控制。 func Open func Open(driverName, dataSourceName string) (*DB, error) Open 打开一个 dirverName 指定的数据库，dataSourceName 指定数据源，一般包至少括数据库文件名和（可能的）连接信息。 第一个参数是调用的驱动名，比如下面的例子中使用的是 github.com/go-sql-driver/mysql 中注册的驱动 “mysql” 第二个参数依赖与特定驱动的语法，用来连接数据库，通常是 URL 的形式，如 “root:user78@/test” 大多数用户会通过数据库特定的连接帮助函数打开数据库，返回一个 *DB。 Go 标准库中没有数据库驱动。参见 http://golang.org/s/sqldrivers 获取第三方驱动。 Open 函数不创建与数据库的连接，也不验证其参数。它可能会延迟到你第一次调用该数据库时才回去真正创建与数据库的连接。所以如果要立即检查数据源的名称是否合法，或者数据库是否实际可用，应调用返回值的 Ping 方法。 func (*DB) Ping func (db *DB) Ping() error Ping 检查与数据库的连接是否仍有效，如果需要会创建连接。 func (*DB) Close func (db *DB) Close() error Close 关闭数据库，释放任何打开的资源。一般不会关闭 DB，因为 DB 句柄通常被多个 go 程共享，并长期活跃。 举例，正确是不会报错： package main import( \"log\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") // 格式为\"user:password@/dbname\" defer db.Close() if err != nil{ panic(err) } //使用Ping检查数据库是否实际可用 if err = db.Ping(); err != nil{ log.Fatal(err) } } 如果写错密码，则会返回： userdeMBP:go-learning user$ go run test.go 2019/02/20 19:51:00 Error 1045: Access denied for user 'root'@'localhost' (using password: YES) exit status 1 可见调用 sql.Open() 函数时并没有报错，是调用 db.Ping() 函数时才报出的密码错误 返回的 DB 可以安全的被多个 go 程同时使用，并会维护自身的闲置连接池。这样一来，Open 函数只需调用一次。很少需要关闭 DB，因为 sql.DB 对象是为了长连接设计的，不要频繁使用 Open() 和 Close() 函数，否则会导致各种错误。 因此应该为每个待访问的数据库创建一个 sql.DB 实例，并在用完前保留它。如果需要短连接使用，那么可以将其作为函数的参数传递给别的 function 的参数使用，而不是在这个 function 中调用 Open() 和 Close() 再建立已经创建的 sql.DB 实例，或者将其设置为全局变量。 func (*DB) Driver func (db *DB) Driver() driver.Driver Driver 方法返回数据库下层驱动。 下面的四个函数用于进行数据库操作 func (*DB) Exec func (db *DB) Exec(query string, args ...interface{}) (Result, error) Exec 执行一次命令（包括查询、删除、更新、插入等），不返回数据集，返回的结果是 Result Result 接口允许获取执行结果的元数据。参数 args 表示 query 中的占位参数。 func (*DB) Query func (db *DB) Query(query string, args ...interface{}) (*Rows, error) Query 执行一次查询，返回多行结果（即 Rows），一般用于执行 select 命令。 参数 args 表示 query 中的占位参数。 上面两个的差别在于：Query 会返回查询结果 Rows, Exec 不会返回查询结果，只会返回一个结果的状态 Result 所以一般进行不需要返回值的 DDL 和增删改等操作时会使用 Exec，查询则使用 Query。当然这主要还是取决于是否需要返回值 func (*DB) QueryRow func (db *DB) QueryRow(query string, args ...interface{}) *Row QueryRow执行一次查询，并期望返回最多一行结果（即Row）。QueryRow总是返回非nil的值，直到返回值的Scan方法被调用时，才会返回被延迟的错误。（如：未找到结果） func (*DB) Prepare func (db *DB) Prepare(query string) (*Stmt, error) Prepare 创建一个准备好的状态用于之后的查询和命令，即准备一个需要多次使用的语句，供后续执行用。返回值可以同时执行多个查询和命令。 func (*DB) Begin func (db *DB) Begin() (*Tx, error) Begin开始一个事务。隔离水平由数据库驱动决定。 例 首先先在 mysql 中创建数据库 test，并生成两个表，一个是用户表 userinfo，一个是关联用户信息表 userdetail。使用 workbench 进行创建，首先创建数据库 test： CREATESCHEMA`test`DEFAULTCHARACTERSETutf8; 然后创建表： use test; create table `userinfo` ( `uid` int(10) not null auto_increment, `username` varchar(64) null default null, `department` varchar(64) null default null, `created` date null default null, primary key (`uid`) ); create table `userdetail`( `uid` int(10) not null default '0', `intro` text null, `profile` text null, primary key (`uid`) ); 接下来就示范怎么使用 database/sql 接口对数据库进行增删改查操作： 当然运行前首先需要下载驱动： go get -u github.com/go-sql-driver/mysql 当然，如果你连接的是 sqlite3 数据库，那么你要下载的驱动是： http://github.com/mattn/go-sqlite3 举例； package main import( \"fmt\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func checkErr(err error){ if err != nil{ panic(err) } } func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") // 格式为\"user:password@/dbname\" defer db.Close() checkErr(err) // 插入数据 stmt, err := db.Prepare(\"insert userinfo set username = ?,department=?,created=?\") checkErr(err) // 执行准备好的Stmt res, err := stmt.Exec(\"user1\", \"computing\", \"2019-02-20\") checkErr(err) // 获取上一个，即上面insert操作的ID id, err := res.LastInsertId() checkErr(err) fmt.Println(id) ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:1","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"type Result type Result interface { LastInsertId() (int64, error) RowsAffected() (int64, error) } Result 是对已执行的 SQL 命令的总结。 LastInsertId 返回一个数据库生成的回应命令的整数。 当插入新行时，一般来自一个\"自增\"列。 不是所有的数据库都支持该功能，该状态的语法也各有不同。 RowsAffected 返回被 update、insert 或 delete 命令影响的行数。 不是所有的数据库都支持该功能。 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:2","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"type Row 上面的 DB 的函数 Query() 和 QueryRow() 会返回 ROWs 和 ROW，因此下面就是如何去得到返回结果的更多详细的信息 type Row struct { // 内含隐藏或非导出字段 } QueryRow 方法返回 Row，代表单行查询结果。 func (*Row) Scan func (r *Row) Scan(dest ...interface{}) error Scan 将该行查询结果各列分别保存进 dest 参数指定的值中。如果该查询匹配多行，Scan 会使用第一行结果并丢弃其余各行。如果没有匹配查询的行，Scan 会返回 ErrNoRows。 举例：一开始数据库中为空，因此调用 Scan 会返回错误： package main import( \"fmt\" \"log\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") //后面格式为\"user:password@/dbname\" defer db.Close() if err != nil{ panic(err) } //使用Ping检查数据库是否实际可用 if err = db.Ping(); err != nil{ log.Fatal(err) } //查询数据 var uid int var username, department, created string err = db.QueryRow(\"select * from userinfo\").Scan(\u0026uid, \u0026username, \u0026department, \u0026created) switch { case err == sql.ErrNoRows: log.Printf(\"No user with that ID.\") // 返回 2019/02/21 10:38:33 No user with that ID. case err != nil: log.Fatal(err) default: fmt.Printf(\"Username is %s\\n\", username) } } 因此如果先插入数据再调用 QueryRow 则不会出错了： package main import( \"fmt\" \"log\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") // 格式为\"user:password@/dbname\" defer db.Close() if err != nil{ log.Fatal(err) } // 使用Ping检查数据库是否实际可用 if err = db.Ping(); err != nil{ log.Fatal(err) } stmt, err := db.Prepare(\"insert userinfo set username =?,department=?,created=?\") if err != nil{ log.Fatal(err) } _, err = stmt.Exec(\"testQueryRow\", \"computing\", \"2019-02-21\") if err != nil{ log.Fatal(err) } // 查询数据 var uid int var username, department, created string err = db.QueryRow(\"select * from userinfo\").Scan(\u0026uid, \u0026username, \u0026department, \u0026created) switch { case err == sql.ErrNoRows: log.Printf(\"No user with that ID.\") case err != nil: log.Fatal(err) default: fmt.Printf(\"Uid is %v, username is %s, department is %s, created at %s\\n\", uid, username, department, created) } } 返回： userdeMBP:go-learning user$ go run test.go Uid is 3, username is testQueryRow, department is computing, created at 2019-02-21 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:3","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"type Rows type Rows struct { // 内含隐藏或非导出字段 } Rows 是查询的结果。它的游标指向结果集的第零行，使用 Next 方法来遍历各行结果： rows, err := db.Query(\"SELECT ...\") ... defer rows.Close() for rows.Next() { var id int var name string err = rows.Scan(\u0026id, \u0026name) ... } err = rows.Err() // 在退出迭代后检查错误 ... func (*Rows) Columns func (rs *Rows) Columns() ([]string, error) Columns 返回列名。如果 Rows 已经关闭会返回错误。 func (*Rows) Scan func (rs *Rows) Scan(dest ...interface{}) error Scan 将当前行各列结果填充进 dest 指定的各个值中，用于在迭代中获取一行结果。 如果某个参数的类型为 []byte，Scan 会保存对应数据的拷贝，该拷贝为调用者所有，可以安全地修改或无限期地保存。如果参数类型为 *RawBytes 可以避免拷贝；参见 RawBytes 的文档获取其使用的约束。 如果某个参数的类型为 *interface{}，Scan 会不做转换的拷贝底层驱动提供的值。如果值的类型为 []byte，会进行数据的拷贝，调用者可以安全使用该值。 func (*Rows) Next func (rs *Rows) Next() bool Next 准备用于 Scan 方法的下一行结果。如果成功会返回 true，如果没有下一行或者出现错误会返回 false。Err() 方法应该被调用以区分这两种情况。 每一次调用 Scan 方法，甚至包括第一次调用该方法，都必须在前面先调用 Next 方法。 func (*Rows) Close func (rs *Rows) Close() error Close 关闭 Rows，阻止对其更多的列举。 如果 Next 方法返回 false，Rows 会自动关闭，满足检查 Err 方法结果的条件。Close 方法是幂等的（即多次调用不会出错），不影响 Err 方法的结果。 用于关闭结果集 Rows。结果集引用了数据库连接，并会从中读取结果。读取完之后必须关闭它才能避免资源泄露。只要结果集仍然打开着，相应的底层连接就处于忙碌状态，不能被其他查询使用。 func (*Rows) Err func (rs *Rows) Err() error Err 返回可能的、在迭代时出现的错误，即用于在退出迭代后检查错误。Err 需在显式或隐式调用 Close 方法后调用，即如果 Next 方法返回 false，Rows 会自动关闭，相当于调用了 Close()。 正常情况下迭代退出是因为内部产生的 EOF 错误（即数据读取完毕），使得下一次 rows.Next() == false，从而终止循环；在迭代结束后要检查错误，以确保迭代是因为数据读取完毕，而非其他“真正”错误而结束的。 举例： 包括上面的例子，这里再插入一条数据，这样数据库中就有两条数据了 package main import( \"fmt\" \"log\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") // 格式为\"user:password@/dbname\" defer db.Close() if err != nil{ log.Fatal(err) } // 使用Ping检查数据库是否实际可用 if err = db.Ping(); err != nil{ log.Fatal(err) } stmt, err := db.Prepare(\"insert userinfo set username =?,department=?,created=?\") if err != nil{ log.Fatal(err) } _, err = stmt.Exec(\"testQuery\", \"data mining\", \"2019-02-21\") if err != nil{ log.Fatal(err) } // 查询数据 rows, err := db.Query(\"select * from userinfo\") if err != nil{ log.Fatal(err) } defer rows.Close() // 迭代结果 var uid int var username, department, created string for rows.Next() { if err = rows.Scan(\u0026uid, \u0026username, \u0026department, \u0026created); err != nil { log.Fatal(err) } fmt.Printf(\"Uid is %v, username is %s, department is %s, created at %s\\n\", uid, username, department, created) } // 查看迭代时是否出错以及出的是什么错 if rows.Err() != nil { log.Fatal(err) } } 返回： userdeMBP:go-learning user$ go run test.go Uid is 3, username is testQueryRow, department is computing, created at 2019-02-21 Uid is 4, username is testQuery, department is data mining, created at 2019-02-21 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:4","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"type Stmt 在调用 db.Prepare() 后会返回 *Stmt，即准备好的语句 一般一个会多次进行查询的语句就应该将其设置为准备好的语句。 Stmt 是和单个数据库直接绑定的。客户端会发送一个带有占位符，如 ？的 SQL 语句的 Stmt 到服务端，然后服务端会返回一个 Stmt ID，说明给你绑定的连接是哪一个。然后之后当客户端要执行该 Stmt 时，就会发送 ID 和参数来绑定连接并执行操作。 要注意的是不能直接为 Stmt 绑定连接，连接只能与 DB 和 Tx 绑定，当我们生成一个 Stmt 时，首先它会自动在连接池中绑定一个空闲连接，然后 Stmt 会记住该连接，然后之后执行时尝试使用这个连接，如果不可用，如连接繁忙或关闭，则会重新准备语句并再绑定一个新的连接 Stmt 中可以执行的方法与 db 中的方法十分类似 func (*Stmt) Exec func (*Stmt) Query func (*Stmt) QueryRow func (*Stmt) Close package main import( \"fmt\" \"log\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") //后面格式为\"user:password@/dbname\" defer db.Close() if err != nil{ log.Fatal(err) } //使用Ping检查数据库是否实际可用 if err = db.Ping(); err != nil{ log.Fatal(err) } stmt1, err := db.Prepare(\"insert userinfo set username =?,department=?,created=?\") if err != nil{ log.Fatal(err) } _, err = stmt1.Exec(\"testStmtExecAndQueryRow\", \"accounting\", \"2019-02-21\") if err != nil{ log.Fatal(err) } defer stmt1.Close() stmt2, err := db.Prepare(\"select * from userinfo where uid =?\") if err != nil{ log.Fatal(err) } //查询数据 var uid int var username, department, created string err = stmt2.QueryRow(5).Scan(\u0026uid, \u0026username, \u0026department, \u0026created) if err != nil{ log.Fatal(err) } fmt.Printf(\"Uid is %v, username is %s, department is %s, created at %s\\n\", uid, username, department, created) defer stmt2.Close() } 输出 userdeMBP:go-learning user$ go run test.go Uid is 5, username is testStmtExecAndQueryRow, department is accounting, created at 2019-02-21 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:5","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"type Tx db.Begin() 函数会返回 *Tx。Go 中事务（Tx）是一个持有数据库连接的对象，它允许用户在同一个连接上执行上面提到的各类操作。 使用它的原因是：Tx 上执行的方法都保证是在同一个底层连接上执行的，这样对连接状态的修改将会一直对后续的操作起作用 然而 DB 的方法就不会保证是在同一条连接上执行，如果之前的连接繁忙或关闭，那么就会使用其他的连接 Tx 和 Stmt 不能分离，意思就是 Tx 必须调用自己的 Tx.Prepare() 函数来生成 Stmt 来供自己使用，而不能使用 DB 生成的 Stmt，因为这样他们使用的必定不是同一个连接。 当然，如果你想要在该事务中使用已存在的状态，参见 Tx.Stmt 方法，将 DB 的 Stmt 转成 Tx 的 Stmt。 type Tx struct { // 内含隐藏或非导出字段 } Tx 代表一个进行中的数据库事务。 一次事务必须以对 Commit 或 Rollback 的调用结束。 调用 Commit 或 Rollback 后，所有对事务的操作都会失败并返回错误值 ErrTxDone。 func (*Stmt) Exec func (*Stmt) Query func (*Stmt) QueryRow 事务中的多条语句 因为事务保证在它上面执行的查询都由同一个连接来执行，因此事务中的语句必需按顺序一条一条执行。 对于返回结果集的查询，事务必须在结果集执行 Close() 之后才能进行下一次查询。 用户如果尝试在前一条语句的结果还没读完前就执行新的查询，连接就会失去同步。这意味着事务中返回结果集的语句都会占用一次单独的网络往返。 func (*Tx) Prepare func (tx *Tx) Prepare(query string) (*Stmt, error) Prepare 准备一个专用于该事务的状态。返回的该事务专属状态操作在 Tx 递交或回滚后不能再使用，因此一定要在事务结束前，即调用 Commit() 或 Rollback 函数前关闭准备语句。 在事务中使用 defer stmt.Close() 是相当危险的。因为当事务 Tx 结束后，它会先释放自己持有的数据库 DB 连接，但事务 Tx 创建的未关闭 Stmt 仍然保留着对事务 Tx 连接的引用。 在事务结束后执行 stmt.Close()，他就会根据引用去查找之前的数据库 DB 连接，然后想要释放它。但是其实数据库的连接早就被释放了，而且如果原来释放的数据库 DB 连接已经被其他查询获取并使用，就会产生竞争，极有可能破坏连接的状态。因此两者的释放顺序是十分重要的 先释放在事务 Tx 的状态 Stmt，再释放事务 Tx，最后释放 db package main import( \"fmt\" \"log\" \"database/sql\" _ \"github.com/go-sql-driver/mysql\" ) func checkErr(err error){ if err != nil{ log.Fatal(err) } } func main() { db, err := sql.Open(\"mysql\", \"root:user78@/test\") // 格式为\"user:password@/dbname\" defer db.Close() checkErr(err) // 使用Ping检查数据库是否实际可用 if err = db.Ping(); err != nil{ log.Fatal(err) } tx, err := db.Begin() checkErr(err) defer tx.Commit() stmt1, err := tx.Prepare(\"insert userinfo set username =?,department=?,created=?\") checkErr(err) result, err := stmt1.Exec(\"testTx\", \"PD\", \"2019-02-21\") checkErr(err) id, err := result.LastInsertId() checkErr(err) defer stmt1.Close() stmt2, err := tx.Prepare(\"select * from userinfo where uid =?\") checkErr(err) //查询数据 var uid int var username, department, created string err = stmt2.QueryRow(id).Scan(\u0026uid, \u0026username, \u0026department, \u0026created) checkErr(err) fmt.Printf(\"Uid is %v, username is %s, department is %s, created at %s\\n\", uid, username, department, created) defer stmt2.Close() } 上面的 defer 会安装 stmt2 -\u003e stmt1 -\u003e tx -\u003e db 的顺序来关闭连接 成功返回： userdeMBP:go-learning user$ go run test.go Uid is 6, username is testTx, department is PD, created at 2019-02-21 func (*Tx) Stmt func (tx *Tx) Stmt(stmt *Stmt) *Stmt Stmt 使用已存在的状态生成一个该事务特定的状态。 示例： updateMoney, err := db.Prepare(\"UPDATE balance SET money=money+? WHERE id=?\") ... tx, err := db.Begin() ... res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203) func (*Tx) Commit func (tx *Tx) Commit() error Commit 递交事务。 func (*Tx) Rollback func (tx *Tx) Rollback() error Rollback 放弃并回滚事务。 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:2:6","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"database/sql/driver https://www.cnblogs.com/wanghui-garcia/p/10405601.html import \"database/sql/driver\" driver 包定义了应被数据库驱动实现的接口，这些接口会被 sql 包使用。 绝大多数代码应使用 sql 包。 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:3:0","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"driver.Driver Driver是一个数据库驱动的接口，其定义了一个Open(name string)方法，该方法返回一个数据库的Conn接口： type Driver interface { Open(name string) (Conn, error) } Open 返回一个新的与数据库的连接，参数 name 的格式是驱动特定的。 Open 可能返回一个缓存的连接（之前关闭的连接），但这么做是不必要的； sql 包会维护闲置连接池以便有效的重用连接。 返回的连接同一时间只会被一个 go 程使用。所以返回的 Conn 只能用来进行一次 goroutine 操作，即不能把这个Conn 应用于 Go 的多个 goroutine 中，否则会出现错误，如： go goroutineA(Conn) //执行查询操作 go goroutineB(Conn) //执行插入操作 这样的代码会使 Go 不知某个操作到底是由哪个 goroutine 发起的从而导致数据混乱。 可能会发生： goroutineA 里面执行的查询操作的结果返回给 goroutineB，从而让 goroutineB 将此结果当成自己执行的插入数据 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:3:1","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["Golang"],"content":"driver.Conn Conn 是一个数据连接的接口定义。它只能应用在一个 goroutine 中 type Conn interface { Prepare(query string) (Stmt, error) Close() error Begin() (Tx, error) } Prepare 返回一个准备好的、绑定到该连接的状态，换句话说，返回与当前连接相关的 SQL 语句的准备状态，可以进行查询、删除等操作 Close 作废并停止任何现在准备好的状态和事务，将该连接标注为不再使用。 因为 sql 包维护着一个连接池，只有当闲置连接过剩时才会调用 Close 方法，驱动的实现中不需要添加自己的连接缓存池。 因为驱动实现了 database/sql 中建议的 conn pool，所以不用再去实现缓存 conn 之类的，这样会更容易引起问题 Begin 返回一个代表事务处理的 Tx，通过它你可以进行查询、更新等操作，或者对事务进行回滚、递交 ","date":"2021-12-31","objectID":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/:3:2","tags":["数据库"],"title":"Go sql 标准库","uri":"/Notes/posts/golang/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C/sql/"},{"categories":["专业课"],"content":"软件工程 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:0:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍏 软件工程学概述 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件危机 定义 在计算机软件的开发和维护过程中所遇到的一系列严重问题。 典型表现 开发成本和进度估计不准确 用户对完成的软件系统不满意 软件产品质量靠不住 软件不可维护 没有适当的文档资料 软件成本在计算机系统成本中占比上升 软件开发生产效率的提高追不上计算机普及的深入 产生原因 规模加大，复杂性提高 不同于硬件，缺乏可见性，维护即要修改原来的设计 技术手段和管理方法缺乏 用户和开发人员的鸿沟 不同于一般程序，规模庞大多人分工 。。。 软件开发工作量： 编写 10%-20% 测试 40%-50% 运行维护：长期，费用占 55%-70% 软件配置：程序、文档、数据 软件开发最主要的失败原因：对客户的需求没有全面理解 软件开发的修改成本：在中期剧增 消除途径 正确认识软件是程序、文档和数据的完整集合 充分认识软件开发是各类人员协同配合的工程项目 推广软件开发的成功技术，消除早期错误观念 开发和使用更好的软件工具 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件工程 概念 采用工程的概念、原理、技术、方法来开发和维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好技术方法结合起来，以经济地开发出高质量的软件并有效地维护它。 本质特性 注重大型程序的构造 中心课题是控制复杂性 软件经常变化 开发效率非常重要 和谐开发合作 软件必须有效地支持他的用户 在软件工程领域中通常由具有一种文化背景的人替具有另一种文化背景的人创造产品 基本原理 （好像不重要） 分阶段的生命周期 阶段评审 严格的产品控制 采用现代化程序设计技术 结果应能清楚地审查 开发小组人员少而精 承认不断改进软件工程的必要性 软件工程方法学（泛型） （好像不重要） 在软件生命周期全过程中使用的一整套技术方法 三要素：方法、工具、过程 方法 传统方法学 生命周期方法学或结构化泛型 采用结构化技术 面向行为或面向数据 面向对象方法学 以数据为主线，封装数据和对数据的操作 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件生命周期 定义时期：问题定义、可行性研究、需求分析 开发时期： 系统设计：总体设计、详细设计 系统实现：编码和单元测试、综合测试 维护时期： 软件维护：改正性维护、适应性维护、完善性维护、预防性维护 问题定义 要解决的问题是什么？ 确定客户的问题性质，工程目标和工程规模 可行性研究 问题是否有可行的解决办法？ 经济、技术、法律可行性 → 第二章 需求分析 目标系统必须做什么？ 确定系统必须具备的功能、性能，产生规格说明书 → 第三章 总体设计（概要设计） 概括地说，应该怎样实现目标系统？ 推选设计方案及其详细计划，确定程序模块间的关系 → 第五章 详细设计 ： 怎样具体地实现系统？ 详细设计每个模块，确定实现模块功能需要的算法和数据结构 → 第六章 编码和单元测试 仔细编写、测试每一个模块 → 第七章 综合测试 集成测试（装配后测试）、验收测试（用户参与测试） → 第七章 软件维护 使系统持久满足用户的需要 → 第八章 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件过程 生命周期模型（过程模型）：描述软件过程，规定了把生命周期划分成哪些阶段和各个阶段的执行顺序。 典型的过程模型 瀑布模型 文档驱动型，适合小规模软件 特点 阶段间具有顺序性和依赖性（各阶段依次进行） 推迟实现（尽可能推迟物理实现） 质量保证（每个阶段完成文档，并进行审核） 优点：强迫开发人员采用规范方法，文档驱动降低维护成本 缺点：前期没产品，无法应对改进的需求 快速原型模型 取得客户满意的原型再做规格说明书，无反馈环 快速原型可以取代规格说明阶段，但不是设计阶段 较好适应客户需求描述不完全或不确定的情况，减少返工 开发人员在建立原型中得到经验，减少犯错的可能 原型在得到用户确认后会被抛弃，但界面等可以得到保留 优点：快速、经济，适合招标 增量模型（渐增模型） 将软件拆分成构件逐步交付客户 完成需求分析规格说明和概要设计后，将软件看作增量构件的组合 从核心构件开始逐渐集成软件（但必须是可测试的） 优点 逐步增加功能 用户有较充裕的时间学习和适应新产品，减少新产品给客户带来的心理影响 分阶段交付产品 适应需求变化 缺点：需要一个开放结构，方便构件加入；开发人员需要协调软件的整体性和构件的独立性 螺旋模型 以瀑布和快速原型为基础，每个阶段前都增加风险分析 优点 适合内部开发的大规模软件 风险驱动，比快速原型更好的控制各类风险 缺点：开发人员需要有风险意识和经验 喷泉模型 喷泉模型体现了面向对象开发过程迭代和无缝连接的特性 将线性过程作为总目标 对开发活动进行迭代求精，不同阶段无明显边界 Rational 统一过程 RUP 最佳实践 6 个开发经验：迭代开发、管理需求、使用基于构件的体系结构、可视化建模、验证软件质量、控制软件变更 RUP 软件开发生命周期 核心工作流 6 个核心过程工作流程、3 个核心支持工作流程 4 个工作阶段： 初始阶段（建立业务模型，定义产品视图，确定项目范围） 精化阶段（确定体系结构，制定项目计划，确定资源需求） 构建阶段（开发构件和应用程序、集成并测试） 移交阶段（将开发的产品提交用户使用） 敏捷过程 客户密切合作、快速响应 个体和交互胜过过程和工具：构建开发团队，再配置过程和工具 可以工作的软件胜过面面俱到的文档：文档尽可能精简 客户合作胜过合同谈判：开发团队和客户密切合作 相应变化胜过遵循计划：计划具备可塑性 极限编程 敏捷过程的一种，适合需求模糊且经常改变的场合 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:1:4","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍎 可行性研究 第二章 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"可行性研究的任务 可行性研究：研究问题是否值得解决，而非解决问题 可行性研究的任务 技术可行性：有技术实现？ 经济可行性：经济效益超过开发成本？ 操作可行性：系统的操作方式在用户组织内是否可行？ 法律、社会效益可行性 根本性任务：对以后的行动方针提出建议。 可行性研究过程 复查系统规模和目标 研究目前正在使用的系统 导出新系统的高层逻辑模型（数据流图、数据字典） 进一步定义问题 导出和评价供选择的解法 推荐行动方针、草拟开发计划、书写文档提交审查…… ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"✔️ 数据流图 数据流图 OFD：逻辑模型，分层次的描绘方法便于读者从抽象到具体逐步深入了解系统。 描绘信息和数据从输入移动到输出过程中所经受的变化 只描绘数据在软件流动和被处理的逻辑过程 数据存储和数据流是数据的静态和动态表现 数据的符号表示（* + ⊕）不会考吧 数据库的写入写出流可以不写名字 变换流：一般的 事务流：有分类的 父子图平衡、数据守恒 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"数据字典 逻辑模型：数据流图+数据字典 定义数据的方法： 顺序：确定顺序的连接分量，如 D=A+B+C 选择：标所多个元素中取一个，如 G=[D|E|F] 重复：将分量重复若干次，如 H=3{G}5 表示 G 重复 3 到 5 次 可选：重复零到一次，如 I=(H) ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:2:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍏 需求分析 第三章 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"需求分析的任务 需求分析：系统必须做什么？定义时期最后一个阶段，产生软件需求规格说明书。 确定对系统的综合要求 功能需求：系统必须提供的服务 性能需求：系统必须满足的定时约束和容量约束 可靠性和可用性需求：系统的可靠性（重启，出错等） 出错处理需求：系统对环境错误的处理和响应（别的系统或者环境错了） 接口需求：系统与环境的通信格式 约束：设计和实现时需要遵守的限制（语言限制、硬件平台限制） 逆向需求：软件系统不该做什么 将来可能提出的要求：据分析未来很可能出现的需求 然后是…… 分析系统的数据要求 导出系统的逻辑模型 修正系统开发计划 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"与用户沟通获得需求的方法 与用户沟通获得需求的方法P59： 访谈：正式、非正式访谈；调查表、情景分析技术 面向数据流自顶向下求精：把数据流图中数据流和数据存储定义到元素级 建议的应用规格说明技术：面相团队，客户和开发人员密切合作（开需求分析会） 快速建立软件原型：快速建立用于演示目标系统功能的模型 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"分析建模与规格说明 （应该不考） 结构化分析SD：面向数据流自顶向下，逐步求精进行需求分析的方法。 实质上是一种创建模型的活动：实体-联系图、数据流图、状态图 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"验证软件需求 验证软件需求P70： 一致性：需求与需求不矛盾。采用形式化需求陈述语言书写 完整性：规格说明书包括所有用户需要的功能和性能。使用原型系统，和客户密切合作。 现实性：需求的软件硬件实现现实性。根据过往开发经验。必要时使用仿真技术 有效性：需求能有效解决用户面对的。使用原型系统，和客户密切合作 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:3:4","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍎 总体设计 第五章 总体设计（概要设计、初步设计）：概括的说，系统应当如何实现。划分出组成系统的物理元素，并设计软件的结构，设计数据库并制定测试计划。P92 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"设计过程 系统设计阶段 + 结构设计阶段 设想供选择的方案：从数据流图出发，抛弃技术不可行的方法 选择合理的方案：低、中、高成本三套方案，并提供系统流程图、物理元素清单、成本效益分析、实现系统的进度计划 推荐最佳方案：综合利弊推荐最佳方案，制定详细计划 功能分解：将复杂的功能分解，使每个功能对程序员明显易懂 设计软件结构：把模块组织成良好的层次系统，顶层调用下层实现 设计数据库：详见数据库课程 制定测试计划：尽早考虑测试问题，详见第七章 书写文档：系统说明、用户手册、测试计划、详细的实现计划、数据库设计结果 审查和复查：严格审查，客户复审 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"设计原理 模块化：把程序划分成独立命名且可独立访问的模块，每个模块完成一个子功能。把模块集成在一起又能满足客户需求。模块化程度适中开发成本最低（接口成本） 抽象：用层次的方式构造和分析 逐步求精：将精力放在当前开发阶段的重点上，稍后处理其他必要细节 信息隐藏和局部化：模块内部信息独立于其他模块而不可被访问；将关系密切的软件元素物理上彼此靠近 模块独立：高内聚，低耦合 耦合：（好、低）数据\u003c控制=特征\u003c公共环境\u003c内容（不好、高） 数据耦合：模块通过参数交换数据 控制耦合：模块通过参数交换控制信息（可分解模块转化为数据耦合） 特征耦合：模块接收的参数数据结构中有冗余数据信息（访问权限漏洞） 公共环境耦合：多个模块共用数据环境（全局变量） 内容耦合：访问模块内部数据、不正常访问、代码重叠、多入口 内聚：（好、高）功能\u003e顺序\u003e通信\u003e过程\u003e时间\u003e逻辑\u003e偶然（不好、低） 偶然内聚：一组没有完整功能的语句巧合地被多次使用 逻辑内聚：不同功能的语句混在一起，共用部分代码 时间内聚：语句在同一段时间内执行 过程内聚：模块内元素相关，且以特定顺序执行 通信内聚：模块使用同一个输入产生同一个输出 顺序内聚：模块处理元素和同一功能密切相关，且顺序执行 功能内聚：模块所有元素属于同一整体，完成单一功能 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"启发规则 改进软件结构提高模块独立性：高内聚低耦合 模块规模适中：模块复杂和借口复杂折衷 深度、宽度、扇出和扇入适当： 深度：软件结构中控制的层数 宽度：一层中模块总数的最大值 扇出：一个模块直接调用的模块数 扇入：一个模块被上级调用的模块数 模块的作用域应该在控制域之内： 控制域：自身和直接或间接从属模块的集合 力争降低模块接口的复杂度：参数和返回值应当简单且易理解 设计单入口单出口模块：不要随意 return 模块功能要可预测：相同输入对应相同输出 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"面向数据流的设计方法 变换流：数据从外部进入软件系统，经处理后离开系统进入外部 事务流：数据到达一个处理后根据输入类型从若干个动作中选取一个执行 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:4:4","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍏 详细设计 第六章 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:5:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"结构程序设计 详细设计：确定应该怎么具体实现所要求的系统。不仅要保证逻辑上正确实现每个模块的功能，更要保证处理过程尽可能简明易懂。 结构程序设计：（五要素）仅通过顺序、选择和循环控制结构连接，且每个代码块只有一个入口，一个出口。 经典结构程序设计：顺序、IF-ELSE、DO-WHILE 扩展结构程序设计：CASE、DO-UNTIL 修正结构程序设计：LEAVE、BREAK ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:5:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"✔️ 过程设计工具 过程设计工具 P124-129：大题 程序流程图 不是逐步求精的好工具，诱导程序员过早考虑控制流程 允许随意转移数据，不受约束 不易表示数据结构 盒图（NS 图） 功能域明确 不能任意转移控制 容易确定数据的作用域 容易表现嵌套关系，体现层次结构 PAD 图 设计产生的必然是结构化程序 程序结构清晰，竖线总条数即程序层次数 表现程序逻辑，易读易懂易记 易于转化为高级语言 可以表示程序逻辑，也可以表示数据结构 支持自顶向下逐步求精的方法 判定表、判定树 程序流程图 基本符号 控制结构 扩展符号 例 盒图 基本符号 示例 特点 不允许随意转移控制 局部及全程数据的作用域易见 易表现嵌套关系以及模块的层次结构 PAD 图 问题分析图 (Problem Analysis Diagram, PAD) 日立公司，1973 示例 特点 支持逐步求精的设计思想 容易将 PAD 自动转换为高级语言源程序 判定表，判定树 表示复杂条件组合与动作之间的对应关系 示例：航空行李托运费计算 按规定：重量不超过（包括）30 公斤的行李可免费托运。重量超过 30 公斤时，对超运部分，头等舱国内乘客收 4 元/公斤，其它舱位国内乘客收 6 元/公斤；外国乘客收费为国内乘客的 2 倍。 判定表： 判定树： ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:5:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"程序复杂度的定量度量 环形复杂度：度量程序复杂度的一种方法。 线性无关的区域数（即离散中平面图面数） 边数 - 节点数 +2 判定节点数 +1 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:5:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍎 实现 第七章 实现：编码 + 测试。软件测试工作量占开发的 40% 以上，安全软件更多。 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"编码 选择程序设计语言 除了选择适宜的程序设计语言外，也要考虑以下因素 系统与用户的要求：客户限制 可以使用的编译程序：目标环境限制编译程序 可以得到的软件工具 工程规模：规模过大可以自己设计语言（书上观点） 程序员的知识：技术栈 软件可移植性要求 软件的应用领域：科学计算、Web 开发等 编码风格 程序内部文档：变量命名、模块注解、代码注解、程序清单的布局 数据说明：数据结构和用途的说明 语句构造：避免写一行、避免非常复杂的条件测试、避免大量嵌套等 输入输出：对输入做合法性检验，设计良好的输出报表等 效率：程序运行时间、存储器效率、输入输出效率 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件测试基础 软件测试的目标 测试是为了发现程序中的错误 好的测试方案极可能发现迄今为止未发现的错误 成功的测试是发现了迄今为止未发现的错误的测试 软件测试：为了发现程序中的错误而执行程序的过程 软件测试的目的：在软件投入生产性运行之前，尽可能多地发现软件中的错误 软件测试准则 （可能蛮重要的） 测试追溯客户需求 远在测试开始前制定测试计划（需求分析阶段） Pareto 原理：80% 的错误来自 20% 的模块 从小规模测试开始逐步到大规模测试 穷举测试是不可能的 由第三方从事测试工作可以最大可能发现错误 测试方法 黑盒测试 已经知道产品应该具有的功能，通过测试验证每个功能是否正常使用 等价划分 边界值分析 白盒测试 知道产品内部工作过程，通过测试检验内部动作是否按照规格说明书正常进行 语句覆盖、判定覆盖、条件覆盖、判定/条件覆盖、条件组合覆盖 测试步骤 模块测试（单元测试）：验证每个模块作为一个单元能正确运行 子系统测试：将模块组成子系统测试，着重测试模块的接口 系统测试：子系统组成系统测试需求和功能，寻找需求说明的错误和软件总体设计错误 验收测试（确认测试）：将软件实体作为单一实体测试，在用户积极参与下进行 平行运行：同时运行新系统和旧系统比较差异 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"单元测试 （P153） 检测软件设计的最小单元—模块 测试重点 模块接口、局部数据结构、重要执行通路、出错处理通路、边界条件 代码审查 单元测试由组长、设计者、编写者、测试者建立审查小组测试 计算机测试 编写驱动程序测试模块，代替模块接口进行测试 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"集成测试 子系统测试 + 系统测试 将模块组装成程序的两种方法：非渐增式测试方法、渐增式测试方法 非渐增式测试 分别测试每个模块，按设计一次性集成 对模块做单元测试 将所有模块组装在一起 将组装后的程序作为整体进行测试 缺点：无错误隔离手段，主要设计错误发现迟 渐增式测试 逐步把下一被测模块同已测好的那些模块进行集成 将单元测试和集成测试组合起来，把下一个要测试的模块同已经测试好的那些模块结合起来进行测试 自顶向下集成： 步骤 用存根程序代替直属控制模块 根据树的 dfs 序或 bfs 序进行集成 逐步加入新的模块，可能需要进行回归测试 优点 错误隔离； 不需要驱动程序； 早期就可以验证程序功能； 较早发现接口错误 缺点 需要存根程序（桩模块） 低层错误可能很晚才能发现 回归测试：加入新模块后将原有的测试再做一遍 自底向上集成： 步骤 根据树的逆 bfs 序进行集成 将底层模块组成簇，编写驱动程序测试 去掉驱动程序，将上层模块加入进来，簇合并 优点 错误隔离； 可复用模块得到充分测试； 不需要存根程序 缺点 需要驱动程序； 主要设计错误发现迟； 验证系统功能迟 三明治式集成（混合式集成） 步骤 确立一个模块层为界限 上层使用自顶向下策略 下层使用自底向上策略 优点 集大成，减少了驱动模块和存根程序的开发 错误隔离 能较早的发现设计缺陷 操作模块得到成分测试，可以信任的复用 缺点：中间层的测试非常晚 三者比较 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:4","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"确认测试 定义（也叫验收测试）：验证软件的有效性，即符合用户的功能和性能需求。用户积极参与，通常使用黑盒测试方法。 软件配置复查：软件配置齐全符合要求；文档和程序一致；手册正确性完整性 Alpha 测试：用户在开发者的场所进行，在开发者指导下进行测试 Beta 测试：最终用户在客户场所进行，开发者不在场，但记录测试过程中的问题 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:5","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"调试 调试：在测试发生错误后排除错误的过程（艰巨的脑力劳动） 蛮干法：输出日志，并查找问题 回溯法：人工沿控制流回溯源码 原因排除法：对分查找法、归纳法、演绎法 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:6:6","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍏 维护 第八章 自学内容 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:7:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件维护的定义 软件维护：在软件已经交付使用后，为了改正错误或满足新的需要而修改软件的过程。 改正性维护：诊断和改正错误的过程，17%～21% 适应性维护：为了和变化的环境适当配合而进行的修改软件活动，18%～25% 完善性维护：增加用户提出的新功能或修改已有功能，50%～66% 预防性维护：为未来的改进奠定良好的基础，4% 左右 完善»适应\u003e=改正\u003e其他 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:7:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件维护的特点 结构化维护与非结构化维护的差别巨大 结构化维护：完整的软件配置（文档、测试等）减少了精力浪费并提高了维护的总体质量 维护代价高昂：甚至达到预算的 70-80% 维护的问题多 理解他人代码的困难 文档资料不足 开发人员可能已经调离 设计时未考虑将来的修改 软件维护不是吸引人的工作 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:7:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件的可维护性 决定软件可维护性的因素： 可理解性：功能、接口、内部处理逻辑；模块化、文档、语言 可测试性：可用的测试、调试工具 可修改性：耦合、内聚、信息隐藏、局部化、控制域与作用域的关系 可移植性：硬件环境移植的难题程度 可重用性：可重用构件越多，测试的可靠性越高，维护的精力越少 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:7:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"🍎 面向对象方法学 第九至十一章 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"面向对象方法学概述 OO = objects + classes + inheritances + communication with messages 面向对象 = 对象 + 类 + 继承 + 消息通信 对象：客观世界由对象组成，复杂的对象由简单的对象组成 类：将对象划分成对象类，定义属性和方法 继承：子类具有和基类相同的属性或方法 消息传递：对象间通过传递消息相互联系 面向对象方法学的优点 P205： 与人类思维习惯一致 稳定性好：以对象为中心构造系统 可重用性好：数据和操作是平等的；对象类可重复使用 较易开发大型软件产品 可维护性好：易改易维护易调试易理解 在 UML 术语中 “类” 的实际含义是 “一个类及属于该类的对象”。 对象模型：类图 功能模型：用例图 动态模型：顺序图、状态图 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"面向对象建模 三种模型 功能模型：系统功能（指明系统应该 “做什么”）。数据流图或用例图 对象模型：静态的、结构化的系统的数据结构：类图、对象图（最重要、最基本、最核心） 动态模型：系统的控制结构：活动图、状态图、顺序图等 ✔️ 用例图 描述外部行为者 (actor) 所理解的系统功能 系统、行为者、用例及用例之间的关系 定义 系统 提供用例的黑盒 边界用于划定系统的功能范围 行为者（Actor） 与系统交互的人或其它系统 用例（Use Case） 行为者感受到的一个完整功能 实现一个具体的用户目标 向行为者提供可识别的值 步骤 确定系统边界 确定行为者：角色/参与者 确定用例 简述行为者和用例 用例描述 确定行为者 行为者总在系统外，不是系统的一部分 可能的行为者 谁使用系统 谁维护系统 谁启动或关闭系统 谁从系统获取信息 谁为系统提供信息 是否有事情自动在预计时间发生 确定用例 行为者希望系统提供什么功能 行为者 CRUD 什么信息 系统给行为者通知什么信息 系统需要从行为者那得到什么信息 系统的启动、关闭、维护等 简述行为者和用例 用例描述 完成用例功能需要的步骤 基本路径 可选路径 用例描述模板 基本路径 基本路径 (快乐场景) ：运转正常时，使用用例的步骤 可选路径 用例描述模板 用例模型结构 包含（Include） 扩展（Extend） 继承（Inheritance） 包含 多个用例可以重用的行为段 包含是无条件的 扩展 有条件地扩展已有用例的行为 在不改变原始用例的情况下增加用例行为 继承 种属关系 可以于行为者和用例 偏重修改的意味 ✔️ 类图 类间关系 关联（Association） 聚集（Aggregation） 泛化（Generalization） 示例 ✔️ 顺序图 按第一次动作的时间顺序安排协作对象 为每一个消息添加信息链和活动条 对每一个活动重复第 2 步操作 ✔️ 状态图 描绘对象的状态及引起状态迁移的事件，来表示对象的行为 状态：对象满足某些条件、执行某些活动或等待某些事件。 初态、终态和中间状态 活动：对象达到某种状态时所做的处理 事件：在某个特定时刻发生的事情，引起状态迁移 迁移：两个状态间的一种关系。当对象处于一个状态时，在特定事件发生并且特定条件满足时，执行一定动作并进入第二个状态 符号 示例 画状态图 例 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"面向对象设计 面向对象设计的任务 系统设计：系统策略、目标系统的高层结构 对象设计：类、关联、接口 面向对象设计准则 模块化 抽象 信息隐藏 弱耦合（跟之前不一样） 交互耦合：对象通过消息连接来实现耦合（应尽可能松散、参数少而简单） 继承耦合：基类和派生类的耦合（应保持紧密） 强内聚 服务内聚：一个服务完成且仅完成一个功能 类内聚：一个类有且仅有一个用途 一般 - 特殊（层次）内聚：符合多数人的观念 可重用 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"启发规则 提高面向对象设计质量的启发规则 P261： 设计结果清晰易懂 一般 - 特殊结构深度适当：类层数 7 ± 2 使用简单的协议：参数少 使用简单的服务：避免一个方法太复杂 把设计变动减至最小 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:4","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软件重用 软件重用层次 知识重用，如软件工程知识的重用 方法和标准重用，如开发方法或国标 软件成分重用 代码重用：复制粘贴、包含、继承 设计结果重用：设计模型的重用 分析结果重用：需求模型的重用 类构件的重用方式 实例重用：多个对象用同一个实例；一个复杂的类由多个简单的类创建 继承重用：利用继承性对类构件进行剪裁 多态重用：利用多态性使对外接口更具一般性 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:5","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"测试策略 （应该不用） 面向对象软件不存在层次的控制结构，传统的自顶向下和自底向上集成策略没有意义。 集成测试方法： 基于线程的测试：把相应系统的一个输入或事件需要的类集成分别进行测试和回归测试 基于使用的测试：把独立类测试完成后再测试依赖类直至测试完成 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:8:6","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"软工设计图 以下总结仅供参考。 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:0","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"数据流图 ☆ https://www.bilibili.com/video/BV1Jt411d7nR?p=3 父子图平衡、子图内平衡 顶层图：整个软件系统看作一个大的加工，确定软件的数据源点和终点、源点和终点与软件系统之间的输入/输出数据流 零层图、一层图 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:1","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"NS 图（盒图） ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:2","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"PAD 图 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:3","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"判定表 判定表化简 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:4","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"判定树 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:5","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"用例图 ☆ 用例：椭圆，描述从行为者看到的系统全部完整的功能（存款而非插卡输密码等） 行为者希望系统提供什么功能 行为者必须的增删改查的功能 系统给行为者的通知 系统从行为者得到的信息 系统边界：黑色方框，用于划定系统的功能范围 行为者：小人，位于系统外和系统进行交互的人和系统； 用例：功能 包含、使用：A 使用 B 的功能，描述一种必然性 销户/下单、结算/搜索商品 每次都必须做，先做什么才能做什么 扩展：A 扩展出了 B 的功能，B 用到了 A 的功能，描述一种可能性 注册/短信提醒、登录/停机提醒 额外可能做的功能，通常是扩展（登录发现没注册）。 新功能用老功能，通常是扩展（停机提醒用短信提醒） 只能额外做操作，不能修改 继承、泛化：A 继承基类 B 空心三角箭头：管理员 → 用户 修改了原有的某些功能。做了不一样的东西 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:6","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"白盒测试（结构测试、逻辑驱动测试） 语句覆盖（点覆盖）：测试数据需要覆盖所有语句 判定覆盖（边覆盖）：测试数据满足所有的判定结果（即每个判定的TF结果都要走过） 条件覆盖：将判定中的判定子句的所有TF都走过（只看条件，可能大判定TF没都走） 判定/条件覆盖：满足判定+条件覆盖 多重条件覆盖（条件组合）：将所有判定的子句TF的组合都走过，但不同判定之间无关联 路径覆盖：将每条可能的路径至少执行一次，如有循环至少进入一次 条件组合覆盖 覆盖 判定/条件覆盖 判定/条件覆盖 覆盖 判定覆盖和组合覆盖 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:7","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"黑盒测试（功能测试、数据驱动测试） 等价类：有效等价类、无效等价类 设计测试用例： 有效的：尽可能多的覆盖未覆盖的有效等价类，直至覆盖全部 无效的：只覆盖一个，直至覆盖全部 设计等价类表： 设计有效类测试用例： 设计无效类测试用例： 边界值分析 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:8","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"类图 ☆ 类图属于对象模型，描述类及类与类之间的静态关系 public + private – protected # 重数：0..1，0..，1..，1..15，3 一元关联：学生管理学生 导航：箭头，表示使用到对象 关联类： 限定关联： 聚集关系：菱形表示 组合：（公司和部门）强依赖删除父类，则所有子类失去意义 聚合：（部门和员工）弱依赖，由什么组成 组合（强） 聚合（弱） 泛化： 依赖： ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:9","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"顺序图（事件跟踪图） 顺序图描述对象之间动态的交互关系 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:10","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"状态图 ☆ 借书 (n)[n\u003c10]/n=n+1 组合状态 顺序图改状态图： 射入线：状态图中的事件。 射出线：状态图中的状态的行为。 两个事件之间的间隔就是一个状态。 二进制转换，输入输出题目描述-简单二进制这回你的任务很简单，就是简单的数数，不过是在二进制下计算哦，计算一个十进制数的二进制包含多少个1. 如3的二进制是11，则包含2个1，2的二进制是10，则包含1个1.解答要求时间限制：1000ms, 内存限制：100MB输入输入包含多组测试， 每组测试输入一个整数n(0≤ n \u003c65535)，输入到文件末尾结束。输出输出n的二进制含有1的个数，每组测试占一行。样例输入样例 1 复制310输出样例 122 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/:9:11","tags":["软件工程"],"title":"软件工程","uri":"/Notes/posts/courses/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"categories":["专业课"],"content":"实用计算机英语 ","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:0:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["专业课"],"content":"Chapter1 Key Term Definition application software End user software cloud computing Uses the Internet and the Web to shift many computer activities from a user’s computer to computers on the Internet. communication device Computer equipment that allows a computer to connect to other computer systems to share data and information. 紧凑型光盘compact disc (CD) A type of optical disc that has the least storage capacity. computer competency Having computer related skills connectivity Allows computers to connect and share information with other computers. data Unprocessed facts. database file Typically created by database management programs to contain highly structured and organized data. desktop computer A type of microcomputer that is small enough to fit on top of or alongside a desk yet is too big to carry around. device driver Specialized programs designed to allow particular input or output devices to communicate with the rest of the computer system. digital versatile disc (DVD) A type of optical device that gives great capacity and can be used to store many different types of data. (See also digital video disc) digital video disc (DVD) A type of optical device that gives great capacity and can be used to store many different types of data. (See also digital versatile disc) document file Data files created by word processors to save documents such as memos, term papers, and letters. end user The most important part of an information system. (See also people) 通用应用程序general purpose application Application software that is used in nearly all careers. flash memory card A solid-state storage device widely used in notebook computers. Flash memory also is used in a variety of specialized input devices to capture and transfer data to desktop computers. handheld computer The smallest microcomputer that is designed to fit into the palm of one hand. hard disk A secondary storage device that uses magnetized dust to store the information. hardware The equipment that processes the data to create information. information Processed facts. information system Composed of five parts: people, procedures, software, hardware, and data. information technology (IT) Relating to computer software and hardware, and data. input device Translate data and programs that humans can understand into a form the computer can process. Internet The largest computer network in the world. keyboard A type of input device that allows the user to input character data into the computer. mainframe computer A type of computer that is capable of great processing speeds and data storage. memory Holds data and program instructions for processing the data. (See also primary storage, random access memory) microcomputer The least powerful type of computer, yet the most widely used and fastest-growing, type of computer. microprocessor Controls and manipulates data to produce information. midrange computer Also referred to as servers**,** most widely used to support end users for specific needs such as retrieving data from a database or supplying access to application software. 调制解调器modem Modifies telephone communications into a form that can be processed by a computer. monitor A common output device that allows the user to see what the computer is doing. mouse A type of input device that allows the user to point and click on items for easier operation. network A communications system connecting two or more computers. notebook computer A type of microcomputer that is portable, lightweight, and fits into most briefcases. operating system Program that coordinates computer resources, provides an interface between users and the computer, and runs applications. optical disc A secondary storage device that uses laser technology and has the greatest capacity. output device Translates the processed information from the computer into a form that humans can understand. people The most important part of an information system. (See also end users) 个人数字助理personal digital assistant (PDA) The most w","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:1:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["专业课"],"content":"Chapter2 Key Term Definition address The location or name of a Web site. Advanced Research Project Agency Network(ARPANET) Launched in 1969 when the United States funded a project that developed a national computer network. AJAX An advanced use of JavaScript that can be found on many interactive sites. applets Special programs on Web sites that provide animation, interactivity, and display graphics. 附件attachment Files, such as documents and worksheets that can be sent along with an e-mail message. 拍卖行网站auction house site Sell a wide range of merchandise directly to bidders. BitTorrent A type of file transfer that distributes files across many different computers for more efficient downloads. blog Web logs that contain time stamped postings. browser Software programs that provide a user interface to Web resources. business-to-business (B2B) Involves the sale of a product or service from one business to another over the Internet business-to-consumer (B2C) The sale of a product or service to the general public or end users over the Internet 电缆调制解调器cable Modems that provide Internet high-speed access using unused bandwidth on a cable television network. 层叠样式表Cascading Style Sheets (CSS) Files inserted into an HTML document that control the appearance of Web pages including layout, colors, and fonts. Center for European Nuclear Research (CERN) Introduced the World Wide Web in 1992 in Switzerland. circles A service offered through Google+, for grouping individuals according to interests or other criteria client based e-mail account Special program known as an e-mail client that needs to be installed and running in order to enable a computer to communicate with the e-mail service provider. cloud computing Uses the Internet and the Web to shift many computer activities from a user’s computer to computers on the Internet. consumer-to-consumer (C2C) Involves individuals selling to individuals over the Internet. digital cash Internet’s equivalent to traditional cash. Buyers purchase digital cash from a third party by transferring funds from their banks. digital wallet resides on a user’s smartphone and contains an individual’s mailing address, credit card as well as other information typically required to make an online purchase. domain name It is part of an URL that signifies the name of a Web server where the resource is located. downloading Copying a file from a server to a local computer. 数字用户线路DSL Digital Subscriber Line, provides a digital connection over unused frequencies of standard telephone lines. e-commerce Buying and selling of goods over the Internet. (See also electronic commerce) e-learning Being able to take classes on almost any subject from educational institutions that offer courses online. electronic commerce Buying and selling of goods over the Internet. (See also e-commerce) electronic mail Electronic mail, the transmissions of electronic messages over the Internet. (See also e-mail) e-mail Electronic mail, the transmissions of electronic messages over the Internet. (See also electronic mail) e-mail client Special program required to communicate with the e-mail service provider in client-based e-mail accounts. Facebook Social networking site that provides an array of features and applications including instant messaging, photo and video sharing, games, and more. Facebook groups Share information that is typically organized around topics, events, ideas. Facebook pages Created by businesses to promote products and services. Facebook profiles Created by individuals who may include photos, lists of personal interest, contact information, and other personal information. 文件传输协议file transfer protocol (FTP) An Internet standard for transferring files. filter Blocks access to selected Web sites. friend A person that you specify in a list to use instant messaging. Google Plus A combination of some of Google Inc.’s previously existing services with some new services, many of which are similar to Facebook’s Google+ A combinati","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:2:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["专业课"],"content":"Chapter3 analytical graph A visual representation of data in a worksheet. (See also chart) animation Special effects that add action to text and graphics on a slide. app Also known as application software. End-user software and is used to accomplish a variety of tasks. (See also application software) app store Typically Web sites providing access to specific apps for a fee or free. application software End-user software and is used to accomplish a variety of tasks. (See also app) 项目符号列表 bulleted list A sequence of topics that is preceded by a graphical element. bitmap image Use thousands of dots or pixels to represent images. (See also raster image) blog Personal web site that can be created by individuals. button Used in toolbars to provide shortcuts for quick access to commonly used commands. 单元格 cell A box in a spreadsheet application that is the intersection of ac row and a column. character effect The appearance, or style, of a font, such as bold, italics, or underline. chart A visual representation of data in a worksheet. (See also analytical graph) 剪贴画 clip art Graphic illustrations representing a wide range of topics. cloud suite Online office suites stored at a server on the Internet and are available anywhere you can access the Internet. column A vertical arrangement of figures in a spreadsheet application. computer trainer Teaches new users how to use the latest software and hardware. content template Feature of presentation software and include suggested content for each slide. contextual tab Feature of Microsoft Office that appears automatically when needed. database A collection of related data. database management system (DBMS) A program that sets up, or structures, a database, and provides tools to enter, edit, and retrieve data from the database. (See also database manager) database manager A program that sets up, or structures, a database, and provides tools to enter, edit, and retrieve data from the database. (See also database management system) design template An element in a presentation graphics application that provides professionally selected combinations of color schemes, slide layouts, and special effects. desktop publishing program Allow you to mix text and graphics to create publications of professional quality. (See also page layout program) 对话框 dialog box A pop-up box that provides additional information and requests user input. document Files that are created by a word processing program. drawing program Used to create and to edit vector images. (See also illustration program) Editing The act of modifying a document. Field A column in a database table that represents an element of data to be gathered. find and replace The act of quickly locating text in a document and replacing it with a blank or modified text. filter A tool to display only those records meeting specified conditions. Flash A type of Web animation that is usually full-screen, highly dynamic, and interactive. Font The appearance of characters in a document. font size Refers to the height and width of a font. form An item that displays on a computer monitor and typically reflects the contents for one record in a table. format The appearance, or readability, of a document. formula A mathematical equation, or instruction, to calculate numbers, used in a spreadsheet application. function A prewritten formula provided by a spreadsheet application that performs calculations. gallery Feature of Microsoft Office that simplifies the process of making selections from a list of alternatives by replacing dialog boxes with visual presentations of results. general purpose application Software that is widely used in nearly every discipline and occupation. grammar checker A pre-programmed function within a word processing application that checks for problems with capitalization, punctuation, and sentence structure. 图形站点地图 graphical site map Representation of the overall Web site design 图形用户界面 graphical user interface (GUI) Display graphical eleme","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:3:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["专业课"],"content":"Chapter4 Key Term Definition Add a Device Wizard A Windows feature provides step-by-step guidance for selecting the appropriate driver and installing that driver. Android Mobile phone operating system developed by Andriod for the Andriod phone. antivirus program A system utility that guards a computer system against viruses or other damaging programs that can invade it. background Program or programs that are not active in your window on the desktop but are available to switch to from your foreground program Backup and Restore A utility program included with the many versions of Windows that makes a copy of all files or selected files that have been saved onto a disk. backup program A system utility that makes copies of files to be used in case the originals are lost or damaged. Blackberry OS Also know as RIM OS, a mobile phone operating system designed as the platform for the BlackBerry handheld computer Boot Camp Feature of Leopard, the new version of Mac OS, which allows appropriately equipped Apple computers to run both Mac OS and Windows XP. booting The process of starting or restarting a computer Chrome OS Linus OS designed for netbook computers and focuses on Internet connectivity through cloud computing cold boot The process of starting a computer after it has been turned off. computer support specialist A person who provides technical support to customers and other users. Dashboard Widgets A feature of MAC OS. They are a collection of specialized programs that will constantly update and display information. desktop A place an operating system provides users in order to access computer resources. desktop operating system An operating system that controls a desktop or laptop computer. (See also stand-alone operating system) device driver Specialized programs that allow particular input or output devices to communicate with the rest of the computer system. (See also driver) diagnostic program A system utility that recognizes and corrects problems, ideally before they become serious. (See also troubleshooting program) dialog box A feature of a GUI operating system which provides information or requests input. Disk Cleanup A trouble-shooting utility included in many versions of Windows that identifies and eliminates nonessential files. 磁盘碎片整理器 Disk Defragmenter A Windows utility program that locates and eliminates unnecessary fragments and rearranges files and unused disk space to optimize operations. driver Specialized programs that allow particular input or output devices to communicate with the rest of the computer system. (See also device driver) embedded operating system A device that has the operating system programs permanently stored on ROM file Where data and programs are stored file compression program A system utility that reduces the size of files so they require less storage space and can be sent more efficiently over the Internet. folder A container in a file management system where related files are stored. foreground Program in which you are currently running in the active window on your desktop. fragmented When a file cannot be stored to disk as one contiguous block, it is broken up into small parts and stored wherever space is available. 手势控制 Gesture control Use of fingers to run programs and to control the content of the display screen. Graphical user interface (GUI) A user interface that uses graphical elements such as icons and windows. guest operating system The operating system for a virtual machine. Help Provides online assistance for operating system functions and procedures. host operating system The operating system of a physical machine. Icon A graphic representation for a program or function. iOS Developed by Apple (formerly known as iPhone OS) to support iPhone, iPod Touch, and iPad. One of the fastest-growing mobile OS. iPhone OS Type of mobile phone operating system used as the platform for Apple’s iPhone, iPod Touch and iPad. Launchpad Displays and provides direct access to all apps install","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:4:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["专业课"],"content":"Chapter5 Key Term Definition 交流适配器 AC adapter A power adapter that converts AC to DC, provides power to drive the system unit components, and can recharge batteries. 一体机 All-in-one A desktop computer that has the monitor and system unit housed together in the same case (e.g., Apple’s iMac). 模拟信号 analog Continuous, signals that vary to represent different tones, pitches, and volume. 算术逻辑单元 arithmetic-logic unit (ALU) The ALU performs two types of operations: arithmetic and logical. arithmetic operation Fundamental math operations: addition, subtraction, multiplication, division. ASCII Binary coding scheme widely used on all computers, including microcomputers. Eight bits form each byte, and each byte represents one character. binary system A numbering system that consists of only two digits, 0 and 1. bit Data and instructions can be represented electronically with a two-state or binary system of numbers (0 and 1). Each 0 or 1 is called a bit - Short for – Binary Digit**.** bus Connects the parts of the CPU to each other. (See also bus line) bus line Connects the parts of the CPU to each other. (See also bus) bus width The number of bits that can travel simultaneously down a bus. byte Eight bits. Each byte typically represents one character. 电缆 cable Connects external devices to the system unit via ports. cache memory A temporary high-speed holding area between the memory and the CPU - used to improve processing time. carrier package Micro chips on mounted on them. They are either plugged directly into sockets on the system board or onto cards that are then plugged into slots on the system board. central processing unit (CPU) The “brains” of a computer and is contained on a single chip. (See also microprocessor, processor) character encoding standards These standards assign a unique sequence of bits to each character. chip Consists of tiny circuit boards etched onto squares of sand-like material called silicon. (See also integrated circuit, silicon chip, semiconductor) clock speed The speed of processing or power of a computer system. computer technician People who repair and install computer components and systems. control unit The part of a processor that tells the rest of the computer system how to carry out a program’s instructions, and directs the movement of electronic signals between memory and the CPU. coprocessor Specialty chip designed to improve specific computing operations. desktop The screen that is displayed on the monitor when the computer starts up. All items and icons on the screen are considered to be on your desktop and are used to interact with the computer. digital Signals that are only in two states – on or off – are used to represent voice and data. DIMM Dual in-line memory module – an expansion module inserted into the system board for adding additional RAM. DVI (Digital Video Interface) port Provides connections to analog and digital monitors. EBCDIC Extended Binary Coded Decimal Interchange Code. An 8-bit binary coding scheme developed by IBM and used primarily in large computers. external Serial Advanced Technology Attachment) (eSATA) A port that provides very high-speed connections for external hard disk drives, optical disks, and other large secondary storage devices. Ethernet port A high-speed networking port that has become a standard for many of today’s computers. expansion bus Connects the CPU to other components on the system board, including expansion slots. expansion card Optional devices users can insert into their computers. expansion slot Slots provided on a microcomputer where users can insert optional devices. ExpressCard ExpressCard slots accept credit card–sized expansion cards in notebook computers. FireWire bus A bus dedicated to the acceleration of graphics performance. FireWire port Provides connections to specialized FireWire devices such as camcorders. flash memory Chips that can retain data even if power is disrupted. game port A legacy port used to connect video game controller","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:5:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["专业课"],"content":"Chapter6 Key Term Definition active display area Diagonal length of a monitor’s viewing area. Also know as size. active-matrix monitor A type of flat-panel monitor where each pixel is independently activated. (See also thin film transistor (TFT) monitor) active-matrix organic light-emitting diode (AMOLED) A monitor technology that has the benefits of lower power consumption and longer battery life, as well as possibilities for much thinner displays. artificial intelligence (AI) A field of computer science that attempts to develop computer systems that can mimic or simulate human thought processes and actions. aspect ratio This is a ratio determined by the width of a monitor divided by its height. bar code reader Contains photoelectric cells that scan or read bar codes. (See also bar code scanner) bar code scanner Contains photoelectric cells that scan or read bar codes. (See also bar code reader) card reader A device that interprets the encoded information contained on credit, debit, access, and identification cards. carpal tunnel syndrome A repetitive strain injury consisting of damage to the nerves and tendons in the hands. cathode-ray tube (CRT) monitor The most common type of monitor that are typically placed directly on the system unit or on the desktop. clarity The quality and sharpness of the displayed images. cloud printer Printers connected to the Internet that provide printing services to others on the Internet. combination key A key, that when held down in combination with another key, performs an action. contrast ratio Indicates a monitor’s ability to display colors. It compares the light intensity of the brightest white to the darkest black. cordless mouse A battery-powered device that typically uses radio waves or infrared light waves to communicate with the system unit. (See also wireless mouse) digital camera Images are recorded digitally on a disk or in the camera’s memory rather than on film. digital media player A specialized device for storing, transferring, and playing audio files. See also portable media player) dance pad An input device for dance games where signals are sent via a pressure-sensitive mat. digital video camera Record motion digitally on a disk or in the camera’s memory. digital whiteboard Specialized devices with a large display connected to a computer or projector (see also interactive whiteboard) display screen A computer device that presents visual images of text and graphics. (See also monitor) document scanner Scanner that quickly scans multipage documents by automatically feeding one page at a time through a scanning surface. dot-matrix printer A type of printer that forms characters and images using a series of small pins on a print head. dot pitch A function of a monitor that is the distance between each pixel. (See also pixel pitch) dots-per-inch (dpi) The measurement of printer resolution, the more dots-per-inch the better the quality of the image printed. dual-scan monitor Type of flat-panel monitor that create images by scanning the entire screen. (See also passive-matrix monitor) duplex printing Printing feature that allows automatic printing on both sides of a sheet of paper. e-book Dedicated, handheld, book-size devices that display text and graphics (See also e-book reader) e-book reader Dedicated, handheld, book-sized devices that display text and graphics. (See also e-book) e-paper A special type of screen for an e-book reader that requires power only when changing pages, and not the entire time a page is displayed. (See also e-paper) electronic paper A special type of screen for an e-book reader that requires power only when charging pages, and not the entire time a page is displayed. (See also e-paper) ergonomic keyboard A type of keyboard designed specifically to alleviate wrist strain associated with the repetitive movements of typing. flat-panel monitor A type of monitor that is much thinner and requires less power to operate than CRTs. flatbed scanner The image to b","date":"2021-12-28","objectID":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/:6:0","tags":["软件工程"],"title":"实用计算机英语","uri":"/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/"},{"categories":["Golang"],"content":"os os 包提供了平台无关的操作系统功能接口。 尽管错误处理是 go 风格的，但设计是 Unix 风格的；所以，失败的调用会返回 error 而非错误码。通常 error 里会包含更多信息。 例如，如果使用一个文件名的调用（如 Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为 *PathError，其内部可以解包获得更多信息。 os 包规定为所有操作系统实现的接口都是一致的。有一些某个系统特定的功能，需要使用 syscall 获取。实际上，os 依赖于 syscall。 在实际编程中，我们应该总是优先使用 os 中提供的功能，而不是 syscall。 下面是一个简单的例子，打开一个文件并从中读取一些数据： file, err := os.Open(\"file.go\") // For read access. if err != nil { log.Fatal(err) } 如果打开失败，错误字符串是自解释的，例如： open file.go: no such file or directory 而不像 C 语言，需要额外的函数（或宏）来解释错误码。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:0:0","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"快览 func Create(name string) (file *File, err Error) 根据提供的文件名创建新的文件，返回一个文件对象，默认权限是 0666 func NewFile(fd uintptr, name string) *File 根据文件描述符创建相应的文件，返回一个文件对象 func Open(name string) (file *File, err Error) 只读方式打开一个名称为 name 的文件 func OpenFile(name string, flag int, perm uint32) (file *File, err Error) 打开名称为 name 的文件，flag 是打开的方式，只读、读写等，perm 是权限 func (file *File) Write(b []byte) (n int, err Error) 写入 byte 类型的信息到文件 func (file *File) WriteAt(b []byte, off int64) (n int, err Error) 在指定位置开始写入 byte 类型的信息 func (file *File) WriteString(s string) (ret int, err Error) 写入 string 信息到文件 func (file *File) Read(b []byte) (n int, err Error) 读取数据到 b 中 func (file *File) ReadAt(b []byte, off int64) (n int, err Error) 从 off 开始读取数据到 b 中 func Remove(name string) Error 删除文件名为 name 的文件 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:1:0","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"文件 I/O 在 Unix 系统调用中，所有 I/O 操作以文件描述符 ( 一个非负整数 , 通常是小整数 ) 来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。这里，我们主要介绍普通文件的 I/O。 在 Go 中，文件描述符封装在 os.File 结构中，通过 File.Fd() 可以获得底层的文件描述符：fd。 按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。os 包提供了 3 个 File 对象，分别代表这 3 种标准描述符：Stdin、Stdout 和 Stderr，它们对应的文件名分别是：/dev/stdin、/dev/stdout 和 /dev/stderr。 这里说的文件名，并不一定存在，比如 Windows 下就没有。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:2:0","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"打开文件 OpenFile OpenFile() 既能打开一个已经存在的文件，也能创建并打开一个新文件。 func OpenFile(name string, flag int, perm FileMode) (*File, error) OpenFile 是一个更一般性的文件打开函数，大多数调用者都应用 Open 或 Create 代替本函数。 它会使用指定的选项（如 O_RDONLY 等）、指定的模式（如 0666 等）打开指定名称的文件。 如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 *PathError。它会记录具体操作、文件路径和错误原因。 另外，在 OpenFile 内部会调用 NewFile，来得到 File 对象。 name 要打开的文件由参数 name 指定。 它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。 flag 位掩码参数 flag 用于指定文件的访问模式，可用的值在 os 中定义为常量（以下值并非所有操作系统都可用）： const ( O_RDONLY int = syscall.O_RDONLY // 只读模式打开文件 O_WRONLY int = syscall.O_WRONLY // 只写模式打开文件 O_RDWR int = syscall.O_RDWR // 读写模式打开文件 O_APPEND int = syscall.O_APPEND // 写操作时将数据附加到文件尾部 O_CREATE int = syscall.O_CREAT // 如果不存在将创建一个新文件 O_EXCL int = syscall.O_EXCL // 和 O_CREATE 配合使用，文件必须不存在 O_SYNC int = syscall.O_SYNC // 打开文件用于同步 I/O O_TRUNC int = syscall.O_TRUNC // 如果可能，打开时清空文件 ) 其中，O_RDONLY、O_WRONLY、O_RDWR 应该只指定一个，剩下的通过 | 操作符来指定。 该函数内部会给 flags 加上 syscall.O_CLOEXEC，在 fork 子进程时会关闭通过 OpenFile 打开的文件，即子进程不会重用该文件描述符。 由于历史原因，O_RDONLY | O_WRONLY 并非等于 O_RDWR，它们的值一般是 0、1、2 perm 位掩码参数 perm 指定了文件的模式和权限位，类型是 os.FileMode，文件模式位常量定义在 os 中： const ( // 单字符是被 String 方法用于格式化的属性缩写。 ModeDir FileMode = 1 \u003c\u003c (32 - 1 - iota) // d: 目录 ModeAppend // a: 只能写入，且只能写入到末尾 ModeExclusive // l: 用于执行 ModeTemporary // T: 临时文件（非备份文件） ModeSymlink // L: 符号链接（不是快捷方式文件） ModeDevice // D: 设备 ModeNamedPipe // p: 命名管道（FIFO） ModeSocket // S: Unix 域 socket ModeSetuid // u: 表示文件具有其创建者用户 id 权限 ModeSetgid // g: 表示文件具有其创建者组 id 的权限 ModeCharDevice // c: 字符设备，需已设置 ModeDevice ModeSticky // t: 只有 root/ 创建者能删除 / 移动文件 // 覆盖所有类型位（用于通过 \u0026 获取类型位），对普通文件，所有这些位都不应被设置 ModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice ModePerm FileMode = 0777 // 覆盖所有 Unix 权限位（用于通过 \u0026 获取类型位） ) 以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。 不是所有的位都能用于所有的系统，唯一共有的是用于表示目录的 ModeDir 位。 以上这些被定义的位是 FileMode 最重要的位。另外 9 个位（权限位）为标准 Unix rwxrwxrwx 权限（所有人都可读、写、运行）。 FileMode 还定义了几个方法，用于判断文件类型的 IsDir() 和 IsRegular()，用于获取权限的 Perm()。 Open 和 Create 打开一个文件，一般通过 Open 或 Create，我们看这两个函数的实现。 func Open(name string) (*File, error) { return OpenFile(name, O_RDONLY, 0) } func Create(name string) (*File, error) { return OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666) } ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:2:1","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"读取文件 Read func (f *File) Read(b []byte) (n int, err error) Read 方法从 f 中读取最多 len(b) 字节数据并写入 b。 它返回读取的字节数和可能遇到的任何错误。 文件终止标志是读取 0 个字节且返回值 err 为 io.EOF。 从方法声明可以知道，File 实现了 io.Reader 接口。 Read 对应的系统调用是 read。 ReadAt 对比下 ReadAt 方法： func (f *File) ReadAt(b []byte, off int64) (n int, err error) ReadAt 从指定的位置（相对于文件开始位置）读取长度为 len(b) 个字节数据并写入 b。 它返回读取的字节数和可能遇到的任何错误。 当 n\u003clen(b) 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 err 会是 io.EOF。它对应的系统调用是 pread。 Read 和 ReadAt 的区别：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 off 指定的位置开始读，且不会改变文件当前偏移量。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:2:2","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"写入文件 Write func (f *File) Write(b []byte) (n int, err error) Write 向文件中写入 len(b) 字节数据。 它返回写入的字节数和可能遇到的任何错误。 如果返回值 n!=len(b)，本方法会返回一个非 nil 的错误。 从方法声明可以知道，File 实现了 io.Writer 接口。 Write 对应的系统调用是 write。 WriteAt, WriteString Write 与 WriteAt 的区别同 Read 与 ReadAt 的区别一样。 为了方便，还提供了 WriteString 方法，它实际是对 Write 的封装。 注意：Write 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会影响性能），有两种办法： 打开文件时指定 os.O_SYNC； 调用 File.Sync() 方法。 说明：File.Sync() 底层调用的是 fsync 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件数据），需要自己封装，调用 fdatasync 系统调用。（syscall.Fdatasync） ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:2:3","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"关闭文件 Close close() 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。 当进程终止时，将自动关闭其已打开的所有文件描述符。 func (f *File) Close() error os.File.Close() 是对 close() 的封装。 我们应该养成关闭不需要的文件的良好编程习惯。 文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，长期运行的服务可能会把文件描述符耗尽。 通常的写法如下： file, err := os.Open(\"/tmp/studygolang.txt\") if err != nil { // 错误处理，一般会阻止程序往下执行 return } defer file.Close() // 在return之前执行 关于返回值 error 以下两种情况会导致 Close 返回错误： 关闭一个未打开的文件； 两次关闭同一个文件； 通常，我们不会去检查 Close 的错误。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:2:4","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"改变文件偏移量 Seek 对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。 文件偏移量是指执行下一个 Read 或 Write 操作的文件其实位置，会以相对于文件头部起始点的文件当前位置来表示。 文件第一个字节的偏移量为 0。 文件打开时，会将文件偏移量设置为指向文件开始，以后每次 Read 或 Write 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。 因此，连续的 Read 和 Write 调用将按顺序递进，对文件进行操作。 而 Seek 可以调整文件偏移量。方法定义如下： func (f *File) Seek(offset int64, whence int) (ret int64, err error) Seek 设置下一次读 / 写的位置。 offset 为相对偏移量 whence 决定相对位置 0 为相对文件开头 1 为相对当前位置 2 为相对文件结尾。 它返回新的偏移量（相对开头）和可能的错误。 使用中，whence 应该使用 os 包中的常量：SEEK_SET、SEEK_CUR 和 SEEK_END。 注意：Seek 只是调整内核中与文件描述符相关的文件偏移量记录，并没有引起对任何物理设备的访问。 一些 Seek 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置： file.Seek(0, os.SEEK_SET) // 文件开始处 file.Seek(0, SEEK_END) // 文件结尾处的下一个字节 file.Seek(-1, SEEK_END) // 文件最后一个字节 file.Seek(-10, SEEK_CUR) // 当前位置前 10 个字节 file.Seek(1000, SEEK_END) // 文件结尾处的下 1001 个字节 最后一个例子在文件中会产生“空洞”。 Seek 对应系统调用 lseek。该系统调用并不适用于所有类型，不允许将 lseek 应用于管道、FIFO、socket 或 终端。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:2:5","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"截断文件 truncate 和 ftruncate 系统调用将文件大小设置为 size 参数指定的值；Go 语言中相应的包装函数是 os.Truncate 和 os.File.Truncate。 func Truncate(name string, size int64) error func (f *File) Truncate(size int64) error 如果文件当前长度大于参数 size，调用将丢弃超出部分，若小于参数 size，调用将在文件尾部添加一系列空字节或是一个文件空洞。 它们之间的区别在于如何指定操作文件： Truncate 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。若文件名为符号链接，那么调用将对其进行解引用。 很明显，调用 File.Truncate 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:3:0","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"文件属性 Stat 文件属性，也即文件元数据。 在 Go 中，文件属性具体信息通过 os.FileInfo 接口获取。 函数 Stat、Lstat 和 File.Stat 可以得到该接口的实例。这三个函数对应三个系统调用：stat、lstat 和 fstat。 这三个函数的区别： stat 会返回所命名文件的相关信息。 lstat 与 stat 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。 fstat 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。 Stat 和 Lstat 无需对其所操作的文件本身拥有任何权限，但针对指定 name 的父目录要有执行（搜索）权限。而只要 File 对象 ok，File.Stat 总是成功。 FileInfo 接口如下： type FileInfo interface { Name() string // 文件的名字（不含扩展名） Size() int64 // 普通文件返回值表示其大小；其他文件的返回值含义各系统不同 Mode() FileMode // 文件的模式位 ModTime() time.Time // 文件的修改时间 IsDir() bool // 等价于 Mode().IsDir() Sys() interface{} // 底层数据来源（可以返回 nil） } Sys() 底层数据的 C 语言 结构 statbuf 格式如下： struct stat { dev_t st_dev; // 设备 ID ino_t st_ino; // 文件 i 节点号 mode_t st_mode; // 位掩码，文件类型和文件权限 nlink_t st_nlink; // 硬链接数 uid_t st_uid; // 文件属主，用户 ID gid_t st_gid; // 文件属组，组 ID dev_t st_rdev; // 如果针对设备 i 节点，则此字段包含主、辅 ID off_t st_size; // 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小 blksize_t st_blsize; // 分配给文件的总块数，块大小为 512 字节 blkcnt_t st_blocks; // 实际分配给文件的磁盘块数量 time_t st_atime; // 对文件上次访问时间 time_t st_mtime; // 对文件上次修改时间 time_t st_ctime; // 文件状态发生改变的上次时间 } Go 中 syscal.Stat_t 与该结构对应。 如果我们要获取 FileInfo 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下： fileInfo, err := os.Stat(\"test.log\") if err != nil { log.Fatal(err) } sys := fileInfo.Sys() stat := sys.(*syscall.Stat_t) fmt.Println(time.Unix(stat.Atimespec.Unix())) ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:4:0","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"改变文件时间戳 Chitimes 可以显式改变文件的访问时间和修改时间。 func Chtimes(name string, atime time.Time, mtime time.Time) error Chtimes 修改 name 指定的文件对象的访问时间和修改时间，类似 Unix 的 utime() 或 utimes() 函数。 底层的文件系统可能会截断 / 舍入时间单位到更低的精确度。 如果出错，会返回 *PathError 类型的错误。 在 Unix 中，函数的底层实现会调用 utimenstat()，它提供纳秒级别的精度 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:4:1","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"文件属主 Chown 每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。 系统调用 chown、lchown 和 fchown 可用来改变文件的属主和属组，Go 中对应的函数或方法： func Chown(name string, uid, gid int) error func Lchown(name string, uid, gid int) error func (f *File) Chown(uid, gid int) error 它们的区别和上文提到的 Stat 相关函数类似。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:4:2","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"文件权限 这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以及 Unix 域套接字等。 关于目录权限 目录与文件拥有相同的权限方案，只是对 3 种权限的含义另有所指。 读权限：可列出（比如，通过 ls 命令）目录之下的内容（即目录下的文件名）。 写权限：可在目录内创建、删除文件。注意，要删除文件，对文件本身无需有任何权限。 可执行权限：可访问目录中的文件。因此，有时也将对目录的执行权限称为 search（搜索）权限。 访问文件时，需要拥有对路径名所列所有目录的执行权限。例如，想读取文件 /home/studygolang/abc，则需拥有对目录 /、/home 以及 /home/studygolang 的执行权限（还要有对文件 abc 自身的读权限）。 IsPermission 在文件相关操作报错时，可以通过 os.IsPermission 检查是否是权限的问题。 func IsPermission(err error) bool 返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。ErrPermission 和一些系统调用错误会使它返回真。 另外，syscall.Access 可以获取文件的权限。这对应系统调用 access。 Chmod 除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是 set-user-ID(bit 04000)、set-group-ID(bit 02000) 和 sticky(bit 01000) 位。set-user-ID 和 set-group-ID 权限位将在进程章节介绍。这里介绍 sticky 位。 Sticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操作。 根据这个机制来创建为多个用户共享的一个目录，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。/tmp 目录就设置了 sticky 位，正是出于这个原因。 chmod 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 ls -l 显示文件时，会在其他用户执行权限字段上看到字母 t（有执行权限时） 或 T（无执行权限时）。 os.Chmod 和 os.File.Chmod 可以修改文件权限（包括 sticky 位），分别对应系统调用 chmod 和 fchmod。 func main() { file, err := os.Create(\"studygolang.txt\") if err != nil { log.Fatal(\"error:\", err) } defer file.Close() fileMode := getFileMode(file) log.Println(\"file mode:\", fileMode) file.Chmod(fileMode | os.ModeSticky) log.Println(\"change after, file mode:\", getFileMode(file)) } func getFileMode(file *os.File) os.FileMode { fileInfo, err := file.Stat() if err != nil { log.Fatal(\"file stat error:\", err) } return fileInfo.Mode() } // Output: // 2016/06/18 15:59:06 file mode: -rw-rw-r-- // 2016/06/18 15:59:06 change after, file mode: trw-rw-r-- // ls -l 看到的 studygolang.tx 是：-rw-rw-r-T // 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:4:3","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"目录与链接 在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二： 在其 i-node 条目中，会将目录标记为一种不同的文件类型。 目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 i-node 标号。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:5:0","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"创建和移除（硬）链接 Link Remove 硬链接是针对文件而言的，目录不允许创建硬链接。 link 和 unlink 系统调用用于创建和移除（硬）链接。 Go 中 os.Link 对应 link 系统调用；但 os.Remove 的实现会先执行 unlink 系统调用，如果要移除的是目录，则 unlink 会失败，这时 Remove 会再调用 rmdir 系统调用。 Link 创建一个名为 newname 指向 oldname 的硬链接。如果出错，会返回 *LinkError 类型的错误。 func Link(oldname, newname string) error Remove 删除 name 指定的文件或目录。如果出错，会返回 *PathError 类型的错误。如果目录不为空，Remove 会返回失败。 func Remove(name string) error ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:5:1","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"更改文件名 系统调用 rename 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。 该系统调用既可以用于文件，也可以用于目录。 Go 中的 os.Rename 是对应的封装函数。 func Rename(oldpath, newpath string) error Rename 修改一个文件的名字或移动一个文件。如果 newpath 已经存在，则替换它。注意，可能会有一些个操作系统特定的限制。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:5:2","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"使用符号链接 符号链接即软链接 软链接类似于快捷方式，它可以指向任意文件系统中的一个文件或目录。 硬链接也可以看作是文件或目录的快捷方式，但是无法在两个不同文件系统之间创建硬链接。 symlink 系统调用用于为指定路径名创建一个新的符号链接（想要移除符号链接，使用 unlink）。 Go 中的 os.Symlink 是对应的封装函数。 Symlink 创建一个名为 newname 指向 oldname 的符号链接。如果出错，会返回 *LinkError 类型的错误。 func Symlink(oldname, newname string) error 由 oldname 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，newname 成为“悬空链接”，其他系统调用试图对其进行解引用操作都将错误（通常错误号是 ENOENT）。 ReadLink 有时候，我们希望通过符号链接，能获取其所指向的路径名。系统调用 readlink 能做到，Go 的封装函数是 os.Readlink： func Readlink(name string) (string, error) Readlink 获取 name 指定的符号链接指向的文件的路径。 如果出错，会返回 *PathError 类型的错误。 我们看看 Readlink 的实现。 func Readlink(name string) (string, error) { for len := 128; ; len *= 2 { b := make([]byte, len) n, e := fixCount(syscall.Readlink(name, b)) if e != nil { return \"\", \u0026PathError{\"readlink\", name, e} } if n \u003c len { return string(b[0:n]), nil } } } 这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 b 长度不够，文件名会被截断，而 readlink 系统调用无非分辨所返回的字符串到底是经过截断处理，还是恰巧将 b 填满。这里采用的验证方法是分配一个更大的（两倍）b 并再次调用 readlink。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:5:3","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"创建和移除目录 Mkdir, MkdirAll mkdir 系统调用创建一个新目录，Go 中的 os.Mkdir 是对应的封装函数。 func Mkdir(name string, perm FileMode) error Mkdir 使用指定的权限和名称创建一个目录。如果出错，会返回 *PathError 类型的错误。 name 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 os.ErrExist 错误。 perm 参数指定了新目录的权限。对该位掩码值的指定方式和 os.OpenFile 相同，也可以直接赋予八进制数值。注意，perm 值还将于进程掩码相与（\u0026）。如果 perm 中设置了 sticky 位，那么将对新目录设置该权限。 因为 Mkdir 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。os.MkdirAll 用于递归创建所有不存在的目录。 Remove, RemoveAll rmdir 系统调用移除一个指定的目录，目录可以是绝对路径或相对路径。 在讲解 unlink 时，已经介绍了 Go 中的 os.Remove。 注意，这里要求目录必须为空。为了方便使用，Go 中封装了一个 os.RemoveAll 函数： func RemoveAll(path string) error RemoveAll 删除 path 指定的文件，或目录及它包含的任何下级对象。 它会尝试删除所有东西，除非遇到错误并返回。 如果 path 指定的对象不存在，RemoveAll 会返回 nil 而不返回错误。 RemoveAll 的内部实现逻辑如下： 调用 Remove 尝试进行删除，如果成功或返回 path 不存在，则直接返回 nil； 调用 Lstat 获取 path 信息，以便判断是否是目录。注意，这里使用 Lstat，表示不对符号链接解引用； 调用 Open 打开目录，递归读取目录中内容，执行删除操作。 ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:5:4","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"读目录 Readdirnames, Readdir POSIX 与 SUS 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现了读目录功能。 func (f *File) Readdirnames(n int) (names []string, err error) Readdirnames 读取目录 f 的内容，返回一个最多有 n 个成员的 []string，切片成员为目录中文件对象的名字，采用目录顺序。 对本函数的下一次调用会返回上一次调用未读取的内容的信息。 如果 n\u003e0，Readdirnames 函数会返回一个最多 n 个成员的切片。这时，如果 Readdirnames 返回一个空切片，它会返回一个非 nil 的错误说明原因。如果到达了目录 f 的结尾，返回值 err 会是 io.EOF。 如果 n\u003c=0，Readdirnames 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 Readdirnames 调用成功（读取所有内容直到结尾），它会返回该切片和 nil 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。 func (f *File) Readdir(n int) (fi []FileInfo, err error) Readdir 内部会调用 Readdirnames，将得到的 names 构造路径，通过 Lstat 构造出 []FileInfo。 例：列出某个目录的文件列表 package main import ( \"fmt\" \"io\" \"os\" \"path/filepath\" ) func main() { ReadAndOutputDir(\"../../..\", 3) } func ReadAndOutputDir(rootPath string, deep int) { file, err := os.Open(rootPath) if err != nil { fmt.Println(\"error:\", err) return } defer file.Close() for { fileInfos, err := file.Readdir(100) if err != nil { if err == io.EOF { break } fmt.Println(\"readdir error:\", err) return } if len(fileInfos) == 0 { break } for _, fileInfo := range fileInfos { if fileInfo.IsDir() { if deep \u003e 0 { ReadAndOutputDir(filepath.Join(rootPath, string(os.PathSeparator), fileInfo.Name()), deep-1) } } else { fmt.Println(\"file:\", fileInfo.Name(), \"in directory:\", rootPath) } } } } ","date":"2021-12-25","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/:5:5","tags":["Go 库"],"title":"Go os 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"},{"categories":["Golang"],"content":"io https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.1.html io 包为 I/O 原语提供了基本的接口。它主要包装了这些原语的已有实现。 由于这些被接口包装的 I/O 原语是由不同的低级操作实现，因此，在另有声明之前不该假定它们的并发执行是安全的。 在 io 包中最重要的两个接口：Reader 和 Writer 接口。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:0:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"Reader 接口 type Reader interface { Read(p []byte) (n int, err error) } Read 将 len(p) 个字节读取到 p 中。 它返回读取的字节数 n（0 \u003c= n \u003c= len(p)） 以及任何遇到的错误。 如果资源内容已全部读取完毕，应该返回 io.EOF 错误。 即使 Read 返回的 n \u003c len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。 若可读取的数据不到 len(p) 个字节，Read 会返回可用数据，而不是等待更多数据。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:1:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 所有实现了 Read 方法的类型都满足 io.Reader 接口，也就是说，在所有需要 io.Reader 的地方，都可以传递实现了 Read() 方法的类型的实例。 func ReadFrom(reader io.Reader, num int) ([]byte, error) { p := make([]byte, num) n, err := reader.Read(p) if n \u003e 0 { return p[:n], nil } return p, err } ReadFrom 函数将 io.Reader 作为参数，也就是说，ReadFrom 可以从任意的地方读取数据，只要来源实现了 io.Reader 接口。 比如，我们可以从标准输入、文件、字符串等读取数据，示例代码如下： // 从标准输入读取 data, err = ReadFrom(os.Stdin, 11) // 从普通文件读取，其中 file 是 os.File 的实例 data, err = ReadFrom(file, 9) // 从字符串读取 data, err = ReadFrom(strings.NewReader(\"from string\"), 12) io.EOF 变量的定义：var EOF = errors.New(\"EOF\")，是 error 类型。 根据 reader 接口的说明，在 n \u003e 0 且数据被读完了的情况下，返回的 error 有可能是 EOF 也有可能是 nil。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:1:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"Writer 接口 type Writer interface { Write(p []byte) (n int, err error) } Write 将 len(p) 个字节从 p 中写入到基本数据流中。 它返回从 p 中被写入的字节数 n（0 \u003c= n \u003c= len(p)）以及任何遇到的引起写入提前停止的错误。若 Write 返回的 n \u003c len(p)，它就必须返回一个非 nil 的错误 同样的，所有实现了Write方法的类型都实现了 io.Writer 接口。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:2:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 这里，我们通过标准库的例子来学习。 在 fmt 标准库中，有一组函数：Fprint/Fprintf/Fprintln，它们接收一个 io.Wrtier 类型参数（第一个参数），也就是说它们将数据格式化输出到 io.Writer 中。 我们以 fmt.Fprintln 为例 func Println(a ...interface{}) (n int, err error) { return Fprintln(os.Stdout, a...) //os.Stdout实现了Writer } 很显然，fmt.Println 会将内容输出到标准输出中。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:2:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"实现了 io.Reader 接口或 io.Writer 接口的类型 实现了 io.Reader 或 io.Writer 接口的函数参数是一个接口类型 os.File 同时实现了 io.Reader 和 io.Writer strings.Reader 实现了 io.Reader bufio.Reader/Writer 分别实现了 io.Reader 和 io.Writer bytes.Buffer 同时实现了 io.Reader 和 io.Writer bytes.Reader 实现了 io.Reader compress/gzip.Reader/Writer 分别实现了 io.Reader 和 io.Writer crypto/cipher.StreamReader/StreamWriter 分别实现了 io.Reader 和 io.Writer crypto/tls.Conn 同时实现了 io.Reader 和 io.Writer encoding/csv.Reader/Writer 分别实现了 io.Reader 和 io.Writer mime/multipart.Part 实现了 io.Reader net/conn 分别实现了 io.Reader 和 io.Writer(Conn接口定义了Read/Write) 以上类型中，常用的类型有：os.File、strings.Reader、bufio.Reader/Writer、bytes.Buffer、bytes.Reader ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:2:2","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"关于 os.Stdin 与 os.Stdout 我们还看到 os.Stdin/Stdout 这样的代码，它们似乎分别实现了 io.Reader/io.Writer 接口。实际上在 os 包中有这样的代码： var ( Stdin = NewFile(uintptr(syscall.Stdin), \"/dev/stdin\") Stdout = NewFile(uintptr(syscall.Stdout), \"/dev/stdout\") Stderr = NewFile(uintptr(syscall.Stderr), \"/dev/stderr\") ) 也就是说，Stdin/Stdout/Stderr 只是三个特殊的文件类型的标识（即都是 os.File 的实例），自然也实现了 io.Reader 和 io.Writer。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:2:3","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"ReaderAt 接口 可以通过该接口从指定偏移量处开始读取数据。 type ReaderAt interface { ReadAt(p []byte, off int64) (n int, err error) } ReadAt 从基本输入源的偏移量 off 处开始，将 len(p) 个字节读取到 p 中。 它返回读取的字节数 n（0 \u003c= n \u003c= len(p)）以及任何遇到的错误。 当 ReadAt 返回的 n \u003c len(p) 时，它就会返回一个 非nil 的错误来解释 为什么没有返回更多的字节。在这一点上，ReadAt 比 Read 更严格。 即使 ReadAt 返回的 n \u003c len(p)，它也会在调用过程中使用 p 的全部作为暂存空间。若可读取的数据不到 len(p) 字节，ReadAt 就会阻塞,直到所有数据都可用或一个错误发生。 在这一点上 ReadAt 不同于 Read。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:3:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 reader := strings.NewReader(\"Go语言中文网\") p := make([]byte, 6) n, err := reader.ReadAt(p, 2) if err != nil { panic(err) } fmt.Printf(\"%s, %d\\n\", p, n) 输出： 语言, 6 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:3:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"WriterAt 接口 可以通过该接口将数据写入到数据流的特定偏移量之后。 type WriterAt interface { WriteAt(p []byte, off int64) (n int, err error) } WriteAt 从 p 中将 len(p) 个字节写入到偏移量 off 处的基本数据流中。 它返回从 p 中被写入的字节数 n（0 \u003c= n \u003c= len(p)）以及任何遇到的引起写入提前停止的错误。 若 WriteAt 返回的 n \u003c len(p)，它就必须返回一个 非nil 的错误。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:4:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 通过简单示例来演示 WriteAt 方法的使用（os.File 实现了 WriterAt 接口）： file, err := os.Create(\"writeAt.txt\") if err != nil { panic(err) } defer file.Close() file.WriteString(\"Golang中文社区——这里是多余\") n, err := file.WriteAt([]byte(\"Go语言中文网\"), 24) if err != nil { panic(err) } fmt.Println(n) 打开文件 WriteAt.txt，内容将是：Golang中文社区——Go语言中文网。 分析： file.WriteString(\"Golang中文社区——这里是多余\") 往文件中写入 Golang中文社区——这里是多余，之后 file.WriteAt([]byte(\"Go语言中文网\"), 24) 在文件流的 offset=24 处写入 Go语言中文网（会覆盖该位置的内容）。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:4:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"ReaderFrom 接口 type ReaderFrom interface { ReadFrom(r Reader) (n int64, err error) } ReadFrom 从 r 中读取数据，直到 EOF 或发生错误。其返回值 n 为读取的字节数。除 io.EOF 之外，在读取过程中遇到的任何错误也将被返回。 如果 ReaderFrom 可用，Copy 函数就会使用它。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:5:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 下面的例子简单的实现将文件中的数据全部读取（显示在标准输出）： file, err := os.Open(\"writeAt.txt\") // file实现了Reader if err != nil { panic(err) } defer file.Close() writer := bufio.NewWriter(os.Stdout) // writer实现了ReaderFrom writer.ReadFrom(file) writer.Flush() 当然，我们可以通过 ioutil 包的 ReadFile 函数获取文件全部内容。其实，跟踪一下 ioutil.ReadFile 的源码，会发现其实也是通过 ReadFrom 方法实现（用的是 bytes.Buffer，它实现了 ReaderFrom 接口）。 如果不通过 ReadFrom 接口来做这件事，而是使用 io.Reader 接口，我们有两种思路： 先获取文件的大小（File 的 Stat 方法），之后定义一个该大小的 []byte，通过 Read 一次性读取 定义一个小的 []byte，不断的调用 Read 方法直到遇到 EOF，将所有读取到的 []byte 连接到一起 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:5:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"WriterTo 接口 type WriterTo interface { WriteTo(w Writer) (n int64, err error) } WriteTo 将数据写入 w 中，直到没有数据可写或发生错误。其返回值 n 为写入的字节数。 在写入过程中遇到的任何错误也将被返回。 如果 WriterTo 可用，Copy 函数就会使用它。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:6:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 reader := bytes.NewReader([]byte(\"Go语言中文网\")) // reader实现了WriterTo reader.WriteTo(os.Stdout) ReaderFrom 和 WriterTo 接口实质上传递了 Reader 和 Writer 的数据 数据源 -\u003e Reader (写入到 p) -\u003e ReaderFrom WriterTo -\u003e Writer (从 p 中写出) -\u003e 数据流 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:6:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"Seeker 接口 Seek 方法是用于设置偏移量的，这样可以从某个特定位置开始操作数据流 type Seeker interface { Seek(offset int64, whence int) (ret int64, err error) } Seek 设置下一次 Read 或 Write 的偏移量为 offset 它的解释取决于 whence 0 表示相对于文件的起始处 1 表示相对于当前的偏移 2 表示相对于其结尾处。 Seek 返回新的偏移量和一个错误，如果有的话。 听起来和 ReaderAt/WriteAt 接口有些类似，不过 Seeker 接口更灵活，可以更好的控制读写数据流的位置。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:7:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 获取倒数第二个字符（需要考虑 UTF-8 编码，这里的代码只是一个示例） reader := strings.NewReader(\"Go语言中文网\") reader.Seek(-6, io.SeekEnd) r, _, _ := reader.ReadRune() fmt.Printf(\"%c\\n\", r) ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:7:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"关于 whence whence 的值，在 io 包中定义了相应的常量，应该使用这些常量 const ( SeekStart = 0 // seek relative to the origin of the file SeekCurrent = 1 // seek relative to the current offset SeekEnd = 2 // seek relative to the end ) 而原先 os 包中的常量已经被标注为Deprecated // Deprecated: Use io.SeekStart, io.SeekCurrent, and io.SeekEnd. const ( SEEK_SET int = 0 // seek relative to the origin of the file SEEK_CUR int = 1 // seek relative to the current offset SEEK_END int = 2 // seek relative to the end ) ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:7:2","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"Closer 接口 type Closer interface { Close() error } 该接口比较简单，只有一个 Close() 方法，用于关闭数据流。 文件 (os.File)、归档（压缩包）、数据库连接、Socket 等需要手动关闭的资源都实现了 Closer 接口。 实际编程中，经常将 Close 方法的调用放在 defer 语句中。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:8:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"其他接口 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:9:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"一些复合接口 ReadCloser、ReadSeeker、ReadWriteCloser、ReadWriteSeeker、ReadWriter、WriteCloser 和 WriteSeeker 接口 这些接口是上面介绍的接口的两个或三个组合而成的新接口。例如 ReadWriter 接口： type ReadWriter interface { Reader Writer } 这是 Reader 接口和 Writer 接口的简单组合（内嵌）。 这些接口的作用是：有些时候同时需要某两个接口的所有功能，即必须同时实现了某两个接口的类型才能够被传入使用。可见，io 包中有大量的“小接口”，这样方便组合为“大接口”。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:9:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"SectionReader 类型 SectionReader 是一个 struct（没有任何导出的字段），实现了 Read, Seek 和 ReadAt，同时，内嵌了 ReaderAt 接口。结构定义如下： type SectionReader struct { r ReaderAt // 该类型最终的 Read/ReadAt 最终都是通过 r 的 ReadAt 实现 base int64 // NewSectionReader 会将 base 设置为 off off int64 // 从 r 中的 off 偏移处开始读取数据 limit int64 // limit - off = SectionReader 流的长度 } 该类型读取数据流中部分数据。看一下 func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader 的文档说明就知道了：NewSectionReader 返回一个 SectionReader，它从 r 中的偏移量 off 处读取 n 个字节后以 EOF 停止。 也就是说，SectionReader 只是内部（内嵌）ReaderAt 表示的数据流的一部分：从 off 开始后的 n 个字节。 这个类型的作用是：方便重复操作某一段 (section) 数据流；或者同时需要 ReadAt 和 Seek 的功能。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:10:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"LimitedReader 类型 type LimitedReader struct { R Reader // underlying reader，最终的读取操作通过 R.Read 完成 N int64 // max bytes remaining } 从 R 读取但将返回的数据量限制为 N 字节。每调用一次 Read 都将更新 N 来反应新的剩余数量。 也就是说，最多只能返回 N 字节数据。 LimitedReader 只实现了 Read 方法（Reader 接口）。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:11:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 使用示例如下： content := \"This Is LimitReader Example\" reader := strings.NewReader(content) //reader实现了Reader limitReader := \u0026io.LimitedReader{R: reader, N: 8} for limitReader.N \u003e 0 { tmp := make([]byte, 2) limitReader.Read(tmp) fmt.Printf(\"%s\", tmp) } 输出： This Is 可见，通过该类型可以达到 只允许读取一定长度数据 的目的。 在 io 包中，LimitReader 函数的实现其实就是调用 LimitedReader： func LimitReader(r Reader, n int64) Reader { return \u0026LimitedReader{r, n} } ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:11:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"Copy 函数 Copy 函数的签名： func Copy(dst Writer, src Reader) (written int64, err error) Copy 将 src 复制到 dst，直到在 src 上到达 EOF 或发生错误。它返回复制的字节数，如果有错误的话，还会返回在复制时遇到的第一个错误。 成功的 Copy 返回 err == nil，而非 err == EOF。由于 Copy 被定义为从 src 读取直到 EOF 为止，因此它不会将来自 Read 的 EOF 当做错误来报告。 若 dst 实现了 ReaderFrom 接口，其复制操作可通过调用 dst.ReadFrom(src) 实现。此外，若 src 实现了 WriterTo 接口，其复制操作可通过调用 src.WriteTo(dst) 实现。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:12:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 代码： io.Copy(os.Stdout, strings.NewReader(\"Go语言中文网\")) 直接将内容输出（写入 Stdout 中）。 我们甚至可以这么做： package main import ( \"fmt\" \"io\" \"os\" ) func main() { io.Copy(os.Stdout, os.Stdin) fmt.Println(\"Got EOF -- bye\") } 执行：echo \"Hello, World\" | go run main.go ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:12:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"CopyN 函数 func CopyN(dst Writer, src Reader, n int64) (written int64, err error) CopyN 将 n 个字节 (或到一个error) 从 src 复制到 dst。 它返回复制的字节数以及在复制时遇到的最早的错误。当且仅当 err == nil 时，written == n 。 若 dst 实现了 ReaderFrom 接口，复制操作也就会使用它来实现。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:13:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"例 io.CopyN(os.Stdout, strings.NewReader(\"Go语言中文网\"), 8) 会输出： Go语言 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:13:1","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"WriteString 函数 这是为了方便写入 string 类型提供的函数 func WriteString(w Writer, s string) (n int, err error) WriteString 将 s 的内容写入 w 中，当 w 实现了 WriteString 方法时，会直接调用该方法，否则执行 w.Write([]byte(s))。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/:14:0","tags":["Go 库","io"],"title":"Go io 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/"},{"categories":["Golang"],"content":"rand ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/rand/:0:0","tags":["Go 库"],"title":"Go math/rand 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/rand/"},{"categories":["Golang"],"content":"math/rand “math/rand” 包实现了伪随机数生成器。也就是生成整形和浮点型。 该包中根据生成伪随机数是是否有种子(可以理解为初始化伪随机数)，可以分为两类： 有种子。通常以时钟，输入输出等特殊节点作为参数初始化；该类型生成的随机数相比无种子时重复概率较低。 无种子。可以理解为此时种子为 1， Seek(1) import ( \"fmt\" \"math/rand\" \"time\" ) func main() { for i := 0; i \u003c 10; i++ { r := rand.New(rand.NewSource(time.Now().UnixNano())) fmt.Printf(\"%d \", r.Int31()) } fmt.Println(\"\") for i := 0; i \u003c 10; i++ { fmt.Printf(\"%d \", rand.Int31()) } } // 1278610617 1508223627 2035989429 921556381 1472325922 1058000409 246974909 2131355695 160634752 1895791427 // 1298498081 2019727887 1427131847 939984059 911902081 1474941318 140954425 336122540 208240456 646203300 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/rand/:1:0","tags":["Go 库"],"title":"Go math/rand 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/rand/"},{"categories":["Golang"],"content":"示例 package main import ( \"fmt\" \"math/rand\" \"os\" \"text/tabwriter\" ) func main() { // Create and seed the generator. // Typically a non-fixed seed should be used, such as time.Now().UnixNano(). // Using a fixed seed will produce the same output on every run. r := rand.New(rand.NewSource(99)) // The tabwriter here helps us generate aligned output. w := tabwriter.NewWriter(os.Stdout, 1, 1, 1, ' ', 0) defer w.Flush() show := func(name string, v1, v2, v3 interface{}) { fmt.Fprintf(w, \"%s\\t%v\\t%v\\t%v\\n\", name, v1, v2, v3) } // Float32 and Float64 values are in [0, 1). show(\"Float32\", r.Float32(), r.Float32(), r.Float32()) show(\"Float64\", r.Float64(), r.Float64(), r.Float64()) // ExpFloat64 values have an average of 1 but decay exponentially. show(\"ExpFloat64\", r.ExpFloat64(), r.ExpFloat64(), r.ExpFloat64()) // NormFloat64 values have an average of 0 and a standard deviation of 1. show(\"NormFloat64\", r.NormFloat64(), r.NormFloat64(), r.NormFloat64()) // Int31, Int63, and Uint32 generate values of the given width. // The Int method (not shown) is like either Int31 or Int63 // depending on the size of 'int'. show(\"Int31\", r.Int31(), r.Int31(), r.Int31()) show(\"Int63\", r.Int63(), r.Int63(), r.Int63()) show(\"Uint32\", r.Uint32(), r.Uint32(), r.Uint32()) // Intn, Int31n, and Int63n limit their output to be \u003c n. // They do so more carefully than using r.Int()%n. show(\"Intn(10)\", r.Intn(10), r.Intn(10), r.Intn(10)) show(\"Int31n(10)\", r.Int31n(10), r.Int31n(10), r.Int31n(10)) show(\"Int63n(10)\", r.Int63n(10), r.Int63n(10), r.Int63n(10)) // Perm generates a random permutation of the numbers [0, n). show(\"Perm\", r.Perm(5), r.Perm(5), r.Perm(5)) } Output: Float32 0.2635776 0.6358173 0.6718283 Float64 0.628605430454327 0.4504798828572669 0.9562755949377957 ExpFloat64 0.3362240648200941 1.4256072328483647 0.24354758816173044 NormFloat64 0.17233959114940064 1.577014951434847 0.04259129641113857 Int31 1501292890 1486668269 182840835 Int63 3546343826724305832 5724354148158589552 5239846799706671610 Uint32 2760229429 296659907 1922395059 Intn(10) 1 2 5 Int31n(10) 4 7 8 Int63n(10) 7 6 3 Perm [1 4 2 3 0] [4 2 1 3 0] [1 2 4 0 3] ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/rand/:1:1","tags":["Go 库"],"title":"Go math/rand 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/rand/"},{"categories":["Golang"],"content":"sort 该包实现了四种基本排序算法：插入排序、归并排序、堆排序和快速排序。 但是这四种排序方法是不公开的，它们只被用于 sort 包内部使用。 所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法，就可以顺利对数据集合进行排序： 获取数据集合长度的 Len() 方法 比较两个元素大小的 Less() 方法 交换两个元素位置的 Swap() 方法 sort 包会根据实际数据自动选择高效的排序算法。 除此之外，为了方便对常用数据类型的操作，sort 包提供了对 []int 切片、[]float64 切片和 []string 切片的完整支持，主要包括： 对基本数据类型切片的排序支持 基本数据元素查找 判断基本数据类型切片是否已经排好序 对排好序的数据集合逆序 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:0:0","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"数据集合排序 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:1:0","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"三个需要实现的方法 前面已经提到过，对数据集合（包括自定义数据类型的集合）排序需要实现 sort.Interface 接口的三个方法，我们看以下该接口的定义： type Interface interface { // 获取数据集合元素个数 Len() int // 如果 i 索引的数据小于 j 索引的数据，返回 true，且不会调用下面的 Swap()，即数据升序排序。 Less(i, j int) bool // 交换 i 和 j 索引的两个元素的位置 Swap(i, j int) } 数据集合实现了这三个方法后，即可调用该包的 Sort() 方法进行排序。 Sort() 方法定义如下： func Sort(data Interface) Sort() 方法惟一的参数就是待排序的数据集合。 该包还提供了一个方法可以判断数据集合是否已经排好顺序，该方法的内部实现依赖于我们自己实现的 Len() 和 Less() 方法： func IsSorted(data Interface) bool { n := data.Len() for i := n - 1; i \u003e 0; i-- { if data.Less(i, i-1) { return false } } return true } 下面是一个使用 sort 包对学生成绩排序的示例： package main import ( \"fmt\" \"sort\" ) // 学生成绩结构体 type StuScore struct { name string // 姓名 score int // 成绩 } type StuScores []StuScore //Len() func (s StuScores) Len() int { return len(s) } //Less(): 成绩将有低到高排序 func (s StuScores) Less(i, j int) bool { return s[i].score \u003c s[j].score } //Swap() func (s StuScores) Swap(i, j int) { s[i], s[j] = s[j], s[i] } func main() { stus := StuScores{ {\"alan\", 95}, {\"hikerell\", 91}, {\"acmfly\", 96}, {\"leao\", 90}, } // 打印未排序的 stus 数据 fmt.Println(\"Default:\\n\\t\",stus) //StuScores 已经实现了 sort.Interface 接口 , 所以可以调用 Sort 函数进行排序 sort.Sort(stus) // 判断是否已经排好顺序，将会打印 true fmt.Println(\"IS Sorted?\\n\\t\", sort.IsSorted(stus)) // 打印排序后的 stus 数据 fmt.Println(\"Sorted:\\n\\t\",stus) } 该示例程序的自定义类型 StuScores 实现了 sort.Interface 接口，所以可以将其对象作为 sort.Sort() 和 sort.IsSorted() 的参数传入。运行结果： Default: [{alan 95} {hikerell 91} {acmfly 96} {leao 90}] IS Sorted? true Sorted: [{leao 90} {hikerell 91} {alan 95} {acmfly 96}] 该示例实现的是升序排序，如果要得到降序排序结果，其实只要修改 Less() 函数： //Less(): 成绩降序排序 , 只将小于号修改为大于号 func (s StuScores) Less(i, j int) bool { return s[i].score \u003e s[j].score } ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:1:1","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"Reverse() 此外，sort 包提供了 Reverse() 方法，可以允许将数据按 Less() 定义的排序方式逆序排序，而不必修改 Less() 代码。方法定义如下： func Reverse(data Interface) Interface 我们可以看到 Reverse() 返回的一个 sort.Interface 接口类型，整个 Reverse() 的内部实现比较有趣： // 定义了一个 reverse 结构类型，嵌入 Interface 接口 type reverse struct { Interface } // reverse 结构类型的 Less() 方法拥有嵌入的 Less() 方法相反的行为 // Len() 和 Swap() 方法则会保持嵌入类型的方法行为 func (r reverse) Less(i, j int) bool { return r.Interface.Less(j, i) } // 返回新的实现 Interface 接口的数据类型 func Reverse(data Interface) Interface { return \u0026reverse{data} } 了解内部原理后，可以在学生成绩排序示例中使用 Reverse() 来实现成绩升序排序： sort.Sort(sort.Reverse(stus)) fmt.Println(stus) ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:1:2","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"Search() 最后一个方法：Search() func Search(n int, f func(int) bool) int 该方法会使用“二分查找”算法来找出能使 f(x)(0\u003c=x\u003cn) 返回 true 的最小值 i。 前提条件 : f(x)(0\u003c=x\u003ci) 均返回 false, f(x)(i\u003c=x\u003cn) 均返回 true。 如果不存在 i 可以使 f(i) 返回 true, 则返回 n。 Search() 函数一个常用的使用方式是搜索元素 x 是否在已经升序排好的切片 s 中： x := 11 s := []int{3, 6, 8, 11, 45} // 注意已经升序排序 pos := sort.Search(len(s), func(i int) bool { return s[i] \u003e= x }) if pos \u003c len(s) \u0026\u0026 s[pos] == x { fmt.Println(x, \" 在 s 中的位置为：\", pos) } else { fmt.Println(\"s 不包含元素 \", x) } 官方文档还给出了一个猜数字的小程序： func GuessingGame() { var s string fmt.Printf(\"Pick an integer from 0 to 100.\\n\") answer := sort.Search(100, func(i int) bool { fmt.Printf(\"Is your number \u003c= %d? \", i) fmt.Scanf(\"%s\", \u0026s) return s != \"\" \u0026\u0026 s[0] == 'y' }) fmt.Printf(\"Your number is %d.\\n\", answer) } ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:1:3","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"已支持的内部数据类型排序 前面已经提到，sort 包原生支持 []int、[]float64 和 []string 三种内建数据类型切片的排序操作，即不必我们自己实现相关的 Len()、Less() 和 Swap() 方法。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:2:0","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"IntSlice 类型及 []int 排序 由于 []int 切片排序内部实现及使用方法与 []float64 和 []string 类似，所以只详细描述该部分。 sort 包定义了一个 IntSlice 类型，并且实现了 sort.Interface 接口： type IntSlice []int func (p IntSlice) Len() int { return len(p) } func (p IntSlice) Less(i, j int) bool { return p[i] \u003c p[j] } func (p IntSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } // IntSlice 类型定义了 Sort() 方法，包装了 sort.Sort() 函数 func (p IntSlice) Sort() { Sort(p) } // IntSlice 类型定义了 SearchInts() 方法，包装了 SearchInts() 函数 func (p IntSlice) Search(x int) int { return SearchInts(p, x) } 并且提供的 sort.Ints() 方法使用了该 IntSlice 类型： func Ints(a []int) { Sort(IntSlice(a)) } 所以，对 []int 切片排序更常使用 sort.Ints()，而不是直接使用 IntSlice 类型： s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据 sort.Ints(s) fmt.Println(s) // 将会输出[1 2 3 4 5 6] 如果要使用降序排序，显然要用前面提到的 Reverse() 方法： s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据 sort.Sort(sort.Reverse(sort.IntSlice(s))) fmt.Println(s) // 将会输出[6 5 4 3 2 1] 如果要查找整数 x 在切片 a 中的位置，相对于前面提到的 Search() 方法，sort 包提供了 SearchInts(): func SearchInts(a []int, x int) int 注意，SearchInts() 的使用条件为：切片 a 已经升序排序 以下是一个错误使用的例子： s := []int{5, 2, 6, 3, 1, 4} // 未排序的切片数据 fmt.Println(sort.SearchInts(s, 2)) // 将会输出 0 而不是 1 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:2:1","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"Float64Slice 类型及 []float64 排序 实现与 Ints 类似，只看一下其内部实现： type Float64Slice []float64 func (p Float64Slice) Len() int { return len(p) } func (p Float64Slice) Less(i, j int) bool { return p[i] \u003c p[j] || isNaN(p[i]) \u0026\u0026 !isNaN(p[j]) } func (p Float64Slice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p Float64Slice) Sort() { Sort(p) } func (p Float64Slice) Search(x float64) int { return SearchFloat64s(p, x) } 与 Sort()、IsSorted()、Search() 相对应的三个方法： func Float64s(a []float64) func Float64sAreSorted(a []float64) bool func SearchFloat64s(a []float64, x float64) int 要说明一下的是，在上面 Float64Slice 类型定义的 Less 方法中，有一个内部函数 isNaN()。 isNaN() 与 math 包中 IsNaN() 实现完全相同，sort 包之所以不使用 math.IsNaN()，完全是基于包依赖性的考虑，应当看到，sort 包的实现不依赖与其他任何包。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:2:2","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"StringSlice 类型及 []string 排序 两个 string 对象之间的大小比较是基于“字典序”的。 实现与 Ints 类似，只看一下其内部实现： type StringSlice []string func (p StringSlice) Len() int { return len(p) } func (p StringSlice) Less(i, j int) bool { return p[i] \u003c p[j] } func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] } func (p StringSlice) Sort() { Sort(p) } func (p StringSlice) Search(x string) int { return SearchStrings(p, x) } 与 Sort()、IsSorted()、Search() 相对应的三个方法： func Strings(a []string) func StringsAreSorted(a []string) bool func SearchStrings(a []string, x string) int ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:2:3","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"[]interface 排序与查找 通过前面的内容我们可以知道，只要实现了 sort.Interface 接口，即可通过 sort 包内的函数完成排序，查找等操作。并且 sort 包已经帮我们把[]int, []float64, []string 三种类型都实现了该接口，我们可以方便的调用。但是这种用法对于其它数据类型的 slice 不友好，可能我们需要为大量的 struct 定义一个单独的 []struct 类型，再为其实现 sort.Interface 接口，类似这样： type Person struct { Name string Age int } type Persons []Person func (p Persons) Len() int { panic(\"implement me\") } func (p Persons) Less(i, j int) bool { panic(\"implement me\") } func (p Persons) Swap(i, j int) { panic(\"implement me\") } 因为排序涉及到比较两个变量的值，而 struct 可能包含多个属性，程序并不知道你想以哪一个属性或哪几个属性作为衡量大小的标准。 如果你能帮助程序完成比较，并将结果返回， sort 包内的方法就可以完成排序，判断，查找等。sort 包提供了以下函数： func Slice(slice interface{}, less func(i, j int) bool) func SliceStable(slice interface{}, less func(i, j int) bool) func SliceIsSorted(slice interface{}, less func(i, j int) bool) bool func Search(n int, f func(int) bool) int 通过函数签名可以看到，排序相关的三个函数都接收 []interface，并且需要传入一个比较函数，用于为程序比较两个变量的大小，因为函数签名和作用域的原因，这个函数只能是 匿名函数。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:3:0","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"sort.Slice 该函数完成 []interface 的排序，举个栗子： people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.Slice(people, func(i, j int) bool { return people[i].Age \u003c people[j].Age }) // 按年龄升序排序 fmt.Println(\"Sort by age:\", people) 输出结果： By age: [{Gopher 7} {Vera 24} {Alice 55} {Bob 75}] ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:3:1","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"sort.SliceStable 该函数完成 []interface 的稳定排序，举个栗子： people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.SliceStable(people, func(i, j int) bool { return people[i].Age \u003e people[j].Age }) // 按年龄降序排序 fmt.Println(\"Sort by age:\", people) 输出结果： By age: [{Bob 75} {Alice 55} {Vera 24} {Gopher 7}] ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:3:2","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"sort.SliceIsSorted 该函数判断 []interface 是否为有序，举个栗子： people := []struct { Name string Age int }{ {\"Gopher\", 7}, {\"Alice\", 55}, {\"Vera\", 24}, {\"Bob\", 75}, } sort.Slice(people, func(i, j int) bool { return people[i].Age \u003e people[j].Age }) // 按年龄降序排序 fmt.Println(\"Sort by age:\", people) fmt.Println(\"Sorted:\",sort.SliceIsSorted(people,func(i, j int) bool { return people[i].Age \u003c people[j].Age })) 输出结果： Sort by age: [{Bob 75} {Alice 55} {Vera 24} {Gopher 7}] Sorted: false sort 包没有为 []interface 提供反序函数，但是从 1 和 2 可以看出，我们传入的比较函数已经决定了排序结果是升序还是降序。 判断 slice 是否为有序，同样取决于我们传入的比较函数，从 3 可以看出，虽然 slice 已经按年龄降序排序，但我们在判断 slice 是否为有序时给的比较函数是判断其是否为升序有序，所以最终得到的结果为 false。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:3:3","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"sort.Search 该函数判断 []interface 是否存在指定元素，举个栗子： 升序 slice sort 包为 []int，[]float64，[]string 提供的 Search 函数其实也是调用的该函数，因为该函数是使用的二分查找法，所以要求 slice 为升序排序状态。并且判断条件必须为 \u003e=，这也是官方库提供的三个查找相关函数的的写法。 举个栗子： a := []int{2, 3, 4, 200, 100, 21, 234, 56} x := 21 sort.Slice(a, func(i, j int) bool { return a[i] \u003c a[j] }) // 升序排序 index := sort.Search(len(a), func(i int) bool { return a[i] \u003e= x }) // 查找元素 if index \u003c len(a) \u0026\u0026 a[index] == x { fmt.Printf(\"found %d at index %d in %v\\n\", x, index, a) } else { fmt.Printf(\"%d not found in %v,index:%d\\n\", x, a, index) } 输出结果： found 21 at index 3 in [2 3 4 21 56 100 200 234] 降序 slice 如果 slice 是降序状态，而我们又不想将其变为升序，只需将判断条件由 \u003e= 变更为 \u003c= 即可。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/:3:4","tags":["Go 库"],"title":"Go sort 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/sort/"},{"categories":["Golang"],"content":"命名 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:0:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"文件命名 文件命名一律采用小写，不用驼峰式，尽量见名思义，看见文件名就可以知道这个文件下的大概内容。 其中测试文件以 test.go 结尾，除测试文件外，命名不出现*。 例子： stringutil.go， stringutil_test.go ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:1:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"包名 package 包名用小写,使用短命名,尽量和标准库不要冲突。 包名统一使用单数形式。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:2:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"变量 变量命名一般采用驼峰式，当遇到特有名词（缩写或简称，如 DNS）的时候，特有名词根据是否私有全部大写或小写。 例子： apiClient、URLString ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:3:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"常量 同变量规则，力求语义表达完整清楚，不要嫌名字长。 如果模块复杂，为避免混淆，可按功能统一定义在package下的一个文件中。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:4:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"接口 单个函数的接口名以 er 为后缀 type Reader interface { Read(p []byte) (n int, err error) } 两个函数的接口名综合两个函数名，如: type WriteFlusher interface { Write([]byte) (int, error) Flush() error } 三个以上函数的接口名类似于结构体名，如: type Car interface { Start() Stop() Drive() } ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:5:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"结构体 结构体名应该是名词或名词短语，如Account,Book，避免使用Manager这样的。 如果该数据结构需要序列化，如json， 则首字母大写， 包括里面的字段。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:6:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"方法 方法名应该是动词或动词短语，采用驼峰式。将功能及必要的参数体现在名字中， 不要嫌长， 如 updateById，getUserInfo. 如果是结构体方法，那么 Receiver 的名称应该缩写，一般使用一个或者两个字符作为 Receiver 的名称。如果 Receiver 是指针， 那么统一使用p。 如： func (f foo) method() { ... } func (p *foo) method() { ... } 对于Receiver命名应该统一， 要么都使用值， 要么都用指针。 注释 每个包都应该有一个包注释，位于 package 之前。如果同一个包有多个文件，只需要在一个文件中编写即可；如果你想在每个文件中的头部加上注释，需要在版权注释和 Package前面加一个空行，否则版权注释会作为Package的注释。如： // Copyright 2009 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. package net 每个以大写字母开头（即可以导出）的方法应该有注释，且以该函数名开头。如： // Get 会响应对应路由转发过来的 get 请求 func (c *Controller) Get() { ... } 大写字母开头的方法以为着是可供调用的公共方法，如果你的方法想只在本包内掉用，请以小写字母开发。如: func (c *Controller) curl() { ... } 注释应该用一个完整的句子，注释的第一个单词应该是要注释的指示符，以便在 godoc 中容易查找。 ","date":"2021-12-23","objectID":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/:7:0","tags":[],"title":"Go 命名和开发规范","uri":"/Notes/posts/golang/%E5%91%BD%E5%90%8D%E5%92%8C%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"},{"categories":["Golang"],"content":"math math 包实现的就是数学函数计算。 ","date":"2021-12-22","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:0:0","tags":["Go 库"],"title":"Go math 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"三角函数 正弦函数，反正弦函数，双曲正弦，反双曲正弦 - func Sin(x float64) float64 - func Asin(x float64) float64 - func Sinh(x float64) float64 - func Asinh(x float64) float64 一次性返回 sin,cos func Sincos(x float64) (sin, cos float64) 余弦函数，反余弦函数，双曲余弦，反双曲余弦 - func Cos(x float64) float64 - func Acos(x float64) float64 - func Cosh(x float64) float64 - func Acosh(x float64) float64 正切函数，反正切函数，双曲正切，反双曲正切 - func Tan(x float64) float64 - func Atan(x float64) float64 和 func Atan2(y, x float64) float64 - func Tanh(x float64) float64 - func Atanh(x float64) float64 ","date":"2021-12-22","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:1:0","tags":["Go 库"],"title":"Go math 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"幂次函数 - func Cbrt(x float64) float64 // 立方根函数 - func Pow(x, y float64) float64 // x 的幂函数 - func Pow10(e int) float64 // 10 根的幂函数 - func Sqrt(x float64) float64 // 平方根 - func Log(x float64) float64 // 对数函数 - func Log10(x float64) float64 // 10 为底的对数函数 - func Log2(x float64) float64 // 2 为底的对数函数 - func Log1p(x float64) float64 // log(1 + x) - func Logb(x float64) float64 // 相当于 log2(x) 的绝对值 - func Ilogb(x float64) int // 相当于 log2(x) 的绝对值的整数部分 - func Exp(x float64) float64 // 指数函数 - func Exp2(x float64) float64 // 2 为底的指数函数 - func Expm1(x float64) float64 // Exp(x) - 1 ","date":"2021-12-22","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:2:0","tags":["Go 库"],"title":"Go math 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"特殊函数 - func Inf(sign int) float64 // 正无穷 - func IsInf(f float64, sign int) bool // 是否正无穷 - func NaN() float64 // 无穷值 - func IsNaN(f float64) (is bool) // 是否是无穷值 - func Hypot(p, q float64) float64 // 计算直角三角形的斜边长 ","date":"2021-12-22","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:3:0","tags":["Go 库"],"title":"Go math 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"类型转化函数 - func Float32bits(f float32) uint32 // float32 和 unit32 的转换 - func Float32frombits(b uint32) float32 // uint32 和 float32 的转换 - func Float64bits(f float64) uint64 // float64 和 uint64 的转换 - func Float64frombits(b uint64) float64 // uint64 和 float64 的转换 ","date":"2021-12-22","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:4:0","tags":["Go 库"],"title":"Go math 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["Golang"],"content":"其他函数 - func Abs(x float64) float64 // 绝对值函数 - func Ceil(x float64) float64 // 向上取整 - func Floor(x float64) float64 // 向下取整 - func Mod(x, y float64) float64 // 取模 - func Modf(f float64) (int float64, frac float64) // 分解 f，以得到 f 的整数和小数部分 - func Frexp(f float64) (frac float64, exp int) // 分解 f，得到 f 的位数和指数 - func Max(x, y float64) float64 // 取大值 - func Min(x, y float64) float64 // 取小值 - func Dim(x, y float64) float64 // 复数的维数 - func J0(x float64) float64 // 0 阶贝塞尔函数 - func J1(x float64) float64 // 1 阶贝塞尔函数 - func Jn(n int, x float64) float64 // n 阶贝塞尔函数 - func Y0(x float64) float64 // 第二类贝塞尔函数 0 阶 - func Y1(x float64) float64 // 第二类贝塞尔函数 1 阶 - func Yn(n int, x float64) float64 // 第二类贝塞尔函数 n 阶 - func Erf(x float64) float64 // 误差函数 - func Erfc(x float64) float64 // 余补误差函数 - func Copysign(x, y float64) float64 // 以 y 的符号返回 x 值 - func Signbit(x float64) bool // 获取 x 的符号 - func Gamma(x float64) float64 // 伽玛函数 - func Lgamma(x float64) (lgamma float64, sign int) // 伽玛函数的自然对数 - func Ldexp(frac float64, exp int) float64 // value 乘以 2 的 exp 次幂 - func Nextafter(x, y float64) (r float64) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x - func Nextafter32(x, y float32) (r float32) // 返回参数 x 在参数 y 方向上可以表示的最接近的数值，若 x 等于 y，则返回 x - func Remainder(x, y float64) float64 // 取余运算 - func Trunc(x float64) float64 // 截取函数 ","date":"2021-12-22","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/:5:0","tags":["Go 库"],"title":"Go math 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/math/"},{"categories":["前端"],"content":"Vue3 官方文档是最好的教程：https://v3.cn.vuejs.org/guide/ ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:0:0","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"认识 \u003cdiv id=\"counter\"\u003e Counter: {{ counter }} \u003c/div\u003e const Counter = { data() { return { counter: 0 } }, mounted() { setInterval(() =\u003e { this.counter++ }, 1000) } } Vue.createApp(Counter).mount('#counter') 另一个例子 const app = Vue.createApp({ data() { return { count: 4 } }, methods: { increment() { // `this` 指向该组件实例 this.count++ } } }) const vm = app.mount('#app') ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:1:0","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"不成熟的认知习惯 在 OptionsAPI 中 data 写成函数形式，里面 return 一个对象 methods 写成对象形式 computed 写成对象形式，里面的计算属性写成函数形式 mounted 写成函数形式 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:1:1","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"新特性 树摇（Tree shacking） 组合式 API（Composition API） ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:1:2","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"安装 vue-cli 基于 webpack 封装，生态非常强大，可配置性也非常高，几乎能够满足前端工程化的所有要求。缺点就是配置复杂，甚至有公司有专门的 webpack 工程师专门做配置，另外就是 webpack 由于开发环境需要打包编译，开发体验实际上不如 vite。 vite 开发模式基于 esbuild，打包使用的是 rollup。急速的 冷启动 和无缝的 hmr 在开发模式下获得极大的体验提升。缺点就是该脚手架刚起步，生态上还不及 webpack Vite vite 是伴随这 Vue3.0 诞生的单文件组件的非打包开发服务器，用来进行 3.0 的编译 安装 vite 命令 # yarn 安装 yarn global add create-vite-app # npm 全局安装 npm i -g create-vite-app 创建项目 # 完整命令 create-vite-app \u003cproject-name\u003e # 缩写命令 cva \u003cproject-name\u003e # or 推荐 npm init vite@latest \u003cproject-name\u003e -- --template vue 配置 vite.config.ts // vite.config.ts module.exports = { port: 8077, // 服务端口 proxy: { // 代理 // string shorthand \"/foo\": \"http://localhost:4567/foo\", // with options \"/api\": { target: \"http://jsonplaceholder.typicode.com\", changeOrigin: true, rewrite: (path) =\u003e path.replace(/^\\/api/, \"\"), }, }, }; Vue CLI 安装 npm install -g @vue/cli 创建项目 vue create my-vue3-demo # 通过可视化工具创建 vue ui 启动 npm run serve vue.config.js 配置 // vue.config.js module.exports = { outputDir: 'dist', // 打包的目录 lintOnSave: true, // 在保存时校验格式 productionSourceMap: false, // 生产环境是否生成 SourceMap devServer: { open: true, // 启动服务后是否打开浏览器 overlay: { // 错误信息展示到页面 warnings: true, errors: true }, host: '0.0.0.0', port: 8066, // 服务端口 https: false, hotOnly: false, // proxy: { // 设置代理 // '/api': { // target: host, // changeOrigin: true, // pathRewrite: { // '/api': '/', // } // }, // }, }, } ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:1:3","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"一些思想 对于任何包含响应式数据的复杂逻辑，都应该使用计算属性 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的响应依赖关系缓存的。计算属性只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要 author.books 还没有发生改变，多次访问 publishedBookMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数 但是如果你不希望有缓存，请用 method 来替代 当需要在数据变化时执行异步或开销较大的操作时，使用侦听器更为合适。 因为 v-if 是一个指令，所以必须将它添加到一个元素上。但是如果想切换多个元素呢？此时可以把一个 \u003ctemplate\u003e 元素当做不可见的包裹元素，并在上面使用 v-if。最终的渲染结果将不包含 \u003ctemplate\u003e 元素 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 建议尽可能在使用 v-for 时提供 key attribute，如 v-for=\"item in items\" :key=\"item.id\" 有时，我们想要显示一个数组经过过滤或排序后的版本，而不实际变更或重置原始数据。在这种情况下，可以创建一个计算属性，来返回过滤或排序后的数组 类似于 v-if，你也可以利用带有 v-for 的 \u003ctemplate\u003e 来循环渲染一段包含多个元素的内容 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:1:4","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"TS 支持 配置文件 // tsconfig.json { \"compilerOptions\": { \"target\": \"esnext\", \"module\": \"esnext\", // 这样就可以对 `this` 上的数据属性进行更严格的推断 \"strict\": true, \"jsx\": \"preserve\", \"moduleResolution\": \"node\" } } 请注意，必须包含 strict: true (或至少包含 noImplicitThis: true，它是 strict 标志的一部分) 才能在组件方法中利用 this 的类型检查，否则它总是被视为 any 类型。 如果你使用自定义 Webpack 配置，需要配置 ’ ts-loader ’ 来解析 vue 文件里的 \u003cscript lang=\"ts\"\u003e 代码块： // webpack.config.js module.exports = { ... module: { rules: [ { test: /\\.tsx?$/, loader: 'ts-loader', options: { appendTsSuffixTo: [/\\.vue$/], }, exclude: /node_modules/, }, { test: /\\.vue$/, loader: 'vue-loader', } ... 定义 Vue 组件 \u003cscript lang=\"ts\"\u003e import { defineComponent } from 'vue' export default defineComponent({ // 已启用类型推断 }) \u003c/script\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:1:5","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"基本知识 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:0","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"组件化 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。仔细想想，几乎任意类型的应用界面都可以抽象为一个组件树： 在 Vue 中，组件本质上是一个具有预定义选项的实例。在 Vue 中注册组件很简单：如对 App 对象所做的那样创建一个组件对象，并将其定义在父级组件的 components 选项中： // 创建 Vue 应用 const app = Vue.createApp(...) // 定义名为 todo-item 的新组件 app.component('todo-item', { template: `\u003cli\u003eThis is a todo\u003c/li\u003e` }) // 挂载 Vue 应用 app.mount(...) 现在，你可以将其放到到另一个组件的模板中： \u003col\u003e \u003c!-- 创建一个 todo-item 组件实例 --\u003e \u003ctodo-item\u003e\u003c/todo-item\u003e \u003c/ol\u003e 但是这样会为每个待办项渲染同样的文本。我们应该能将数据从父组件传入子组件才对。让我们来修改一下组件的定义，使之能够接受一个 prop；然后使用 v-bind 指令将待办项传到循环输出的每个组件中： \u003cdiv id=\"todo-list-app\"\u003e \u003col\u003e \u003c!-- 现在我们为每个 todo-item 提供 todo 对象 todo 对象是变量，即其内容可以是动态的。 我们也需要为每个组件提供一个“key”，稍后再 作详细解释。 --\u003e \u003ctodo-item v-for=\"item in groceryList\" v-bind:todo=\"item\" v-bind:key=\"item.id\" \u003e\u003c/todo-item\u003e \u003c/ol\u003e \u003c/div\u003e const TodoList = { data() { return { groceryList: [ { id: 0, text: 'Vegetables' }, { id: 1, text: 'Cheese' }, { id: 2, text: 'Whatever else humans are supposed to eat' } ] } } } const app = Vue.createApp(TodoList) app.component('todo-item', { props: ['todo'], template: `\u003cli\u003e{{ todo.text }}\u003c/li\u003e` }) app.mount('#todo-list-app') 在一个大型应用中，有必要将整个应用程序划分为多个组件，以使开发更易管理。不过这里有一个 (假想的) 例子，以展示使用了组件的应用模板是什么样的： \u003cdiv id=\"app\"\u003e \u003capp-nav\u003e\u003c/app-nav\u003e \u003capp-view\u003e \u003capp-sidebar\u003e\u003c/app-sidebar\u003e \u003capp-content\u003e\u003c/app-content\u003e \u003c/app-view\u003e \u003c/div\u003e 单个文件组件 在典型的 Vue 应用中，我们使用单个文件组件而不是字符串模板。 在模块系统中局部注册 如果你使用了诸如 Babel 和 webpack 的模块系统。在这些情况下，我们推荐创建一个 components 目录，并将每个组件放置在其各自的文件中。 然后你需要在局部注册之前导入每个你想使用的组件。例如，在一个假设的 ComponentB.js 或 ComponentB.vue 文件中： import ComponentA from './ComponentA' import ComponentC from './ComponentC' export default { components: { ComponentA, ComponentC } // ... } 现在 ComponentA 和 ComponentC 都可以在 ComponentB 的模板中使用了。 字母不分大小写 另外，HTML attribute 名不区分大小写，因此浏览器将所有大写字符解释为小写。这意味着当你在 DOM 模板中使用时，驼峰 prop 名称和 event 处理器参数需要使用它们的 kebab-cased (横线字符分隔) 等效值： // 在JavaScript中的驼峰 app.component('blog-post', { props: ['postTitle'], template: ` \u003ch3\u003e{{ postTitle }}\u003c/h3\u003e ` }) \u003c!-- 在HTML则是横线字符分割 --\u003e \u003cblog-post post-title=\"hello!\"\u003e\u003c/blog-post\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:1","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"应用实例 每个 Vue 应用都是通过用 createApp 函数创建一个新的应用实例开始的： const app = Vue.createApp({ /* 选项 */ }) 该应用实例是用来在应用中注册“全局”组件的。简单的例子： const app = Vue.createApp({}) app.component('SearchInput', SearchInputComponent) app.directive('focus', FocusDirective) app.use(LocalePlugin) 应用实例暴露的大多数方法都会返回该同一实例，允许链式： Vue.createApp({}) .component('SearchInput', SearchInputComponent) .directive('focus', FocusDirective) .use(LocalePlugin) 根组件与挂载 传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。 一个应用需要被挂载到一个 DOM 元素中。例如，如果你想把一个 Vue 应用挂载到 \u003cdiv id=\"app\"\u003e\u003c/div\u003e，应该传入 #app： const RootComponent = { /* 选项 */ } const app = Vue.createApp(RootComponent) const vm = app.mount('#app') mount 不返回应用本身，它返回的是根组件实例 大多数的真实应用都是被组织成一个嵌套的、可重用的组件树。举个例子，一个 todo 应用组件树可能是这样的： Root Component └─ TodoList ├─ TodoItem │ ├─ DeleteTodoButton │ └─ EditTodoButton └─ TodoListFooter ├─ ClearTodosButton └─ TodoListStatistics 组件实例 property 在 data 中定义的 property 是通过组件实例暴露的： const app = Vue.createApp({ data() { return { count: 4 } } }) const vm = app.mount('#app') console.log(vm.count) // =\u003e 4 有各种其他的组件选项，可以将用户定义的 property 添加到组件实例中，例如 methods，props，computed，inject 和 setup。组件实例的所有 property，无论如何定义，都可以在组件的模板中访问。 Vue 还通过组件实例暴露了一些内置 property，如 $attrs 和 $emit。这些 property 都有一个 $ 前缀，以避免与用户定义的 property 名冲突。 生命周期钩子 每个组件在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。 生命周期钩子的 this 上下文指向调用它的当前活动实例。 不要在选项 property 或回调上使用箭头函数，因为他们没有 this ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:2","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"模板语法 部分内容详见 Vue2 动态参数 也可以在指令参数中使用 JavaScript 表达式，方法是用方括号括起来： \u003c!-- 注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。 --\u003e \u003ca v-bind:[attributeName]=\"url\"\u003e ... \u003c/a\u003e 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。 例如，如果你的组件实例有一个 data property 为 attributeName，其值为 \"href\"，那么这个绑定将等价于 v-bind:href。 同样地，你可以使用动态参数为一个动态的事件名绑定处理函数： \u003ca v-on:[eventName]=\"doSomething\"\u003e ... \u003c/a\u003e 在这个示例中，当 eventName 的值为 \"focus\" 时，v-on:[eventName] 将等价于 v-on:focus 对动态参数表达式约定 动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 HTML attribute 名里是无效的。例如： \u003c!-- 这会触发一个编译警告 --\u003e \u003ca v-bind:['foo' + bar]=\"value\"\u003e ... \u003c/a\u003e 变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式。 在 DOM 中使用模板时 (直接在一个 HTML 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 attribute 名全部强制转为小写： \u003c!-- 在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。 除非在实例中有一个名为“someattr”的 property，否则代码不会工作。 --\u003e \u003ca v-bind:[someAttr]=\"value\"\u003e ... \u003c/a\u003e 修饰符 修饰符 (modifier) 是以半角句号 . 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： \u003cform v-on:submit.prevent=\"onSubmit\"\u003e...\u003c/form\u003e 在接下来对 v-on 和 v-for等功能的探索中，将会看到修饰符的其它例子 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:3","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"Data Property 组件的 data 选项是一个函数。Vue 会在创建新组件实例的过程中调用此函数。它应该返回一个对象，然后 Vue 会通过响应性系统将其包裹起来，并以 $data 的形式存储在组件实例中。为方便起见，该对象的任何顶级 property 也会直接通过组件实例暴露出来： const app = Vue.createApp({ data() { return { count: 4 } } }) const vm = app.mount('#app') console.log(vm.$data.count) // =\u003e 4 console.log(vm.count) // =\u003e 4 // 修改 vm.count 的值也会更新 $data.count vm.count = 5 console.log(vm.$data.count) // =\u003e 5 // 反之亦然 vm.$data.count = 6 console.log(vm.count) // =\u003e 6 直接将不包含在 data 中的新 property 添加到组件实例是可行的。但由于该 property 不在背后的响应式 $data 对象内，所以 Vue 的响应性系统不会自动跟踪它。 Vue 使用 $ 前缀通过组件实例暴露自己的内置 API。它还为内部 property 保留 _ 前缀。你应该避免使用这两个字符开头的的顶级 data property 名称 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:4","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"防抖和节流 Vue 没有内置支持防抖和节流，但可以使用 Lodash 等库来实现。 如果某个组件仅使用一次，可以在 methods 中直接应用防抖： \u003cscript src=\"https://unpkg.com/lodash@4.17.20/lodash.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e Vue.createApp({ methods: { // 用 Lodash 的防抖函数 click: _.debounce(function() { // ... 响应点击 ... }, 500) } }).mount('#app') \u003c/script\u003e 但是，这种方法对于可复用组件有潜在的问题，因为它们都共享相同的防抖函数。为了使组件实例彼此独立，可以在生命周期钩子的 created 里添加该防抖函数: app.component('save-button', { created() { // 用 Lodash 的防抖函数 this.debouncedClick = _.debounce(this.click, 500) }, unmounted() { // 移除组件时，取消定时器 this.debouncedClick.cancel() }, methods: { click() { // ... 响应点击 ... } }, template: ` \u003cbutton @click=\"debouncedClick\"\u003e Save \u003c/button\u003e ` }) ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:5","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"计算属性的 Setter 计算属性默认只有 getter，不过在需要时你也可以提供一个 setter： // ... computed: { fullName: { // getter get() { return this.firstName + ' ' + this.lastName }, // setter set(newValue) { const names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] } } } // ... 现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:6","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"侦听器 虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 例如： \u003cdiv id=\"watch-example\"\u003e \u003cp\u003e Ask a yes/no question: \u003cinput v-model=\"question\" /\u003e \u003c/p\u003e \u003cp\u003e{{ answer }}\u003c/p\u003e \u003c/div\u003e \u003c!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --\u003e \u003c!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e const watchExampleVM = Vue.createApp({ data() { return { question: '', answer: 'Questions usually contain a question mark. ;-)' } }, watch: { // whenever question changes, this function will run question(newQuestion, oldQuestion) { if (newQuestion.indexOf('?') \u003e -1) { this.getAnswer() } } }, methods: { getAnswer() { this.answer = 'Thinking...' axios .get('https://yesno.wtf/api') .then(response =\u003e { this.answer = response.data.answer }) .catch(error =\u003e { this.answer = 'Error! Could not reach the API. ' + error }) } } }).mount('#watch-example') \u003c/script\u003e 在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:7","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"计算属性 vs 侦听器 Vue 提供了一种更通用的方式来观察和响应当前活动的实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，watch 很容易被滥用——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子： \u003cdiv id=\"demo\"\u003e{{ fullName }}\u003c/div\u003e const vm = Vue.createApp({ data() { return { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' } }, watch: { firstName(val) { this.fullName = val + ' ' + this.lastName }, lastName(val) { this.fullName = this.firstName + ' ' + val } } }).mount('#demo') 上面代码是命令式且重复的。将它与计算属性的版本进行比较： const vm = Vue.createApp({ data() { return { firstName: 'Foo', lastName: 'Bar' } }, computed: { fullName() { return this.firstName + ' ' + this.lastName } } }).mount('#demo') 好很多了，不是吗？ ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:8","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"class 的对象语法 在模板里定义对象 我们可以传给 :class (v-bind:class 的简写) 一个对象，以动态地切换 class： \u003cdiv class=\"static\" :class=\"{ active: isActive, 'text-danger': hasError }\" \u003e\u003c/div\u003e data() { return { isActive: true, hasError: false } } 渲染的结果为： \u003cdiv class=\"static active\"\u003e\u003c/div\u003e 在 data 中定义对象 绑定的数据对象不必内联定义在模板里 \u003cdiv :class=\"classObject\"\u003e\u003c/div\u003e data() { return { classObject: { active: true, 'text-danger': false } } } 在计算属性里定义对象 我们也可以在这里绑定一个返回对象的计算属性。这是一个常用且强大的模式： \u003cdiv :class=\"classObject\"\u003e\u003c/div\u003e data() { return { isActive: true, error: null } }, computed: { classObject() { return { active: this.isActive \u0026\u0026 !this.error, 'text-danger': this.error \u0026\u0026 this.error.type === 'fatal' } } } style 也可以用： \u003cdiv :style=\"styleObject\"\u003e\u003c/div\u003e data() { return { styleObject: { color: 'red', fontSize: '13px' } } } 数组语法 我们也可以把一个数组传给 :class，以应用一个 class 列表： \u003cdiv :class=\"[activeClass, errorClass]\"\u003e\u003c/div\u003e data() { return { activeClass: 'active', errorClass: 'text-danger' } } 渲染的结果为： \u003cdiv class=\"active text-danger\"\u003e\u003c/div\u003e 如果你想根据条件切换列表中的 class，可以使用三元表达式： \u003cdiv :class=\"[isActive ? activeClass : '', errorClass]\"\u003e\u003c/div\u003e 这样写将始终添加 errorClass，但是只有在 isActive 为 truthy 时才添加 activeClass 不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法： \u003cdiv :class=\"[{ active: isActive }, errorClass]\"\u003e\u003c/div\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:9","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"关于 v-on 事件修饰符 Vue.js 为 v-on 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。 .stop .prevent .capture .self .once .passive \u003c!-- 阻止单击事件继续传播 --\u003e \u003ca @click.stop=\"doThis\"\u003e\u003c/a\u003e \u003c!-- 提交事件不再重载页面 --\u003e \u003cform @submit.prevent=\"onSubmit\"\u003e\u003c/form\u003e \u003c!-- 修饰符可以串联 --\u003e \u003ca @click.stop.prevent=\"doThat\"\u003e\u003c/a\u003e \u003c!-- 只有修饰符 --\u003e \u003cform @submit.prevent\u003e\u003c/form\u003e \u003c!-- 添加事件监听器时使用事件捕获模式 --\u003e \u003c!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --\u003e \u003cdiv @click.capture=\"doThis\"\u003e...\u003c/div\u003e \u003c!-- 只当在 event.target 是当前元素自身时触发处理函数 --\u003e \u003c!-- 即事件不是从内部元素触发的 --\u003e \u003cdiv @click.self=\"doThat\"\u003e...\u003c/div\u003e \u003c!-- 点击事件将只会触发一次 --\u003e \u003ca @click.once=\"doThis\"\u003e\u003c/a\u003e 按键修饰符 在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 v-on 或者 @ 在监听键盘事件时添加按键修饰符： \u003c!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --\u003e \u003cinput @keyup.enter=\"submit\" /\u003e 你可以直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。 \u003cinput @keyup.page-down=\"onPageDown\" /\u003e 在上述示例中，处理函数只会在 $event.key 等于 'PageDown' 时被调用。 按键别名 Vue 为最常用的键提供了别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 系统修饰键 可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta \u003c!-- Alt + Enter --\u003e \u003cinput @keyup.alt.enter=\"clear\" /\u003e \u003c!-- Ctrl + Click --\u003e \u003cdiv @click.ctrl=\"doSomething\"\u003eDo something\u003c/div\u003e .exact 修饰符 .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。 \u003c!-- 即使 Alt 或 Shift 被一同按下时也会触发 --\u003e \u003cbutton @click.ctrl=\"onClick\"\u003eA\u003c/button\u003e \u003c!-- 有且只有 Ctrl 被按下的时候才触发 --\u003e \u003cbutton @click.ctrl.exact=\"onCtrlClick\"\u003eA\u003c/button\u003e \u003c!-- 没有任何系统修饰符被按下的时候才触发 --\u003e \u003cbutton @click.exact=\"onClick\"\u003eA\u003c/button\u003e 鼠标按钮修饰符 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:10","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"关于 v-model 修饰符 .lazy 在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了输入法组织文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步： \u003c!-- 在“change”时而非“input”时更新 --\u003e \u003cinput v-model.lazy=\"msg\" /\u003e .number 如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符： \u003cinput v-model.number=\"age\" type=\"number\" /\u003e 这通常很有用，因为即使在 type=\"number\" 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。 .trim 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符： \u003cinput v-model.trim=\"msg\" /\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:2:11","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"Composition API ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:0","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"结构示例 optionAPI \u003ctemplate\u003e \u003cdiv\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { name: '', components: {}, props: {}, data() { return {} }, watch: {}, created() {}, mounted() {}, methods: {} } \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e\u003c/style\u003e CompositionAPI \u003ctemplate\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent, onMounted, reactive, UnwrapRef, watch } from 'vue'; interface State {} export default defineComponent({ name: 'components name', props: {}, setup(props) { console.log('props: ', props); //data const state: UnwrapRef\u003cState\u003e = reactive({}); //Lifecycle Hooks onMounted(() =\u003e {}); //watch watch( () =\u003e props, (_count, _prevCount) =\u003e {}, { deep: true, immediate: true, } ); //methods const getList = () =\u003e {}; return { state, getList }; }, }); \u003c/script\u003e \u003cstyle lang=\"scss\" scoped\u003e\u003c/style\u003e （组合式 API） 一些基础性的总结：https://juejin.cn/post/7008063765585330207 https://segmentfault.com/a/1190000040319089 https://www.jianshu.com/p/5996f611c990 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:1","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"setup setup 是一个组件选项，所以像别的组件选项一样，写在组件导出的对象里。 \u003cscript\u003e export default { name: \"App\", setup() { // ... return { // ... } }, } \u003c/script\u003e setup 选项应该为一个函数 setup 选项函数接受两个参数： props 和 context setup 选项函数需要返回要暴露给组件的内容 参数 props 正如在一个标准组件中所期望的那样，setup 函数中的 props 是响应式的，当传入新的 prop 时，它将被更新。 // MyBook.vue export default { props: { title: String }, setup(props) { console.log(props.title) } } 但是，因为 props 是响应式的，你不能使用 ES6 解构，因为它会消除 prop 的响应性。 如果需要解构 prop，可以通过使用 setup 函数中的 toRefs 来安全地完成此操作。 import { toRefs } from 'vue' setup(props) { const { title } = toRefs(props) console.log(title.value) } context context 上下文是一个普通的 JavaScript 对象，它暴露三个组件的 property： // MyBook.vue export default { setup(props, context) { // Attribute (非响应式对象) console.log(context.attrs) // 插槽 (非响应式对象) console.log(context.slots) // 触发事件 (方法) console.log(context.emit) } } context 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 context 使用 ES6 解构。 // MyBook.vue export default { setup(props, { attrs, slots, emit }) { ... } } attrs 和 slots 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 attrs.x 或 slots.x 的方式引用 property。请注意，与 props 不同，attrs 和 slots 是非响应式的。如果你打算根据 attrs 或 slots 更改应用副作用，那么应该在 onUpdated 生命周期钩子中执行此操作。 返回值 对象 如果 setup 返回一个对象，则可以在组件的模板中像传递给 setup 的 props property 一样访问该对象的 property： \u003c!-- MyBook.vue --\u003e \u003ctemplate\u003e \u003c!-- 模板中使用会被自动解开，所以不需要 .value --\u003e \u003cdiv\u003e{{ readersNumber }} {{ book.title }}\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { ref, reactive } from 'vue' export default { setup() { const readersNumber = ref(0) const book = reactive({ title: 'Vue 3 Guide' }) // expose to template return { readersNumber, book } } } \u003c/script\u003e 注意，从 setup 返回的 refs 在模板中访问时是被自动解开的，因此不应在模板中使用 .value。 渲染函数 setup 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态： // MyBook.vue import { h, ref, reactive } from 'vue' export default { setup() { const readersNumber = ref(0) const book = reactive({ title: 'Vue 3 Guide' }) // Please note that we need to explicitly expose ref value here return () =\u003e h('div', [readersNumber.value, book.title]) } } 新的 setup 组件选项在创建组件之前执行，一旦 props 被解析，并充当合成 API 的入口点。 不用 this 在 setup() 内部，this 不会是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆。 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:2","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"ref 与 reactive reactive 和 ref 都是用来定义响应式数据的 reactive 更推荐去定义复杂的数据类型，ref 更推荐定义基本类型 可以简单的理解为：ref 是对 reactive 的二次包装，ref 定义的数据访问的时候要多一个 .value toRefs API 提供了一个方法可以把 reactive 的值处理为 ref reactive reactive() 接收一个普通对象然后返回该普通对象的响应式代理。等同于 2.x 的 Vue.observable() const obj = reactive({ count: 0 }) 响应式转换是“深层的”：会影响对象内部所有嵌套的属性。基于 ES2015 的 Proxy 实现，返回的代理对象不等于原始对象。建议仅使用代理对象而避免依赖原始对象。 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e{ state.count }\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { reactive } from 'vue' export default { setup() { // state 现在是一个响应式的状态 const state = reactive({ count: 0, }) } } \u003c/script\u003e ref 接受一个参数值并返回一个响应式且可改变的 ref 对象。ref 对象拥有一个指向内部值的单一属性 .value const count = ref(0) console.log(count.value) // 0 count.value++ console.log(count.value) // 1 如果传入 ref 的是一个对象，将调用 reactive 方法进行深层响应转换。 模板中访问 当 ref 作为渲染上下文的属性返回（即在setup() 返回的对象中）并在模板中使用时，它会自动解套，无需在模板内额外书写 .value： \u003ctemplate\u003e \u003cdiv\u003e{{ count }}\u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default { setup() { return { count: ref(0), } }, } \u003c/script\u003e 作为响应式对象的属性访问 当 ref 作为 reactive 对象的 property 被访问或修改时，也将自动解套 value 值，其行为类似普通属性： const count = ref(0) const state = reactive({ count, }) console.log(state.count) // 0 state.count = 1 console.log(count.value) // 1 注意如果将一个新的 ref 分配给现有的 ref， 将替换旧的 ref： const otherCount = ref(2) state.count = otherCount console.log(state.count) // 2 console.log(count.value) // 1 注意当嵌套在 reactive Object 中时，ref 才会解套。从 Array 或者 Map 等原生集合类中访问 ref 时，不会自动解套： const arr = reactive([ref(0)]) // 这里需要 .value console.log(arr[0].value) const map = reactive(new Map([['foo', ref(0)]])) // 这里需要 .value console.log(map.get('foo').value) 类型定义 interface Ref\u003cT\u003e { value: T } function ref\u003cT\u003e(value: T): Ref\u003cT\u003e 有时我们可能需要为 ref 做一个较为复杂的类型标注。我们可以通过在调用 ref 时传递泛型参数来覆盖默认推导： const foo = ref\u003cstring | number\u003e('foo') // foo 的类型: Ref\u003cstring | number\u003e foo.value = 123 // 能够通过！ 例 \u003ctemplate\u003e \u003cdiv\u003e{{count}} \u003cbutton @click=\"changeCount\"\u003e添加\u003c/button\u003e \u003c/div\u003e \u003cdiv\u003e学生的姓名是:{{student.name}}\u003c/div\u003e \u003cdiv\u003e学生的年龄是:{{student.age}} \u003cbutton @click=\"changeStudentAge(20)\"\u003e添加\u003c/button\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent, ref, reactive } from 'vue'; export default defineComponent({ name: 'Home', setup () { const count = ref(0) const changeCount = () =\u003e { count.value = count.value + 1 } const student = reactive({ name: 'Bob', age: 12 }) const changeStudentAge = (age: number) =\u003e { student.age = age } return { count, changeCount, student, changeStudentAge } } }); \u003c/script\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:3","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"computed 使用响应式 computed API 有两种方式： 传入一个 getter 函数，返回一个默认不可手动修改的 ref 对象。 const count = ref(1) const plusOne = computed(() =\u003e count.value + 1) console.log(plusOne.value) // 2 plusOne.value++ // 错误！ 传入一个拥有 get 和 set 函数的对象，创建一个可手动修改的计算状态。 const count = ref(1) const plusOne = computed({ get: () =\u003e count.value + 1, set: (val) =\u003e { count.value = val - 1 }, }) plusOne.value = 1 console.log(count.value) // 0 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:4","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"watch 引入 watch， import { watch } from 'vue' 直接使用watch，watch 接受 3 个参数 要监听更新的响应式引用或者 getter 函数 一个回调用来做更新后的操作 可选配置项 setup() { const count = ref(0) //监听count watch( () = \u003e count, (_count, _prevCount) = \u003e {}, { deep: true, immediate: true } ); } \u003ctemplate\u003e \u003cdiv\u003e{{count}}\u003c/div\u003e \u003cdiv\u003e{{doubleCount}}\u003c/div\u003e \u003cbutton @click=\"addCount\"\u003e添加\u003c/button\u003e \u003c/template\u003e \u003cscript lang=\"ts\"\u003e import { defineComponent, ref, computed, watchEffect, watch } from 'vue'; export default defineComponent({ name: 'App', setup () { const count = ref(0) watch(count, (newValue, oldValue) =\u003e { // 如多个则用数组的方式传入[count, count1] console.log(`newValue为：${newValue},--------oldValue为：${oldValue}`) }) watchEffect(() =\u003e { console.log('watchEffect', count.value) }) const addCount = () =\u003e { count.value++ } const doubleCount = computed(() =\u003e { return count.value * 2 }) return { count, doubleCount, addCount } } }); \u003c/script\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:5","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"props/$emit 父子组件传值的写法 父组件 \u003cSearch @searchData=\"searchData\" :quaryParams=\"quaryParams\"/\u003e 父组件的写法和vue还是一样的，只是子组件需要作一些改变 子组件 \u003cscript lang=\"ts\"\u003e import { defineComponent } from 'vue'; interface GetUserListParams { pageNum: number; pageSize: number; roleName: string; } export default defineComponent({ name: 'Search', props: { quaryParams: { type: Object as PropType\u003cGetUserListParams\u003e , default: () = \u003e ({ pageNum: 1, pageSize: 10, roleName: '' }) } }, emits: ['searchData'],//需要声明emits setup(_props, context) { const onSubmit = () =\u003e { context.emit('searchData', \"我是子节点传递给父节点的值\"); } return { getData } } }); \u003c/script\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:6","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"跨组件传值 在 Vue 2 中，我们可以使用 Provide/Inject 跨组件传值，在 Vue 3 中也可以。 在 setup 中 使用，必须从 vue 中导入使用。 使用 Provide 时，一般设置为 响应式更新的，这样的话，父组件变更，子组件，子孙组件也跟着更新。 怎么设置为响应式更新呢？ 使用 ref / reactive 创建响应式变量 使用 provide('name', '要传递的响应式变量') 最后添加一个更新 响应式变量的事件，这样响应式变量更新， provide 中的变量也跟着更新 父组件 \u003ctemplate\u003e \u003cSon/\u003e \u003c/template\u003e \u003cscript\u003e import { provide, defineComponent, ref, reactive } from \"vue\"; export default defineComponent({ setup() { const father = ref(\"我父组件\"); const info = reactive({ id: 23, message: \"前端自学社区\", }); function changeProvide(){ info.message = '测试' } provide('father',father) provide('info',info) return {changeProvide}; } }) \u003c/script\u003e 子组件 \u003ctemplate\u003e \u003cdiv\u003e \u003ch1\u003e{{info.message}}\u003c/h1\u003e \u003ch1\u003e{{fatherData}}\u003c/h1\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import {provide, defineComponent,ref,reactive, inject} from 'vue' export default defineComponent({ setup () { const fatherData = inject('father') const info = inject('info') return {fatherData,info} } }) \u003c/script\u003e ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:7","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"模块化 往往是把一个功能的所有状态、方法、都封装到一个函数里面，方便统一管理 将相关功能提取到一个独立的组合式函数中 // src/composables/useUserRepositories.js import { fetchUserRepositories } from '@/api/repositories' import { ref, onMounted, watch } from 'vue' export default function useUserRepositories(user) { const repositories = ref([]) const getUserRepositories = async () =\u003e { repositories.value = await fetchUserRepositories(user.value) } onMounted(getUserRepositories) watch(user, getUserRepositories) return { repositories, getUserRepositories } } 当我们哪个功能需要再其他组件被复用的时候，直接把相关的方法提取出去，然后再引用进来就可以了 // src/components/UserRepositories.vue import { toRefs } from 'vue' import useUserRepositories from '@/composables/useUserRepositories' import useRepositoryNameSearch from '@/composables/useRepositoryNameSearch' import useRepositoryFilters from '@/composables/useRepositoryFilters' export default { components: { RepositoriesFilters, RepositoriesSortBy, RepositoriesList }, props: { user: { type: String, required: true } }, setup(props) { const { user } = toRefs(props) const { repositories, getUserRepositories } = useUserRepositories(user) const { searchQuery, repositoriesMatchingSearchQuery } = useRepositoryNameSearch(repositories) const { filters, updateFilters, filteredRepositories } = useRepositoryFilters(repositoriesMatchingSearchQuery) return { // 因为我们并不关心未经过滤的仓库 // 我们可以在 `repositories` 名称下暴露过滤后的结果 repositories: filteredRepositories, getUserRepositories, searchQuery, filters, updateFilters } } } ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:8","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"defineComponent 最主要的功能是为了 ts 下的类型推导 如果我们直接写 export default {} 这个时候，对于编辑器而言，{} 只是一个 Object 的类型，无法有针对性的提示我们对于 vue 组件来说 {} 里应该有哪些属性。但是增加一层 defineComponet 的话， export default defineComponent({}) 这时，{} 就变成了 defineComponent 的参数，那么对参数类型的提示，就可以实现对 {} 中属性的提示，外还可以进行对参数的一些类型推导等操作。 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:9","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"与 TS 的结合 接口约束约束属性 采用 TypeScirpt 的特性， 类型断言 + 接口 完美的对 属性进行了 约束 interface 分页查询 字段属性类型验证 export default interface queryType{ page: Number, size: Number, name: String, age: Number } 组件中使用 import queryType from '../interface/Home' data() { return { query:{ page:0, size:10, name:'测试', age: 2 } as queryType } }, 组件使用 defineComponent 来定义 这样 TypeScript 正确推断 Vue 组件选项中的类型 import { defineComponent } from 'vue' export default defineComponent({ setup(){ return{ } } }) 类型声明 reactive export default interface Product { name:String, price:Number, address:String } import Product from '@/interface/Product' import {reactive} from 'vue' const product = reactive({name:'xiaomi 11',price:5999,address:'北京'}) as Product return {fatherData,info,product} ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:10","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["前端"],"content":"setup script setup script 是 vue3 新出的一个语法糖，使用方法就是在书写 script 标签的时候在其后面加上一个 setup 修饰。 \u003cscript setup\u003e\u003c/script\u003e 自动注册子组件 普通语法 \u003ctemplate\u003e \u003cdiv\u003e \u003ch2\u003e我是父组件!\u003c/h2\u003e \u003cChild /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { defineComponent, ref } from 'vue'; import Child from './Child.vue' export default defineComponent({ components: { Child }, setup() { return { } } }); \u003c/script\u003e vue3 语法在引入 Child 组件后，需要在 components 中注册对应的组件才可使用。 setup script 写法 \u003ctemplate\u003e \u003cdiv\u003e \u003ch2\u003e我是父组件!-setup script\u003c/h2\u003e \u003cChild /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup\u003e import Child from './Child.vue' \u003c/script\u003e 属性和方法无需返回 \u003ctemplate\u003e \u003cdiv\u003e \u003ch2 @click=\"ageInc\"\u003e{{ name }} is {{ age }}\u003c/h2\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript setup\u003e import { ref } from 'vue'; const name = ref('CoCoyY1') const age = ref(18) const ageInc = () =\u003e { age.value++ } \u003c/script\u003e 支持 props、emit 和 context 普通语法 //Father.vue \u003ctemplate\u003e \u003cdiv \u003e \u003ch2 \u003e我是父组件！\u003c/h2\u003e \u003cChild msg=\"hello\" @child-click=\"childCtx\" /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e import { defineComponent, ref } from 'vue'; import Child from './Child.vue'; export default defineComponent({ components: { Child }, setup(props, context) { const childCtx = (ctx) =\u003e { console.log(ctx); } return { childCtx } } }) \u003c/script\u003e //Child.vue \u003ctemplate\u003e \u003cspan @click=\"handleClick\"\u003e我是子组件! -- msg: {{ props.msg }}\u003c/span\u003e \u003c/template\u003e \u003cscript\u003e import { defineComponent, ref } from 'vue' export default defineComponent({ emits: [ 'child-click' ], props: { msg: String }, setup(props, context) { const handleClick = () =\u003e { context.emit('child-click', context) } return { props, handleClick } }, }) \u003c/script\u003e setup script 语法 \u003cscript setup\u003e const props = defineProps({ foo: String }) const emit = defineEmits(['change', 'delete']) // setup code \u003c/script\u003e setup script 语法糖提供了三个新的 API 来供我们使用：defineProps、defineEmits和 useContext。 其中 defineProps 用来接收父组件传来的值 props。defineEmits 用来声明触发的事件表。useContext 用来获取组件上下文 context。 defineProps 和 defineEmits 都是只在 \u003cscript setup\u003e 中才能使用的编译器宏。他们不需要导入且会随着 \u003cscript setup\u003e 处理过程一同被编译掉。 defineProps 接收与 props 选项相同的值，defineEmits 也接收 emits 选项相同的值。 defineProps 和 defineEmits 在选项传入后，会提供恰当的类型推断。 技巧 ","date":"2021-12-22","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/:3:11","tags":["前端","快速入门","Vue"],"title":"Vue3","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue3/"},{"categories":["Golang"],"content":"filepath path/filepath 包涉及到路径操作时，路径分隔符使用 os.PathSeparator。 不同系统，路径表示方式有所不同，比如 Unix 和 Windows 差别很大。本包能够处理所有的文件路径，不管是什么系统。 路径操作函数并不会校验路径是否真实存在。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:0:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"解析路径名字符串 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:1:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"Dir Base Dir() 和 Base() 函数将一个路径名字符串分解成目录和文件名两部分。 func Dir(path string) string func Base(path string) string Dir 返回路径中除去最后一个路径元素的部分，即该路径最后一个元素所在的目录。 在使用 Split 去掉最后一个元素后，会简化路径并去掉末尾的斜杠。 如果路径是空字符串，会返回 “.\"； 如果路径由 1 到多个斜杠后跟 0 到多个非斜杠字符组成，会返回 “/\"； 其他任何情况下都不会返回以斜杠结尾的路径。 Base 函数返回路径的最后一个元素。 在提取元素前会去掉末尾的斜杠。 如果路径是 “\"，会返回 “.\"； 如果路径是只有一个斜杆构成的，会返回 “/\"。 比如，给定路径名 /home/polaris/studygolang.go，Dir 返回 /home/polaris，而 Base 返回 studygolang.go。 如果给定路径名 /home/polaris/studygolang/，Dir 返回 /home/polaris/studygolang（这与 Unix 中的 dirname 不一致，dirname 会返回 /home/polaris），而 Base 返回 studygolang。 有人提出此问题，不过官方认为这不是问题，如果需要和 dirname 一样的功能，应该自己处理，比如在调用 Dir 之前，先将末尾的 / 去掉。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:1:1","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"Ext 此外，Ext 可以获得路径中文件名的扩展名。 func Ext(path string) string Ext 函数返回 path 文件扩展名。扩展名是路径中最后一个从 . 开始的部分，包括 .。如果该元素没有 . 会返回空字符串。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:1:2","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"相对路径和绝对路径 某个进程都会有当前工作目录（进程相关章节会详细介绍），一般的相对路径，就是针对进程当前工作目录而言的。当然，可以针对某个目录指定相对路径。 绝对路径，在 Unix 中，以 / 开始；在 Windows 下以某个盘符开始，比如 C:\\Program Files。 func IsAbs(path string) bool IsAbs 返回路径是否是一个绝对路径。而 func Abs(path string) (string, error) Abs 函数返回 path 代表的绝对路径，如果 path 不是绝对路径，会加入当前工作目录以使之成为绝对路径。因为硬链接的存在，不能保证返回的绝对路径是唯一指向该地址的绝对路径。在 os.Getwd 出错时，Abs 会返回该错误，一般不会出错，如果路径名长度超过系统限制，则会报错。 func Rel(basepath, targpath string) (string, error) Rel 函数返回一个相对路径，将 basepath 和该路径用路径分隔符连起来的新路径在词法上等价于 targpath。也就是说，Join(basepath, Rel(basepath, targpath)) 等价于 targpath。如果成功执行，返回值总是相对于 basepath 的，即使 basepath 和 targpath 没有共享的路径元素。如果两个参数一个是相对路径而另一个是绝对路径，或者 targpath 无法表示为相对于 basepath 的路径，将返回错误。 fmt.Println(filepath.Rel(\"/home/polaris/studygolang\", \"/home/polaris/studygolang/src/logic/topic.go\")) fmt.Println(filepath.Rel(\"/home/polaris/studygolang\", \"/data/studygolang\")) // Output: // src/logic/topic.go \u003cnil\u003e // ../../../data/studygolang \u003cnil\u003e ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:2:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.3. 路径的切分和拼接 对于一个常规文件路径，我们可以通过 Split 函数得到它的目录路径和文件名： func Split(path string) (dir, file string) Split 函数根据最后一个路径分隔符将路径 path 分隔为目录和文件名两部分（dir 和 file）。如果路径中没有路径分隔符，函数返回值 dir 为空字符串，file 等于 path；反之，如果路径中最后一个字符是 /，则 dir 等于 path，file 为空字符串。返回值满足 path == dir+file。dir 非空时，最后一个字符总是 /。 // dir == /home/polaris/，file == studygolang filepath.Split(\"/home/polaris/studygolang\") // dir == /home/polaris/studygolang/，file == \"\" filepath.Split(\"/home/polaris/studygolang/\") // dir == \"\"，file == studygolang filepath.Split(\"studygolang\") 相对路径到绝对路径的转变，需要经过路径的拼接。Join 用于将多个路径拼接起来，会根据情况添加路径分隔符。 func Join(elem ...string) string Join 函数可以将任意数量的路径元素放入一个单一路径里，会根据需要添加路径分隔符。结果是经过 Clean 的，所有的空字符串元素会被忽略。对于拼接路径的需求，我们应该总是使用 Join 函数来处理。 有时，我们需要分割 PATH 或 GOPATH 之类的环境变量（这些路径被特定于 OS 的列表分隔符连接起来），filepath.SplitList 就是这个用途： func SplitList(path string) []string 注意，与 strings.Split 函数的不同之处是：对 “\"，SplitList 返回[]string{}，而 strings.Split 返回 []string{”\"}。SplitList 内部调用的是 strings.Split。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:3:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.4. 规整化路径 func Clean(path string) string Clean 函数通过单纯的词法操作返回和 path 代表同一地址的最短路径。 它会不断的依次应用如下的规则，直到不能再进行任何处理： 将连续的多个路径分隔符替换为单个路径分隔符 剔除每一个 . 路径名元素（代表当前目录） 剔除每一个路径内的 .. 路径名元素（代表父目录）和它前面的非 .. 路径名元素 剔除开始于根路径的 .. 路径名元素，即将路径开始处的 /.. 替换为 /（假设路径分隔符是 /） 返回的路径只有其代表一个根地址时才以路径分隔符结尾，如 Unix 的 / 或 Windows 的 C:\\。 如果处理的结果是空字符串，Clean 会返回 .，代表当前路径。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:4:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.5. 符号链接指向的路径名 在上一节 os 包中介绍了 Readlink，可以读取符号链接指向的路径名。不过，如果原路径中又包含符号链接，Readlink 却不会解析出来。filepath.EvalSymlinks 会将所有路径的符号链接都解析出来。除此之外，它返回的路径，是直接可访问的。 func EvalSymlinks(path string) (string, error) 如果 path 或返回值是相对路径，则是相对于进程当前工作目录。 os.Readlink 和 filepath.EvalSymlinks 区别示例程序： // 在当前目录下创建一个 studygolang.txt 文件和一个 symlink 目录，在 symlink 目录下对 studygolang.txt 建一个符号链接 studygolang.txt.2 fmt.Println(filepath.EvalSymlinks(\"symlink/studygolang.txt.2\")) fmt.Println(os.Readlink(\"symlink/studygolang.txt.2\")) // Ouput: // studygolang.txt \u003cnil\u003e // ../studygolang.txt \u003cnil\u003e ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:5:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.6. 文件路径匹配 func Match(pattern, name string) (matched bool, err error) Match 指示 name 是否和 shell 的文件模式匹配。模式语法如下： pattern: { term } term: '*' 匹配 0 或多个非路径分隔符的字符 '?' 匹配 1 个非路径分隔符的字符 '[' [ '^' ] { character-range } ']' 字符组（必须非空） c 匹配字符 c（c != '*', '?', '\\\\', '['） '\\\\' c 匹配字符 c character-range: c 匹配字符 c（c != '\\\\', '-', ']'） '\\\\' c 匹配字符 c lo '-' hi 匹配区间[lo, hi]内的字符 匹配要求 pattern 必须和 name 全匹配上，不只是子串。在 Windows 下转义字符被禁用。 Match 函数很少使用，搜索了一遍，标准库没有用到这个函数。而 Glob 函数在模板标准库中被用到了。 func Glob(pattern string) (matches []string, err error) Glob 函数返回所有匹配了 模式字符串 pattern 的文件列表或者 nil（如果没有匹配的文件）。pattern 的语法和 Match 函数相同。pattern 可以描述多层的名字，如 /usr/*/bin/ed（假设路径分隔符是 /）。 注意，Glob 会忽略任何文件系统相关的错误，如读目录引发的 I/O 错误。唯一的错误和 Match 一样，在 pattern 不合法时，返回 filepath.ErrBadPattern。返回的结果是根据文件名字典顺序进行了排序的。 Glob 的常见用法，是读取某个目录下所有的文件，比如写单元测试时，读取 testdata 目录下所有测试数据： filepath.Glob(\"testdata/*.input\") ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:6:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.7. 遍历目录 在介绍 os 时，讲解了读取目录的方法，并给出了一个遍历目录的示例。在 filepath 中，提供了 Walk 函数，用于遍历目录树。 func Walk(root string, walkFn WalkFunc) error Walk 函数会遍历 root 指定的目录下的文件树，对每一个该文件树中的目录和文件都会调用 walkFn，包括 root 自身。所有访问文件 / 目录时遇到的错误都会传递给 walkFn 过滤。文件是按字典顺序遍历的，这让输出更漂亮，但也导致处理非常大的目录时效率会降低。Walk 函数不会遍历文件树中的符号链接（快捷方式）文件包含的路径。 walkFn 的类型 WalkFunc 的定义如下： type WalkFunc func(path string, info os.FileInfo, err error) error Walk 函数对每一个文件 / 目录都会调用 WalkFunc 函数类型值。调用时 path 参数会包含 Walk 的 root 参数作为前缀；就是说，如果 Walk 函数的 root 为 “dir”，该目录下有文件 “a”，将会使用 “dir/a” 作为调用 walkFn 的参数。walkFn 参数被调用时的 info 参数是 path 指定的地址（文件 / 目录）的文件信息，类型为 os.FileInfo。 如果遍历 path 指定的文件或目录时出现了问题，传入的参数 err 会描述该问题，WalkFunc 类型函数可以决定如何去处理该错误（Walk 函数将不会深入该目录）；如果该函数返回一个错误，Walk 函数的执行会中止；只有一个例外，如果 Walk 的 walkFn 返回值是 SkipDir，将会跳过该目录的内容而 Walk 函数照常执行处理下一个文件。 和 os 遍历目录树的示例对应，使用 Walk 遍历目录树的示例程序在 walk，程序简单很多。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:7:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.8. Windows 起作用的函数 filepath 中有三个函数：VolumeName、FromSlash 和 ToSlash，针对非 Unix 平台的。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:8:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"1.9. 关于 path 包 path 包提供了对 / 分隔的路径的实用操作函数。 在 Unix 中，路径的分隔符是 /，但 Windows 是 \\。在使用 path 包时，应该总是使用 /，不论什么系统。 path 包中提供的函数，filepath 都有提供，功能类似，但实现不同。 一般应该总是使用 filepath 包，而不是 path 包。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/:9:0","tags":["Go 库"],"title":"Go filepath 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/filepath/"},{"categories":["Golang"],"content":"time time 包提供了时间的显示和测量用的函数。日历的计算采用的是公历。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:0:0","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"一些对象 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:1:0","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"时间类型 Time time.Time 代表一个纳秒精度的时间点。 程序中应使用 Time 类型值来保存和传递时间，而不是指针。就是说，表示时间的变量和字段，应为 time.Time 类型，而不是 *time.Time. 类型。 一个 Time 类型值可以被多个 go 协程同时使用。 时间点可以使用 Before、After 和 Equal 方法进行比较。Sub 方法让两个时间点相减，生成一个 Duration 类型值（代表时间段）。Add 方法给一个时间点加上一个时间段，生成一个新的 Time 类型时间点。 通过 == 比较 Time 时，Location 信息也会参与比较，因此 Time 不应该作为 map 的 key。 内部结构 type Time struct { // sec gives the number of seconds elapsed since // January 1, year 1 00:00:00 UTC. sec int64 // nsec specifies a non-negative nanosecond // offset within the second named by Seconds. // It must be in the range [0, 999999999]. nsec int32 // loc specifies the Location that should be used to // determine the minute, hour, month, day, and year // that correspond to this Time. // Only the zero Time has a nil Location. // In that case it is interpreted to mean UTC. loc *Location } time.Now() 我们可以通过 time.Now() 函数获取当前的时间对象，然后获取时间对象的年月日时分秒等信息。 // Now returns the current local time. func Now() Time { sec, nsec := now() return Time{sec + unixToInternal, nsec, Local} } now() 的具体实现在 runtime 包中，以 linux/amd64 为例，在 sys_linux_amd64.s 中的 time · now，这是汇编实现的 回到 time.Now() 的实现，现在我们得到了 sec 和 nsec，从 Time{sec + unixToInternal, nsec, Local} 这句可以看出，Time 结构的 sec 并非 Unix 时间戳，实际上，加上的 unixToInternal 是 1-1-1 到 1970-1-1 经历的秒数。也就是 Time 中的 sec 是从 1-1-1 算起的秒数，而不是 Unix 时间戳。 示例代码如下： func timeDemo() { now := time.Now() //获取当前时间 fmt.Printf(\"current time:%v\\n\", now) year := now.Year() //年 month := now.Month() //月 day := now.Day() //日 hour := now.Hour() //小时 minute := now.Minute() //分钟 second := now.Second() //秒 fmt.Printf(\"%d-%02d-%02d %02d:%02d:%02d\\n\", year, month, day, hour, minute, second) } ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:1:1","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"时间戳 时间戳是自 1970 年 1 月 1 日（08:00:00GMT）至当前时间的总毫秒数。它也被称为 Unix 时间戳（UnixTimestamp）。 time.Time.Unix() //得到 Unix 时间戳； time.Time.UnixNano() //得到 Unix 时间戳的纳秒表示； 基于时间对象获取时间戳的示例代码如下： func timestampDemo() { now := time.Now() //获取当前时间 timestamp1 := now.Unix() //时间戳 timestamp2 := now.UnixNano() //纳秒时间戳 fmt.Printf(\"current timestamp1:%v\\n\", timestamp1) fmt.Printf(\"current timestamp2:%v\\n\", timestamp2) } 使用 time.Unix() 函数可以将时间戳转为时间格式。 func timestampDemo2(timestamp int64) { timeObj := time.Unix(timestamp, 0) //将时间戳转为时间格式 fmt.Println(timeObj) } ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:1:2","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"时间间隔 Duration 对象 time.Duration 是 time 包定义的一个类型，它代表两个时间点之间经过的时间，以纳秒为单位。time.Duration 表示一段时间间隔，可表示的最长时间段大约 290 年。 time 包中定义的时间间隔类型的常量如下： const ( Nanosecond Duration = 1 Microsecond = 1000 * Nanosecond Millisecond = 1000 * Microsecond Second = 1000 * Millisecond Minute = 60 * Second Hour = 60 * Minute ) 例如：time.Duration 表示 1 纳秒，time.Second 表示 1 秒。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:1:3","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"时间操作 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:0","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"Add 我们在日常的编码过程中可能会遇到要求时间 + 时间间隔的需求，Go 语言的时间对象有提供 Add 方法如下： func (t Time) Add(d Duration) Time 举个例子，求一个小时之后的时间： func main() { now := time.Now() later := now.Add(time.Hour) // 当前时间加1小时后的时间 fmt.Println(later) } ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:1","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"Sub 求两个时间之间的差值： func (t Time) Sub(u Time) Duration 返回一个时间段 t-u。如果结果超出了 Duration 可以表示的最大值/最小值，将返回最大值/最小值。 要获取时间点 t-d（d 为 Duration），可以使用 t.Add(-d)。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:2","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"Equal func (t Time) Equal(u Time) bool 判断两个时间是否相同，会考虑时区的影响，因此不同时区标准的时间也可以正确比较。 本方法和用 t==u 不同，这种方法还会比较地点和时区信息。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:3","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"Before func (t Time) Before(u Time) bool 如果 t 代表的时间点在 u 之前，返回真；否则返回假。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:4","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"After func (t Time) After(u Time) bool 如果 t 代表的时间点在 u 之后，返回真；否则返回假。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:2:5","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"定时器 定时器是进程规划自己在未来某一时刻接获通知的一种机制 使用 time.Tick (时间间隔) 来设置定时器，定时器的本质上是一个通道（channel）。 func tickDemo() { ticker := time.Tick(time.Second) //定义一个1秒间隔的定时器 for i := range ticker { fmt.Println(i)//每秒都会执行的任务 } } ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:3:0","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"时间格式化 时间类型有一个自带的方法 Format 进行格式化，需要注意的是 Go 语言中格式化时间模板不是常见的 Y-m-d H:M:S，而是使用 Go 的诞生时间 2006 年 1月 2 号15 点 04 分（记忆口诀为 2006 1 2 3 4）。也许这就是技术人员的浪漫叭。 补充：如果想格式化为 12 小时方式，需指定 PM。 func formatDemo() { now := time.Now() // 格式化的模板为Go的出生时间2006年1月2号15点04分 Mon Jan // 24小时制 fmt.Println(now.Format(\"2006-01-02 15:04:05.000 Mon Jan\")) // 12小时制 fmt.Println(now.Format(\"2006-01-02 03:04:05.000 PM Mon Jan\")) fmt.Println(now.Format(\"2006/01/02 15:04\")) fmt.Println(now.Format(\"15:04 2006/01/02\")) fmt.Println(now.Format(\"2006/01/02\")) } ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:4:0","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"解析字符串格式的时间 time.Parse 和 time.ParseInLocation 被用来解析时间串 一般的，我们应该总是使用 time.ParseInLocation 来解析时间，并给第三个参数传递 time.Local now := time.Now() fmt.Println(now) // 加载时区 loc, err := time.LoadLocation(\"Asia/Shanghai\") if err != nil { fmt.Println(err) return } // 按照指定时区和指定格式解析字符串时间 timeObj, err := time.ParseInLocation(\"2006/01/02 15:04:05\", \"2019/08/04 14:15:20\", loc) if err != nil { fmt.Println(err) return } fmt.Println(timeObj) fmt.Println(timeObj.Sub(now)) ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:4:1","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"获取整点的 Time 实例 比如，有这么个需求：获取当前时间整点的 Time 实例。例如，当前时间是 15:54:23，需要的是 15:00:00。我们可以这么做： t, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", time.Now().Format(\"2006-01-02 15:00:00\"), time.Local) fmt.Println(t) 实际上，time 包给我们提供了专门的方法，功能更强大，性能也更好，这就是 Round 和 Trunate，它们区别，一个是取最接近的，一个是向下取整。 使用示例： t, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", \"2016-06-13 15:34:39\", time.Local) // 整点（向下取整） fmt.Println(t.Truncate(1 * time.Hour)) // 整点（最接近） fmt.Println(t.Round(1 * time.Hour)) // 整分（向下取整） fmt.Println(t.Truncate(1 * time.Minute)) // 整分（最接近） fmt.Println(t.Round(1 * time.Minute)) t2, _ := time.ParseInLocation(\"2006-01-02 15:04:05\", t.Format(\"2006-01-02 15:00:00\"), time.Local) fmt.Println(t2) ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:4:2","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"时区 不同国家（有时甚至是同一个国家内的不同地区）使用不同的时区。对于要输入和输出时间的程序来说，必须对系统所处的时区加以考虑。Go 语言使用 Location 来表示地区相关的时区，一个 Location 可能表示多个时区。 time 包提供了 Location 的两个实例：Local 和 UTC。Local 代表当前系统本地时区；UTC 代表通用协调时间，也就是零时区。time 包默认（为显示提供时区）使用 UTC 时区。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:5:0","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"Local 如何表示本地时区？ 时区信息既浩繁又多变，Unix 系统以标准格式存于文件中，这些文件位于 /usr/share/zoneinfo，而本地时区可以通过 /etc/localtime 获取，这是一个符号链接，指向 /usr/share/zoneinfo 中某一个时区。如：/usr/share/zoneinfo/Asia/Shanghai。 因此，在初始化 Local 时，通过读取 /etc/localtime 可以获取到系统本地时区。 当然，如果设置了环境变量 TZ，则会优先使用它。 相关代码： tz, ok := syscall.Getenv(\"TZ\") switch { case !ok: z, err := loadZoneFile(\"\", \"/etc/localtime\") if err == nil { localLoc = *z localLoc.name = \"Local\" return } case tz != \"\" \u0026\u0026 tz != \"UTC\": if z, err := loadLocation(tz); err == nil { localLoc = *z return } } ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:5:1","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"获得特定时区的实例 函数 LoadLocation 可以根据名称获取特定时区的实例。 函数声明如下： func LoadLocation(name string) (*Location, error) 如果 name 是 \"\" 或 “UTC”，返回 UTC；如果 name 是 “Local”，返回 Local；否则 name 应该是 IANA 时区数据库里有记录的地点名（该数据库记录了地点和对应的时区），如 “America/New_York”。 LoadLocation 函数需要的时区数据库可能不是所有系统都提供，特别是非 Unix 系统。此时 LoadLocation 会查找环境变量 ZONEINFO 指定目录或解压该变量指定的 zip 文件（如果有该环境变量）；然后查找 Unix 系统的惯例时区数据安装位置，最后查找 $GOROOT/lib/time/zoneinfo.zip。 可以在 Unix 系统下的 /usr/share/zoneinfo 中找到所有的名称。 通常，我们使用 time.Local 即可，偶尔可能会需要使用 UTC。在解析时间时，心中一定记得有时区这么回事。当你发现时间出现莫名的情况时，很可能是因为时区的问题，特别是当时间相差 8 小时时。 ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:5:2","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"其他方法 time.Sleep() func Sleep(d Duration) 例： // Calling Sleep method time.Sleep(8 * time.Second) // Printed after sleep is over fmt.Println(\"Sleep Over.....\") ","date":"2021-12-16","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/:5:3","tags":["Go 库"],"title":"Go time 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/time/"},{"categories":["Golang"],"content":"bytes 该包定义了一些操作 byte slice 的便利操作。 因为字符串可以表示为 []byte，所以 bytes 包定义的函数、方法等和 strings 包很类似 为了方便，会称呼 []byte 为 字节数组 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/:0:0","tags":["Go 库"],"title":"Go bytes 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/"},{"categories":["Golang"],"content":"是否存在某个子 slice // 子 slice subslice 在 b 中，返回 true func Contains(b, subslice []byte) bool 该函数的内部调用了 bytes.Index 函数 func Contains(b, subslice []byte) bool { return Index(b, subslice) != -1 } 题外：对比 strings.Contains 会发现，一个判断 \u003e=0，一个判断 != -1，可见库不是一个人写的，没有做到一致性。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/:1:0","tags":["Go 库"],"title":"Go bytes 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/"},{"categories":["Golang"],"content":"[]byte 出现次数 // slice sep 在 s 中出现的次数（无重叠） func Count(s, sep []byte) int 和 strings 实现不同，此包中的 Count 核心代码如下： count := 0 c := sep[0] i := 0 t := s[:len(s)-n+1] for i \u003c len(t) { // 判断 sep 第一个字节是否在 t[i:] 中 // 如果在，则比较之后相应的字节 if t[i] != c { o := IndexByte(t[i:], c) if o \u003c 0 { break } i += o } // 执行到这里表示 sep[0] == t[i] if n == 1 || Equal(s[i:i+n], sep) { count++ i += n continue } i++ } ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/:2:0","tags":["Go 库"],"title":"Go bytes 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/"},{"categories":["Golang"],"content":"Runes 类型转换 // 将 []byte 转换为 []rune func Runes(s []byte) []rune 该函数将 []byte 转换为 []rune ，适用于汉字等多字节字符，示例： b:=[]byte(\"你好，世界\") for k,v:=range b{ fmt.Printf(\"%d:%s |\",k,string(v)) } r:=bytes.Runes(b) for k,v:=range r{ fmt.Printf(\"%d:%s|\",k,string(v)) } 运行结果： 0:ä |1:½ |2: |3:å |4:¥ |5:½ |6:ï |7:¼ |8: |9:ä |10:¸ |11: |12:ç |13: |14: | 0:你|1:好|2:，|3:世|4:界| ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/:3:0","tags":["Go 库"],"title":"Go bytes 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/bytes/"},{"categories":["Golang"],"content":"container 该包实现了三个复杂的数据结构：堆，链表，环。 这个包就意味着你使用这三个数据结构的时候不需要再费心从头开始写算法了。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/:0:0","tags":["Go 库"],"title":"Go container 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/"},{"categories":["Golang"],"content":"堆 这里的堆使用的数据结构是最小二叉树，即根节点比左边子树和右边子树的所有值都小。 go 的堆包只是实现了一个接口，我们看下它的定义： type Interface interface { sort.Interface Push(x interface{}) // add x as element Len() Pop() interface{} // remove and return element Len() - 1. } 可以看出，这个堆结构继承自 sort.Interface, 回顾下 sort.Interface，它需要实现三个方法 Len() int Less(i, j int) bool Swap(i, j int) 加上堆接口定义的两个方法 Push(x interface{}) Pop() interface{} 就是说你定义了一个堆，就要实现五个方法，直接拿 package doc 中的 example 做例子： type IntHeap []int func (h IntHeap) Len() int { return len(h) } func (h IntHeap) Less(i, j int) bool { return h[i] \u003c h[j] } func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] } func (h *IntHeap) Push(x interface{}) { *h = append(*h, x.(int)) } func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x } 那么 IntHeap 就实现了这个堆结构，我们就可以使用堆的方法来对它进行操作： h := \u0026IntHeap{2, 1, 5} heap.Init(h) heap.Push(h, 3) heap.Pop(h) 具体说下内部实现，是使用最小堆，索引排序从根节点开始，然后左子树，右子树的顺序方式。索引布局如下： 0 1 2 3 4 5 6 7 8 9 10 11 假设 (heap[1]== 小明 ) 它的左子树 (heap[3]== 小黑 ) 和右子树 (heap[4]== 大黄 ) 且 小明 \u003e 小黑 \u003e 大黄 ; 堆内部实现了 down 和 up 函数 down 函数用于将索引 i 处存储的值 ( 设 i=1, 即小明 ) 与它的左子树 ( 小黑 ) 和右子树 ( 大黄 ) 相比 , 将三者最小的值大黄与小明的位置交换，交换后小明继续与交换后的子树 (heap[9]和 heap[10]) 相比，重复以上步骤，直到小明位置不变。 up 函数用于将索引 i 处的值 ( 设 i=3, 即小黑 ) 与他的父节点 ( 小明 ) 比较，将两者较小的值放到父节点上，本例中即交换小黑和小明的位置，之后小黑继续与其父节点比较，重复以上步骤，直到小黑位置不变。 假设 heap[11]== 阿花 当从堆中 Pop 一个元素的时候，先把元素和最后一个节点的值 ( 阿花 ) 交换，然后弹出，然后对阿花调用 down，向下保证最小堆。 当往堆中 Push 一个元素的时候，这个元素插入到最后一个节点，本例中为 heap[12]，即作为 heap[5]的右子树，然后调用 up 函数向上比较。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/:1:0","tags":["Go 库"],"title":"Go container 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/"},{"categories":["Golang"],"content":"链表 链表就是一个有 prev 和 next 指针的数组了。它维护两个 type，( 注意，这里不是 interface) type Element struct { next, prev *Element // 上一个元素和下一个元素 list *List // 元素所在链表 Value interface{} // 元素 } type List struct { root Element // 链表的根元素 len int // 链表的长度 } 基本使用是先创建 list，然后往 list 中插入值，list 就内部创建一个 Element，并内部设置好 Element 的 next, prev 等。具体可以看下例子： // This example demonstrates an integer heap built using the heap interface. package main import ( \"container/list\" \"fmt\" ) func main() { list := list.New() list.PushBack(1) list.PushBack(2) fmt.Printf(\"len: %v\\n\", list.Len()) fmt.Printf(\"first: %#v\\n\", list.Front()) fmt.Printf(\"second: %#v\\n\", list.Front().Next()) } output: len: 2 first: \u0026list.Element{next:(*list.Element)(0x2081be1b0), prev:(*list.Element)(0x2081be150), list:(*list.List)(0x2081be150), Value:1} second: \u0026list.Element{next:(*list.Element)(0x2081be150), prev:(*list.Element)(0x2081be180), list:(*list.List)(0x2081be150), Value:2} list 对应的方法有： type Element func (e *Element) Next() *Element func (e *Element) Prev() *Element type List func New() *List func (l *List) Back() *Element // 最后一个元素 func (l *List) Front() *Element // 第一个元素 func (l *List) Init() *List // 链表初始化 func (l *List) InsertAfter(v interface{}, mark *Element) *Element // 在某个元素后插入 func (l *List) InsertBefore(v interface{}, mark *Element) *Element // 在某个元素前插入 func (l *List) Len() int // 在链表长度 func (l *List) MoveAfter(e, mark *Element) // 把 e 元素移动到 mark 之后 func (l *List) MoveBefore(e, mark *Element) // 把 e 元素移动到 mark 之前 func (l *List) MoveToBack(e *Element) // 把 e 元素移动到队列最后 func (l *List) MoveToFront(e *Element) // 把 e 元素移动到队列最头部 func (l *List) PushBack(v interface{}) *Element // 在队列最后插入元素 func (l *List) PushBackList(other *List) // 在队列最后插入接上新队列 func (l *List) PushFront(v interface{}) *Element // 在队列头部插入元素 func (l *List) PushFrontList(other *List) // 在队列头部插入接上新队列 func (l *List) Remove(e *Element) interface{} // 删除某个元素 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/:2:0","tags":["Go 库"],"title":"Go container 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/"},{"categories":["Golang"],"content":"环 环的结构有点特殊，环的尾部就是头部，所以每个元素实际上就可以代表自身的这个环。 它不需要像 list 一样保持 list 和 element 两个结构，只需要保持一个结构就行。 type Ring struct { next, prev *Ring Value interface{} } 我们初始化环的时候，需要定义好环的大小，然后对环的每个元素进行赋值。环还提供一个 Do 方法，能遍历一遍环，对每个元素执行一个 function。 看下面的例子： // This example demonstrates an integer heap built using the heap interface. package main import ( \"container/ring\" \"fmt\" ) func main() { ring := ring.New(3) for i := 1; i \u003c= 3; i++ { ring.Value = i ring = ring.Next() } // 计算 1+2+3 s := 0 ring.Do(func(p interface{}){ s += p.(int) }) fmt.Println(\"sum is\", s) } output: sum is 6 ring 提供的方法有 type Ring func New(n int) *Ring // 初始化环 func (r *Ring) Do(f func(interface{})) // 循环环进行操作 func (r *Ring) Len() int // 环长度 func (r *Ring) Link(s *Ring) *Ring // 连接两个环 func (r *Ring) Move(n int) *Ring // 指针从当前元素开始向后移动或者向前（n 可以为负数） func (r *Ring) Next() *Ring // 当前元素的下个元素 func (r *Ring) Prev() *Ring // 当前元素的上个元素 func (r *Ring) Unlink(n int) *Ring // 从当前元素开始，删除 n 个元素 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/:3:0","tags":["Go 库"],"title":"Go container 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/container/"},{"categories":["Golang"],"content":"strconv 这个包实现了字符串和基本数据类型之间转换 这里的基本数据类型包括：布尔、整型（包括有 / 无符号、二进制、八进制、十进制和十六进制）和浮点型等。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:0:0","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"strconv 包转换错误处理 介绍具体的转换之前，先看看 strconv 中的错误处理。 由于将字符串转为其他数据类型可能会出错，strconv 包定义了两个 error 类型的变量：ErrRange 和 ErrSyntax。其中，ErrRange 表示值超过了类型能表示的最大范围，比如将 “128” 转为 int8 就会返回这个错误；ErrSyntax 表示语法错误，比如将 \"\" 转为 int 类型会返回这个错误。 然而，在返回错误的时候，不是直接将上面的变量值返回，而是通过构造一个 NumError 类型的 error 对象返回。NumError 结构的定义如下： // A NumError records a failed conversion. type NumError struct { Func string // the failing function (ParseBool, ParseInt, ParseUint, ParseFloat) Num string // the input Err error // the reason the conversion failed (ErrRange, ErrSyntax) } 可见，该结构记录了转换过程中发生的错误信息。该结构不仅包含了一个 error 类型的成员，记录具体的错误信息，而且它自己也实现了 error 接口： func (e *NumError) Error() string { return \"strconv.\" + e.Func + \": \" + \"parsing \" + Quote(e.Num) + \": \" + e.Err.Error() } 包的实现中，定义了两个便捷函数，用于构造 NumError 对象： func syntaxError(fn, str string) *NumError { return \u0026NumError{fn, str, ErrSyntax} } func rangeError(fn, str string) *NumError { return \u0026NumError{fn, str, ErrRange} } 在遇到 ErrSyntax 或 ErrRange 错误时，通过上面的函数构造 NumError 对象。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:1:0","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"字符串和整型之间的转换 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:2:0","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"字符串转为整型 包括三个函数：ParseInt、ParseUint 和 Atoi，函数原型如下： // 转为有符号整型 func ParseInt(s string, base int, bitSize int) (i int64, err error) // 转为无符号整型 func ParseUint(s string, base int, bitSize int) (n uint64, err error) // 是 ParseInt 的便捷版，内部通过调用 *ParseInt(s, 10, 0)* 来实现的 func Atoi(s string) (i int, err error) 着重介绍 ParseInt。 参数 base 代表字符串按照给定的进制进行解释。 一般的，base 的取值为 2~36 如果 base 的值为 0，则会根据字符串的前缀来确定 base 的值：“0x” 表示 16 进制； “0” 表示 8 进制；否则就是 10 进制。 参数 bitSize 表示的是整数取值范围，或者说整数的具体类型。取值 0、8、16、32 和 64 分别代表 int、int8、int16、int32 和 int64。 当 bitSize==0 时的情况 这里有必要说一下，当 bitSize==0 时的情况。 Go 中，int/uint 类型，不同系统能表示的范围是不一样的，目前的实现是，32 位系统占 4 个字节；64 位系统占 8 个字节。当 bitSize==0 时，应该表示 32 位还是 64 位呢？这里没有利用 runtime.GOARCH 之类的方式，而是巧妙的通过如下表达式确定 intSize： const intSize = 32 \u003c\u003c uint(^uint(0)\u003e\u003e63) const IntSize = intSize // number of bits in int, uint (32 or 64) 主要是 ^uint(0)»63 这个表达式。操作符 ^ 在这里是一元操作符 按位取反，而不是 按位异或。更多解释可以参考：Go 位运算：取反和异或。 超出 bitSize 的表示范围 问题：下面的代码 n 和 err 的值分别是什么？ n, err := strconv.ParseInt(\"128\", 10, 8) 在 ParseInt/ParseUint 的实现中，如果字符串表示的整数超过了 bitSize 参数能够表示的范围，则会返回 ErrRange，同时会返回 bitSize 能够表示的最大或最小值。因此，这里的 n 是 127。 另外，ParseInt 返回的是 int64，这是为了能够容纳所有的整型，在实际使用中，可以根据传递的 bitSize，然后将结果转为实际需要的类型。 转换的基本原理（以 “128” 转 为 10 进制 int 为例）： s := \"128\" n := 0 for i := 0; i \u003c len(s); i++ { n *= 10 + s[i] // base } 在循环处理的过程中，会检查数据的有效性和是否越界等。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:2:1","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"整型转为字符串 实际应用中，我们经常会遇到需要将字符串和整型连接起来，在 Java 中，可以通过操作符 “+” 做到。不过，在 Go 语言中，你需要将整型转为字符串类型，然后才能进行连接。 这个时候，strconv 包中的整型转字符串的相关函数就派上用场了。这些函数签名如下： // 无符号整型转字符串 func FormatUint(i uint64, base int) string // 有符号整型转字符串 func FormatInt(i int64, base int) string // Itoa内部直接调用FormatInt(i, 10)实现 func Itoa(i int) string 其中，base 参数可以取 2~36（0-9，a-z）。 标准库还提供了另外两个函数：AppendInt 和 AppendUint，这两个函数不是将整数转为字符串，而是将整数转为字符数组 append 到目标字符数组中。（最终，我们也可以通过返回的 []byte 得到字符串） 除了使用上述方法将整数转为字符串外，经常见到有人使用 fmt 包来做这件事。如： fmt.Sprintf(\"%d\", 127) 那么，这两种方式我们该怎么选择呢？我们主要来考察一下性能。 startTime := time.Now() for i := 0; i \u003c 10000; i++ { fmt.Sprintf(\"%d\", i) } fmt.Println(time.Now().Sub(startTime)) startTime := time.Now() for i := 0; i \u003c 10000; i++ { strconv.Itoa(i) } fmt.Println(time.Now().Sub(startTime)) 我们分别循环转换了 10000 次。Sprintf 的时间是 3.549761ms，而 Itoa 的时间是 848.208us，相差 4 倍多。 Sprintf 性能差些可以预见，因为它接收的是 interface，需要进行反射等操作。个人建议使用 strconv 包中的方法进行转换。 注意：别想着通过 string(65) 这种方式将整数转为字符串，这样实际上得到的会是 ASCCII 值为 65 的字符，即 ‘A’。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:2:2","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"字符串和布尔值之间的转换 Go 中字符串和布尔值之间的转换比较简单，主要有三个函数： // 接受 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False 等字符串； // 其他形式的字符串会返回错误 func ParseBool(str string) (value bool, err error) // 直接返回 \"true\" 或 \"false\" func FormatBool(b bool) string // 将 \"true\" 或 \"false\" append 到 dst 中 // 这里用了一个 append 函数对于字符串的特殊形式：append(dst, \"true\"...) func AppendBool(dst []byte, b bool) ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:3:0","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"字符串和浮点数之间的转换 类似的，包含三个函数： func ParseFloat(s string, bitSize int) (f float64, err error) func FormatFloat(f float64, fmt byte, prec, bitSize int) string func AppendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) 函数的命名和作用跟上面讲解的其他类型一致。 关于 FormatFloat 的 fmt 参数， 在格式化 IO 中有详细介绍。而 prec 表示有效数字（对 fmt=‘b’ 无效），对于 ’e’, ‘E’ 和 ‘f’，有效数字用于小数点之后的位数；对于 ‘g’ 和 ‘G’，则是所有的有效数字。例如： strconv.FormatFloat(1223.13252, 'e', 3, 32) // 结果：1.223e+03 strconv.FormatFloat(1223.13252, 'g', 3, 32) // 结果：1.22e+03 由于浮点数有精度的问题，精度不一样，ParseFloat 和 FormatFloat 可能达不到互逆的效果。如： s := strconv.FormatFloat(1234.5678, 'g', 6, 64) strconv.ParseFloat(s, 64) 另外，fmt=‘b’ 时，得到的字符串是无法通过 ParseFloat 还原的。 特别地（不区分大小写），+inf/inf，+infinity/infinity，-inf/-infinity 和 nan 通过 ParseFloat 转换分别返回对应的值（在 math 包中定义）。 同样的，基于性能的考虑，应该使用 FormatFloat 而不是 fmt.Sprintf。 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:4:0","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"其他导出的函数 如果要输出这样一句话：This is “studygolang.com” website. 该如何做？ So easy: fmt.Println(`This is \"studygolang.com\" website`) 如果没有 `` 符号，该怎么做？转义： fmt.Println(\"This is \\\"studygolang.com\\\" website\") 除了这两种方法，strconv 包还提供了函数这做件事（Quote 函数）。我们称 “studygolang.com” 这种用双引号引起来的字符串为 Go 语言字面值字符串（Go string literal）。 上面的一句话可以这么做： fmt.Println(\"This is\", strconv.Quote(\"studygolang.com\"), \"website\") ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/:5:0","tags":["Go 库"],"title":"Go strconv 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/strconv/"},{"categories":["Golang"],"content":"unicode 由于 UTF-8 的作者 Ken Thompson 同时也是 go 语言的创始人，所以说，在字符支持方面，几乎没有语言的理解会高于 go 了。 go 对 unicode 的支持包含三个包 : unicode unicode/utf8 unicode/utf16 unicode 包包含基本的字符判断函数。utf8 包主要负责 rune 和 byte 之间的转换。utf16 包负责 rune 和 uint16 数组之间的转换。 由于字符的概念有的时候比较模糊，比如字符（小写 a）普通显示为 a，在重音字符中（grave-accented）中显示为à。 这时候字符（character）的概念就有点不准确了，因为 a 和à显然是两个不同的 unicode 编码，但是却代表同一个字符，所以引入了 rune。 一个 rune 就代表一个 unicode 编码，所以上面的 a 和à是两个不同的 rune。 go 语言的所有代码都是 UTF8 的，所以如果我们在程序中的字符串都是 utf8 编码的，但是我们的单个字符（单引号扩起来的）却是 unicode 的 ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/:0:0","tags":["Go 库"],"title":"Go Unicode 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/"},{"categories":["Golang"],"content":"unicode 包 unicode 包含了对 rune 的判断。这个包把所有 unicode 涉及到的编码进行了分类，使用结构 type RangeTable struct { R16 []Range16 R32 []Range32 LatinOffset int } 来表示这个功能的字符集。这些字符集都集中列表在 table.go 这个源码里面。 比如控制字符集： var _Pc = \u0026RangeTable{ R16: []Range16{ {0x005f, 0x203f, 8160}, {0x2040, 0x2054, 20}, {0xfe33, 0xfe34, 1}, {0xfe4d, 0xfe4f, 1}, {0xff3f, 0xff3f, 1}, }, } 比如对国内开发者很实用的汉字字符集： var _Han = \u0026RangeTable{ R16: []Range16{ {0x2e80, 0x2e99, 1}, {0x2e9b, 0x2ef3, 1}, {0x2f00, 0x2fd5, 1}, {0x3005, 0x3005, 1}, {0x3007, 0x3007, 1}, {0x3021, 0x3029, 1}, {0x3038, 0x303b, 1}, {0x3400, 0x4db5, 1}, {0x4e00, 0x9fea, 1}, {0xf900, 0xfa6d, 1}, {0xfa70, 0xfad9, 1}, }, R32: []Range32{ {0x20000, 0x2a6d6, 1}, {0x2a700, 0x2b734, 1}, {0x2b740, 0x2b81d, 1}, {0x2b820, 0x2cea1, 1}, {0x2ceb0, 0x2ebe0, 1}, {0x2f800, 0x2fa1d, 1}, }, } 回到包的函数，我们看到有下面这些判断函数： func IsControl(r rune) bool // 是否控制字符 func IsDigit(r rune) bool // 是否阿拉伯数字字符，即 0-9 func IsGraphic(r rune) bool // 是否图形字符 func IsLetter(r rune) bool // 是否字母 func IsLower(r rune) bool // 是否小写字符 func IsMark(r rune) bool // 是否符号字符 func IsNumber(r rune) bool // 是否数字字符，比如罗马数字Ⅷ也是数字字符 func IsOneOf(ranges []*RangeTable, r rune) bool // 是否是 RangeTable 中的一个 func IsPrint(r rune) bool // 是否可打印字符 func IsPunct(r rune) bool // 是否标点符号 func IsSpace(r rune) bool // 是否空格 func IsSymbol(r rune) bool // 是否符号字符 func IsTitle(r rune) bool // 是否 title case func IsUpper(r rune) bool // 是否大写字符 func Is(rangeTab *RangeTable, r rune) bool // r 是否为 rangeTab 类型的字符 func In(r rune, ranges ...*RangeTable) bool // r 是否为 ranges 中任意一个类型的字符 看下面这个例子： func main() { single := '\\u0015' fmt.Println(unicode.IsControl(single)) single = '\\ufe35' fmt.Println(unicode.IsControl(single)) digit := '1' fmt.Println(unicode.IsDigit(digit)) fmt.Println(unicode.IsNumber(digit)) letter := 'Ⅷ' fmt.Println(unicode.IsDigit(letter)) fmt.Println(unicode.IsNumber(letter)) han:='你' fmt.Println(unicode.IsDigit(han)) fmt.Println(unicode.Is(unicode.Han,han)) fmt.Println(unicode.In(han,unicode.Gujarati,unicode.White_Space)) } 输出结果： true false true true false true false true false ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/:1:0","tags":["Go 库"],"title":"Go Unicode 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/"},{"categories":["Golang"],"content":"utf8 包 utf8 里面的函数就有一些字节和字符的转换。 判断是否符合 utf8 编码的函数： func Valid(p []byte) bool func ValidRune(r rune) bool func ValidString(s string) bool 判断 rune 所占字节数： func RuneLen(r rune) int 判断字节串或者字符串的 rune 数： func RuneCount(p []byte) int func RuneCountInString(s string) (n int) 编码和解码到 rune： func EncodeRune(p []byte, r rune) int func DecodeRune(p []byte) (r rune, size int) func DecodeRuneInString(s string) (r rune, size int) func DecodeLastRune(p []byte) (r rune, size int) func DecodeLastRuneInString(s string) (r rune, size int) 是否为完整 rune： func FullRune(p []byte) bool func FullRuneInString(s string) bool 是否为 rune 第一个字节： func RuneStart(b byte) bool 示例： word:=[]byte(\"界\") fmt.Println(utf8.Valid(word[:2])) fmt.Println(utf8.ValidRune('界')) fmt.Println(utf8.ValidString(\"世界\")) fmt.Println(utf8.RuneLen('界')) fmt.Println(utf8.RuneCount(word)) fmt.Println(utf8.RuneCountInString(\"世界\")) p:=make([]byte,3) utf8.EncodeRune(p,'好') fmt.Println(p) fmt.Println(utf8.DecodeRune(p)) fmt.Println(utf8.DecodeRuneInString(\"你好\")) fmt.Println(utf8.DecodeLastRune([]byte(\"你好\"))) fmt.Println(utf8.DecodeLastRuneInString(\"你好\")) fmt.Println(utf8.FullRune(word[:2])) fmt.Println(utf8.FullRuneInString(\"你好\")) fmt.Println(utf8.RuneStart(word[1])) fmt.Println(utf8.RuneStart(word[0])) 运行结果： false true true 3 1 2 [229 165 189] 22909 3 20320 3 22909 3 22909 3 false true false true ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/:2:0","tags":["Go 库"],"title":"Go Unicode 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/"},{"categories":["Golang"],"content":"utf16 包 utf16 的包的函数就比较少了。 将 uint16 和 rune 进行转换 func Encode(s []rune) []uint16 func EncodeRune(r rune) (r1, r2 rune) func Decode(s []uint16) []rune func DecodeRune(r1, r2 rune) rune func IsSurrogate(r rune) bool // 是否为有效代理对 unicode 有个基本字符平面和增补平面的概念，基本字符平面只有 65535 个字符，增补平面（有 16 个）加上去就能表示 1114112 个字符。 utf16 就是严格实现了 unicode 的这种编码规范。 而基本字符和增补平面字符就是一个代理对（Surrogate Pair）。一个代理对可以和一个 rune 进行转换。 示例： words :=[]rune{'𝓐','𝓑'} u16:=utf16.Encode(words) fmt.Println(u16) fmt.Println(utf16.Decode(u16)) r1,r2:=utf16.EncodeRune('𝓐') fmt.Println(r1,r2) fmt.Println(utf16.DecodeRune(r1,r2)) fmt.Println(utf16.IsSurrogate(r1)) fmt.Println(utf16.IsSurrogate(r2)) fmt.Println(utf16.IsSurrogate(1234)) 输出结果： [55349 56528 55349 56529] [120016 120017] 55349 56528 120016 true true false ","date":"2021-12-15","objectID":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/:3:0","tags":["Go 库"],"title":"Go Unicode 标准库","uri":"/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E6%9C%AC/unicode/"},{"categories":["前端"],"content":"API 规范 ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:0:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"Filtering 如果记录数量很多，服务器不可能都将它们返回给用户。API 应该 提供参数，过滤返回结果。下面是一些常见的参数。 ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2\u0026per_page=100：指定第几页，以及每页的记录数。 ?sortby=name\u0026order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 所有 URL 参数 必须 是全小写，必须 使用下划线类型的参数形式 经常使用的、复杂的查询 应该 标签化，降低维护成本。如 GET /trades?status=closed\u0026sort=sortby=name\u0026order=asc # 可为其定制快捷方式 GET /trades/recently_closed ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:1:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"Versioning 所有的 API 必须保持向后兼容，你 必须 在引入新版本 API 的同时确保旧版本 API 仍然可用。所以 应该 为其提供版本支持。 如在 URL 中嵌入版本编号 api.example.com/v1/* ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:2:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"API Root URL API 的根入口点应尽可能保持足够简单，这里有两个常见的 URL 根例子： api.example.com/* example.com/api/* ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:3:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"Endpoints 端点就是指向特定资源或资源集合的 URL。在端点的设计中，你 必须 遵守下列约定： URL 的命名 必须 全部小写 URL 中资源（resource）的命名 必须 是名词，并且 必须 是复数形式 必须 优先使用 Restful 类型的 URL URL 中不能出现 -，必须 用下划线 _ 代替（存疑） URL 必须 是易读的 URL 一定不可 暴露服务器架构 例如 https://api.example.com/zoos https://api.example.com/animals https://api.example.com/zoos/{zoo}/animals https://api.example.com/animal_types https://api.example.com/employees ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:4:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"HTTP 动词 对于资源的具体操作类型，由 HTTP 动词表示。常用的 HTTP 动词有下面五个（括号里是对应的 SQL 命令）。 GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 例如 请求方法 URL 描述 GET /zoos 列出所有的动物园 (ID 和名称，不要太详细) POST /zoos 新增一个新的动物园 GET /zoos/{zoo} 获取指定动物园详情 PUT /zoos/{zoo} 更新指定动物园(整个对象) PATCH /zoos/{zoo} 更新动物园(部分对象) DELETE /zoos/{zoo} 删除指定动物园 GET /zoos/{zoo}/animals 检索指定动物园下的动物列表 (ID 和名称，不要太详细) GET /animals 列出所有动物 (ID 和名称)。 POST /animals 新增新的动物 GET /animals/{animal} 获取指定的动物详情 PUT /animals/{animal} 更新指定的动物(整个对象) PATCH /animals/{animal} 更新指定的动物(部分对象) GET / 获取所有动物类型(ID和名称，不要太详细) GET /animal_types/{type} 获取指定的动物类型详情 GET /employees 检索整个雇员列表 GET /employees/{employee} 检索指定特定的员工 GET /zoos/{zoo}/employees 检索在这个动物园工作的雇员的名单(身份证和姓名) POST /employees 新增指定新员工 POST /zoos/{zoo}/employees 在特定的动物园雇佣一名员工 DELETE /zoos/{zoo}/employees/{employee} 从某个动物园解雇一名员工 ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:5:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"Response 所有的 API 响应，必须 遵守 HTTP 设计规范，必须 选择合适的 HTTP 状态码。一定不可 所有接口都返回状态码为 200 的 HTTP 响应，如： HTTP/1.1 200 ok Content-Type: application/json Server: example.com { \"code\": 0, \"msg\": \"success\", \"data\": { \"username\": \"username\" } } 复制代码 或 HTTP/1.1 200 ok Content-Type: application/json Server: example.com { \"code\": -1, \"msg\": \"该活动不存在\", } 复制代码 下表列举了常见的 HTTP 状态码 状态码 描述 1xx 代表请求已被接受，需要继续处理 2xx 请求已成功，请求所希望的响应头或数据体将随此响应返回 3xx 重定向 4xx 客户端原因引起的错误 5xx 服务端原因引起的错误 200 ok 在所有 成功 的 GET 请求中，必须 返回此状态码 201 Created 当服务器创建数据成功时，应该 返回此状态码 202 Accepted 该状态码表示服务器已经接受到了来自客户端的请求，但还未开始处理。常用短信发送、邮件通知、模板消息推送等这类很耗时需要队列支持的场景中 204 No Content 该状态码表示响应实体不包含任何数据，其中： 在使用 DELETE 方法删除资源 成功 时，必须 返回该状态码 使用 PUT、PATCH 方法更新数据 成功 时，也 应该 返回此状态码 400 Bad Request 由于明显的客户端错误（例如，请求语法格式错误、无效的请求、无效的签名等），服务器 应该 放弃该请求 当服务器无法从其他 4xx 类型的状态码中找出合适的来表示错误类型时，都 必须 返回该状态码。 401 Unauthorized 该状态码表示当前请求需要身份认证，以下情况都 必须 返回该状态码。 未认证用户访问需要认证的 API access_token 无效/过期 客户端在收到 401 响应后，都 应该 提示用户进行下一步的登录操作。 403 Forbidden 该状态码可以简单的理解为没有权限访问该请求，服务器收到请求但拒绝提供服务。 如当普通用户请求操作管理员用户时，必须 返回该状态码。 404 Not Found 该状态码表示用户请求的资源不存在，如 获取不存在的用户信息 （get /users/9999999） 访问不存在的端点 上述情况都 必须 返回该状态码，若该资源已永久不存在，则 应该 返回 410 响应。 405 Method Not Allowd 当客户端使用的 HTTP 请求方法不被服务器允许时，必须 返回该状态码。 如客户端调用了 POST 方法来访问只支持 GET 方法的 API 该响应 必须 返回一个 Allow 头信息用以表示出当前资源能够接受的请求方法的列表 406 Not Acceptable API 在不支持客户端指定的数据格式时，应该返回此状态码。如支持 JSON 和 XML 输出的 API 被指定返回 YAML 格式的数据时 Http 协议一般通过请求首部的 Accept 来指定数据格式 408 Request Timeout 客户端请求超时时 必须 返回该状态码，需要注意的时，该状态码表示 客户端请求超时，在涉及第三方 API 调用超时时，一定不可 返回该状态码 409 Gonfilct 该状态码表示因为请求存在冲突无法处理。如通过手机号码提供注册功能的 API，当用户提交的手机号已存在时，必须 返回此状态码。 410 Gone 和 404 类似，该状态码也表示请求的资源不存在，只是 410 状态码进一步表示所请求的资源已不存在，并且未来也不会存在。在收到 410 状态码后，客户端 应该 停止再次请求该资源 413 Request Entity Too Large 该状态码表示服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。 此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器 应该 返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 Request-URI Too Long 该状态码表示请求的 URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。 415 Unsupported Media Type 通常表示服务器不支持客户端请求首部 Content-Type 指定的数据格式。如在只接受 JSON 格式的 API 中放入 XML 类型的数据并向服务器发送，都 应该 返回该状态码。 该状态码也可用于如：只允许上传图片格式的文件，但是客户端提交媒体文件非法或不是图片类型 429 Too Many Request 该状态码表示用户请求次数超过允许范围。如 API 设定为 60次/分钟，当用户在一分钟内请求次数超过 60 次后，都 应该 返回该状态码。 500 Internal Server Error 该状态码 必须 在服务器出错时抛出，对于所有的 500 错误，都 应该 提供完整的错误信息支持，也方便跟踪调试。 503 Service Unavailable 该状态码表示服务器暂时处理不可用状态，当服务器需要维护或第三方 API 请求超时/不可达时，都 应该 返回该状态码，其中若是主动关闭 API 服务，应该在返回的响应首部加上 Retry-After 头部，表示多少秒后可以再次访问。 ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:6:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["前端"],"content":"其他细节 请求方式 说明 路径 请求参数 param 响应参数 data GET 获取所有资源 /api/todos 无 资源对象列表 POST 新增资源 /api/todos 资源对象 无 DELETE 删除批量资源 /api/todos id 数组对象 无 GET 查询单个资源 /api/todos/{id} 无 资源对象 DELETE 删除单个资源 /api/todos/{id} 无 无 POST 更新单个资源 (整个对象) /api/todos/{id} 资源模型 无 PATCH 更新单个资源 (部分属性) /api/todos/{id} 待更改属性对象 无 GET 分页查询资源 /api/todos?page=1\u0026size=20 查询参数对象 资源对象列表 时间字段尽量字符串化 关于请求 put 和 post 为 data 以请求体方式发送请求 get 和 delete 为 params 以查询参数方式发送请求 访问接口传参：请求体 + 路径参数 + 查询参数 axios 中 请求体在 param 中，作为请求体发送； 路径参数在 url 中，一般从 param 里调出； 查询参数在另外的形参里，一般会作为请求体发送（好像不对） 只要 param 传送的是完整 json 数据，fastapi 就会判断出它是对应的 pydantic 模型，将其作为请求体，若 param 不是完整的，则会被识别为路径或查询参数（一般为查询参数，因为路径参数直接写在 url 中了，不会写在请求体中） 实际上，查询参数既可以通过构建 url 发出，也可以写在请求体里发送（方法：不用封装成 json 格式，直接传参即可）。建议使用后者。因为前者不够优雅，耦合性高；而且 fastAPI 可以从请求体中将三种参数分开识别，非常方便呀 新增资源时，建议在响应中返回新增资源的 json 模型，这样在前端中可以比较方便地进行页面更新操作 而删除资源则不用 ","date":"2021-12-11","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/:7:0","tags":["API","前端","后端"],"title":"API 规范","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/api-%E8%A7%84%E8%8C%83/"},{"categories":["效率工具"],"content":"Git ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:0:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"安装 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:1:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"设置名字、邮箱 $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:1:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"创建版本库（repository） 创建空目录 $ mkdir \u003crepo name\u003e $ cd \u003crepo name\u003e $ pwd pwd命令用于显示当前目录 把这个目录变成Git可以管理的仓库 $ git init ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:1:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"文件操作 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:2:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"添加文件 把文件往 Git 版本库里添加的时候，是分两步执行的： 第一步是用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步是用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支。 将工作区文件添加到暂存区 $ git add \u003cfilename\u003e 将暂存区文件添加到本地仓库 $ git commit -m \u003cmessage\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:2:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看信息 查看仓库当前状态 $ git status 查看文件修改 $ git diff \u003cfilename\u003e 查看工作区和版本库里文件的区别 $ git diff HEAD -- \u003cfilename\u003e 查看文件内容 $ cat \u003cfilename\u003e 查看版本库状态 $ git log $ git log --pretty=oneline //简单显示 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:2:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"修改文件 退回上一版本 $ git reset --hard HEAD^ 上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100 退回某一版本 $ git reset --hard \u003cid\u003e 显示所有历史命令 $ git reflog 清除工作区的修改 $ git checkout -- \u003cfilename\u003e 实质：用版本库里的版本替换工作区的版本 清除暂存区的修改 $ git reset HEAD \u003cfilename\u003e 从工作区中删除文件 $ rm \u003cfilename\u003e 从版本库中删除文件 $ git rm \u003cfilename\u003e 别忘了git commit ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:2:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"远程仓库操作 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:3:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"创建SSH Key $ ssh-keygen -t rsa -C \"youremail@example.com\" 可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:3:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"关联远程仓库 $ git remote add origin git@github.com:GitHub-name/Repo-name.git ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:3:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"初次推送 $ git push -u origin master ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:3:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"将本地库推送至远程库 $ git push origin master 若要强制推送覆盖远程文件 $ git push -f origin master ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:3:4","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"将远程库克隆至本地库 $ git clone git@github.com:GitHub-name/Repo-name.git ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:3:5","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"分支操作 分支共有5种类型 master/main，最终发布版本，整个项目中有且只有一个 develop，项目的开发分支，原则上项目中有且只有一个 feature，功能分支，用于开发一个新的功能 release，预发布版本，介于develop和master之间的一个版本，主要用于测试 hotfix，修复补丁，用于修复master上的bug，直接作用于master ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"创建并切换到新的分支 $ git switch -c \u003cname\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"创建新的分支 $ git branch \u003cname\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"切换到已有的分支 $ git switch \u003cname\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看分支 $ git branch ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:4","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"合并某分支到当前分支 $ git merge \u003cname\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:5","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"删除分支 $ git branch -d \u003cname\u003e 若要强行删除 $ git branch -D \u003cname\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:6","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看分支的合并情况 $ git log --graph --pretty=oneline --abbrev-commit ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:7","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本； 你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。 所以，团队合作的分支看起来就像这样： ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:8","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"暂存工作现场 $ git stash ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:9","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看暂存的工作现场 $ git stash list ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:10","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"恢复暂存现场 $ git stash pop 若要恢复指定的stash $ git stash apply stash@{0} ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:11","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"复制一个特定的提交到当前分支 $ git cherry-pick \u003cid\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:12","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"整理分支 $ git rebase rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:4:13","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"多人协作 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看远程库的信息 $ git remote 若要查看更详细的信息 $ git remote -v ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"推送分支 $ git push origin \u003cbranch-name\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"在本地创建和远程分支对应的分支 $ git checkout -b \u003cbranch-name\u003e origin/\u003cbranch-name\u003e 分支名字最好一样 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"将远程库最新的提交抓下来 $ git pull 若提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令 $ git branch --set-upstream-to \u003cbranch-name\u003e origin/\u003cbranch-name\u003e 或 $ git pull origin \u003cbranch-name\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:4","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"主要步骤 多人协作的工作模式通常是这样： 首先，可以试图用git push origin \u003cbranch-name\u003e推送自己的修改； 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并； 如果合并有冲突，则解决冲突，并在本地提交； 没有冲突或者解决掉冲突后，再用git push origin \u003cbranch-name\u003e推送就能成功！ ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:5","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"fork 相关操作 添加一个将被同步给 fork 远程的上游仓库 git remote add upstream git@github.com:GitHub-name/Repo-name.git 从上游仓库拉取更新 git fetch upstream 与自己的分支合并 git merge upstream/master ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:5:6","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"标签操作 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:6:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"创建标签 切换到需要打标签的分支上，然后用以下命令创建标签 $ git tag \u003ctag-name\u003e 若要根据commit id打标签 $ git tag \u003ctag-name\u003e \u003cid\u003e 若要创建带有说明的标签 $ git tag -a \u003ctag-name\u003e -m \"message\" \u003cid\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:6:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看标签 $ git tag ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:6:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"查看标签详细信息 $ git show \u003ctag-name\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:6:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"删除标签 $ git tag -d \u003ctag-name\u003e 若要删除远程库标签，先从本地删除，然后 $ git push origin :refs/tags/\u003ctag-name\u003e ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:6:4","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"推送标签至远程库 $ git push origin \u003ctag-name\u003e 若要一次性全部推送 $ git push origin --tags ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:6:5","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"个性化 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:7:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"显示更丰富的颜色 $ git config --global color.ui true ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:7:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"配置别名 $ git config –global alias. ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:7:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"忽略特殊文件 $ touch .gitignore 或直接创建一个.gitignore文件 别忘了提交.gitignore ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:7:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"删库跑路 $ rm .git -rf ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:7:4","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"规范 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:8:0","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"GitFlow 分支命名规范 master：也称 main，存储正式发布的产品。 这个分支上的产品要求随时处于可部署状态。 它只能通过与其他分支合并来更新内容，禁止直接在 master || main 分支进行修改。 develop：汇总开发者完成的工作成果 develop 分支上的产品可以是缺失功能模块的半成品，但是已有的功能模块不能是半成品 develop 分支只能通过与其他分支合并来更新内容，禁止直接在 develop 分支进行修改。 feature 分支：feature/\u003c功能名\u003e，例如：feature/login 当要开发新功能时，从 master 分支创建一个新的 feature 分支，并在 feature 分支上进行开发。 开发完成后，需要将该 feature 分支合并到 develop 分支，最后删除该 feature 分支 release 分支 当 develop 分支上的项目准备发布时，从 develop 分支上创建一个新的 release 分支，新建的 release 分支只能进行质量测试、bug 修复、文档生成等面向发布的任务，不能再添加功能。 这一系列发布任务完成后，需要将 release 分支合并到 master 分支上，并根据版本号为 master 分支添加 tag，然后将 release 分支创建以来的修改合并回 develop 分支，最后删除 release 分支 hotfix 分支：hotfix/日期，例如：hotfix/0104 当 master 分支中的产品出现需要立即修复的 bug 时，从 master 分支上创建一个新的 hotfix 分支，并在 hotfix 分支上进行 BUG 修复。 修复完成后，需要将 hotfix 分支合并到 master 分支和 develop 分支，并为 master 分支添加新的版本号 tag，最后删除 hotfix 分支。 ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:8:1","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"commit 规范 \u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e type feat：新功能（feature） fix：问题修复 docs：文档 style：调整格式（不影响代码运行 white-space, formatting, missing semi colons, etc） perf：优化性能或体验 refactor：重构（既不是新增功能，也不是修補 bug 的程式碼變動） test：增加测试 chore：构建过程或辅助工具的变动 merge：代码合并。 revert：撤销以前的提交 sync：同步主线或分支的 Bug scope：用于说明提交的影响范围，内容根据具体项目而定 subject：概括提交内容 详见：https://www.cnblogs.com/daysme/p/7722474.html ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:8:2","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["效率工具"],"content":"其他 识别大小写 git config core.ignorecase false 修改上一次的 commit 记录 git commit --amend ","date":"2021-12-09","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/:8:3","tags":["Git","快速入门"],"title":"Git 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/git/"},{"categories":["前端"],"content":"Pinia Pinia (pronounced like /peenya/ in English) is the closest word to piña (pineapple in Spanish) that is a valid package name. A pineapple is in reality a group of individual flowers that join together to create a multiple fruit. Similar to stores, each one is born individually, but they are all connected at the end. It’s also a delicious tropical fruit indigenous to South America. Not all applications need access to a global state, but if yours need one, Pinia will make your life easier. import { defineStore } from 'pinia' export const todos = defineStore('todos', { state: () =\u003e ({ /** @type { text: string, id: number, isFinished: boolean }[] */ todos: [], /** @type {'all' | 'finished' | 'unfinished'} */ filter: 'all', // type will be automatically inferred to number nextId: 0, }), getters: { finishedTodos(state) { // autocompletion! ✨ return state.todos.filter((todo) =\u003e todo.isFinished) }, unfinishedTodos(state) { return state.todos.filter((todo) =\u003e !todo.isFinished) }, /** * @returns { text: string, id: number, isFinished: boolean }[] */ filteredTodos(state) { if (this.filter === 'finished') { // call other getters with autocompletion ✨ return this.finishedTodos } else if (this.filter === 'unfinished') { return this.unfinishedTodos } return this.todos }, }, actions: { // any amount of arguments, return a promise or not addTodo(text) { // you can directly mutate the state this.todos.push({ text, id: this.nextId++, isFinished: false }) }, }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:0:0","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"认识 import { createPinia } from 'pinia'; app.use(createPinia()); start by creating a store // stores/counter.js import { defineStore } from 'pinia' export const useCounterStore = defineStore('counter', { state: () =\u003e ({ count: 0 }) actions: { increment() { this.count++ }, }, }) use it in a component import { useCounterStore } from '@/stores/counter' export default { setup() { const counter = useCounterStore() counter.count++ // with autocompletion ✨ counter.$patch({ count: counter.count + 1 }) // or using an action instead counter.increment() }, } You can even use a function (similar to a component setup()) to define a Store for more advanced use cases: export const useCounterStore = defineStore('counter', () =\u003e { const count = ref(0) function increment() { count.value++ } return { count, increment } }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:1:0","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"安装 安装需要 @next 因为 Pinia 2 处于 beta 阶段, Pinia 2 是对应 Vue3 的版本 # 使用 npm npm install pinia@next # 使用 yarn yarn add pinia@next ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:1:1","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Store A Store (like Pinia) is an entity holding state and business logic that isn’t bound to your Component tree. In other words, it hosts global state. It’s a bit like a component that is always there and that everybody can read off and write to. It has three concepts, the state, getters and actions and it’s safe to assume these concepts are the equivalent of data, computed and methods in components. ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:2:0","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Defining a Store import { defineStore } from 'pinia' // useStore could be anything like useUser, useCart // the first argument is a unique id of the store across your application export const useStore = defineStore('main', { // other options... }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:2:1","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Using the store We are defining a store because the store won’t be created until useStore() is called inside of setup(): import { useStore } from '@/stores/counter' export default { setup() { const store = useStore() return { // you can return the whole store instance to use it in the template store, } }, } Note that store is an object wrapped with reactive, meaning there is no need to write .value after getters but, like props in setup, we cannot destructure (解构) it: export default defineComponent({ setup() { const store = useStore() // ❌ This won't work because it breaks reactivity // it's the same as destructuring from `props` const { name, doubleCount } = store name // \"eduardo\" doubleCount // 2 return { // will always be \"eduardo\" name, // will always be 2 doubleCount, // this one will be reactive doubleValue: computed(() =\u003e store.doubleCount), } }, }) In order to extract properties from the store while keeping its reactivity, you need to use storeToRefs(). It will create refs for any reactive property. This is useful when you are only using state from the store but not calling any action: import { storeToRefs } from 'pinia' export default defineComponent({ setup() { const store = useStore() // `name` and `doubleCount` are reactive refs // This will also create refs for properties added by plugins // but skip any action or non reactive (non ref/reactive) property const { name, doubleCount } = storeToRefs(store) return { name, doubleCount } }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:2:2","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"State import { defineStore } from 'pinia' const useStore = defineStore('storeId', { // arrow function recommended for full type inference state: () =\u003e { return { // all these properties will have their type inferred automatically counter: 0, name: 'Eduardo', isAdmin: true, } }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:3:0","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Accessing By default, you can directly read and write to the state by accessing it through the store instance: const store = useStore() store.counter++ ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:3:1","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Resetting You can reset the state to its initial value by calling the $reset() method on the store: const store = useStore() store.$reset() ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:3:2","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Mutating Apart from directly mutating the store with store.counter++, you can also call the $patch method. It allows you to apply multiple changes at the same time with a partial state object: store.$patch({ counter: store.counter + 1, name: 'Abalam', }) However, some mutations are really hard or costly to apply with this syntax: any collection modification (e.g. pushing, removing, splicing an element from an array) requires you to create a new collection. Because of this, the $patch method also accepts a function to group this kind of mutations that are difficult to apply with a patch object: cartStore.$patch((state) =\u003e { state.items.push({ name: 'shoes', quantity: 1 }) state.hasChanged = true }) The main difference here is that $patch() allows you to group multiple changes into one single entry in the devtools. Note both, direct changes to state and $patch() appear in the devtools and can be time travelled (not yet in Vue 3). ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:3:3","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Replacing You can replace the whole state of a store by setting its $state property to a new object: store.$state = { counter: 666, name: 'Paimon' } You can also replace the whole state of your application by changing the state of the pinia instance. This is used during SSR for hydration pinia.state.value = {} ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:3:4","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Subscribing You can watch the state and its changes through the $subscribe() method of a store, similar to Vuex’s subscribe method. The advantage of using $subscribe() over a regular watch() is that subscriptions will trigger only once after patches (e.g. when using the function version from above). cartStore.$subscribe((mutation, state) =\u003e { // import { MutationType } from 'pinia' mutation.type // 'direct' | 'patch object' | 'patch function' // same as cartStore.$id mutation.storeId // 'cart' // only available with mutation.type === 'patch object' mutation.payload // patch object passed to cartStore.$patch() // persist the whole state to the local storage whenever it changes localStorage.setItem('cart', JSON.stringify(state)) }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:3:5","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Getters Getters are exactly the equivalent of computed values for the state of a Store. They can be defined with the getters property in defineStore(). They receive the state as the first parameter to encourage the usage of arrow function: export const useStore = defineStore('main', { state: () =\u003e ({ counter: 0, }), getters: { doubleCount: (state) =\u003e state.counter * 2, }, }) Most of the time, getters will only rely on the state, however, they might need to use other getters. Because of this, we can get access to the whole store instance through this when defining a regular function but it is necessary to define the type of the return type (in TypeScript). This is due to a known limitation in TypeScript and doesn’t affect getters defined with an arrow function nor getters not using this: export const useStore = defineStore('main', { state: () =\u003e ({ counter: 0, }), getters: { // automatically infers the return type as a number doubleCount(state) { return state.counter * 2 }, // the return type **must** be explicitly set doublePlusOne(): number { // autocompletion and typings for the whole store ✨ return this.counter * 2 + 1 }, }, }) Then you can access the getter directly on the store instance: \u003ctemplate\u003e \u003cp\u003eDouble count is {{ store.doubleCount }}\u003c/p\u003e \u003c/template\u003e \u003cscript\u003e export default { setup() { const store = useStore() return { store } }, } \u003c/script\u003e ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:4:0","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Accessing other getters As with computed properties, you can combine multiple getters. Access any other getter via this. Even if you are not using TypeScript, you can hint your IDE for types with the JSDoc: 绷不住了 export const useStore = defineStore('main', { state: () =\u003e ({ counter: 0, }), getters: { // type is automatically inferred because we are not using `this` doubleCount: (state) =\u003e state.counter * 2, // here we need to add the type ourselves (using JSDoc in JS). We can also // use this to document the getter /** * Returns the counter value times two plus one. * * @returns {number} */ doubleCountPlusOne() { // autocompletion ✨ return this.doubleCount + 1 }, }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:4:1","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Accessing other stores getters To use another store getters, you can directly use it inside of the getter: import { useOtherStore } from './other-store' export const useStore = defineStore('main', { state: () =\u003e ({ // ... }), getters: { otherGetter(state) { const otherStore = useOtherStore() return state.localData + otherStore.data }, }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:4:2","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Actions Actions are the equivalent of methods in components. They can be defined with the actions property in defineStore() and they are perfect to define business logic: export const useStore = defineStore('main', { state: () =\u003e ({ counter: 0, }), actions: { increment() { this.counter++ }, randomizeCounter() { this.counter = Math.round(100 * Math.random()) }, }, }) Actions are invoked like methods: export default defineComponent({ setup() { const main = useMainStore() // call the action as a method of the store main.randomizeCounter() return {} }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:5:0","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"Accessing other stores actions To use another store, you can directly use it inside of the action: import { useAuthStore } from './auth-store' export const useSettingsStore = defineStore('settings', { state: () =\u003e ({ // ... }), actions: { async fetchUserPreferences(preferences) { const auth = useAuthStore() if (auth.isAuthenticated) { this.preferences = await fetchPreferences() } else { throw new Error('User must be authenticated') } }, }, }) ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:5:1","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["前端"],"content":"File Structure # Pinia equivalent, note ids match previous namespaces src └── stores ├── index.js # (Optional) Initializes Pinia, does not import stores ├── module1.js # 'module1' id ├── nested-module2.js # 'nested/module3' id ├── nested-module3.js # 'nested/module2' id └── nested.js # 'nested' id ","date":"2021-12-08","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/:5:2","tags":["前端","快速入门"],"title":"Pinia","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/pinia/"},{"categories":["效率工具"],"content":"mermaid ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:0:0","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"FlowChart ```mermaid graph TD A--\u003eB ``` ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:1:0","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"方向 TB 从上到下 BT 从下到上 RL 从右到左 LR 从左到右 TD 同TB graph TD Up--\u003eDown ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:1:1","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"基本图形 [带文本的矩形] [(带文本的圆角矩形) \u003e带文本的不对称的矩形] {带文本的菱形} ((带文本的圆形)) 如果节点的文字中包含标点符号，需要时用双引号包裹起来 ```mermaid graph TD A[带文本的矩形] B(带文本的圆角矩形) C\u003e带文本的不对称的矩形] D{带文本的菱形} E((带文本的圆形)) ``` graph TD A[带文本的矩形] B(带文本的圆角矩形) C\u003e带文本的不对称的矩形] D{带文本的菱形} E((带文本的圆形)) ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:1:2","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"结点间连接 A –\u003e B A带箭头指向B A — B A不带箭头指向B A -.- B A用虚线指向B A -.-\u003e B A用带箭头的虚线指向B A ==\u003e B A用加粗的箭头指向B A – 描述 — B A不带箭头指向B并在中间加上文字描述 A – 描述 –\u003e B A带箭头指向B并在中间加上文字描述 A -. 描述 .-\u003e B A用带箭头的虚线指向B并在中间加上文字描述 A == 描述 ==\u003e B A用加粗的箭头指向B并在中间加上文字描述 graph TB subgraph 1 A1 --\u003e B1 end subgraph 2 A2 --- B2 end subgraph 3 A3 -.- B3 end subgraph 4 A4 -.-\u003e B4 end subgraph 5 A5 ==\u003e B5 end subgraph 6 A6 -- 描述 --- B6 end subgraph 7 A7 -- 描述 --\u003e B7 end subgraph 8 A8 -. 描述 .-\u003e B8 end subgraph 9 A9 == 描述 ==\u003e B9 end ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:1:3","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"子流程图 ```mermaid subgraph title graph definition end ``` graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:1:4","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"Demo ```mermaid graph LR start[开始] --\u003e input[输入A,B,C] input --\u003e conditionA{A是否大于B} conditionA -- YES --\u003e conditionC{A是否大于C} conditionA -- NO --\u003e conditionB{B是否大于C} conditionC -- YES --\u003e printA[输出A] conditionC -- NO --\u003e printC[输出C] conditionB -- YES --\u003e printB[输出B] conditionB -- NO --\u003e printC[输出C] printA --\u003e stop[结束] printC --\u003e stop printB --\u003e stop ​``` graph LR start[开始] --\u003e input[输入A,B,C] input --\u003e conditionA{A是否大于B} conditionA -- YES --\u003e conditionC{A是否大于C} conditionA -- NO --\u003e conditionB{B是否大于C} conditionC -- YES --\u003e printA[输出A] conditionC -- NO --\u003e printC[输出C] conditionB -- YES --\u003e printB[输出B] conditionB -- NO --\u003e printC[输出C] printA --\u003e stop[结束] printC --\u003e stop printB --\u003e stop ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:1:5","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"Class Diagram ```mermaid classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ``` classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:2:0","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"定义类 使用关键字 class 使用关系符 \u003c|-- 定义两个类的关系 classDiagram class Animal Vehicle \u003c|-- Car ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:2:1","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"定义属性、方法 Mermaid distinguishes between attributes and functions/methods based on if the parenthesis () are present or not 使用 : 使用 {} class BankAccount BankAccount : +String owner BankAccount : +BigDecimal balance BankAccount : +deposit(amount) BankAccount : +withdrawal(amount) class BankAccount{ +String owner +BigDecimal balance +deposit(amount) +withdrawl(amount) } 函数返回值 写在函数后 +withdrawl(amount) int 设置泛型 使用 ~~ 包围 classDiagram class Square~Shape~{ int id List~int~ position setPoints(List~int~ points) getPoints() List~int~ } Square : -List~string~ messages Square : +setMessages(List~string~ messages) Square : +getMessages() List~string~ classDiagram class Square~Shape~{ int id List~int~ position setPoints(List~int~ points) getPoints() List~int~ } Square : -List~string~ messages Square : +setMessages(List~string~ messages) Square : +getMessages() List~string~ 设置成员可视类型 + Public - Private # Protected ~ Package/Internal note you can also include additional classifiers to a method definition by adding the following notations to the end of the method, i.e.: after the (): * Abstract e.g.: someAbstractMethod()* $ Static e.g.: someStaticMethod()$ ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:2:2","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"类关系 [classA][Arrow][ClassB]:LabelText Type Description \u003c|– Inheritance *– Composition o– Aggregation –\u003e Association – Link (Solid) ..\u003e Dependency ..|\u003e Realization .. Link (Dashed) classDiagram classA \u003c|-- classB classC *-- classD classE o-- classF classG \u003c-- classH classI -- classJ classK \u003c.. classL classM \u003c|.. classN classO .. classP :I'm a label ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:2:3","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["效率工具"],"content":"Entity Relationship Diagrams erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses CUSTOMER { string name string custNumber string sector } \u003cfirst-entity\u003e [\u003crelationship\u003e \u003csecond-entity\u003e : \u003crelationship-label\u003e] Value (left) Value (right) Meaning ` o` `o ` ` }o o{ Zero or more (no upper limit) `} ` ` ","date":"2021-12-07","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/:3:0","tags":["快速入门"],"title":"mermaid","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/mermaid/"},{"categories":["前端"],"content":"yarn ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:0:0","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"基本操作 ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:0","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"安装 npm install yarn ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:1","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"初始化一个新项目 yarn init ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:2","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"安装所有依赖项 yarn yarn install ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:3","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"添加依赖项 yarn add [package] yarn add [package]@[version] yarn add [package]@[tag] ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:4","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"将依赖项添加到不同的依赖类别中 yarn add [package] --dev # dev dependencies yarn add [package] --peer # peer dependencies ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:5","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"更新依赖项 yarn up [package] yarn up [package]@[version] yarn up [package]@[tag] ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:6","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"删除依赖项 yarn remove [package] ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:7","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"更新 Yarn 本体 yarn set version latest yarn set version from sources ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:1:8","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"与 vite 配合 ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:2:0","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"运行 yarn dev ","date":"2021-12-05","objectID":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/:2:1","tags":["快速入门","前端","包管理器"],"title":"yarn","uri":"/Notes/posts/frontend/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/yarn/"},{"categories":["前端"],"content":"Vue2 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:0:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"认识 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:1:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"概念 Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统 \u003cdiv id=\"app\"\u003e {{ message }} \u003c/div\u003e var app = new Vue({ el: '#app', data: { message: 'Hello Vue!' } }) v- attribute 被称为指令。指令带有前缀 v-，以表示它们是 Vue 提供的特殊 attribute。 它们会在渲染的 DOM 上应用特殊的响应式行为 JavaScript 框架 简化 Dom 操作 响应式数据驱动 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:1:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"核心 数据绑定 事件绑定 用户输入获取 组件定义和使用 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:1:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"引入 CDN \u003c!-- 开发环境版本，包含了有帮助的命令行警告 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003c!-- 生产环境版本，优化了尺寸和速度 --\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue\"\u003e\u003c/script\u003e Vue CLI 安装 npm install -g @vue/cli 升级 npm update -g @vue/cli 创建项目 vue create project-name 安装必要工具 npm install 开启本地端口 npm run serve npm run serve -- --port 5000 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:1:3","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"基础 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:2:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"Vue 实例 var app = new Vue({ el:\"#app\", data:{ message:\"Hello World\", array:[], obj:{}, } }) el：挂载点， Vue 会管理 el 选项命中的元素及其内部的后代元素 可以挂载到双标签上，不能使用 HTML 和 BODY data：数据对象 Vue 中用到的数据定义在 data 中 data 中可以写复杂类型的数据 渲染复杂类型数据时,遵守 js 的语法即可 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:2:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"Vue 指令 Vue 指令指的是,以 v- 开头的一组特殊语法 v-text 设置标签的文本值 (textContent) 支持在内部写表达式，如 v-text=\"message + '!'\" v-text 指令无论内容是什么,只会解析为文本 var app = new Vue({ el: \"#app\", data: { message: \"Hello\" } }) 默认写法：在文本标签中添加 v-text 属性值，会替换全部内容 \u003cdiv id=\"app\"\u003e \u003ch2 v-text=\"message\"\u003e\u003c/h2\u003e \u003c/div\u003e 差值表达式 {{ }} 可以替换指定内容 \u003cdiv id='app'\u003e \u003cp\u003e{{message + '!'}}\u003c/p\u003e \u003c/div\u003e v-html 设置标签的 innerHTML 若内容中有 html 结构，会被解析为标签，如 content:\"\u003ca href='#'\u003eHello World\u003c/a\u003e\" 辨析：解析文本使用 v-text,需要解析 html 结构使用 v-html var app = new Vue({ el:\"#app\", data:{ content:\"Hello World\" } }) \u003cdiv id=\"app\"\u003e \u003cp v-html=\"content\"\u003e\u003c/p\u003e \u003c/div\u003e v-on 为元素绑定事件 事件名不需要写 on 指令可以简写为 @ 绑定的方法定义在 methods 属性中 方法内部通过 this 关键字可以访问定义在 data 中数据 var app = new Vue({ el: \"#app\", methods: { doIt: function () { // ... } } }) \u003cdiv id=\"app\"\u003e \u003cinput type=\"button\" value=\"bind1\" v-on:click=\"doIt\"\u003e \u003cinput type=\"button\" value=\"bind2\" v-on:monseenter=\"doIt\"\u003e \u003cinput type=\"button\" value=\"bind3\" v-on:dblclick=\"doIt\"\u003e \u003cinput type=\"button\" value=\"bind4\" @dblclick=\"doIt\"\u003e \u003c/div\u003e 例：计数器 \u003cdiv id=\"app\"\u003e \u003cinput type='button' value='-' v-on:click='sub'\u003e \u003cspan\u003e{{value}}\u003c/span\u003e \u003cinput type='button' value='+' v-on:click='add'\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript\u003e var app = new Vue({ el: \"#app\", data: { value: 1 }, methods: { sub: function () { this.value -= 1; }, add: function () { this.value += 1; } }, }) \u003c/script\u003e 修饰符 事件的后面跟上 .修饰符 可以对事件进行限制 .stop - 调用 event.stopPropagation()。 .prevent - 调用 event.preventDefault()。 .capture - 添加事件侦听器时使用 capture 模式。 .self - 只当事件是从侦听器绑定的元素本身触发时才触发回调。 .{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。 .native - 监听组件根元素的原生事件。 .once - 只触发一次回调。 .left - (2.2.0) 只当点击鼠标左键时触发。 .right - (2.2.0) 只当点击鼠标右键时触发。 .middle - (2.2.0) 只当点击鼠标中键时触发。 .passive - (2.3.0) 以 { passive: true } 模式添加侦听器 \u003c!-- 方法处理器 --\u003e \u003cbutton v-on:click=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 动态事件 (2.6.0+) --\u003e \u003cbutton v-on:[event]=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 内联语句 --\u003e \u003cbutton v-on:click=\"doThat('hello', $event)\"\u003e\u003c/button\u003e \u003c!-- 缩写 --\u003e \u003cbutton @click=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 动态事件缩写 (2.6.0+) --\u003e \u003cbutton @[event]=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 停止冒泡 --\u003e \u003cbutton @click.stop=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 阻止默认行为 --\u003e \u003cbutton @click.prevent=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 阻止默认行为，没有表达式 --\u003e \u003cform @submit.prevent\u003e\u003c/form\u003e \u003c!-- 串联修饰符 --\u003e \u003cbutton @click.stop.prevent=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 键修饰符，键别名 --\u003e \u003cinput @keyup.enter=\"onEnter\"\u003e \u003c!-- 键修饰符，键代码 --\u003e \u003cinput @keyup.13=\"onEnter\"\u003e \u003c!-- 点击回调只会触发一次 --\u003e \u003cbutton v-on:click.once=\"doThis\"\u003e\u003c/button\u003e \u003c!-- 对象语法 (2.4.0+) --\u003e \u003cbutton v-on=\"{ mousedown: doThis, mouseup: doThat }\"\u003e\u003c/button\u003e v-show 根据表达值的真假，切换元素的显示和隐藏 原理是修改元素的 display，实现显示隐藏 指令后面的内容，最终都会解析为布尔值 var app = new Vue({ el:\"#app\", data:{ isShow:false, age:16 } }) \u003cdiv id=\"app\"\u003e \u003cimg src=\"地址\" v-show=\"true\"\u003e \u003cimg src=\"地址\" v-show=\"isShow\"\u003e \u003cimg src=\"地址\" v-show=\"age\u003e=18\"\u003e \u003c/div\u003e v-if 根据表达值的真假,切换元素的显示和隐藏 (操纵 dom 元素) 本质是通过操纵 dom 元素来切换显示状态 表达式的值为 true,元素存在于 dom 树中,为 false，从 dom 树中移除 辨析：频繁的切换使用 v-show，偶尔切换使用v-if，前者的切换消耗小 var app = new Vue({ el:\"#app\", data:{ isShow:false, } }) \u003cdiv id=\"app\"\u003e \u003cp v-if=\"true\"\u003e我是一个p标签\u003c/p\u003e \u003cp v-if=\"isShow\"\u003e我是一个p标签\u003c/p\u003e \u003cp v-if=\"表达式\"\u003e我是一个p标签\u003c/p\u003e \u003c/div\u003e v-bind 设置元素的属性：v-bind:属性名=表达式 可以用 : 简写 需要动态的增删 class 建议使用对象的方式 var app = new Vue({ el:\"#app\", data:{ imgSrc:\"picture-path\", imgTitle:\"text\", isActive:false } }) \u003cdiv id=\"app\"\u003e \u003cimg v-bind:src= \"imgSrc\" \u003e \u003cimg v-bind:title=\"imgTitle+'!'\"\u003e \u003cimg v-bind:class=\"isActive?'active':''\"\u003e \u003cimg v-bind:class=\"{active:isActive}\"\u003e \u003c/div\u003e v-for 根据数据生成列表结构 语法：(item, index) in array item 和 index 可以结合其他指令一起使用 数组长度的更新会同步到页面上,是响应式的 var app = new Vue({ el: \"#app\", data: { arr: ['a', 'b', 'c', 'd', 'e'], objArr: [ { name: 'Mike' }, { name: 'Jack' } ] } }) \u003cdiv id=\"app\"\u003e \u003cul\u003e \u003cli v-for=\"(item,index) in arr\" :title='item'\u003e {{index}} -\u003e {{ item }} \u003c/li\u003e \u003cli v-for=\"item in objArr\"\u003e {{ item.name }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e v-model 获取和设置表单元素的值 (双向数据绑定) 绑定的数据会和表单元素值相关联 \u003cdiv id=\"app\"\u003e \u003cinput type=\"text\" v-model=\"message\" /\u003e \u003c/div\u003e ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:2:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"组件间的数据传递 父子组件之间的数据传递可以使用 props 或者 $emit 等方式 父传子 使用 props 子组件部分 父组件部分 子传父 通过事件传递数据 子组件部分 父组件部分 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:2:3","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"一些原理 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:3:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"计算属性 computed 中的 getter 在 Vue 中，computed 的属性可以被视为是 data 一样，可以读取和设值，因此在 computed 中可以分成 getter（读取） 和 setter（设值），一般情况下是没有 setter 的，computed 预设只有 getter ，也就是只能读取，不能改变设值。 vue.js 计算属性默认只有 getter，因为是默认值所以我们也常常省略不写，如下代码： var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar' }, computed: { fullName: function () { return this.firstName + ' ' + this.lastName } } }) 其实computed里的代码完整的写法应该是： computed: { fullName: { get(){ return this.firstName + ' ' + this.lastName } } } axios ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:3:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"介绍 Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:4:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"引入 使用 npm: $ npm install axios 使用 bower: $ bower install axios 使用 cdn: \u003cscript src=\"https://unpkg.com/axios/dist/axios.min.js\"\u003e\u003c/script\u003e ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:4:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"样例 axios({ method: 'GET', url: url, }) .then(res =\u003e {console.log(res)}) .catch(err =\u003e {console.log(err)}) axios.post('/user', { firstName: 'Mike', lastName: 'Allen' }).then( res =\u003e { console.info(res) }).catch( e =\u003e { console.info(e) }) ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:4:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"使用 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:5:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"axios(config) // 发送 POST 请求 axios({ method: 'post', url: 'www.google.com', data: { firstName: 'Fred', lastName: 'Flintstone' } }); ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:5:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"axios(url[, config]) // 发送 GET 请求（默认的方法） axios('/user/12345'); ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:5:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"别名 axios.get(url[, config]) axios.post(url[, data[, config]]) ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:5:3","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"配置项 { // `url` 是用于请求的服务器 URL url: '/user', // `method` 是创建请求时使用的方法 method: 'get', // 默认是 get // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。 // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL baseURL: 'https://some-domain.com/api/', // `transformRequest` 允许在向服务器发送前，修改请求数据 // 只能用在 'PUT', 'POST' 和 'PATCH' 这几个请求方法 // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream transformRequest: [function (data) { // 对 data 进行任意转换处理 return data; }], // `transformResponse` 在传递给 then/catch 前，允许修改响应数据 transformResponse: [function (data) { // 对 data 进行任意转换处理 return data; }], // `headers` 是即将被发送的自定义请求头 headers: {'X-Requested-With': 'XMLHttpRequest'}, // `params` 是即将与请求一起发送的 URL 参数 // 必须是一个无格式对象(plain object)或 URLSearchParams 对象 params: { ID: 12345 }, // `paramsSerializer` 是一个负责 `params` 序列化的函数 // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/) paramsSerializer: function(params) { return Qs.stringify(params, {arrayFormat: 'brackets'}) }, // `data` 是作为请求主体被发送的数据 // 只适用于这些请求方法 'PUT', 'POST', 和 'PATCH' // 在没有设置 `transformRequest` 时，必须是以下类型之一： // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams // - 浏览器专属：FormData, File, Blob // - Node 专属： Stream data: { firstName: 'Fred' }, // `timeout` 指定请求超时的毫秒数(0 表示无超时时间) // 如果请求话费了超过 `timeout` 的时间，请求将被中断 timeout: 1000, // `withCredentials` 表示跨域请求时是否需要使用凭证 withCredentials: false, // 默认的 // `adapter` 允许自定义处理请求，以使测试更轻松 // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)). adapter: function (config) { /* ... */ }, // `auth` 表示应该使用 HTTP 基础验证，并提供凭据 // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头 auth: { username: 'janedoe', password: 's00pers3cret' }, // `responseType` 表示服务器响应的数据类型，可以是 'arraybuffer', 'blob', 'document', 'json', 'text', 'stream' responseType: 'json', // 默认的 // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称 xsrfCookieName: 'XSRF-TOKEN', // default // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称 xsrfHeaderName: 'X-XSRF-TOKEN', // 默认的 // `onUploadProgress` 允许为上传处理进度事件 onUploadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `onDownloadProgress` 允许为下载处理进度事件 onDownloadProgress: function (progressEvent) { // 对原生进度事件的处理 }, // `maxContentLength` 定义允许的响应内容的最大尺寸 maxContentLength: 2000, // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte validateStatus: function (status) { return status \u003e= 200 \u0026\u0026 status \u003c 300; // 默认的 }, // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目 // 如果设置为0，将不会 follow 任何重定向 maxRedirects: 5, // 默认的 // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项： // `keepAlive` 默认没有启用 httpAgent: new http.Agent({ keepAlive: true }), httpsAgent: new https.Agent({ keepAlive: true }), // 'proxy' 定义代理服务器的主机名称和端口 // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据 // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。 proxy: { host: '127.0.0.1', port: 9000, auth: : { username: 'mikeymike', password: 'rapunz3l' } }, // `cancelToken` 指定用于取消请求的 cancel token // （查看后面的 Cancellation 这节了解更多） cancelToken: new CancelToken(function (cancel) { }) } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:6:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"工程化目录结构 脚手架 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:7:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"架构 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:8:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"main.js 程序入口 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:8:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"App.vue 主视图 \u003ctemplate\u003e \u003cdiv id=\"app\"\u003e \u003cdiv\u003e \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e | \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e \u003c/div\u003e \u003crouter-view /\u003e \u003c/div\u003e \u003c/template\u003e \u003cscript\u003e export default {}; \u003c/script\u003e \u003cstyle lang=\"scss\"\u003e \u003c/style\u003e 结构：\u003ctemplate\u003e 脚本： \u003cscript\u003e 样式：\u003cstyle\u003e 页面中放入一个路由视图容器： \u003crouter-view\u003e\u003c/router-view\u003e 引用路由链接： \u003crouter-link to=\"/\"\u003eHome\u003c/router-link\u003e | \u003crouter-link to=\"/about\"\u003eAbout\u003c/router-link\u003e ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:8:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"router 路由配置例 import Vue from 'vue' import VueRouter from 'vue-router' import Home from '../views/Home.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'Home', component: Home }, { path: '/about', name: 'About', component: () =\u003e import('../views/About.vue') } ] 用 Vue.js + Vue Router 创建单页应用 使用 Vue.js ，我们已经可以通过组合组件来组成应用程序；当你要把 Vue Router 添加进来，我们需要做的是，将组件 (components) 映射到路由 (routes)，然后告诉 Vue Router 在哪里渲染它们。 \u003cscript src=\"https://unpkg.com/vue/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://unpkg.com/vue-router/dist/vue-router.js\"\u003e\u003c/script\u003e \u003cdiv id=\"app\"\u003e \u003ch1\u003eHello App!\u003c/h1\u003e \u003cp\u003e \u003c!-- 使用 router-link 组件来导航. --\u003e \u003c!-- 通过传入 `to` 属性指定链接. --\u003e \u003c!-- \u003crouter-link\u003e 默认会被渲染成一个 `\u003ca\u003e` 标签 --\u003e \u003crouter-link to=\"/foo\"\u003eGo to Foo\u003c/router-link\u003e \u003crouter-link to=\"/bar\"\u003eGo to Bar\u003c/router-link\u003e \u003c/p\u003e \u003c!-- 路由出口 --\u003e \u003c!-- 路由匹配到的组件将渲染在这里 --\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/div\u003e ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:8:3","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"单文件组件 Vuex ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:9:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"认识 vuex 是一个专门为 vue.js 应用程序开发的状态管理模式。 核心思想：把组件的共享状态抽取出来，以一个全局单例模式进行管理 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:10:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"五类对象 state：存储状态（变量）在组件中使用 $store.state.foo getters：对数据获取之前的再次编译，可以理解为 state 的 computed 属性。在组件中使用 $store.getters.fun() mutations：修改状态，并且是同步的。在组件中使用 $store.commit('funcName',params) 。它和组件中的自定义事件类似。 actions：异步操作。在组件中使用是 $store.dispath('funcName',params) modules：store 的子模块，为了开发大型项目，方便状态管理而使用的。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:10:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"简单配置 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:11:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"main.js Vuex 提供了一个从根组件向所有子组件，以 store 选项的方式 “注入” 该 store 的机制 //main.js内部对store.js的配置 import store from '\"@/store/store.js' //具体地址具体路径 new Vue({ el: '#app', store, //将store暴露出来 template: '\u003cApp\u003e\u003c/App\u003e', components: { App } }); ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:11:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"store/index.js import Vue from 'vue'; //首先引入vue import Vuex from 'vuex'; //引入vuex Vue.use(Vuex) export default new Vuex.Store({ state: { // state 类似 data //这里面写入数据 }, getters:{ // getters 类似 computed // 在这里面写个方法 }, mutations:{ // mutations 类似methods // 写方法对数据做出更改(同步操作) }, actions:{ // actions 类似methods // 写方法对数据做出更改(异步操作) } }) 或者 mport Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const state = {} const getters = {} const mutations = {} const actions = {} const store = new Vuex.Store({ state, getters, mutations, actions }) export default store; 但更建议的做法是：在单独的文件里写好每个组件的状态，最后统一在 index.js 中引入 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:11:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"项目结构 ├── index.html ├── main.js ├── api │ └── ... # 抽取出API请求 ├── components │ ├── App.vue │ └── ... └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:11:3","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"对象 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:12:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"state state 中存放状态对象 const state = { todos: [ { id: 1, title: \"Wake up\", done: false }, { id: 2, title: \"Learn\", done: false }, ] } 以形似 $store.state.todos 或 $store.state.todo.todos （如果此状态分模块单独存放的话）调用 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:12:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"getters getters 里存放着从 state 中派生出来的一些状态，类似于 computed，所以 getters 里的状态都具有相应的依赖值，而且以函数的形式进行定义 const getters = { doneTodos: state =\u003e { return state.tasks.filter(task =\u003e task.done) }, doneTodosNum: (state, getters) =\u003e { return getters.doneTodos.length } } 注意，getter 也可以接受其他 getter 作为第二个参数 通过属性访问 getter 会暴露为 store.getters 对象，可以以属性的形式访问这些值，如 $store.getters.doneTodoNum，不分组件 通过方法访问 也可以通过让 getter 返回一个函数，来实现给 getter 传参。在对 store 里的数组进行查询时非常有用 getTodoById: state =\u003e id =\u003e { return state.todos.find(todo =\u003e todo.id === id) } // 调用时 $store.getters.getTodoById(2) 注意，getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:12:2","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"mutations 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数 const mutations = { addTask(state, newTaskTitle) { console.log('add: ' + newTaskTitle); let newTask = { id: Date.now(), title: newTaskTitle, done: false, }; state.tasks.push(newTask); newTaskTitle = \"\"; }, } 要唤醒一个 mutation handler，需要以相应的 type 调用 store.commit 方法，如 $store.commit('mutations','Sleep')，不分组件 载荷 传入的额外参数称为载荷（payload） 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读 mutations: { increment (state, payload) { state.count += payload.amount } } // 调用时 store.commit('increment', { amount: 10 }) type 属性 提交 mutation 的另一种方式是直接使用包含 type 属性的对象 store.commit({ type: 'increment', amount: 10 }) Mutation 需遵守 Vue 的响应规则 既然 Vuex 的 store 中的状态是响应式的，那么当我们变更状态时，监视状态的 Vue 组件也会自动更新。这也意味着 Vuex 中的 mutation 也需要与使用 Vue 一样遵守一些注意事项： 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 使用 Vue.set(obj, 'newProp', 123), 或者 以新对象替换老对象。例如，利用对象展开运算符 (opens new window) 我们可以这样写： state.obj = { ...state.obj, newProp: 123 } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:12:3","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"actions Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } }, actions: { increment (context) { context.commit('increment') } } }) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters Action 通过 store.dispatch 方法触发，如 $store.dispatch('increment') Actions 支持同样的载荷方式和对象方式进行分发 // 以载荷形式分发 store.dispatch('incrementAsync', { amount: 10 }) // 以对象形式分发 store.dispatch({ type: 'incrementAsync', amount: 10 }) 使用参数结构定义 实践中，我们会经常用到 ES2015 的 参数解构 (opens new window) 来简化代码（特别是我们需要调用 commit 很多次的时候）： actions: { increment ({ commit }) { commit('increment') } } 异步触发 可以在 action 内部执行异步操作 actions: { incrementAsync ({ commit }) { setTimeout(() =\u003e { commit('increment') }, 1000) } } 来看一个更加实际的购物车示例，涉及到调用异步 API 和分发多重 mutation： actions: { checkout ({ commit, state }, products) { // 把当前购物车的物品备份起来 const savedCartItems = [...state.cart.added] // 发出结账请求，然后乐观地清空购物车 commit(types.CHECKOUT_REQUEST) // 购物 API 接受一个成功回调和一个失败回调 shop.buyProducts( products, // 成功操作 () =\u003e commit(types.CHECKOUT_SUCCESS), // 失败操作 () =\u003e commit(types.CHECKOUT_FAILURE, savedCartItems) ) } } ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:12:4","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"modules 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。例如： ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:12:5","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"mapState、mapGetters、mapActions ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:13:0","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"mapState 当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性，让你少按几次键： // 在单独构建的版本中辅助函数为 Vuex.mapState import { mapState } from 'vuex' export default { // ... computed: mapState({ // 箭头函数可使代码更简练 count: state =\u003e state.count, // 传字符串参数 'count' 等同于 `state =\u003e state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) { return state.count + this.localCount } }) } 当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 mapState 传一个字符串数组。 computed: mapState([ // 映射 this.count 为 store.state.count 'count' ]) ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/:13:1","tags":["前端","快速入门","Vue"],"title":"Vue2","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vue2/"},{"categories":["前端"],"content":"Vuetify ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:0:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"基本知识 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:1:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"引入 CDN \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003clink href=\"https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900\" rel=\"stylesheet\"\u003e \u003clink href=\"https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css\" rel=\"stylesheet\"\u003e \u003clink href=\"https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css\" rel=\"stylesheet\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui\"\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"app\"\u003e \u003cv-app\u003e \u003cv-content\u003e \u003cv-container\u003eHello world\u003c/v-container\u003e \u003c/v-content\u003e \u003c/v-app\u003e \u003c/div\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js\"\u003e\u003c/script\u003e \u003cscript src=\"https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js\"\u003e\u003c/script\u003e \u003cscript\u003e new Vue({ el: '#app', vuetify: new Vuetify(), }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 使用 Vue CLI vue create my-app # 切换到新项目目录 cd my-app 在项目目录中使用 vue add vuetify 或者使用Vue UI 安装 vue ui Electron 用法 要在 Electron 中使用 Vuetify ，需通过 Vue CLI 添加 electron-builder 插件。 # 安装 vue add electron-builder # 使用 yarn electron:build yarn electron:serve ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:1:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"布局 Vuetify有两个主要布局组件， v-app 和 v-main \u003ctemplate\u003e \u003cv-app\u003e \u003cv-main\u003e \u003c!-- page content --\u003e \u003crouter-view\u003e\u003c/router-view\u003e \u003c/v-main\u003e \u003c/v-app\u003e \u003c/template\u003e \u003cscript\u003e export default { name: \"App\", data: () =\u003e ({ // }), }; \u003c/script\u003e v-app v-app 组件是应用程序的根节点，直接替换默认的 Vue 入口 \u003cdiv id=\"app\"\u003e 在其中写入的元素，会作为布局的一部分 在组件或其他视图中，不需要引入 v-app 所有应用都需要 v-app 组件。 这是许多 Vuetify 组件和功能的挂载点，而且它必须是所有 Vuetify 组件的祖先节点 v-app 只应该在应用中渲染一次。 v-main v-main 组件是替换 main HTML 元素和应用程序的根节点 内容 的语义替代 常常在其中切换路由 它会根据你指定的应用组件的结构而动态调整大小 默认应用标记 只要设置 app 属性，你可以将布局元素放在任何地方 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:1:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"通用属性 Name Type Default Description color string undefined 详见 colors page app 相应的组件是应用布局的一部分 dense boolean flase 使组件更小 elevation number | string undefined 组件的海拔可接受 0 到 24 之间的值 disabled boolean false 移除组件的单击或 target 功能 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:1:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"应用组件 这些组件通常被用作布局元素。它们可以混合和匹配，并且每个特定组件在任何时候都只能存在一个 每一个应用组件都有一个指定的位置和优先级，影响布局系统中的位置 v-app-bar：总是放在应用顶部，优先级低于 v-system-bar。 v-bottom-navigation：总是放在应用底部，优先级高于 v-footer。 v-footer：总是放在应用底部，优先级低于 v-bottom-navigation。 v-navigation-drawer：可以放置在应用的左边或右边，并且可以配置在 v-app-bar 的旁边或下面。 v-system-bar：总是放在应用顶部，优先级高于 v-app-bar ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:2:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-app-bar v-app-bar 组件对于任何图形用户界面（GUI）都至关重要，因为它通常是站点导航的主要来源 App-bar 组件与 \u003ca href=“/components/navigation drawers”\u003e v-navigation-drawer 配合使用，可以在应用程序中提供站点导航 v-app-bar 组件用于应用程序范围内的操作和信息 API Name Type Default Description collapse boolean false 将工具栏置于折叠状态，以减小其最大宽度 collapse-on-scroll boolean false 滚动时将应用栏置于折叠状态 dense boolean false 将工具栏内容的高度降低到 48px（使用 prominent 属性时为 96px）。 子组件 v-app-bar-nav-icon 专门为与 v-toolbar 和 v-app-bar 一起使用而创建的样式化图标按钮组件 在工具栏的左侧显示为汉堡菜单，它通常用于控制导航抽屉的状态 \u003cv-app-bar-nav-icon\u003e\u003c/v-app-bar-nav-icon\u003e v-app-bar-title 修改过的 v-toolbar-title 组件 ，用于配合 shrink-on-scroll 属性使用 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:2:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-bottom-navigation ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:2:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-footer v-footer 组件用于显示用户可能想要从网站中的任何页面都能访问到的公共信息 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:2:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-navition-drawer （导航抽屉） 用于导航应用程序的组件 为了显示的目的，一些示例被包装在 v-card 元素中。 通常会把 v-navigation-drawer 组件作为 v-app 的直接子组件 使用 null 作为其 v-model 的初始值 将会将抽屉初始化为在移动设备上关闭，在桌面环境下打开。 通常使用 nav 属性将抽屉与 v-list 组件配对 API Name Type Default Description expand-on-hover boolean false 将抽屉折叠成 mini-variant，直到用鼠标悬停 temporary boolean false 临时抽屉位于其应用之上，并使用稀松布（叠加）来使背景变暗 permanent boolean false 不管屏幕尺寸如何，抽屉都可以看到 src string | object undefined 指定 v-img 作为组件背景。 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:2:4","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-system-bar ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:2:5","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"多功能组件 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:3:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-cards 卡中有4个基本组件。 v-card-title, v-card-subtitle, v-card-text 和 v-card-actions API Name Type Default Description hover boolean false 悬停时将应用 4dp 的海拔（默认值为 2dp） img string undefined 指定卡片的背景图。对于更高级的实现，建议您使用 v-img 组件 to string | object undefined 表示链接的目标路由 dense boolean false 将工具栏内容的高度降低到 48px rounded boolean | string undefined 对指定的组件应用 border-radius 样式 outlined boolean false 去除卡片的实心颜色并添加细边框 loading boolean | string false 显示线性进度条。可以是指定将哪种颜色应用于进度条的字符串（任何 material 色彩——主要（primary）, 次要（secondary）, 成功（success）, 信息（info），警告（warning），错误（error）），或者使用组件的布尔值 color（由色彩属性设置——如果它被组件支持的话）还可以是原色 子组件 v-card-actions 用于为卡片放置 动作 的容器，如 v-btn 或 v-menu v-card-text 主要用于卡片中的 文本内容 v-card-subtitle 为卡片字幕提供默认的 字体大小 和 填充 v-card-title 为卡片字幕提供默认的 字体大小 和 填充 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:3:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-tool-bar v-toolbar 组件对于任何 gui 都是至关重要的，因为它通常是站点导航的主要来源。 工具栏组件与 \u003ca href=\"/components/navigation drawers\"\u003e, v-navigation-drawer 和 v-card 配合使用非常有效 \u003ctemplate\u003e \u003cdiv\u003e \u003cv-toolbar\u003e \u003cv-app-bar-nav-icon\u003e\u003c/v-app-bar-nav-icon\u003e \u003cv-toolbar-title\u003eVuetify\u003c/v-toolbar-title\u003e \u003cv-spacer\u003e\u003c/v-spacer\u003e \u003cv-btn icon\u003e \u003cv-icon\u003emdi-export\u003c/v-icon\u003e \u003c/v-btn\u003e \u003c/v-toolbar\u003e \u003c/div\u003e \u003c/template\u003e API Name Type Default Description prominent boolean false 将工具栏内容的高度增加到 128px src string | object undefined 指定 v-img 作为组件背景 collapse boolean false 将工具栏置于折叠状态，以减小其最大宽度 dense boolean false 将工具栏内容的高度降低到 48px 子组件 v-toolbar-items 允许 v-btn 扩展全高度 v-toolbar-title 用于显示标题 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:3:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-list v-list 组件用于显示信息。 它可以包含头像、内容、操作、列表组标题等等。 列表以易于在集合中识别特定项目的方式显示内容。 它们为组织一组文本和图像提供了一致的样式 列表有三种基本形式。 单行 (默认), 双行 和 三行. 行声明指定了项目的最小高度，也可以使用相同的属性从 v-list 中进行控制 \u003ctemplate\u003e \u003cv-card class=\"mx-auto\" max-width=\"300\" tile \u003e \u003cv-list dense\u003e \u003cv-subheader\u003eREPORTS\u003c/v-subheader\u003e \u003cv-list-item-group v-model=\"selectedItem\" color=\"primary\" \u003e \u003cv-list-item v-for=\"(item, i) in items\" :key=\"i\" \u003e \u003cv-list-item-icon\u003e \u003cv-icon v-text=\"item.icon\"\u003e\u003c/v-icon\u003e \u003c/v-list-item-icon\u003e \u003cv-list-item-content\u003e \u003cv-list-item-title v-text=\"item.text\"\u003e\u003c/v-list-item-title\u003e \u003c/v-list-item-content\u003e \u003c/v-list-item\u003e \u003c/v-list-item-group\u003e \u003c/v-list\u003e \u003c/v-card\u003e \u003c/template\u003e API Name Type Default Description disabled boolean false 禁用所有子级的 v-list-item 组件 flat boolean false 删除活动的 v-list-item 上突出显示的背景 dense boolean false 减小列表块的最大宽度 rounded boolean false 圆角 v-list-item 边 three-line / two-line boolean false 增加三 \\ 两行的列表项高度 nav boolean false 另一种样式可以减小 v-list-item 的宽度并圆角化。 通常与 v-navigation-drawer 一起使用 子组件 v-list-item 装载列表项子组件 Name Type Default Description link boolean false 指定组件为链接。当使用 href 或 to属性时，这是自动的设置的。 to string | object undefined 表示链接的目标路由 href string | object undefined 指定组件为锚点并应用 href 属性。 v-list-item-content 装载文字组件 v-list-item-icon 装载图标组件 v-list-item-title 列表元素标题 v-list-item-subtitle 列表元素副标题 v-list-item-action 装载动作组件 v-list-item-avatar 装载头像类型的图片组件 img ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:3:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"小型组件 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:4:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-btn API Name Type Default Description outlined boolean false 使背景透明并使用薄边框 block boolean false 将按钮扩大到可用空间的 100％。 depressed boolean false 移除按钮的阴影效果 disabled boolean false 移除组件的单击或 target 功能 elevation number | string undefined 组件的海拔可接受 0 到 24 之间的值 exact boolean false 完全匹配链接。如果没有这个链接，‘/’ 将匹配每个路由 append boolean false 设置 append 属性总是会附加到当前路径的相对路径上。 fab boolean false Designates the button as a floating-action-button. Button will become round href string | object undefined 指定组件为锚点并应用 href 属性 icon boolean false Designates the button as icon. Button will become round and applies the text prop link boolean false 指定组件为链接。当使用 href 或 to 属性时，这是自动的设置的 plain boolean false 移除悬停在按钮上时应用的默认背景变化 value any undefined 控制组件可见还是隐藏 text boolean false Makes the background transparent ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:4:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-icon 可以在按钮内部使用 \u003cv-btn class=\"ma-2\" color=\"red\" dark \u003e Decline \u003cv-icon dark right \u003e mdi-cancel \u003c/v-icon\u003e \u003c/v-btn\u003e API Name Type Default Description small boolean false 使组件尺寸变的小 large boolean false 使组件尺寸变的巨大 x-small boolean false 使组件尺寸变的更小 x-large boolean false 使组件尺寸变的无比巨大 right boolean false 当按钮放置在另一个元素或文本的右边时，对按钮内的图标应用适当的间距 left boolean false 当按钮放置在另一个元素或文本的左边时，对按钮内的图标应用适当的间距 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:4:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-img API Name Type Default Description alt string undefined 屏幕阅读器的备用文本。 留空以装饰图像 aspect-ratio string | number undefined 计算为width/height，因此对于 1920x1080px 的图片，其值为 1.7778。 contain boolean false 防止图像不合适时被裁剪 x-large boolean false 使组件尺寸变的无比巨大 max-height number | string undefined 设定组件的最大高度 min-width number | string undefined 设定组件的最小宽度 src string | object undefined 图像的 URL。这个属性是强制性的 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:4:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-pagination v-pagination 组件用于分离长数据集，以便用户消化信息。 根据提供的数据量，分页组件将自动缩放 分页默认根据设置的 length 属性显示页数，两边有 prev 和 next 按钮帮助导航 API Name Type Default Description length number 0 分页组件的长度 prev-icon string ‘$prev’ 指定用于上一个图标的图标 next-icon string ‘$next’ 指定用于下一个图标的图标 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:4:4","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-snackbar v-snackbar 以最简单的形式向用户显示一个临时且可关闭的通知 API Name Type Default Description timeout number | string 5000 等待snackbar 自动隐藏的时间 (毫秒) 。使用 “-1” 保持无限期打开 (版本 \u003c 2 的 0 )。 建议这个数字在 4000 和 10000 之间。此属性的更改将重置超时 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:4:5","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"大型组件 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:5:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-date-picker API Name Type Default Description max string undefined 允许的最大 日期/月份（ISO 8601格式） min string undefined 允许的最小 日期/月份（ISO 8601格式） multiple boolean false 允许选择多个日期 picker-date string undefined 显示 年/月 type string ‘date’ 确定选择器的类型 - 日期选择器的 date ，月选择器的 month scrollable boolean false 允许通过鼠标滚动更改显示的月份 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:5:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-time-picker API Name Type Default Description format string ‘ampm’ 定义在选择器中显示的时间格式。可用的选项是 ampm 和 24hr scrollable boolean false 允许通过鼠标滚动更改 小时/分钟 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:5:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"表单组件 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-text-field 使用 v-model 绑定输入值，同时可以设置默认值 API Name Type Default Description label string undefined 设置输入标签 filled boolean false 应用替代填充输入样式 placeholder string undefined 设置输入的占位符文本 hint string undefined 提示文本 counter boolean | number | string undefined 为输入长度创建一个计数器，如果未指定数字，则默认为25，不会应用任何验证 rules array [] 接受不同类型的 function, boolean 和 string 。 函数传递输入值作为参数，必须返回 true / false 或包含错误消息的 string 。 如果函数返回 (或数组包含的任何值) false 或 string ，输入字段将输入错误状态 value any undefined 输入的值 disabled boolean false 禁用输入 rounded boolean false 向输入添加边框半径 readonly boolean false 将输入设置为只读状态 hide-details boolean | string undefined 隐藏提示和验证错误。当设置为 auto 时，只有在有信息（提示、错误信息、计数器值等）要显示时，才会显示信息 persistent-hint boolean false 强制提示总是可见的 prepend-icon string undefined 在组件前添加一个图标，使用与 v-icon 相同的语法 prepend-inner-icon string undefined 在组件的输入中添加一个图标，使用与 v-icon 相同的语法 prefix string undefined 显示前缀 suffix string undefined 显示后缀 single-line boolean false 标签在 focus/dirty 上不移动 type string ’text' 设置输入类型 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-radio 单选按钮。虽然 v-radio 可以单独使用，但它最好与 v-radio-group 一起使用。 在 v-radio-group 上使用 v-model，可以访问组内所选单选按钮的值 API Name Type Default Description disabled boolean false 移除组件的单击或 target 功能 readonly boolean false 将输入设置为只读状态 value any undefined 在组中选择组件时使用的值。如果没有提供，则使用 index label string undefined 设置输入标签 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-checbox v-checbox 组件为用户提供了在两个不同的值之间选择的能力。 它们与开关(switch) 非常相似，可用于复杂的表格和核对清单 API Name Type Default Description append-icon string undefined 在组件上附加一个图标，使用与 v-icon 相同的语法 disabled boolean false 禁用输入 hint string undefined 提示文本 label string undefined 设置输入标签 input-value any undefined v-model 的绑定值 v-simple-checbox ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-select 下拉框 API Name Type Default Description items array [] 可以是对象数组或字符串数组。当使用对象时，将寻找文本和值字段。 这可以使用 item-text 和 item-value 属性来更改 disabled boolean false 禁用输入 hint string undefined 提示文本 label string undefined 设置输入标签 item-text string | array | function text 设置items’属性的文本值 item-value string | array | function value 设置 items 的值的属性 prepend-icon string undefined 在组件前添加一个图标，使用与 v-icon 相同的语法 multiple boolean false 多选，接受数组作为值 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:4","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-switch API Name Type Default Description input-value any undefined v-model 的绑定值 flat boolean false 显示没有海拔的组件 inset boolean false 扩展 v-switch 轨迹以包含缩略图 value any undefined 输入的值 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:5","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-slider API Name Type Default Description max number | string 100 设置允许的最大值 min number | string 0 设置允许的最小值 prepend-icon string undefined 在组件前添加一个图标，使用与 v-icon 相同的语法 step number | string 1 如果大于0，则为滑块上的点设置步骤间隔 track-color string undefined 设置刻度线颜色 thumb-color string undefined 设置拇指和拇指标签颜色 thumb-label boolean | string undefined 显示拇指标签 label string undefined 设置输入标签 value any undefined 输入的值 thumb-label boolean | string undefined 显示拇指标签 ticks boolean | string false 显示刻度线。如果 true ，使用滑块时将显示刻度线。如果设置为 'always' ，它总是显示刻度线 inverse-label boolean false 使用 rtl 反转标签位置 tick-labels array [] 与 Array 一起提供时，将尝试按索引顺序将标签映射到每个步骤 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:6","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-file-input v-file-input组件的核心是一个基于 v-text-field 拓展的基本容器 使用 accpect 属性，v-file-input组件可以选择接收你想要的媒体格式/文件类型，如 accept=\"image/png, image/jpeg\" 当 show-size 属性和 counter 一同启用时，会下输入框下方显示文件总数和大小 API Name Type Default Description append-icon string undefined 在组件上附加一个图标，使用与 v-icon 相同的语法 clearable boolean true 添加清除已输入内容功能，默认图标是Material Design Icons mdi-clear truncate-length number | string 22 在用省略号截断之前的文件名的长度 label string undefined 设置输入标签 loading boolean | string false 显示线性进度条。可以是指定将哪种颜色应用于进度条的字符串（任何 material 色彩——主要（primary）, 次要（secondary）, 成功（success）, 信息（info），警告（warning），错误（error） multiple boolean false 将 multiple 属性添加到输入中，允许选择多个文件 chips boolean false 改变一个已选择项为小纸片（chips）的显示方式 show-size boolean | number false 设置所选文件的显示大小 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:7","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-textarea v-textarea 最简单的形式是多行文本字段，对于大量文本非常有用 API 与 v-text-feild 类似 Name Type Default Description no-resize boolean false 移除调整大小的句柄 rows number | string 5 默认行数 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:8","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-form ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:6:9","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"网格系统 （Grid System） ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:7:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"7.1 v-container v-container 提供了将你的网站内容居中和水平填充的功能。 你还可以使用 fluid 属性将容器在所有视口和设备尺寸上完全扩展。 fill-height 将使整个内容 相对于 page 居中 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:7:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-row v-row 是 v-col 的容器组件。 它使用 flex 属性来控制其内栏的布局和流 Name Type Default Description align string undefined 应用 align-items css 属性。可用的选项是 start, center, end, baseline 和 stretch justify string undefined 应用 justify-content css 属性。可用选项是 start, center, end, space-between 和 space-around ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:7:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-col v-col 包裹内容，它必须是 v-row 的直接子代 Name Type Default Description dense boolean false 减少 v-col 之间的距离。 cols boolean | string | number false 设置组件扩展的默认列数。可用的选项是 1 -\u003e 12 和 auto 。 md boolean | string | number false 更改中等和更大断点上的列数，其他断点同理 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:7:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"v-spacer v-spacer 是一个基本而又通用的间隔组件，用于分配父子组件之间的剩余宽度 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:7:4","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"组 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:8:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"样式 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:9:0","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"颜色 每种颜色都会被转换为 background 和 text 变体 \u003ctemplate\u003e \u003cdiv class=\"purple darken-2 text-center\"\u003e \u003cspan class=\"white--text\"\u003eLorem ipsum\u003c/span\u003e \u003c/div\u003e \u003c/template\u003e 改变背景颜色 red 改变文本颜色 text--red 改变背景明暗 lighten-4 改变文本明暗 text--darken-2 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:9:1","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"文本 字体强调 \u003ctemplate\u003e \u003cdiv\u003e \u003cp class=\"font-weight-black\"\u003e Black text. \u003c/p\u003e \u003cp class=\"font-weight-bold\"\u003e Bold text. \u003c/p\u003e \u003cp class=\"font-weight-medium\"\u003e Medium weight text. \u003c/p\u003e \u003cp class=\"font-weight-regular\"\u003e Normal weight text. \u003c/p\u003e \u003cp class=\"font-weight-light\"\u003e Light weight text. \u003c/p\u003e \u003cp class=\"font-weight-thin\"\u003e Thin weight text. \u003c/p\u003e \u003cp class=\"font-italic\"\u003e Italic text. \u003c/p\u003e \u003c/div\u003e \u003c/template\u003e 字体大小 格式 .text-{value} 用于 xs .text-{breakpoint}-{value} 用于 sm, md, lg 和 xl value h1 h2 h3 h4 h5 h6 subtitle-1 subtitle-2 body-1 body-2 button caption overline 文本对齐 自动对齐 .text-justify 指定方向对齐 .text-left .text-right .text-center .text-{breakpoint}-{direction} 不透明度 text--primary 与默认文本具有相同的不透明度。 text--secondary 用于提示和辅助文本。 text--disabled 用于去除强调文本 装饰线 移除文本装饰线 .text-decoration-none 添加上划线 .text-decoration-overline 添加下划线线 ``.text-decoration-underline` 添加删除线 ``.text-decoration-line-through` 转换大小写 .text-lowercase：小写 .text-uppercase：大写 .text-capitalize：单词首字母大写 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:9:2","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"间距 格式：{property}{direction}-{size} property 应用间距类型: m - 应用 margin p - 应用 padding direction 指定了该属性所应用的侧边: t - 应用 margin-top 和 padding-top 的间距 b - 应用 margin-bottom 和 padding-bottom 的间距 l - 应用 margin-left 和 padding-left 的间距 r - 应用 margin-right 和 padding-right 的间距 s - 应用 margin-left/padding-left (LTR模式) 和 margin-right/padding-right(RTL模式) 的间距 e - 应用 margin-right/padding-right (LTR模式) 和 margin-left/padding-left(RTL模式) 的间距 x - 应用 *-left 和 *-right 的间距 y - 应用 *-top 和 *-bottom 的间距 a - 在所有方向应用该间距 size 以4px增量控制间距属性: 0 - 通过设置为 0 来消除所有 margin 或 padding. 1 - 设置 margin 或 padding 为 4px 2 - 设置 margin 或 padding 为 8px 3 - 设置 margin 或 padding 为 12px 4 - 设置 margin 或 padding 为 16px 5 - 设置 margin 或 padding 为 20px 6 - 设置 margin 或 padding 为 24px 7 - 设置 margin 或 padding 为 28px 8 - 设置 margin 或 padding 为 32px 9 - 设置 margin 或 padding 为 36px 10 - 设置 margin 或 padding 为 40px 11 - 设置 margin 或 padding 为 44px 12 - 设置 margin 或 padding 为 48px 13 - 设置 margin 或 padding 为 52px 14 - 设置 margin 或 padding 为 56px 15 - 设置 margin 或 padding 为 60px 16 - 设置 margin 或 padding 为 64px n1 - 设置 margin 为 -4px n2 - 设置 margin 为 -8px n3 - 设置 margin 为 -12px n4 - 设置 margin 为 -16px n5 - 设置 margin 为 -20px n6 - 设置 margin 为 -24px n7 - 设置 margin 为 -28px n8 - 设置 margin 为 -32px n9 - 设置 margin 为 -36px n10 - 设置 margin 为 -40px n11 - 设置 margin 为 -44px n12 - 设置 margin 为 -48px n13 - 设置 margin 为 -52px n14 - 设置 margin 为 -56px n15 - 设置 margin 为 -60px n16 - 设置 margin 为 -64px auto - 设置间距为 auto ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:9:3","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["前端"],"content":"显示辅助 设置显示元素 格式：hidden-{breakpoint}-{condition} condition： only - 只在某个指定断点隐藏元素 and down - 在指定的断点和以下隐藏元素, 从 sm 到 lg 断点 and up - 在指定的断点和以上隐藏元素, 从 sm 到 lg 断点 https://vuetifyjs.com/zh-Hans/styles/display/#section-53ef89c16027 ","date":"2021-11-30","objectID":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/:9:4","tags":["归档","前端","快速入门","Vue"],"title":"Vuetify","uri":"/Notes/posts/frontend/%E6%A1%86%E6%9E%B6/vuetify/"},{"categories":["Linux"],"content":"vi 编辑器 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:0:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"启动 vi [选项] [filename] ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:1:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"工作模式 1、命令模式：键盘接受的任何字符都被当作命令来解释，不会出现在屏幕上。 2、输入模式（编辑模式）：输入的任何字母都被当做文件内容显示在屏幕上； 3、底行命令模式：在屏幕底部显示“：”，等待用户输入命令。 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:2:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"进入插入入模式的方法（从命令模式） i 从当前的光标位置，开始输入字符 I 光标移动到当前行的行首，开始输入字符 a 从当前的光标的下一个位置，开始输入字符 A 光标移动到当前行的行尾，开始输入字符 o 光标所在行之下新增一行 O 光标所在行之上新增一行 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:3:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"删除字符（命令模式） x：删除光标所在的字符 nx：从光标开始，向右删除n个字符 X：删除光标前面的那个字符 nX：从光标之前的那个字符开始，向左删除n个字符 dd：删除光标所在的整行 D：从光标开始删除到行尾 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:4:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"查找字符串（命令模式） / 字符串： 光标从当前位置开始向文件尾部查找，如果找到，光标停留在该 字符串的首字母上； ？字符串：光标从当前位置开始向文件 头部查找，如果找到，光标停留该字 符串的首字母上； n: 继续查找满足条件的字符串 N：改变方向查找，继续查找满足条件的字符串 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:5:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"其他命令模式命令 1、u : 撤销上一步操作 2、. :重复上一步操作 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:6:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"文本块操作（底行命令模式） : set nu //每一行前面出现行号 set nonu //不显示行号 n1,n2 co n3 //将从n1行-n2行之间(包括n1,n2行本身）的所有文本复制到第n3行之下 n1,n2 m n3 //将从n1行-n2行之间(包括n1,n2行本身）的所有文本移动到第n3行之下 n1,n2 d //删除从n1行-n2行之间(包括n1,n2行本身）的所有文本 n1,n2 s/字符串1/字符串2/g //将从n1行-n2行之间(包括n1,n2行本身）的所有字符串1， 用字符串2替换 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:7:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"保存和退出（底行命令模式） w 文件路径：保存文件 wq：保存文件并退出编辑器 q：退出编辑器 q!: 不保存文件直接退出编辑器 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:8:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"编写C语言程序 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:9:0","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"gcc 编译器 功能：调用 C 编译器，执行该命令后，将完成预处理、编译、优化、连接并最终生成可执行代码。 格式：gcc [option] file-list 源代码文件要求带扩展名（*.c） 可执行代码默认存储在a.out文件中 Linux操作系统 4 常用选项 -ansi ：只支持 ANSI 标准的 C 语法 -c：只生成目标文件（扩展名为 .o）,不进行连接 -o \u003cfile\u003e：指定可执行文件名为 \u003cfile\u003e，不是默认的a.out -O[level]:进行优化 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:9:1","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"编译步骤 vi hello.c // 用 vi 编辑器编写程序代码，存储成*.c文件（hello.c） gcc hello.c // 用 gcc 不带参数编译 或 gcc -o hello hello.c //用gcc带参数编译 ls // 用 ls 查看可执行文件 a.out ./a.out // 执行该文件 或 ./hello //执行该文件 ","date":"2021-11-27","objectID":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/:9:2","tags":["Linux","Vim"],"title":"Linux vi 编辑器","uri":"/Notes/posts/linux/vi-%E7%BC%96%E8%BE%91%E5%99%A8/"},{"categories":["Linux"],"content":"基础 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:0:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"目录结构 Linux 文件系统是一个目录树的结构，文件系统结构从一个根目录开始，根目录下可以有任意多个文件和子目录，子目录中又可以有任意多个文件和子目录 bin：存放二进制可执行文件(ls,cat,mkdir 等) boot：存放用于系统引导时使用的各种文件 dev：用于存放设备文件 etc：存放系统配置文件 home：存放所有用户文件的根目录 lib：存放跟文件系统中的程序运行所需要的共享库及内核模块 mnt:系统管理员安装临时文件系统的安装点 opt:额外安装的可选应用程序包所放置的位置 proc:虚拟文件系统，存放当前内存的映射 root：超级用户目录 sbin：存放二进制可执行文件，只有 root 才能访问 tmp：用于存放各种临时文件 usr：用于存放系统应用程序，比较重要的目录 /usr/local——本地管理员软件安装目录 var：用于存放运行时需要改变数据的文件 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:1:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"文件类型 普通文件 - 目录 d 符号链接 l 硬链接： 与普通文件没什么不同，inode 都指向同一个文件在硬盘中的区块 软链接： 保存了其代表的文件的绝对路径，是另外一种文件，在硬盘上有独立的区块，访问时替换自身路径 (可理解为快捷方式)。 字符设备文件 c 块设备文件 b 套接字 s 命名管道 p ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:2:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"命令 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:3:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"格式 cmd [options] [arguments] 命令名称 [-选项] [参数] 命令名：描述命令功能的英文单词或缩写，必不可少； [-选项]：执行该命令的限定参数或功能参数； [参数]：执行该命令的所必需对象，如文件、目录等； 选项和参数都作为 Shell 命令执行时的输入，它们之间用空格分隔开 一般来说，后面跟的选项如果单字符选项前使用一个减号 -；单词选项前使用两个减号 -- [ ] 表示语法上可有可无 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:3:1","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"可执行文件的分类 内置命令：出于效率的考虑，将一些常用命令的解释程序构造在 Shell 内部。 外置命令：存放在 /bin、/sbin 目录下的命令 实用程序：存放在 /usr/bin、/usr/sbin、/usr/share、/usr/local/bin 等目录下的实用程序 用户程序：用户程序经过编译生成可执行文件后，可作为 Shell 命令运行 Shell 脚本：由 Shell 语言编写的批处理文件，可作为 Shell 命令运行 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:3:2","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"登陆操作 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:4:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"登陆提示信息的意义 [root@localhost~ ]# root：当前用户的账号 localhost：主机名 ~ ：用户当前所在的目录。 如果现在要创建一个文件的话，会被保存在这个目录下。 ~ 为用户的主目录，即专属于该用户的目录 root 用户的主目录为：/root Linux 系统每创建一个普通用户，就会在 /home 这个目录下创建一个对应的 目录，并且是以用户名命名的。 比如：普通用户 user 的主目录是：/home/user ；普通用户 test 的主目录为：/home/test #：root 用户的命令提示符 $：普通用户的命令提示符 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:4:1","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"命令 pwd （print working dirctory） 功能：显示用户当前所处的工作目录（当前工作目录） 格式：pwd [选项] man （manual） 功能：显示命令的使用说明手册。 格式：man 命令名 通常 man 显示的命令帮助格式包含以下4部分： NAME : 命令名称； SYNOPSIS : 语法大纲； DESCRIPTION : 描述说明； OPTIONS : 选项 man 命令查询控制手册时,给出了一些功能键设置： 空格键 ：显示手册页的下一屏 回车键 ：一次滚动手册页的一行 q 键 ：退出 man 命令 cat （concatenate） 功能一 功能：显示文件信息，可与输入输出重定向配合使用。 格式：cat [选项] fileName 常用选项 -n：由 1 开始对所有输出行进行编号显示。 实例 查看刚刚的 record 文件 $ cat record 对 /etc/passwd 文件进行编号显示 $ cat –n /etc/passwd 功能二 功能：建立小型文件 格式 cat \u003e fileName … // 输入信息 Ctrl+d // 存盘并退出 实例 建立一个名为 m1 的文件，内容为：echo cat is not a cat! $ cat \u003e m1 //创建文件 echo cat is not a cat! Ctrl+d $ cat m1 //显示文件 功能三 功能：合并文件。 格式：cat file1 file2 \u003e newFileName 实例：将 m1,m2 合并为 m3 建立一个名为m1的文件，内容为：echo cat is not a cat! 建立一个名为m2的文件，内容为：date 的结果。 $ date \u003e m2 //创建文件 $ cat m2 //显示文件 $ cat m1 m2 \u003em3 //合并文件 $ cat m3 //显示文件 more 功能：分屏显示文件内容。首先显示一屏后若还有内容，按 Enter 键再显示下 一行，按 Space 键显示下一屏，按 Q 退出。 格式：more 文件路径 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:4:2","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"通配符与特殊符号 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:5:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"通配符 *：匹配任何字符和任何数目的字符 ?：匹配单一数目的任何字符 []：匹配 [] 之内的任意一个字符，[] 指定一个符号的取值范围 [!]：匹配除了 [!] 之外的任意一个字符，! 表示非的意思 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:5:1","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"例 列出 /etc 目录下的所有扩展名为 conf 的配置文件 $ ls /etc/*.conf 列出 /etc 目录下所有文件名由 3 个字母构成的配置文件 $ ls /etc/???.conf 列出 /etc 目录下所有以 a、b 或者 c 开头的配置文件 $ ls /etc/[abc]*.conf $ ls /etc/[a-c]*.conf $ ls /etc/[!d-z]*.conf ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:5:2","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"特殊符号 分号 ; 用于隔开多条命令并使它们能够连续执行。 输出的结果是多个命令连续执行后的输出结果 符号 \u0026 用于指定当前命令在后台执行 实例 拷贝一个大文件 file 时需要占用较长的时间，将拷贝工作放到后台执行 执行时返回的显示结果是该命令的作业号和进程 PID 号 执行完毕会在前台提示 $ cp file /tmp/filetmp \u0026 转移符号 \\ 通配符和特殊符号在 shell 中被解释为某种含义和功能，当要表示这些符号的本身时，需要使用转义符号 \\ 实例 $ echo \\\\ $ echo \\\u0026 $ echo \\*\\\u0026 管道 | $ 命令1 | 命令2 | 命令3 | … | 命令n 将多个简单的命令集合在一起，用以完成较复杂的功能 实例 $ cal | wc -l // 对当前月的日历输出结果进行行数的统计 $ ls -al /etc | more //由于/etc目录下的文件和子目录的数目很多，将 结果传送给more分页显示。 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:5:3","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"重定向 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:6:0","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"概念 Shell 中不使用系统的标准输入、标准输出或者标准错误输出端口，重新进行指定的情况称为输入输出重定向 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:6:1","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"输出重定向、附加输出重定向 目的：保存命令输出的结果 格式 输出重定向：命令 \u003e 重定向文件（覆盖原文件的内容） 附加输出重定向：命令 » 重定向文件（在指定文件的末尾追加命令结果） 例 date \u003e record #将date的结果重定向输出到record文件中 who \u003e\u003erecord #将who的结果附加重定向输出到record中 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:6:2","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"输入重定向 目的：把命令的标准输入重新定向到指定文件中 格式：命令 \u003c 重定向文件 例 用输入重定向的方式查看 record 的内容。 cat \u003c record // 与 cat record 命令完全相同 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:6:3","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["Linux"],"content":"错误输出重定向 目的：保存错误内容 格式：命令 2\u003e 重定向文件 例 敲一个错误的命令，ls lsm，通过错误输出重定向，将错误信息保存到文件 err 中 ls lsm //输入错误的命令 ls lsm 2\u003e err //错误输出重定向 cat err //查看err内容 ","date":"2021-11-27","objectID":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/:6:4","tags":["Linux"],"title":"Linux 基础","uri":"/Notes/posts/linux/%E5%9F%BA%E7%A1%80/"},{"categories":["专业课"],"content":"题型 填空 10-12 分，概念 单选 20 分 综合大题 4道，其中 2-3 小题 算法设计，写出复杂度的递推公式（分治法），并推导；动态方程/递归方程 程序填空（回溯法） 手工操作题（分支限界法：解空间树、队列变化次序……） 算法设计与分析 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:0:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"认识 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:1:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"基本概念 算法 有穷规则的集合，其中的规则规定了解决某一特殊问题的一系列运算；计算序列 特点 输入（零个或多个） 输出（至少一个） 确定性 有限性（执行次数、执行时间） 可行性 程序：数据结构 + 算法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:1:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"P 问题与 NP 问题 （会考概念） P 问题：Polynomial Problem，多项式时间复杂度内能解的问题 NP 问题：Non-deterministic Polynomial Problem，非确定性多项式时间能解的问题，可以在多项式时间复杂度内对猜测进行验证 NPC 问题：NP-Complete，多项式时间内可转化为任意 NP 问题，可视为代表性 NP 问题 P 问题是确定计算模式下的易解问题，NP 问题是非确定性计算模式下的易验证问题，$P \\subseteq NP$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:1:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"算法渐进复杂性 粗略理解：取 T(n) 的高阶，即为渐进表达式 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:1:3","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"增长的阶 用增长的阶来衡量算法复杂度 g(n) 比 f(n) 结构要简单，可以近似代表 f(n) 符号意义 （看） 复杂性阶的理解举例 理解 各记号在等式和不等式中的意义 性质 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:1:4","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"递归 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:2:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"定义 递归算法：一个直接或间接地调用自身的算法 递归函数：使用函数自身给出定义的函数 递归方程：对于递归算法，一般可把时间代价表示为一个递归方程 解递归方程最常用的方法是进行递归扩展 边界条件 递归关系 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:2:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"例 初始条件与递归方程是递归函数的两个要素 例 1 Ackerman 排列问题 Perm() 为便于理解，以 {1,2,3,4,5,6} 为例： 1 2 3 4 5 6 –\u003e 1 2 3 4 5 6 –\u003e 1 2 3 4 5 6 –\u003e 1 2 3 4 5 6 –\u003e 1 2 3 4 5 6 –\u003e 1 2 3 4 5 6 –\u003e 1 2 3 4 6 5 –\u003e 1 2 3 4 6 5 template\u003cclass Type\u003e void Perm(Type list[],int k, int m){ //产生list[k:m]的所有排列 if(k==m){ //只剩下一个元素，到达递归的最底层 for (int i=0;i\u003c=m;i++) cout \u003c\u003c list[i]; cout \u003c\u003c endl; } else{ //还有多个元素待排列，递归产生排列 for (int i=k;i\u003c=m;i++) { Swap(list[k],list[i]); Perm(list,k+1,m); Swap(list[k],list[i]); //复位，保证所有元素都能依次做前缀 } } } template\u003cclass Type\u003e inline void Swap(Type \u0026a, Type \u0026b) { Type temp=a; a = b; b = temp; } 整数划分问题 q(n,1)=1，n≥1。当最大加数 n~1~ 不大于 1 时，任何正整数n只有一种划分形式，即 n=1+1+…+1 q(n,m)=q(n,n)，m≥n。最大加数 n~1~ 不能大于 n。 q(n,n)=1+q(n,n-1)。正整数 n 的划分由 n~1~=n 的划分和 n~1~≤n-1 的划分组成；n~1~=n 时，划分仅有一种。 q(n,m-1)+q(n-m,m)，n\u003em\u003e1。正整数 n 的最大加数 n~1~ 不大于 m 的划分由 n~1~=m 的划分和 n~1~≤m-1 的划分组成。 hanoi 汉诺塔问题 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:2:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"原理 也就是递归调用工作栈 递归程序逐层调用需要分配存储空间，一旦某一层被启用，就要为之开辟新的空间。而当一层执行完毕，释放相应空间掉，退到上一层。 递归程序逐层调用需要记录调用/返回地址（函数指针）及相关输入，返回参数。 递归程序逐层调用及返回时需要建立控制转移机制。 递归优点：结构清晰，可读性强 递归缺点：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多 解决方法：在递归算法中消除递归调用，使其转化为非递归算法。可采用一个用户定义的栈来模拟系统的递归调用工作栈。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:2:3","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"递归程序代价 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:2:4","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"分治 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"定义 基本思想 将问题分解成若干子问题，然后求解子问题。 子问题较原问题更容易些，由此得出原问题的解，就是所谓的“分而治之”的意思。 分治策略可以递归进行，即子问题仍然可以用分治策略来处理，但最后的问题要非常基本而简单。 步骤 把问题分解为 k 个性质相同、但规模较小的子问题，并求解这些子问题。 逐步合并子问题的解，直到获得原问题的解 算法构架 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"代价分析 （复杂度的推导必考） ==递归式== 参数 m：子问题总数量 k：一次分解的子问题数量（一般小于等于 m） n/m：单个子问题的规模 f(n)：merge 的时间复杂度 推导式 ==又可写成== $$ T(N)= \\begin{cases} \\ O(N^{log_ba}),\\ a\u003eb^k \\ \\ O(N^klog_bN),\\ a=b^k \\ \\ O(N^k),\\ a\u003cb^k \\ \\end{cases}\\ \\ 之于 \\ T(N)=aT(N/b)+N^k $$ ==推导== ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"二分搜索技术 给定已按升序排好序的 n 个元素 a[0:n-1]，现要在这 n 个元素中找出一特定元素 x 基本思想 算法实现 复杂性 做时间复杂度的推导必考 $$ T(n)=T(n/2)+1 $$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:3","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"大整数的乘法 设计一个有效的算法，可以进行两个 n 位大整数的乘法运算 小学生算法 一位位乘 复杂度为 O(n^2^) 一种毫无进步的分治 另一种分治 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:4","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"strassen 矩阵乘法 暂且考虑方阵相乘 传统方法 垃圾的分治方法 好分治 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:5","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"棋盘覆盖 不考 基本思想 算法实现 def chess_board(tr:int, tc:int, dr:int, dc:int, size:int): \"\"\" 棋盘覆盖问题 param tr: 棋盘起始行坐标 param tc: 棋盘起始列坐标 param dr: 特殊方格的行号 param dc: 特殊方格的列号 param size: \"\"\" if size==1: return t= s=size/2 # 分割棋盘 if dr\u003ctr+s and dc\u003ctc+s 复杂性 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:6","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"合并排序 就是归并排序 基本思想 递归算法 实现 复杂性 非递归的分治算法 非递归：自底向上 递归：自顶向下 实现 复杂性 （长为 n/2） 复杂性 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:7","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"快速排序 设基准 -\u003e 划分子列 -\u003e 递归 算法实现 graph LR start[开始]--\u003econ1{\"i \u003c j?\"} con1 -- NO --\u003e recurve[\"结束一次快排\"] con1 -- YES --\u003e con2{\"Elem[i] \u003e Elem[j]?\"} con2 -- YES --\u003e exchange[\"i,j 值互换\"] exchange ---\u003e pivot{\"基准位置?\"} con2 -- NO --\u003epivot pivot -- \"前\" --\u003e j[\"j--\"] pivot -- \"后\" --\u003e i[\"i++\"] i --\u003e finish[\"下次循环\"] j --\u003e finish finish --\u003e con1 复杂度 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:8","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"线性时间选择 一个结论：一般的选择问题可以在 O(n) 时间内得到解决 模仿快排的、很拉的分治算法 使用到类似于快排的算法 改进的分治 思想：选择一个有用的基准值，让每一次递归都有效，能大概剔除 n/4 的规模 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:9","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"最接近点对问题 不会出大题 一维 二维 分治 推广到二维 算法 第四部中的 X 与 Y 只要排一次序就行 复杂度 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:10","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"循环赛程表问题 不考 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:3:11","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"动态规划 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"定义 最优子结构性质 重叠子问题性质 基本思想 将问题分解成若干子问题，然后求解子问题。 子问题不是互相独立的 方法 自底向上求解 备忘录：递归，自顶向下 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"基本要素 算法目标 求解有某种最优性质的问题（离散型）。它可能有许多可行解，希望找到具有最优值的解。 算法思想 动态规划算法将待求解问题分解成若干子问题，先求解子问题 从这些子问题的解得到原问题的解。这些子问题往往不互相独立 分解时得到的子问题数目可能很多，有些子问题被重复计算了很多次 求解方法 自底向上方式、自上而下方式 采用备忘录方法：求解过程中需保持已经解决的子问题的解，而在需要时再找出已求得的解，就可以避免大量的重复计算，节省时间。动态规划法用表记录所有已解的子问题的答案。不管该子问题以后是否会被用到，只要它被计算过，就将其结果填入表中。 动态规划中的概念、名词术语 概念、名词术语 解释 阶段 把问题分成几个相互联系的有顺序的几个环节 状态 某一阶段的触发位置称为状态。通常一个阶段包含若干状态。 决策 从某阶段的一个状态演变到下一阶段某状态的选择。特点：前一阶段的终点是后一阶段的起点，前一阶段的决策影响后一阶段的状态。 策略 由考生到终点的全过程中，由每段决策组成的决策序列。 状态转移方程 描述由 k 阶段到 k+1 阶段状态的演变规律称为状态转移方程（用数学形式表达） 目标函数与最优化概念 目标函数是衡量多阶段决策过程优劣的准则。最优化概念是在一定条件下找到一个途径，按照题目具体性质所确定的运算以后，使全过程的总效益达到最优。 动态规划 在多阶段决策问题中，各阶段采取的决策依赖于目前状态，并引起状态的转移以求得最优化过程。 最佳原理：==一个最优化策略的子策略总是最优的== 动态规划的求解步骤： 找出最优解的性质，并刻画其结构特征 递归地定义最优值（写出动态规划方程） 以自底向上（或自顶向下）的方式计算出最优值 根据计算最优值得到的信息，构造一个最优解 动态规划的基本要素 （填空、简答考） 动态规划算法的有效性依赖于问题本身所具有的两个重要性质：最优子结构性质和子问题重叠性质。 最优子结构 当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。 证明用反证法： 先假设由问题的最优解导出的子问题的解不是最优的，然后再设法证明在这个假设下可构造出一个比原问题最优解更好的解，从而导致矛盾。 构建一个问题的最优解 $\\pi$ 构建其子问题的一个解（一个递归式），接下来开始证明这个解是最优解 如果这个解不是子问题的最优解，则满足某一个不等式，使得另有一个解 $\\pi’$ 成为子问题的最优解 这个解 $\\pi’$ 加上第一个元素后将会成为整个问题的最优解 这与 $\\pi$ 是问题的最优解矛盾，不等式推翻，证明最优子结构性质 重叠子问题 在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。 动态规划利用子问题的重叠性质，对每个子问题只解一次，并将解保存在一个表格中，在以后尽可能多利用这些子问题的解。 特征：不同的子问题个数随问题的大小呈多项式增长而非指数增长。 动态规划法与分治策略 共性：都通过子问题求解原问题 方法：分治法是把一个规模为n的问题分成多个与原问题类型相同的较小的子问题，通过对子问题的求解，并把子问题的解合并起来，构造出整个问题的解；动态规划法先求子问题的解，通过求解子问题，构造原问题的解 ==差异==： 独立性 分治法各子问题互相独立，动态规划法的各子问题不独立 子问题数目 动态规划法中设计的子问题，不独立的有很多，而独立的应只有多项式级； 分治法设计的子问题数一般达指数级 局部最优 动态规划法把问题分成许多子问题，每个子问题的解都是局部最优；分治法未必考虑最优性 备忘录方法 动态规划法可采用备忘录方法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"矩阵连乘 问题叙述 给定 n 个矩阵 $A_1$，$A_2$，……，$A_n$，其中 A~1~ 与 A~j+1~ 是可乘的，i=1,2,……，n-1，现要计算出这 n 个矩阵的连乘积 $A_1 A_2 … A_n$。 确定一种运算次序，使总的运算次数达到最少。 两个矩阵相乘时： A=(a~ij~)~m×k~，B=(b~ij~)~k×n~，C=(c~ij~)~m×n~ C 有 m×n 个元素，需 m×n×k 次乘法，m×n×(k-1) 次加法 完全加括号的矩阵连乘积可递归地定义为： 单个矩阵是完全加括号的； 若矩阵链乘积 A 是完全加括号的，则 A 可表示为 2 个完全加括号的矩阵连乘积 B 和 C 的乘积并加括号，即 A=(BC) 算法分析 分析最优解的结构 记 $A[i:j]$ 为 A~i~A~i+!~…A~j~，记 $m[i][j]$ 是计算 A~i~A~i+!~…A~j~ 时的最少乘法次数，显然 $A[i:i]=A_i$，$m[i][i]=0$ 特征：计算 $A[i:k]$ 和 $A[k+1:j]$ 的次序是最优的。 建立递归关系 假定计算 $A[1:n]$ 的一个最优次序在矩阵 A~k~ 和A~k+1~ 之间将矩阵链断开，1≤k\u003cn $m[1][n]=m[1][k]+m[k+1][n]+p_0p_kp_n$ 一般情况 假定计算 $A[i:j]$ 的一个最优次序在矩阵 A~k~ 和 A~k+1~ 之间将矩阵链断开，i≤k\u003cj m[1] [n]=m[1] [k]+m[k+1] [n]+p~i-1~p~k~p~j~ 一般递推关系： 计算最优值 不同子问题个数最多有 ${n}\\choose{2}$+$n=\\theta(n^2)$ 个。 依据递归式自底向上进行计算。在计算过程中保存已解决的子问题答案，每个子问题只计算一次。 /* r:矩阵序的长度 p[]：存放矩阵序列维度的数组 m[][]：最优值数组 s[][]：记录最优断开位置的数组 */ void MatrixChain(int *p, int n, int **m){ int i,r,j,k,t; for (i=1;i\u003c=n;i++) m[i][i]=0; for (r=2;r\u003c=n;r++) // 每次循环计算出x个矩阵相乘时的最优运算次数，x=1到n-1 for (i=1;i\u003c=n-r+1;i++){ // 斜着 j = i+r-1; // x m[i][j]=m[i+1][j]+p[i-1]*p[i]*p[j]; //初始化 for (k=i+1;k\u003cj;k++){ t=m[i][k]+m[k+1][j]+p[i-1]*p[k]*p[j]; if (t\u003cm[i][j]) m[i][j]=t; } } } def matrix_chain(n: int, p: List[int]) -\u003e tuple: \"\"\" 计算最优值关系矩阵 :param n: 连乘矩阵的个数 :param p: 矩阵序列维度的列表 :return: 最优断开位置的二维列表, 备忘录 \"\"\" m: List[List[int]] = [ [0 for i in range(n + 1)] for j in range(n + 1)] # 初始记录矩阵全设为零 s: List[List[int]] = [ [0 for i in range(n + 1)] for j in range(n + 1)] # 记录最优断开位置的数组 for r in range(2, n + 1): # 对每个对角线 for i in range(1, n - r + 2): # 对每行 j = i + r - 1 # 对角线长 m[i][j] = m[i][i] + m[i + 1][j] + \\ p[i - 1] * p[i] * p[j] # 初始化 m[i][j] s[i][j] = i # 记录断开位置 for k in range(i + 1, j): # 寻找m[i][j]最小值 t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if t \u003c m[i][j]: m[i][j] = t s[i][j] = k # 记录断开位置 return s, m 复杂度 计算时间上界为 $O(n^3)$，空间为 $O(n^2)$ 构造最优解 引入分割点标记 $s[i][j]$，确定加括号方式，构造最优解 void Traceback(int i, int j, int **s) { if (i==j) return; Traceback(i,s[i][j],s); Traceback(s[i][j]+1,j,s); cout \u003c\u003c \"Multiply A \"\u003c\u003c i \u003c\u003c \", \" \u003c\u003c s[i][j]; cout \u003c\u003c \" and A \" \u003c\u003c (s[i][j]+1) \u003c\u003c \" ,\" \u003c\u003c j \u003c\u003c endl; } ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:3","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"最长公共子序列 概念 子序列：若给定序列 $X={x_1,x_2,…,x_m}$，则另一序列 $Z={z_1,z_2,…,z_k}$是 X 的子序列，是指存在一个严格递增下标序列 ${i_1,i_2,…,i_k}$ 使得对于所有 j=1,2,…,k 有：$Z_j=X_{ij}$ 公共子序列：给定两个序列 X 和 Y，当另一序列 Z 既是 X 的子序列又是 Y 的子序列时，称 Z 是序列 X 和 Y 的公共子序列 设序列 $X={x_1,x_2,…,x_m}$ 和 $Y={y_1,y_2,…,y_n}$ 的最长公共子序列为 $Z={z_1,z_2,…,z_k}$，则 若 $x_m=y_n$，则 $z_k=x_m=y_n$，且 Z~k-1~ 是 X~m-1~ 和 Y~n-1~ 的最长公共子序列 若 $x_m≠y_n$ 且 $z_k≠x_m$，则 Z 是 X~m-1~ 和 Y 的最长公共子序列 若 $x_m≠y_n$ 且 $z_k≠y_n$，则 Z 是 X 和 Y~n-1~ 的最长公共子序列 当 i=0 或 j=0 时，空序列是 $X_i$ 和 $Y_j$ 的最长公共子序列，此时 $c[i][j]=0$。 递归 其他情况下的递归关系： $$ c[i][j]=\\begin{cases}0,i=0、j=0\\c[i-1][j-1]+1,i、j＞0;x_i=y_j\\max(c[i][j-1],c[i-1][j]),i、j\u003e0;x_i≠y_j\\end{cases} $$ 子问题空间中，总共有 $\\theta(mn)$ 个不同的子问题，用动态规划算法自底向上计算最优值能提高算法的效率。 代码 /* c[i][j]：存储Xi和Yj的最长公共子序列的长度 b[i][j]：记录c[i][j]的值是由哪个子问题的解得到的 */ //计算最优值 void LCSLength(int m, int n, char *x, char *y, int **c, int **b) { int i,j; for (i=1;i\u003c=m;i++) c[i][0]=0; for (i=1;i\u003c=n;i++) c[0][i]=0; for(i=1;i\u003c=m;i++) { for(j=1;j\u003c=n;j++) { if (x[i]==y[j]){ c[i][j]=c[i-1][j-1]+1; b[i][j]=1; //指↖ } else if(c[i-1][j]\u003e=c[i][j-1]){ c[i][j]=c[i-1][j]; b[i][j]=2; //指↑ } else{ c[i][j]=c[i][j-1]; b[i][j]=3; //指← } } } } //构造最长公共子序列 void LCS(int i, int j, char *x, int **b) { if (i==0 || j==0) return; if (b[i][j]==1) { LCS(i-1,j-1,x,b); cout \u003c\u003c x[i]; } else if(b[i][j]==2) LCS(i-1,j,x,b); else LCS(i,j-1,x,b); } ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:4","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"最大子段和 问题描述 给定由 n 个整数组成的序列 $a_1,a_2,a_3……,a_n$，求该序列形如 $\\sum{a_k}$ 的子段和的最大值。 枚举：$O(n^3)$ 递推：$O(n^2)$ 分治策略 将序列 $a[1:n]$ 分为长度相等的两段 $a[1:n/2]$ 和 $a[n/2+1:n]$，分别求出这两段的最大子段和 S~1~，S~2~ $a[1:n]$ 的最大子段和 S 有三种可能： $S=S~1$，$S=S_2$ 或 $S=\\sum_{k=i}^{j}{a_k}$，$i≤n/2，n/2+1≤j$ 对于第三种情况只需求得 S~1~ 中 i 到 n/2 最大子段和，S~2~ 中 n/2+1 到 j 最大子段和，二者相加 S=S~1~’+S~2~’（因为比包含 n/2 处的数） 时间复杂度递推式： $$ T(n)=\\begin{cases}2T(n/2)+O(n),n\u003eC\\O(1),n≤C\\end{cases} $$ 由上解得 $T(n)=O(nlogn)$ 动态规划 对 $a[1:j]$，记 $b[j]$，$1≤j≤n$ $b[j]=max$~{1≤i≤j}~{$\\sum_{k=i}^{j}{a_k}$} 以 j 为末尾位置的最大子段和 $a[1:n]$ 的最大子段和 $S=max$~{1≤j≤n}~{$b[j]$}，即 j 从 1 到 n 的最大 b[j] 有递推： $$ b[j]=max{b[j-1]+a[j],a[j]} $$ int MaxSum(int n, int *a) { int sum=0,b=0; for (int i =1; i\u003c=n;i++) { if (b\u003e0) b+=a[i]; else b=a[i]; if(b\u003esum) sum=b; } return sum; } // 好妙 复杂性：$O(n)$ 推广：最大子矩阵和问题 给定一个 m 行 n 列的整数矩阵 A，试求矩阵 A 的一个子矩阵，使其各元素之和为最大。 思想：将多行压成一行 int MaxSum2(int m, int n, int **a) { int sum=0,*b=new int [n+1]; for (int i =1;i\u003c=m;i++){ for (int k=1;k\u003c=n;k++) b[k]=a[i][k]; // 将i行数据存进b数组中 for (int j=i+1;j\u003c=m;j++){ for (int k=1; k\u003c=n;k++) b[k]+=a[j][k]; // 将新一行累加到b数组中 int max=MaxSum(n,b); // 获取加上这行后，所得的最大子段和（降维） if(max\u003esum) sum=max; } } return sum; } 复杂性：$O(m^2n)$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:5","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"凸多边形最优三角剖分 凸多边形：用多边形顶点的逆时针序列表示凸多边形，即 P={v~0~，v~1~，…，v~n-1~} 表示具有 n 条边的凸多边形。 弦：若 v~i~ 与 v~j~ 是多边形上不相邻的 2 个顶点，则线段 v~i~v~j~ 称为多边形的一条弦。弦将多边形分割成 2 个多边形 {v~i~，v~i+1~，…，v~j~} 和 {v~j~，v~j+1~，…，v~i~} 凸多边形最优三角剖分：给定凸多边形 P，以及定义在由多边形的边和弦组成的三角形上的权函数 w。确定该凸多边形的三角剖分，使得该三角剖分中诸三角形上权之和为最小。 与矩阵连乘思想类似，都是找到一颗最优的语法树 递归结构 定义 $t[i][j]$，1 ≤ i＜j ≤ n 为凸子多边形 {v~i-1~，v~i~，…，v~j~} 的最优三角剖分所对应的权函数值，即其最优值。 $t[i][j]=t[i][k]+t[k+1][j]+$(△v~i-1~v~k~v~j~ 权值) 递归定义 时间复杂性：$O(n^3)$ 空间复杂性：$O(n^2)$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:6","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"流水作业调度 问题描述 n 个作业 {1,2,…,n} 要在由 2 台机器 M1 和 M2 组成的流水线上完成加工。每个作业加工的顺序都是现在 M1 上加工，然后在 M2 上加工 M1 和 M2 加工作业 i 所需的时间分别为 a~i~ 和 b~i~。 流水作业调度问题：确定这 n 个作业的最优加工顺序，使得从第一个作业在机器 M1 上开始加工，到最后一个作业在机器 M2 上加工完成所需的时间最少。 算法分析 优化的点：M2 会有空闲时间 一个最优调度应使机器 M1 没有空闲时间且机器 M2 的空闲时间最少。 机器 M2 的两种情况： 机器空闲 作业积压 设机器 M1 开始加工 S 中作业时，机器 M2 还在加工其他作业，要等时间 t 后才可利用，完成 S 中作业所需的最短时间记为 $T(S,t)$ 由此，该问题变为求最优值为 $T(J,0)$ 最优子结构性质 设 π 是所给 n 个流水作业的一个最优调度，即已排好作业调度：π(1)，π(2)，…，π(n)，其中 π(i)∈{1,2,…,n} 设机器 M1 开始加工 J 中第一个作业 J~π(1)~ 时，机器 M2 可能在等待，它所需的加工时间为 a~π(1)~+T‘，其中 T’ 是在机器 M2 的等待时间为 b~π(1)~ 时，安排作业 J~π(2)~，…，J~π(n)~ 所需的时间，这是最好的时间。 记 S=J-{J~π(1)~}，则可证明：$T’=T(S,b_{π(1)})$ 递归关系 可得 $T(J,0)=min_{1≤i≤n}{a_i+T(J-{J_i},b_i)}$ 一般情况：$T(S,t)=min_{Ji∈S}{a_i+T(S-{J_i},b_i+max{t-a_i,0})}$ Johnson 不等式 设 π 是作业集 S 在机器 M2 的等待时间为 t 时的任一最优调度。若 π(1)=i，π(2)=j，由动态规划递归式可得： $T(S,t)=a_i+T(S-{J_i},b_i+max{t-a_i,0})=a_i+a_j+T(S-{J_i,J_j},t_{ij})$ 其中，$t_{ij}=b_j+b_i-a_j-a_i+max{t,a_i+a_j-b_i,a_i}$ 若作业 J~i~ 和 J~j~ 满足 min{a~j~,b~i~}≥min{a~i~,b~j~}，称做 J~i~ 和 J~j~ 满足 Johnson 不等式。 当作业 J~i~ 和 J~j~ 不满足 Johnson 不等式时，只要交换他们的加工顺序后，不会增加加工时间。 所有满足 Johnson 法则的调度均为最优调度。 最坏情况下算法所需的计算时间为 $O(nlogn)$，所需空间为 $O(n)$ 注意证明！ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:7","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"0-1 背包问题 问题描述 给定 n 个物体和一个背包，物体 i 的重量为 w~i~，价值为 v~i~ (i=1,2,……,n)，背包能容纳的物体重量为 c，要从这 n 个物体中选出若干件放入背包，使得放入物体的总重量小于等于 c，而总价值达到最大。 如果用 x~i~=1 表示将第 i 件物体放入背包，用 x~i~=0 表示未放入，则问题变为选择一组 x~i~ (i=0,1) 使得 $w_x=\\sum_{i=l}^{n}{w_ix_i}≤c$，$v_x=\\sum_{i=l}^{n}{v_ix_i}$，并且达到最大 证明最优子结构性质 递归关系 $m(i,j)$ 是背包容量为 j，可选择物品为 $i,i+1,…,n$ 时 0-1 背包问题的最优值。 由 0-1 背包问题的最优子结构性质，有计算 $m(i,j)$ 的递归式： $$ m(i,j)=\\begin{cases}max{m(i+1,j),m(i+1,j-w_i)+v_i},j \\ge w_i \\ m(i+1,j),0 \\le j＜w_i\\end{cases} $$ /* w[]: 重量数组 c: 最大容纳重量 n: 从第n个开始 */ template\u003cclass Type\u003e void Knapsack(Type v,int w,int c, int n, Type** m) { int jMax=min(w[n]-1,c); for(int j=0;j\u003c=jMax;j++) //初始化 m[n][j]=0; for(int j=w[n];j\u003c=c;j++) //价值 m[n][j]=v[n]; for(int i=n-1;i\u003e1;i--) { jMax=min(w[i]-1,c); for(int j=0;j\u003c=jMax;j++) //放不下 m[i][j]=m[i+1][j]; for(int j=w[i];j\u003c=c;j++) //放得下 m[i][j]=max(m[i+1][j],m[i+1][j-w[i]]+v[i]); } m[1][c]=m[2][c]; if(c\u003e=w[1]) m[1][c]=max(m[1][c],m[2][c-w[1]]+v[1]); } //构造最优解 template\u003cclass Type\u003e void Traceback(Type **m, int w, int c, int n, int x) { for(int i=1;i\u003cn;i++) { if(m[i][c]==m[i+1][c]) x[i]=0; else{ x[i]=1; c-=w[i]; } } x[n]=(m[n][c])?1:0; } 时间复杂性：$O(min{nc,2^n})$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:4:8","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"贪心算法 贪心策略不从整体最优考虑，而总是某种意义上是局部最优的方面做出选择。 ==贪心策略总是作出在当前看来最好的选择== ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:5:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"活动安排问题 问题描述 有 n 个活动的集合 E={1,2,……,n}，其中每个活动都要求使用同一资源，而在同一时间内只有一个活动能使用这一资源。 每个活动 i 都有一个要求使用该资源的起始时间 s~i~ 和一个结束时间 f~i~，且 s~i~＜f~i~。 若选择了活动 i，则它在半开时间区间 [s~i~,f~i~) 内占用资源。若区间 [s~i~,f~i~) 与区间 [s~j~,f~j~) 不相交，则称活动 i 与活动 j 是相容的。 求解策略 策略：从队列中每次总是选择具有最早完成时间的相容活动加入活动集合 A 中。 预备：将活动以完成时间升序排列 int GreedySelector(int n,int s[], int f[], bool A[]) { A[1]=true; int j=1,count=1; for(int i=2;i\u003c=n;i++){ if(s[i]\u003e=f[j]) { A[i]=true; j=i; count++; } else A[i]=false; } return count; } 选择具有最早完成时间的相容活动加入集合A中，时间复杂性：$O(nlogn)$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:5:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"贪心算法的基本要素 贪心选择性质 所求问题的整体最优解可以通过一系列局部最优的选择来达到。 最优子结构性质 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质 问题具有贪心选择性质的证明方法 （贪心策略的证明要考，看清楚要证明什么） 明确贪心选择策略 S 按该贪心选择策略，选一个局部最优解，确定第一步选择（假定有一个最优解 A） 考察问题的最优解 A，并证明它的第一步必可通过贪心选择策略开始 贪心算法与动态规划算法的差异 贪心选择 问题的整体最优解可以通过一系列局部最优的选择求得。 通常自顶向下的方式进行，以迭代方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。 动态规划 问题的整体最优解由所有相关子问题的最优解组成 每步选择依赖于相关子问题，待子问题求解后，才做出选择。 通常以自底向上的方式解决各子问题。 两者的共同点 贪心算法和动态规划算法都要求问题具有最优子结构性质； 都通过求解一系列子问题的解求得原问题的解 一般背包问题的贪心选择性质证明 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:5:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"最优装载 问题描述 有一批集装箱要装上一艘载重量为 c 的轮船。其中集装箱 i 的重量为 w~i~。确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。 算法描述 用 x~i~ 表示将第 i 件集装箱装入船，用 x~i~=0 表示未放入，则问题变为选择一组 x~i~(i=0,1) 最优装载问题可以用贪心算法求解。 确定贪心选择策略：采用重量最轻者先装，可产生最优装载问题的最优解。 步骤： 预备：先对货物按重量从轻到重排序 策略：依次按最轻者装入 void Loading(int x[],int w[],int c,int n) { int *t=new int [n+1]; Sort(w,t,n); for(int i=1;i\u003c=n;i++) x[i]=0; for(int i=1;i\u003c=n\u0026\u0026w[t[i]]\u003c=c;i++){ x[t[i]]=1; c-=w[t[i]]; } } 算法所需的计算时间为 $O(nlogn)$ 性质证明 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:5:3","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"哈夫曼编码 问题描述 一个文件含 100,000 个字符，共有 6 个字母 a,b,c,d,e,f 出现，频率为：45,13,12,16,9,5，用 0、1 穿表示字母对文件进行压缩。 哈夫曼编码特点：给出现频率高的字符较短的 0、1 编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。 编码方法 前缀码 对每一个字符规定一个 0、1 串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀。 译码方式：取前缀码 编码方法：构造二叉树 表示最优前缀码的二叉树总是一棵完全二叉树，即树中任一非叶结点都有2个儿子结点。 平均码长定义为$B(T)=\\sum_{c∈C}f(c)d_T(c)$，$C$ 为字符集，$f(c)$ 为字符 $c$ 在文件中出现的频率，$d_T(c)$ 为深度 使平均码长达到最小的前缀码编码方程称为给定编码字符集 $C$ 的最优前缀码 构造哈夫曼编码 哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树T。 算法思想：算法以 $|C|$ 个叶结点开始，执行 $ |C|-1$ 次的“合并”运算后产生最终所要求的树 T。 哈夫曼树 算法步骤： 用 $C$ 中每一字符 $c$ 的频率 $f(c)$ 初始化一个队列 Q 对优先队列 Q 用贪心选择：取出具有最小频率的 2 棵树 x,y，并将这 2 棵树合并为新树 z，其频率为合并的 2 棵树的频率之和，并将新树插入优先队列 Q。 作 n-1 次类似的合并。优先队列中只剩下一棵树，即所要求的的树 T。 哈夫曼树的实现方式与复杂性 用最小堆实现优先队列 Q 初始化优先队列需要 $O(n)$ 计算时间，n-1 次的合并总共需要 $O(nlogn)$ 计算时间 n 个字符的哈夫曼算法的计算时间为 $O(nlogn)$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:5:4","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"单源最短路径 问题描述 给定带权有向图 G=(V,E)，其中每条边的权是非负实数。给定 V 中的一个顶点 v，称为源。计算从源v到所有其他各顶点u的最短路长度 d[u]。 Dijkstra 算法基本思想 设置顶点集合 S 并不断地作贪心选择来扩充这个集合。u∈S，当且仅当从源 v 到该顶点 u 的最短路径长度已知。 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:5:5","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"回溯法 子集树算法框架 排列数算法框架 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"回溯法的算法框架 问题的解空间 解向量：问题的解用向量表示 $(x_1,x_2,…,x_k)$，其中 $k≤n$，$n$ 为问题的规模 约束条件 显式约束：对分量 $x_i$ 的取值的明显限定 隐式约束：为满足问题的解而对分量施加的约束 解空间：对于问题的一个实例，解向量满足显式约束条件的所有多元组，构成了该实例的一个解空间。 状态空间树：用于形象描述解空间的树 目标函数与最优解 目标函数：衡量问题解的“优劣”标准 最优解：使目标函数取极（大/小）值的解 回溯法 基本方法：利用限界函数来避免生成那些实际上不可能产生所需解的活结点，以减少问题的计算量，避免无效搜索 限界函数：用于剪枝（会出代码填空） 约束函数：某个满足条件的表达式或关系式 限界函数（Upper Bound）：某个函数表达式或关系式 回溯法：具有限界函数的深度优先搜索方法 基本思想 以深度优先方式搜索解空间 开始时，根节点为活结点，也是当前的扩展结点 对扩展结点，寻找儿子结点： 若找到新结点，新结点称为活结点并成为扩展结点，转 3； 若找不到新结点，当前结点成为死结点，并回退到最近的一个活结点，使它成为扩展结点，转 3 搜索继续进行，直到找到所求的解或解空间中已无活结点时为止 解题步骤 针对所给问题，定义问题的解空间 确定合适的解空间结构 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索，直到找到所求的解或解空间中已无活结点时为止 子集树与排列树 左图为子集树，遍历子集树需计算 $O(2^n)$；右图为排列树，遍历排列树需要 $O(n!)$ //legal(t)为Constraint(t)\u0026\u0026Bound(t) //子集树 void backtrack(int t) { if (t\u003en) output(x); else for(int i=0;i\u003c=1;i++) { x[t]=i; if(legal(t)) backtrack(t+1); } } //排列树 void backtrack(int t) { if(t\u003en) output(x); else for(int i=t;i\u003c=n;i++) { swap(x[t],x[i]); if(legal(t)) backtrack(t+1); swap(x[t],x[i]); } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"装载问题 问题描述 有一批共 n 个集装箱要装上 2 艘载重量分别为 $c_1$ 和 $c_2$ 的轮船，其中集装箱 i 的重量为 $w_i$，且 $\\sum_{i=1}^{n}{w_i≤c_1+c_2}$ 求一个装载方案可以将这批集装箱装上这两艘轮船 最优装载方案 首先将第一艘轮船尽可能装满 将第一艘轮船尽可能装满等价于选取全体集装箱集合的一个子集，使该子集中集装箱重量之和最接近 $c_1$ 将剩余的集装箱装上第二艘轮船 装载问题等价于特殊的 0-1 背包问题 装载问题的回溯法 解空间：子集树，完全二叉树 设定解向量：$(x_1,x_2,…,x_n)$ 约束条件 显式约束：$x_i=0,1(i=1,2,…,n)$ 隐式约束：无 约束函数（整体）：$\\sum^{n}_{i=1}{w_ix_i}≤c_1$ /* cw:当前船c1的载重量 bestw:当前船c1d最优载重量, 越大越好 r:剩余集装箱的重量，限界函数:cw+r\u003ebestw */ //求最优值 void backtrack(int i) //搜索第i层结点 { if(i\u003en) //到达叶结点 { if(cw\u003ebestw) bestw=cw; //修正最优值 return; } r-=w[i]; if(cw+w[i]\u003c=c) //搜索左子树 { cw+=w[i]; backtrack(i+1); cw-=w[i]; //回退 } if(cw+r\u003ebestw) //搜索右子树 backtrack(i+1); r+=w[i]; } 为了构造最优解，需在算法中记录与当前最优值相对应的当前最优解。 /* cw:当前载重量 x:当前解 bestx:当前最优解 bestw:当前最优载重量 r:剩余集装箱的重量，限界函数:cw+r\u003ebestw */ void backtrack(int i) { if(i\u003en) { if(cw\u003ebestw) for(int j=1;j\u003c=n;j++) bestx[j]=x[j]; //记录路径 bestw=cw; return; } r-=w[i]; if(cw+w[i]\u003c=c){ //搜索左子树 x[i]=1; cw+=w[i]; backtrack(i+1); cw-=w[i]; } if(cw+r\u003ebestw){ //搜索右子树 x[i]=0; backtrack(i+1); } r+=w[i]; //复位 } 迭代回溯 注：代码见书P 130 将回溯法表示成非递归的形式 所需计算时间仍为$O(2^n)$ 优化：修改递归回溯程序，使所需的计算时间仍为$O(2^n)$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"批处理作业调度 问题描述 给定 n 个作业的集合 $J=${$J_1,J_2,…,J_n$}，每个作业须由机器 M1 处理，再由机器 M2 处理。作业 $J_i$ 需机器 j 的处理时间为 $t_{ji}$，所有作业在机器 M2 上完成处理的时间和称为该作业调度的完成时间和：$f=\\sum_{i=1}^{n}{F_{2i}}$ 算法设计 设 x[1…n] 是 n 个作业，解空间为排列树 f1=f1+m[x[j]][1] f2[i]=((f2[i-1]\u003ef1)?f2[i-1]:f1)+m[x[j]][2] 没有约束函数，只有限界函数 /* f1:机器1完成处理时间 f：完成时间和 bestf:当前最优值 m:各作业所需的处理时间 x:当前作业调度 bestx:当前最优调度 f2:机器2完成处理 */ void backtrack(int i) { if(i\u003en){ for(int j=1;j\u003c=n;j++) bestx[j]=x[j]; bestf=f; } else { for(int j=i;j\u003c=n;j++){ f1+=M[x[j]][1]; f2[i]=((f2[i-1]\u003ef1)?f2[i-1]:f1)+M[x[j]][2]; f+=f2[i]; if(f\u003cbestf) //限界函数 { Swap(x[i],x[j]); backtrack(i+1); Swap(x[i],x[j]); //复位 } f1-=M[x[j]][1]; f-=f2[i]; } } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:3","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"n 后问题 问题描述 在 n×n 格的棋盘上放置彼此不受攻击的 n 个皇后，任何两个皇后不放在同一行或同一列或同一斜线上 求出可行解的个数 算法分析 设定解向量：$(x_1,x_2,…,x_n)$，采用排列树 约束条件 显式约束：$x_i=1,2,…,n(i=1,2,…,n)$ 隐式约束 不同列：$x_i≠x_j$ 不处于同一正、反对角线：$ | i-j | ≠ | x_i-x_j | $ /* n:皇后个数 x:当前解 sum:当前已找到的可行方案书 */ //约束函数 bool place(int k) //k为当前行号 { for(int j=1;j\u003ck;j++){ if((abs(k-j)==abs(x[j]-x[k])) || (x[j]==x[k])) return false; return true; } } //递归回溯 void backtrack(int t) { if(t\u003en) sum++; else { for(int i=1;i\u003c=n;i++) //这里用的是n叉子集树 { x[t]=i; if(place(t)) backtrack(t+1); } } } 迭代回溯 void N-queen(n){ x[1]=0; k=1; while(k\u003e0){ x[k]=x[k]+1; while((x[k]\u003c=n)\u0026\u0026!place(k)) // 寻找可以放置的x[k] x[k]=x[k]+1; if(x[k]\u003c=n) if(k==n) sum++; else k++; x[k]=0; else k--; } } ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:4","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"0-1 背包问题 解空间：子集树 限界函数： double bound(int i) //计算上界 { double cleft=c-cw; //剩余容量 double bnd=cp; //cp:当前价值 while(i\u003c=n \u0026\u0026 w[i]\u003c=cleft) //以物品单位重量价值递减序装入物品 { cleft-=w[i]; bnd+=p[i]; i++; } if(i\u003c=n \u0026\u0026 w[i]\u003ecleft) //背包有空隙时，装满背包 bnd+=p[i]*cleft/w[i]; return bnd; } //回溯程序 void Backtrack(int i) { if(i\u003en) bestp=cp; return; if(cw+w[i]\u003c=c) { cw+=w[i]; cp+=p[i]; Backtrack(i+1); cw-=w[i]; cp-=p[i]; } if(bound(i+1)\u003ebestp) Backtrack(i+1); } 时间复杂度：$O(n2^n)$ ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:5","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"最大团问题 概念 通俗的讲，就是在一个无向图中找出一个点数最多的完全图 算法分析 解空间：子集树 限界函数：取 cn+(n-i)，即有足够多的可选择顶点使得算法有可能在右子树中找到更大的团 /* n:图的顶点数 x:当前解 bestx:当前最优解 cn:当前顶点数 bestn:当前最大顶点数 */ void backtrack(int i) { if(i\u003en) { for(int j=1;j\u003c=n;j++) bestx[j]=x[j]; bestn=cn; return; } int ok=1; for(int j=1;j\u003ci;j++) //欲扩展节点i { if(x[j]==1 \u0026\u0026 !a[i][j]) //考察：i与前面的j是否相连 // 若x[j]在团中而且j与i不x { ok=0; //i与前面的j不相连，舍弃i break; } } if(ok) //进入左子树 { x[i]=1; cn++; backtrack(i+1); x[i]=0; cn--; } if(cn+n-i\u003ebestn) //进入右子树 { x[i]=0; backtrack(i+1); } } 启发式信息 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:6:6","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"分支限界法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:7:0","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"概念 基于广度优先 与回溯法的不同 基本思想 方法 术语 剪枝的表现：不要将这个节点入列 子集树与排列数的算法框架 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:7:1","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["专业课"],"content":"装载问题 描述 队列式分支限界法 ","date":"2021-11-25","objectID":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/:7:2","tags":["算法"],"title":"算法设计与分析","uri":"/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"},{"categories":["Linux"],"content":"shell 编程 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:0:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"认识 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:1:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"环境 Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。 Linux 的 Shell 种类众多，常见的有： Bourne Shell（/usr/bin/sh或/bin/sh） Bourne Again Shell（/bin/bash） C Shell（/usr/bin/csh） K Shell（/usr/bin/ksh） Shell for Root（/sbin/sh） …… Bash 是大多数Linux 系统默认的 Shell。 在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 #!/bin/sh，它同样也可以改为 #!/bin/bash。 #!/bin/bash echo \"Hello World !\" #! 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。 Shebang（也称为 Hashbang）是一个由井号和叹号构成的字符串行（#!），其出现在文本文件的第一行的前两个字符。在文件中存在 Shebang 的情况下，类 Unix 操作系统的程序载入器会分析 Shebang 后的内容，将这些内容作为解释器指令，并调用该指令，并将载有 Shebang 的文件路径作为该解释器的参数 例如, 以指令 #!/bin/sh 开头的文件在执行时会实际调用 /bin/sh 程序 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:1:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"运行 作为可执行程序 chmod +x ./test.sh # 使脚本具有执行权限 ./test.sh # 执行脚本 在 linux 中，后缀名几乎是可以任意的或者没有后缀名，一般将 shell 保存为 xxx.sh 是为了看起来更直观 ./test.sh 若写成 test.sh，系统会去 PATH 里寻找有没有叫 test.sh 的文件，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里 作为解释器参数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名 /bin/sh test.sh /bin/php test.php 这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:1:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"变量 变量名和等号之间不能有空格 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:2:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"基本操作 定义 your_name=\"Melon\" 除了显式地直接赋值，还可以用语句给变量赋值，如： for file in `ls /etc` # 或 for file in $(ls /etc) 以上语句将 /etc 下目录的文件名循环出来。 使用 使用一个定义过的变量，只要在变量名前面加美元符号即可，如： your_name=\"qinjx\" echo $your_name echo ${your_name} 变量名外面的花括号是可选的，加花括号是为了帮助解释器识别变量的边界 只读变量 使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。 下面的例子尝试更改只读变量，结果报错： #!/bin/bash myUrl=\"https://www.google.com\" readonly myUrl myUrl=\"https://www.baidu.com\" # 此句将报错 报错信息： /bin/sh: NAME: This variable is read only. 删除变量 使用 unset 命令可以删除变量。 unset variable_name unset 命令不能删除只读变量。 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:2:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"变量类型 运行 shell 时，会同时存在三种变量： 局部变量（用户变量）：局部变量在脚本或命令中定义，仅在当前 shell 实例中有效，其他 shell 启动的程序不能访问局部变量。 环境变量：所有的程序，包括 shell 启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候 shell 脚本也可以定义环境变量。 shell 变量：shell 变量是由 shell 程序设置的特殊变量。shell 变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了 shell 的正常运行 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:2:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"数据类型 字符串 单引号 str='this is a string' 单引号字符串的限制： 其中任何字符都会原样输出，单引号字符串中的变量是无效的； 其中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号 your_name=\"Melon\" str=\"Hello, I know you are \\\"$your_name\\\"! \\n\" echo -e $str 输出结果为： Hello, I know you are \"Melon\"! 优点： 双引号里可以有变量 双引号里可以出现转义字符 拼接字符串 your_name=\"Melon\" # 使用双引号拼接 greeting=\"hello, \"$your_name\" !\" greeting_1=\"hello, ${your_name}!\" echo $greeting $greeting_1 # 使用单引号拼接 greeting_2='hello, '$your_name' !' greeting_3='hello, ${your_name} !' echo $greeting_2 $greeting_3 输出结果为： hello, Melon ! hello, Melon ! hello, Melon ! hello, ${your_name} ! 获取字符串长度 string=\"abcd\" echo ${#string} # 输出4 提取子字符串 以下实例从字符串第 2 个字符开始截取 4 个字符： string=\"runoob is a great site\" echo ${string:1:4} # 输出 unoo 第一个字符的索引值为 0 查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： string=\"runoob is a great site\" echo `expr index \"$string\" io` # 输出4 数组 定义 bash 支持一维数组（不支持多维数组），并且没有限定数组的大小 在 Shell 中，用括号来表示数组，数组元素用\"空格\"符号分割开。定义数组的一般形式为： array_name=(value0 value1 value2 value3) 或者 array_name=( value0 value1 value2 value3 ) 还可以单独定义数组的各个分量： array_name[0]=value0 array_name[1]=value1 array_name[n]=valuen 可以不使用连续的下标，而且下标的范围没有限制。 读取数组 读取数组元素值的一般格式是： valuen=${array_name[n]} 使用 @ 符号可以获取数组中的所有元素 echo ${array_name[@]} # or echo ${array_name[*]} 获取数组的长度 获取数组长度的方法与获取字符串长度的方法相同，例如： # 取得数组元素的个数 length=${#array_name[@]} # 或者 length=${#array_name[*]} # 取得数组单个元素的长度 lengthn=${#array_name[n]} ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:2:3","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"环境变量 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:2:4","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"参数 脚本内获取参数的格式为：$n #!/bin/bash echo \"Shell 传递参数实例！\"; echo \"执行的文件名：$0\"; echo \"第一个参数为：$1\"; echo \"第二个参数为：$2\"; echo \"第三个参数为：$3\"; $ chmod +x test.sh $ ./test.sh 1 2 3 Shell 传递参数实例！ 执行的文件名：./test.sh 第一个参数为：1 第二个参数为：2 第三个参数为：3 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:3:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"参数处理 参数处理 说明 $# 传递到脚本的参数个数 $* 命令行中所有参数。 如 \"$*\" 用「\"」括起来的情况、以 \"$1 $2 … $n\" 的形式输出所有参数。 $$ 脚本运行的当前进程 ID 号 $! 后台运行的最后一个进程的 ID 号 $@ 与 $* 相同，但是使用时加引号，并在引号中返回每个参数。 如 \"$@\" 用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $- 显示 Shell 使用的当前选项，与 set 命令功能相同。 $? 显示最后命令的退出状态。0 表示没有错误，其他任何值表明有错误。 #!/bin/bash # author:菜鸟教程 # url:www.runoob.com echo \"Shell 传递参数实例！\"; echo \"第一个参数为：$1\"; echo \"参数个数为：$#\"; echo \"传递的参数作为一个字符串显示：$*\"; 执行与输出 $ chmod +x test.sh $ ./test.sh 1 2 3 Shell 传递参数实例！ 第一个参数为：1 参数个数为：3 传递的参数作为一个字符串显示：1 2 3 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:3:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"$* 与 $@ 区别 #!/bin/bash # author:菜鸟教程 # url:www.runoob.com echo \"-- \\$* 演示 ---\" for i in \"$*\"; do echo $i done echo \"-- \\$@ 演示 ---\" for i in \"$@\"; do echo $i done 执行脚本，输出结果如下所示： $ chmod +x test.sh $ ./test.sh 1 2 3 -- $* 演示 --- 1 2 3 -- $@ 演示 --- 1 2 3 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:3:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"操作符 原生 bash 不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr 原生的运算式格式：$[ 运算式 ]，注意中括号间用空格隔开 expr 是一款表达式计算工具，使用它能完成表达式的求值操作。 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2 完整的表达式要被 `` 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 # 第1种方式 $(()) echo $(((2+3)*4)) # 第2种方式 $[]，推荐 echo $[(2+3)*4] # 使用 expr TEMP=`expr 2 + 3` echo `expr $TEMP \\* 4` ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:4:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"字符串比较操作符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否不相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为 0，为 0 返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n \"$a\" ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:4:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"数字比较操作符 关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 expr #!/bin/bash # author:菜鸟教程 # url:www.runoob.com a=10 b=20 val=`expr $a + $b` echo \"a + b : $val\" val=`expr $a - $b` echo \"a - b : $val\" val=`expr $a \\* $b` echo \"a * b : $val\" val=`expr $b / $a` echo \"b / a : $val\" val=`expr $b % $a` echo \"b % a : $val\" if [ $a == $b ] then echo \"a 等于 b\" fi if [ $a != $b ] then echo \"a 不等于 b\" fi 乘号(*)前边必须加反斜杠()才能实现乘法运算 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:4:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"文件操作符 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true [ -b $file ] -c file 检测文件是否是字符设备文件，如果是，则返回 true [ -c $file ] -d file 检测文件是否是目录，如果是，则返回 true [ -d $file ] -f file 检测文件是否是普通文件（非目录，非设备文件），若是，则返回 true [ -f $file ] -g file 检测文件是否设置了 SGID 位，如果是，则返回 true [ -g $file ] -k file 检测文件是否设置了粘着位 (Sticky Bit)，如果是，则返回 true [ -k $file ] -p file 检测文件是否是有名管道，如果是，则返回 true [ -p $file ] -u file 检测文件是否设置了 SUID 位，如果是，则返回 true [ -u $file ] -r file 检测文件是否可读，如果是，则返回 true [ -r $file ] -w file 检测文件是否可写，如果是，则返回 true [ -w $file ] -x file 检测文件是否可执行，如果是，则返回 true [ -x $file ] -s file 检测文件是否为空（文件大小是否大于 0），不为空返回 true [ -s $file ] -e file 检测文件（包括目录）是否存在，如果是，则返回 true [ -e $file ] 其他检查符： -S：判断某文件是否 socket。 -L：检测文件是否存在并且是一个符号链接。 #!/bin/bash # author:菜鸟教程 # url:www.runoob.com file=\"/var/www/runoob/test.sh\" if [ -r $file ] then echo \"文件可读\" else echo \"文件不可读\" fi if [ -w $file ] then echo \"文件可写\" else echo \"文件不可写\" fi if [ -x $file ] then echo \"文件可执行\" else echo \"文件不可执行\" fi if [ -f $file ] then echo \"文件为普通文件\" else echo \"文件为特殊文件\" fi if [ -d $file ] then echo \"文件是个目录\" else echo \"文件不是个目录\" fi if [ -s $file ] then echo \"文件不为空\" else echo \"文件为空\" fi if [ -e $file ] then echo \"文件存在\" else echo \"文件不存在\" fi ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:4:3","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"逻辑操作符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 运算符 说明 举例 \u0026\u0026 逻辑的 AND [[ $a -lt 100 \u0026\u0026 $b -gt 100 ]] 返回 false || 逻辑的 OR `[[ $a -lt 100 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:4:4","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"循环 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"for 语句 一般格式 for((assignment;condition:next));do command_1; command_2; commond_..; done; #!/bin/bash for((i=1;i\u003c=5;i++));do echo \"这是第 $i次调用\"; done; in for var in item1 item2 ... itemN do command1 command2 ... commandN done 写成一行： for var in item1 item2 ... itemN; do command1; command2… done; ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"while 语句 while condition do command done #!/bin/bash int=1 while(( $int\u003c=5 )) do echo $int let \"int++\" done 以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量 读取键盘信息 while 循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量 FILM，按 \u003cCtrl-D\u003e结束循环 echo '按下 \u003cCTRL-D\u003e 退出' echo -n '输入你最喜欢的电影名: ' while read FILM do echo \"是的！$FILM是一部好电影\" done 无限循环 while : do command done 或者 while true do command done 或者 for (( ; ; )) ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"util 语句 until 循环执行一系列命令直至条件为 true 时停止。 until 循环与 while 循环在处理方式上刚好相反。 一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。 until condition do command done condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。 使用 until 命令来输出 0 ~ 9 的数字： #!/bin/bash a=0 until [ ! $a -lt 10 ] do echo $a a=`expr $a + 1` done ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:3","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"repeat 语句 repeat 语句用来执行一个只要重复固定次数的语句 # 显示连字符60次 repeat 60 echo '-' ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:4","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"select 语句 select 语句用来生成一个菜单列表 select item in itemlist do statement done #!/bin/bash echo \"What is your favourite OS?\" select name in \"Linux\" \"Windows\" \"Mac OS\" \"UNIX\" \"Android\" do echo $name done echo \"You have selected $name\" ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:5","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"shift 语句 位置参数可以用 shift 命令左移。比如 shift 3 表示原来的 $4 现在变成 $1，原来的 $5 现在变成 $2 等等，原来的 $1、$2、$3 丢弃，$0 不移动。不带参数的 shift 命令相当于 shift 1。 #!/bin/bash until [ $# -eq 0 ] do echo \"第一个参数为: $1参数个数为: $#\" shift done 执行以上程序x_shift.sh： $./x_shift.sh 1 2 3 4 第一个参数为: 1 参数个数为: 4 第一个参数为: 2 参数个数为: 3 第一个参数为: 3 参数个数为: 2 第一个参数为: 4 参数个数为: 1 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:5:6","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"条件 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:6:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"if 语句 a=10 b=20 if [ $a == $b ] then echo \"a 等于 b\" elif [ $a -gt $b ] then echo \"a 大于 b\" elif [ $a -lt $b ] then echo \"a 小于 b\" else echo \"没有符合的条件\" fi if if condition then command1 command2 ... commandN fi 写成一行 if [ $(ps -ef | grep -c \"ssh\") -gt 1 ]; then echo \"true\"; fi if else if condition then command1 command2 ... commandN else command fi if elif else if condition1 then command1 elif condition2 then command2 else commandN fi ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:6:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"case 语句 case … esac 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分枝选择结构 每个 case 分支用右圆括号开始 用两个分号 ;; 表示 break，即执行结束，跳出整个 case … esac 语句 esac（就是 case 反过来）作为结束标记。 可以用 case 语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。 case 值 in 模式1) command1 command2 ... commandN ;; 模式2） command1 command2 ... commandN ;; esac 如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。 例 echo '输入 1 到 4 之间的数字:' echo '你输入的数字为:' read aNum case $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;; esac #!/bin/sh site=\"github\" case \"$site\" in \"github\") echo \"GitHub\" ;; \"google\") echo \"Google 搜索\" ;; \"taobao\") echo \"淘宝网\" ;; esac ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:6:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"杂项语句 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:7:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"break 和 continue break命令允许跳出所有循环 #!/bin/bash while : do echo -n \"输入 1 到 5 之间的数字:\" read aNum case $aNum in 1|2|3|4|5) echo \"你输入的数字为 $aNum!\" ;; *) echo \"你输入的数字不是 1 到 5 之间的! 游戏结束\" break ;; esac done continue 仅仅跳出当前循环 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:7:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"exit 语句 exit 命令用于退出目前的 shell 若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:7:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"函数 linux shell 允许用户定义函数，然后在 shell 脚本中可以随便调用。 [ function ] funname [()] { action; [return int;] } 可以带 function fun() 定义，也可以直接 fun() 定义，不带任何参数。 加 return 返回；如果不加，将以最后一条命令运行结果，作为返回值。 return 后跟数值 n（0-255） #!/bin/bash demoFun(){ echo \"这是我的第一个 shell 函数!\" } echo \"-----函数开始执行-----\" demoFun echo \"-----函数执行完毕-----\" #!/bin/bash funWithReturn(){ echo \"这个函数会对输入的两个数字进行相加运算...\" echo \"输入第一个数字: \" read aNum echo \"输入第二个数字: \" read anotherNum echo \"两个数字分别为 $aNum和 $anotherNum!\" return $(($aNum+$anotherNum)) } funWithReturn echo \"输入的两个数字之和为 $?!\" 所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:8:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"函数参数 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1 表示第一个参数，$2 表示第二个参数… #!/bin/bash # author:菜鸟教程 # url:www.runoob.com funWithParam(){ echo \"第一个参数为 $1!\" echo \"第二个参数为 $2!\" echo \"第十个参数为 $10!\" echo \"第十个参数为 ${10}!\" echo \"第十一个参数为 ${11}!\" echo \"参数总数有 $#个!\" echo \"作为一个字符串输出所有参数 $*!\" } funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出 第一个参数为 1 ! 第二个参数为 2 ! 第十个参数为 10 ! 第十个参数为 34 ! 第十一个参数为 73 ! 参数总数有 11 个! 作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当 n\u003e=10 时，需要使用 ${n} 来获取参数。 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:8:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"常用命令 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:9:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"echo 显示普通字符串: echo \"It is a test\" 这里的双引号完全可以省略 echo It is a test 显示转义字符 echo \"\\\"It is a test\\\"\" 结果将是: \"It is a test\" 同样，双引号也可以省略 显示变量 read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量 #!/bin/sh read name echo \"$nameIt is a test\" 以上代码保存为 test.sh，name 接收标准输入的变量，结果将是: [root@www ~]# sh test.sh OK #标准输入 OK It is a test #输出 显示换行 echo -e \"OK! \\n\" # -e 开启转义 echo \"It is a test\" 输出结果： OK! It is a test 显示不换行 #!/bin/sh echo -e \"OK! \\c\" # -e 开启转义 \\c 不换行 echo \"It is a test\" 输出结果： OK! It is a test 显示结果定向至文件 echo \"It is a test\" \u003e myfile 原样输出字符串，不进行转义或取变量(用单引号) echo '$name\\\"' 输出结果： $name\\\" 显示命令执行结果 echo `date` 这里使用的是反引号 `, 而不是单引号 ’ 结果将显示当前日期 Sun 24 Oct 2021 08:44:45 PM CST ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:9:1","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"printf printf 命令模仿 C 程序库（library）里的 printf() 程序。 printf 使用引用文本或空格分隔的参数 默认的 printf 不会像 echo 自动添加换行符 printf format-string [arguments...] 参数 format-string：格式控制字符串 arguments：参数列表 $ echo \"Hello, Shell\" Hello, Shell $ printf \"Hello, Shell\\n\" Hello, Shell 格式化 #!/bin/bash printf \"%-10s %-8s %-4s\\n\" 姓名 性别 体重kg printf \"%-10s %-8s %-4.2f\\n\" 郭靖 男 66.1234 printf \"%-10s %-8s %-4.2f\\n\" 杨过 男 48.6543 printf \"%-10s %-8s %-4.2f\\n\" 郭芙 女 47.9876 执行脚本，输出结果如下所示： 姓名 性别 体重kg 郭靖 男 66.12 杨过 男 48.65 郭芙 女 47.99 %s %c %d %f 都是格式替代符 ％s 输出一个字符串 ％d 整型输出 ％c 输出一个字符 ％f 输出实数，以小数形式输出。 %-10s 指一个宽度为 10 个字符（ - 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。 %-4.2f 指格式化为小数，其中 .2 指保留 2 位小数。 多种格式 #!/bin/bash # format-string 为双引号 printf \"%d %s\\n\" 1 \"abc\" # 单引号与双引号效果一样 printf '%d %s\\n' 1 \"abc\" # 没有引号也可以输出 printf %s abcdef # 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用 printf %s abc def printf \"%s\\n\" abc def printf \"%s %s %s\\n\" a b c d e f g h i j # 如果没有 arguments，那么 %s 用 NULL代替，%d 用 0 代替 printf \"%s and %d \\n\" 输出 1 abc 1 abc abcdefabcdefabc def a b c d e f g h i j and 0 转义序列 序列 说明 \\a 警告字符，通常为ASCII的BEL字符 \\b 后退 \\c 抑制（不显示）输出结果中任何结尾的换行字符（只在 %b 格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略 \\f 换页（formfeed） \\n 换行 \\r 回车（Carriage return） \\t 水平制表符 \\v 垂直制表符 \\ 一个字面上的反斜杠字符 \\ddd 表示1到3位数八进制值的字符。仅在格式字符串中有效 \\0ddd 表示1到3位的八进制值字符 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:9:2","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"输入 / 输出重定向 大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。 一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。 同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。 重定向命令列表如下： 命令 说明 command \u003e file 将输出重定向到 file。 command \u003c file 将输入重定向到 file。 command » file 将输出以追加的方式重定向到 file。 n \u003e file 将文件描述符为 n 的文件重定向到 file。 n » file 将文件描述符为 n 的文件以追加的方式重定向到 file。 n \u003e\u0026 m 将输出文件 m 和 n 合并。 n \u003c\u0026 m 将输入文件 m 和 n 合并。 « tag 将开始标记 tag 和结束标记 tag 之间的内容作为输入。 ","date":"2021-11-23","objectID":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/:10:0","tags":["Linux","shell"],"title":"Linux shell 编程","uri":"/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/"},{"categories":["Linux"],"content":"文件操作 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:0","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"概念 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件的定义 广义：一切皆文件 狭义：磁盘文件 Linux中文件是一个字符流序列： 普通文件（文本文件、可执行文件） 目录 磁盘、键盘、打印机、网卡等设备 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:1","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件的成分 索引节点（i结点）： 文件的信息：文件权限、文件主、文件大小、存放位置、建立日期等 文件使用的一个标识符，同一个文件有相同的inode号。 数据：文件的实际内容、 查看文件的i节结号：ls -I ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:2","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件名 1、文件名最长可多达255个字符，除斜线/和空字符以外，文件名可以包含任意 的ACSII字符 2、避免使用特殊字符：；、|、\u003e、\u003c、”、`、$、！、%、\u0026、*、？、\\、（、）、[、]、空格、制表符或者其他的控制字符 3、习惯上允许使用“_”“.”来区别文件的类型；同类文件应使用同样的后缀 或扩展名 4、文件名区分大小写 5、以圆点“.”开头的文件名是隐含文件，必须使用ls –a 才能在屏幕上显示。 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:3","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件目录 1、用于标识系统中的文件及物理地址，提供给检索文件使用。 2、文件目录项包含：文件名、i结点号。 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:4","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件系统层次结构标准（FHS） / ：linux 系统目录树的起点 bin：命令文件目录，也称二进制目录 boot：存放系统的内核文件和引导装载程序文件 dev：设备文件目录，存放所有的设备文件，例如cdrom为光盘设备 etc：存放系统配置文件，如 password 文件 home：包含系统中各个用户的主目录，子目录名即为各用户名 lib：存放各种编程语言库 media：系统设置的自动挂载点，如u盘的自动挂载点 opt：表示可选择的意思，有些软件包会被安装在这里; usr：最大的目录之一，很多系统中，该目录是作为独立的分区挂载的，该目录中主要存放不经常变化的数据，以及系统下安装的应用程序目录 mnt：主要用来临时挂载文件系统，为某些设备默认提供挂载点 （WSL 中 windows 系统的文件会被挂载在这个目录） proc：虚拟文件系统，该目录中的文件是内存中的映像。 sbin：保存系统管理员或者 root 用户的命令文件。 tmp：存放临时文件 var：通常保存经常变化的内容，如系统日志、邮件文件等 root：系统管理员主目录 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:5","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件路径 分类 绝对路径：从 / 目录开始直到目标文件或者目录的路径 相对路径：相对路径是指从当前所在的目录出发，直到目标文件或者目录的路径。 表示目录的特殊符号 ~ 表示用户的主目录 . 表示当前目录 .. 表示上一级目录 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:6","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件类型 普通文件（-） 常规文件，包含各种长度的字符串。 内核对这些数据没有进行结构化，只是有序的字节序列 文本文件 ：信件、脚本等 数据文件：电子表格、数据库等 可执行的二进制文件：linux 系统所提供的各种命令 目录文件（d） 目录也称为文件夹，是一类特殊的文件； 每个目录的第一项：表示目录本身，并以 . 为文件名。 每个目录的第二项：表示该目录的父目录，用 .. 表示 设备文件（c、b） 设备文件除了存放在文件节点中的信息外，它们不包含任何数据。 设备文件通常在 /dev 目录下： 字符（character）设备：键盘、终端、打印机和鼠标。 块（block）设备：硬盘、光盘等。 链接文件（l） Linux 具有为一个文件起多个名字的功能，称为链接 其他 套接字（sockets） 管道（pipe） ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:7","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"基本操作 （一）创建文件 1、vi filename （vi编辑器的基本用法） 2、cat \u003e filename （输出重定向） 3、 touch 命令 【功能】更新一个文件的访问和修改时间，如果没有对应文件则新建该文件。 ​ 【格式】touch 文件或者目录路径 【实例】touch f1.sh （二）查看文件 1、ls （list）命令 【功能】显示目录内容，默认显示当前目录的文件列表。 如果所给的参数是文件，则仅列出与该文件有关的信息。 【格式】ls [-选项] [文件或目录路径] 【重要选项】 -a(all)：列出目录中所有项，包括以“.”开始的项（以点开头的为隐藏文件）。 -l（use a long listing format）：以长格式来显示文件的详细信息。每行列出 的信息依次是：文件的类型与权限、链 接数、文件属主、文件属组、文件大小、 建立或者最近修改的时间。 -i（inode）：在输出的第一列显示文件的索引节点号。 -d（directory）:仅列出目录本身的信息，而非列出目录中的文件列表信息 【常用】 按时间排序，以列表的方式显示目录项 ls -lrt （三）删除文件 1、rm 命令 【功能】删除文件与目录。 【格式】rm [选项] 文件名 【选项】 -f 文件名 不提示直接删除，强制删除 -r 目录名 递归删除目录文件 危险操作！ 【实例】rm f1.sh （四）其他 1、file命令 【功能】确定指定文件类型 【格式】file 文件名 [文件名…] 【实例】file * ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"目录操作 （一）新建目录 mkdir命令 【功能】新建目录 【格式】mkdir [选项] [目录名] 【实例1】新建目录dir1 mkdir dir1 【实例2】同时创建2个目录 mkdir dir2 dir3 【实例3】递归生成目录dir4、dir5 即dir4是当前目录的子目录，而dir5又是dir4的子目录 mkdir –p dir4/dir5 【实例4】对生成的目录指定权限: 744(111 100 100) mkdir –m 744 dir6 （二）切换目录 cd命令 【功能】更改当前目录 （执行和读权限） 【格式】cd [目录路径] 【实例】 cd /etc //切换到/etc目录下，可以是绝对路径、相对路径 cd //移到自己的主目录，适合于任何用户及任意目录下直接回到用户主目录下 cd ~ //移动到主目录下 cd .. //上移一层目录 （三）删除空目录 rmdir命令 【功能】删除空目录 【格式】rmdir [选项][目录路径] 【实例】 rmdir dir1 //删除空目录 rmdir dir4 //非空目录， dir4目录下还有目录（dir5）或者文件要用 “rm –r” （四）复制文件或目录 cp命令 【功能】复制文件或者目录 【格式】cp [选项] 源文件或者目录路径 目标文件或者目录路径 【常用选项】 -b 若存在同名文件，覆盖前先备份原来的文件 -r 以递归的方式复制文件，用于复制源目录内的内容（保留源目录 结构） -a 复制时包含当前目录 【实例1】将文件m1复制为f1（f1不存在） mkdir dir1 //创建新目录 cd dir1 //切换目录到dir1 cat \u003e m1 //创建m1 文件内容为m1 cp m1 f1 cat f1 // 查看f1的内容和m1一致 【实例2】将文件m1复制为f1（f1存在，内容为m1） cat \u003e m2 //创建m2 文件内容为m2 cp m2 f1 cat f1 //f1内容被m2内容覆盖 【实例3】将文件m3复制为f1，如果f1文件已经存在，则备份原来的f1文件。 cat \u003e m3 //创建m3的内容为m3 cat f1 //查看f1的内容 cp –b m3 f1 //备份的文件名为f1~；查看文件内容的变化 【实例4】将当前目录（dir1）下的所有文件（不包含目录）复制到test目录中 cd .. mkdir test //在user目录下创建目录test cd dir1 cp ./ * /home/user/test //将当前目录下的所有文件（不包含目录）复制到test目录中 【实例5】复制目录test的所有内容到dir1中 cp -a test dir1 //复制目录 （五）移动文件或目录 mv命令 【功能】移动或重命名文件或者目录。 【格式】mv [选项] 源文件或者目录路径 目标文件或者目录路径 【常用选项】 -b 若存在同名文件，覆盖前先备份原来的文件 -f 强制覆盖同名文件 【实例1】将文件名从f1变成f2 touch f1 mv f1 f2 【实例2】将目录dir4 改名为dir5 mkdir dir4 mv dir4 dir5 【实例3】将以m开头命名的多个文件移到dir4目录中（剪切） mv m* dir4 （六）查找、检索、排序文件 1、find命令 【功能】从指定路径开始向下搜索满足表达式的文件和目录。 【格式】find [路径] [表达式] [操作] 【常用表达式】 -name 文件 按文件名查找，可以使用通配符 -type 文件类型 按文件类型查找；f为普通文件、d为目录文件，l为链接 文件，b为块设备文件、C为字符设备文件 -size [+|-] 文件大小 查找指定大小的文件; c：字节 ； k： Kb ；M：Mb ； G：Gb -user 用户名 查找文件所有者为指定用户的文件 -group 组名 查找文件所属组为指定组的文件 -perm 权限值 按权限查找 -mtime(mmin)，-atime (amin)，-ctime(cmin) +/-n 按时间属性进行检索 【常用操作】 -delete 删除搜索到的文件和目录 -exec 命令名 { } ; 对搜索到的结果执行特定的命令 【时间属性检索】 -mtime（Modification time）：文件内容（内容数据）修改时间 -ctime（Change time）：文件属性（权限）修改时间 -atime（Access time）：文件被读取时间 -mtime n: n为数字，意义为在n天之前的一天以内被更改过的文件。 -mtime +n: 列出n天之前（不含n天本身）被更改过的文件 -mtime -n: 列出n天之内（含有n天本身）被更改过的文件 比如 查找3天之内修改过的文件 find –type f (–a与)(-o或)(!非) –mtime -3 2、grep命令 【功能】从指定文本文件或者标准输出中查找符合条件的字符串，默认显示其所在行的内容。 【格式】grep [选项] 字符串 [文件…] 【常用选项】 -i 忽略字符大小写的差别 -n 在显示符合的字符串之前，标出该行的行号 -v 显示不包含指定字符串的行 【实例1】在passwd文件中检索root字符串 grep root /etc/passwd cat /etc/passwd | grep root 3、sort命令 【功能】对文件进行排序与合并 【格式】sort [选项][文件列表] 【实例】 sort file1 对file1文件按每行第一个字符进行排序输出 sort file1 file2 对file1和file2两个文件合并起来排序并输出 sort -r file1 对file1文件按每行第一个字符进行反向排序 sort –r -o outf1 file1 对file1文件按每行第一个字符进行反向排序，并把 结果放在outf1中 sort -n file1 对file1文件按每行第一个字段进行数值排序 sort -k 3 file1 对file1文件按每行第3个字段为关键字进行排序 sort –n -k 3 file1 对file1文件按每行第3个字段进行数值排序 【例】 把当前目录下的所有文件按文件由大到小进行排序 ls –l |sort –n –r –k 5 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"文件权限 详见：https://blog.csdn.net/u013197629/article/details/73608613 （一）概念 1、文件权限是指文件的访问控制，即哪些用户可以访问文件以及执行 什么样的操作 2、用户分类 1）文件所有者（owner）：建立文件或者目录的用户 2）同组用户（group）：文件所属组群中的所有用户 3）其他用户（other）：既不是文件所有者，也不是同组用户的其他用户 3、文件的三类访问权限 1）读取权限：浏览文件/目录中内容的权限 2）写入权限 文件：修改文件内容的权限 目录：删除、添加和重命名目录内文件的权限 3）执行权限： 文件：对可执行文件而言，是允许执行的权限 目录：进入目录的权限 4、默认权限 新建一个文件或者目录时，系统会为文件设置默认权限。 默认权限的设置与系统的umask值有关 可以通过umask命令查看当前系统的umask设置 5、查看权限 ls -l 命令 （二）访问权限的表示方法 1、字母表示法 1）r（读） 2）w（写） 3）x（可执行或查找） 4）-（无权限） 2、字母表示法 相应权限位有权限表示为1，无权限表示为0，然后转换为八进制表示 （三）修改文件的权限 1、chmod 命令 【功能】修改文件的访问权限（文件属主或者root） 【格式1】chmod 字母模式 文件名 【例】新建文件file （权限为 110 110 100） chmod g+x , o-r file // 给同组用户增加x权限，其他用户取消r权限 【格式2】chmod 数字模式 文件名 【例】新建文件file1（权限为 110 110 100） chmod 670 file1 //为同组用户增加x权限，其他用户取消r权限 2、chown命令 【功能】修改文件的所有者，并可一并修改文件的所属组群 【格式】chown 文件所有者 [:组群] 文件 【例】 1） 将文件f3所有者由root改为zlh 以root身份登陆，先创建用户zlh chown zlh f3 ls –l 2）将f4文件的所有者和所属组群设置为zlh用户和zlh组群 chown zlh：zlh f4 ls -l 3） 将文件f5所属组群修改为zlh chown ： zlh f5 ls –l 3、chgrp命令 【功能】修改文件的所属组群 【格式】chgrp 组群 文件 【例】将f6所属的组群由root改为zlh ls –l chgrp zlh f6 ","date":"2021-10-24","objectID":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/:4:0","tags":["Linux"],"title":"Linux 文件操作","uri":"/Notes/posts/linux/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["CPP"],"content":"基本语法 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:0:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"基本形式 class 类名 { public: //行为或属性 protected: //行为或属性 private: //行为或属性 }; 大括号内为类体，装成员函数、数据成员 例 class Point { public: void setPoint(int x, int y); void printPoint(); private: int xPos; int yPos; }; ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:1:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"定义 类成员 类可以没有成员，也可以定义多个成员。成员可以是数据、函数或类型别名。所有的成员都必须在类的内部声明 数据成员 变量、数组、常量、对象、对象数组 对象称为组合成员 成员函数 成员函数必须在类内部声明，可以在类内部定义，也可以在类外部定义。如果在类内部定义，就默认是内联函数 分类： 特殊函数 ​ 构造函数（浅/深拷贝构造函数）、析构函数、常函数/只读函数、静态函数、虚函数、纯虚函数、赋值函数 一般函数 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:2:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"对类的实例化 创建对象 Test test1, test2(3), test3(3, 4); Test tArray[10]; Test *tPtr = \u0026test1; Test \u0026tRef = test1; 动态地为其分配内存 Test *p; p = new Test; delete p; //对象数组 p = new Test[5]; delete[] p; //堆对象调用函数 p-\u003eShow(); ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:3:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"定义函数体 //在类内部定义函数体 class 类名 { 返回类型 函数名(形参列表) { //函数体 } }; //在类外部定义函数体 class 类名 { 返回类型 函数名(形参列表); }; 返回类型 类名::函数名(形参列表) { //函数体 }  ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:4:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"调用类的成员 一般调用 Test test1; test1.Sum(); 引用调用 Test test1, \u0026r = test1; r.Sum(); 开辟内存调用 Test *p; p = new Test; p-\u003eSum(); 使用无名对象调用（语句结束，自动析构） test2.Test(); test2=Test(1,2); 指针调用 Test test1(3, 4), *p = \u0026test1; test1.Sum(); p-\u003eSum(); (*p).Sum(); (p[0]).Sum(); ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:5:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"this指针常量 成员函数（除了静态函数）具有一个附加的隐含形参（表现为Test *const this），即 this指针，它由编译器隐含地定义。成员函数的函数体可以显式使用 this 指针 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:6:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"常函数 特点 可以使用数据成员，不能进行修改，对函数的功能有更明确的限定； 常对象只能调用常函数，不能调用普通函数； 常函数的this指针是const CStu*，即指向常量的常量指针（常量指针常量） 格式 void fun() const {} 例 int Geta() const { return a; } 构造函数 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:7:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"特征 函数名与类名相同 一般有形参表 构造函数是一种特殊的成员函数，不需要人为调用，而是在对象建立的时候自动被执行 例 class Test { public: Test (); Test (int x,int y); private: int a,b; }; Test::Test() { } Test::Test(int x,int y) { a=x; b=y; } //在主函数中调用 Test test1(3,4); Test ()为无参构造函数或默认构造函数，写这个函数的好处是当你在创建对象的时候并不想立即对它初始化，而是在后续的工作中再进行赋初值，即：Test test1; 部分IDE会自动生成一个默认构造函数 Test(int x,int y)完成了初始化工作，它有两个形参，分别给数据成员a，b进行初始化，定义对象的时候传入了 3和4，则 a和b 被初始化为 3 和 4 成员初始化表 用来赋初值，可在构造函数的形参中赋初值 在类内 Test (int x,int y):a(x),b(y) {} 在类外 Test::Test(int x,int y):a(x),b(y) { //… } 在含有组合成员的类里，构造函数、拷贝构造函数都需要用成员初始化表 构造函数可以重载，也可以带默认参数 Test (int x = 0,int y = 0):a(x),b(y) {} Test test(3); 一旦指定了 x = 0，就必须指定 y 的值 所以这样是错误的：Test (int x = 0,int y):a(x),b(y) {} 在类内，默认值写在()中 在类外，~~默认值写在{}中，~~声明写，定义不写 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:8:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"分类 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:9:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"默认构造函数 无实参 Point() {} ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:9:1","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"一般构造函数 Point(int x = 0, int y = 0) : xPos(x), yPos(y) {} ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:9:2","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"拷贝构造函数 Point(const Point \u0026N) {} 用一个已经生成的对象来初始化另一个同类的对象 可以用成员初始化表 格式 类名 (const 类名\u0026 obj) { //函数体 } 例 Test (const Test\u0026 t):a(t.a),b(t.b) {} Test(const Test \u0026t) { this-\u003ea = t.a; this-\u003eb = t.b; } 如果不定义复制构造函数，以上对象也可以这样进行初始化，原因就是系统也会自己生成一个复制构造函数 在主函数内调用 Point p1(3, 4); Point p2 = p1; Point p2(p1); ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:9:3","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"转换构造函数 带一个实参的构造函数，它可以实现数据量类型的隐式转换和强制转换 Point(int x) { xPos = x; yPos = 1; } //在类内，能把x这个int数据转换成一个对象 Point p1 = 4; Point p2(8); 可以用成员初始化表 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:9:4","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"深拷贝构造函数 浅拷贝 默认拷贝构造函数可以完成对象的数据成员简单的复制,这也称为浅拷贝 浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间 深拷贝 深拷贝不但对指针进行拷贝，而且对指针指向的内容进行拷贝 经深拷贝后的指针是指向两个不同地址的指针 例 只占有栈空间的类，可以用默认的浅拷贝函数 class Test1 { private: int p; public: Test(int x) { this-\u003ep = x; } //浅拷贝 Test(const Test1 \u0026a) { this-\u003ep = a.p; } }; 占有堆空间（指针）的类，使用深拷贝函数 class Test2 { private: int *p; public: Test2(int x) { this-\u003ep = new int(x); } //深拷贝 Test2(const Test2 \u0026a) { this-\u003ep = new int(*a.p); } }; 总而言之，浅拷贝会把指针变量的地址复制; 深拷贝会重新开辟内存空间 析构函数 作用 析构函数在类里起了一个“清理”的作用，比如类中有需要动态开辟内存的成员，而在程序结束之后我们需要释放内存，这时只要将释放内存的语句写在析构函数中，而系统在程序运行结束之后会自动执行析构函数，进行内存的释放以及对象的销毁 先构造的后析构 格式 默认的析构函数 ~Test(){}; 占用堆空间的类的析构函数 ~Test() { if (p != NULL) delete p; } 赋值运算符函数 格式 类名 \u0026operator=(const 类名 \u0026source_arg) 例 class Test { private: int *p; public: Test(int x) { this-\u003ep = new int(x); } void Show() const { cout \u003c\u003c *p \u003c\u003c endl; } Test(const Test \u0026a) { this-\u003ep = new int(*a.p); } ~Test() { if (p != NULL) delete p; } Test \u0026operator=(const Test \u0026a) { if (\u0026a != this) //防止自我赋值而丢失资源 { if (p != NULL) delete p; //主动释放原资源 this-\u003ep = new int(*a.p); //申请资源 } return *this; //返回赋值结果 } }; 要点 如果对象在声明的同时马上进行初始化操作，则称之为拷贝运算 如果对象在声明之后，再进行赋值运算，称之为赋值运算 在类外定义 Test \u0026Test::operator=(const Test \u0026N) 类模板 例 template \u003cclass T1, class T2, class T3\u003e class Student { public: Student(T1 name, T2 age, T3 score) { //......... } T1 m_Name; T2 m_Age; T3 m_Score; }; //主函数中声明对象 Student\u003cstring,int,float\u003es(\"Tom\",18,85.5); 类的函数模板 如果在类外定义，类外要写上函数模板的形式，类内声明时不用 template \u003cclass T1, class T2\u003e Student\u003cT1, T2\u003e::Student(T1 name, T2 age) : m_name(mName), m_age(mAge) {} ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:9:5","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"大大大大大例子 #ifndef VECTOR_H #define VECTOR_H #include \u003cbits/stdc++.h\u003eusing namespace std; template \u003ctypename T\u003e class Vector { public: Vector(T *coor = NULL, int len = 0); Vector(const Vector\u003cT\u003e \u0026N); ~Vector(); Vector \u0026operator=(const Vector\u003cT\u003e \u0026N); /*功能函数*/ void Show() const; T GetLen() const; void Resize(int num); /*双目运算符重载*/ template \u003ctypename TYPE\u003e friend Vector\u003cTYPE\u003e operator+(const Vector\u003cTYPE\u003e \u0026v1, const Vector\u003cTYPE\u003e \u0026v2); template \u003ctypename TYPE\u003e friend Vector\u003cTYPE\u003e operator-(const Vector\u003cTYPE\u003e \u0026v1, const Vector\u003cTYPE\u003e \u0026v2); template \u003ctypename TYPE\u003e friend Vector\u003cTYPE\u003e operator*(const TYPE \u0026a, const Vector\u003cTYPE\u003e \u0026v1); template \u003ctypename TYPE\u003e friend Vector\u003cTYPE\u003e operator*(const Vector\u003cTYPE\u003e \u0026v1, const TYPE \u0026a); Vector\u003cT\u003e \u0026operator+=(const Vector\u003cT\u003e \u0026v1); Vector\u003cT\u003e \u0026operator-=(const Vector\u003cT\u003e \u0026v1); /*单目运算符重载*/ Vector\u003cT\u003e \u0026operator++(); //前置++ Vector\u003cT\u003e \u0026operator--(); //前置-- Vector\u003cT\u003e operator++(int); //后置++ Vector\u003cT\u003e operator--(int); //后置-- /*关系运算符重载*/ bool operator==(const Vector\u003cT\u003e \u0026v1); bool operator!=(const Vector\u003cT\u003e \u0026v1); T \u0026operator[](int index) const; //下标运算符 /*IO流操作运算符重载*/ template \u003ctypename TYPE\u003e friend istream \u0026operator\u003e\u003e(istream \u0026in, Vector\u003cTYPE\u003e \u0026v1); template \u003ctypename TYPE\u003e friend ostream \u0026operator\u003c\u003c(ostream \u0026out, const Vector\u003cTYPE\u003e \u0026v1); private: T *m_coor; int m_len; }; template \u003ctypename T\u003e Vector\u003cT\u003e::Vector(T *coor, int len) { //int len = sizeof(coor) / sizeof(coor[0]); //不可行，辣鸡C++ m_len = len; m_coor = new T[len]; for (int i = 0; i \u003c m_len; i++) { m_coor[i] = coor[i]; } } template \u003ctypename T\u003e Vector\u003cT\u003e::Vector(const Vector\u003cT\u003e \u0026N) { /* m_len = N.m_len; m_coor = new int[m_len]; for (int i = 0; i \u003c m_len; i++) { m_coor[i] = N.m_coor[i]; } */ m_len = 0; m_coor = NULL; *this = N; } template \u003ctypename T\u003e Vector\u003cT\u003e::~Vector() { m_len = 0; if (m_coor != NULL) delete[] m_coor; } template \u003ctypename T\u003e Vector\u003cT\u003e \u0026Vector\u003cT\u003e::operator=(const Vector\u003cT\u003e \u0026N) { m_len = N.m_len; m_coor = new int[m_len]; for (int i = 0; i \u003c m_len; i++) { m_coor[i] = N.m_coor[i]; } return *this; } template \u003ctypename T\u003e void Vector\u003cT\u003e::Show() const { cout \u003c\u003c \"The coordinates of this \" \u003c\u003c m_len \u003c\u003c \"-dimensional vector are: (\"; for (int i = 0; i \u003c m_len - 1; i++) { cout \u003c\u003c m_coor[i] \u003c\u003c \", \"; } cout \u003c\u003c m_coor[m_len - 1] \u003c\u003c \")\" \u003c\u003c endl; } template \u003ctypename T\u003e T Vector\u003cT\u003e::GetLen() const { return m_len; } template \u003ctypename T\u003e void Vector\u003cT\u003e::Resize(int num) { if (num \u003c 0) { T *temp = m_coor; //delete[] m_coor; //不可delete，下同 m_coor = new T[m_len + num]; for (int i = 0; i \u003c m_len + num; i++) { m_coor[i] = temp[i]; } //delete[] temp; //此处delete，待证，下同 m_len += num; } else if (num \u003e 0) { T *temp = m_coor; m_coor = new T[m_len + num]; for (int i = 0; i \u003c m_len + num; i++) { m_coor[i] = (i \u003c m_len) ? temp[i] : 0; } //delete[] temp; m_len += num; } else return; } template \u003ctypename T\u003e Vector\u003cT\u003e operator+(const Vector\u003cT\u003e \u0026v1, const Vector\u003cT\u003e \u0026v2) { Vector\u003cT\u003e result(v1); if (v1.m_len != v2.m_len) return result; for (int i = 0; i \u003c result.m_len; i++) { result[i] += v2[i]; } return result; } template \u003ctypename T\u003e Vector\u003cT\u003e operator-(const Vector\u003cT\u003e \u0026v1, const Vector\u003cT\u003e \u0026v2) { Vector\u003cT\u003e result(v1); if (v1.m_len != v2.m_len) return result; for (int i = 0; i \u003c result.m_len; i++) { result[i] -= v2[i]; } return result; } template \u003ctypename T\u003e Vector\u003cT\u003e operator*(const T \u0026a, const Vector\u003cT\u003e \u0026v1) { Vector\u003cT\u003e result(v1); for (int i = 0; i \u003c v1.m_len; i++) { result.m_coor[i] = a * v1.m_coor[i]; } return result; } template \u003ctypename T\u003e Vector\u003cT\u003e operator*(const Vector\u003cT\u003e \u0026v1, const T \u0026a) { return a * v1; } template \u003ctypename T\u003e Vector\u003cT\u003e \u0026Vector\u003cT\u003e::operator+=(const Vector\u003cT\u003e \u0026v1) { return *this = *this + v1; } template \u003ctypename T\u003e Vector\u003cT\u003e \u0026Vector\u003cT\u003e::operator-=(const Vector\u003cT\u003e \u0026v1) { return *this = *this - v1; } template \u003ctypename T\u003e Vector\u003cT\u003e \u0026Vector\u003cT\u003e::operator++() { for (int i = 0; i \u003c m_len; i++) { m_coor[i]++; } return *this; } template \u003ctypename T\u003e Vector\u003cT\u003e \u0026Vector\u003cT\u003e::operator--() { for (int i = 0; i \u003c m_len; i++) { m_coor[i]--; } return *this; } templat","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:10:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"静态数据成员 定义 在一个类中，如果将一个数据成员申明为static，这种成员就被称为静态数据成员。与一般数据成员不同的是，无论建立多少个类的对象，都只有一个静态数据成员拷贝 创建、定义及初始化 格式 创建 static 数据类型 变量名 定义及初始化 (Type className::VarName = value) 数据类型 类名::静态数据成员名 = value; 数据类型 类名::静态数据成员名(value); 例 class Test { private: int m_num; static int m_count; //创建静态数据成员 public: Test(int num = 0) { m_num = num; m_count++; } }; int Test::m_count = 0; //定义及初始化静态数据成员，类的静态成员变量需要在类外分配内存空间 int Test::m_count(0); //第二种方法 访问 格式 对象名.静态数据成员名 类名::静态数据成员名 例 Test t1(1); int a; a = Test::m_count; //公有的静态成员才能这样被访问 a = t1.m_count; 说明 静态数据成员的生命期不依赖于任何对象，为程序的生命周期 静态数据成员需要在类外单独分配空间， 静态数据成员在程序内部位于全局数据区 静态数据成员属于类，而不像普通的数据成员那样属于某个对象，因此我们可以用“类名::”这样的形式访问静态数据成员 静态数据成员在该类的任何对象创建之前就已经存在。因此，公有的静态数据成员可以在对象定义之前就被访问 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:11:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"静态成员函数 格式 static 返回类型 静态成员函数名（形参列表）; 例 static int getCount() { return m_count; } 调用 格式 对象名.静态成员函数名 类名::静态成员函数名 例 Test::getCount; t1.getCount; 说明 静态成员函数属于整个类所有，没有this指针 静态成员函数只能直接访问静态成员变量和静态成员函数 静态成员函数可以定义成内嵌的，也可以在类外定义，在类外定义时，前面不需要加static 使用静态成员函数的一个原因就是可以用它在建立任何对象之前处理静态数据成员 译系统将静态成员函数限定为内部连接，也就是说，与现行的文件相连接的文件中的同名函数不会与该函数发生冲突，维护了该函数的安全性，这是使用静态成员函数的另外一个原因 友元 概念 C++提供了友元机制，允许一个类将其非公有成员的访问权限授予指定的函数或类。友元的声明只能在类定义的内部，因此，访问类非公有成员除了自身成员，还有友元 友元的作用在于提高程式的运行效率，但是，他破坏了类的封装性和隐藏性，使得非成员函数能够访问类的私有成员 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:12:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"友元函数 格式 在类中使用 friend 关键字来添加友元函数 friend 类型 函数名(形式参数); 例 //类内 friend int getSumNum(Test t1,Test t2); //类外 int getSumNum(Test t1,Test t2) { int result=t1.m_num+t2.m_num; return result; } 说明 友元函数是能够访问类中私有成员的非成员函数 友元函数在类内声明，类外定义，定义和使用时不需加作用域和类名，与普通函数无异。 一个函数可以是多个类的友元函数，只需要在各个类中分别声明 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:13:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"友元类 概念 声明一个类是另一个类的友元 格式 在类内声明 friend class 类名; 例 class Test { friend class X; //X是Test的友元类，X可以访问Test的任意成员 private: int m_num; public: Test(int num = 0) { m_num = num; } }; 说明 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元 强制类型转换 例 class Student { public: string name; int age; }; //在成员函数中 operator int() const { return age; } operator string() const { return name; } //在主函数中使用 int age1 = (int)stu1; string name1 = (string)stu2; 重载运算符 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:14:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"概念 在 C++ 中，可以称运算符为运算符函数 即运算符是一种特殊的函数； 它们的名称、定义和调用格式与普通函数有些差别； 运算符函数可以作为某个类的成员函数，也可以作为普通的C++函数（常作为类的友元函数） 规定 C++ 不允许用户自己定义新的运算符； 不允许改变运算符操作数的个数（自然不允许使用带默认值的参数）； 不能改变运算符的运算优先级； 不能改变运算符的运算结合方向。 下列 5 个运算符不允许被重载。 :: 作用域区分符 . 成员访问运算符 .* 成员指针访问运算符 sizeof 数据尺寸运算符 ? : 三目条件运算符（唯一的三目运算） 重载运算符时，至少要有一个操作数为用户自定义的类类型（因为对基本数据类型及其指针而言，其定义已经存在，而构成重载必须有不同于基本数据类型的参数）。 重载的运算符函数不能为类的静态成员函数。 须指出的是系统不会将运算符 “+” 与运算符 “=” 自动组合成运算符 “+=”。需要使用运算符 “+=” 时，应该单独重载它 基本原则 尽可能地使用引用型形式参数，并尽可能地加以 const 限制。其作用是尽可能地避免拷贝构造形参操作数；尽可能地保护实参操作数；同时使操作符具有与常量运算的能力。 尽可能地采用引用返回，其作用是尽可能地避免拷贝构造临时对象。 若第一个操作数可能为非本类的对象时，应考虑将运算符重载成类的友元函数； 尽可能地保持运算符原有的含义、保持运算符的直观可视性； 充分利用类型转换函数、转换构造函数 目的 运算符重载的基本指导原则是为了让自定义类的行为和内建类型一样。自定义类的行为越接近内建类型，就越便于这些类的客户使用。例如，如果要编写一个表示分数的类，最好定义+、-、*和/运算符应用于这个类的对象时的意义。 重载运算符的第二个原因是为了获得对程序行为更大的控制权。例如，可对自定义类重载内存分配和内存释放例程，来精确控制每个对象的内存分配和内存回收。 需要强调的是，运算符重载未必能给类开发者带来方便；主要用途是给类的客户带来方便 分类 普通运算符重载(“ + ”、“-”、“ * ”、“ / ”等) 前置运算符重载(\"++\"、\"--\") 后置运算符重载(\"++\"、\"--\") 插入运算符重载(\"\u003e\u003e\") 提取运算符重载(\"\u003c\u003c\") 总结 * / % ^ \u0026 | ~ ! = \u003c \u003e += -= *= /= %= ^= \u0026= |= \u003c\u003c \u003e\u003e \u003c\u003c= \u003e\u003e= == != \u003c= \u003e= \u0026\u0026 || ++ -- , -\u003e* -\u003e () [] new new[] delete delete[] ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:15:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"重载各类运算符 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"I/O 流操作运算符 系统重载这两个操作符是以系统类成员函数的形式进行的，因此 cout« var 语句可以理解为：cout.operator«( var ) 习惯用类外的友元函数重载形式 istream \u0026operator\u003e\u003e(istream \u0026in, Student \u0026s1) { in \u003e\u003e s1.age \u003e\u003e s1.weight; return in; } ostream \u0026operator\u003c\u003c(ostream \u0026out, Student \u0026s1) { out \u003c\u003c s1.age \u003c\u003c \", \" \u003c\u003c s1.weight; return out; } //同时在类内添加友元 friend istream \u0026operator\u003e\u003e(istream \u0026in, Student \u0026s1); friend ostream \u0026operator\u003c\u003c(ostream \u0026out, Student \u0026s1); ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:1","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"双目算术运算符 一般为类内成员函数，友元也可 Student operator-(const Student \u0026s2) { Student temp(this-\u003eage - s2.age, this-\u003eage - s2.weight); return temp; } Student operator*(const Student \u0026s2) { Student temp(this-\u003eage * s2.age, this-\u003eage * s2.weight); return temp; } Student operator/(const Student \u0026s2) { Student temp(this-\u003eage / s2.age, this-\u003eage / s2.weight); return temp; } ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:2","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"下标运算符 必须以类的成员函数的形式进行重载 返回类型 \u0026 operator[] (参数) 或 const 返回类型 \u0026 operator[] (参数) 如果使用第一种声明方式，操作符重载函数不仅可以访问对象，同时还可以修改对象 如果使用第二种声明方式，则操作符重载函数只能访问而不能修改对象 以String类为例 char \u0026operator[](int index) const { return String[index]; } ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:3","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"迭代赋值运算符 Student \u0026operator+=(const Student \u0026s2) { this-\u003eage = this-\u003eage + s2.age; this-\u003eweight = this-\u003eweight + s2.weight; return *this; } 其余类似 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:4","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"关系运算符 bool operator\u003e(const Student \u0026s2) { return this-\u003eage - s2.age \u003e 0; } 其余类似 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:5","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"前（后）增（减）量运算符（单目运算符） 前置 Student \u0026operator++() { this-\u003eage++; this-\u003eweight++; return *this; } 后置 Student operator++(int) { Student temp(this-\u003eage, this-\u003eweight); age++; weight++; return temp; } //或 Student operator++(int) { Student temp(*this); //拷贝构造 ++（*this）; //利用前增量运算符函数 return temp; } 其余类似 继承和派生 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:16:6","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"概念 类的继承就是新类由已经存在的类获得已有特性，类的派生是由已经存在的类产生新类的过程。已有类叫做基类，产生的新类叫做派生类 一个派生类可以有多个基类，叫做多继承；否则为单继承。直接派生出某个类的基类叫做这个类的直接基类，基类的基类或更高层的基类叫做派生类的间接基类 基类的构造函数和析构函数派生类是不能继承的。如果派生类需要对新成员初始化或者进行特定的清理工作，就需要就需要自己定义构造函数和析构函数了。从基类继承的成员的初始化仍可通过基类的构造函数来完成 派生类的数据成员包括从基类继承来的数据成员和派生类新增的数据成员，还可能包括其他类的对象（实际上还间接包括了这些对象的数据成员）作为其数据成员。我们对派生类初始化时需要对基类的数据成员、派生类新增数据成员和内嵌的其他类对象的数据成员进行初始化。 基类的构造函数若有参数，则派生类必须定义构造函数，将传入的参数再传递给基类的构造函数，对基类进行初始化。若基类没有定义构造函数，则派生类也可以不定义构造函数，都使用默认构造函数，对于派生类的新增数据成员可以通过其他的公有函数成员来初始化。而如果基类同时定义了默认构造函数和带参数的构造函数，那么在派生类的构造函数中可以给出基类名及其参数表，也可以不显式给出 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:17:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"格式 class DeriveClass: acess_label BaseClass ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:18:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"例 #include \u003cbits/stdc++.h\u003eusing namespace std; class Base // 基类Base的声明 { public: // 公有成员函数 Base(int a, int b) { x = a; y = b; } int GetX() { return x; } int GetY() { return y; } private: // 私有数据成员 int x; int y; }; class Child : private Base // 派生类的声明，继承方式为私有继承 { public: // 新增公有成员函数 Child(int a, int b, int c) : Base(a, b), z(c) {} int GetX() { return Base::GetX(); } //这叫重写/覆盖，不能叫重载 int GetY() { return Base::GetY(); } int GetZ() { return z; } private: // 新增私有数据成员 int z; }; int main() { Child c1(1, 2, 3); cout \u003c\u003c c1.GetX() \u003c\u003c c1.GetY() \u003c\u003c c1.GetZ() \u003c\u003c endl; system(\"pause\"); } ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:18:1","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"继承方式 一般使用公有继承 公有继承 派生类对基类中的公有成员和保护成员的访问属性都不变，而对基类的私有成员则不能访问。（类的对象也属于类外的，不能访问保护成员） 保护继承 基类的公有成员和保护成员被派生类继承后变成派生类的保护成员，而基类的私有成员在派生类中不能访问。 私有继承 基类的公有成员和保护成员被派生类继承后变成派生类的私有成员，而基类的私有成员在派生类中不能访问 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:19:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"派生类的构造函数 说明 派生类的构造函数需要做的工作有，使用传递给派生类的参数，调用基类的构造函数和内嵌对象成员的构造函数来初始化它们的数据成员，再添加新语句初始化派生类新成员。派生类构造函数的语法形式为： 派生类名::派生类名(参数表):基类构造函数名1(参数表1),...基类构造函数名m(参数名m),组合成员名(对象参数表1),...,组合成员名n(对象参数表n)，其他成员初始化 { 初始化派生类新成员的语句; } 基类的构造函数若有参数，则派生类必须定义构造函数，将传入的参数再传递给基类的构造函数，对基类进行初始化。 若基类没有定义构造函数，则派生类也可以不定义构造函数，都使用默认构造函数，对于派生类的新增数据成员可以通过其他的公有函数成员来初始化。 而如果基类同时定义了默认构造函数和带参数的构造函数，那么在派生类的构造函数中可以给出基类名及其参数表，也可以不显式地给出 执行构造函数的构造顺序 首先调用基类的构造函数，若有多个基类，调用顺序按照它们在派生类声明时从左到右出现的顺序 如果有内嵌对象成员，则调用内嵌对象成员的构造函数，若为多个内嵌对象，则按照它们在派生类中声明的顺序调用，如果无内嵌对象则跳过这一步； 调用派生类构造函数中的语句 例 #include \u003ciostream\u003eusing namespace std; class Base1 // 基类Base1，只有默认构造函数 { public: Base1() { cout \u003c\u003c \"Base1 construct\" \u003c\u003c endl; } }; class Base2 // 基类Base2，只有带参数的构造函数 { public: Base2(int x) { cout \u003c\u003c \"Base2 construct \" \u003c\u003c x \u003c\u003c endl; } }; class Base3 // 基类Base3，只有带参数的构造函数 { public: Base3(int y) { cout \u003c\u003c \"Base3 construct \" \u003c\u003c y \u003c\u003c endl; } }; class Child : public Base2, public Base1, public Base3 // 派生类Child { public: Child(int i, int j, int k, int m) : Base2(i), Base3(j), b2(k), b3(m) {} private: // 派生类的内嵌对象成员 Base1 b1; Base2 b2; Base3 b3; }; int main() { Child child(3, 4, 5, 6); system(\"pause\"); } 基类和内嵌对象成员的构造函数的调用顺序和它们在派生类构造函数中出现的顺序无关 Child(int i, int j, int k, int m) : Base2(i),b3(j),b2(k),Base3(m) {} 结果按照i,m,k,j的顺序赋值 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:20:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"派生类的析构函数 说明 派生类的析构函数一般只需要在其函数体中清理新增成员就可以了，对于继承的基类成员和派生类内嵌对象成员的清理，则一般由系统自动调用基类和对象成员的析构函数来完成 执行析构函数的清理顺序（正好和派生类构造函数相反） 执行析构函数语句清理派生类的新增成员； 调用内嵌对象成员所属类的析构函数清理派生类内嵌对象成员，各个对象成员的清理顺序与其在构造函数中的构造顺序相反； 调用基类的析构函数清理继承的基类成员，如果是多继承则各个基类的清理顺序也与其在构造函数中的构造顺序相反。 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:21:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"作用域分辨符 在派生类内部访问基类同名成员的语法形式 基类名::数据成员名; // 数据成员 基类名::函数成员名(参数表); // 函数成员 在派生类外通过派生类对象访问的话，前面还要加上“派生类对象名.” 派生类对象名.基类名::数据成员名; // 数据成员 派生类对象名.基类名::函数成员名(参数表); // 函数成员 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:22:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"类型兼容/复制兼容 说明 赋值兼容规则就是指在基类对象可以使用的地方都可以用公有派生类对象来代替。 可以使用类Base对象的地方都可以使用类Child的对象来代替。 规则 派生类对象可以赋值给基类对象。也就是将派生类对象从基类继承的成员的值分别赋值给基类对象相应的成员。例如： base = child; 派生类对象的地址可以赋值给基类类型的指针。例如：pBase = \u0026child; 派生类对象可以用来初始化基类的引用。例如：Base \u0026b = child; 公有派生类对象可以代替基类对象使用，但是我们只能使用它从基类继承的成员，而无法使用它的新添成员。 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:23:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"虚函数 说明 虚函数就是在类的声明中用关键字virtual限定的成员函数 虚函数是非静态的成员函数，一定不能是静态（static）的成员函数 虚函数的主要作用就是显示的声明基类中的函数可以在派生类中重新定义，也就是说只有成员函数才能被申明为虚函数 构造函数不能是虚函数；基类析构函数应当是虚析构函数，即使它不执行任何操作 格式 类内 virtual 函数类型 函数名(形参表) { 函数体 } 类外 只能在此成员函数的声明前加virtual修饰，而不能在它的定义（实现）前加 虚析构函数 析构函数用于在类的对象消亡时做一些清理工作，我们在基类中将析构函数声明为虚函数后，其所有派生类的析构函数也都是虚函数，使用指针引用时可以动态绑定，实现运行时多态，通过基类类型的指针就可以调用派生类的析构函数对派生类的对象做清理工作。 析构函数没有返回值类型，没有参数表，所以虚析构函数的声明也比较简单，形式如下 virtual ~类名(); 纯虚函数 即使有的虚函数在基类中不需要做任何工作，我们也要写出一个空的函数体，这时这个函数体没有什么意义，重要的是此虚函数的原型声明。C++为我们提供了纯虚函数，让我们在这种情况下不用写函数实现，只给出函数原型作为整个类族的统一接口就可以了，函数的实现可以在派生类中给出。 抽象类不能实例化 纯虚函数是在基类中声明的，声明形式为 virtual 函数类型 函数名(参数表) = 0; 纯虚函数的声明形式与一般虚函数类似，只是最后加了个=0。纯虚函数这样声明以后，在基类中就不再给出它的实现了，各个派生类可以根据自己的功能需要定义其实现。 一些要点 类相当于一种新的数据类型，数据类型不占用存储空间，用类型定义一个实体的时候，才会为它分配存储空间 面向对象程序设计过程中一般将数据隐蔽起来，也就是说一般的变量(数据)都声明为private，而成员函数声明为public。如果在声明的时候不写访问控制属性，则类会默认它为private。 在类里面，数据成员不能够进行初始化 对象所占的空间等于基本空间（所有数据成员所占的字节，可以用sizeof()显示）和资源空间（生成的堆空间） 创建对象数组，先定义的后析构 在类的设计中，若类的对象可能带有资源（数据成员为指针，开辟过堆空间），则应定义深拷贝构造函数，重载赋值运算符以实现深赋值运算，定义析构函数释放资源。 类的三大特性：封装性、继承性、多态性 重载：相同作用域，函数名相同 重写：不同作用域，函数头完全相同 隐藏：不同作用域，函数名相同（返回类型、形参表等可能不同） 基类指针指向派生类对象，再用基类指针调用派生类虚函数，会产生多态（迟后联编） 十一、链表类 #ifndef LinkList_H #define LinkList_H #include \u003cbits/stdc++.h\u003eusing namespace std; class Link { public: Link(int num, string name, int age, int grade); //构造函数 Link(const Link \u0026a); //拷贝构造函数 Link \u0026operator=(const Link \u0026a); //赋值运算符函数 ~Link(); //析构函数 static void Show(); //显示全部链表的各结点的学生信息 static void ShowGrade(int flag); //找出语文成绩最高/低的同学 static void ShowAge(int age); //找出年龄为某岁的学生个数，并输出学生信息 void DeleteNode(); //删除指定节点 static void SortByNumber(); //按学号排序 void ModifyGrade(int grade); //修改分数 friend void ShowInfo(Link a); //显示某对象的全部信息 private: int m_number; string m_name; int m_age; int m_grade; Link *next; static Link *head; static int num; }; Link *Link::head = NULL; int Link::num = 0; Link::Link(int number, string name, int age, int grade) { num++; m_number = number; m_name = name; m_age = age; m_grade = grade; this-\u003enext = head; head = this; cout \u003c\u003c \"Create an object \" \u003c\u003c name \u003c\u003c endl; } Link::Link(const Link \u0026a) { num++; m_number = a.m_number; m_name = a.m_name; m_age = a.m_age; m_grade = a.m_grade; this-\u003enext = head; head = this; cout \u003c\u003c \"Copy an object \" \u003c\u003c a.m_name \u003c\u003c endl; } Link \u0026Link::operator=(const Link \u0026a) { cout \u003c\u003c \"change \" \u003c\u003c m_name \u003c\u003c \"into \" \u003c\u003c a.m_name \u003c\u003c endl; m_number = a.m_number; m_name = a.m_name; m_age = a.m_age; m_grade = a.m_grade; return *this; } Link::~Link() { Link *pGuard = head; if (head == this) head = this-\u003enext; else { while (pGuard-\u003enext != this) pGuard = pGuard-\u003enext; pGuard-\u003enext = this-\u003enext; } num--; cout \u003c\u003c \"Delete the list successfully~\" \u003c\u003c endl; } void Link::Show() { Link *p; cout \u003c\u003c \"Number of nodes: \" \u003c\u003c num \u003c\u003c endl; for (p = head; p != NULL; p = p-\u003enext) { cout \u003c\u003c \"00\" \u003c\u003c p-\u003em_number \u003c\u003c setw(8) \u003c\u003c p-\u003em_name \u003c\u003c setw(8) \u003c\u003c p-\u003em_age \u003c\u003c \"岁\" \u003c\u003c setw(8) \u003c\u003c p-\u003em_grade \u003c\u003c \"分\" \u003c\u003c endl; } } void Link::ShowGrade(int flag) { Link *p; Link *HighGra, *LowGra; HighGra = head; LowGra = head; for (p = head; p != NULL; p = p-\u003enext) { if (p-\u003em_grade \u003e HighGra-\u003em_grade) { HighGra = p; } if (p-\u003em_grade \u003c LowGra-\u003em_grade) { LowGra = p; } } if (flag == 1) cout \u003c\u003c HighGra-\u003em_name \u003c\u003c \" gets the highest Chinese grade.\" \u003c\u003c endl; else cout \u003c\u003c LowGra-\u003em_name \u003c\u003c \" gets the lowest Chinese grade.\" \u003c\u003c endl; } void Link::ShowAge(int age) { int count = 0; Link *p; cout \u003c\u003c \"Students in \" \u003c\u003c age \u003c\u003c \" years old: \"; for (p = head; p != NULL; p = p-\u003enext) { if (p-\u003em_age == age) { count++; cout \u003c\u003c p-\u003em_name \u003c\u003c \" \"; } } cout \u003c\u003c endl \u003c\u003c count \u003c\u003c \" total students.\" \u003c\u003c endl; } void Link::DeleteNode() { Link *p; if (this == head) { head = this-\u003enext; } else { for (p = head; p != NULL; p = p-\u003enext) { if (p-\u003enext == this) { p-\u003enext = this-\u003enext; break; } } } num--; cout \u003c\u003c this-\u003em_name \u003c\u003c \" has deleted.\" \u003c\u003c endl; } void Link::SortByNumber() { Link *newHead = NULL, *p, *q, *max; int storedNum = num; while (num != 0) { for (q = max = head; q != NULL; q = q-\u003enext) { if (max-\u003em_number \u003c q-\u003em_number) { max = q; } } for (q = head; q != NULL; q =","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E7%B1%BB/:24:0","tags":["C++"],"title":"C++ 类","uri":"/Notes/posts/cpp/%E7%B1%BB/"},{"categories":["CPP"],"content":"要点 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:0:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"ASCII 码 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 ASCII值 控制字符 0 NUT 32 (space) 64 @ 96 、 1 SOH 33 ! 65 A 97 a 2 STX 34 \" 66 B 98 b 3 ETX 35 # 67 C 99 c 4 EOT 36 $ 68 D 100 d 5 ENQ 37 % 69 z E 101 e 6 ACK 38 \u0026 70 F 102 f 7 BEL 39 ' 71 G 103 g 8 BS 40 ( 72 H 104 h 9 HT 41 ) 73 I 105 i 10 LF 42 * 74 J 106 j 11 VT 43 + 75 K 107 k 12 FF 44 , 76 L 108 l 13 CR 45 - 77 M 109 m 14 SO 46 . 78 N 110 n 15 SI 47 / 79 O 111 o 16 DLE 48 0 80 P 112 p 17 DCI 49 1 81 Q 113 q 18 DC2 50 2 82 R 114 r 19 DC3 51 3 83 S 115 s 20 DC4 52 4 84 T 116 t 21 NAK 53 5 85 U 117 u 22 SYN 54 6 86 V 118 v 23 TB 55 7 87 W 119 w 24 CAN 56 8 88 X 120 x 25 EM 57 9 89 Y 121 y 26 SUB 58 : 90 Z 122 z 27 ESC 59 ; 91 [ 123 { 28 FS 60 \u003c 92 / 124 | 29 GS 61 = 93 ] 125 } 30 RS 62 \u003e 94 ^ 126 ` 31 US 63 ? 95 _ 127 DEL ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:1:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"操作系统标准I/O重新定向 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:2:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"将标准I/O重新定向到其他设备 \u003c 重新定向标准输入 \u003e 或 \u003e\u003e 重新定向标准输出 | 管道操作(将左侧命令的输出作为右侧的输入) ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:2:1","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"多种不同方式的运行 使用操作系统(如:Windows)的I/O重新定向功能运行 可执行文件 Hello.exe Hello Hello \u003c Input.txt Hello \u003e Output.txt Hello \u003e\u003e Output.txt Hello \u003c Input.txt \u003e Output.txt Hello \u003c Input.txt \u003e\u003e Output.txt type Input.txt | Hello type Input.txt | Hello \u003e Output.txt 可将这些命令写入“批处理文件”（即命令处理程序）中 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:2:2","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"批处理文件（*.bat文件） 批处理（batch，以bat为扩展名），也称为脚本，其本质是一批操作系统命令按一定顺序排列而形成程序。 批处理中支持条件分支、循环等结构。 批处理文件格式为文本文件（可用Windows的记事本等文本编辑软件进行编辑），基本上每一行为一条命令。 C/C++等语言所生成的可执行文件(.exe)是一种操作系统命令。 常用的命令有 echo 输出字符串 rem 注释 pause 暂停，按任意键继续 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:2:3","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"引用 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:3:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"概念 引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样 int a; int \u0026ra = a; 说明 \u0026在此不是求地址运算，而是起标识作用 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。 ra=1; 等价于 a=1; 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。\u0026ra与\u0026a相等 不能建立数组和函数的引用 优点：使用引用传递函数的参数，在内存中并没有产生实参的副本，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给 形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效 率和所占空间都好 与指针比较：使用指针作为函数的参数虽然也能达到与使用引用的效果，但是，在被调函数中同样要给形参分配存储单元，且需要重复使用\"*指针变量名“的形式进行运算，这很容易产生错误且程序的阅读性较差；另一方面，在主调函数的调用点处，必须用变量的地址作为实参。而引用更容易使用，更清晰。 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:3:1","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"常引用 int a; const int \u0026ra = a; 用这种方式声明的引用，不能通过引用对目标变量的值进行修改,从而使引用的目标成为const，达到了引用的安全性。 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:3:2","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"值传递、指针传递、引用传递 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:4:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"值传递 形参是实参的拷贝，改变形参的值并不会影响外部实参的值。从被调用函数的角度来说，值传递是单向的（实参-\u003e形参），参数的值只能传入，不能传出。当函数内部需要修改参数，并且不希望这个改变影响调用者时，采用值传递。 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:4:1","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"指针传递 形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:4:2","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"引用传递 形参相当于是实参的“别名”，对形参的操作其实就是对实参的操作，在引用传递过程中，被调函数的形式参数虽然也作为局部变量在栈 中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参的任何操作都被处理成间接寻址，即通过 栈中存放的地址访问主调函数中的实参变量。正因为如此，被调函数对形参做的任何操作都影响了主调函数中的实参变量 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:4:3","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"整型例 值传递 void change1(int n); change1(n); 指针传递 void change2(int *n); //函数内需要间址取值 change2(\u0026n); 引用传递 void change3(int \u0026n); change3(n); ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:4:4","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"重载函数 定义 函数名相同，不同的参数搭配时，含义不同 允许重载的条件 参数类型不同 参数个数不同 参数顺序不同 满足一条即可重载 例 int func(int x) { return x; } int func(int x,int y) { return x + y; } int func(const char *s) { return strlen(s); } ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:5:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"函数模板 概念 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个虚拟的类型来代表 语法 template \u003ctypename T\u003e template — 声明创建模板 typename — 表面其后面的符号是一种数据类型，可以用class代替 T — 通用的数据类型，名称可以替换，通常为大写字母 调用 func(a,b); 或 func\u003cint\u003e(a,b); 使用多个虚类型 template \u003cclass T1, class T2\u003e void func(T1 a, T2 b) { .... } //调用 func\u003cint,double\u003e(a,b); ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:6:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"内联函数 概念 定义：当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用. 优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联. 缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。 基本使用 在函数前加inline即可 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:7:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"带有默认值参数的函数 定义 C++允许实参个数与形参个数不同。在声明函数原型时，为一个或多个形参指定默认值，以后调用此函数时，若省略其中某一实参，C++自动的以默认值作为相应参数的值。 例子 //声明 int special(float x = 5, float y = 5.3); //调用 special(100, 79.8); //x = 100, y = 79.8 special(25); //x = 25, y = 5.3 special(); //x = 5, y = 5.3 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:8:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"new与delete ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:9:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"new 格式 new 类型(初值) new 类型[大小] 例 new int; //开辟一个存放整数的存储空间，返回地址(即指针) new int(100); //开辟一个存放整数的空间，并指定该整数的初值为100，返回地址 new char[10]; //开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址 new int[5][4]; //开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址 float *p=new float (3.14159); //开辟一个存放单精度数的空间，并指定该实数的初值为//3.14159，将返回的该空间的地址赋给指针变量p 要点 用 new 分配数组空间时不能指定初值。 如果由于内存不足等原因而无法正常分配空间，则 new 会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:9:1","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"delete 格式 delete [ ] 指针变量 delete 变量 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:9:2","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"函数返回字符串 使用 static char *func() { static char str[5]; return str; } 使用全局变量 char str[5]; char *func() { //... return str; } ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:9:3","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"异常处理 ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:10:0","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"概念 异常是程序执行期产生问题，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw: 关键字 throw: 当问题出现，程序通过 throw 抛出一个异常; catch: 在你想要处理问题的地方，通过异常处理程序捕获异常; try: try 块中的代码标识将被激活的特定异常。它后面允许跟着一个或多个 catch 块; ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:10:1","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"抛出异常 使用 throw 语句在代码块中任何位置抛出异常。throw 语句的操作数可以是任意表达式，表达式的结果类型决定了抛出异常的类型 double Div(int a, int b) throw(char, double) { if (b == 0) { throw(char) 0; } if (a % b) { throw(double) b; } return (a / b); } ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:10:2","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["CPP"],"content":"捕获异常 catch 块跟在 try 块后面，用于捕获异常。可指定想要捕捉的异常类型，由 catch 关键字后括号内的异常声明类型决定 try { // 保护代码 } catch (数据类型1 形参) { // 处理异常的代码 } catch (数据类型3 形参) { // 处理异常的代码 } catch (...) { // 处理其他任何类型的代码 } 例 int a[5] = {10, 10, 8, 6, 4}; int b[5] = {5, 3, 0, 2, 0}; int n = 0, i, z; for (i = 0; i \u003c 5; i++) { try { cout \u003c\u003c Div(a[i], b[i]) \u003c\u003c \", \"; n++; } catch (char) { cout \u003c\u003c \"/0\"\u003c\u003c \", \"; } catch (double \u0026x) { cout \u003c\u003c \"/\" \u003c\u003c x \u003c\u003c \", \"; } } cout \u003c\u003c endl \u003c\u003c n \u003c\u003c \" totally\" \u003c\u003c endl; 结果 2, /3, /0, 3, /0, 2 totally ","date":"2021-10-23","objectID":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/:10:3","tags":["C++"],"title":"C++ 一些要点","uri":"/Notes/posts/cpp/%E8%A6%81%E7%82%B9/"},{"categories":["效率工具"],"content":"LaTeX 数学公式 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:0:0","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"数学模式 在 LaTeX 数学模式中，公式有两种形式——行内公式和行间公式。前者公式嵌入在行内，适用于简单短小的公式；后者居中独占一行，适用于比较长或重要的公式。 空格 公式中的空格均会被忽略，可以使用命令\\quad或\\qquad实现 编号 在行间公式中，命令\\tag{n}可以进行手动编号 例 $$f(x)=a -b \\tag{1.1} $$ $$ f(x) = a - b \\tag{1.1} $$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:1:0","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"行内公式 格式 $ 公式 $ 例 $f(x)=a+b $ $f(x)=a+b$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:1:1","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"行间公式 格式 $$ 公式 $$ 例 $$f(x)=a+b $$ $$ f(x) = a+b $$ 说明 使用 Typora 时，$$ + Enter 即可快速创建一个公式块 多行公式 使用\\\\来换行 $$2x+3y=34\\\\x+4y=25$$ $$ 2x+3y=34 \\ x+4y=25 $$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:1:2","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"数学结构 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:0","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"常用符号 名称 代码 示例 显示 上下标 ^, _ a_{ij}^{2} $$a_{ij}^2 $$ 分数 \\frac \\cfrac \\frac {1}{3} \\cfrac {1}{3} $$\\frac {1}{3}$$ $$\\cfrac {1}{3}$$ 开方 \\sqrt[n] []不写默认开平方根 \\sqrt[3]{5-x} $$\\sqrt[3]{5-x}$$ 上下标记 \\overline, \\underline \\overline{x+y} \\qquad \\underline{a+b}​ $$\\overline{x+y} \\qquad \\underline{a+b}$$ 上下水平大括号 \\overbrace, \\underbrace \\overbrace{1+2+\\cdots+n}^{n个} \\ \\underbrace{a+b+\\cdots+z}_{26} $$\\overbrace{1+2+\\cdots+n}^{n个} \\ \\underbrace{a+b+\\cdots+z}_{26}$$ 向量 \\vec, \\overrightarrow, \\overleftarrow \\vec{a} + \\overrightarrow{AB} + \\overleftarrow{DE} $$\\vec{a} + \\overrightarrow{AB} + \\overleftarrow{DE}$$ 段内效果的上下标 \\limits \\bigcap\\limits_{i=1}^{n} A_i $$\\bigcap\\limits_{i=1}^{n} A_i$$ 下省略号 \\ldots \\overline{A_1}\\cap \\overline{A_2}\\ldots\\cap \\overline{A_n} $$\\overline{A_1}\\cap \\overline{A_2}\\ldots\\cap \\overline{A_n}$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:1","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"关系运算符 代码 符号 \\pm $$\\pm$$ \\times $$\\times$$ \\div $$\\div$$ \\mid $$\\mid$$ \\cdot （点乘） $$\\cdot$$ \\odot $$\\odot$$ \\otimes $$\\otimes$$ \\oplus $$\\oplus$$ \\leq or \\le $$\\leq$$ \\geq or \\ge $$\\geq$$ \\neq $$\\neq$$ \\approx $$\\approx$$ \\equiv $$\\equiv$$ \\sum $$\\sum$$ \\prod $$\\prod$$ \\mathscr $$\\mathscr {ABCDEF}$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:2","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"对数运算符 代码 符号 \\log $$\\log$$ \\lg $$\\lg$$ \\ln $$\\ln$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:3","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"三角运算符 代码 符号 \\bot $$\\bot$$ \\angle $$\\angle$$ \\sin $$\\sin$$ \\cos $$\\cos$$ \\tan $$\\tan$$ \\cot $$\\cot$$ \\sec $$\\sec$$ \\csc $$\\csc$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:4","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"微积分运算符 代码 符号 \\int $$\\int$$ \\iint $$\\iint$$ \\iiint $$\\iiint$$ \\oint $$\\oint$$ \\lim $$\\lim$$ \\infty $$\\infty$$ \\mathrm{d} $$\\mathrm{d}$$ \\partial $$\\partial$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:5","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"集合运算符 代码 符号 \\emptyset $$\\emptyset$$ \\in $$\\in$$ \\notin $$\\notin$$ \\subset $$\\subset$$ \\subseteq $$\\subseteq$$ \\supseteq $$\\supseteq$$ \\cap $$\\cap$$ \\cup $$\\cup$$ \\vee or \\lor $$\\vee$$ \\wedge or \\land $$\\wedge$$ \\exists $$\\exists$$ \\forall $$\\forall$$ \\lfloor \\rfloor （向下取整） $$\\lfloor \\ \\rfloor$$ \\lceil \\rceil （向上取整） $$\\lceil \\ \\rceil$$ \\neg $$\\neg$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:6","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"矩阵 代码 示例 显示 \\matrix \\begin{matrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{matrix} $$\\begin{matrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{matrix}$$ \\bmatrix \\begin{bmatrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{bmatrix} $$\\begin{bmatrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{bmatrix}$$ \\vmatrix \\begin{vmatrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{vmatrix} $$\\begin{vmatrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{vmatrix}$$ \\pmatrix \\begin{pmatrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{pmatrix} $$\\begin{pmatrix} 1\u00262\u00263 \\ 4\u00265\u00266 \\ 7\u00268\u00269 \\end{pmatrix}$$ 下列代码中，\u0026用于分隔列，\\用于分隔行 $$\\begin{bmatrix} 1\u0026 2\u0026 \\cdots\\\\67\u0026 95\u0026 \\cdots\\\\\\vdots\u0026 \\vdots\u0026 \\ddots\\\\\\end{bmatrix}$$ $$ \\begin{bmatrix} 1 \u0026 2 \u0026 \\cdots \\ 67 \u0026 95 \u0026 \\cdots \\ \\vdots \u0026 \\vdots \u0026 \\ddots \\ \\end{bmatrix} $$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:7","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"头顶符号 代码 符号 \\hat $$\\hat{x}$$ \\bar $$\\bar{x}$$ \\dot $$\\dot{x}$$ \\ddot $$\\ddot{x}$$ \\vec $$\\vec{x}$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:8","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"箭头(arrow) 说明 代码 符号 单箭头单向 left和right \\leftarrow \\rightarrow $$\\leftarrow \\ \\rightarrow$$ 双箭头单向 Left和Right \\Leftarrow \\Rightarrow $$\\Leftarrow \\ \\Rightarrow$$ 双向 leftright和Leftright \\leftrightarrow $$\\leftrightarrow$$ 长箭头 long和Long \\longleftarrow $$\\longleftarrow$$ 否定 n \\nRightarrow $$\\nRightarrow$$ 互推 \\rightleftharpoons $$\\rightleftharpoons$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:9","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"界定符大小 代码 符号 \\big $$\\big($$ \\Big $$\\Big($$ \\bigg $$\\bigg($$ \\Bigg $$\\Bigg($$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:10","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"希腊字母 代码 大写 代码 小写 A $$A$$ \\alpha $$\\alpha$$ B $$B$$ \\beta $$\\beta$$ \\Gamma $$\\Gamma$$ \\gamma $$\\gamma$$ \\Delta $$\\Delta$$ \\delta $$\\delta$$ E $$E$$ \\epsilon $$\\epsilon$$ Z $$Z$$ \\zeta $$\\zeta$$ H $$H$$ \\eta $$\\eta$$ \\Theta $$\\Theta$$ \\theta $$\\theta$$ I $$I$$ \\iota $$\\iota$$ K $$K$$ \\kappa $$\\kappa$$ \\Lambda $$\\Lambda$$ \\lambda $$\\lambda$$ M $$M$$ \\mu $$\\mu$$ N $$N$$ \\nu $$\\nu$$ Xi $$Xi$$ \\xi $$\\xi$$ O $$O$$ \\omicron $$\\omicron$$ \\Pi $$\\Pi$$ \\pi $$\\pi$$ P $$P$$ \\rho $$\\rho$$ \\Sigma $$\\Sigma$$ \\sigma $$\\sigma$$ T $$T$$ \\tau $$\\tau$$ \\Upsilon $$\\Upsilon$$ \\upsilon $$\\upsilon$$ \\Phi $$\\Phi$$ \\phi $$\\phi$$ X $$X$$ \\chi $$\\chi$$ \\Psi $$\\Psi$$ \\psi $$\\psi$$ \\Omega $$\\Omega$$ \\omega $$\\omega$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:3:0","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"字体 输入 说明 显示 输入 说明 显示 \\rm 罗马体 $$\\rm{Sample}$$ \\cal 花体 $$\\cal{SAMPLE}$$ \\it 意大利体 $$\\it{Sample}$$ \\Bbb 黑板粗体 $$\\Bbb{SAMPLE}$$ \\bf 粗体 $$\\bf{Sample}$$ \\mit 数学斜体 $$\\mit{SAMPLE}$$ \\sf 等线体 $$\\sf{Sample}$$ \\scr 手写体 $$\\scr{SAPLE}$$ \\tt 打字机体 $$\\tt{Sample}$$ \\frak 哥特字体 $$\\frak{sample \\ SAMPLE}$$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:4:0","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["效率工具"],"content":"一万个例子 $$\\int_0^1\\arctan\\mathrm{d}x =\\arctanx \\bigg| _0^1-\\int_0^1x \\mathrm{d}(\\arctanx)=\\frac{\\pi}{4} -\\frac{1}{2}\\ln(1+x^2)$$ $$ \\int_0^1 \\arctan \\mathrm{d}x = \\arctan x \\bigg| _0^1 - \\int _0^1 x \\mathrm{d}(\\arctan x) = \\frac{\\pi}{4} - \\frac{1}{2}\\ln(1+x^2) $$ $$\\int_{-3}^3\\frac{x^5\\sin^3x}{4+x^2+x^4}\\mathrm{d}x +\\int_0^1e ^\\sqrt{x}\\mathrm{d}x $$ $$ \\int _{-3}^3 \\frac{x^5 \\sin ^3 x}{4+x^2+x^4}\\mathrm{d}x + \\int _0^1 e ^\\sqrt{x}\\mathrm{d}x $$ $$\\begin{cases} \\ \\alpha_i \\ge0\\\\\\ y_if(x_i)-1\\ge0\\\\\\ \\alpha_i(y_if(\\vecx_i)-1)\\ge0\\end{cases} $$ $$ \\begin{cases} \\ \\alpha_i \\ge 0 \\ \\ y_if(x_i)-1 \\ge 0 \\ \\ \\alpha_i(y_if(\\vec x_i)-1) \\ge 0 \\end{cases} $$ 界定符前冠以 \\left（修饰左定界符）或 \\right（修饰右定界符），可以得到自适应缩放的定界符 $$\\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k} \\right)$$ $$ \\left(\\sum_{k=\\frac{1}{2}}^{N^2}\\frac{1}{k}\\right) $$ $$A+AB=A \\\\A+\\overlineAB=A+B \\\\AB+\\A\\overlineB=A \\\\AB+\\overline{A}C +BC=AB+\\overline{A}C $$ $$ A+AB=A \\ A+\\overline AB=A+B \\ AB+A \\overline B=A \\ AB+\\overline {A}C +BC=AB+\\overline{A}C $$ ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:5:0","tags":["LaTeX","快速入门"],"title":"LaTeX 数学公式","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/latex-%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["Linux"],"content":"进程管理 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:0:0","tags":["Linux"],"title":"Linux 进程管理","uri":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"概念 （一）进程 程序的一次执行过程 资源分配和管理的基本单位 （二）进程管理的内容 1、监视进程：获取当前系统中各个进程的具体状态信息 2、调整进程运行优先级 3、守护进程 （三）与进程有关的信息 PID(Process ID) 进程号 PPID(Parent ID) 父进程的PID号 USER/UID 执行该进程的用户名及其 UID TTY 启动该进程的终端 PRI(priority) 进程的优先级，数字越大表示优先级越低 NICE 进程的谦让度，表示进程对CPU时间要求的迫切程度 %CPU 进程占用的CPU比例 %MEM 进程占用的内存比例 TIME: 进程实际占用CPU的总时间 STIME: 进程开始执行的时间 ADDR 进程在内存中的地址 RSS: 进程占用的内存大小(KB) VSZ: 进程占用的虚拟内存空间 CMD 启动进程的命令 STAT(state，可用S表示) 进程的状态 S 睡眠状态 Z 僵尸状态 W 进程没有驻留页（等待） D 不间断睡眠（挂起） R 运行或者准备运行状态 T 停止或者追踪 I 空闲 N 低优先级的任务 （四）Linux系统中部分常用的信号 （五）进程的优先级（PRI） 进程的优先级PRI（priority）：是操作系统在进程调度时用于判决进程是否能 够获得CPU的依据之一。 1、进程的优先级越高，则越能在竞争中胜出而获得CPU时间 2、以一个整数来表达的，数值越低，优先级越高 3、每个普通进程的优先级默认为80 （六）进程的谦让度（NICE） 进程的谦让度（NICE）:表示进程对CPU时间要求的迫切程度。 1、取值范围为-20~19 2、进程的谦让度为负数时，反映进程对CPU 资源的要求较为迫切。 3、 一般来说：优先级(PRI)与谦让度(NICE)存在如下的关系： PRI（new）=PRI（old）+NICE 4、root用户可以调整自己和其他用户的进程的nice值，且范围为-20~19； 5、普通用户只能调整自己进程的nice值，为了避免普通用户抢占系统资源， nice的调整范围为0~19，而且只能往高调整 （七）进程类型 1、系统进程 : 操作系统启动后，系统环境平台运行所加载的进程。 2、用户进程：与终端相关联，是由用户所执行的进程。 3、守护进程：在后台运行的进程，有时也称为服务。它没有屏幕提示，只是在 后台等待用户或系统的请求 （八）Linux系统中的部分系统服务及其守护进程 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:1:0","tags":["Linux"],"title":"Linux 进程管理","uri":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"进程监视命令 （一）ps(process status)命令 【功能】报告进程的相关信息 【格式】ps [选项] 【选项】 -l 以长格式显示进程信息 -e 显示所有进程的信息（包含系统进程） -a 显示所有用户进程 -x 显示没有控制终端的进程 -u 显示用户名和启动时间等信息 【例】 ps –el ps -aux ps -aux –sort -pid 按pid排序 （二）top命令 【功能】以实时的方式报告进程的相关信息 【格式】top [选项] 【选项】-d 10 设定刷新进程信息的间隔时间（秒） （三）pstree命令 【功能】显示进程家族树的信息 【格式】 pstree [选项] [进程PID/用户名] 【选项】 -p 显示每个进程的PID号 -u 用户名 指定只显示属于该用户的进程 （四）lsof(list open files)命令 【功能】列出由某进程所打开的文件 【格式】 lsof [选项] [文件或目录路径] 【选项】 -p PID 列出由该进程所打开的所有文件 -u 用户名 列出某用户打开的所有文件 ps 报告进程的相关信息 top 以实时的方式报告进程的相关信息 pstree 显示进程家族树的信息 lsof(list open files) 列出由某进程所打开的文件 （五）kill命令 【功能】向特定进程发送某种信号 【格式】kill [选项] [-信号名称/编号] [PID列表] 【选项】 -l 列出系统中定义的信号 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:2:0","tags":["Linux"],"title":"Linux 进程管理","uri":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"进程优先级命令 （一）nice命令 【功能】设定要启动的进程的谦让度 【格式】nice [选项] 命令 【选项】-n（nice） 数值 ：设定谦让度,数值的范围 -20 ~ 19 【实例】以root身份登陆系统，来给将启动的vi进程设定谦让度为-3 nice –n -3 vi\u0026 ps –l （二）renice命令 【功能】调整已存在进程的nice值 【格式】renice -n 谦让度 进程pid号 【实例】将上一个例子中的vi进程的谦让度调整为3 renice -n 3 进程pid号 ps –l ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:3:0","tags":["Linux"],"title":"Linux 进程管理","uri":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"系统服务管理命令 （一）runlevel命令 【功能】用于显示系统当前的和上一次的运行级别。如系统不存在上一次的运行级别，用N来代 替。 【格式】runlevel （二）init命令 【功能】转换服务的运行级别。 【格式】init[n] ； 其中格式中的n为0~6的级别，转换级别后系统立刻生效。 【例】 init 3 #切换到第3运行级 runlevel init 0 #关机 init 6 #重新启动 init 5 #进入图形界面 （三）systemctl系统服务管理 1、查看系统服务启动状态。 【格式】 systemctl list-unit-files –type service #列出所有服务，并且检查是否开机启动。 【实例1】搜索指定的服务(crond)在系统中是否开机启动。 systemctl list -unit-files –type service|grep crond 2、列出所有处于激活状态的服务 【格式】 systemctl list-units –type service –all 其中: UNIT:服务名 LOAD:服务是否已经被加载 ACTIVE:服务活动状态 SUB:服务进程状态 DESCRIPTION:服务的描述 3、服务状态控制 【格式】systemctl [status/start/stop/restart/reload] name.service 【实例】 systemctl status crond.service //查看crond.service服务状态 systemctl stop crond.service //关闭crond.service服务 systemctl start crond.service //开启crond.service服务 4、服务开机自启控制 【格式】systemctl [enable/disable] name.service 【实例】 设置crond.service 服务为开机自动启动。 systemctl enable crond.service 搜索crond服务在系统中是否开机启动 systemctl list -unit-files –type service|grep crond （四）版本迭代差异 1、Centos7/RHEL7版本： 1）systemd 进程 取代 init进程； 2）init进程的配置文件/etc/inittab保留，但内容改变，原来的功能也不再使用 3）targets取代runlevels ①获得默认启动的target: systemctl get-default ②设置系统默认启动的target: systemctl set-default 【实例1】systemctl set-default multi-user.target //修改为多用户字符状态 【实例2】systemctl set-default graphical.target //修改为图形界面 ③centos7仍然保留使用静态的运行级别来构建不同的启动状态 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/:4:0","tags":["Linux"],"title":"Linux 进程管理","uri":"/Notes/posts/linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"软件操作 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/:0:0","tags":["Linux"],"title":"Linux 软件操作","uri":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"概念 （一）以软件包的方式安装 软件包是指软件提供方已经将软件程序编译好，并且将所有相关文件打包后所形成的一个安装文件。 不同类型的安装包就需要使用不同的软件包管理工具完成管理工作 1、分类 1）.rpm软件包: 由Redhat公司提出并使用在Redhat、Fedora、CentOS中， 对应的软件包管理工具称为rpm包管理器 2）.deb软件包: 由Debian社区提出并使用在Debian和Ubuntu中，对应的软 件包管理工具称为dpkg 2、特点：安装比较简便，但存在软件包依赖关系问题 （二）在线方式安装 1、分类 1）yum (Yellowdog Updater Modified，对应于.rpm软件包) 服务 2）apt (Advanced Packaging Tool，对应于.deb软件包) 服务 2、特点：安装简便，但需要访问网络服务器 （三）以源代码的方式安装 自由软件直接提供了软件的整套源代码，需要利用gcc和make等工具对源 代码进行编译后得到可执行的二进制文件，然后还需要将生成的可执行文件 以及相关的配置文件等放置在正确的文件系统路径位置，此外可能还需要修 改一些系统配置才能完成全部安装过程。 特点：安装复杂程度高 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/:1:0","tags":["Linux"],"title":"Linux 软件操作","uri":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"RPM （一）使用RPM安装（Red Hat Package Manager） 1、名称格式 name –version.type.rpm 1）type：包的类型（适用的硬件架构） 2）例 httpd-2.0.40-21.i386.rpm linuxqq_2.0.0-b1-1024_x86_64.rpm httpd-2.0.40-21.src.rpm （src表示软件源代码） 2、命令 1）安装 【格式】rpm -ivh \u003cRPM包名\u003e 【选项说明】 i （install）：安装 v（verify）：在安装中显示详细的安装信息 h（horizontal）： 显示水平进度条“#” 2）删除 【格式】rpm -e \u003cRPM包名\u003e 【实例】rpm –e httpd 3）查询 rpm -qa 查询系统中安装的所有RPM软件包 rpm -q \u003cRPM包名\u003e 查询指定的软件包是否已经安装 rpm -qp \u003cRPM包文件名\u003e 查询包中文件的信息，用于安装前了解软件包中的信息 rpm -qi \u003cRPM包名\u003e 查询系统中已安装包的描述信息 rpm -ql \u003cRPM包名\u003e 查询系统中已安装包中所包含的文件 rpm -qf \u003c文件名\u003e 查询系统中指定文件所属的软件包 4）升级 【格式】rpm -Uvh \u003cRPM包名\u003e 5）验证 【格式】rpm -V [参数] 参数可以是包名、文件名或者为空 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/:2:0","tags":["Linux"],"title":"Linux 软件操作","uri":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"yum （一）yum服务 yum（Yellow dog Updater Modified）是一个用在Fedora、RedHat以及 CentOS中的Shell前端软件包管理器 能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖关系， 并且一次安装所有依赖的软件包 所有软件包由集中的yum软件仓库提供 1、命令格式 【格式】 yum [options] [command] [package …] [options]包括 -y（当安装过程提示选择，全部选\"yes\"） -q（不显示安装的过程） [command]为所要进行的操作 [package …]是操作的对象 2、常用命令 1）查询指定的软件包安装情况： yum list \u003c软件包名\u003e 2）查询指定的软件包详细信息： yum info \u003c软件包名\u003e 3）安装软件包 : yum install \u003c软件包或程序组名\u003e 4）更新指定的软件包 ： yum update \u003c软件包名\u003e 5）删除 删除指定的软件包 ： yum remove \u003c软件包名\u003e 清除缓存目录下的软件包： yum clean \u003c软件包名\u003e ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/:3:0","tags":["Linux"],"title":"Linux 软件操作","uri":"/Notes/posts/linux/%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"categories":["Linux"],"content":"用户管理 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:0:0","tags":["Linux"],"title":"Linux 用户管理","uri":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"概念 （一）账户 一个用户在系统上标识 1、用户（账户） 文件、进程、任务，给每个用户提供特定的工作环境 1）超级用户：root 2）系统用户：伪账户 3）普通用户 2、组（账户） 具有相同特征的用户的集合体 一个组可有多个用户，一个用户可属于不同的组 创建组的目的是可以成批的管理同类的用户，从而简化管理工作 当用户属于多个组时，登录的组称为主组，其他组称为附加组 1）私有组 2）标准组 （二）用户相关配置文件 1、passwd文件： 1）位置：/etc/passwd 2）作用：保存各个用户的账户信息（密码除外） 3）文件格式：每行定义一个用户账号，一行中又划分为多个字段，定 义用户账号的不同属性，各字段间用“：”分隔 4）passwd文件格式： 用户名：密码：用户ID：组群ID：用户全名：用户主目录：使用的shell 5）所有用户都可以查看该文件的内容 口令密码使用×填充，不使用明文保存 6）用户ID（UID） root：0 系统用户：1~999 普通用户：1000开始 7）组ID（GID）： 用来表示用户所属的组 8）部分字段可以为空，但是必须用：分隔 2、shadow文件 1）位置： /etc/shadow 2）作用：保存各用户账户的密码等信息 3）文件格式：每行定义一个用户账号，一行中又划分为多个字段定义 用户账号的不同属性，各字段间用“：”分隔 4）shadow文件格式：用户名：口令：最后一次修改时间：最小时间间隔： 最大时间间隔：警告时间：不活动时间：失效时间：标志 5）只有root有权限查看shadow文件 密文：若为“*”、“！！”表示账户未设置密码 （三）组相关配置文件 1、组群账号信息文件 ：group 位置：/etc/group 作用：保存各用户账户的分组信息。 group文件的各字段：组名：组口令：组GID：组成员 root组：GID为0； 系统组：安装Linux以及部分服务性程序时系统自动设置的组，GID取值为1到999. 私有组：由超级用户新建的组，GID\u003e=1000 2、组群口令信息文件—gshadow 位置： /etc/gshadow 作用：用于定义用户组口令、组管理员等信息。 gshadow的各字段：组名：组口令：组管理员账号：组成员列表 其中组口令字段以“！！”占位。 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:1:0","tags":["Linux"],"title":"Linux 用户管理","uri":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"用户操作 （一）useradd命令 【功能】新建用户账号 【格式】useradd [ 选项] 用户名 【选项】 -d home-dir 设置用户的宿主目录，默认为/home/username -e date 设置账号的过期日期，格式如：2020-10-30 -g group-name 设定用户的所属组名 -s shell-path 设定用户使用的shell，默认/bin/bash -u uid 设定用户的UID ，唯一且大于1000 -D username 用于显示用户所使用的默认值 【例】按照默认值新建用户 tom useradd tom （二）passwd命令 【功能】设置或修改用户的口令,修改口令的属性 【格式】passwd [选项] 用户名 【选项】 -S username 用于查询指定用户的口令状态，仅root可用 -l username 用于锁定指定用户的口令，仅root可用 -u username 用于解锁指定用户的口令，仅root可用 -d username 用于删除指定用户的口令，仅root可用 【例】 passwd tom //为tom用户设置初始口令 passwd –S tom //查看tom用户的口令状态 （三）usermod命令 【功能】修改用户的属性 ，与useradd参数相同 【格式】usermod [选项] 用户名 【选项】 - c 全名 指定用户的全称 -d 主目录 指定用户的主目录 -e 有效期限 指定用户账号的有效期限 -f 缓冲天数 指定口令过期后多久将关闭此账号 -g 组群ID或组群名 指定用户所属的主要组群 -G 组群ID或组群名 指定用户所属的附加组群 -u 用户ID 指定用户的UID -l newusername username 改变已有用户名 -L username 用于锁定指定的用户账户 -U username 对已锁定的用户账号进行解锁 【实例】 修改tom账户的属性： 用户名的全称改为tommy ；指定它的主目录为/home/tommy ；uid设置为1010 usermod –c tommy –d /home/tommy -u 1010 tom 将名为tom的用户改名为tommy usermod –l tommy tom （四）id命令 【功能】查看用户的UID GID和用户所属组群的信息。 【格式】id [ 用户名] 【注】如不指定，则显示当前用户的相关信息 （五）userdel命令 【功能】删除指定的用户账号 【格式】userdel [-r] 用户名 使用r参数，删除用户的同时删除用户所有相关的文件，包括宿主目录及用户的邮件池等。 【实例】userdel –r tom ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:2:0","tags":["Linux"],"title":"Linux 用户管理","uri":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["Linux"],"content":"组群操作 （一）groupadd命令 【功能】新建组群 【格式】groupadd [选项] 组名 【选项】-g GID 指定新建组的GID(\u003e1000) 【实例】新建一个组，组名为mygroup 输入：groupadd mygroup 【实例】新建一个组，并指定其GID1010，组名为studentgroup 输入：groupadd –g 1010 studentgroup 【实例】新建用户zhuang1 ，将它加入到刚刚建立的为studentgroup组。 useradd –g studentgroup zhuang1 （二）groupmod命令 【功能】修改指定组群的属性 【格式】groupmod [选项] 组名 【选项】 -g GID 指定新建组的GID(\u003e=1000) -n 新组名 原组名 指定组群的新名字 -G 组群名 用户名 将用户添加到组群中 【实例】将刚刚建立的mygroup组，改名为newmygroup 输入： groupmod –n newmygroup mygroup （三）groupdel命令 【功能】删除指定的组群 【格式】groupdel [选项] 组名 【注】被删组群不是任何用户的主组群 要删除的组账户必须存在并且不能作为私有组被用户账号引用 【实例1】删除私有组：tom组 输入：groupdel tom； 将提醒你不能移除私有组 【实例2】删除空组：将刚刚建立newmygroup 输入：groupdel newmygroup 【实例3】删除有用户的组： studentgroup组，先删除用户再删除组 userdel -r zhuang1 userdel -r zhuang2 userdel -r zhuang3 groupdel studentgroup （四）gpasswd命令 【功能】用于将指定用户添加到指定用户组或从组内删除 【格式】gpasswd [选项] 用户名 组名 【选项】 -a username groupname 将指定用户添加到指定用户组中 -d username groupname 从组内删除用户 -A username groupname 设指定用户为指定组的管理员 【实例】创建几个普通用户，将其加入到指定的组。 useradd tom1 useradd tom2 groupadd mygroup1 gpasswd -a tom1 mygroup1 gpasswd -a tom2 mygroup1 【实例】从组内删除用户tom1 gpasswd –d tom1 mygroup1 （五）groups命令 【功能】查看一个用户的所属的所有组群 【格式】groups 用户名 ","date":"2021-10-23","objectID":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/:3:0","tags":["Linux"],"title":"Linux 用户管理","uri":"/Notes/posts/linux/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86/"},{"categories":["Python"],"content":"内建函数 ","date":"2021-10-23","objectID":"/Notes/posts/python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:0:0","tags":["Python"],"title":"Python 内建函数","uri":"/Notes/posts/python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["Python"],"content":"字符串 .endswith(suffix[, start[, end]]) suffix – 该参数可以是一个字符串或者是一个元素 start – 字符串中的开始位置 end – 字符中结束位置 .capitalize() 把字符串的第一个字符大写 .count(str, beg=0, end=len(string)) 返回 str 在 string 里面出现的次数，beg 和 end 指定范围 .decode(encoding=‘UTF-8’, errors=‘strict’) 以 encoding 指定的编码格式解码 string 如果出错默认报一个 ValueError 的 异 常 ， 除非 errors 指 定 的 是 ‘ignore’ 或 者’replace’ .encode(encoding=‘UTF-8’, errors=‘strict’) 以 encoding 指定的编码格式编码 string ==.find(str, beg=0, end=len(string))== 检测 str 是否包含在 string 中 如果是返回开始的索引值，否则返回 -1 .isalnum() 检测字符串是否由字母和数字组成 .isalpha() 检测字符串是否只由字母组成 .isdigit() 检测字符串是否只由数字组成 ==.join()== 将序列中的元素以指定的字符连接生成一个新的字符串 str.join(sequence) sequence – 要连接的元素序列 str = \"-\"; seq = (\"a\", \"b\", \"c\"); # 字符串序列 print str.join( seq ); 输出 a-b-c .lstrip() 截掉字符串左边的指定字符（默认为空格） str.lstrip([chars]) .rstrip() 删除字符串末尾的指定字符（默认为空格） ==.strip()== 移除字符串头尾指定的字符（默认为空格或换行符）或字符序列 .replace() 字符串中的 old（旧字符串） 替换成 new (新字符串)，如果指定第三个参数 max，则替换不超过 max 次 str.replace(old, new[, max]) ==.split()== 通过指定分隔符对字符串进行切片，如果参数 num 有指定值，则分隔 num+1 个子字符串 返回分割后的字符串列表 str.split(str, num) str – 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。 num – 分割次数。默认为 string.count(str) , 即分隔所有。 str = \"Line1-abcdef \\nLine2-abc \\nLine4-abcd\"; print str.split( ); # 以空格为分隔符，包含 \\n print str.split(' ', 1 ); # 以空格为分隔符，分隔成两个 输出 ['Line1-abcdef', 'Line2-abc', 'Line4-abcd'] ['Line1-abcdef', '\\nLine2-abc \\nLine4-abcd'] .upper() 将字符串中的小写字母转为大写字母 .lower() 转换字符串中所有大写字符为小写 .swapcase() 对字符串的大小写字母进行转换 ==.replace(old, new[, max])== 替换字符 old – 将被替换的子字符串。 new – 新字符串，用于替换old子字符串。 max – 可选字符串, 替换不超过 max 次 .maketrans(intab, outtab) 创建字符映射的转换表 intab – 字符串中要替代的字符组成的字符串 outtab – 相应的映射字符的字符串 intab = \"aeiou\" outtab = \"12345\" trantab = str.maketrans(intab, outtab) txt = \"this is string example....wow!!!\"; print(txt.translate(trantab)) # th3s 3s str3ng 2x1mpl2....w4w!!! partition(str) 根据指定的分隔符将字符串进行分割，不会将分隔符舍去 str = \"www.runoob.com\" print str.partition(\".\") # 输出 ('www', '.', 'runoob.com') center(width, str) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串，默认填充空格 \u003e\u003e\u003e str = 'runoob' \u003e\u003e\u003e str.center(20, '*') '*******runoob*******' \u003e\u003e\u003e str.center(20) ' runoob ' ","date":"2021-10-23","objectID":"/Notes/posts/python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:1:0","tags":["Python"],"title":"Python 内建函数","uri":"/Notes/posts/python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["Python"],"content":"其他 enumerate() 将一个可遍历的数据对象 (如列表、元组或字符串) 组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中 返回 enumerate(枚举) 对象。 enumerate(sequence, [start=0]) sequence – 一个序列、迭代器或其他支持迭代对象。 start – 下标起始位置。 seq = ['one', 'two', 'three'] for i, element in enumerate(seq): print(i, element) 输出 0 one 1 two 2 three dir() 不带参数时，返回当前范围内的变量、方法和定义的类型列表； 带参数时，返回参数的属性、方法列表 map() 根据提供的函数对指定序列做映射。 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。 map(function, iterable, ...) 返回迭代器，可用 list() 转换成列表 .format() 数字 格式 输出 描述 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 -1 {:+.2f} -1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0\u003e2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x\u003c4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x\u003c4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:\u003e10d} 13 右对齐 (默认, 宽度为10) 13 {:\u003c10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 11 ‘{:b}’.format(11) ‘{:d}’.format(11) ‘{:o}’.format(11) ‘{:x}’.format(11) ‘{:#x}’.format(11) ‘{:#X}’.format(11) 1011 11 13 b 0xb 0XB 进制 eval(expression) 执行一个字符串表达式，并返回表达式的值 \u003e\u003e\u003ex = 7 \u003e\u003e\u003e eval( '3 * x' ) 21 \u003e\u003e\u003e eval('pow(2,2)') 4 \u003e\u003e\u003e eval('2 + 2') 4 \u003e\u003e\u003e n=81 \u003e\u003e\u003e eval(\"n + 4\") 85 bin(x) 将数字 x 转换为二进制串 chr(x) 返回 unicode 为 x 的字符 ord(x) 返回字符 x 的 unicode 编码 filter(function, iterable) 过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换 function – 判断函数。 iterable – 可迭代对象。 reduce(function, iterable) 函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果 #!/usr/bin/python from functools import reduce def add(x, y) : # 两数相加 return x + y sum1 = reduce(add, [1,2,3,4,5]) # 计算列表和：1+2+3+4+5 sum2 = reduce(lambda x, y: x+y, [1,2,3,4,5]) # 使用 lambda 匿名函数 print(sum1) print(sum2) round(x [, n]) 返回浮点数 x 的四舍五入值 x – 数值表达式。 n – 数值表达式，表示从小数点位数。 zip([iterable, …]) 将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表 iterabl – 一个或多个迭代器 返回元组列表 \u003e\u003e\u003ea = [1,2,3] \u003e\u003e\u003e b = [4,5,6] \u003e\u003e\u003e c = [4,5,6,7,8] \u003e\u003e\u003e zipped = zip(a,b) # 打包为元组的列表 [(1, 4), (2, 5), (3, 6)] \u003e\u003e\u003e zip(a,c) # 元素个数与最短的列表一致 [(1, 4), (2, 5), (3, 6)] \u003e\u003e\u003e zip(*zipped) # 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式 [(1, 2, 3), (4, 5, 6)] locals() 返回当前作用域内所有局部变量和值的字典 globals() 返回当前作用域内所有全局变量和值的字典 ","date":"2021-10-23","objectID":"/Notes/posts/python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/:2:0","tags":["Python"],"title":"Python 内建函数","uri":"/Notes/posts/python/%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0/"},{"categories":["效率工具"],"content":"Vim ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:0:0","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"模式 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:1:0","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"正常模式（Normal-mode) 正常模式一般用于浏览文件，也包括一些复制、粘贴、删除等操作 启动 VIM 后默认位于正常模式。 不论是什么模式，按 \u003cEsc\u003e 键都会进入正常模式 ( 插入模式按一下 Esc ，就会切换到正常模式，命令模式或者可视模式下执行完操作以后，就会自动进入正常模式，如果进入命令模式或者可视模式没有执行任何操作，按两下 Esc 即可 ） 快速移动光标 h,j,k,l 左，下，上，右 当前行移动光标 ==0== 移动到行头 ==^== 移动到本行第一个不是blank的位置 ==$== 移动到行尾 g_ 移动到本行最后一个不是blank的位置 ==w== 光标移动到下一个单词的开头 e 光标移动到下一个单词的结尾 ==fa== 移动到本行下一个为 a 的字符处 nfa 移动到本行光标处开始的第 n 个 字符为 a 的地方 Fa 移动到本行上一个为 a 的字符处 nFa 移动到本行上一个第 n 个 字符为 a 的地方 ta 移动光标至 a 字符的前一个字符 nta 移动到第n个 a 字符的前一个字符处 Ta 移动光标至 a 字符的后一个字符 nTa 移动到第n个 a 字符的后一个字符处 ; 和, 当使用 f, F, t ,T, 关键字指定字符跳转的时候，使用 ；可以快速跳转到写一个指定的字符，, 是跳到前一个指定的字符 跨行移动光标 ==nG == 光标定位到第 n 行的行首 ==gg == 光标定位到第一行的行首 ==G == 光标定位到最后一行的行首 H 光标定位到当前屏幕的第一行行首 M 光标移动到当前屏幕的中间 L 光标移动到当前屏幕的尾部 ==zt== 把当前行移动到当前屏幕的最上方，也就是第一行 ==zz== 把当前行移动到当前屏幕的中间 ==zb== 把当前行移动到当前屏幕的尾部 % 匹配括号移动，包括 ( , { , [ 需要把光标先移动到括号上 ==*== 和 ==#== 匹配光标当前所在的单词，移动光标到下一个（或者上一个）匹配的单词（ * 是下一个，# 是上一个） 翻页操作 ==ctrl+f== 查看下一页内容 ==ctrl+b== 查看上一页内容 VIM 的复制，黏贴 ，删除 三个重要的快捷键 d , y , p d 是删除的意思，通常搭配一个字符 ( 删除范围 ) 实现删除功能，常用的如下： ==dw== 删除一个单词 ==dnw== 删除 n 个单词， dfa 删除光标处到下一个 a 的字符处（ fa 定位光标到 a 处 ） dnfa 删除光标处到第 n 个 a 的字符处 ==dd== 删除一整行 ndd 删除光标处开始的 n 行 d$ 删除光标到本行的结尾 dH 删除屏幕显示的第一行文本到光标所在的行 dG 删除光标所在行到文本的结束 y 复制，通常搭配一个字符（复制范围）实现复制的功能，常用的如下： ==yw== 复制一个单词，还有 ==ynw== yfa 复制光标到下一个 a 的字符处,还有ynfa ==yy== 复制一行，还有 nyy y$ 复制光标到本行的结尾 yH 复制屏幕显示的第一行文本到光标所在的行 yG 复制光标所在行到文本的结束 p 黏贴，当执行完复制或者黏贴的命令以后，VIM 会把文本寄存起来。 ==p== 在光标后开始复制 P 大写的 P 光标前开始复制 撤销操作和恢复 ==u== 撤销刚才的操作 ctrl + r 恢复撤销操作 删除字符操作和替换 ==x== 删除光标当前所在的字符 ==r== 替换掉光标当前所在的字符 R 替换掉从光标开始以后的所有字符，除非 \u003cESC \u003e 退出，或者 jj （代替 上文有提到）退出。 大小写转换 ~ 将光标下的字母改变大小写 n~ 将光标位置开始的n个字母改变其大小写 g~~ 改变当前行字母的大小写 gUU 将当前行的字母改成大写 guu 将当前行的字母全改成小写 ngUU 将从光标开始到下面n行字母改成大写 gUw 将光标下的单词改成大写 guw 将光标下的单词改成小写 VIM 的重复命令 ==. == 重复上一个操作的命令 n\u003ccommand\u003e 重复某个命令 n 次，如 10p复制 10 次，10dd 删除十次。 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:1:1","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"插入模式（Insert-mode) 在命令模式下按下i就进入了插入模式，进入编辑状态，通过键盘输入内容 从正常模式进入插入模式时 i 在光标所在的字符前插入文本。 I 在光标所在行的行首插入文本。 a 在光标所在的字符之后插入文本。 A 在光标所在行的行尾插入文本。 o 光标所在行的下一行行首文本。 O 光标所在行的上一行行首文本。 s 除光标所在处的字符然后插入文本。 S 除光标所在行，在当前行的行首开始插入需要录入的文本。 cw 删除从光标处开始到该单词结束的所有字符，然后插入文本 在输入模式下， 如果你按下Ctrl-o，你就会进入到insert-normal（输入-普通）子模式。如果你关注一下左下角的模式指示器，通常你将看到-- INSERT -- ，但是按下Ctrl-o后就会变为-- (insert) --。 在这一模式下，你可以执行一条普通模式的命令 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:1:2","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"命令模式（Command-mode) 在正常模式中，按下：（冒号）键或者/ （斜杠），会进入命令模式。 在命令模式中可以执行一些输入并执行一些 VIM 或插件提供的指令 行操作 ==:set nu== 显示行号。 ==:set nonu== 不显示行号 ==:n== 定位到第n行 关键字查找 ==:/{word}== 输入==n==定位到下一个匹配，==N ==定位到上一个匹配。 :set ic 查找时不区分大小写 :set noic 查找时区分大小写 删除 :n1,n2d 删除多行文本。n1 和 n2 指的是起始行号和结束行号，d 是删除关键字 替换 :{作用范围}s/{目标}/{替换}/{替换标志} 作用范围 s 当前行 %s 全文 n1,n2s n1到n2行 替换标志 空替换标志表示只替换从光标位置开始，目标的第一次出现 g 全局（global）替换 i 大小写不敏感 I 大小写敏感 c 需要确认 使用ab :ab {key} {word} 该命令执行后，然后切换到编辑模式下,输入 key值会把输入的key值自动替换成word值 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:1:3","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"可视模式（Visual-mode） 在正常模式按下v, V, \u003cCtrl\u003e+v，可以进入可视模式。 可视模式中的操作有点像拿鼠标进行操作，选择文本的时候有一种鼠标选择的即视感，有时候会很方便。 v字符可视化，按下键盘上的v以后，屏幕底部应该会有一个 VISUAl 的提示，操作 h,j,k,l就选中文本，继续按 v 退出可视化模式。 V 行可视化，按下键盘上的V以后，屏幕底部应该有一个 VISUAL LINE 的提示，操作j,k可以向上或者向下以行为单位选中文本，继续按下 V 退出可视化模式。 Ctrl+v 块状可视化，按下键盘上的 Ctrl+v 以后，屏幕底部应该会有一个提示 VISUALBLOCK ，可以通过 h,j,k,l 块状的操作选择区域，这是很多编辑器都不可以做到的，继续按下Ctrl+v会退出可视化模式。 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:1:4","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"操作文本 可视化模式下选择操作区域以后 按下 d会删除选择的区域 按下y会复制选择的区域 按下 p 会黏贴选择的区域 字符模式下的特殊操作 当操作的文本光标在 “”，‘’ ，（），{} ，[（双引号，单引号，小括号，大括号，中括号）当中时 va\"选中 ”“ 内的所有内容包括双引号 ， ==vi\"== 选中 \"\" 内的所有内容，不包括 \"\" 块区域下的特殊操作 Ctrl+v 选中块区域以后，按下大写的 I 或者 A 可以在区域的前面或者后面输入内容，按下jj或者 \u003cESC\u003e,可以看到选中的区域前面或者后面会有输入的内容。 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:1:5","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"词汇表 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:2:0","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"语法规则 verb + noun # 动词 + 名词 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:2:1","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"名词（动作Motion） 动作对象 h 左 j 下 k 上 l 右 w 向前移动到下一个单词的开头 } 跳转到下一个段落 $ 跳转到当前行的末尾 文本对象 i + object 内部文本对象 a + object 外部文本对象 w 一个单词* p 一个段落 s 一个句子 (或) 一对() {或} 一对{} [或] 一对[] \u003c或\u003e 一对\u003c\u003e t XML标签 \" 一对\"\" ' 一对'' ` 一对`` ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:2:2","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"动作（操作符Operator） y 复制(yank) d 删除(delete) c 删除(change)文本，将删除的文本存到寄存器中，进入插入模式 动作也接受数字作为参数 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:2:3","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"移动 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:0","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"字符导航 上下左右移动一个字符 h 左 j 下 k 上 l 右 对移动计数 [计数] + 移动 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:1","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"单词导航 w 移动到下一个单词的开头* W 移动到下一个词组的开头 e 移动到下一个单词的结尾 E 移动到下一个词组的结尾 b 移动到前一个单词的开头* B 移动到前一个词组的开头 ge 移动到前一个单词的结尾 gE 移动到前一个词组的结尾 一个单词指的是一个只包含a-zA-Z0-9字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:2","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"当前行导航 0 跳到本行第一个字符* ^ 跳到本行第一个非空字符* g_ 跳到本行最后一个非空字符 $ 跳到本行最后一个字符* n| 跳到本行第n列 在本行通过f和t进行行内搜索 f 在同一行向后搜索第一个匹配* F 在同一行向前搜索第一个匹配 t 在同一行向后搜索第一个匹配，并停在匹配前 T 在同一行向前搜索第一个匹配，并停在匹配前 ; 在同一行重复最近一次搜索* , 在同一行向相反方向重复最近一次搜索* ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:3","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"段落导航 一个段落从一个空行之后开始 { 跳转到上一个段落 } 跳转到下一个段落 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:4","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"行号导航 gg 跳转到第一行 G 跳转到最后一行 nG 跳转到第n行 n% 跳到文件的n% ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:5","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"窗格导航 H 跳转到屏幕的顶部 M 跳转到屏幕的中间 L 跳转到屏幕的底部 nH 跳转到距离顶部n行的位置 nL 跳转到距离底部n行的位置 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:6","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"滚动 Ctrl-e 向下滚动一行* Ctrl-d 向下滚动半屏 Ctrl-f 向下滚动一屏 Ctrl-y 向上滚动一行* Ctrl-u 向上滚动半屏 Ctrl-b 向上滚动一屏 相对当前行进行滚动 zt 将当前行置于屏幕顶部附近 zz 将当前行置于屏幕中央 zt 将当前行置于屏幕底部 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:7","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"搜索导航 / 向后搜索一个匹配 ? 向前搜素一个匹配 n 重复上一次搜索(和上一次方向相同) N 重复上一次搜索(和上一次方向相反) 快速搜索光标下的文本 * 向后查找光标所在的完整单词 # 向前查找光标所在的完整单词 g* 向后搜索光标所在的单词 g# 向前搜索光标所在的单词 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:8","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["效率工具"],"content":"位置标记 通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签。通过mx设置一个标记，其中x可以是a-zA-Z。 ma 用a标签标记一个位置 `a 精确回到a标签的位置(行和列) 'a 跳转到a标签的行 ","date":"2021-10-23","objectID":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/:3:9","tags":["Vim","快速入门"],"title":"Vim 教程","uri":"/Notes/posts/%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/vim/"},{"categories":["专业课"],"content":"假设检验 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:0:0","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"引例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:1:0","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"基本概念 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:0","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"理论性理解 假设 对未知总体分布的一个推断 关于总体分布类型的推断，叫非参数假设 关于总体分布参数的推断，叫参数假设 假设检验 检验假设正确与否 分参数假设检验与非参数假设检验 本章只关注参数假设检验 ​ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:1","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"结合例子理解 在上例中，其中的 $H_0$ 称为原假设（零假设） 称$H_1$为备择假设，指原假设被拒绝后可供选择的假设 称给定的数 $\\alpha$ 为显著水平 称 $Z=\\cfrac{\\overline X-\\mu_0}{\\sigma/\\sqrt{n}}$ 为检验统计量 当检验统计量取某个区域$C$中的值时，就要拒绝原假设$H_0$，称区域$C$为拒绝域 称拒绝域的边界点为临界点 由于决策是依据一次抽样作出的，在原假设$H_0$为真时，可能犯拒绝$H_0$的错误，称这种“弃真”错误为第一类错误 其概率为$P{拒绝H_0|H_0为真}$，记为$P_{H_0}{H_1}$ 同时在原假设$H_0$不真时，可能犯接受$H_0$错误，称这种“取伪”的错误为第二类错误 其概率为$P{接受H_0|H_1为真}$，记为$P_{H_1}{H_0}$ 在样本容量一定时，若要使犯一类错误的概率减少，犯另一类错误的概率就会增加 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:2:2","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"显著性假设检验 控制犯第一类错误的概率的检验方法叫做显著性假设检验 步骤 提出一个原假设$H_0$，和与此相对的备择假设$H_1$ 根据所做的假设，确定拒绝形式 确定检验统计量，并由$P_{H_0}{H_1}\\le \\alpha$确定拒绝域 通过抽样结果，作出拒绝域或接受$H_0$的决策（若检验统计量的观察值在拒绝域内，则拒绝$H_0$） 实际上，假设检验是一种带有概率意义的反证法 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:3:0","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"单个正态总体的假设检验 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:4:0","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"总体均值的假设检验 在总体方差$\\sigma^2$已知的条件下 以$U=\\cfrac{\\overline X-\\mu_0}{\\sigma/\\sqrt{n}}$为检验统计量，采用$z$检验法 双边检验：检验假设为$H_0:\\mu=\\mu_0,H_1:\\mu\\neq\\mu_0$ $$ 拒绝域：|z|\\ge z_{\\alpha/2} $$ 左边检验：检验假设为$H_0:\\mu\\ge\\mu_0,H_1:\\mu\u003c\\mu_0$ $$ 拒绝域：z\\le -z_\\alpha $$ 右边检验：检验假设为$H_0:\\mu\\le\\mu_0,H_1:\\mu\u003e\\mu_0$ $$ 拒绝域：z\\ge z_\\alpha $$ 在总体方差$\\sigma^2$未知的条件下 以$T=\\cfrac{\\overline X-\\mu_0}{S/\\sqrt{n}}$为检验统计量，采用$t$检验法 双边检验：检验假设为$H_0:\\mu=\\mu_0,H_1:\\mu\\neq\\mu_0$ $$ 拒绝域：|t|\\ge t_{\\alpha/2}(n-1) $$ 左边检验：检验假设为$H_0:\\mu\\ge\\mu_0,H_1:\\mu\u003c\\mu_0$ $$ 拒绝域：t\\le-t_{\\alpha}(n-1) $$ 右边检验：检验假设为$H_0:\\mu\\le\\mu_0,H_1:\\mu\u003e\\mu_0$ $$ 拒绝域：t\\ge t_{\\alpha}(n-1) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:4:1","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"总体方差的假设检验 在$\\mu$未知的条件下，以$\\chi^2=\\cfrac{(n-1)S^2}{\\sigma_0^2}$为检验统计量，采用$\\chi^2$检验法 双边检验：检验假设为$H_0:\\sigma^2=\\sigma_0^2,H_1:\\sigma^2\\neq\\sigma_0^2$，拒绝域为 $$ \\chi^2\\le\\chi_{1-\\alpha/2}^2(n-1) \\ 或 \\ \\chi^2\\ge\\chi_{\\alpha/2}^2(n-1) $$ 左边检验：检验假设为$H_0:\\sigma^2\\ge\\sigma_0^2,H_1:\\sigma^2\u003c\\sigma_0^2$，拒绝域为 $$ \\chi^2\\le\\chi_{1-\\alpha}^2(n-1) $$ 右边检验：检验假设为$H_0:\\sigma^2\\le\\sigma_0^2,H_1:\\sigma^2\u003e\\sigma_0^2$，拒绝域为 $$ \\chi^2\\le\\chi_{\\alpha}^2(n-1) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:4:2","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"双正态总体的假设检验 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:5:0","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"总体均值差的检验 在总体方差$\\sigma_1^2,\\sigma_2^2$已知的条件下 以$Z=\\cfrac{\\overline{X_1}-\\overline{X_2}-\\delta}{\\sqrt{\\sigma_1^2/n_1+\\sigma_2^2/n_2}}$为检验统计量，采用$z$检验法 双边检验：检验假设为$H_0:\\mu_1-\\mu_2=\\delta,H_1:\\mu_1-\\mu_2\\neq\\delta$，拒绝域为 $$ |z|\\ge z_{\\alpha/2} $$ 左边检验：检验假设为$H_0:\\mu_1-\\mu_2\\ge\\delta,H_1:\\mu_1-\\mu_2\u003c\\delta$，拒绝域为 $$ z\\le-z_\\alpha $$ 右边检验：检验假设为$H_0:\\mu_1-\\mu_2\\le\\delta,H_1:\\mu_1-\\mu_2\\delta$，拒绝域为 $$ z\\ge z_\\alpha $$ 在总体方差$\\sigma_1^2,\\sigma_2^2$未知的条件下 以$T=\\cfrac{\\overline{X_1}-\\overline{X_2}-\\delta}{S_w\\sqrt{1/n_1+1/n_2}}$为检验统计量，采用$t$检验法 双边检验：检验假设为$H_0:\\mu_1-\\mu_2=\\delta,H_1:\\mu_1-\\mu_2\\neq\\delta$，拒绝域为 $$ |t|\\ge t_{\\alpha/2}(n_1+n_2-2) $$ 左边检验：检验假设为$H_0:\\mu_1-\\mu_2\\ge\\delta,H_1:\\mu_1-\\mu_2\u003c\\delta$，拒绝域为 $$ t\\le-t_\\alpha(n_1+n_2-2) $$ 右边检验：检验假设为$H_0:\\mu_1-\\mu_2\\le\\delta,H_1:\\mu_1-\\mu_2\u003e\\delta$，拒绝域为 $$ t\\ge t_\\alpha(n_1+n_2-2) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:5:1","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"总体方差相等的假设检验 在$\\mu_1,\\mu_2$未知的条件下，以$F=\\cfrac{S_1^2}{S_2^2}$为检验统计量，采用$F$检验法 双边检验：检验假设为$H_0:\\sigma_1^2=\\sigma_2^2,H_1:\\sigma_1^2\\neq\\sigma_2^2$，拒绝域为 $$ F\\le F_{1-\\alpha/2}(n_1-1,n_2-1) \\ 或 \\ F\\ge F_{\\alpha/2}(n_1-1,n_2-1) $$ 左边检验：检验假设为$H_0:\\sigma^2\\ge\\sigma_0^2,H_1:\\sigma^2\u003c\\sigma_0^2$，拒绝域为 $$ F\\le F_{1-\\alpha}(n_1-1,n_2-1) $$ 右边检验：检验假设为$H_0:\\sigma^2\\le\\sigma_0^2,H_1:\\sigma^2\u003e\\sigma_0^2$，拒绝域为 $$ F\\ge F_{\\alpha}(n_1-1,n_2-1) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/:5:2","tags":["概率论与数理统计"],"title":"概率论 第八章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/8.-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"},{"categories":["专业课"],"content":"随机变量及其分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:0:0","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"随机变量 定义：设随机试验的样本空间为 $S$，把试验的每一个可能的结果 $e\\in S$ 与一 个 实数 $X(e)$ 对应起来，则称这种定义在S上的一个实值单值映射 $X=X(e)$ 为随机变量(Random Variables) 引入随机变量后，就可将对随机事件及其概率的研究转化为对随机变量及其取值规律的研究 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:1:0","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"离散型随机变量及其概率分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:0","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定义 离散型随机变量 设$X$为一个随机变量，如果它的全部可能取值只有有限个或可数无穷个，则称$X$为一个离散型随机变量 概率分布 设离散型随机变量X所有可能取值为 $x_i(i=1,2,\\ldots,n 或i=1,2,\\ldots)$，称$P{X=x_i}=p_i(i=1,2,\\ldots,n 或i=1,2,\\ldots)$为$X$的概率分布或分布律 分布律可以更直观地用以下表格的形式来描述 $X$ $x_1$ $x_2$ … $x_n$ … $p_i$ $p_1$ $p_2$ … $p_n$ … 其中$p_i$满足 $p_i \\ge 0$ $\\sum\\limits_{i=1}^{n(\\infty)}p_i=1$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:1","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"常见的三个离散型随机变量 (0-1) 或二值分布 $$ P{X=k}=p^k(1-p)^{1-k}\\qquad k=0,1(0\u003cp\u003c1) $$ 二项分布 n 次实验发生了 k 次，每次实验独立，或是放回抽样 $$ P{X=k}=C_n^kp^k(1-p)^{n-k}\\qquad k=0,1,2,\\ldots,n $$ 记作 $X\\sim B(n,p)$，$X$ 即为即为 $n$ 重贝努利试 验中 $A$ 发生的次数 泊松 (Possion) 分布 $$ P{X=k}=e^{-\\lambda}\\cfrac{\\lambda^k}{k!}\\qquad \\lambda\u003e0,k=0,1,2,\\ldots $$ 记作 $X\\sim \\pi(\\lambda)$ 例 某医院在一天的急诊病人数; 某一个时间间隔内某地区发生的交通事故的次数; 在一个时间间隔内某种放射性物质发出经过计数器的α 粒子数 泊松定理：当 n 很大，p 很小时有近似式： $$ C_n^kp^k(1-p)^{n-k}\\approx e^{-\\lambda}\\cfrac{\\lambda^k}{k!} $$ 有时可将较难计算的二项分布转化为泊松分布去计算 补充：超几何分布 N 个样本中有 $N_1$ 类和 $N_2$ 类，从中（不放回地）取 $n$ 个，取出 $N_1$ 的个数设为 $k$ $$ P(X=k)=\\cfrac{C_{N_1}^kC_{N_2}^{n-k}}{C_N^n} $$ 当 N 很大，n 很小时，不放回近似为放回，超几何分布近似为二项分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:2","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"例 某人进行射击，设每次射击的命中率为 0*.*02,独立射击 400 次，试求至少击中两次的概率 设击中的次数为 X，则 $X\\sim B(400,0.02)$，因此所求概率为（近似为泊松定理计算） $$ P{X \\ge 2}=1-P{X\u003c2}=1-P{X=0}-P{X=1}=0.9972 $$ 某公司生产一种产品 300 件，废品率为 0*.*01,问在这 300 件产品中废品数大于 5 的概率是多少？ 设 300 件产品中废品数为 X，则 $X \\sim B(300,0.01)$，因此所求概率为 $$ P{X \\ge 5}=1-\\sum\\limits_{k=0}^5C_{300}^k(0.01)^k(0.99)^{300-k}\\approx 1-\\sum\\limits_{k=0}^5 \\cfrac{e^{-3}3^k}{k!}=0.083918 $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:3","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"随机变量的分布函数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:0","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定义 设$X$是一个随机变量，$x$是任意实数，称函数 $$ F(x)=P{X \\le x}\\qquad -\\infty\u003cx\u003c\\infty $$ 为$X$的分布函数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:1","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"特征 $P{X \\le a}=F(a)$ $P{X \u003e a}=1-F(a)$ $P{a\u003cX\\le b}=F(b)-F(a)$ $P{X = a}=F(a+0)-F(a-0)=F(a)-F(a-0)$ 注意，$P{a\\le X\\le b}\\neq F(b)-F(a)$，而是$P{a\\le X\\le b}=F(b)-F(a-0)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:2","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"性质 $F(x)$是一个不减函数 $0\\le F(x)\\le 1$，且$\\lim\\limits_{x\\rightarrow -\\infty}F(x)\\triangleq F(-\\infty)=0\\qquad\\lim\\limits_{x\\rightarrow +\\infty}F(x)\\triangleq F(+\\infty)=1$ $F(x)$是右连续的，即$F(x+0)=F(x)$ 若一个函数具有以上性质，则它一定是某个随机变量的分布函数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:3","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"离散型随机变量的分布函数（常数） 设离散型随机变量X的分布律为$P{X=x_k}=p_k\\qquad k=1,2,\\ldots$ 则X的分布函数为（x以内，分布函数为所有概率之和） $$ F(x)=P{X \\le x}=\\sum\\limits_{x_k\\le x}P{X=k}=\\sum\\limits_{x_k \\le x}p_k $$ 即当$x_{k-1}\\le x\u003cx_k$时，$F(x)=\\sum\\limits_{i-1}^{k-1}p_i$（在x附近，分布函数为其概率） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:4","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"例 设随机变量$X$的分布函数为 $$ F(x)=A+B\\arctan x,\\qquad -\\infty\u003cx\u003c\\infty $$ ​ 试求：（1）系数A和B； （2）$X$落在$(-1,1]$内的概率 设随机变量X的分布律为 X -1 2 3 $p_i$ 1/4 1/2 1/4 ​ 求X的分布函数，并求$P{X\\le \\cfrac{1}{2}},P{\\cfrac{3}{2}\u003cX\\le \\cfrac{5}{2} }$ 解：前值为1/4，后值为1/2 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:5","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"连续型随机变量及其概率密度 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:0","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定义 如果对随机变量$X$的分布函数$F(x)$，存在一个非负可积函$f(x)$,使得对任意的$x$，有 $$ F(x)=P{X\\le x}=\\int_{-\\infty}^x f(t)dt $$ 则称$X$为一个连续型随机变量，称$f(x)$为$X$的概率密度函数,简称概率密度(Probability densities) 注：连续型随机变量的分布函数为连续函数，所以对任意$a$，有$P{X=a}=0$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:1","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"性质 $f(x)\\ge 0$ $\\int_{-\\infty}^{+\\infty}f(x)dx=1$ $f(x)=F’(x)$ $$ P{X\\le a}=\\int_{-\\infty}^{a}f(x)dx,\\quad P{X\u003eb}=\\int_b^{+\\infty}f(x)dx \\ P{a\u003cx\\le b}=\\int_a^b f(x)dx $$ 注意：分布函数与概率密度函数的区别，例如$F(x)\\le1$成立，但$f(x)\\le 1,\\int_{-\\infty}^{+\\infty}F(x)dx=1$不成立！ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:2","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"常见的三个连续型随机变量 均匀分布 $$ f(x)=\\begin{cases} \\ \\cfrac{1}{b-a}\\qquad a\u003cx\u003cb \\ \\ 0\\qquad\\qquad 其他 \\end{cases} $$ 记为$X\\sim U(a,b)$ 分布函数 $$ F(x)=\\begin{cases} \\ 0 \\qquad\\qquad x\u003ca \\ \\cfrac{x-a}{b-a}\\qquad a\\le x\u003cb \\ \\ a\\qquad\\qquad x\\ge b \\end{cases} $$ 汽车站等车时间 针落地与某直线的倾斜角 指数分布 $$ f(x)=\\begin{cases} \\ \\lambda e^{-\\lambda x}\\qquad x\\ge 0 \\ \\ 0\\qquad\\qquad 其他 \\end{cases}\\quad(\\lambda\u003e0) $$ 记为$X\\sim e(\\lambda)$ 分布函数 $$ F(x)=\\begin{cases} \\ 1- e^{-\\lambda x}\\qquad x\u003e 0 \\ \\ 0\\qquad\\qquad \\quad 其他 \\end{cases}\\quad $$ 指数分布具有无记忆性，即 $$ P{X\u003et}=p{X\u003es+t|X\u003es} $$ 新生的物品（生物）能存活 t 年的以上概率 = 已经活了 s 年的物品（生物）再存活 t 年以上的概率 电话系统通话时间 消耗性产品的寿命 生物寿命 正态分布 $$ f(x)=\\cfrac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\cfrac{(x-\\mu)^2}{2\\sigma^2}},\\quad -\\infty\u003cx\u003c+\\infty $$ 记为$X\\sim N(\\mu,\\sigma^2)$ 性质 $\\mu$ 为均值，控制图像位置，$\\sigma$ 为方差，控制图像高低（陡缓） $y=f(x)$ 以 $x=\\mu$ 为对称轴，呈钟形曲线 概率最大值在 $x=\\mu$ 时取到，值为 $\\cfrac{1}{\\sqrt{2\\pi}\\sigma}$ 分布函数 $$ F(x)=\\cfrac{1}{\\sqrt{2\\pi}\\sigma}\\int_{-\\infty}^x e^{-\\cfrac{(t-\\mu)^2}{2\\sigma^2}}dt $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:3","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"正态分布详解 对正态分布随机变量$X$，若$\\mu=0,\\sigma=1$，则称$X$服从标准正态分布，其分布函数和概率密分别用$\\Phi(x)$和$\\phi(x)$表示，即 $$ \\Phi(x)=\\cfrac{1}{\\sqrt{2\\pi}}\\int_{-\\infty}^xe^{-\\cfrac{t^2}{2}}dt,\\quad\\phi(x)=\\cfrac{1}{\\sqrt{2\\pi}}e^{-\\cfrac{x^2}{2}} \\ \\Phi(0)=\\cfrac{1}{2},\\quad \\Phi(x)=1-\\Phi(-x) $$ 定理1：设$X\\sim N(\\mu,\\sigma^2)$，则$Y=\\cfrac{X-\\mu}{\\sigma}~N(0,1)$。因此有（标准化） $P{X\\le a}=P{\\cfrac{X-\\mu}{\\sigma}\\le \\cfrac{a-\\mu}{\\sigma} }=\\Phi(\\cfrac{a-\\mu}{\\sigma})$ $P{X\u003eb}=P{\\cfrac{X-\\mu}{\\sigma}\u003e \\cfrac{b-\\mu}{\\sigma} }=1-\\Phi(\\cfrac{b-\\mu}{\\sigma})$ $P{a\u003cX\\le b}=P{\\ \\cfrac{a-\\mu}{\\sigma} \u003c\\cfrac{X-\\mu}{\\sigma}\\le \\cfrac{b-\\mu}{\\sigma} }=\\Phi(\\cfrac{b-\\mu}{\\sigma})-\\Phi(\\cfrac{a-\\mu}{\\sigma})$ 当$a\u003e0$时，$\\Phi(a)$的值往往是通过查表得到，当$a\u003c0$时，先利用$\\Phi(a)=1-\\Phi(-a)$，再查表得到。 $p{|x-\\mu|\u003c\\sigma}=0.6826$ $p{|x-\\mu|\u003c2\\sigma}=0.9544$ $p{|x-\\mu|\u003c3\\sigma}=0.9974$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:4","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"例 某元件的寿命$X$服从指数分布，其参数为$\\lambda=\\cfrac{1}{1000}$，求3个这样的元件用1000小时时，至少已有一个损坏的概率 解：一个元件使用1000小时时损坏的概率为 $$ P{X\\le 1000}=1-e^{-1} $$ ​ 用$Y$表示3个元件中使用1000小时时损坏的元件数，则$Y\\sim B(3,1-e^{-1})$，因此所求概率为 $$ P{Y\\ge 1}=1-P{Y=0}=1-C_3^0(1-e^{-1})^0(e^{-1})^3=1-e^{-3} $$ 设$X\\sim N(1,4)$ （1）求$P{x\\le 5},\\ P{0\u003cX\\le 1.6},\\ P{|X-1|\\le 2}$ （2）设$d$满足$P{X\u003ed}\\ge 0.9$，问$d$至少为多少 解： （1）标准化，查表。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:5","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"随机变量的函数的分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:0","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"随机变量函数的概念 如果存在一个函数$g(\\sdot)$，使得随机变量$X,Y$满足：$Y=g(X)$，则称随机变量$Y$是随机变量$X$的函数。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:1","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"离散型随机变量的函数的分布 设离散型随机变量$X$的分布律为： $$ P{X=x_i}=p_i,\\qquad i=1,2,\\ldots $$ 显然，$X$的随机变量函数$Y=g(X)$也是离散型随机变量，且$Y$的分布律为 $$ P{Y=y_i}=\\sum\\limits_{g(x_i)=y_i}p_i\\qquad j=1,2,\\ldots $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:2","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"连续型随机变量的函数的分布 设$X$的概率密度为$f_X(x),Y=g(X)$，则$Y$的分布函数为 $$ F_Y(y)=P{Y\\le y}=P{g(X)\\le y}=\\int_{C_y}f(x)dx $$ 其中$C_y={x\\mid g(x)\\le y}$ 方法：$F_Y(x)\\rightarrow F_X(x)$，两边求导，$f_Y(x)\\leftarrow f_X(x)$ 定理 设随机变量$X$概率密度为$f_X(x)$，函数$y=g(x)$处处可导，且$g’(x)\u003e0$（或$g’(x)\u003c0$），则$Y=g(X)$也是连续型随机变量，其概率密度为 $$ f_Y(y)=\\begin{cases} \\ f_X(h(y))|h’(y)| \\qquad \\alpha\u003cy\u003c\\beta \\ \\ 0\\qquad\\qquad \\qquad\\qquad 其他 \\end{cases}\\quad $$ 其中$x=h(y)$为$y=g(x)$的反函数 当$f(x)$在$(-\\infty,+\\infty)$上非零时 $$ \\alpha=min(g(-\\infty),g(+\\infty)),\\beta=max(g(-\\infty),g(+\\infty)) $$ 当$f(x)$在$[a,b]$上非零时 $$ \\alpha=min(g(a),g(b)),\\beta=max(g(a),g(b)) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:3","tags":["概率论与数理统计"],"title":"概率论 第二章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/2.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"样本及抽样分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:0:0","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"数理统计的基本概念 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:1:0","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"总体与个体 总体（母体）：具有一定共性的研究对象的全体，记为 $\\Bbb{X}$ 个体：构成总体的每一个成员 总体的容量：个体的个数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:1:1","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"样本与样本分布 抽样：按一定的原则从$\\Bbb{X}$中抽取若干个体 样本：被抽出的部分个体（相互独立且同分布），记作$X_1,X_2,\\ldots,X_n$ 总体分布：每一个个体可以看作一个随机变量，这个随机变量的分布即为总体分布 样本容量：样本是一组随机变量$X_1,X_2,\\ldots,X_n$，$n$即为样本容量 样本值：对样本进行一次观察得到的一组观察值$x_1,x_2,\\ldots,x_n$ 样本分布：样本$(X_1,X_2,\\ldots,X_n)$的概率分布，有 $$ F(x_1,x_2,\\ldots,x_n)=F(x_1)F(x_2)\\ldots F(x_n)\\ f(x)=f(x_1)f(x_2)\\ldots f(x_n) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:1:2","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"统计量 定义 设 $X_1,X_2,\\ldots,X_n$ 是来自总体 $\\Bbb{X}$ 的一个样本，称此样本的任一不含总体分布未知参数的函数为该样本的统计量 统计量是随机变量，不是一个数 常见的统计量及其观察值分布 样本均值 $$ \\overline{X}=\\cfrac{1}{n}\\sum\\limits_{i=1}^{n}X_i\\ \\overline{x}=\\cfrac{1}{n}\\sum\\limits_{i=1}^{n}x_i $$ 样本方差 $$ S^2=\\cfrac{1}{n-1}\\sum\\limits_{i=1}^{n}(X_i-\\overline{X})^2=\\cfrac{1}{n-1}(\\sum\\limits_{i=1}^{n}X_i^2-n\\overline{X}^2)\\ s^2=\\frac{1}{n-1}\\sum\\limits_{i-1}^n(x_i-\\overline{x})^2 $$ 样本标准差 $$ S=\\sqrt{\\cfrac{1}{n-1}\\sum\\limits_{i=1}^{n}(X_i-\\overline{X})^2}\\ s=\\sqrt{\\frac{1}{n-1}\\sum\\limits_{i-1}^n(x_i-\\overline{x})^2} $$ 样本k阶（原点）矩 $$ A_k=\\cfrac{1}{n}\\sum\\limits_{i=1}^nX_i^k\\qquad k=1,2,\\ldots\\ a_k=\\cfrac{1}{n}\\sum\\limits_{i=1}^nx_i^k $$ 样本k阶中心矩 $$ B_k=\\cfrac{1}{n}\\sum\\limits_{i=1}^n(X_i-\\overline{X})^k\\qquad k=2,3,\\ldots\\ b_k=\\cfrac{1}{n}\\sum\\limits_{i=1}^n(x_i-\\overline{x})^k $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:1:3","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"抽样分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:2:0","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"概念 称统计量的分布为抽样分布（统计分布） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:2:1","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"分类 $\\chi ^2$ 分布 定义 设 $X_1,X_2,\\ldots,X_n$ 是来自总体 $N(0,1)$ 的样本，则称统计量 $$ \\chi^2=X_1^2+X_2^2+\\ldots+X_n^2=\\sum\\limits_{i=1}^{n}X_i^2 $$ 服从自由度为 $n$ 的 $\\chi^2$ 分布，记作 $\\chi^2\\sim \\chi^2(n)$ 性质 $\\chi_1^2+\\chi_2^2\\sim \\chi^2(n_1+n_2)$ $E(\\chi^2)=n\\qquad D(\\chi^2)=2n$ 图形特征（扩展） 单峰曲线，在 n-2 时取到最大值 不对称，n 越大越对称 当 n 很大时可用正态分布来近似 $t$ 分布 设$X\\sim N(0,1),Y\\sim \\chi^2(n)$，且 $X,Y$ 相互独立，则称统计量 $$ t=\\cfrac{X}{\\sqrt{Y/n}} $$ 服从自由度为 $n$ 的 $t$ 分布（学生氏分布），记作 $t\\sim t(n)$ $F$ 分布 设 $U\\sim \\chi^2(n_1),V\\sim \\chi^2(n_2)$，且 $U,V$ 相互独立，则称统计量 $$ F=\\cfrac{U/n_1}{V/n_2} $$ 服从自由度为 $(n_1,n_2)$的 $F$ 分布，记作 $F\\sim F(n_1,n_2)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:2:2","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"分位数 （Quantile） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:3:0","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"概念 对随机变量$X,0\u003c\\alpha\u003c1$ 若$P{X\u003et_\\alpha}=\\alpha$，则称$t_\\alpha$为$X$的上$\\alpha$分位点 若$P({X\u003ct_{\\alpha_1}}\\cup{X\u003et_{\\alpha_2}})=\\alpha(\\alpha_1+\\alpha_2=1)$，则称$t_{\\alpha_1}$和$t_{\\alpha_2}$为$X$的双侧$\\alpha$分位点 通常取$\\alpha_2=\\alpha/2,\\alpha_1=1-\\alpha/2$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:3:1","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"常见分布的分位点 标准正态分布 设 $X\\sim N(0,1)$，若数 $z_\\alpha$ 满足 $$ P{X\u003ez_\\alpha}=\\alpha,0\u003c\\alpha\u003c1 $$ 则称 $z_\\alpha$ 为标准正态分布的上 $\\alpha$ 分位点 $\\chi^2$ 分布 设$\\mathcal{X}^2\\sim X^2(n)$，若数${\\mathcal X_\\alpha^2}(n)$满足 $$ P{\\mathcal{X}^2\u003eX_\\alpha^2(n)}=\\alpha,0\u003c\\alpha\u003c1 $$ 则称${\\mathcal{X}_\\alpha^2}(n)$为$\\mathcal{X^2}(n)$分布的上$\\alpha$分位点 $t$ 分布 设 $t\\sim t(n)$，若数 $t_\\alpha(n)$ 满足 $$ P{t\u003et_\\alpha(n)}=\\alpha,0\u003c\\alpha\u003c1 $$ 则称 $t_\\alpha(n)$ 为 $t(n)$分布的上 $\\alpha$ 分位点 有$t_{1-\\alpha}(n)=-t_\\alpha(n)$ $F$ 分布 设 $F\\sim F(n_1,n_2)$，若数 $F_\\alpha(n_1,n_2)$ 满足 $$ P{F\u003eF_\\alpha(n_1,n_2)}=\\alpha,0\u003c\\alpha\u003c1 $$ 则称 $F_\\alpha(n_1,n_2)$ 为$F$分布的上 $\\alpha$ 分位点 有$F_\\alpha(n_1,n_2)=\\cfrac{1}{F_{1-\\alpha}(n_2,n_1)}$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:3:2","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"总结 分布名 上 $\\alpha$ 分位点 双侧 $\\alpha$ 分位点 标准正态分布 $z_\\alpha$ $\\pm z_{\\alpha/2}$ $\\mathcal X^2$ 分布 ${\\mathcal X_\\alpha^2}(n)$ ${\\mathcal X}^2_{\\alpha/2}(n)\\{\\mathcal X}^2_{1-\\alpha/2}(n)$ $t$ 分布 $t_\\alpha(n)$ $\\pm t_{\\alpha/2}(n)$ $F$ 分布 $F_\\alpha(n_1,n_2)$ $F_{\\alpha/2}(n_1,n_2)\\F_{1-\\alpha/2}(n_1,n_2)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:3:3","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"正态总体的样本均值与样本方差的分布 设总体$\\Bbb X$的均值为$\\mu$，方差为$\\sigma^2$，$X_1,X_2,\\ldots,X_n$是来自$\\Bbb X$的一个样本，$\\overline{X}$和$S^2$分别为该样本的样本均值和样本方差，则 $$ E(\\overline{X})=\\mu,D(\\overline{X})=\\cfrac{\\sigma^2}{n}\\ E(S^2)=\\sigma^2 $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:4:0","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定理一 设总体$\\Bbb X$的分布为$N(\\mu,\\sigma^2)$，$X_1,X_2,\\ldots,X_n$是来自$\\Bbb X$的一个样本，$\\overline{X}$为该样本的样本均值，则 $$ (1) \\quad \\overline{X}\\sim N(\\mu,\\sigma^2/n)\\qquad (2)\\quad\\cfrac{\\overline{X}-\\mu}{\\sigma/\\sqrt{n}}\\sim N(0,1) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:4:1","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定理二 设总体$\\Bbb X$的分布为$N(\\mu,\\sigma^2)$，$X_1,X_2,\\ldots,X_n$是来自$\\Bbb X$的一个样本，$\\overline{X}$和$S^2$分别为该样本的样本均值和样本方差，则 $$ (1)\\quad\\cfrac{n-1}{\\sigma^2}S^2\\sim\\chi^2(n-1)\\qquad(2)\\quad\\overline{X}与S^2相互独立 $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:4:2","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定理三 设总体$\\Bbb X$的分布为$N(\\mu,\\sigma^2)$，$X_1,X_2,\\ldots,X_n$是来自$\\Bbb X$的一个样本，$\\overline{X}$和$S^2$分别为该样本的样本均值和样本方差，则 $$ \\cfrac{\\overline{X}-\\mu}{S/\\sqrt{n}}\\sim t(n-1) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:4:3","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定理四 设 $X_1,X_2,\\ldots,X_{n1}$ 与 $Y_1,Y_2,\\ldots,Y_{n2}$ 分别是来自两个相互独立的正态总体 $N(\\mu_1,\\sigma^2_1)$ 和 $N(\\mu_2,\\sigma^2_2)$ 的样本，$\\overline{X}$ 和$ \\overline{Y}$ 分别为这两个样本的样本均值，$S_1^2$ 和 $S_2^2$ 分别为这两个样本的样本方差，则 $$ (1)\\quad\\cfrac{(\\overline{X}-\\overline{Y})-(\\mu_1-\\mu_2)}{\\sqrt{\\sigma_1^2/n_1+\\sigma_2^2/n_2}}\\sim N(0,1)\\qquad(2)\\quad\\cfrac{S_1^2/S_2^2}{\\sigma_1^2/\\sigma_2^2}\\sim F(n_1-1,n_2-1) \\(3)当\\sigma^2_1=\\sigma^2_2=\\sigma^2时，\\quad\\cfrac{(\\overline{X}-\\overline{Y})-(\\mu_1-\\mu_2)}{S_w\\sqrt{\\cfrac{1}{n_1}+\\cfrac{1}{n_2}}}\\sim t(n_1+n_2-2) \\其中S_w=\\sqrt{\\cfrac{(n_1-1)S_1^2+(n_2-1)S^2_2}{n_1+n_2-2}} $$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/:4:4","tags":["概率论与数理统计"],"title":"概率论 第六章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/6.-%E6%A0%B7%E6%9C%AC%E5%8F%8A%E6%8A%BD%E6%A0%B7%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"参数估计 统计推断的基本问题分为两类：一是估计问题，另一个是假设检验。本章主要讨论总体参数的点估计和区间估计。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:0:0","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"点估计 用总体 $\\Bbb X$ 的一个样本来估计总体未知参数的方法称为点估计法 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:1:0","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"术语 设 $X_1,X_2,\\ldots,X_n$ 是来自总体 $\\Bbb X$ 的一个样本，点估计法就是要构建一个合适的统计量$\\hat{\\theta}(X_1,X_2,\\ldots,X_n)$用它的观察值$\\hat{\\theta}(x_1,x_2,\\ldots,x_n)$作为未知参数$\\theta$的近似值，有 估计量：$\\hat{\\theta}(X_1,X_2,\\ldots,X_n)$ 估计值：$\\hat{\\theta}(x_1,x_2,\\ldots,x_n)$ 估计量和估计值统称为估计 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:1:1","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"矩估计法 用样本矩作为相应的总体矩的估计方法称为矩估计法 方法 设$\\theta_1,\\theta_2,\\ldots,\\theta_k$为带估计的参数，用$\\Theta$表示带估计参数组成的向量，即$\\Theta=(\\theta_1,\\theta_2,\\ldots,\\theta_k)$ $\\Bbb X$ 为连续型总体，其概率密度为 $f(x,\\Theta)$，总体的前 $k$ 阶矩为 $$ \\mu_l(\\Theta)=E(X^l)=\\int_{-\\infty}^{+\\infty}x^lf(x,\\Theta)dx\\quad l=1,2,\\ldots,k $$ $\\Bbb X$ 为离散型总体，其分布律为 $P{X=x_i}=p_i(\\Theta),i=1,2,\\ldots,k$，总体的前 $k$ 阶矩为 $$ \\mu_l(\\Theta)=E(X^l)=\\sum\\limits_{i=1}^{\\infty}(x_i)^lp_i(\\Theta)\\quad l=1,2,\\ldots,k $$ 设$X_1,X_2,\\ldots,X_n$为来自总体$\\Bbb X$的一个样本，它的前$k$阶样本矩观察值为 $$ a_l=\\cfrac{1}{n}\\sum\\limits_{i=1}^nx_i^l\\quad (l=1,2,\\ldots,k) $$ 然后列方程（组） $$ \\begin{cases} \\ \\mu_1(\\theta_1,\\theta_2,\\ldots,\\theta_k)=a_1 \\ \\ \\mu_2(\\theta_1,\\theta_2,\\ldots,\\theta_k)=a_2 \\ \\ \\vdots \\ \\ \\mu_k(\\theta_1,\\theta_2,\\ldots,\\theta_k)=a_k \\end{cases} $$ 最后求解方程（组），即可获得未知参数$\\theta_1,\\theta_2,\\ldots,\\theta_k$的估计值为 $$ \\hat{\\theta}_l=\\theta_l(a_1,a_2,\\ldots,a_k)\\quad (l=1,2,\\ldots,k) $$ 因此估计量为 $$ \\hat{\\theta}_l=\\theta_l(A_1,A_2,\\ldots,A_k)\\quad (l=1,2,\\ldots,k) $$ 例 结论 总体期望可以由样本均值（一阶中心矩）表示，$\\overline{X} 或 A_1$ 总体方差可以由样本二阶中心矩表示，$A_2$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:1:2","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"最大似然估计法 设 $\\theta_1,\\theta_2,\\ldots,\\theta_k$ 为带估计的参数，用$\\Theta$表示带估计参数组成的向量，即$\\Theta=(\\theta_1,\\theta_2,\\ldots,\\theta_k)$ 设$x_1,x_2,\\ldots,x_n$是一组抽样值，这意味着${X_1=x_1,X_2=x_2,\\ldots,X_n=x_n}$是一个大概率事件。 最大似然估计法就是要确定未知参数的值，使得$P{X_1=x_1,X_2=x_2,\\ldots,X_n=x_n}$（这其中含有未知参数）为最大。 方法 $\\Bbb X$ 为离散型总体，其分布律为 $P{X=x_i}=p_i(\\Theta),i=1,2,\\ldots,k$，设$x_1,x_2,\\ldots,x_n$是一组抽样值 $$ P{X_1=x_1,X_2=x_2,\\ldots,X_n=x_n}=\\prod\\limits_{i=1}^np_i(\\Theta),令\\ L(x_1,x_2,\\ldots,x_n;\\Theta)=\\prod\\limits_{i=1}^np_i(\\Theta) $$ $\\Bbb X$ 为连续型总体，其概率密度为 $f(x,\\Theta)$，设$x_1,x_2,\\ldots,x_n$是一组抽样值 $$ P{X_1=x_1,X_2=x_2,\\ldots,X_n=x_n}\\approx\\prod\\limits_{i=1}^nf(x_i;\\Theta) $$ ​ 其中$\\prod\\limits_{i=1}^ndx_i$与未知参数$\\Theta$无关 $$ L(x_1,x_2,\\ldots,x_n;\\Theta)=\\prod\\limits_{i=1}^nf(x_i;\\Theta) $$ 称 $$ L=(x_1,x_2,\\ldots,x_n;\\theta_1,\\theta_2,\\ldots,\\theta_k) $$ 为似然函数，其自变量为$\\theta_1,\\theta_2,\\ldots,\\theta_k$。 最大似然估计就是要确定参数取何值时似然函数达到最大值。 通常利用对数似然函数来求，即求 $$ \\cfrac{\\partial}{\\partial\\theta_i}lnL(x_1,x_2,\\ldots,x_n;\\theta_1,\\theta_2,\\ldots,\\theta_k)=0\\qquad(i=1,2,\\ldots,k) $$ 来求得未知参数的估计值$\\hat\\theta_1,\\hat\\theta_2,\\ldots,\\hat\\theta_k$，再将其估计值改为估计量 例 步骤 求总体的分布律/概率密度 写出似然函数 $$ L(\\Theta)=\\prod\\limits_{i=1}^np_i(\\Theta)\\ 或 \\ L(\\Theta)=\\prod\\limits_{i=1}^nf(x_i;\\Theta) $$ 取对数，求导 $$ \\cfrac{\\partial}{\\partial\\Theta}lnL=… $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:1:3","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"估计量的评选标准 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:2:0","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"无偏性 若估计量 $\\hat\\theta=\\hat\\theta(X_1,X_2,\\ldots,X_n)$ 的数学期望 $E(\\hat\\theta)$ 存在，且对任意 $\\theta\\in \\Theta$ 有 $$ E(\\hat\\theta)=\\theta $$ 则称$\\hat\\theta$是$\\theta$的无偏估计量 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:2:1","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"有效性 设$\\hat\\theta_1=\\hat\\theta_1(X_1,X_2,\\ldots,X_n)$与$\\hat\\theta_2=\\hat\\theta_2(X_1,X_2,\\ldots,X_n)$都是$\\theta$的无偏估计量，若对任意的$\\theta\\in \\Theta$，有 $$ D(\\hat\\theta_1)\\le D(\\hat\\theta_2) $$ 则称 $\\hat\\theta_1$ 较 $\\hat\\theta_2$ 有效 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:2:2","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"相合性 设 $\\hat\\theta=\\hat\\theta(X_1,X_2,\\ldots,X_n)$ 是参数 $\\theta$ 的估计量，若对于任意的 $\\theta\\in \\Theta$，对于任意 $\\varepsilon\u003e0$ 有 $$ \\lim\\limits_{n\\rightarrow\\infty}P{|\\hat\\theta-\\theta|\u003c\\varepsilon}=1 $$ 则称 $\\hat\\theta$ 是 $\\theta$ 的相合估计量 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:2:3","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"区间估计 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:3:0","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"置信区间 设总体 $\\Bbb X$ 的分布含有一个未知参数 $\\theta$，对于给定的 $\\alpha(0\u003c\\alpha\u003c1)$，由来自 $\\Bbb X$ 的样本 $X_1,X_2,\\ldots,X_n$ 确定的两个统计量$\\underline\\theta=\\underline\\theta(X_1,X_2,\\ldots,X_n)$ 和 $\\overline\\theta=\\overline\\theta(X_1,X_2,\\ldots,X_n)$，对任意 $\\theta\\in\\Theta$ 都有 $$ P{\\underline\\theta\u003c\\theta\u003c\\overline\\theta}\\ge 1-\\alpha $$ 则称随机区间 $(\\underline\\theta,\\overline\\theta)$为 $\\theta$ 的一个置信水平为 $1-\\alpha$ 的置信区间， $\\underline\\theta$：双侧置信下限 $\\overline\\theta$：双侧置信上限 $1-\\alpha$：置信水平 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:3:1","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"区间估计 求出一个合适的置信水平为 $1-\\alpha$ 的置信区间，使得该区间包含参数 $\\theta$ 真值的可信程度为置信水平 $1-\\alpha$ 步骤 寻求一个样本 $X_1,X_2,\\ldots,X_n$ 和 $\\theta$ 的函数 $W=W(X_1,X_2,\\ldots,X_n,\\theta)$，使其分布是已知（但该分布与$\\theta$无关），（通常称这个$W$为枢轴量） 对给定的置信水平 $1-\\alpha$，由双侧分位点确定 $a$ 和 $b$，使得 $$ P{a\u003cW(X_1,X_2,\\ldots,X_n,\\theta)\u003cb}=1-\\alpha $$ 由 $a\u003cW(X_1,X_2,\\ldots,X_n,\\theta)$ 得出 $\\underline\\theta\u003c\\theta\u003c\\overline\\theta$，则 $(\\underline\\theta,\\overline\\theta)$ 为所求的 $\\theta$ 的置信水平为 $1-\\alpha$ 的置信区间 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:3:2","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"正态总体均值与方差的区间估计 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:4:0","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"单个总体的情况 方差$\\sigma^2$已知的条件下均值$\\mu$的置信区间（略） 方差$\\sigma^2$未知的条件下均值$\\mu$的置信区间 $$ (\\overline X\\pm\\cfrac{S}{\\sqrt{n}}t_{\\alpha/2}(n-1)) $$ 方差$\\sigma^2$的置信区间 $$ (\\cfrac{(n-1)S^2}{\\chi^2_{\\alpha/2}(n-1)},\\cfrac{(n-1)S^2}{\\chi^2_{1-\\alpha/2}(n-1)}) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:4:1","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"两个总体的情况 $\\sigma_1^2,\\sigma_2^2$已知，$\\mu_1-\\mu_2$的区间估计，枢轴量为 $$ Z=\\cfrac{\\overline X-\\overline Y-(\\mu_1-\\mu_2)}{\\sqrt{\\cfrac{\\sigma_1^2}{n_1}+\\cfrac{\\sigma_2^2}{n_2}}}\\sim N(0,1) $$ $\\sigma_1^2,\\sigma_2^2$未知，$\\mu_1-\\mu_2$的区间估计，枢轴量为 $$ t=\\cfrac{\\overline X-\\overline Y-(\\mu_1-\\mu_2)}{S_w\\sqrt{\\cfrac{1}{n_1}+\\cfrac{1}{n_2}}}\\sim t(n_1+n_2-2) $$ $\\mu_1,\\mu_2$未知，$\\cfrac{\\sigma_1^2}{\\sigma_2^2}$的区间估计，枢轴量为 $$ F=\\cfrac{S_1^2/S_2^2}{\\sigma_1^2/\\sigma_2^2}\\sim F(n_1-1,n_2-1) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:4:2","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"总结 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:4:3","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:4:4","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"单侧置信区间 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/:4:5","tags":["概率论与数理统计"],"title":"概率论 第七章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/7.-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/"},{"categories":["专业课"],"content":"多维随机变量及其分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:0:0","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维随机变量 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:1:0","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"定义 设$E$是一个随机试验，它的样本空间为$S$，设$X=X(e), Y=Y(e)$是定义在$S$上的两个随机变量，由它们构成的向量$(X,Y)$，叫做二维随机变量（也称随机矢量） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:1:1","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"分布函数及其性质 设$(X,Y)$是一个二维随机变量，对任意的实数$x,y$，定义 $$ F(x,y)=P({X\\le x}\\cap {Y\\le y})\\triangleq P{X\\le x,Y\\le y} $$ 则称$F(x,y)$为二维随机变量$(X,Y)$的分布函数。 性质 $F(x,y)$是关于变量 x 和 y 的不减函数 $0\\le F(x,y)\\le 1$ $F(-\\infty,y)=\\lim\\limits_{x\\rightarrow-\\infty}F(x,y)=0,\\quad F(x,-\\infty)=\\lim\\limits_{y\\rightarrow-\\infty}F(x,y)=0\\ F(-\\infty,-\\infty)=\\lim\\limits_{x,y\\rightarrow-\\infty}F(x,y)=0\\ F(+\\infty,+\\infty)=\\lim\\limits_{x,y\\rightarrow+\\infty}F(x,y)=1$ $F(x,y)$既关于 x 右连续（$F(x+0,y)=F(x,y)$），也关于 y 右连续（$F(x,y+0)=F(x,y)$） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:1:2","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维离散型随机变量及其分布 若二维随机变量$(X,Y)$只有有限或可列个取值对，则称$X,Y$为一个二维离散型随机变量 若随机矢量$(X,Y)$所有可能取值对为$(x_i,y_i),(i=1,2,\\ldots,j=1,2,\\ldots)$ 则称 $$ P({X=x_i}\\cap{Y=y_i})\\triangleq {X=x_i,Y=y_i}=P_{i,j} \\(i=1,2,\\ldots,j=1,2,\\ldots) $$ 为$(X,Y)$的分布律或称联合分布律。 联合分布律可以更直观地用以下表格的形式来描述 其中$p_{i,j}(i=1,2,\\ldots,j=1,2,\\ldots)$要满足以下条件 $p_{i,j}\\ge 0$ $\\sum\\limits_{i=1}^\\infty\\sum\\limits_{j=1}^\\infty p_{i,j}=1$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:1:3","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维连续型随机变量及其概率密度 二维连续型随机变量的定义 设$(X,Y)$为二维随机变量，$F(x,y)$为其分布函数，若存在一个非负二元 函数$f(x,y)$，使得对任意$x,y$有 $$ F(x,y)=\\int_{-\\infty}^x\\int_{-\\infty}^y f(s,t)dsdt $$ 则称$(X,Y)$为二维连续型随机变量，并称$f(x,y)$为$(X,Y)$的概率密度， 或称为$X$和$Y$的联合概率密度 二维概率密度的性质 $f(x,y)\\ge 0$ $\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty} f(x,y)dxdy=1$ $P{(X,Y)\\in D}=\\iint\\limits_D f(x,y)dxdy$（其中的$D$为一个平面区域） $f(x,y)=\\cfrac{\\partial ^2 F(x,y)}{\\partial x\\partial y}$ 两个常见的二维连续型随机变量 二维均匀分布 $(X,Y)$的概率密度为 $$ f(x,y)=\\begin{cases} \\ \\cfrac{1}{A}\\qquad (x,y)\\in G \\ \\ 0\\qquad \\quad 其他 \\end{cases}\\quad \\其中G为平面上的一个有界区域，A为其面积（即S(G)） $$ 二维正态分布 $(X,Y)$的概率密度为 $$ f(x,y)=\\cfrac{1}{2\\pi \\sqrt{1-\\rho^2}\\sigma_1\\sigma_2}exp{\\cfrac{-1}{2(1-\\rho^2)}\\left[ \\bigg(\\cfrac{x-\\mu_1}{\\sigma_1}\\bigg)^2-2\\rho \\bigg(\\cfrac{x-\\mu_1}{\\sigma_1}\\bigg)\\cdot \\bigg(\\cfrac{y-\\mu_2}{\\sigma_2}\\bigg)+\\bigg(\\cfrac{y-\\mu_2}{\\sigma_2}\\bigg)^2 \\right]} $$ ​ 记作$(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$ ​ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:1:4","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"边缘分布 （Marginal Distribution） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:0","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"概念 对于二维随机变量 w$(X,Y)$，其分布函数为 $F(x,y)$，它的每个分量 $X$ 和 $Y$ 都是一维随机变量，它们各自的分布函数分别为 $F_X(x)$ 和 $F_Y(y)$，通常把它们称为 $(X,Y)$ 关于 $X$ 和 $Y$ 的边缘分布函数。 接下来我们考察一下联合分布函数$F(x,y)$与边缘分布函数$F_X(x)$和$F_Y(y)$的关系： $$ F_X(x)=P{X\\le x}=P{X\\le x,Y\u003c+\\infty}=F(x,+\\infty)\\F_Y(y)=P{Y\\le y}=P{X\u003c +\\infty,Y\\le y}=F(+\\infty,y) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:1","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维离散型随机变量的边缘分布律 $$ F_X(x)=F(x,+\\infty)=\\sum\\limits_{x_i\\le x}\\sum\\limits_{j=1}^{+\\infty}p_{i,j} $$ （注意：对一维随机变量$X$，$F_X(x)=\\sum\\limits_{x_i\\le x}p_i$） 所以关于$X$的边缘分布律为 $$ P{X=x_i}=\\sum\\limits_{j=1}^\\infty p_{i,j}\\triangleq p_{i\\cdot} \\qquad(i=1,2,\\ldots) $$ 类似地，关于$Y$的边缘分布律为 $$ P{Y=y_i}=\\sum\\limits_{i=1}^\\infty p_{i,j}\\triangleq p_{j\\cdot} \\qquad(j=1,2,\\ldots) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:2","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维连续型随机变量的边缘概率密度 设二维连续型随机变量$(X,Y)$的联合概率密度为$f(x,y)$，则 $$ F_X(x)=F(x,+\\infty)=\\int_{-\\infty}^x\\left[ \\int_{-\\infty}^{+\\infty}f(s,t)dt \\right]ds \\ 对一维连续型随机变量X，F_X(x)=\\int_{-\\infty}^{x}f_X(t)dt $$ 所以，==关于$X$的边缘概率密度==为 $$ f_X(x)=\\int_{-\\infty}^{+\\infty}f(x,y)dy $$ 同样地，==关于 $Y$ 的边缘概率密度==为 $$ f_Y(y)=\\int_{-\\infty}^{+\\infty}f(x,y)dx $$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:2:3","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"条件分布 （Conditional Distribution） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:0","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维离散型随机变量的条件分布律 设$(X,Y)$是二维离散型随机变量，其分布律为 $$ P{X=x_i,Y=y_i}=p_{i,j}\\qquad i,j=1,2,\\ldots $$ 的概率，即求事件 $$ {X=x_i|Y=y_i}\\qquad i=1,2,\\ldots $$ 的概率。由条件概率公式可得 $$ P{X=x_i|Y=y_i}=\\cfrac{P{X=x_i,Y=y_i}}{P{Y=y_i}}=\\cfrac{p_{i,j}}{\\sum\\limits_{i=1}^{\\infty}p_{i,j}}\\qquad i=1,2,\\ldots $$ 其为在$Y=y_i$的条件下随机变量$X$的==条件分布律== 类似地，称 $$ P{Y=y_i|X=x_i}=\\cfrac{P{X=x_i,Y=y_i}}{P{X=x_i}}=\\cfrac{p_{i,j}}{\\sum\\limits_{j=1}^{\\infty}p_{i,j}}\\qquad j=1,2,\\ldots $$ 为在$X=x_i$的条件下随机变量$Y$的条件分布律 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:1","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维连续型随机变量的条件概率密度 考的不多 联合密度比边缘密度 称 $$ f_{X|Y}(x|y)=\\cfrac{f(x,y)}{f_Y(y)} $$ 为在$Y=y$条件下$X$的==条件概率密度==，记为$f_{X|Y}(x|y)$ 同时称 $$ F_{X|Y}(x|y)=\\int_{-\\infty}^x\\cfrac{f(s,y)}{f_Y(y)}ds=\\int_{-\\infty}^xf_{X|Y}(x|y)dx $$ 为在$Y=y$条件下$X$的==条件分布函数==，记为$F_{X|Y}(x|y)$或$P{X\\le x|Y=y}$ 类似地，定义 $$ f_{Y|X}(y|x)=\\cfrac{f(x,y)}{f_Y(x)}\\ F_{Y|X}(y|x)=\\int_{-\\infty}^y\\cfrac{f(x,t)}{f_X(x)}dt $$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:3:2","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"随机变量的独立性 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:0","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二个随机变量独立性的概念 联合密度 = 边缘密度相乘 边缘密度 = 条件密度 设$F(x,y),F_X(x),F_Y(y)$分别为二维随机变量$(X,Y)$的联合分布函数和边缘分布函数，若对任意的$x,y$，都有 $$ F(x,y)=F_X(x)F_Y(y) \\quad即\\ P{X\\le x,Y\\le y}=P{X\\le x}P{Y\\le y} $$ ==独立的条件== 离散型：$P{X= x_i,Y= y_j}=P{X= x_i}P{Y= y_j}$ 对任意 i, j 成立 连续型：$f(x,y)=f_X(x)f_Y(y)$ 例 对于连续型随机变量$(X,Y)$，若$X$与$Y$相互独立，当且仅当 $$ f_X(x)=f_{X|Y}(x|y) \\ 或 \\ f_Y(y)=f_{Y|X}(y|x) $$ 若$(X,Y)\\sim N(\\mu_1,\\mu_2,\\sigma_1^2,\\sigma_2^2,\\rho)$，则 $$ f_X(x)=\\cfrac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-\\cfrac{(x-\\mu_1)^2}{2\\sigma_1^2}},\\quad f_X(x)=\\cfrac{1}{\\sqrt{2\\pi}\\sigma_2}e^{-\\cfrac{(x-\\mu_2)^2}{2\\sigma_2^2}} $$ 对于二维正态随机变量$(X,Y)$，相互独立的充要条件为 $\\rho=0$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:1","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"多维随机变量的独立性 $n$维随机变量$(X_1,X_2,\\ldots ,X_n)$的分布函数定义为 $$ F(x_1,x_2,\\ldots,x_n)=P{X_1\\le x_1,X_2\\le x_2,\\ldots,X_n\\le x_n} $$ 若对于所有$x_1,x_2,\\ldots,x_n$，有 $$ F(x_1,x_2,\\ldots,x_n)=F_{X_1}(x_1)F_{X_2}(x_2)\\ldots F_{X_n}(x_n) $$ 则称$X_1,X_2,\\ldots ,X_n$是相互独立的 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:4:2","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"两个随机变量的函数的分布 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:0","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维连续型随机变量的函数的分布 一般的二维连续型随机变量的函数的分布 设$(X,Y)$是二维随机变量，其概率密度为$f(x,y)$，$Z=g(X,Y)$是一个二维随机变量的函数，==则== $$ F_Z(z)=P{Z\\le z}=P{g(X,Y)\\le z}=\\iint\\limits_{D_z} f(x,y)dxdy \\ 其中D_z={(x,y)|g(x,y)\\le z} $$ 例 $Z=X+Y$的分布 设$(X,Y)$是二维随机变量，其概率密度为$f(x,y)$，则$Z=X+Y$的分布函数为 $$ F_Z(z)=\\int_{-\\infty}^z[\\int_{-\\infty}^{+\\infty}f(u-y,y)dy]du $$ 其概率密度为 $$ f_{X+Y}(z)=\\int_{-\\infty}^{+\\infty}f(z-y,y)dy=\\int_{-\\infty}^{+\\infty}f(x,z-x)dx $$ 例 $Z=\\cfrac{Y}{X},Z=XY$的分布 设$(X,Y)$是二维随机变量，其概率密度为$f(x,y)$，则$Z=\\cfrac{Y}{X}$的分布函数为 $$ f_{\\frac{Y}{X}}(z)=\\int_{-\\infty}^{+\\infty}|x|f(x,xz)dx $$ 也可以求得$Z=XY$的概率密度为 $$ f_{XY}(z)=\\int_{-\\infty}^{+\\infty}\\cfrac{1}{|x|}f(x,\\cfrac{z}{x})dx $$ $M=max{X,Y},N=min{X,Y}$ 的分布 设 $(X,Y)$ 是二维随机变量，其概率密度为 $f(x,y)$，则 $M=max{X,Y}$ 的分布函数为 $$ F_{max}(z)=F_X(z)F_Y(z) $$ $N=min{X,Y}$ 的分布函数为 $$ F_{min}(z)=1-[1-F_X(z)][1-F_Y(z)] $$ 扩展 设$X_i(i=1,2,\\ldots,n)$是$n$个相互独立的随机变量，它们的分布函数为$F_{x_i}(x)$，则$M=max{X_1,X_2,\\ldots,X_n}$和$N=min{X_1,X_2,\\ldots,X_n}$的分布函数分别为 $$ F_{max}(z)=F_{x_1}(z)F_{x_2}(z)\\ldots F_{x_n}(z) \\ \\qquad \\ F_{min}(z)=1-[1-F_{x_1}(z)][1-F_{x_2}(z)]\\ldots [1-F_{x_n}(z)] $$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:1","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"二维离散型随机变量的函数的分布 注意：若$X$和$Y$相互独立 若$X\\sim N(\\mu_1,\\sigma_1^2),Y\\sim N(\\mu_2,\\sigma_2^2)$，则$X+Y\\sim N(\\mu_1+\\mu_2,\\sigma_1^2+\\sigma_2^2)$ 若$X\\sim e(\\alpha),Y\\sim e(\\beta)$，则$min(X,Y)\\sim e(\\alpha+\\beta)$ 若$X\\sim B(n_1,p),Y\\sim B(n_2,p)$，则$Z=X+Y\\sim B(n_1+n_2,p)$ 若$X\\sim \\pi(\\lambda_1),Y\\sim \\pi(\\lambda_2)$，则$Z=X+Y\\sim \\pi(\\lambda_1+\\lambda_2)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/:5:2","tags":["概率论与数理统计"],"title":"概率论 第三章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/3.-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83/"},{"categories":["专业课"],"content":"随机变量的数字特征 定义：这些用来描述随机变量统 计特征的数字，称为随机变量的数字特征。 ​ 最常用的数字特征有：数学 期望(均值)、方差、相关系数和矩。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:0:0","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"数学期望 E(x) （Expectation） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:1:0","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"定义 设离散型随机变量$X$的分布律为$P{X=x_k}=p_k,\\quad (k=1,2,\\ldots)$，若级数$\\sum\\limits_{k=1}^\\infty x_kp_k$绝对收敛，则称级数$\\sum\\limits_{k=1}^\\infty x_kp_k$的和为$X$的数学期望（均值），记为$E(X)$； 设连续型随机变量$X$的概率密度为$f(x)$，若积分$\\int_{-\\infty}^{+\\infty}xf(x)dx$绝对收敛，则称级数$\\int_{-\\infty}^{+\\infty}xf(x)dx$的和为$X$的数学期望（==均值==），记为$E(X)$； 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:1:1","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"性质 $E(C)=C$ $E(CX)=CE(X)$ $E(X+Y)=E(X)+E(Y)$ 若$X$与$Y$相互独立，则$E(XY)=E(X)E(Y)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:1:2","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"六个常见随机变量的数学期望 （0-1）分布 $$ E(X)=p $$ 二项分布 $B(n,p)$ $$ E(X)=np $$ 泊松分布 $\\pi(\\lambda)$ $$ E(X)=\\lambda $$ 均匀分布 $U(a,b)$ $$ E(X)=\\cfrac{a+b}{2} $$ 指数分布 $e(\\lambda)$ $$ E(X)=\\cfrac{1}{\\lambda} $$ 正态分布 $N(\\mu,\\sigma^2)$ $$ E(X)=\\mu $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:1:3","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"随机变量的函数的数学期望 $X$为离散型的，$Y=g(X)$的均值 若$X$的分布律为$P{X=x_i}=p_i\\quad (i=1,2,\\ldots)$，则 $$ E(Y)=\\sum\\limits_{i=1}^\\infty g(x_i)p_i $$ $(X,Y)$为离散型的，$Z=g(X,Y)$的均值 若$(X,Y)$的分布律为$P{X=x_i,Y=y_i}=p_{i,j}\\quad (i,j=1,2,\\ldots)$，则 $$ E(Z)=\\sum\\limits_{i,j}g(x_i,y_i)p_{i,j} $$ $X$为连续型的，$Y=g(X)$的均值 若$X$的概率密度为$f_X(x)$，则 $$ E(Y)=\\int_{-\\infty}^{+\\infty}g(x)f_X(x)dx $$ $(X,Y)$为连续型的，$Z=g(X,Y)$的均值 若$(X,Y)$的概率密度为$f(x,y)$，则 $$ E(Z)=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}g(x,y)f(x,y)dxdy $$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:1:4","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"方差 D(X) (Variance) ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:2:0","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"定义 设$X$是一个对随机变量，若$E{[X-E(X)]^2}$存在，则称其为$X$的方差，记为$D(X)$或$Var(X)$ 称$\\sqrt{D(X)}$为标准差或均方差，记为$\\sigma(X)$ 认识 标准差、方差越大，离散程度越大，若$X$的取值比较集中，则方差$D(X)$较小,若$X$的取值比较分散，则方差$D(X)$较大。因此，$D(X)$是刻画$X$取值分散程度的一个量，它是衡量取值分散程度的一个尺度 ==公式== $$ D(X)=E(X^2)-[E(X)]^2 $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:2:1","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"性质 $D(C)=0$ $D(CX)=C^2D(X)$ $D(X+Y)=D(X)+D(Y)+2E{[X-E(X)][Y-E(Y)]}$ 若$X$，$Y$相互独立，则有$D(X+Y)=D(X)+D(Y)$，又有$D(X-Y)=D(X)+D(Y)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:2:2","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"常见随机变量的方差 （0-1）分布 $$ D(X)=p(1-p) $$ 二项分布 $B(n,p)$ $$ D(X)=np(1-p) $$ 泊松分布 $\\pi(\\lambda)$ $$ D(X)=\\lambda $$ 均匀分布 $U(a,b)$ $$ D(X)=\\cfrac{(b-a)^2}{12} $$ 指数分布 $e(\\lambda)$ $$ D(X)=\\cfrac{1}{\\lambda^2} $$ 正态分布 $N(\\mu,\\sigma^2)$ $$ D(X)=\\sigma^2 $$ ==随机变量参考总结== 分布名称 分布律或概率密度 数学期望 方差 （0-1）分布 $P{X=k}=p^k(1-p)^{1-k}$ $p$ $p(1-p)$ 二项分布 $B(n,p)$ $P{X=k}=C_n^kp^k(1-p)^{n-k}$ $np$ $np(1-p)$ 泊松分布 $\\pi(\\lambda)$ $P{X=k}=e^{-\\lambda}\\cfrac{\\lambda^k}{k!}$ $\\lambda$ $\\lambda$ 均匀分布 $U(a,b)$ $f(x)=\\begin{cases}\\ \\cfrac{1}{b-a}\\qquad a\u003cx\u003cb\\ \\ 0\\qquad\\qquad 其他\\end{cases}$ $\\cfrac{a+b}{2}$ $\\cfrac{(b-a)^2}{12}$ 指数分布 $e(\\lambda)$ $f(x)=\\begin{cases}\\ \\lambda e^{-\\lambda x}\\qquad x\\ge 0\\ \\ 0\\qquad\\qquad 其他\\end{cases}$ $\\cfrac{1}{\\lambda}$ $\\cfrac{1}{\\lambda^2}$ 正态分布 $N(\\mu,\\sigma^2)$ $f(x)=\\cfrac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\cfrac{(x-\\mu)^2}{2\\sigma^2}}$ $\\mu$ $\\sigma^2$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:2:3","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"协方差 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:3:0","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"定义 设$(X,Y)$为二维随机变量，若$E{[X-E(X)][Y-E(Y)]}$存在，则称其为$X$和$Y$的协方差，记为$Cov(X,Y)$ ==公式== $$ Cov(X,Y)=E(XY)-E(X)E(Y) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:3:1","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"性质 $Cov(X,X)=D(X)$ $Cov(X,Y)=Cov(Y,X)$ $Cov(aX,bY)=abCov(X,Y)$ $Cov(C,X)=0$ $Cov(X_1+X_2,Y)=Cov(X_1,Y)+Cov(X_2,Y)$ 当$X$与$Y$相互独立时，$Cov(X,Y)=0$ $D(aX+bY)=a^2D(X)+b^2D(Y)+2abCov(X,Y)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:3:2","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"相关系数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:4:0","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"定义 设$(X,Y)$为二维随机变量，$D(X)\u003e0,D(Y)\u003e0$，称 $$ \\cfrac{Cov(X,Y)}{\\sqrt{D(X)D(Y)}} $$ 为$X$和$Y$的相关系数，记为$\\rho_{XY}$。其值为0时，$X$和$Y$不相关 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:4:1","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"性质 $|\\rho_{XY}|\\le 1$ 当$X$与$Y$相互独立时，$\\rho_{XY}=0$，$X$和$Y$不相关 若$D(X)\u003e0,D(Y)\u003e0,|\\rho_{XY}|=1\\Leftrightarrow 存在常数a,b，使得P{Y=aX+b}=1$ 而且当$a\u003e0$时，$\\rho_{XY}=1$，当$a\u003c0$时，$\\rho_{XY}=-1$ ==相关系数刻画了随机变量$X$与$Y$之间”线性相关“的程度== 例 $X^*=\\cfrac{X-E(X)}{\\sqrt{D{X}}}$是对随机变量$X$的标准化，有 $$ \\rho_{XY}=Cov(X^,Y^) $$ 对于二维正态分布来说，不相关$\\Leftrightarrow$独立 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:4:2","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"不相关与独立 独立：没有任何关系 不相关：没有线性关系 $独立 \\Rightarrow 不相关 \\ 不相关 \\nRightarrow 独立$ 二维随机变量中，两者等价 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:4:3","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"矩 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:5:0","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"定义 设$X,Y$是随机变量 若$E(X^k),k=1,2,\\ldots$存在，称它为$X$的$k$阶原点矩，简称**$k$阶矩** 若$E{[X-E(X)]^k},k=2,3,\\ldots$存在，称它为$X$的**$k$阶中心矩** 若$E(X^kY^l),k,l=1,2,\\ldots$存在，称它为$X$和$Y$的**$k+l$阶混合矩** 若$E{[X-E(X)]^k[Y-E(Y)]^l},k,l=2,3,\\ldots$存在，称它为**$X$和$Y$的$k+l$阶混合中心矩** 数学期望为一阶原点矩，方差为二阶中心矩，协方差为二阶混合中心矩 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:5:1","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"协方差矩阵 设$n$维随机变量$(X_1,X_2,\\ldots,X_n)$的二阶混合中心矩$E{[X_i-E(X_i)][Y_j-E(Y_j)]}\\triangleq c_{i,j}, (i,j=1,2,\\ldots,n)$都存在，则称矩阵 $$ \\begin{pmatrix} c_{11}\u0026c_{12}\u0026\\ldots\u0026c_{1n} \\ c_{21}\u0026c_{22}\u0026\\ldots\u0026c_{nn}\\ \\vdots\u0026\\vdots\u0026\\vdots\u0026\\vdots \\ c_{n1}\u0026c_{n2}\u0026\\ldots\u0026c_{nn} \\end{pmatrix} $$ 为$n$维随机变量$(X_1,X_2,\\ldots,X_n)$的协方差矩阵 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/:5:2","tags":["概率论与数理统计"],"title":"概率论 第四章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/4.-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/"},{"categories":["专业课"],"content":"大数定律与中心极限定理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:0:0","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"大数定律 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:1:0","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"契比雪夫不等式 定理：设随机变量$X$的数学期望$E(X)=\\mu$，方差为$D(X)=\\sigma^2$，则对任意正数$\\varepsilon$，有 $$ P{|X-\\mu|\\ge\\varepsilon}\\le \\cfrac{\\sigma^2}{\\varepsilon^2} $$ 即为契比雪夫不等式(Chebyshev) 也可以写成 $$ P{|x-\\mu|\u003c\\varepsilon}\\ge 1- \\cfrac{\\sigma^2}{\\varepsilon^2} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:1:1","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"大数定律 辛钦大数定律 （弱大数定律） 设 $X_1,X_2,\\ldots$ 是相互独立，服从同分布的随机变量序列，且数学期望 $E(X_k)=\\mu(k=1,2,\\ldots)$，（方差无要求）则对任意 $\\varepsilon\u003e0$，有 $$ \\lim\\limits_{n\\rightarrow\\infty}P{|\\cfrac{1}{n}\\sum\\limits_{k=1}^{n}X_k-\\mu|\u003c\\varepsilon}=1 $$ 平均数依概率收敛于期望 伯努利大数定律 设$f_A$是$n$次独立重复试验中事件$A$发生的次数，$p$是事件$A$在每次实验中发生的概率，则对于任意的$\\varepsilon\u003e0$，有 $$ \\lim\\limits_{n\\rightarrow\\infty}P{|\\cfrac{f_A}{n}-p|\u003c\\varepsilon}=1 \\或\\ \\lim\\limits_{n\\rightarrow\\infty}P{|\\cfrac{f_A}{n}-p|\\ge\\varepsilon}=0 $$ 在$n$充分大时，随机事件”频率$\\cfrac{f_A}{n}$与$A$的概率$p$的偏差小于$\\varepsilon$“几乎是必然事件 即，==当试验次数很大时，可以用事件的频率来代替事件的概率== 依概率收敛 设$Y_1,Y_2,\\ldots$是一个随机变量序列，$a$是一个常数，若对任意$\\epsilon\u003e0$，都有 $$ \\lim\\limits_{n\\rightarrow\\infty}P{|Y_n-a|\u003c\\epsilon}=1 $$ 则称$Y_1,Y_2,\\ldots$依概率收敛于$a$X_n\\stackrel{P}\\rightarrow a$ 辛钦大数定理有，$\\overline{X}=\\cfrac{1}{n}\\sum\\limits_{k=1}^{n}X_k\\stackrel{P}\\rightarrow\\mu$ 伯努利大数定理有，随机事件发生的频率依概率收敛于概率 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:1:2","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"中心极限定理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:2:0","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"独立同分布的中心极限定理 现象由大量相互独立的因素所影响 大量独立同分布的变量之和的极限分布是正态分布 设$X_1,X_2,\\ldots$是相互独立，服从同分布的随机变量序列，且数学期望$E(X_k)=\\mu,D(X_k)=\\sigma^2$，则随机变量$\\sum\\limits_{k=1}^n X_k$的标准化变量 $$ Y_n=\\cfrac{\\sum\\limits_{k=1}^{n}X_k-n\\mu}{\\sqrt{n}\\sigma} $$ 的分布函数$F_n(x)$对于任意$x$，有 $$ \\lim\\limits_{n\\rightarrow\\infty}F_n(x)=\\int_{-\\infty}^x\\cfrac{1}{\\sqrt{2\\pi}}e^{-\\frac{t^2}{2}}dt=\\Phi(x) $$ 推论：当$x$充分大时，有 $$ \\cfrac{\\sum\\limits_{k=1}^{n}X_k-n\\mu}{\\sqrt{n}\\sigma}\\stackrel{近似地}\\sim N(0,1) \\或\\ \\sum\\limits_{k=1}^n \\stackrel{近似地}\\sim N(n\\mu,n\\sigma^2) $$ 令$\\overline{X}=\\cfrac{\\sum\\limits_{k=1}^nX_n}{n}$，则 $$ \\cfrac{\\overline{X}-\\mu}{\\sigma/\\sqrt{n}}\\stackrel{近似地}\\sim N(0,1) \\或\\ \\overline{X}\\stackrel{近似地}\\sim N(\\mu,\\sigma^2/n) $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:2:1","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"棣莫弗-拉普拉斯定理 (De Moivre-Laplace) 设随机变量$\\eta_n \\ (n=1,2,\\ldots)$服从$n,p$的二项分布，则对于任意$x$，有 $$ \\lim\\limits_{n\\rightarrow\\infty}P{\\cfrac{\\eta_n-np}{\\sqrt{np(1-p)}}\\le x}=\\int_{-\\infty}^x\\cfrac{1}{\\sqrt{2\\pi}}e^{-t^2/2}dt=\\Phi(x) $$ 推论：若$X\\sim B(n,p)$，当$n$充分大时， $$ X\\stackrel{近似地}\\sim N(np,np(1-p)) $$ 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/:2:2","tags":["概率论与数理统计"],"title":"概率论 第五章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/5.-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E4%B8%8E%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/"},{"categories":["专业课"],"content":"概念 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:0:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"随机试验 特性 可重复性：可在相同条件下重复进行 可观察性：可能结果不止一个，并且能事先知道所有可能结果 不确定性：结果无法事先预知 符号：$E$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:1:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"样本空间 定义：样本点的集合，记作 $S$ 情况：有限个，可列个（可以排列成一个数列），不可列 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:2:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"随机事件 定义：试验 $E$ 的样本空间 $S$ 的子集称为 $E$ 的随机事件，简称事件 若一次事件的结果出现在某一随机事件中，则称该事件发生了 特殊事件 基本事件：由一个样本点组成的单点集 必然事件：样本空间 $S$ 本身 不可能事件：空集 $\\emptyset$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:3:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"事件运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:4:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"运算符 包含：$A\\subset B$ A 的发生必然导致 B 的发生 相等：$A=B$ 和事件：$A\\cup B$ A 和 B 至少有一个发生 积事件：$A\\cap B$ 或 $AB$ A和B同时发生 差事件：$A-B$ A发生而B不发生 不相容事件：$AB=\\emptyset$ A和B不能同时发生 逆事件（对立事件）：$\\overline{A}=B$ 或 $\\overline{B}=A$ 满足条件 $A\\cup B=S,AB=\\emptyset$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:4:1","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"推广 $\\bigcup\\limits_{i=1}^{n} A_i$ n 个事件至少有一个发生 $\\bigcup\\limits_{i=1}^{\\infty} A_i$ 无穷个事件至少有一个发生 $\\bigcap\\limits_{i=1}^{n} A_i$ n 个事件同时发生 $\\bigcap\\limits_{i=1}^{\\infty} A_i$ 无穷个事件同时发生 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:4:2","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"定律 交换律、结合律、分配律 德摩根定律（对偶律）：$\\overline{A \\cup B}=\\overline{A}\\cap \\overline{B}\\ \\overline{\\bigcup\\limits_{i=1}^{n} A_i}=\\overline{A_1}\\cap \\overline{A_2}\\ldots\\cap \\overline{A_n} \\ \\overline{\\bigcap\\limits_{i=1}^{n} A_i}=\\overline{A_1}\\cup \\overline{A_2}\\ldots\\cup \\overline{A_n}$ ==$A-B=A-AB=A\\overline B$== ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:4:3","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"频率 定义 频数：n 次实验中事件 A 发生的次数，记为 $n_A$ 频率：比值 $n_A / n$，记为 $R_{n}(A)$ 性质 $0\\leq R_{n}(A) \\leq 1$ $R_{n}(S)=1$ 对于互不相容的事件，$R_n(A_1\\cup A_2\\cup\\ldots\\cup A_k)=R_n(A_1)+R_n(A_2)+\\ldots+R_n(A_k)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:5:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"概率 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:6:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"定义 有随机试验$E$，它的样本空间$S$。对于$E$的每一个事件$A$赋予一个实数（集合函数），记为$P(A)$，称之为概率 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:6:1","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"满足条件 非负性：对于每个事件$A$，有$P(A)\\geq 0$ 完备性：对于必然事件，有$P(S)= 1$ 可列可加性 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:6:2","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"性质 $P(\\empty)=0$ $P(A)\\leq 1$ $P(\\overline A)=1-P(A)$ ==$P(A-B)=P(A)-P(AB)$== 若$B \\subset A$，有$P(A-B)=P(A)-P(B)$ （有限可加性）对于互不相容的事件，$P(A_1\\cup A_2\\cup\\ldots\\cup A_n)=\\sum\\limits_{i-1}^{n}P(A_i)$ ==（加法公式）$P(A\\cup B)=P(A)+P(B)-P(AB)$== ==$P(A)=0\\nRightarrow A=\\empty$== ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:6:3","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"概型 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:7:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"古典概型 定义：样本点有限；每一个基本事件发生的概率等可能 概率计算公式 $$ P(A)=\\frac{事件A中所含的样本点数}{样本空间S中所含样本点数} $$ 例 100个产品中有4个次品，从中抽12个，求恰好有2个次品的概率 $$ \\frac{C_4^2C_{96}^{10}}{C_{100}^{12}} $$ 袋中a白球b红球，k人作无放回抽取，求第i个人取到 白球的概率 $$ \\frac{a\\cdot A_{a+b-1}^{k-1}}{A_{a+b}^k}=\\frac{a}{a+b} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:7:1","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"几何概型 定义：样本空间为一个区间、平面区域、或空间立体的等可能随机试验的概率模型 概率计算公式（$\\mu$表示区间、平面区域或空间立体的长度、面积或体积） $$ p(A)=\\frac{\\mu(A)}{\\mu(B)} $$ 例 甲乙相约7-8点见面，先到者最多等20分钟，过时离开，求两者会面概率 $$ S={(x,y)\\mid0\\le x\\le 60,0\\le y\\le 60} \\ A={(x,y)\\mid(x,y)\\in S,|x-y|\\le 20} \\ 画图，求面积比 $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:7:2","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"条件概率 事件A已发生的条件下，B发生的概率，记作$P(B| A)$ ==公式：$P(B | A)=\\cfrac{P(AB)}{P(A)}$== ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:8:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"划分的概念 满足： ​ 1. $A_1, A_2,\\ldots,A_n$互不相容 ​ 2. $A_1\\cup A_2\\cup\\ldots\\cup A_n=S$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:8:1","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"定律 （加法公式）$P(B_1\\cup B_2|A)=P(B_1|A)+P(B_2|A)-P(B_1 B_2|A)$ ==（乘法公式）$P(AB)=P(B|A)P(A)$== ​ 推广：$P(A_1 A_2 \\ldots A_n)=P(A_1)P(A_2|A_1)P(A_3|A_2 A_1)\\ldots P(A_n|A_{n-1}\\ldots A_2 A_1)$ ==（全概率公式）==若$A_1, A_2,\\ldots,A_n$是样本空间$S$的划分，$B$为任意一个事件 $$ P(B)=\\sum\\limits_{i=1}^{n}P(B|A_i)P(A_i) $$ ==（贝叶斯公式）== $$ P(A_i|B)=\\frac{P(B|A_i)P(A_i)}{\\sum\\limits_{k=1}^{n}P(B|A_k)P(A_k)} $$ 取$n=2$，将$A_1$记为$A$，此时$A_2$就是$\\overline A$。 ​ （全概率公式） $$ P(B)=P(B|A)P(A)+P(B|\\overline A)P(\\overline A) $$ ​ （贝叶斯公式） $$ P(A|B)=\\cfrac{P(B|A)P(A)}{P(B|A)P(A)+P(B|\\overline A)P(\\overline A)} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:8:2","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"独立性 互不相容与独立没有必然联系 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:9:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"概念 若$P(B|A)=P(B)$，意味着$A$的发生不影响$B$的发生 若 $$ P(AB)=P(A)P(B) $$ 则$A$，$B$两事件独立 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:9:1","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"定理 设$P(B)\u003e0$，若$A, B$独立，则$P(A|B)=P(A|\\overline B)=P(A)$ 若$A, B$独立，则$A$与$\\overline B$，$\\overline A$与$B$，$\\overline A$与$\\overline B$也独立 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:9:2","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"推广 有$A_1, A_2,\\ldots,A_n$，如果对于其中任意2个，3个，…，n个事件的积事件的概率都等于各事件概率之积，则$A_1, A_2,\\ldots,A_n$相互独立 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:9:3","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"n重贝努利试验 若在随机试验$E$中，只关注随机试验$A$即$\\overline A$的发生，则称$E$为一个贝努利试验，独立地重复n次即为n重贝努利试验 设$P(A)=p$，则事件$A$出现了$k$次的概率为 $$ P=C_{n}^{k}\\cdot p^k(1-p)^{n-k} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:9:4","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"贝叶斯详述 $$ P(H|E)=\\frac{P(H)P(E|H)}{P(E)} $$ H：Hypothesis，假设 E：Evidence，证据 比例角度 分母：符合特征的概率 分子：符合特征同时又符合假设的概率，通常是——符合假设的概率 × 符合假设之中符合特征的概率 新增的信息对假设类别与非假设类别产生的影响不同 若影响相同，则引入的证据是无关特征 我们容易根据似然概率得出看法，天然的将$P(H|E)$ 与 $P(E|H)$视作相同，其实是没有考虑到先验概率带来的影响 假设应该建立在先验概率上，不过先验概率基于个人的经验，必然存在偏差 $P(H)$：先验概率 $P(H|E)$：Posterior，后验概率，将证据考虑之后的概率 $P(E|H)$：Likelihoods，似然概率，在假设成立的情况下，符合证据特征的概率；伴随新增信息带来的可能性 $P(E)$：The total probability of seeing the evidence，通常用全概率公式展开 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/:10:0","tags":["概率论与数理统计"],"title":"概率论 第一章","uri":"/Notes/posts/courses/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/1.-%E6%A6%82%E5%BF%B5/"},{"categories":["专业课"],"content":"物理层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:0:0","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"物理层的基本概念 物理层考虑的是怎样才能在连接计算机的各种传输媒体上传输数据比特流，而不是指具体的传输媒体。 物理层的作用是要尽可能地屏蔽掉不同传输媒体和通信手段的差异 ，使数据链路层感觉不到这些差异。 用于物理层的协议也常称为物理层规程（procedure） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:1:0","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"主要任务 确定与传输媒体接口的一些特性 机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等。 电气特性：指明在接口电缆的各条线上出现的电压的范围。 功能特性：指明某条线上出现的某一电平的电压表示何种意义。 过程特性：指明对于不同功能的各种可能事件的出现顺序。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:1:1","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"数据通信的基础知识 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:2:0","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"数据通信系统的模型 组成 源系统 源点（信源）：源点设备产生要传输的数据，例如计算机键盘输入汉字通过计算机产生输出的数字比特流。 发送器：数字比特流要经过发送器编码后才能在传输系统中传输。例如：调制器 传输系统 传输系统可以是传输线，也可以是复杂的网络系统。 目的系统 终点（信宿）：终点设备将数字比特流转换成信息输出，例如把汉字显示在屏幕上。 接收器：接收器把来自传输线路上的模拟信号进行解调，还原出数字比特流。例如：解调器 术语 数据 (data)：运送消息（话音、文字、图像等）的实体。 信号 (signal)：数据的电气的或电磁的表现 。 数据 在信道中以电信号的形式传送，电信号分为：模拟信号和数字信号。 模拟信号 (analogous)：代表消息的参数的取值是连续的 数字信号 (digital signal)：代表消息的参数的取值是离散的。 码元 (code)：在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。 使用二进制编码时，只有两种不同的码元（代表 0 和 1） 调制：把数字信号转换为模拟信号的过程 。 解调：把模拟信号转换为数字信号的过程。 模拟信号与数字信号 模拟数据、模拟信号 最早的电话系统 模拟数据、数字信号 模拟数据数字化后，可以使用先进的数字传输和交换设备，如现代的电话系统。 数字数据、模拟信号 有些传输媒体只适合传输模拟信号，如光纤和无线信道。 数字数据、数字信号 数字数据编码成数字信号的设备，比起数字到模拟设备更简单、更廉价。 信道 信道 ( channel )：一般用来表示向某一个方向传送信息的媒体。一条通信电路往往包含发送信道和接收信道。 信道类型 单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互。例：无线电广播 双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送，当然也就不能同时接收 。 双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息。 在计算机提供的二进制数字信号与电话网提供的模拟信号之间进行转换，这类技术统称为调制解调技术。 基带信号 （即基本频带信号）：来自信源的信号，就是将数字信号 1 或 0 直接用两种不同的电压来表示，然后送到线路上去传输基带信号 计算机输出的信号通常为基带信号 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进调行调制（modulation） 调制类型 基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码(coding） 带通调制：使用载波 (carrier) 进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。 带通信号：经过载波调制后的信号。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:2:1","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"数字信号编码 基带调制技术（从数字到数字信号） 常用编码方式 不归零码：正电平代表 1，负电平代表 0 。 在一个码元的全部时间内，电压保持恒定 频率低 连续发送多个“ 1” 码或“ 0” 码时，码元之间没有间隙，不容易区分 归零码：正脉冲代表 1，负脉冲代表 0，有跳变 在一个码元的全部时间内，非零电压的持续时间小于一个码元的时间 在一个码元的后半部分时间内，电压总是归于零的 好处：解决了不归零码在连续发送“ 1” 码或“ 0” 码不容易区分的问题 缺点：跳变次数过多，携带的数据量相对较少 曼彻斯特编码 位周期中心的向上跳变代表 0 ，位周期中心的向下跳变代表 1 也可反过来定义。 差分曼彻斯特编码 在每一位的中心处始终都有跳变。 利用每个码元的开始时有无跳变来表示“ 0” 或“ 1” 。 位开始边界有跳变代表 0 ，没有跳变代表 1 编码方式比较 从信号波形中可以看出，曼彻斯特编码和差分曼彻斯特编码产生的信号频率比不归零制高。 从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率，这叫作没有自同步能力， 而曼彻斯特编码和差分曼彻斯特编码 具有自同步能力 。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:2:2","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"数字调制技术 带通调制方法（数字信号到模拟信号） 二元制调制方法 选取一个适合于在线路上传输的正弦波作为载波，让载波的某些特性（ 幅度、频率、相位随基带信号的变化而变化（即波形变换）。 最基本的二元制调制方法有以下几种： 1. 调幅 (AM) 载波的 振幅 随基带数字信号而变化。 实现起来简单 , 但抗干扰性能差 极端情况：0 不波动，1 波动 2. 调频 (FM) 载波的 频率 随基带数字信号而变化。 抗干扰性能好 , 但占用带宽较大 3. 调相 (PM) 载波的 初始相位 随基带数字信号而变化。 抗干扰性能最好，且相位的变化也可以同步发送器和接收器的时钟 绝对 PM 与相对 PM 用载波的相位绝对值或变化来表示数据。 绝对调相： 0 对应相位 “0”，1 对应相位 “180” 。 相对调相：发送的信号与前一个信号同相（相位不发生变化），则表示 “0”；发送的信号与前一个信号反相（相位发生变化），则表示 “1” 。（0 则一致，1 则反相） 注意：检测相位变化比检测相位值要容易。 多元制混合调制方法 上面几种调制方式，一个码元仅包含 2 个状态（两种振幅、频率、相位），即 1 个码元携带 1bit 信息 多元制混合调制方法可以获得更高的信息传输速率，让 1 个码元携带多位比特信息 正交振幅调制（QAM） (Quadrature Amplitude Modulation） 例如： 可供选择的相位有 12 种，而对于每一种相位有 1 或 2 种振幅可供选择。总共有 16 种组合，即 16 个码元。 由于 4bit 编码共有 16 种不同的组合，因此这 16 个点中的每个点可对应于一种 4 bit 的编码。数据传输率可提高 4 倍 注意：不是码元越多越好。若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加 脉冲编码调制（PCM） (Pulse Code Modulation) 话音、图像等模拟信号在时间上和取值上都是连续的，对其进行数字信号编码 ，是将其转换成一系列在时间和取值上都是离散的 二进制数码脉冲。最常用的编码方法就是 PCM 现在的数字传输系统均采用脉码调制 PCM 体制 。 PCM 包括三个主要步骤（将模拟信号转换为数字信号的过程）：采样 -\u003e 量化 -\u003e 编码 采样 实现时间上的离散化 每隔一定时间间隔 , 取模拟信号的当前值作为样本，该样本代表了模拟信号在某一时刻的瞬时值 采样频率需远高于信号频率 采样的依据：奈奎斯特 (Nyquist) 采样定理 量化 是使采样值在取值上离散化 抽样信号虽然是时间轴上离散的信号，但仍然是模拟信号，其取值是连续值, 必须量化为离散值。 具体做法是：将原始信号的取值范围划分为若干个等级，将每个采样值“取整”到离它最近的一个等级上 量化后的抽样信号与量化前的抽样信号相比较，当然有所失真，表现为噪声 离散值的个数（等级划分）决定了量化的精度。 我国电话信号的 PCM 体制中，量化等级为 256，即 8 位。 编码 将量化后的采样值用一定位数的二进制数码来表示 编码的位数和量化的级数有关，若量化级数为 N ，则每个采样值就可以编码成 Log 2 N 为的二进制码。 我国的 PCM 体制的编码位数为 8 ，即每个脉冲信号编码为 8bit 信息，由于每秒 8000 个脉冲，话音的标准编码速率为 64Kb/s 。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:2:3","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"通信的极限容量 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输速率越高，或信号传输距离越远，或噪声干扰越大，或传输媒体质量越差在信道的输出端的波形的失真就越严重。 限制码元在信道上的传输速率的因素有以下两个 信道能够通过的频率范围 信噪比 信道能够通过的频率范围 具体的信道所能通过的频率范围（信道的带宽 Hz ）总是有限的。信号中的许多高频分量往往不能通过信道 理想低通信道 ：信号的所有低频分量，只要频率不超过某个上限，都能够不失真地通过信道。 理想带通信道 ：信号的频率在某个范围之间的频率分量能够不失真地通过信道，其它分量不能通过。 奈氏（Nyquist）准则 奈奎斯特给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。 理想低通信道的最高码元传输速率 = 2W Baud W 是理想低通信道的带宽，单位为赫 (Hz) 公式含义：每赫带宽的理想低通信道的最高码元传输速率是每秒 2W 个码元 Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元 （即，码元 / 秒） 理想带通特性信道的最高码元传输速率 = W Baud（基本不考） 结论 在任何信道中，码元传输的速率是有上限的， 否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。 比特率与波特率（重要） 比特率 S：数据传输速率，单位 “比特 / 秒” 波特率 B：码元传输速率，单位 “码元 / 秒” 若码元的状态数为 2 时，比特率 = 波特率（即每秒钟传输的二进制位数等于每秒钟传输码元数） 若码元的状态数为 4 时，四种状态分别表示为 “00” ”01” “10” ”11” 。则一个码元可以携带两位二进制数，此时比特率 = 2 * 波特率。 若 1 个码元携带 n bit 的信息量， M Baud 的码元传输速率所对应的信息传输速率为 M × n b/s 公式 $$ S=B*log_2M $$ 信噪比 噪声存在于所有的电子设备和通信信道中。 噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误 。 但噪声的影响是相对的 。 如果信号相对较强，那么噪声的影响就相对较小。 信噪比公式 信噪比就是信号的平均功率和噪声的平均功率之比 。常记为 S / N ，并用 分贝 (dB) 作为度量单位。即： $$ 信噪比 \\ (dB) = 10 \\log_{10}(S/N) \\ (dB) $$ 例如，当 S / N = 10 时，信噪比为 10dB ，而当 S / N = 1000 时，信噪比为 30dB 。 香农公式 信道的极限信息传输速率 C 可表达为 $$ C=W\\log_2(1+S/N) \\ (bits/s) $$ 其中 W 为信道的带宽 ，以 Hz 为单位 S 为信道内所传信号的平均功率； N 为信道内部的高斯噪声功率。 S/N 不带单位！ 结论 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是： 用编码的方法让每一个码元携带更多比特的信息量。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:2:4","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"物理层下面的传输媒体 传输媒体也称为传输介质或传输媒介， 它就是数据传输系统中在发送器和接收器之间的物理通路 。 传输媒体可分为两大类 导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播 。 非导引型传输媒体：自由空间中传播，电磁波的传输常称为无线传输。 频谱 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:3:0","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"导引型传输媒体 双绞线 古老但最常用的传输媒体 。 电话系统使用的就是双绞线。 绞合可减少对相邻双绞线的电磁干扰。 模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。 带宽依赖于线的粗细和传输距离 分类 屏蔽双绞线 STP (Shielded Twisted Pair)：带金属屏蔽层 无屏蔽双绞线 UTP (Unshielded Twisted Pair) 标准 EIA/TIA 568 A 。 此标准规定了 5 个种类的 UTP 标准 （从 1 类线到 5 类线）。 对传送数据来说，现在最常用的 UTP 是 5 类线（Category 5 或 CAT5） 同轴电缆 同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据 。 同轴电缆的带宽取决于电缆的质量 分类 基带同轴电缆 局域网发展初期常用 宽带同轴电缆 有线电视常用 光缆 光纤是光纤通信的传输媒体。 光纤 由非常透明的石英玻璃拉成细丝，主要由纤芯和薄层构成双层通信圆柱体，纤芯很细直径只有 8 至 100um ，纤芯和包层具有不同的折射系数。 由于可见光的频率非常高，约为 10 8 MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽 工作原理 光线在纤芯中传输的方式是不断地全反射 只要从纤芯中射到纤芯表面的光线的入射角大于某个临界角度，就可产生全反射 。 分类 多模光纤 可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤 传输中光脉冲会逐渐展宽，造成失真，适合短距离传输 单模光纤 若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤 使用昂贵的半导体激光源，光脉冲的衰耗小，适合长距离传输 优点 通信容量非常大 。 传输损耗小，中继距离长。 抗雷电和电磁干扰性能好。 无串音干扰，保密性好。 体积小，重量轻。 光纤通信中使用的光波的波段 常用的三个波段的中心分别位于 850 nm （多模）1300 nm（多模和单模）和 1550 nm（单模）。 所有这三个波段都具有 25000~30000 GHz 的带宽， 可见光纤的通信容量非常大 。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:3:1","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"非引导型传输媒体 将自由空间称为“非导引型传输媒体”。 无线传输所使用的频段很广。 分类 短波通信 （即高频通信） 主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。 微波通信 由于地球表面的弯曲，信号的直线传输有限，需要建微波中继站。 地面微波接力通信 卫星通信 无线局域网使用的 ISM 频段 要使用某一段无线电频谱进行通信，通常必须得到本国政府有关无线电频谱管理机构的许可证。但是，也有一些无线电频段是可自由使用的，正好满足计算机 无线局域网 的需求。例如： ISM（工业、科学、医学）频段。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:3:2","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"信道复用技术 复用 (multiplexing) 是将多路信号组合在一条物理信道上进行传输，在接收端再将各路信号分离开来，提高通信线路的利用率。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:4:0","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"频分复用 FDM (Frequency Division Multiplexing) 将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源 （请注意，这里的“带宽”是频率带宽而不是数据的发送速率） 例：ADSL 技术 （非对称数字用户线路） 利用现有电话线 实际带宽 1.1 MHz) 实现宽带网络连接 非对称（Asymmetric）的含义：下行速率大于上行 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:4:1","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"时分复用 TDM (Time Division Multiplexing) 时分复用的所有用户是在不同的时间占用同样的频带宽度。 用户轮流使用 同步 TDM （普通 TDM） 是将时间划分为一段段等长的时分复用帧（TDM 帧），每个用户占用的时隙周期性出现。 即：信号源与时隙序号固定，即同步 。 时间片的分配事先约定，且固定不变。 优点：控制简单，接收设备根据预约的时间片分配方案，将收到的数据分发到不同的输出线路上。 缺点：当某个信号源没有数据时，仍然占用时间片，不能充分利用信道。 造成线路资源的浪费 异步 TDM （统计时分复用 STDM） 时间片按需分配，需要发送数据的信号源提出申请，才能获得时间片。 即：公共信道的时隙实行 “按需分配”，对那些需要传送信息或正在工作的终端（信号源）才分配时隙，可以使得所有时隙都能够饱满地得到使用，可以使得服务的终端数大于时隙的个数，提高信道的利用率 特点：可以充分利用信道，但控制比较复杂 。 例 电话系统中为了有效地利用传输线路，可将多个话路的 PCM 信号用时分复用 TDM (Time Division Multiplexing) 的方法装成时分复用帧，然后发送到线路上。 北美体制： 用于北美和日本的电话系统 T1 信号（1.544 Mbps） 欧洲体制： 我国电信部门使用的 E1 传输系统（2.048 Mbps） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:4:2","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"波分复用 （Wavelength Division Multiplexing） 同 FDM 类似，主要用于光纤通信中； 波分复用就是光的频分复用 。 不同的信号源使用不同频率（波长）的光波来传输数据，各路光经过一个棱镜（或衍射光栅），合成一个光束在光纤上传输；在接收端再将各路光波分开。 密集波分复用 DWDM（Dense WDM ）：技术的发展一根光纤上复用的光载波信息路数越来越多，例如 80 或更多路数。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:4:3","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"码分复用 （Code Division Multiplexing） 常用的名词是码分多址 CDMA (Code Division Multiple Access) 每个用户在同样的时间使用同样的频带 进行通信。 各用户使用经过特殊挑选的不同码型 ，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 特别在无线局域网中，采用 CDMA 可提高话音质量、数据传输可靠性、增大通信系统容量（是 GSM 的 4、5倍），降低手机的平均发射功率。 码片序列 （chip sequence） 每一个比特时间划分为 m 个短的间隔，称为码片（chip）。设 m = 8 每个站被指派一个唯一 的 m bit 码片序列 。 如发送比特 1，则发送自己的 m bit 码片序列。 如发送比特 0，则发送该码片序列的二进制反码 。 例如： S 站的 8 bit 码片序列是 00011011 发送比特 1 时，就发送序列 00011011 发送比特 0 时，就发送序列 11100100 按惯例， 0 写成 - 1，1 写成 +1， S 站的码片序列：（ - 1 - 1- 1 + 1 + 1 - 1 + 1 + 1 ） 码片序列实现了扩频 假定 S 站要发送信息的数据率为 b bit/s 。由于每一个比特要转换成 m 个比特的码片，因此 S 站实际上发送的数据率提高到 mb bit/s ，同时 S 站所占用的频带宽度也提高到原来数值的 m 倍。 这种通信方式是扩频 (spread) 通信 CDMA 的一个重要特性 每个站分配的码片序列不仅必须各不相同， 并且还必须互相正交 (orthogonal) 。 在实用的系统中是使用 伪随机码序列。 令向量 S 表示站 S 的码片向量，令 T 表示其他任何站的码片向量。 两个不同站的码片序列正交，就是向量 S 和 T 的规格化内积 (inner product) 等于 0 $$ S*T\\equiv\\frac{1}{m}\\sum_{i=1}^{m}S_iT_i=0 $$ 码片序列的正交关系举例 向量 S 为 ( - 1 - 1 - 1 + 1 + 1 - 1 + 1 + 1 )，向量 T 为 ( - 1 - 1 + 1 - 1 + 1 + 1 + 1 - 1 ) 。 把向量 S 和 T 的各分量值代入公式就可看出这两个码片序列是正交的。 向量 S 和 T 的码片反码的向量内积也是 0 正交关系的另一个重要特性 任何一个码片向量和该码片向量自己的规格化内积都是 1 一个码片向量和该码片反码的向量的规格化内积值是 -1 CDMA 工作原理 每个站各自发送扩频信号，在接收端形成叠加的信号。 当接收站打算接收 S 站的信号时，就用 S 站的码片序列与收到的叠加信号求规格化内积： 若 S 站有信号发送 ，则内积结果为 1 ( 发送数据 1 ) 或 - 1 ( 发送数据 0 ) 若 S 站没有信号发送 ，则内积结果为 0 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/:4:4","tags":["计算机网络"],"title":"计算机网络 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/2.-%E7%89%A9%E7%90%86%E5%B1%82/"},{"categories":["专业课"],"content":"数据链路层 在此层要解决的问题：封装成帧、透明传输、差错控制（检错、纠错） 点对点信道 这种信道使用一对一的点对点通信方式（ PPP 协议 ） 广播信道。 这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 CSMA/CD 协议 为了分析链路层协议，采用简化的链路层模型 数据链路层以上的各层用一个主机代替； 物理层和通信线路等效成一条简单数据链路； ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:0:0","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"使用点对点信道的数据链路层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:0","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"数据链路和帧 链路 (link) 是一条无源的结点到相邻结点的物理线路（有线或无线），中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路 (data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现在最常用的方法是使用 网络适配器（即网卡） 来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 数据链路层的基本概念 也有人采用另外的术语。这就是把链路分为物理链路和逻辑链路。 物理链路 就是上面所说的链路 。 逻辑链路 就是上面的数据链路，是物理链路加上必要的通信协议。 早期的数据通信协议曾叫做通信规程 (procedure) 。因此在数据链路层，规程和协议是同义语。 数据链路层的协议数据单元 - 帧 常常在两个对等的数据链路层之间画出一个数字管道，而在这条数字管道上传输的数据单位是帧 数据链路层不必考虑物理层如何实现比特传输的细节。 甚至还可以更简单地设想好像是沿着两个数据链路层之间的水平方向把帧直接发送到对方 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:1","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"三个基本问题 封装成帧 （framing） 定义 在一段数据的前后分别添加首部和尾部然后就构成了一个帧。使接收方能确定帧的界限。换句话说，首部和尾部的一个重要作用就是进行帧定界 字节计数法 思想 在帧头设置一个长度域，放置该帧的字节数，当收方收到帧后，通过帧的长度，确定帧的开始。 问题 当帧的长度域出错，帧同步完全丢失； 该方法很少单独使用。 字符填充法 当数据是由可打印的 ASCII 码组成的文本文件时，帧定界可以使用特殊的 ASCII 码 不可打印的控制字符 作为 帧定界符。 控制字符 SOH (Start Of Header) 放在一帧的最前面表示帧的首部开始 。 另一个控制字符 EOT (End Of Transmission) 表示帧的结束 。 比特填充法 思想 使用一个特殊的比特模式 01111110 作为帧的起始和结束标志。 发送方边发送边检查数据，每连续发送 5 个“ 1” 后在后面自动插入一个“ 0” 。这样数据中只会连续出现 5个“ 1”，而不会出现定界符。 接收方在收到 5 个连续的 “1” 后将后面的 “0” 删掉而恢复出原始数据。 好处 数据传输的基本单位是比特而不是字符，可用来传输任意长度的二进制比特串，通用性强。 违法编码法 前提 物理介质上使用的信号编码有冗余码字时，使用这些冗余的码字来作为帧的定界。 举例 如曼彻斯特编码或差分曼彻斯特编码中，有效电平是 “低－高” 或 “高－低”，而 “低－低” 和 “高－高” 电平没有定义，这种违法编码可以作为帧的边界。 透明传输 若所传的数据的比特片段与某一个控制信息相同，要有可靠机制，保证收方能正确识别 如果数据中的某个字节的二进制代码恰好和 SOH 或 EOT 一样，数据链路层就会错误地“找到帧的边界” 解决方法 发送端的数据链路层在数据中出现控制字符 “SOH” 或 “EOT” 的前面 插入一个转义字符 “ESC” （其十六进制编码是 1B) 。 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC 。当接收端收到连续的两个转义字符时，就删除其中前面的一个。 对应字节填充法 差错控制 纠错：通过编码技术，接收方自动将差错改正过来 检错：检测出帧有错误，要么忽略或重传 在传输过程中可能会产生比特差错： 1 可能会变成 0 而 0 也可能变成 1 。 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate) 例如误码率 10^-10^ ，表示 10^10^ 个比特就会出现 1 个比特的差错 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种差错控制措施。 考虑怎样发现和纠正信号传输中的差错。 方法 如何发现差错？ 检错码（奇偶校验码、 CRC）：能检测出错误，但不能纠正错误 纠错码（海明码）：能知道错误，且知道错误的位置 发现差错如何处理？ 前向纠错：由接收方来检查并纠正错误 自动重发请求：不能纠正，接收方反馈。若有错误则重发，否则给肯定应答 前向纠错 （FEC Forward Error Correct） 即发送方发送能使接收方检错并纠错的冗余位，纠错任务由接收方完成；常采用海明码 主要应用于没有反向信道或反向传输时间很长的场合 缺点：为纠错附加的冗余码较多，传输效率低； 优点：实时性好。 自动重发请求 （ARQ Automatic Repeat reQuest） 即发送方发送能使接收方检错的冗余位，若无差错，则接收方回送一个肯定应答 (ACK)；若有差错，则接收方回送一个否定应答 (NAK)，要求发送方重发。 缺点：信息传递连贯性差 优点：接收端设备简单，只要请求重发，无需纠正错误。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:2","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"检错码 构造 检错码 (码字、传输帧) = 信息位＋冗余校验位 码字长 n = K (信息位位数) + r (校验位位数) 编码效率 R = 有效数据位 K / 码字长 n 信息字段和校验字段之间的对应关系 校验字段越长，编码的检错能力越强，编码解码越复杂；附加的冗余信息在整个编码中所占的比例越大，传输的有效成分越低，传输的效率下降。 检错码一旦形成，整个检错码将作为一个整体被发往线路，通常的发送顺序是信息字段在前，校验字段在后。 奇偶校验码 根据数据字节中 1 的个数来检验数据传输中是否发生了错误。 奇校验：使码字中 1 的总个数为奇数 。 偶校验：使码字中 1 的总个数为偶数 。 奇 / 偶校验码：最常用的一种检验码，包括： 水平奇 / 偶校验码 垂直奇 / 偶校验码 水平垂直奇 / 偶校验码 水平奇 / 偶校验码 其信息字段以字符为单位，校验字段仅含一个比特称为校验比特或校验位。 例如：使用七比特的 ASCII 码来构造成八比特的检错码时若采用奇 / 偶校验，校验位的取值应使整个码字包括校验位， 1 的比特个数为奇数或偶数。 信息字段 奇校验码 偶校验码 1000001 10000011 10000010 编码效率： Q / (Q+1) ( 信息字段占 Q 个比特 ) 应用： 通常在异步传输方式中采用偶校验， 同步传输方式中采取奇校验。 垂直奇 / 偶校验码 被传输的信息进行分组，并排列为若干行和若干列。组中每行的相同列进行奇 / 偶校验，最终产生由校验位形成的校验字符 (校验行)，并附加在信息分组之后传输 举例： 4 个字符（ 4 行）组成一信息组 编码效率： PQ / P(Q+1) （假设信息分组占 Q 行 P 列） 水平垂直奇 / 偶校验 也叫方阵校验 在水平校验的基础上实施垂直校验。 例： 4 行 7 列信息组的水平垂直偶校验码为： 循环冗余码 （Cyclic Redundancy Check CRC） 计算机和数据通信中使用最广泛的检错码 ，漏检率低，可用简单的电路实现。 操作 给定一个 k 比特的帧或报文，发送方生成 n 比特的序列（也称为帧检验序列 FCS Frame Check Sequence ），形成 ( k+n ) 的码字，该码字能被某个事先确定的数整除。接收方用相同的数去除收到的帧，如果无余数，则认为数据帧无差错 步骤 在发送端，先把数据划分为组 假定每组 k 个比特 假设待传送的一组数据 M = 101001 （现在 k = 6 ）。我们在 M 的后面再添加供差错检测用的 n 位 冗余码 一起发送。 计算方法 用二进制的 模 2 运算 进行 2^n^ 乘 M 的运算，这相当于在 M 后面添加 n 个 0 得到的 ( k + n ) bit 的数除以事先选定好的长度为 ( n + 1) bit 的除数 P，得出商是 Q 而余数是 R，余数 R 比除数 P 少 1 位，即 R 是 n 位 。 将余数 R 作为冗余码 (帧检验序列) 拼接在数据 M 后面发送出去 。 说明：帧检验序列 在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence) 。 循环冗余检验 CRC 和帧检验序列 FCS 并不等同。 CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。 FCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。 接收端对收到的每一帧进行 CRC 检验 把收到的每一个帧都除以相同的除数 P 模 2 运算 然后 检查得到的余数 R 若得出的余数 R = 0 则判定这个帧没有差错就接受 (accept) 若余数 R 不等于 0 则判定这个帧有差错就丢弃 但这种检测方法并不能确定究竟是哪一个或哪几个比特出现了差错 。 漏检 CRC 不能保证检测出所有的传输错误，但是只要选择位数足够的 P 可以使得差错的概率足够小 只要经过严格的挑选，并使用位数足够多的除数 P 那么出现检测不到的差错的概率就很小很小 CRC 也称多项式编码 任意一个由二进制位串组成的代码都可以和一个 系数仅为 ‘0’ 和 ‘1’ 取值的多项式 一一对应。 多项式表示：即将 k 比特的数据用 k 项多项式表示，它的各项为 X^k-1^, …, X^0^，它的系数为数据中对应位的 0 或 1 。 生成多项式 P 除数 P 可表示成生成多项式 P(X) 例如： P = 110101 ，即 P(X) = X^5^ + X^4^ + X^2^ + 1 (P 为 5 阶多项式）； 生成多项式的最高位和最低位都必须为 1 发送方用它生成冗余位，接收方用它判断是否有错； 若 P 为 r 阶（ r +1 bit ），将产生 r 位冗余位； 发送端帧检验序列 FCS 的生成和接收端 CRC 检验都是用硬件完成的，处理速度很快，不会延误数据的传输 P 的国际标准 注意 仅用循环冗余检验 CRC 差错检测技术只能做到无差错接受，不能检验出帧有没有丢失、重复、失序 无差错接受是指：凡是接受的帧（即不包括丢弃的帧）我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错，也就是说，凡是接收端数据链路层接受的帧都无差错，有差错的帧就丢弃而不接受 。 区分无比特差错与无传输差错（在运输层实现） 要做到可靠传输（即发送什么就收到什么），就必须再加上确认和重传机制 。 在数据链路层使用 CRC 检验能够实现无比特差错的传输但这还不是可靠传输 。 本章介绍的数据链路层协议都不是可靠传输的协议 对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制可以提高通信效率 海明码（纠错码） （重要） 单比特纠错海明码 基本思想 在 k 比特信息上附加 r 比特冗余信息（校验比特），构成 n = k + r 比特的码字，其中每个校验比特和某几个特定的信息比特构成偶校验关系。 接收端对这 r 个偶校验关系进行校验，即将每个校验比特和与它关联的信息比特进行相加（异或），相加的结果为 校正因子 。 如果没有错，则 r 个校正因子都为 0 若校正因子不全为 0 ，根据校正因子的取值，确定错误发 生的位置。 码距 （海明距离 Hamming Distance) 一个编码系统中任意两个合法编码（码字）之间不同的二进位（ bit ）数叫这两个码字的码距 。 例：10101,00110 ，码距为 3 而整个编码系统中任意两个码字的的最小距离就是该编码系统的码距 。 两个结论 如果要检测出 d 个比特的错误，则编码集的海明距离至少为 d + 1 如果要纠正 d 个比特的错误，则编码集的海明距离至少应为 2d + 1 运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:1:3","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"点对点协议 PPP（了解） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:0","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"面向比特的链路层协议 HDLC 高级数据链路控制 （High Level Data Link Control）是由国际标准化组织 ISO 制定的 面向比特 的链路层协议。 采用主从结构，链路上一个主站控制多个从站，主站向从站发送命令，从站向主站返回响应。 点 - 点 点 - 多点 目前很少使用 帧格式 字段 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:1","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"PPP 协议 点对点协议 (Point to Point Protocol) 是数据链路层的功能 主要用在拨号上网 满足的要求 简单 这是首要的要求。 封装成帧 必须规定特殊的字符作为帧定界符 。 透明性 保证数据传输的透明性 。 支持多种网络层协议 能够在同一条物理链路上同时支持多种网络层协议。 支持多种类型链路 能够在多种类型的链路上运行。 差错检测 能够对接收端收到的帧进行检测，并立即丢弃有差错的帧 。 检测连接状态 能够及时自动检测出链路是否处于正常工作状态。 最大传送单元 必须对每一种类型的点对点链路设置最大传送单元 MTU 的 标准默认值，促进各种实现之间的互操作性。 网络层地址协商 必须提供一种机制使通信的两个网络层实体能够通过协商知 道或能够配置彼此的网络层地址。 数据压缩协商 必须提供一种方法来协商使用数据压缩算法。 不需要的功能 纠错 流量控制 序号 多点线路 半双工或单工链路 透明传输问题（要看） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:2:2","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"使用广播信道的数据链路层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:0","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"局域网的数据链路层 特点 网络为一个单位所拥有；地理范围和站点数目均有限 具有较高的数据率、较低的时延和较小的误码率 优点 广播功能 功能，从一个站点可很方便地访问全网。局域网上的主 机可共享连接在局域网上的各种硬件和软件资源。 便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变 提高了系统的可靠性、可用性和生存性 拓扑结构 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:1","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"局域网信道分配策略 广播网中所有站点共享同一个信道，任一站点发送的信息能被所有其他站点接收到。 问题 若有两个或两个以上的站点同时发送数据，则信号在信道中发生碰撞，数据发送失败，为冲突。 广播网中，如何将单一的信道分配各各个不同的用户，是个重要的问题。 用户使用的信道称为媒体（介质），决定由谁来使用信道的协议为媒体（介质）访问控制协议 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:2","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"媒体（介质）共享技术 静态划分信道 频分复用 时分复用 波分复用 码分复用 静态分配的特点 站点数目少且固定，且每个站点有大量数据发送，控制协议简单且传输的效率高。 对于大部分计算机网络，站点数目多且不固定，数据传输有突发性，信道的利用率低。 代价较高，不适合于局域网使用 动态分配 动态媒体接入控制（多点接入） 信道不是在用户通信时固定分配给用户。 例如：异步时分多路复用 STDM ，各站点仅当有数据发送时，才占用信道发送数据。 动态接入控制类型 随机接入 又称争用，用户发送前不需要取得发送权，有数据就发送，发生**冲突（碰撞）**后采取措施解决冲突 控制接入（少用 ） 用户首先获得发送权，再发送数据，不会产生冲突 令牌环局域网的多点线路探询（polling） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:3","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"争用协议 争用协议的特性 随机访问： 意味着对任何站都无法预计其发送的时刻； 竞争发送： 是指所有发送的站自由竞争信道的使用权。 ALOHA 系统和它的后继者 CSMA/CD 都是争用协议的代表。 ALOHA 思想（想发就发，冲突重发） 任何用户有数据发送就可以发送（会带来冲突） 如果发生冲突，接收方会检测出差错，然后不予确认，发送方一定时间内收不到确认就判断发生冲突； 发现数据传输失败后，各自等待一段随机时间 ，再重新发送。 竞争系统中，一方面不断有新的数据帧发送，另一方面冲突帧需要重发，系统的吞吐量是一个重要的指标。 吞吐量 ：单位时间内系统能够成功发送的新的数据帧的平均数量。 结论： ALOHA 系统最大的信道利用率为 18.4% ALOHA 系统的信道利用率是非常低的。原因主要是各个站自由发送数据，碰撞概率增大。 时隙 ALOHA 协议 （ Slotted ALOHA ）控制想发就发的随意性 把时间分为若干个相同的时间片，所有用户在时间片开始时刻同步接入网络信道若发生冲突，则必须等到下一个时间片开始时刻再发送。 时隙 ALOHA 系统的最大信道利用率为 36.8% CSMA/CD 协议（重要） 以太网采取了两种重要的措施 为了通信的简便，以太网采取了两种重要的措施： 采用较为灵活的无连接的工作方式 不必先建立连接就可以直接发送数据。 对发送的数据帧不进行编号，也不要求对方发回确认。 这样做的理由是局域网信道的质量很好，因信道质量产生差错的概率是很小的。 以太网提供的服务是不可靠的交付，即尽最大努力的交付。 当目的站收到有差错的数据帧时就丢弃此帧，其他什么也不做。 差错的纠正由高层来决定。 如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 以太网发送的数据都使用曼彻斯特编码 曼彻斯特编码缺点是：它所占的频带宽度比原始的基带信号增加了一倍 协议内容 CSMA/CD 含义： 载波监听，多点接入 / 碰撞检测 (Carrier Sense Multiple Access with Collision Detection) 多点接入指总线型网络，表示许多计算机以多点接入的方式连接在一根总线上。(计算机之间相互竞争) 载波监听是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。（先听后说，有礼貌） 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 碰撞检测就是计算机边发送数据边检测信道上的信号电压大小。 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。 当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测” 检测到碰撞后 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送 每个站点都是在监听到信道空闲时才发送数据的，为什么还会发生碰撞？根本原因是因为电磁波在媒体上的传播速度总是有限的。 为什么要进行碰撞检测？ 由于电磁波在总线上的传播速率是有限的， 当某个站监听到总线是空闲时，也可能总线并非真正是空闲的 A 向 B 发出的信息，要经过一定的时间后才能传送到 B B 若在 A 发送的信息到达 B 之前发送自己的帧（因为这时 B 的载波监听检测不到 A 所发送的信息），则必然要在某个时间和 A 发送的帧发生碰撞。 碰撞的结果是两个帧都变得无用。 所以需要在发送期间进行碰撞检测，以检测冲突。 CSMA/CD 的重要特性 使用 CSMA/CD 协议的以太网不能进行全双工通信，只能进行双向交替通信（半双工通信）。 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 这种 发送的不确定性 使整个以太网的平均通信量远小于以太网的最高数据率。 两个重要问题 最迟多久才能知道自己发送的数据没和别人发生碰撞（争用期） 检测到碰撞后，等待多长时间再重试（退避算法） 争用期 最先发送数据帧的站，在发送数据帧后至多经过时间 2$\\tau$（两倍端到端单程传播时延）就可知道发送的数据帧是否遭受了碰撞。 以太网的端到端往返时延 2$\\tau$ 称为争用期，或碰撞窗口。 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 二进制指数类型退避算法 (truncated binary exponential) 发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。 基本退避时间取为争用期 2$\\tau$ 从整数集合 [0, 1, 2, 3, 4, … , (2^k^ - 1)] 中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。 参数 k 按公式计算：$k = Min[重传次数, 10]$ 当 $k\\leq 10$ 时，参数 k 等于重传次数。 当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 最短帧长 A站发了一个很短的帧，不幸发生了碰撞，但是帧在发送完毕后才检测到发生碰撞，没法停止发送，因为发完了。。。 帧的发送时延至少持续一个争用期的时间（即 2 倍的传播时延） 以太网的最短帧长 $10 Mbit/s$ 的以太网取 $51.2\\mu s$ 为争用期的长度，它在争用期内可以发送 512bit，即 64 字节（最短有效帧长） 这意味着 以太网在发送数据时，若前 64 字节没有发生冲突，则后续的数据就不会发生冲突 。 如果发生冲突，就一定是在发送的前 64 字节之内。 由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧 强化碰撞 当发送数据的站一旦发现发生了碰撞时 立即停止发送数据； 再继续发送若干比特的人为干扰信号 (jamming signal)，以便让所有用户都知道现在已经发生了碰撞。 要点 准备发送，但没有完全发。在发送之前，必须先检测信道。 检测信道 。 若检测到信道忙，则应不停地检测，一直等待信道转为空闲。 若检测到信道空闲，并在 96 比特时间内信道保持空闲（保证了帧间最小间隔 9.6 μs），就发送这个帧。 检查碰撞。 在发送过程中仍不停地检测信道，即网络适配器要边发送边监听。这里有两种可能性 发送成功： 在争用期内一直未检测到碰撞。这个帧肯定能够发送成功。发送完毕后，其他什么也不做。然后回到 1 发送失败： 在争用期内检测到碰撞。这时立即停止发送数据，并按规定发送人为干扰信号。适配器接着就执行指数退避算法，等待 r 倍 512 比特时间 后，返回到步骤 2，继续检测信道。但若重传达 16 次仍不能成功，则停止重传而向上报错。 先听后发，边听边发，冲突停止，延迟重发 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:3:4","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"以太网 （Ethernet） 两个标准 DIX Ethernet V2 是 DEC、Intel、Xerox 公司联合提出的世界上第一个局域网产品（以太网）的规约——10M/s 的以太网规约。 IEEE 802.3 是 第一个 IEEE 802 委员会制定的局域网标准 两者差别很小，因此可以将 802.3 局域网简称为“以太网” 数据链路层的两个子层 逻辑链路控制 LLC (Logical Link Control) 子层 媒体接入控制 MAC (Medium Access Control) 子层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:0","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"传统以太网 传统以太网 10Mbits/s 速率 最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆 ，最后发展为使用更便宜和更灵活的双绞线 。 采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器 (hub) 集线器本身不解决冲突问题 星形以太网 10BASE-T 1990 年 IEEE 制定出星形以太网 10BASE-T 的标准 802.3i 。 特点 使用无屏蔽双绞线，采用星形拓扑。 每个站需要用两对双绞线，分别用于发送和接收。 双绞线的两端使用 RJ 45 插头 。 集线器使用了大规模集成电路芯片，因此 集线器的可靠性提高 。 10BASE T 的通信距离稍短，每个站到集线器的距离不超过 100 m 10BASE T 双绞线以太网 的出现，是局域网发展史上的一个非常重要的里程碑，它为以太网在局域网中的统治地位奠定了牢固的基础。 信道利用率 多个站在以太网上同时工作就可能会发生碰撞。 设帧长为 L (bits)，数据发送速率为 C (bit/ s)，则帧的发送时间为 T~0~ = L / C (s) 。 以太网信道被占用的情况 参数 α 与利用率 要提高以太网的信道利用率，就必须减小 $\\tau$ 与 T0 之比。 在以太网中定义了参数 α，它是以太网单程端到端时延 $\\tau$ 与帧的发送时间 T0 之比： $$ a=\\frac{\\tau}{T_0} $$ 对以太网参数 α 的要求是 α 要尽可能小 当数据率一定时， 以太网的连线的长度要受到限制，否则 $\\tau$ 的数值会太大 以太网的帧长不能太短，否则 T~0~ 的值会太小，使 α 值太大 信道利用率的最大值S~max~ 在理想化的情况下，以太网上的各站发送数据都不会产生碰撞（这显然已经不是CSMA/CD，而是需要使用一种特殊的调度方法），即总线一旦空闲就有某一个站立即发送数据。 发送一帧占用线路的时间是 $T_0+\\tau$，而帧本身的发送时间是 T~0~。于是我们可计算出理想情况下的极限信道利用率 S~max~ 为： $$ S_{max}=\\frac{T_0}{T_0+\\tau}=\\frac{1}{1+a} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:1","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"以太网的层次结构 数据链路层的两个子层 逻辑链路控制 LLC (Logical Link Control) 子层 屏蔽对各种不同物理网络的访问方法的差异，向上提供数据传输服务的统一的逻辑接口 媒体接入控制 MAC (Media Access Control) 子层 控制对传输介质的访问，并在物理层的基础上实现无差错通信。该子层随不同的物理网络差异较大 TCP/IP 一般不考虑 LLC 子层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:2","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"以太网的 MAC 层 计算机要连接到局域网需要依靠网络接口板。 网络接口板又称为适配器 (adapter) 或网络接口卡 NIC (Network Interface Card) Card)，或网卡 适配器的重要功能： 进行串行 / 并行转换 对数据进行缓存 在计算机的操作系统安装设备驱动程序 实现以太网协议 MAC 层的硬件地址 硬件地址又称为物理地址，或 MAC 地址 标准所说的 “地址” 严格地讲应当是每一个站的 “名字” 或标识符，采用 6 字节 ( 48 位 ) ，是固化在网卡 ROM 中的 MAC 帧格式 常用的以太网 MAC 帧格式有两种标准 DIX Ethernet V2 标准 IEEE 的 802.3 标准 最常用的 MAC 帧是 以太网 V2 的格式 以太网 V2 的 MAC 帧 由五个字段组成。 前两个字段分别为 6 字节长的目的地址和源地址字段。 第三个字段是 2 字节的类型字段，用来标志上一层使用的是什么协议 第四个字段是数据字段，其长度在 46 到 1500 字节之间 最后一个字段是 4 字节的帧检验序列 FCS (使用 CRC 检验） 总帧长 64 - 1518 对于检查出的无效 MAC 帧就简单地丢弃，以太网不负责重传丢弃的帧。 IEEE 802.3 MAC 帧格式（了解） 与以太网 V2 MAC 帧格式 相似， 区别 在于： IEEE 802.3 规定的 MAC 帧的第三个字段是“ 长度 / 类型 ”。 当这个字段值大于 0x0600 时（相当于十进制的 1536 ），就表示“类型”。这样的帧和以太网 V2 MAC 帧完全一样。 当这个字段值小于 0x0600 时才表示“长度” 。 当 “长度 / 类型” 字段值小于 0x0600 时，数据字段必须装入上面的逻辑链路控制 LLC 子层的 LLC 帧。 帧最小间隔 帧间最小间隔为 9.6 μs ，相当于 96 bit 的发送时间。 一个站在检测到总线开始空闲后，还要等待 9.6 μs 才能再次发送数据。 这样做是为了使刚刚收到数据帧的站的接收缓存来得及清理，做好接收下一帧的准备。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:3","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"扩展以太网 在物理层扩展以太网 使用光纤扩展 使用集线器扩展 连接成更大的多级星形结构的以太网 相当于一个转发器，增大碰撞域，实现跨碰撞域的通信 在数据链路层扩展以太网 扩展以太网更常用的方法是在数据链路层进行。 早期使用网桥，现在使用以太网交换机。 网桥 根据 MAC 帧的目的地址对收到的帧进行转发和过滤 一般两个端口 工作原理 网桥从端口接收网段上传送的各种帧； 每当收到一个帧时，先暂存在缓存中。 若此帧未出错，且欲发送的目的站的 MAC 地址属于另外一个网段，则通过查找 “转发表”，将收到的帧送往对应的端口转发。 若此帧出错，则丢弃该帧。 同一个网段内的帧，不会被网桥转发，不会增加网络负担 网桥使各网段成为隔离开的碰撞域 内部结构 优点 过滤通信量、扩大了物理范围、提高了可靠性。 可互连不同物理层、不同 MAC 子层和不同速率的局域网。 缺点 存储转发增加了时延。 在 MAC 子层并没有流量控制功能。 具有不同 MAC 子层的网段桥接在一起时时延更大。 只适合用户数不太多（不超过几百个）和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞（所谓广播风暴） 网桥与集线器的不同 集线器在转发帧时，不对传输媒体进行检测。 网桥在转发帧之前必须执行 CSMA/CD 算法 由于网桥没有网卡，因此网桥并不改变它转发的帧的源地址。 类型（如何生成路由） 固定路由网桥 人为建转发表 透明网桥 网桥确定路由 能生成和修改自己路由表的网桥 用的最多 源路由网桥 站点确定路由 发送站点确定到达目的地的路由，并将它存储在所发送的帧中；网桥接收帧后按其指示的路由将它转发到下一个局域网上。 交换机 即多端口网桥（有更多接口的网桥） 特点 每个接口都直接与一个单台主机或另一个以太网交换机相连，并且一般都工作在全双工方式。 并行性 能同时连通多对接口， 使每一对相互通信的主机都能像独占通信媒体那样，进行无碰撞地传输数据。 相互通信的主机都是独占传输媒体，无碰撞地传输数据。 以太网交换机的接口有存储器， 能在输出端口繁忙时把到来的帧进行缓存 。 即插即用，其内部的帧交换表是通过自学习算法自动地逐渐建立起来 以太网交换机使用了专用的交换结构芯片，用硬件转发，其转发速率要比使用软件转发的网桥快很多。 优点 用户独享带宽，增加了总容量。 用以太网交换机扩展局域网 交换方式 存储转发方式 把整个数据帧先缓存后再进行处理 。 直通 (cut through) 方式 接收数据帧的同时就立即按数据帧的目的 MAC 地址决定该帧的转发接口，因而提高了帧的转发速度 缺点 是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站 在某些情况下，仍需要采用基于软件的存储转发方式进行交换，例如，当需要进行线路速率匹配、协议转换或差错检测时 自学习算法（重要） 以太网交换机运行自学习算法自动维护交换表。 步骤 开始时，以太网交换机里面的交换表是空的 A 先向 B 发送一帧，从接口 1 进入到交换机。 交换机收到帧后， 先查找交换表， 没有查到应从哪个接口转发这个帧。 交换机把这个帧的 源地址 A 和 接口 1 写入交换表 中，并向（除接口 1 以外的）所有接口广播这个帧。 C 和 D 将丢弃这个帧，因为目的地址不对。只 B 才收下这个目的地址正确的帧，称为过滤 从新写入交换表的项目 (A, 1) 可以看出，以后不管从哪一个接口收到帧，只要其目的地址是 A ，就应当把收到的帧从接口 1 转发出去。 B 通过接口 3 向 A 发送一帧。（一般作为答复） 交换机查找交换表， 发现交换表中的 MAC 地址有 A 。表明要发送给 A 的帧（即目的地址为 A 的帧）应从接口 1 转发。 于是就把这个帧传送到接口 1 转发给 A 。 显然，现在已经没有必要再广播收到的帧。 交换表这时新增加的项目 (B, 3)，表明今后如有发送给 B 的帧，就应当从接口 3 转发出去。 经过一段时间后， 只要主机 C 和 D 也向其他主机发送帧， 以太网交换机中的交换表就会把转发到 C 或 D 应当经过的接口号（ 2 或 4 ）写入到交换表中 以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。 交换机自学习和转发帧的步骤归纳 交换机收到一帧后先查找交换表中与收到帧的源地址有无相匹配的项目。 如没有，就在交换表中增加一个项目（源地址、进入的接口和有效时间）。 如有，则把原有的项目进行更新（进入的接口或有效时间）。 转发帧。 查找交换表中与收到帧的 目的地址有无相匹配 的项目。 如没有，则向所有其他接口（进入的接口除外）转发。（泛洪帧） 如有，则按交换表中给出的接口进行转发。 若交换表中给出的接口就是该帧进入交换机的接口，则应丢弃这个帧（因为这时不需要经过交换机进行转发） 生成树协议 为了增加网络的可靠性，会增加冗余链路。自学习的过程就可能导致以太网帧在网络的某个环路中无限制地兜圈子 如图，假定开始时，交换机 #1 和 #2 的交换表都是空的，主机 A 通过接口交换机 #1 向主机 B 发送一帧。 按交换机自学习和转发方法，该帧的某个走向如下 离开交换机#1 的接口3 → 交换机#2 的接口1 → 接口2 → 交换机#1 的接口4 → 接口3 → 交换机#2 的接口1 → …… 这样就无限制地循环兜圈子下去，白白消耗了网络资源 IEEE 802.1D 标准制定了一个生成树协议 STP (Spanning Tree）为了消除广播风暴 其要点是不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:4","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"虚拟局域网 冲突域：连接在同一个网桥或交换机端口的计算机只能有一台计算机发送数据 广播域：网络中所有能接收到同样广播消息的设备的集合 定义 利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN) 。 虚拟局域网 VLAN 是由一些局域网网段构成的与物理位置无关的逻辑组，这些网段具有某些共同的需求 。 每一个 VLAN 的帧都有一个明确的标识符 ，指明发送这个帧的计算机是属于哪一个 VLAN 。 虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网 图注：当 B1 向 VLAN2 工作组内成员发送数据时，工作站 B2 和 B3 将会收到广播的信息，而工作站 A1，A2 和 C1都不会收到 B1 发出的广播信息。虚拟局域网限制了接收广播信息的工作站数，使得网络不会因传播过多的广播信息（即“广播风暴”）而引起性能恶化 优点：安全性好、网络按照逻辑分段、灵活性好 有效控制广播域范围 增强网络安全性 灵活构建虚拟工作组 提高网络的可管理性 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:5","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"高速以太网 高速以太网：100BASE-T 以太网，全双工模式下工作不使用 CSMA/CD 协议，争用期、帧间时间间隔更短 吉比特以太网：允许在 1Gbit /s 下以 全双工 和 半双工 两种方式工作。 功能 载波延伸：最短帧长 64 字节，但争用时间增大为 512 字节，填充特殊字符 分组突发：多短帧发送时，第一个载波延伸，其余指留有必要间隔连续发送 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/:4:6","tags":["计算机网络"],"title":"计算机网络 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/3.-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"},{"categories":["专业课"],"content":"网络层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:0:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"网络层提供的两种服务 电信网：面向连接（真实连接，电话设计简单） 互联网：无连接（计算机有很强的差错处理能力） 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据包服务，不提供服务质量保证。降低了网络造价。 网络层提供的两种服务 虚电路服务：不需要包含目的地址，分组信息比特数较少，差错可以由网络负责控制 数据报服务：网络上报文长度相对较短，主机负责差错、流量控制 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:1:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"网际协议 IP (Internet Protocol) 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一 与 IP 协议配套使用的三个协议 地址解析协议 ARP (Address Resolution Protocol) 网际控制报文协议 ICMP (Internet Control MessageProtocol) 网际组管理协议 IGMP (Internet Group ManagementProtocol) ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"虚拟互连网络 将网络互相连接起来要使用一些中间设备。 中间设备又称为中间系统或中继 (Relay) 系统 有以下五种不同的中继系统： 物理层 ：转发器 (Repeater) 数据链路层：网桥或桥接器 (Bridge) 网络层：路由器 (Router) 网桥和路由器的混合物：桥路器 (brouter) 网络层以上：网关 (Gateway） 网络互连使用路由器 将使用路由器连接起来的网络看成同一个虚拟的IP网络（互连网） 意义 使用 IP 协议的虚拟互连网络可简称为 IP 网 互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络 使用虚拟互连网络的好处是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节（如编址方案、路由选择协议等）。 如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的互联网 (Internet) ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:1","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"分类的 IP 地址 定义 IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是 唯一的 32 位的标识符（4 字节） IP 地址现在由 互联网名字和数字分配机构ICAN (Internet Corporatiofor Assigned Names and Numbers) 进行分配。 分类的 IP 地址将 32 位地址进行了划分 格式 将 IP 地址划分为若干个固定类（ A-E 类） 每一类地址都由两个固定长度的字段组成 其中一个字段是网络号 net-id，它标志主机（或路由器）所连接到的网络 另一个字段则是主机号 host-id ，它标志该主机（或路由器）。 主机号在它前面的网络号所指明的网络范围内必须是唯一的。 由此可见， 一个 IP 地址在整个互联网范围内是唯一的。 分类 A类：8-24，0 开始，最大可指派网络数 27−227−2 ，每个网络最大主机数 224−2224−2 B类：16-16，10开始，最大可指派网络数 214−1214−1 ，每个网络最大主机数 216−2216−2 C类：24-8，110开始，最大可指派网络数 221−1221−1 ，每个网络最大主机数 28−228−2 D类：1110开始，多播地址 E类：1111开始，保留今后使用 分类的好处 划分成不同类别的考虑 各种网络差异很大，有的网络拥有很多主机，而有的网络拥有的主机数目很少。 将 IP 地址划分成不同类别 A 、 B 、 C 可以满足不同用户的需求。 当一个单位申请到一个 IP 地址时，只是申请了一个网络号 Net id ，具体的主机号由各个单位自行分配。 D 类和 E 类使用较少 D 类的多播地址主要留给 IAB （因特网体系结构委员会）使用。 点分十进制记法 常用的三种类别的 IP 地址 三个类别的 IP 地址中， 2 个特殊的 Host id 含义： 全 0 的 Host id 表示该 IP 地址是 “本主机” 所连接的单个网络地址。 如 IP 地址为 5.6.7.8 ，则网络地址为 5.0.0.0 全 1 的 Host id 表示所有 (all)，即该网络上的所有主机 一般不使用的 IP 地址 重要特点 IP 地址是一种分等级的地址结构 单位分配主机号，方便单位管理 路由器只根据网络号转发分组，减少了路由表所需存储空间 实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net id 所有分配到网络号 net id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:2","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"IP 地址与硬件地址 IP 地址与硬件地址是不同的地址。 从层次的角度看 硬件地址（或物理地址） 是数据链路层和物理层使用的地址 。 IP 地址是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的） 主机 H1 与 H2 通信中使用的 IP 地址与硬件地址 HA ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:3","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"地址解析协议 ARP (Address Resolution Protocol） 通信时使用了两个地址： IP 地址 （网络层地址） MAC 地址 （数据链路层地址） 已经知道了一个机器（主机或路由器）的 IP 地址，如何找出其相应的硬件地址？ 地址解析协议 ARP 就是用来解决这样的问题的 ARP 解决了同一个局域网上主机或路由器 IP 和 MAC 地址映射问题 要点 每个主机都设有一个 ARP 高速缓存，里面有所在局域网上的主机和路由器 IP 到硬件地址的映射表，并且能动态更新（设有 TTL） 如有，则通过局域网将 MAC 帧发送到硬件地址 如没有，发送 ARP 请求分组，等待 ARP 响应分组，写入 ARP 高速缓存 ARP 请求/响应分组的内容 发送方硬件地址 发送方 IP 地址 目标方硬件地址（未知填0） 目标方IP地址 请求分组广播，响应分组单播 不直接使用硬件地址通信的原因：硬件地址形式不统一 注意 如果所要找的主机和源主机不在同一个局域网上，那么 就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做 从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。 只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信， ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。 使用 ARP 的四种典型情况 发送方是主机，要把 IP 数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。 发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。 发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上另一个路由器的硬件地址。剩下的工作由这个路由器来完成 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:4","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"IP 数据报的格式 一个 IP 数据报由首部和数据两部分组成。 首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。 在首部的固定部分的后面是一些可选字段，其长度是可变的 版本：占 4 位，指 IP 协议的版本 首部长度：占 4 位，可表示的最大数值是15 个单位，一个单位为 4 字节。因此最大值是 60 字节 区分服务：占 8 位，不常用 总长度：占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。 标识：占 16 位，计数器，用来产生 IP 数据报的标识 标志：占 3 位，目前只有前两位有意义 最低位 MF （more fragment） MF = 1 表示后面还有分片；MF = 0 表示最后一个分片。 中间位 DF（don’t fragment） 只有当 DF = 0 时才允许分片。 片偏移：占 13 位，以 8 个字节为偏移单位。 指出：较长的分组在分片后某片在原分组中的相对位置 （以下了解即可） 生存时间：占 8 位，记为 TTL (Time To Live），指示数据报在网络中可通过的路由器数的最大值。 协议：记录上层协议（TCP 等） 占 8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程 首部检验和：反码运算求和（高位溢出加低位） 占 16 位， 只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 源地址和目的地址：都各占 4 字节 可选字段：不常用，不足1字节需要填充 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:5","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"IP 层转发分组的流程 按主机所在的网络地址制作路由表 根据目的网络地址就能确定下一跳路由器，这样做的结果是： IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付 ） 只有到达最后一个路由器时，才试图向目的主机进行直接交付。 默认路由 路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间。 如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。 这种转发方式在一个网络只有很少的对外连接时是很有用的。 默认路由在主机发送 IP 数据报时往往更能显示出它的好处。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:2:6","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"划分子网和构造超网 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:3:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"划分子网 （subnetting） 格式 三级 IP 地址：网络号::子网号::主机号 转发数据报时，仍然先找到本网络上的路由器，路由器根据网络号和子网号找到子网，最后直接交付目的主机 优点 减少 IP 地址的浪费 使网络组织更加灵活 便于维护管理 划分子网对外部网络透明，对外表现仍然是一个网络 子网掩码 从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。 使用子网掩码 (subnet mask) 可以找出 IP 地址中的子网部分 全 0 或全 1 的子网号是不使用的 规则 长度 32 位 某位 1：IP 地址中的对应位为网络号和子网号 某位 0：IP 地址中的对应位为主机号 子网划分方法 有固定长度子网和变长子网两种子网划分方法。 在采用固定长度子网时，所划分的所有子网的子网掩码都是相同的 。 若使用较少位数的子网号，则每一个子网上可连接的主机数就较多。 划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。 例","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:3:1","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"使用子网时分组的转发 用各网络子网掩码和目的IP地址相与，结果一致直接交付 检查是否有特定主机路由 与路由表各项子网掩码相与，寻找匹配目的网络 由默认路由转发 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:3:2","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"无分类编址 CIDR 无分类域间路由选择 CIDR (Classless Inter Domain Routing) CIDR 消除了传统的 A 类 、 B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间 格式 使用网络前缀（network prefix）代替分类地址中的网络号和子网号 斜线记法（CIDR 记法） 即在 IP 地址面加上一个斜线 /，然后写上网络前缀所占的位数。 这个数值对应于三级编址中子网掩码中 1 的个数 例如： 220.78.168.0/24 主机号全 0 全 1 一般不使用 CIDR 地址块 将有相同网络前缀的连续 IP 地址组成 CIDR 地址块 路由聚合 也称构成超网（supernetting） 一个 CIDR 地址块表示很多地址，称为路由聚合 可以减少路由信息交换 CIDR 虽然不使用子网了 但仍然使用掩码这一名词，但不叫子网掩码 。 对于 20 地址块，它的掩码是 20 个连续的 1。斜线记法中的数字就是掩码中 1 的个数 最长前缀匹配 使用 CIDR 时，路由表中的每个项目由网络前缀和下一跳地址组成。在查找路由表时可能会得到不止一个匹配结果。 应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配 (longest prefix matching)。 网络前缀越长，其地址块就越小，因而路由就越具体 (more specific) 。 最长前缀匹配又称为最长匹配或最佳匹配 举例 使用二叉线索存储（字典树） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:3:3","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"网际控制报文协议 ICMP （Internet Control Message） ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告 ICMP 报文封装在 IP 数据包中，是 IP 层的协议 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:4:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"种类 格式：类型、代码、校验和 种类：ICMP 差错报告报文和ICMP 询问报文 差错报告报文 向源站点报告错误信息，不需要应答 类型 终点不可达 时间超过：收到 TTL 为 0 的数据报时 参数问题：收到的数据报首部有字段不正确时。 改变路由（重定向） 方法 报文的数据部分包含 ICMP 差错报告报文的前 8 个字节，再加上引起错误的 IP 数据报的首部和数据字段的前 8 个字节。 询问报文 采用请求应答方式进行交互用来请求一些消息 分类 回答请求和回答报文 时间戳请求和回答报文 应用举例 PING (Packet InterNet Groper) 分组网间探测 tranceroute 用来跟踪一个分组从源点到终点的路径。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:4:1","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"互联网的路由选择协议 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:5:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"有关路由选择协议的几个基本概念 不存在绝对的最佳路由算法 从路由算法的自适应性考虑 静态路由选择：非自适应路由选择。简单开销小，但不能适应网络动态和变化 动态路由选择：自适应路由选择。适应网络状态的变化，但实现复杂，开销 自治系统 AS 分层次路由选择协议的原因：互联网规模大；许多单位不愿意外接了解内部网络细节 定义： 在单一的技术管理下的一组路由器,而这些路由器使用一种 AS 内部的路由选择协议和共同的度量 。 一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略 两大类路由选择协议 这里网关 == 路由器 域间路由选择和域内路由选择 内部网关协议 IGP ( Interior Gateway Protocol ) 在一个自治系统内部使用的路由选择协议。 目前这类路由选择协议使用得最多，如 RIP（距离向量） 和 OSPF（链路状态） 协议。 外部网关协议 EGP ( External Gateway Protocol ) 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。 这样的协议就是外部网关协议 EGP 。 在外部网关协议中目前使用最多的是 BGP-4 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:5:1","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"内部网关协议 RIP RIP (Routing Information Protocol) 定义 RIP 是一种分布式的、基于距离向量的动态路由选择协议 分布式：每个路由器独立决定自己的路由表 距离、向量：到达目的网络所需费用；一组距离的记录 动态：根据拓扑结构、通信量的变化来改变其路由选择 RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的唯一最佳距离记录 与相邻路由器交换全部路由表 距离 RIP 协议中的 “距离” 也称为 “跳数” (hop count)，因为每经过一个路由器，跳数就加 1。这里的 “距离” 实际上指的是 “最短距离” RIP 认为一个好的路由就是它通过的路由器的数目少即距离短 RIP 允许一条路径最多只能包含 15 个路由器 。 距离的最大值为 16 时即相当于不可达。 可见 RIP 只适用于小型互联网 RIP 不能在两个网络之间同时使用多条路由 RIP 选择一个具有最少路由器的路由，即最短路由。 哪怕还存在另一条高速低时延但路由器较多的路由 。 特点 和哪些路由器交换信息？ 仅和相邻路由器交换信息。 交换什么信息？ 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 在什么时候交换信息？ 按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。若超过 180s 没收到邻居通告，则判定邻居没了并更新路由表。 RIP 路由表的信息 路由表的主要信息 到某个网络的距离（即最短距离） 应经过的下一跳地址 路由表的更新原则是找出到每个目的网络的最短距离 RIP 使用的更新算法称为距离向量算法 路由表的建立 例 距离加一 下一跳不同，选择最优路径 下一跳相同，覆盖 RIP2 协议的报文格式 应用层协议，使用 UDP 协议传输 RIP2 是 1998 年公布的较新的 RIP 版本。 RIP2 报文由 首部 和 路由部分 组成。 优缺点 优点 实现简单，开销较小。 缺点 限制了网络的规模，它能使用的最大距离为 15 路由器之间交换的路由信息是路由器中的完整路由表，开销大 好消息传播得快，坏消息传播得慢。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:5:2","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"内部网关协议 OSPF OSPF (Open Shortest Path First)（开放最短路径优先协议），是为克服 RIP 的缺点在 1989 年开发出来的。 最短路径的计算使用了迪杰斯特拉算法 特点 和哪些路由器交换信息？ 向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。 交换什么信息？ 发送的信息就是与本路由器相邻的所有路由器的链路状态 ，但这只是路由器所知道的部分信息。 “链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的 “度量” ( metric)：费用、距离、时延、带宽等。 最终目标是构建一个全网的拓扑结构图 在什么时候交换信息？ 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。 链路状态数据库 所有的路由器最终都能建立一个链路状态数据库 这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的 （这称为链路状态数据库的同步）。 每个路由器都知道全网有多少路由器，哪些路由器是相连的，代价是多少等。 每个路由器根据数据状态数据库，构造出自己的路由表。 OSPF 的链路状态数据库能较快地进行更新， 使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。 分类 问候 (Hello) 分组 用来发现和维持邻站的可达性。 数据库描述 (Database Description) 分组 向邻站给出自己的链路状态数据库所有项目的摘要信息。 链路状态请求 (Link State Request) 分组 向对方请求发送某些链路状态项目的详细信息。 链路状态更新 (Link State Update) 分组 用洪泛法对全网更新链路状态。 OSPF 协议最核心的部分 链路状态确认 (Link State) 分组 对链路更新分组的确认。 区域 为了使 OSPF 能用于规模很大的网络， OSPF 将一个自治系统再划分为若干个更小的范围，叫做 区域。 每一个区域都有一个 32 位的区域标识符 （用点分十进制表示）。 区域也不能太大，在一个区域内的路由器最好不超过 200 个。 区域划分的好处 将洪泛的范围缩小，减少网络通信量 在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑情况 重要的路由器 主干路由器（backbone router）：主干区域的路由器 区域边界路由器（area border router）：连接两个区域的路由器 自治系统边界路由器：与其他自治系统交换信息的路由器，也是一种边界路由器 报文格式 OSPF 直接用 IP 数据包报传送，其首部的协议字段值为 89 OSPF 构成的数据报很短 可减少路由信息的通信量。 不必将长的数据报分片传送。 分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。 OSPF 分组使用 24 字节的固定长度首部 RIP 与 OSPF 的比较 RIP 节点告诉相邻节点它所知道的所有路由信息 节点根据来自相邻节点的路由信息更新自己的路由表 定期交换信息 可扩展性差 OSPF 节点告诉所有节点它的相邻节点的状态信息 每个节点都有一个全局的拓扑结构，并以此计算路由表 链路状态变化时才交换信息 可扩展性好，可靠 与整个互联网的规模无直接联系。没有“坏消息传播得慢”的问题 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:5:3","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"外部网关协议 BGP BGP (Border Gateway Protocol) ( 边界网关协议 ) 是不同自治系统的路由器之间交换路由信息的协议，目前使用最多的版本是 BGP-4 为什么不能使用内部网关协议？ 互联网的规模太大，使得自治系统之间路由选择非常困难。 主干网路由器的项目表已超过了 5 万个网络前缀。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的 。 当一条路径通过几个不同 AS 时，要想对这样的路径 计算出有意义的代价是不太可能的 。 比较合理的做法是在 AS 之间交换“ 可达性 ”信息。例 “到达目的网络 N 可经过自治系统 AS x ”。 自治系统之间的路由选择必须考虑有关策略。 包括政治、安全或经济方面的考虑。 BGP 致力于寻找一条比较好的路由（并非最佳），采用了路径向量路由选择协议 特点 和谁交换信息？ 与其他 AS 的邻站 BGP 发言人交换信息。 每一个自治系统的管理员要选择至少一个 路由器 作为该自治系统的 “BGP 发言人” (BGP speaker） 通常，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器 ，但也不一定 交换什么信息？ 路径向量。也就是网络可达性的信息，即到达某个网络所要经过的一系列 AS 在什么时候交换信息？ 发生变化时更新有变化的部分 连通图 也就是网络可达性信息 报文格式 封装在 TCP 报文中 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:5:4","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"路由器 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组 结构 路由选择部分 根据所选定的路由选择协议构造出路由表 相邻路由器交换路由信息，更新和维护路由表。 分组转发部分 一组输入端口 交换结构：根据转发表对分组进行处理 一组输出端口 核心功能 控制层：运行各种路由协议 数据层：将收到的 IP 分组转发 交换结构 交换结构是路由器的关键构件 交换方法 通过存储器 通过总线 通过纵横交换结构 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:5:5","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"IP 多播 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:6:0","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"基本概念 多播 (multicast ，以前曾译为组播 ) 是一种一对多通信： 一个源点发送到许多个终点 能够运行多播协议的路由器称为多播路由器 (multicast router) 在互联网上进行多播就叫做 IP 多播 IP 多播分为两种 一种是只在本局域网上进行硬件多播 另一种是在互联网的范围内进行多播 多播 IP 地址 IP 多播所传送的分组需要使用多播 IP 地址。 在多播数据报的目的地址写入多播组的标识符 。 多播组的标识符就是 IP 地址中的D 类地址（多播地址） D 类 IP 地址的前四位是 1110 ，因此范围是 224.0.0.0 到 239.255.255.255 。 每一个 D 类地址标志一个多播组。 多播地址只能用于目的地址， 不能用于源地址 多播数据报 多播数据报和一般 IP 数据报的区别就是它使用 D 类 IP 地址为目的地址，并且首部中的协议字段值是 2，表明使用网际组管理协议 IGMP 多播数据报也是“ 尽最大努力交付 ”，不保证一定能够交付多播组内的所有成员。 对多播数据报不产生 ICMP 差错报文。因此，若在 PING 命令后面键入多播地址，将永远不会收到响应。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:6:1","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"在局域网上进行硬件多播 MAC 地址开头：01-00-5E，表明其为多播地址 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:6:2","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"网际组管理协议 IGMP 和多播路由选择协议 这是 IP 多播需要的两种协议 网际组管理协议 IGMP IGMP 使多播路由器知晓多播组成员信息 多播路由选择协议 大概不考 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/:6:3","tags":["计算机网络"],"title":"计算机网络 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/4.-%E7%BD%91%E7%BB%9C%E5%B1%82/"},{"categories":["专业课"],"content":"运输层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:0:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"运输层协议概述 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:1:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"进程之间的通信 概念 运输层属于面向通信部分的最高层，也是用户功能中的最底层 网络层提供了主机间的逻辑通信，运输层为应用进程间提供了逻辑通信（端到端） 作用 基于端口的复用和分用 复用 ：发送方的不同应用进程使用同一个运输层协议 分用 ：接收方的运输层把数据正确交付给目的进程 根据应用程序的不同需求，运输层需要有两种不同的运输协议，即面向连接的 TCP 和无连接的 UDP 可靠信道的含义：无差错、按序（接收和发送的顺序）、无丢失、无重复 不可靠的含义：不保证交付。接收时不按序、可能出现丢失和重复 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:1:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"运输层的两个主要协议 用户数据报协议 UDP (User Datagram Protocol） 传输控制协议 TCP (Transmission Control Protocol) ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:1:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"运输层的端口 为了使不同操作系统的进程能够相互通信，必须用统一的方法对应用进程进行标志 端口就是运输层服务访问点 TSAP，运输层的复用和分用功能依赖端口来完成。 端口号（Protocol port number）：16 位二进制数，只具有本地意义 如何找进程？IP 地址 + 端口号 服务器端使用的端口号 熟知端口：0-1023，所有用户进程都知道 登记端口号：1024-49151，需要在 IANA 登记，以防重复 客户端使用的端口号 短暂端口号：49152-65535，，留给客户进程选择暂时使用 常用的熟知端口 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:1:3","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"用户数据报协议 UDP ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:2:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"概述 定义 UDP 只在 IP 的数据报服务之上增加了很少一点的功能 复用和分用的功能 差错检测的功能 主要特点 无连接，发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。 尽最大努力交付， 即不保证可靠交付， 因此主机不需要维持复杂的连接状态表。 面向报文。 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。 没有拥塞控制， 因此网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用 IP 电话、视频会议是很重要的。 支持一对一、一对多、多对一和多对多的交互通信。 首部开销小， 只有 8 个字节，比 TCP 的 20 个字节的首部要短 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:2:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"首部格式 UDP 有两个字段 ：数据字段和首部字段。首部字段很简单，只有 8 个字节 首部字段 4 个字段组成，每个字段都是 2 个字节：源端口、目的端口、长度、校验和 在计算检验和时，临时把 “伪首部” 和 UDP 用户数据报连接在一起。伪首部仅仅是为了计算检验和。 校验和 IP 的校验和只校验了 IP 数据报的首部； UDP 的校验和，检查了： UDP 数据报的源端口、目的端口； UDP 数据报的数据部分； IP 数据报的源地址和目的地址。 校验方法：与伪首部、数据一起计算二进制反码校验和，循环进位，最后取反。（不要求） 队列工作原理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:2:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"传输控制协议 TCP ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:3:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"最主要的特点 面向连接 每一条 TCP 连接只能有两个端点 (endpoint)，每一条 TCP 连接只能是点对点的（一对一）。 提供可靠交付的服务。数据无差错、不丢失、不重复，并且按序到达。 全双工通信 面向字节流 TCP 中的 “流 ”（stream）指的是流入或流出进程的字节序列。 “面向字节流” 的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据看成仅仅是一连串无结构的字节流 TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系 。但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:3:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"首部格式 见 5.5 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:3:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"连接 TCP 把连接作为最基本的抽象。每一条 TCP 连接有两个 点。 TCP 连接的端点不是主机，不是主机的 IP 地址，不是应用进程，也不是运输层的协议端口。 TCP 连接的端点叫做套接字 (socket) 或插口 端口号拼接到 （contatenated with） IP 地址即构成了套接字。 套接字 TCP 连接就是由协议软件所提供的一种抽象。 TCP 连接的端点是个很抽象的套接字，即（ IP 地址：端口号） 同一个 IP 地址可以有多个不同的 TCP 连接 同一个端口号也可以出现在多个不同的 TCP 连接中 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:3:3","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"可靠传输的工作原理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:4:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"停止等待协议 发送完一个分组就停止发送等待确认，一旦出现传输差错（检测差错被丢弃或丢失），则超时重传 出现差错的情况 确认丢失、确认迟到 确认丢失：B 向 A 发送的确认丢失了 A （在超时计时器到期后）重传，B 丢弃这个重传的分组，并向 A 再次发送确认 确认迟到：B 向 A 发送的确认迟到了 A （在超时计时器到期后）重传后收到迟到的确认，将其丢弃，B 丢弃这个重传的分组，并再次确认 注意 在发送完一个分组后，必须暂时保留已发送的分组的副本，以备重发。 分组和确认分组都必须进行编号。 超时计时器的重传时间应当比数据在分组传输的平均往返时间更长一些。 自动重传请求 ARQ （Automatic Repeat reQuest） 重传的请求是自动进行的，接收方不需要请求发送方重传某个出错的分组 使用这样的确认和重传机制，就可以在不可靠的传输网络上实现可靠通信 信道利用率 信道利用率 $U=\\frac{T_D}{T_D+RTT+T_A}$ 流水线运输 发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。这样可使信道上一直有数据不间断地传送 由于信道上一直有数据不间断地传送，这种传输方式可获得很高的信道利用率。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:4:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"连续 ARQ 协议 发送方维持一个发送窗口 位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。这样，信道利用率就提高了 。 连续 ARQ 协议规定，发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置 上图没有用到累计确认 累计确认 接收方一般采用累计确认的方式，即不必对收到的分组逐个发送确认，而是对按序到达的最后一个分组发送确认，表示这个分组之前的所有分组都已正确收到了 优点：容易实现，即使确认丢失也不必重传（因为后续确认已经发送） 缺点：不能向发送方反映所有正确收到的分组（回退），序号位数多，重传代价高 Go back N （回退 N） 如果发送方发送了前 5 个分组，而中间的第 3 个分组丢失了。这时接收方只能对前两个分组发出确认。发送方无法知道后面三个分组的下落，而只好把后面的三个分组都再重传一次。 这就是回退 N，表示需要再退回来重传已发送过的 N 个分组 可见当通信线路质量不好时，连续 ARQ 协议会带来负面的影响。 不缓存失序的分组 步骤 发送端： 在发送完一个分组后，不是停下来等待确认分组，而是可以连续再发送若干个分组。 如果这时收到了接收端发来的确认，那么还可以接着发送分组。 如果在超时时间到时，仍然没有收到相应分组的确认，则重新从这个分组开始传起 (Go back N) 。 接收端：只按序接收分组 当接收到一个有差错的分组时，丢弃该分组和它以后的所有分组，让它们在发送端超时，然后重复发送已发送过的最后一个确认分组。 发送窗口的最大值 当用 n 比特进行分组的编号时，接收窗口 W~R~ = 1；只有在发送窗口 $W_T \\le 2^n - 1$ 时，连续 ARQ 协议才能正确运行 例：当 n = 3 时，发送窗口的最大值是 7 而不是 8 用反例证明： 若发送窗口大小为 8 ，则分组编号为 0 - 7 状态 1: 所有确认分组都到达了发送端，此时发送端又发送 8 个新分组，编号为 0~7 ，接收端认为是新分组 状态 2: 所有确认分组丢失，发送端超时后重发 0~7 号分组，接收端同样将其当作新分组接收（实际是重传的旧分组）。 小窗口 ARQ 信道利用率 $U=\\frac{n\\times T_D}{T_D+RTT+T_A}$ ，大窗口信道利用率为 1 通常连续 ARQ 的接收窗口大小 Wr 为1 选择重传 ARQ 协议 连续 ARQ 协议的问题 ：当线路的出错率高时，将出错帧之后的所有帧都丢弃掉，重传这些帧会带来效率上的大幅度降低。 加大接收窗口 ，使得 W~R~ \u003e 1 。先收下发送序号不连续但仍处在接收窗口中的那些数据帧。等到所缺序号的数据帧收到后再一并送交主机。这就是选择重传 ARQ 协议 。 接收窗口的尺寸不能超过 2^n-1^ （即序号范围的 1/2 ），否则可能造成帧的重叠。发送窗口的尺寸一般和接收窗口的尺寸相同。 优点 ：避免重复传送那些本来已经正确到达接收端的数据帧。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:4:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 报文段的首部格式 前 20 位固定字节 + 4n 字节可选项 源端口和目的端口字段 各占 2 字节。 端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。 序号字段 seq 占 4 字节。 TCP 连接中传送的数据流中的每一个字节都编上一个序号。 序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。 确认号字段 ack 占 4 字节 是期望收到对方的下一个报文段的数据的第一个字节的序号。 若确认号 = N，表明：到序号 N - 1 为止的所有数据都已正确收到 以下字段了解即可 数据偏移（即首部长度） 占 4 位 它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。 “数据偏移”的单位是 32 位字（以 4 字节为计算单位） 保留字段 占 6 位，保留为今后使用，但目前应置为 0 紧急 URG 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送 相当于高优先级的数据 确认 ACK 只有当 ACK = 1 时确认号字段才有效。 当ACK = 0 时，确认号无效。 推送 PSH (PuSH) 接收 TCP 收到 PSH = 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。 复位 RST ( ReSeT ) 当 RST = 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。 同步 SYN 同步 SYN = 1 表示这是一个连接请求或连接接受报文。 终止 FIN ( FINish ) 用来释放一个连接。 FIN = 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接。 窗口字段 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。 检验和 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 紧急指针字段 占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。 选项字段 长度可变。 TCP 最初只规定了一种选项，即 最大报文段长度 MSS 。 MSS 告诉对方 TCP ：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。” 填充字段 这是为了使整个首部长度是 4 字节的整数倍。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:5:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 的运输连接管理 TCP 是面向连接的协议 运输连接有三个阶段： 连接建立 数据传送 连接释放 运输连接有三个问题 每一方要能够确知对方存在 允许协商参数 能够对运输实体资源进行分配 采用方式：客户-服务器方式 运输连接的管理就是使运输连接的建立和释放都能正常地进行 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:6:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 连接的建立 三报文握手 客户：同步 SYN=1，seq=x 服务器：SYN=1，ACK=1，seq=y，ack=x+1 客户：ACK=1，seq=x+1，ack=y+1 作用：防止已经失效的连接请求报文突然又传送到了 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:6:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 的连接释放 四报文握手 客户：FIN=1，seq=u 服务器：ACK=1，seq=v，ack=u+1 服务器单向数据传送 服务器：FIN=1，ACK=1，seq=w，ack=u+1 客户：ACK=1，seq=u+1，ack=w+1 TCP连接必须经过两倍**最长报文段寿命（MSL）**后才真正释放 为了保证 A 的 ACK 报文到达 B，并防止已失效的连接请求已经消失 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:6:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 可靠传输的实现 TCP 在不可靠的 IP 服务上建立可靠的数据传输 接收方 累计确认，仅在正确按序收到报文段后，跟新确认序号；其余情况，重复前一次的确认序号 失序报文处理：缓存失序的报文段 发送方 发送策略：流水线 定时器：仅对最早那个未确认报文段使用重传计时器 重发策略：仅在超时后重发最早未确认的报文段 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:7:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"以字节为单位的滑动窗口 步骤 发送缓存与接收缓存的作用 发送缓存用来暂时存放： 发送应用程序传送给发送方 TCP 准备发送的数据； TCP 已发送出但尚未收到确认的数据。 接收缓存用来暂时存放： 按序到达的、但尚未被接收应用程序读取的数据； 不按序到达的数据。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:7:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"超时重传时间的选择 不考 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:7:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"选择确认 SACK 不考 快速重传？ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:7:3","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"总结 GBN、SR、TCP 的区别 GBN：回退 N (go back N),如果某个报文段没有被正确的接收，那么从这个报文段到后面的报文段都要重新发送，返回的ACK采用剋及确认的机制，也就是说如果GBN返回的ACK=3，也就是说3报文段和3 之前的报文段都被正确地接收了 SR：接收方设置缓冲区，为每个报文段设置计时器，如果某个报文段没有被正确接收但是后面的报文段被正确接收了，那么就只需要重发这一个报文段，在接收方整理排序之后就?了，返回的ACK就是当前接收成功的报文段序号 TCP：和 SR 类似，但是 TCP 有快速重传机制，不需要等待某个报文段的计时器超时才能重传，返回的ACK编号是期待接收到的下一个报文的序号 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:7:4","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 的流量控制 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:8:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"利用滑动窗口实现流量控制 接收方通过控制窗口大小来间接地控制发送速率 流量控制（flow control）就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞 利用滑动窗口机制可以很方便地在 TCP 连接上实现流量控制。 接收方动态地调整自己的窗口大小，通过 rwnd 字段通知发送方。 举例 死锁 了解 B 向 A 发送了零窗口的报文段后不久， B 的接收缓存又有了一些存储空间 。于是 B 向 A 发送了 rwnd = 400 的 报文段 。 但这个报文段在传送过程中丢失了，A 一直等待收到 B 发送 的非零窗口的通知， 而 B 也一直等待 A 发送的数据 如果没有其他措施，这种互相等待的死锁局面将一直延续下去 。 为了解决这个问题， TCP 为每一个连接设有一个持续计时器（persistence） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:8:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 的拥塞控制 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:9:0","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"拥塞控制的一般原理 在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种现象称为拥塞（congestion) 。 若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降 。 出现拥塞的原因：∑ 对资源需求 \u003e 可用资源 拥塞常常趋于恶化，并使网络性能变坏。 拥塞控制设计全部主机路由器，而流量控制只关注某一条链路 拥塞控制的常用方法 网络辅助的拥塞控制 路由器 端到端拥塞控制 TCP 采用的方式，端系统自行推断拥塞的产生 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:9:1","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"TCP 的拥塞控制方法 发送方如何感知拥塞 拥塞造成丢包和分组延迟增大，发送方丢过丢包时间来判断拥塞 重传定时器超时 收到三个相同（重复）的 ACK 发送方采用什么机制限制发送速率？ 发送方维持一个拥塞窗口 cwnd 来限制发送窗口，从而间接控制发送速度 拥塞窗口动态变化，取决于网络的拥塞程度 调节策略：AIMD 拥塞避免 乘法减小 发送包检测到丢包后，cwnd 大小减半 加法增大 若无丢包，每经过一个 RTT，将 cwnd 增大一个 MSS，直到检测到丢包 慢开始/慢启动 在新建连接上指数增大 cwnd，直到检测到丢包 设置慢开始门限状态变量 ssthresh 当 cwnd \u003c ssthresh 时，使用慢开始算法。 当 cwnd \u003e ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。 当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法 当遇到丢包时，ssthresh 变为当前 cwnd 的一半 区分不同的丢包事件 超时：网络交付能力差 cwnd 直接降到初始值，然后指数增大 收到重复三个 ACK：网络仍有一定交付能力 cwnd 减半，然后加法增大，是为快重传、快恢复 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/:9:2","tags":["计算机网络"],"title":"计算机网络 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/5.-%E8%BF%90%E8%BE%93%E5%B1%82/"},{"categories":["专业课"],"content":"概述 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:0:0","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"认识 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:1:0","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"物理层 我们的电脑要与外界互联网通信，需要先把电脑连接网络，我们可以用双绞线、光纤、无线电波等方式。这就叫做”实物理层”，它就是把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送 0 和 1 的电信号。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:1:1","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"数据链路层 单纯的 0 和 1 没有任何意义，所以我们使用者会为其赋予一些特定的含义，规定解读电信号的方式：例如：多少个电信号算一组？每个信号位有何意义？这就是”数据链接层”的功能，它在”物理层”的上方，**确定了物理层传输的 0 和 1 的分组方式及代表的意义。**早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。 以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。其中”标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。”标头”的长度，固定为 18 字节。”数据”的长度，最短为 46 字节，最长为 1500 字节。因此，整个”帧”最短为 64 字节，最长为 1518 字节。如果数据很长，就必须分割成多个帧进行发送。 那么，发送者和接受者是如何标识呢？以太网规定，连入网络的所有设备都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做 MAC 地址。每块网卡出厂的时候，都有一个全世界独一无二的 MAC 地址，长度是 48 个二进制位，通常用 12 个十六进制数表示。前 6 个十六进制数是厂商编号，后 6 个是该厂商的网卡流水号。有了 MAC 地址，就可以定位网卡和数据包的路径了。 我们会通过 ARP 协议来获取接受方的 MAC 地址，有了 MAC 地址之后，如何把数据准确的发送给接收方呢？其实这里以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机都发送，让每台计算机读取这个包的”标头”，找到接收方的 MAC 地址，然后与自身的 MAC 地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:1:2","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"网络层 按照以太网协议的规则我们可以依靠 MAC 地址来向外发送数据。理论上依靠 MAC 地址，你电脑的网卡就可以找到身在世界另一个角落的某台电脑的网卡了，但是这种做法有一个重大缺陷就是以太网采用广播方式发送数据包，所有成员人手一”包”，不仅效率低，而且发送的数据只能局限在发送者所在的子网络。也就是说如果两台计算机不在同一个子网络，广播是传不过去的。这种设计是合理且必要的，因为如果互联网上每一台计算机都会收到互联网上收发的所有数据包，那是不现实的。 因此，必须找到一种方法区分哪些 MAC 地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。 **“网络层”出现以后，每台计算机有了两种地址，一种是 MAC 地址，另一种是网络地址。**两种地址之间没有任何联系，MAC 地址是绑定在网卡上的，网络地址则是网络管理员分配的。**网络地址帮助我们确定计算机所在的子网络，MAC 地址则将数据包送到该子网络中的目标网卡。**因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理 MAC 地址。 **规定网络地址的协议，叫做 IP 协议。**它所定义的地址，就被称为 IP 地址。目前，广泛采用的是 IP 协议第四版，简称 IPv4。IPv4 这个版本规定，网络地址由 32 个二进制位组成，我们通常习惯用分成四段的十进制数表示 IP 地址，从 0.0.0.0 一直到 255.255.255.255。 根据 IP 协议发送的数据，就叫做 IP 数据包。IP 数据包也分为”标头”和”数据”两个部分：”标头”部分主要包括版本、长度、IP 地址等信息，”数据”部分则是 IP 数据包的具体内容。IP 数据包的”标头”部分的长度为 20 到 60 字节，整个数据包的总长度最大为 65535 字节。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:1:3","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"传输层 有了 MAC 地址和 IP 地址，我们已经可以在互联网上任意两台主机上建立通信。但问题是同一台主机上会有许多程序都需要用网络收发数据，比如 QQ 和浏览器这两个程序都需要连接互联网并收发数据，我们如何区分某个数据包到底是归哪个程序的呢？也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。 “端口”是 0 到 65535 之间的一个整数，正好 16 个二进制位。0 到 1023 的端口被系统占用，用户只能选用大于1023 的端口。有了 IP 和端口我们就能实现唯一确定互联网上一个程序，进而实现网络间的程序通信。 我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做 UDP 协议，它的格式几乎就是在数据前面，加上端口号。UDP 数据包，也是由”标头”和”数据”两部分组成：”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。UDP 数据包非常简单，”标头”部分一共只有 8 个字节，总长度不超过 65,535 字节，正好放进一个 IP 数据包。 UDP 协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。为了解决这个问题，提高网络可靠性，TCP 协议就诞生了。TCP 协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP 数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常 TCP 数据包的长度不会超过 IP 数据包的长度，以确保单个 TCP 数据包不必再分割。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:1:4","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"应用层 应用程序收到”传输层”的数据，接下来就要对数据进行解包。由于互联网是开放架构，数据来源五花八门，必须事先规定好通信的数据格式，否则接收方根本无法获得真正发送的数据内容。”应用层”的作用就是规定应用程序使用的数据格式，例如我们 TCP 协议之上常见的 Email、HTTP、FTP 等协议，这些协议就组成了互联网协议的应用层。 如下图所示，发送方的 HTTP 数据经过互联网的传输过程中会依次添加各层协议的标头信息，接收方收到数据包之后再依次根据协议解包得到数据。 互联网：专有名词 互连网：通用网络 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:1:5","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"互联网的组成 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:2:0","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"边缘部分 由所有连接在互联网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。 端系统之间的两种通信方式 客户-服务器方式（C/S） 客户是服务的请求方，服务器是服务的提供方 客户软件的特点 被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址 不需要特殊的硬件和很复杂的操作系统 服务器软件的特点 一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址 一般需要强大的硬件和高级的操作系统支持 对等方式（P2P） 不区分客户和服务器。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:2:1","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"核心部分 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换） 在网络核心部分起特殊作用的是路由器 (router)。 路由器是实现分组交换 (packet switching) 的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 分组交换是网络核心部分最重要的功能 电路交换 $N$ 部电话机两两直接相连，需 $N(N – 1)/2$ 对电线。这种直接连接方法所需要的电线对的数量与电话机数量的平方（ $N^2$ ）成正比。 当电话机的数量增多时，就要使用交换机来完成全网的分组任务，这就是电路交换 特点 电路交换必定是面向连接的 电路交换分为三个阶段： 建立连接：建立一条专用的物理通路，以保证双方通话时所需的通信资源在通信时不会被其他用户占用； 通话：主叫和被叫双方一直占用通信资源； 释放连接：释放刚才使用的这条专用的物理通路（释放刚才占用的所有通信资源） 总结 电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10% 分组交换 分组交换采用存储转发技术 步骤 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 (packet) 分组交换网以“分组”（也称为“包”，首部也可称为“包头”）作为数据传输单元，依次把各分组发送到接收端（假定接收端在左边） 接收端收到分组后剥去首部还原成报文 最后，在接收端把收到的数据恢复成为原来的报文。 首部的重要性 每一个分组的首部都含有地址（诸如目的地址和源地址）等控制信息。 分组交换网中的结点交换机根据收到的分组首部中的地址信息，把分组转发到下一个结点交换机。 每个分组在互联网中独立地选择传输路径。（通过路由器） 用这样的存储转发方式，最后分组就能到达最终目的地。 路由器的作用 在路由器中的输入和输出端口之间没有直接连线。 路由器处理分组的过程是： 把收到的分组先放入缓存（暂时存储）； 查找转发表，找出到某个目的地址应从哪个端口转发； 把分组送到适当的端口转发出去。 优点 高效：在分组传输的过程中动态分配传输带宽，对通信链路是逐段占用 灵活：为每一个分组独立地选择最合适的转发路由 迅速：以分组作为传送单位，可以不先建立连接就能向其他主机发送分组。 可靠：保证可靠性的网络协议；分布式多路由的分组交换网，使网络有很好的生存性 缺点 分组在各结点存储转发时需要排队，这就会造成一定的时延。 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销 总结 每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 报文交换 在 20 世纪 40 年代，电报通信也采用了基于存储转发原理的报文交换 (message switching)。 报文交换的时延较长，从几分钟到几小时不等。现在报文交换已经很少有人使用了。 三种交换的比较 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:2:2","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"核心与边缘 互联网的核心部分是由许多网络和把它们互连起来的路由器组成，而主机处在互联网的边缘部分。 互联网核心部分中的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分则通常以相对较低速率的链路相连接。 主机的用途是为用户进行信息处理的，并且可以和其他主机通过网络交换信息。路由器的用途则是用来转发分组的，即进行分组交换的。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:2:3","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"计算机网络的分类 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:3:0","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"按照网络的作用范围进行分类 广域网 WAN (Wide Area Network)：作用范围通常为几十到几千公里（跨越国家），是互联网的核心部分。 城域网 MAN (Metropolitan Area Network)：作用距离约为 5 ~ 50 公里（几个街区甚至整个城市）。 局域网 LAN (Local Area Network) ：局限在较小的范围（如 1 公里左右），校园网或企业网。 个人区域网 PAN (Personal Area Network) ：范围很小，大约在 10 米左右，通过无线技术连接。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:3:1","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"按照网络的使用者进行分类 公用网 (public network) 电信公司建造的大型网络。按 规定交纳费用的人都 可以 使用的 网络。因此也可称为公众网。 专用网 (private network) 某个单位 为特殊业务工作的需要而建造的网络 ，例 如军队、铁路、银行、电力等系统。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:3:2","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"用来把用户接入到互联网的网络 接入网 AN (Access Network) 又称为本地接入网或居民接入网。 接入网是一类比较特殊的计算机网络 ，用于将用户接入互联网。 只是起到让用户能够与互联网连接的“桥梁”作用。 使用不同接入网技术，如电话线拨号、宽带 接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分。 接入网是从某个用户端系统到互联网中的第一个路由器（也称为边缘路由器）之间的一种网络。 从覆盖的范围看，很多接入网还是属于局域网。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:3:3","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"计算机网络的性能 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:4:0","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"性能指标 速率 连接在计算机网络上的主机在数字信道上传送数据位数的速率，也称为数据率 (data rate) 或比特率 (bit) 速率的单位是 bit/s ，或 kbit /s 、 Mbit/s 、 Gbit /s 等。例如 $4 \\times 10^{10} bit/s$ 的数据率就记为 40 Gbit /s 。 带宽 带宽 (bandwidth) 用来表示网络中某通道传送数据的能力 。 表示在单位时间内网络中的某信道所能通过的“ 最高数据率 ”。 更常用的带宽单位是 千比特每秒 ，即 kb/s (10^3^ b/s ) 兆比特每秒 ，即 Mb/s (10 ^6^ b/s ) 吉比特每秒 ，即 Gb/s (10^9^ b/s ) 太比特每秒 ，即 Tb/s (10^12^ b/s ) 吞吐量 吞吐量 (throughput) 表示在单位时间内通过某个网络（或信道、接口）的数据量，包括进和出 时延 时延 (delay 或 latency) 是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间 有时也称为延迟或迟延 网络中的时延由以下几个不同的部分组成 发送时延 发送数据时，数据帧从结点进入到传输媒体所需要的时间。 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 发送时延 = 数据帧长度 (bit) / 发送速率（bit/s) 传播时延 电磁波在信道中需要传播一定的距离而花费的时间。 传播时延 = 信道长度（米) / 信号在信道上的传播速率 (米/秒) 处理时延 主机或路由器在收到分组时，为处理分组（例如分析首部、提取数据、差错检验或查找路由 ）所花费的时间 排队时延 分组在路由器输入、输出队列中排队等待处理所经历的时延。 排队时延的长短往往取决于网络中当时的通信量。 队列溢出时，相当于排队时延无限大。 时延带宽积 链路的时延带宽积又称为以比特为单位的链路长度。 时延带宽积 = 传播时延 × 带宽 往返时间 RTT (Round Trip Time) 往返时间 表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 利用率 信道利用率 指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。 网络利用率 全网络的信道利用率的加权平均值。 信道利用率并非越高越好。 当某信道的利用率增大时，该信道引起的时延也就迅速增加 。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:4:1","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"非性能特征 （nonperformance characteristics） 费用 (cost) 质量 (quality of service) (QoS) 标准化 可靠性 (reliability) 可扩展性 (scalability)和可升级性 (upgradability) 易于管理和维护 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:4:2","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"计算机网络的体系结构 （协议分层）TCP/IP、OSI、五层 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:5:0","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"计算机网络体系结构的形成 开放系统互连基本参考模型 OSI/RM (Open Systems Interconnection Reference Model) Model)，简称为 OSI 。 法律上的 (de jure) 国际标准 OSI 并没有得到市场的认可，非国际标准 TCP/IP 却获得了最广泛的应用。TCP/IP 常被称为 事实上的 (de facto) 国际标准 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:5:1","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"协议与划分层次 网络协议 (network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。 网络协议的三个组成要素 语法： 数据与控制信息的结构或格式 。 语义： 需要发出何种控制信息，完成何种动作以及做出何种响应。 同步： 事件实现顺序的详细说明。 层次式协议结构 划分层次的概念举例：主机 1 向主机 2 通过网络发送文件。 分层的优劣 优点 各层之间是独立的。 灵活性好。 结构上可分割开。 易于实现和维护。 能促进标准化工作。 缺点 降低效率 有些功能会在不同的层次中重复出现，因而产生了额外开销 。 层数控制 层数太少，就会使每一层的协议太复杂。 层数太多，又会在描述和综合各层功能的系统工程任务时遇到较多的困难。 各层完成的主要功能 差错控制：使相应层次对等方的通信更加可靠。 流量控制：发送端的发送速率必须使接收端来得及接收，不要太快。 分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原。 复用和分用：发送端几个高层会话复用一条低层的连接，在接收端再进行分用。 连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后释放连接。 计算机网络的体系结构 计算机网络的体系结构 (architecture) 是计算机网络的各层及其协议的集合。 体系结构就是这个计算机网络及其部件 所应完成的功能的精确定义。 实现 (implementation) 是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。 体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:5:2","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"具有五层协议的体系结构 采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 应用层 (application layer) 通过应用进程间的交互来完成特定网络应用 域名系统 DNS ，万维网 HTTP 协议，电子邮件 SMTP 协议 运输层 (transport layer) 向两台主机中进程之间的通信提供通用的数据传输服务 传输控制协议 TCP 、用户数据报协议 UDP 网络层 (network layer) 为分组交换网上的不同主机提供通信服务；选择合适的路由 网际协议 IP 和路由选择协议 数据链路层 (data link layer) 两个相邻节点之间传送数据 物理层 (physical layer) 传输数据单位为比特，要考虑多大的电压代表 1 或 0 不包含物理媒介 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:5:3","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"实体、协议、服务和服务访问点 实体 (entity) 表示任何可发送或接收信息的硬件或软件进程。 协议是控制两个对等实体进行通信的规则的集合。 语法规则定义了信息的格式，语义规则定义了发送者或接收者所要完成的操作 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。 要实现本层协议，还需要使用下层所提供的服务 协议和服务的关系 协议的实现保证了能够向上一层提供服务 。 本层的服务用户只能看见服务而无法看见下面的协议。即下面的协议对上面的服务用户是透明的。 协议 是 “水平的 ”，即协议是控制对等实体之间通信的规则。 服务 是 “垂直的 ”，即服务是由下层向上层通过层间接口提供的。 上层使用下层提供的服务必须通过服务原语。 服务访问点 同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point) 。 服务访问点 SAP 是一个抽象的概念，它实际上就是一个逻辑接口 。 OSI 把层与层之间交换的数据的单位称为服务数据单元 SDU (Service Data)。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:5:4","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"TCP/IP 的体系结构 它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层 沙漏型协议族 IP over everything ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/:5:5","tags":["计算机网络"],"title":"计算机网络 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/1.-%E6%A6%82%E8%BF%B0/"},{"categories":["专业课"],"content":"输入输出系统 主机与外设的传输原理 输入：外设送到主机 输出：主机送到外设 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:0:0","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"外围设备的定时方式和信息交换方式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:1:0","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"外围设备的速度分级 外设种类繁多，存在以下几种情况： 不同种类的外设数据传输速率差别很大 同一种设备在不同时刻传输速率也可能不同 高速的 CPU 与速度参差不齐的外设怎样在时间上同步呢？ 解决办法时在 CPU 和外设之间数据传送时加以定时。 外设的分级 速度极慢或简单的外设 机械开关、显示二极管 CPU 只需要接受或者发送数据即可 慢速或者中速的设备 可以采用异步定时的方式 高速外设 采用同步定时方式，成组数据传输 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:1:1","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"信息交换方式 程序查询方式 CPU 保持对外设的监听状态 程序中断方式 外设传送数据时向 CPU 汇报 DMA 方式（直接内存访问） 外设传送成组的数据，不需要向 CPU 汇报；传输完成后再汇报，将总线控制权还给 CPU 通道方式 使用专门的 I/O 处理器来协助 CPU 工作 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:1:2","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"程序查询方式 又叫程序控制 I/O 方式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:2:0","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"步骤 先向 I/O 设备发出命令字，请求进行数据传送 从 I/O 接口读入状态字 检查状态字中的标志，看看数据交换是否可以进行 （等）假如这个设备没有准备就绪，则第 (2)、第 (3) 步重复进行，一直到这个设备准备好交换数据，发出准备就绪信号 “Ready” 为止 CPU 从 I/O 接口的数据缓冲寄存器输入数据，或者将数据从 CPU 输出至接口的数据缓冲寄存器。与此同时， CPU 将接口中的状态标志复位 轮询 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:2:1","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"设备编址 统一编址 I/O 设备与内存单元联合在一起编排地址 不需要专门的 I/O 指令组 单独编址 I/O 设备地址与内存地址单独分开 I/O 设备要有专门的指令组 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:2:2","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"程序查询接口 设备选择电路 根据设备地址码选择外设 数据缓冲寄存器 缓冲数据 设备状态标志 标志设备的工作状态 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:2:3","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"程序中断方式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:3:0","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"中断的基本概念 中断（Interrupt）是指 CPU 暂时中止现行程序，转去处理随机发生的紧急事件，处理完后自动返回原程序的功能和技术。 中断系统是计机实现中断功能的软硬件总称。 一般在 CPU 中设置中断机构，在外设接口中设置中断控制器，在软件上设置相应的中断服务程序 中断处理过程注意几个问题： 响应中断时机：外界中断请求是随机的，但 CPU 只有在当前指令执行完毕后，才转至公操作 断点保护问题（PC，寄存器内容和状态的保存） 原子操作：开中断和关中断问题。 将中断屏蔽触发器置为 1，即关闭中断，不接收中断请求 中断是由软硬件结合起来实现的 中断分为内中断（异常）和外中断 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:3:1","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"程序中断方式的基本I/O接口 ① 表示由程序启动外设，将该外设接口的**“忙”标志 BS** 置 “1”，“准备就绪”标志 RD 清 “0”； ② 表示接口向外设发出启动信号； ③ 表示数据由外设传送到接口的缓冲寄存器； ④ 表示当设备动作结束或缓冲寄存器数据填满时，设备向接口送出一控制信号，将数据“准备就绪”标志 RD 置 “1”； ⑤ 表示允许中断标志 EI 为 “1” 时，接口向 CPU 发出中断请求信号； ⑥ 表示在一条指令执行末尾 CPU 检查中断请求线，将中断请求线的请求信号接收到**“中断请求”标志 IR**； ⑦ 表示如果**“中断屏蔽”标志 IM** 为 “0” 时，CPU 在一条指令执行结束后受理外设的中断请求，向外设发出响应中断信号并关闭中断； ⑧ 表示转向该设备的中断服务程序入口； ⑨ 表示在中断服务程序通过输入指令把接口中数据缓冲寄存器的数据读至 CPU 中的寄存器； ⑩ 表示 CPU 发出控制信号 C 将接口中的 BS 和 RD 标志复位 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:3:2","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"单级中断 有优先级，但不能嵌套 概念 所有中断源属于同一级，离 CPU 越近，优先级越高。 中断源的识别：串行排队链法 IR1，IR2，IR3 为中断请求信号 IS1，IS2，IS3 为中断选中信号 INTI 为中断排队输入 INTO 为中断排队输出 INTA？ 中断向量的产生 当 CPU 响应中断时，由硬件直接产生一个固定的地址 (即向量地址) 由向量地址指出每个中断源设备的中断服务程序入口，便于跳转，这种方法通常称为向量中断。 （好图，看 👆） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:3:3","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"多级中断（重要） 概念 每级有一个中断优先权 一维多级中断和二维多级中断 说明： 一个系统有 n 级中断，则 CPU 中有 n 个 IR，n 个 IM 某级中断被响应后，则关闭本级和低于本级的 IM，开放更高级的 IM。 多级中断可以嵌套，但同一级的中断不允许嵌套 中断响应时，确定哪一级中断和中断源采用硬件实现。采用了独立请求方式和链式查询方式相结合的方式。 使用多级堆栈保存现场（包括 IM） 中断屏蔽触发器合在一起，组成了中断屏蔽寄存器 多级中断源的识别 中断优先排队电路 中断向量产生电路 例 ==分析== 中断处理次序 / 优先级：在软件（中段处理程序）中设置 中断响应优先级：在硬件中设置 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:3:4","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"中断控制器（了解） 定义 8259 中断控制器是一个集成电路芯片，它将中断接口与优先级判断等功能汇集于一身，常用于微型机系统 8 位中断请求寄存器 (IR) 接受 8 个外部设备送来的中断请求，每一位对应一个设备。 中断请求寄存器的各位送入优先权判断器，根据中断屏蔽寄存器 (IM) 各位的状态来决定最高优先级的中断请求，并将各位的状态送入中断状态寄存器 IS。IS 保存着判优结果。由控制逻辑向 CPU 发出中断请求信号 INT，并接受 CPU 的中断响应信号 INTA。 数据缓冲器用于保存CPU内部总线与系统数据总线之间进行传送的数据。 读/写逻辑决定数据传送的方向，其中 IOR 为读控制，IOW 为写控制，CS 为设备选择，A0 为 I/O 端口识别。 优先级选择方式 完全嵌套方式 是一种固定优先级方式，连至IR0的设备优先级最高，IR7的优先级最低。这种固定优先级方式对级别低的中断不利，在有些情况下最低级别的中断请求可能一直不能被处理。 轮换优先级方式 A 每个级别的中断保证有机会被处理，将给定的中断级别处理完后，立即把它放到最低级别的位置上去。 轮换优先级方式 B 要求CPU可在任何时间规定最优优先级，然后顺序地规定其他IR线上的优先级。 查询方式 由CPU访问8259的中断状态寄存器，一个状态字能表示出正在请求中断的最高优先级IR线，并能表示出中断请求是否有效。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:3:5","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"DMA 方式 高速外设，同步定时，以数据块为单位进行批量传输 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:4:0","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"基本概念 **直接存储器访问（Direct Memory Address）**是为了在主存储器与 I/O 设备间高速交换批量数据而设置的。 基本思想 通过硬件控制实现主存与 I/O 设备间的直接数据传送，在传送过程中无需 CPU 的干预。数据传送是在 DMA 控制器控制下进行的 优点 速度快，有利于发挥 CPU 的效率。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:4:1","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"DMA 传送方式 停止 CPU 访问内存 （在 DMA 访内过程中，CPU 不能同时访内） 主机响应 DMA 请求后，让出存储总线，直到一组数据传送完毕后，DMA 控制器才把总线控制权交还给 CPU 采用这种工作方式的 I/O 设备，在其接口中一般设置有小容量存储器 I/O 设备先与小容量存储器交换数据，然后由小容量存储器与主机交换数据 这样可减少 DMA 传送占用存储总线的时间，也即减少了 CPU 暂停工作的时间 优点 控制简单，它适用于数据传输率很高的设备进行成组传送。 缺点 在 DMA 控制器访内阶段，内存的效能没有充分发挥，相当一部分内存工作周期是空闲的。这是因为，外围设备传送两个数据之间的间隔一般总是大于内存存储周期，即使高速 I/O 设备也是如此（故许多空闲的存储周期不能被 CPU 利用） 周期挪用方式 也叫周期窃取方式，CPU 没有完全放弃对主存的访问 DMA 控制器与主存储器之间传送一个数据，占用（窃取）一个 CPU 周期，即 CPU 暂停工作一个周期，然后继续执行程序 一次 DMA 传输（挪用）没办法将整个数据块传输完 DMA 与 CPU 交替访内 又称透明的 DMA 传输方式 如果 CPU 的工作周期比内存存取周期长很多，可以采用该种方法 总线控制权的转移速度快，DMA 效率高。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:4:2","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"基本的 DMA 原理 DMA 基本构成 内存地址计数器 用于存放内存中要交换的数据的地址 在DMA传送前，须通过程序将数据在内存中的起始位置(首地址)送到内存地址计数器。 而当DMA传送时，每交换一次数据，将地址计数器加“1”，从而以增量方式给出内存中要交换的一批数据的地址。 字计数器 用于记录传送数据块的长度(多少字数)。其内容也是在数据传送之前由程序预置，交换的字数通常以补码形式表示。 在 DMA 传送时，每传送一个字，字计数器就加“1” ， 当计数器溢出即最高位产生进位时，表示这批数据传送完毕，于是引起DMA控制器向CPU发中断信号 数据缓冲寄存器 用于暂存每次传送的数据(一个字)。 当输入时，由设备(如磁盘)送往数据缓冲寄存器，再由缓冲寄存器通过数据总线送到内存。 反之，输出时，由内存通过数据总线送到数据缓冲寄存器，然后再送到设备。 “DMA 请求” 标志 每当设备准备好一个数据字后给出一个控制信号，使 “DMA 请求” 标志置 “1”。 该标志置位后向“控制/状态”逻辑发出DMA请求，后者又向CPU发出总线使用权的请求(HOLD)，CPU 响应此请求后发回响应信号HLDA，“控制/状态”逻辑接收此信号后发出DMA响应信号，使“DMA请求”标志复位，为交换下一个字做好准备。 “控制/状态” 逻辑 由控制和时序电路以及状态标志等组成，用于修改内存地址计数器和字计数器，指定传送类型(输入或输出)，并对 “DMA 请求” 信号和 CPU 响应信号进行协调和同步。 中断机构 当字计数器溢出时 (全 0)，意味着一组数据交换完毕，由溢出信号触发中断机构，向 CPU 提出中断报告 这里的中断与上一节介绍的 I/O 中断所采用的技术相同，但中断的目的不同，前面是为了数据的输入或输出，而这里是为了报告一组数据传送结束。因此它们是 I/O 系统中不同的中断事件 DMA 数据传送过程 当外设有 DMA 请求时，通常 CPU 在本机器周期结束后，响应 DMA 请求 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:4:3","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"选择型和多路型 DMA 控制器 选择型 一段时间内只能为一个设备服务 多路型 例 下图中假设有磁盘、磁带、打印机三个设备同时工作。磁盘以 30μs 的间隔向控制器发 DMA 请求，磁带以 45μs 的间隔发 DMA 请求，打印机以 150μs 间隔发 DMA 请求。根据传输速率，磁盘优先权最高，磁带次之，打印机最低，图中假设DMA控制器每完成一次 DMA 传送所需的时间是 5μs。若采用多路型 DMA 控制器，请画出 DMA 控制器服务三个设备的工作时间图。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/:4:4","tags":["计算机组成原理"],"title":"计组 第八章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/8.-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"运算方法和运算器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:0:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"定点加法、减法运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:1:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"补码加法 [x+y]补=[x]补+[y]补 符号位运算丢进位 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:1:1","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"补码减法 减法变成加法来做 -y 的补码 = y 的补码所有位取反 +1 [x]补 - [y]补 = [x]补 + [-y]补 [-y]补 = -[y]补 + 2^-n^ （弱智方法，直接求 -y 的补码即可） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:1:2","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"溢出 概念 可能产生溢出的情况 两正数加，变负数，正溢（大于机器所能表示的最大数） 两负数加，变正数，负溢（小于机器所能表示的最小数） 检测方法 双符号位法（变形补码） 00为正，11为负，有下表 $S_{f1}$ $S_{f2}$ 判断 0 0 正数 0 1 正溢 1 0 负溢 1 1 负数 ​ $S_{f1},S_{f2}$为结果的双符号，关系为异或 单符号位法 $C_f$ $C_0$ 判断 0 0 正数 0 1 正溢 1 0 负溢 1 1 负数 ​ 其中$C_f$为符号位产生的进位，$C_0$为最高有效位产生的进位 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:1:3","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"定点乘法、除法运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:2:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"原码并行乘法 一般都用原码算 用绝对值算，且计算时不带符号位 原码阵列，结果是原码；补码阵列，结果变为补码 不带符号位的阵列乘法器 带符号的阵列乘法器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:2:1","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"定点除法 一般都用补码算 人工除法时，人可以比较被除数（余数）和除数的大小来确定商1（够减）或商0（不够减） 机器除法时，余数为正表示够减，余数为负表示不够减。不够减时必须恢复原来余数，才能继续向下运算。这种方法叫恢复余数法，控制比较复杂。 不恢复余数法（加减交替法） 余数为正，商1，下次除数右移做减法； 余数为负，商0，下次除数右移做加法。 控制简单，有规律 手工方案 不恢复余数法 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:2:2","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"浮点加法，减法运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:3:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"运算步骤 0 操作数检查； 比较阶码并完成对阶（小阶向大阶对齐）； 尾数加减运算； 结果规格化；（尾数右移一位，阶码加一） 舍入处理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:3:1","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"要点 用补码表示阶码和尾数 加减后溢出不是真正的溢出，规格化后才是真正的溢出 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:3:2","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:3:3","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"舍入处理（对阶和向右规格化时） 就近舍入（0舍1入）：类似”四舍五入”，丢弃的最高位为1，进1 朝0舍入：截尾 朝$+\\infty$舍入：正数多余位不全为”0”，进1；负数，截尾 朝$-\\infty$舍入：负数多余位不全为”0”，进1；正数，截尾 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:3:4","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"溢出判断和处理 阶码上溢，一般将其认为是$+\\infty$和$-\\infty$ 。 阶码下溢，则数值为0 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:3:5","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"浮点乘法，除法运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:4:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"运算步骤 操作数检查 阶码加减操作 尾数乘除操作 结果规格化和舍入处理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:4:1","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"IEEE754 标准 以32位为例 $$ x=(-1)^S\\times(1.M)\\times2^{E-127} $$ 基数 R=2，基数固定，采用隐含方式来表示它。 S：数的符号位，1位，在最高位，“0”表示正数，“1”表示负数。 M：尾数， 23位，在低位部分，采用纯小数表示。 E：是阶码，8位，采用移码表示。移码比较大小方便。 尾数域最左位(最高有效位)总是1， 故这一位经常不予存储，而认为隐藏在小数点的左边。 采用这种方式时，将浮点数的指数真值 e 变成阶码 E 时，应将指数 e 加上一个固定的偏移值127(01111111)，即 ==E=e+127==。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:5:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"机器码 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:6:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"总线 机器内部各部份数据传送频繁,可以把寄存器间的数据传送通路加以归并,组成总线结构。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:7:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"总线分类 所处位置 内部总线（CPU内） 外部总线（系统总线） 逻辑结构 单向传送总线 双向传送总线 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:7:1","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"定点运算器的组成 单总线结构的运算器 在同一时间只能有一个操作数在总线上 操作速度慢 控制电路简单 双总线结构的运算器 不能直接把输出加到总线 三总线结构的运算器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:7:2","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"流水线 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:8:0","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"原理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/:8:1","tags":["计算机组成原理"],"title":"计组 第二章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/2.-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"},{"categories":["专业课"],"content":"总线系统 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:0:0","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线的概念和结构形态 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:1:0","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线的基本概念 定义 计算机的若干功能部件之间不可能采用全互联形式，因此就需要有公共的信息通道，即总线 分类 内部总线：CPU 内部连接各寄存器及运算器部件之间的总线。 系统总线：外部总线。CPU 和计算机系统中其他高速功能部件相互连接的总线。 I/O 总线：中低速 I/O 设备相互连接的总线 特性 物理特性：物理连接方式 功能特性：64 位 blabla 电气特性：信号传递方向，有效电平范围 时间特性：每根总线在什么时间有效 标准化 总线标准，如 PCI、ISA 等 简化系统设计 简化系统结构，提高系统可靠性 便于系统的扩充和更新 总线带宽（重要） 总线本身所能达到的最高传输速率，单位 MB/s 一次操作可以传输的数据位数 如 S100 为 8 位，ISA 为 16 位，EISA 为 32 位，PCI-2 可达 64 位。 总线宽度不会超过微处理器外部数据总线的宽度。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:1:1","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线的连接方式 适配器（接口）：实现高速 CPU 与低速外设之间工作速度上的匹配和同步，并完成计算机和外设之间的所有数据传送和控制。 单总线 使用一条单一的系统总线来连接 CPU、内存和 I/O 设备 结构特点 在单总线结构中，要求连接到总线上的逻辑部件必须高速运行，以便在某些设备需要使用总线时，能迅速获得总线控制权 而当不再使用总线时，能迅速放弃总线控制权。否则，由于一条总线由多种功能部件共用，可能导致很大的时间延迟 多总线 在 CPU、主存、I/O之间互联采用多条总线 高速的 CPU 总线：CPU 和 cache 之间采用 系统总线：主存连在其上 高速总线上可以连接高速 LAN（100Mb/s局域网）、视频接口、图形接口、SCSI 接口（支持本地磁盘驱动器和其他外设）、Firewire接口（支持大容量I/O设备）。高速总线通过扩充总线接口与扩充总线相连，扩充总线上可以连接串行方式工作的I/O设备。 通过桥 CPU 总线、系统总线和高速总线彼此相连。桥实质上是一种具有缓冲、转换、控制功能的逻辑电路。 多总线结构体现了高速、中速、低速设备连接到不同的总线上同时进行工作，以提高总线的效率和吞吐量，而且处理器结构的变化不影响高速总线。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:1:2","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线的内部结构 地址线单向，数据线双向 早期总线结构的不足之处 CPU 是总线上惟一的主控者。即使后来增加了具有简单仲裁逻辑的 DMA 控制器以支持 DMA 传送，但仍不能满足多 CPU 环境的要求。 总线信号是 CPU 引脚信号的延伸，故总线结构紧密与 CPU 相关，通用性较差。 构成 数据传送总线：地址线、数据线、控制线 仲裁总线：总线请求线、总线授权线 中断和同步总线：中断请求线、中断认可线 公用线：CP线、电源线、地线、复位线等 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:1:3","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线接口 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:2:0","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"信息传送方式 串行（先低后高） 并行 分时（复用：既传地址又传数据） 串行 使用一条传输线，采用脉冲传送。 低位在前，高位在后 主要优点是只需要一条传输线，这一点对长距离传输显得特别重要，不管传送的数据量有多少，只需要一条传输线，成本比较低廉。 缺点就是速度慢 并行 每一数据位需要一条传输线，一般采用电位传送 分时 总线复用或是共享总线的部件分时使用总线 拆卸和装配 拆卸：并的数据拆成一位位 装配：一位位传数据组装起来 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:2:1","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线接口的基本概念 接口是 CPU 和主存、外设之间通过总线进行连接的逻辑部件 接口功能 控制、缓冲、状态、转换（串并）、整理、程序中断 分类 串行数据接口、并行数据接口 系统总线接口、外部设备接口 例 波特率：每秒传送 bit 位数，一般用于串行 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:2:2","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线的仲裁 一次总线操作：一主多从。多个 CPU 和 IO 模块竞争控制权，产生仲裁 为了解决多个功能模块争用总线的问题，必须设置总线仲裁部件 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:3:0","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"集中式仲裁 总线请求信号线 BR，总线授权/响应信号线 BG，busy 标志 BS 链式查询方式 越近的优先级越高 优点 线少 易扩充 缺点 是对询问链的电路故障很敏感 优先级固定 计数器定时查询方式 查询时，计数器开始计数，直到计数值与设备地址匹配 计数器从 0 开始同菊花链，从中止点开始优先级相等 特点 灵活 独立请求方式 n 条 BR 和 n 条 BG，排队电路根据优先次序决定响应 特点 速度快 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:3:1","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"分布式仲裁 每个主方都有仲裁号和仲裁器。仲裁总线上号最大的胜出，否则自动撤出。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:3:2","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线的定时和数据传送模式 总线传输信息步骤：请求总线、总线仲裁、寻址、信息传送、状态返回 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:4:0","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线定时 同步定时 事件出现由总线时钟信号确定。适用于总线长度短、存取时间相近的情况 异步定时 允许将快速和慢速的设备都连一起。不需要时钟信号，应答式。周期长度可变，但总线复杂成本高。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:4:1","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"总线数据传送模式 读、写操作：读操作两次竞争总线。 块传送操作：猝发式传送，连续读（写）四倍字长。 写后读、读修改写操作：用于校验和保护共享资源。 广播、广集操作：广播多从进行写操作；广集多从读进行逻辑与或检测中断。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/:4:2","tags":["计算机组成原理"],"title":"计组 第六章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/6.-%E6%80%BB%E7%BA%BF%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"外围设备 外围设备的功能是在计算机和其他机器之间，以及计算机与用户之间提供联系 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:0:0","tags":["计算机组成原理"],"title":"计组 第七章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":["专业课"],"content":"外围设备概述 基本组成：存储介质，驱动装置，控制电路 分类：输入设备、输出设备、外存设备、数据通信设备、过程控制设备 CPU主存 —\u003e IO —\u003e 外围设备控制器 —\u003e 外围设备 外围设备在设备控制器下工作，而设备控制器通过IO接口与主机连接 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:1:0","tags":["计算机组成原理"],"title":"计组 第七章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":["专业课"],"content":"磁盘存储设备（磁盘、磁带） 优点：存储容量大，位价格低；记录介质可以重复使用；记录信息长久保存不丢失，可以脱机；非破坏性读出。 缺点：存取速度慢，机械结构复杂，对工作环境要求高 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:2:0","tags":["计算机组成原理"],"title":"计组 第七章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":["专业课"],"content":"概念 记录面：盘片上下两面 磁道：记录面上同心圆（外 0 里 n） 扇区：记录一段定长信息，直接寻址的最小单位 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:2:1","tags":["计算机组成原理"],"title":"计组 第七章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":["专业课"],"content":"技术指标 存储密度 道密度：半径方向上单位长度磁道数（道/英寸） 位密度：磁道单位长度上能记录的二进制位数（位/英寸）（一个磁道存储的二进制位数/此磁道的周长） 面密度：位密度*道密度（位/英寸²） 存储容量：一个磁盘存储器所能存储的字节总数 格式化容量 \u003c 非格式化容量 平均存取时间 发出读写命令后，磁头从某一起始位置移动至新的记录位置，到开始从盘片表面读出或写入信息加上传送数据所需要的时间 找道时间 ：磁头定位到磁道上的时间（磁头动） 等待时间：找扇区所需的时间（磁头等，盘片转） 数据传送时间 $T_a=T_s+1/2r+b/rN$ r 为转速，b 为传送字节数，N 为每道字节数 数据传输率： $Dr=nN=D位⋅v线$ 磁盘旋转速度为 n 转/秒，每条磁道容量为 N 个字节 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:2:2","tags":["计算机组成原理"],"title":"计组 第七章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":["专业课"],"content":"显示设备 显示设备：以可见光的形式传递和处理信息的设备 分辨率：显示器能表示的像素个数，水平 × 垂直 灰度级：黑白显示器中所显示的像素点的亮暗差别 刷新：为了使人眼看到稳定的图像显示，电子束重复扫描屏幕的过程。 刷新存储器（视频存储器）容量：M = rC C=log2 灰度级数 记得转化为 B 提高刷存的方式：使用高速 DRAM，多体交叉，提升总线宽度，端口分离。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/:3:0","tags":["计算机组成原理"],"title":"计组 第七章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/7.-%E5%A4%96%E5%9B%B4%E8%AE%BE%E5%A4%87/"},{"categories":["专业课"],"content":"存储器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:0:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"存储器概述 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:1:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"存储器的分类 存储位元 (二进制代码位) -\u003e 存储单元 -\u003e 存储器 （了解） 按存储介质分类 磁表面 半导体存储器 按存取方式分类 随机 (访问数据的时间与数据在存储器中的位置无关) 顺序存取（磁带） 按读写功能分类 RAM：随机存储器，双极型/MOS ROM：只读存储器，MROM/PROM/EPROM/EEPROM 按信息的可保存性分类 永久性 非永久性 按存储器系统中的作用分类 主/辅/缓/控 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:1:1","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"存储器的分级 cache -\u003e 主存 -\u003e 辅存 速度变慢，容量变大 高速缓冲存储器 简称 cache，它是计算机系统中的一个高速小容量半导体存储器。 主存储器 简称主存，是计算机系统的主要存储器，用来存放计算机运行期间的大量程序和数据。能和 cache 交换数据和指令 外存储器 简称外存，它是大容量辅助存储器。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:1:2","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"主存储器的技术指标 （重要） 字存储单元：存放一个机器字的存储单元，相应的单元地址叫字地址。 一个字存储单元通常由多个存储单元组成 字地址指这个字首个字节的地址 字与字节没有明确关系 字节存储单元：存放一个字节的单元，相应的地址称为字节地址。 一个字节存储单元通常由一个存储单元组成（如果存储单元占 8 位的话） 存储容量：指一个存储器中可以容纳的存储单元总数。存储容量越大，能存储的信息就越多。 存取时间：又称存储器访问时间：指一次读操作命令发出到该操作完成，将数据读出到数据总线上所经历的时间。通常取写操作时间等于读操作时间，故称为存储器存取时间。 速度性指标 存储周期：指连续启动两次读操作所需间隔的最小时间。通常，存储周期略大于存取时间，其时间单位为 ns。 速度性指标 存储器带宽：单位时间里存储器所存取的信息量，通常以位/秒或字节/秒做度量单位。 速度性指标 按字节寻址/编址/访问：一字节（Byte）一地址 按字寻址/编址/访问：一（机器）字一地址 例： 1M × 8 位：$2^{20}$ 个存储单元（及其存储容量），每个存储单元占 8 位，存储单元地址共 20 位，相当于 1MB ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:1:3","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"SRAM 存储器 静态读写存储器，存储速度快，容量较小 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:2:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"基本的静态存储元阵列 存储位元 如图存储位元总数为 $64\\times 4=256$ 三组信号线 地址线 如图六条地址线指定了存储器容量是 $2^6=64$ 个存储单元 数据线 如图四条数据线指定了存储器的字长为 4 位 控制线 高电平读，低电平写 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:2:1","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"基本的 SRAM 逻辑结构 SRAM 芯大多采用双译码方式，以便组织更大的存储容量。采用了二级译码：将地址分成 x 向、y 向两部分 图示 15 位地址，8 位存储单元，即 32KB 8 位行地址，7 位列地址展开阵列 采用双译码的方式（减少选择线的数目） A0~A7 为行地址译码线 A8~A14 为列地址译码线 存储阵列的厚度即代表位数（8 位） 通常把各个字的同一个字的同一位集成在一个芯片（32K×1）中 32K 位排成 256×128 的矩阵 8 个片子就可以构成 32KB 读与写的互锁逻辑 控制信号中 CS 是片选信号，CS 有效时（低电平），门 G1、G2 均被打开。OE 为读出使能信号，OE有效时（低电平），门 G2 开启，当写命令WE = 1时（高电平），门 G1 关闭，存储器进行读操作。写操作时，WE = 0，门 G1 开启，门 G2 关闭。注意，门 G1 和 G2 是互锁的，一个开启时另一个必定关闭，这样保证了读时不写，写时不读。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:2:2","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"DRAM 存储器 动态读写存储器，存储速度慢，容量较大 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:3:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"DRAM芯片的逻辑结构 图示：1M × 4 位 DRAM 分时传送地址码 若地址总线宽度为 10 位，先传送地址码 A0～A9，由行选通信号 RAS 打入到行地址锁存器 然后传送地址码 A10～A19，由列选通信号 CRS 打入到列地址锁存器 增加了刷新计数器和相应的控制电路 DRAM 读出后必须刷新，而未读写的存储元也要定期刷新，而且要按行刷新 所以刷新计数器的长度等于行地址锁存器 刷新操作与读/写操作是交替进行的，所以通过 2 选 1 多路开关来提供刷新行地址或正常读/写的行地址。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:3:1","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"刷新周期 刷新周期 DRAM 存储位元是基于电容器上的电荷量存储，这个电荷量随着时间和温度而减少，因此必须定期地刷新，以保持它们原来记忆的正确信息 刷新方式 集中式刷新 DRAM 的所有行在每一个刷新周期中都被刷新。 例如刷新周期为 8ms 的内存来说，所有行的集中式刷新必须每隔8ms进行一次。为此将 8ms 时间分为两部分 前一段时间进行正常的读/写操作 后一段时间（8ms 至正常读/写周期时间）做为集中刷新操作时间。 分散式刷新 每一行的刷新插入到正常的读/写周期之中。 例如上图所示的 DRAM 有 1024 行，如果刷新周期为 8ms，则每一行必须每隔 8ms÷1024=7.8us 进行一次。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:3:2","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"存储器容量的扩充 字长位数扩展（位扩展） 1k × 4 位 -\u003e 1k × 16 位 ，4片 （位扩展，横向） 给定的芯片字长位数较短，不满足设计要求的存储器字长，此时需要用多片给定芯片扩展字长位数。 特点 地址线公用 控制线公用（所有芯片的片选信号、读信号、写信号拼在一起）公用 数据线单独分开连接 所需芯片数 d = 设计要求的存储器容量/选择芯片存储器容量 字存储容量扩展（字扩展） 1k × 4 位 -\u003e 4k × 4 位 ，4片 （字扩展，纵向） 给定的芯片存储容量较小（字数少），不满足设计要求的总存储容量，此时需要用多片给定芯片来扩展字数 特点 地址总线和数据总线公用，后面的地址总线来选择芯片，前面的地址总线选择此芯片的地址 控制总线中 R/W 公用，使能端 EN 不能共用 它由地址总线的高位段译码来决定片选信号。 字位扩展 1k × 4 位 -\u003e 4k × 16 位 ，16 片 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:3:3","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"并行存储器 为了提高 CPU 和主存之间的数据传输率，除了主存采用更高速的技术来缩短读出时间外，还可以采用并行技术的存储器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:4:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"双端口存储器 空间并行 逻辑结构 同一个存储器具有两组相互独立的读写控制电路 R/W：读写 OE：输出使能 CE：片选 A：11位地址线 I/O：16位数据线 无冲突读写控制 当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突 有冲突读写控制 当两个端口同时存取存储器同一存储单元时，便发生读写冲突 为解决此问题，特设置了 BUSY 标志。在这种情况下，片上的判断逻辑可以决定对哪个端口优先进行读写操作，而对另一个被延迟的端口置 BUSY 标志 (BUSY 变为低电平)，即暂时关闭此端口。 判断方式自学 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:4:1","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"多模块交叉存储器 时间并行，多个存储体来存储数据 存储器的模块化组织 一个由若干个模块组成的主存储器是线性编址的。 这些地址在各模块中如何安排，有两种方式：一种是顺序方式，一种是交叉方式 顺序方式 [例] M0－M3 共四个模块，则每个模块8个字 顺序方式： ​ M0：0—7 ​ M1：8－15 ​ M2：16－23 ​ M3：24－31 5位地址组织如下： X X X X X 高位选模块，低位选块内地址 特点：某个模块进行存取时，其他模块不工作，优点是某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。缺点是各模块串行工作，存储器的带宽受到了限制。 交叉方式 [例] M0－M3 共四个模块，则每个模块 8 个字 交叉方式： ​ M0：0，4,…除以4余数为0 ​ M1：1，5,…除以4余数为1 ​ M2：2，6,…除以4余数为2 ​ M3：3，7,…除以4余数为3 5位地址组织如下： X X X X X 高位选块内地址，低位选模块 特点：连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。优点是对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。缺点是不易扩展。 基本结构 右图为四模块交叉存储器结构框图。主存被分成 4 个相互独立、容量相同的模块 M0，M1，M2，M3，每个模块都有自己的读写控制电路、地址寄存器和数据寄存器，各自以等同的方式与 CPU 传送信息。在理想情况下，如果程序段或数据块都是连续地在主存中存取，那么将大大提高主存的访问速度 定量分析 通常在一个存储器周期内，n 个存储体必须分时启动，则各个存储体的启动间隔为 $t=T/n$（n为交叉存取度） 整个存储器的存取速度有望提高 n 倍 $$ t_{顺序}=xT \\ t_{交叉}=T+(x-1)t=T(\\frac{x+n-1}{n}) $$ 例：设存储器容量为 32 字，字长 64 位，模块数 m = 4，分别用顺序方式和交叉方式进行组织。存储周期 T = 200ns，数据总线宽度为 64 位，总线传送周期 = 50ns。若连续读出 4 个字，问顺序存储器和交叉存储器的带宽（单位时间内的传输量）各是多少? 解：顺序存储器和交叉存储器连续读出 m = 4 个字的信息总量都是： ​ q = 64b×4 = 256b ​ 顺序存储器和交叉存储器连续读出 4 个字所需的时间分别是： ​ t2 = mT = 4×200ns = 800ns = 8×10-7s ​ t1 = T + (m - 1) = 200ns + 350ns = 350ns = 35×10-7s ​ 顺序存储器和交叉存储器的带宽分别是： ​ W2=q/t2=256b÷(8×10-7)s=320Mb/s ​ W1=q/t1=256b÷(35×10-7)s=730Mb/s ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:4:2","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"Cache 存储器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:5:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"Cache 基本原理 功能 提高存储器反应速度，解决 CPU 和主存之间的速度不匹配问题 一般采用高速的 SRAM 构成。 CPU 和主存之间的速度差别很大，采用两级或多级 Cache 系统 早期的一级 Cache 在 CPU 内，二级在主板上 现在的 CPU 内带 L1 Cache 和 L2 Cache 全由硬件调度，对用户透明 基本原理 主存与 Cache 以块为单位进行数据交换（依据空间复杂性） CPU 则以字 (存储单元) 为单位访问 Cache，依据地址判断此字当前是否在 Cache 中 若是，直接传 否则，CPU 去主存找此字，同时主存把此字送到 Cache 中（依据时间复杂性） 地址映射 替换策略 写一致性 性能评价 命中率 从 CPU 来看，增加一个 cache 的目的，就是在性能上使主存的平均读出时间尽可能接近cache的读出时间。为了达到这个目的，在所有的存储器访问中由 cache 满足 CPU 需要的部分应占很高的比例，即 cache 的命中率应接近于 1。由于程序访问的局部性（局部性原理），实现这个目标是可能的 命中率公式 $$ 命中率： h=\\frac{N_c}{N_c+N_m} \\ Cache的平均访问时间： t_a=ht_c+(1-h)t_m \\ 访问效率： e=\\frac{t_c}{t_a}=\\frac{1}{r+(1-r)h} \\ 主存慢于Cache的倍率： r=\\frac{t_m}{t_c} $$ 例：CPU 执行一段程序时，cache 完成存取的次数为 1900 次，主存完成存取的次数为 100 次，已知 cache 存取周期为 50ns，主存存取周期为 250ns，求 cache / 主存系统的效率和平均访问时间。 解： $$ h=N_c/(N_c+N_m)=1900/(1900+100)=0.95 \\ r=t_m/t_c=250ns/50ns=5 \\ e=1/(r+(1-r)h)=1/(5+(1-5)×0.95)=83.3% \\ t_a=t_c/e=50ns/0.833=60ns \\ $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:5:1","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"主存与 Cache 的地址映射 映射的本质：主存块号变成 cache 行号 无论选择哪种映射方式，都要把主存和 cache 划分为同样大小的“块”。 选择哪种映射方式，要考虑： 硬件是否容易实现 地址变换的速度是否快 主存空间的利用率是否高 主存装入一块时，发生冲突的概率 全相联的映射方式 主存中的块可以放入到 cache 的任意一行 将地址分为两部分——块号和字（块内地址），在内存块（随机）写入 Cache 时，同时写入块号（标记）； 字即块内地址，即目标在块内的地址；主存中的块内地址即 cache 中的行内地址 CPU 给出访问地址后，也将地址分为两部分（块号和字），比较块号与 Cache 表中的标记进行比较，相同表示命中，访问相应单元；如果没有命中访问内存，CPU 直接访问内存，并将被访问内存的相对应块写入 Cache。 转换公式 主存地址长度＝(s + w) 位 寻址单元数＝2^s+w^ 个字或字节 块大小＝行大小＝2^w^ 个字或字节 主存的块数＝2^s^ 标记大小＝s 位 cache 的行数＝不由地址格式确定 特点： 优点：冲突概率小，Cache 的利用高。（只有当 cache 全满时才会发生冲突） 缺点：比较器难实现，需要一个访问速度很快代价高的相联存储器 应用场合： 适用于小容量的 Cache 直接映射方式 主存中的块只能放入到 cache 的固定一行 映射方法（一对多） i = j mod m 主存第 j 块内容拷贝到 Cache 的 i 行 m 表示 cache 的行数 一般 i 和 m 都是 2^N^ 级 地址：标记 + 行号 + 块内地址 [例] cache 容量 16 字，主存容量 256 字，则地址 2，18，34…..242 等都存放在 cache 的地址 2 内，如果第一次 2 在 cache 中，下次访问 34 内容，则不管 cache 其他位置的内容访问情况，都会引起 2 块内容的替换 基本原理 利用行号选择相应行； 把行标记与 CPU 访问地址进行比较，相同表示命中，访问 Cache； 如果没有命中，访问内存，并将相应块写入 Cache 转换公式 主存地址长度＝ (s+w) 位 寻址单元数＝2^s+w^ 个字或字节 块大小＝行大小＝2^w^ 个字或字节 主存的块数＝2^s^ cache 的行数＝m＝2^r^ 标记大小＝(s-r) 位 特点 优点：比较电路少 m 倍线路，所以硬件实现简单，Cache 地址为主存地址的低几位，不需变换。 缺点：冲突概率高（抖动） 应用场合 适合大容量 Cache 组相联映射方式 前两者的组合，cache 中以若干行为一组，组之间直接映射，组内全相联 Cache 分组，组间采用直接映射方式，组内采用全相联的映射方式 Cache 分组 U，组内容量 V 映射方法（一对多） q = j mod u 主存第 j 块内容拷贝到 Cache 的第 q 组中的某行 u 表示组数；q 表示组号，j 表示块号 地址 = （表示行的）标记 + 组号 + 块内地址 地址变换 设主存地址 x，看是不是在 cache 中，先 y = x mod u，则在 y 组中一次查找 分析 v=1，则为直接相联映射方式 u=1，则为全相联映射方式 v 的取值一般比较小， 一般是 2 的幂，称之为 v 路组相联 cache. 转换公式 主存地址长度＝(s+w) 位 寻址单元数＝2^s+w^ 个字或字节 块大小＝行大小＝2^w^ 个字或字节 主存的块数＝2^s^ 每组的行数＝k 组数 v＝2^d^ cache 的行数＝kv 标记大小＝(s-d) 位 n 路组相联：一个组有 n 行 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:5:2","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"替换策略 LFU（最不经常使用 ）：被访问 / 命中的行计数器增加 1。始终拿走值最小的行，不能反映近期 cache 的访问情况， LRU（近期最少使用） ：被访问的行计数器置 0，其他的计数器增加1，始终拿走值最大的行，符合 cache 的工作原理 随机替换：随便找个位置而已 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:5:3","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"写操作策略 由于 cache 的内容只是主存部分内容的拷贝，它应当与主存内容保持一致。而 CPU 对 cache 的写入更改了 cache 的内容。如何与主存内容保持一致，可选用如下三种写操作策略。 写回法：只写 Cache；换出时，对行的修改位进行判断，决定是写回还是舍掉。 全写法（写直达法）：写命中时，Cache 与内存一起写 写一次法：与写回法一致，但是第一次 Cache 命中时采用全写法。(第一次一起写，之后写 cache) ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:5:4","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"虚拟存储器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:6:0","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"概念 虚地址：用户编制程序时使用的地址称为虚地址或逻辑地址，其对应的存储空间称为虚存空间或逻辑地址空间； 实地址：而计算机物理内存的访问地址则称为实地址或物理地址，其对应的存储空间称为物理存储空间或主存空间。 再定位：程序进行虚地址到实地址转换的过程称为程序的再定位（虚实转换），在访问 cache 之前就已经完成 虚存的访问过程 虚存空间的用户程序按照虚地址编程并存放在辅存中。 程序运行时，由地址变换机构依据当时分配给该程序的实地址空间把程序的一部分调入实存。 每次访存时，首先判断该虚地址所对应的部分是否在实存中： 若是，则进行地址转换并用实地址访问主存； 否则，按照某种算法将辅存中的部分程序调度进内存，再按同样的方法访问主存。 由此可见，每个程序的虚地址空间可以远大于实地址空间，也可以远小于实地址空间。 前一种情况以提高存储容量为目的，后一种情况则以地址变换为目的。 后者通常出现在多用户或多任务系统中：实存空间较大，而单个任务并不需要很大的地址空间，较小的虚存空间则可以缩短指令中地址字段的长度。 cache 与虚存的异同 从虚存的概念可以看出，主存辅存的访问机制与 cache 主存的访问机制是类似的。这是由 cache 存储器、主存和辅存构成的三级存储体系中的两个层次。 cache 和主存之间以及主存和辅存之间分别有辅助硬件和辅助软硬件负责地址变换与管理，以便各级存储器能够组成有机的三级存储体系。cache 和主存构成了系统的内存，而主存和辅存依靠辅助软硬件的支持构成了虚拟存储器。 在三级存储体系中，cache 主存和主存辅存这两个存储层次有许多相同点； 出发点相同 二者都是为了提高存储系统的性能价格比而构造的分层存储体系，都力图使存储系统的性能接近高速存储器，而价格和容量接近低速存储器。 原理相同 都是利用了程序运行时的局部性原理把最近常用的信息块从相对慢速而大容量的存储器调入相对高速而小容量的存储器。 但 cache 主存和主存辅存这两个存储层次也有许多不同之处： 3. 侧重点不同 cache 主要解决主存与CPU的速度差异问题；而就性能价格比的提高而言，虚存主要是解决存储容量问题，另外还包括存储管理、主存分配和存储保护等方面。 4. 数据通路不同 CPU 与 cache 和主存之间均有直接访问通路，cache 不命中时可直接访问主存；而虚存所依赖的辅存与 CPU 之间不存在直接的数据通路，当主存不命中时只能通过调页解决，CPU 最终还是要访问主存。 5. 透明性不同 cache 的管理完全由硬件完成，对系统程序员和应用程序员均透明；而虚存管理由软件（操作系统）和硬件共同完成，由于软件的介入，虚存对实现存储管理的系统程序员不透明，而只对应用程序员透明（段式和段页式管理对应用程序员“半透明”）。 6. 未命中时的损失不同 由于主存的存取时间是 cache 的存取时间的 5～10 倍，而主存的存取速度通常比辅存的存取速度快上千倍，故主存未命中时系统的性能损失要远大于 cache 未命中时的损失。 虚存机制要解决的关键问题 调度问题决定哪些程序和数据应被调入主存。 地址映射问题在访问主存时把虚地址变为主存物理地址（这一过程称为内地址变换）；在访问辅存时把虚地址变成辅存的物理地址（这一过程称为外地址变换），以便换页。此外还要解决主存分配、存储保护与程序再定位等问题。 替换问题决定哪些程序和数据应被调出主存。 更新问题确保主存与辅存的一致性。 在操作系统的控制下，硬件和系统软件为用户解决了上述问题，从而使应用程序的编程大大简化。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:6:1","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"页式虚拟存储器 页 虚地址空间被分成等长大小的页，称为逻辑页； 主存空间也被分成同样大小的页，称为物理页 虚地址分为两个字段：高字段为逻辑页号，低字段为页内地址（偏移量）； 虚页号由逻辑空间的大小决定（单位为页的个数），页内地址由页的大小决定 实存地址也分两个字段：高字段为物理页号，低字段为页内地址。 两者的页内地址相同，唯一需要转换的是虚页号到实页号 通过页表可以把虚地址（逻辑地址）转换成物理地址。 页表 页表中对应每一个虚存页面有一个表项，表项的内容包含该虚存页面所在的主存页面的地址（物理页号），以及指示该逻辑页是否已调入主存的有效位。 地址变换时，用逻辑页号作为页表内的偏移地址索引页表（将虚页号看作页表数组下标）并找到相应物理页号，用物理页号作为实存地址的高字段，再与虚地址的页内偏移量拼接，就构成完整的物理地址。现代的中央处理机通常有专门的硬件支持地址变换。 每个进程所需的页数并不固定，所以页表的长度是可变的，因此通常的实现方法是把页表的基地址保存在寄存器中（页表基址 R），而页表本身则放在主存中。 由于虚存地址空间可以很大，因而每个进程的页表有可能非常长。例如，如果一个进程的虚地址空间为 2G 字节，每页的大小为 512 字节，则总的虚页数为 2^31^/2^9^=2^22^。 为了节省页表本身占用的主存空间，一些系统把页表存储在虚存中（快表，TLB，转换后援缓冲器），全硬件实现，容量小，是页表（此时称慢表）的子集，因而页表本身也要进行分页。当一个进程运行时，其页表中一部分在主存中，另一部分则在辅存中保存。 页表和快表同时查找！ 另一些系统采用二级页表结构。每个进程有一个页目录表，其中的每个表项指向一个页表。 在页表长度较大的系统中，还可以采用反向页表实现物理页号到逻辑页号的反向映射。页表中对应每一个物理页号有一个表项，表项的内容包含该物理页所对应的逻辑页号。访存时，通过逻辑页号在反向页表中逐一查找。如果找到匹配的页，则用表项中的物理页号取代逻辑页号；如果没有匹配表项，则说明该页不在主存中。这种方式的优点是页表所占空间大大缩小，但代价是需要对反向页表进行检索，查表的时间很长。有些系统通过散列（哈希）表加以改进 内页表和外页表 页表是虚地址到主存物理地址的变换表，通常称为内页表。与内页表对应的还有外页表，用于虚地址与辅存地址之间的变换。当主存缺页时，调页操作首先要定位辅存，而外页表的结构与辅存的寻址机制密切相关。例如对磁盘而言，辅存地址包括磁盘机号、磁头号、磁道号和扇区号等。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:6:2","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"段式虚拟存储器 段和段表 段是按照程序的自然分界划分的长度可以动态改变的区域。通常，程序员把子程序、操作数和常数等不同类型的数据划分到不同的段中，并且每个程序可以有多个相同类型的段。 虚地址由段号和段内地址（偏移量）组成。虚地址到实主存地址的变换通过段表实现。 每个表项至少包含下面三个字段： 有效位：指明该段是否已经调入实存。 段起址：指明在该段已经调入实存的情况下，该段在实存中的首地址。 段长：记录该段的实际长度。设置段长字段的目的是为了保证访问某段的地址空间时，段内地址不会超出该段长度导致地址越界而破坏其他段。 段表本身也是一个段，可以存在辅存中，但一般是驻留在主存中。 特点 优点 段的逻辑独立性使其易于编译、管理、修改和保护，也便于多道程序共享。 段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。 缺点 因为段的长度不固定，主存空间分配比较麻烦 容易在段间留下许多外碎片，造成存储空间利用率降低 由于段长不一定是 2 的整数次幂，因而不能简单地像分页方式那样用虚地址和实地址的最低若干二进制位作为段内偏移量，并与段号进行直接拼接，必须用加法操作通过段起址与段内偏移量的求和运算求得物理地址。因此，段式存储管理比页式存储管理方式需要更多的硬件支持。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:6:3","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"段页式虚拟存储器 实存被等分成页。每个程序则先按逻辑结构分段，每段再按照实存的页大小分页，程序按页进行调入和调出操作，但可按段进行编程、保护和共享 一般情况下由一张段表，其中有好多页表 虚地址：基号 + 段号 + 页号 + 页内地址 实地址：物理页号 + 页内地址 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:6:4","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"虚存的替换算法 当从辅存调页至主存而主存已满时，也需要进行主存页面的替换。虚拟存储器的替换算法与cache的替换算法类似，有 FIFO 算法、LRU 算法、LFU 算法等。 虚拟存储器的替换算法与 cache 的替换算法不同的是： cache 的替换全部靠硬件实现，而虚拟存储器的替换有操作系统的支持。 虚存缺页对系统性能的影响比 cache 未命中要大得多，因为调页需要访问辅存，并且要进行任务切换。 虚存页面替换的选择余地很大，属于一个进程的页面都可替换。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/:6:5","tags":["计算机组成原理"],"title":"计组 第三章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/3.-%E5%AD%98%E5%82%A8%E5%99%A8/"},{"categories":["专业课"],"content":"指令系统 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:0:0","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令系统的发展与性能要求 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:0","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令系统的发展 分类 微指令：微程序级的命令，它属于硬件； 宏指令：由若干条机器指令组成的软件指令，它属于软件； 机器指令：介于微指令与宏指令之间，通常简称为指令，每一条指令可完成一个独立的算术运算或逻辑运算操作 本章所讨论的指令，是机器指令 按作用分： 数据传送指令、算术运算指令、逻辑运算指令、程序控制指令 发展情况 复杂指令系统计算机，简称 CISC。 如此庞大的指令系统不但使计算机的研制周期变长，难以保证正确性，不易调试维护，而且由于采用了大量使用频率很低的复杂指令而造成硬件资源浪费。 精简指令系统计算机：简称 RISC 人们提出了便于 VLSI 技术实现的精简指令系统计算机。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:1","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令系统性能要求 **完备性：**完备性是指用汇编语言编写各种程序时，指令系统直接提供的指令足够使用，而不必用软件来实现。 **有效性：**有效性是指利用该指令系统所编写的程序能够高效率地运行。 **规整性：**规整性包括指令系统的对称性、匀齐性、指令格式和数据格式的一致性。 对称性是指：在指令系统中所有的寄存器和存储器单元都可同等对待，所有的指令都可使用各种寻址方式 匀齐性是指：一种操作性质的指令可以支持各种数据类型 指令格式和数据格式的一致性是指：指令长度和数据长度有一定的关系，以方便处理和存取。 **兼容性：**系列机各机种之间具有相同的基本结构和共同的基本指令集，因而指令系统是兼容的，即各机种上基本软件可以通用。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:1:2","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令格式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:0","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"操作码 指令的操作码OP表示该指令应进行什么性质的操作。不同的指令用操作码字段的不同编码来表示，每一种编码代表一种指令。 组成操作码字段的位数一般取决于计算机指令系统的规模 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:1","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"地址码 三地址指令 功能描述 (A1) op (A2)→A3 这种格式虽然省去了一个地址，但指令长度仍比较长，所以只在字长较长的大、中型机中使用，而小型、微型机中很少使用 二地址指令 功能描述 (A1) op (A2)→A1 说明 二地址指令在计算机中得到了广泛的应用， 注意：指令执行之后，A1 中原存的内容已经被新的运算结果替换了 二地址地址根据操作数的物理位置分为： SS 存储器-存储器类型 RS 寄存器-存储器类型 RR 寄存器-寄存器类型 一地址指令 功能描述 (AC) op (A1) → A1 说明 单操作数运算指令，如“+1”、“-1”、“求反” 指令中给出一个源操作数的地址 另一个操作数地址是隐含的 零地址指令 “停机”、“空操作”、“清除”等控制类指令 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:2:2","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令字长度 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:0","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"概念 指令字长度（一个指令字包含二进制代码的位数） 机器字长：计算机能直接处理的二进制数据的位数。 分类 单字长指令：指令字长等于一个机器字长 半字长指令：指令字长等于半个机器字长 双字长指令：指令字长等于两个机器字长 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:1","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"理解 多字长指令的优缺点 优点：提供足够的地址位来解决访问内存任何单元的寻址问题 ； 缺点：必须两次或多次访问内存以取出一整条指令，降低了 CPU 的运算速度，又占用了更多的存储空间 等长指令 各种指令字长度是相等的，指令字结构简单，且指令字长度是不变的 ； 非等长指令 各种指令字长度随指令功能而异，结构灵活，能充分利用指令长度，但指令的控制较复杂 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:2","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令助记符 用3～4个英文字母来表示操作码，一般为英文缩写 不同的计算机系统，规定不一样 必须用汇编语言翻译成二进制代码 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:3","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令格式举例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:3:4","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令和数据的寻址方式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:4:0","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"指令的寻址方式 顺序寻址方式 PC + 1 跳跃寻址方式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:4:1","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"操作数基本寻址方式 形成操作数有效地址的方法，称为操作数的寻址方式 形式地址 + 寻址方式特征位 形式地址 A , 也称偏移量， 它是指令字结构中给定的地址量。 寻址方式特征位， 此处由间址位和变址位组成。 如果这条指令无间址和变址的要求， 那么形式地址就是操作数的有效地址。 如果指令中指明要变址或间址变换， 那么形式地址就不是操作数的有效地址， 而要经过指定方式的变换， 才能形成有效地址。 因此， 寻址过程就是把操作数的形式地址， 变换为操作数的有效地址的过程 隐含寻址 指令中隐含着操作数的地址 如单地址指令的某些运算，隐含了累加器 AC 作为源和目的寄存器 立即寻址 指令的地址字段不操作数地址，而是操作数本身 也就是不用寻址 指令格式：操作码 OP 操作数 A 直接寻址 指令中地址码字段给出的地址 A 就是操作数的有效地址 EA (Effective Address)、 EA＝A 间接寻址 指令的地址码部分给出的地址 A 是操作数地址的地址 EA＝(A) 寄存器寻址 在指令的地址码部分给出 CPU 内某一通用寄存器的编号，指令的操作数存放在相应的寄存器中 EA = R 优点 由于寄存器在CPU的内部，指令在执行时从寄存器中取操作数比访问主存要快得多； 由于寄存器的数量较少，因此寄存器编号所占位数也较少，从而可以有效减少指令的地址码字段的长度。 寄存器间接寻址 为了克服间接寻址中多次访存的缺点，可采用寄存器间接寻址，即将操作数放在主存储器中，而操作数的地址放在某一通用寄存器中，然后在指令的地址码部分给出该通用寄存器的编号 EA = (R) 这种寻址方式的指令较短，并且在取指后只需一次访存便可得到操作数，因此指令执行速度较前述的间接寻址方式要快，也是目前在计算机中使用较为广泛的一种寻址方式 偏移寻址 偏移寻址要求指令中有两个地址字段，至少有一个是显示的 必定显示的形式地址 A （一般是一个偏移量 D） 一个隐含的引用（一般是一个专用寄存器） EA = A + (R) 相对寻址 由程序计数器 PC 提供基准地址（隐含引用），而指令的地址码部分给出相对的位移量 D，两者相加后作为操作数的有效地址 EA＝D + (PC) 基址寻址 专用寄存器是一个基址寄存器，可以显示可以隐式 基址寄存器的位数可以设置得很长，从而可以在较大的存储空间中寻址 EA = D + (R) 变址寻址 变址寻址就是将指令的地址码部分给出的基准地址 A 与变址寄存器 R 中的内容相加，以形成操作数的有效地址。 EA = A + R 段寻址方式 存储空间划分为多段 堆栈寻址 以先进后出原理存储数据 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:4:2","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"寻址方式举例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/:4:3","tags":["计算机组成原理"],"title":"计组 第四章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/4.-%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/"},{"categories":["专业课"],"content":"中央处理器 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:0:0","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"CPU的功能和组成 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:1:0","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"CPU的功能 指令控制（程序的顺序控制） 操作控制（一条指令有若干操作信号实现） 时间控制（指令各个操作实施时间的定时） 数据加工（算术运算和逻辑运算） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:1:1","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"CPU的基本组成 中央处理器 CPU = 运算器 + cache + 控制器 运算器 ALU 通用寄存器：R0～R3 暂存器：DR 状态字寄存器：PSW cache 指令 cache：PC，IBUS 数据 cache：AR，DBUS 控制器 程序计数器、指令寄存器、数据缓冲器、地址寄存器、时序发生器、指令译码器、总线（数据通路） 程序计数器 PC (Programming Counter) 用来存放正在执行的指令的地址或接着将要执行的下一条指令的地址。 顺序执行时，每执行一条指令，PC的值应加1 要改变程序执行顺序的情况时，一般由转移类指令将转移目标地址送往 PC ，可实现程序的转移 指令寄存器 IR (Instruction Register) 指令寄存器用来存放从存储器中取出的待执行的指令。 在执行该指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:1:2","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"CPU 中的主要寄存器 数据缓冲寄存器(DR) 中转站 补偿速度差别 指令寄存器 (IR) 程序计数器 (PC) 数据地址寄存器 (AR) 通用寄存器 (R0～R3) 状态字寄存器 (PSW) ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:1:3","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"指令周期 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:0","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"指令周期的基本概念 指令周期：取出一条指令并执行这条指令的时间 CPU 周期：又称机器周期，用从内存中读取一个指令字的最短时间来规定 CPU 周期 ​ 换句话说，就是以主存的工作周期 (存取周期) 为基础来规定 CPU 周期 ​ 通常把一条指令周期划分为若干个机器周期，每个机器周期完成一个基本操作 ​ 一个 CPU 周期中，包含若干个节拍脉冲（T 周期） ​ CPU 周期通常定义为机器主频的倒数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:1","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"MOV 指令的指令周期 两个 CPU 周期 取指周期 程序计数器PC中装入第一条指令地址101（八进制）； PC的内容被放到指令地址总线ABUS（I）上，对指存进行译码，并启动读命令； 从101号地址读出的MOV指令通过指令总线IBUS装入指令寄存器IR； 程序计数器内容加1，变成102，为取下一条指令做好准备； 指令寄存器中的操作码（OP）被译码； CPU识别出是MOV指令，至此，取指周期即告结束 执行周期 操作控制器（OC）送出控制信号到通用寄存器，选择R1（10）作源寄存器，选择R0作目标寄存器； OC送出控制信号到ALU，指定ALU做传送操作； OC送出控制信号，打开ALU输出三态门，将ALU输出送到数据总线DBUS上。注意，任何时候DBUS上只能有一个数据。 OC送出控制信号，将DBUS上的数据打入到数据缓冲寄存器DR（10）； OC送出控制信号，将DR中的数据10打入到目标寄存器R0，R0的内容由00变为10。至此，MOV指令执行结束。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:2","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"LAD 指令的指令周期 三个 CPU 周期 取指周期 与 MOV 指令一样，以下皆同 执行周期 操作控制器OC发出控制命令打开IR输出三态门，将指令中的直接地址码6放到数据总线DBUS上； OC发出操作命令，将地址码6装入数存地址寄存器AR； OC发出读命令，将数存6号单元中的数100读出到DBUS上； OC发出命令，将DBUS上的数据100装入缓冲寄存器DR； OC发出命令，将DR中的数100装入通用寄存器R1，原来R1中的数10被冲掉。至此，LAD指令执行周期结束。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:3","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"ADD 指令的指令周期 两个 CPU 周期 执行周期 操作控制器OC送出控制命令到通用寄存器，选择R1做源寄存器，R2做目标寄存器； OC送出控制命令到ALU，指定ALU做R1（100）和R2（20）的加法操作； OC送出控制命令，打开ALU输出三态门，运算结果120放到DBUS上； OC送出控制命令，将DBUS上数据打入缓冲寄存器DR；ALU产生的进位信号保存状态字寄存器在PSW中。 OC送出控制命令，将DR（120）装入R2，R2中原来的内容20被冲掉。至此ADD指令执行周期结束 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:4","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"STO 指令的指令周期 三个 CPU 周期 执行周期 注意：DBUS 为单总线结构，先送地址，后送数据 操作控制器OC送出操作命令到通用寄存器，选择（R3）=30做数据存储器的地址单元； OC发出操作命令，打开通用寄存器输出三态门（不经ALU以节省时间），将地址30放到DBUS上； OC发出操作命令，将地址30打入AR，并进行数存地址译码； OC发出操作命令到通用寄存器，选择（R2）=120），作为数存的写入数据； OC发出操作命令，打开通用寄存器输出三态门，将数据120放到DBUS上。 OC发出操作命令，将数据120写入数存30号单元，它原先的数据40被冲掉。至此，STO指令执行周期结束 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:5","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"JMP 指令的指令周期 两个 CPU 周期 执行周期 OC 发生操作控制命令，打开指令寄存器 IR 的输出三态门，将IR中的地址码 101 发送到DBUS上； OC 发出操作控制命令，将 DBUS 上的地址码 101 打入到程序计数器 PC 中，PC中的原先内容 106 被更换。于是下一条指令不是从 106 号单元取出，而是转移到 101 号单元取出。至此 JMP 指令执行周期结束 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:6","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"用方框图语言表示指令周期 方法 指令系统设计（模型机的五指令系统） 方框——按 CPU 周期 方框内内容——数据通路操作或控制操作 菱形符号——判别或测试 ~——公操作 前边所讲述的5种操作的框图描述 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:2:7","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"时序产生器和控制方式 同步控制方式（指令的机器周期和时钟周期数不变） 完全统一的机器周期执行各种不同的指令 或采用不定长机器周期 中央控制于局部控制的结合 异步控制方式 每条指令需要多长时间就占多长时间 联合控制方式 大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式 或，机器周期的节拍脉冲固定，但是各指令的机器周期数不固定（微程序控制器采用） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:3:0","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"微程序控制器 微命令-\u003e微指令-\u003e微程序 一条机器指令对应着一个微程序 分清控制器，运算器，存储器，总线之间的边界 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:4:0","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"概念 微命令：控制部件向执行部件发出的各种控制命令叫作微命令，它是构成控制序列的最小单位 微操作：执行器接受微命令后所进行的操作 微指令：把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令 操作控制字段，又称微操作码字段，用以产生某一步操作所需的各个微操作控制信号。 某位为1，表明发微指令 微指令发出的控制信号都是节拍电位信号，持续时间为一个CPU周期 微命令信号还要引入时间控制 顺序控制字段，又称微地址码字段，用以控制产生下一条要执行的微指令地址。 微程序：一系列微指令的有序集合就是微程序 一段微程序对应一条机器指令。 微地址 ：存放微指令的控制存储器的单元地址 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:4:1","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"微程序控制原理 控制存储器 (μCM) 这是微程序控制器的核心部件，用来存放微程序。其性能 (包括容量、速度、可靠性等) 与计算机的性能密切相关 机器运行时只读不写，工作时，读取一条微指令并运行，以此往复 微指令寄存器 (μIR) 用来存放从 μCM 取出的正在执行的微指令 地址转移逻辑 用来产生初始微地址和后继微地址，以保证微指令的连续执行 微地址寄存器 (μMAR) 它接受微地址形成部件送来的微地址，为下一步从μCM中读取微指令作准备。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:4:2","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"微指令格式 水平型微指令：一次能定义并执行多个并行操作微命令的微指令 垂直型微指令：微指令中设置微操作码字段，采用微操作码编译法，由微操作码规定微指令的功能 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/:4:3","tags":["计算机组成原理"],"title":"计组 第五章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/5.-%E4%B8%AD%E5%A4%AE%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["专业课"],"content":"概论 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:0:0","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"分类 数字计算机 专用计算机 通用计算机 模拟计算机 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:1:0","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"发展简史 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:2:0","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"五代变化 电子管计算机（1946—1957年）：数据处理 晶体管计算机（1958—1964年）：工业控制 中小规模集成电路计算机（1965—1971年）：小型计算机 大规模和超大规模集成电路计算机（1972—1990年）：微型计算机 巨大规模集成电路计算机（1991年开始）：单片机 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:2:1","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"性能指标 吞吐量 表征一台计算机在某一时间间隔内能够处理的信息量，单位是字节/秒（B/S）。 响应时间 表征从输入有效到系统产生响应之间的时间度量，用时间单位来度量，例如微秒（10-6S）、纳秒（10-9S）。 利用率 给定的时间间隔内，系统被实际使用的时间所占的比率，一般用百分比表示。 处理机字长 指处理机运算器中一次能够完成二进制数运算的位数。当前处理机的字长有8位、16位、32位、64位。字长越长，表示计算的精度越高 总线宽度 CPU中运算器与存储器之间进行互连的内部总线二进制位数。 存储器容量 存储器中所有存储单元的总数目，通常用KB、MB、GB、TB来表示。 存储器带宽 存储器的速度指标，单位时间内从存储器读出的二进制数信息量，一般用字节数/秒表示。 主频/时钟周期 CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率（f）叫CPU的主频。度量单位是MHz（兆赫兹）、GHz（吉赫兹）。例如Pentium系列机为60MHz～266MHz，而Pentium 4升至3.6GHz。 CPU时钟周期（T） 主频的倒数，即T=1/f，度量单位是微秒、纳秒。 CPU执行时间 CPU执行一段程序所占用的CPU时间。CPU执行时间 ＝ CPU时钟周期数 × CPU时钟周长 CPI 每条指令周期数，即执行一条指令所需的平均时钟周期数。 CPI ＝ 执行程序所需的CPU时钟周期数/该程序包含的指令条数 MIPS 每秒百万条指令数。MIPS = 指令条数/程序执行时间Te × 10的6次方 = 时钟频率/CPI × 10的6次方。MIPS是单位时间内的执行指令数，所以MIPS值越高说明机器速度越快。 MFLOPS 每秒百万次浮点操作次数。MFLOPS = 程序中的浮点操作数/程序执行时间Te × 10的6次方。 MFLOPS是基于操作而非指令的，只能用来衡量机器浮点操作的性能，而不能体现机器的整体性能。 TFLOPS 每秒万亿次浮点操作次数，该技术指标一般在超级计算机中使用。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:2:2","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"硬件 控制器：人的大脑的操作控制功能 运算器：人的大脑的计算功能 存储器：人的大脑记忆功能 输入设备：交互接口，笔 输出设备：交互接口，纸 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:3:0","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"运算器 算术运算和逻辑运算 在计算机中参与运算的数是二进制的 运算器的长度一般是8、16、32或64位 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:3:1","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"存储器 存储数据和程序（指令） 容量（存储单元、存储单元地址、容量单位） 分类内存（ROM、RAM）、外存 存储器单位： ​ $1KB ＝ 2^{10}B \\ 1MB ＝ 2^{20}B \\ 1GB ＝ 2^{30}B \\ 1TB ＝ 2^{40}B $ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:3:2","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"控制器 指令和程序：指令的形式（操作和地址码、存储程序的概念、指令中程序和数据的存放、指令系统） 指令和数据存储 控制器的基本任务：按照一定的顺序一条接着一条取指令、指令译码、执行指令。取指周期和执行周期 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:3:3","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"适配器与I/O设备 输入设备：把人们所熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式 输出设备：把计算机处理的结果变换为人或其他机器设备所能接收和识别的信息形式 适配器：它使得被连接的外围设备通过系统总线与主机进行联系，以便使主机和外围设备并行协调地工作 总线：构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:3:4","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"软件 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:4:0","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"分类 系统软件 各种服务性程序，如诊断程序、排错程序、练习程序等 语言程序，如汇编程序、编译程序、解释程序等 操作系统 数据库管理系统 应用软件 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:4:1","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"发展演变 编程语言的发展 手编程序：机器语言程序，手工编译二进制码 汇编程序：符号语言程序，汇编程序汇编 高级程序：算法语言/高级语言，机器编译程序/解释程序 系统软件的发展 手编程序：机器语言程序，手工编译二进制码 汇编程序：符号语言程序，汇编程序汇编 高级程序：算法语言/高级语言，机器编译程序/解释程序 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:4:2","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"多级计算机系统 微程序设计级，这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。 一般机器级，也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。 操作系统级，它由操作系统程序实现。这些操作系统由机器指令和广义指令组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。 汇编语言级，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。 高级语言级，它是面向用户的，为方便用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/:5:0","tags":["计算机组成原理"],"title":"计组 第一章","uri":"/Notes/posts/courses/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.-%E6%A6%82%E8%AE%BA/"},{"categories":["专业课"],"content":"一、数学语言与证明方法 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:0:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"符号 运算 $A-B$：B对A的相对补 $A\\oplus B$：A与B的对称差 A与B中不重叠的部分 ~$A$：绝对补，等于$E-A$ $P(A)$：A的幂集（A的所有子集组成的集合） $|P(A)|=\\sum\\limits_{i=1}^n C_n^i \\quad (n=|A|)$ $a\\mid b$：a整除b $a\\nmid b$：a不能整除b $a\\equiv b(mod \\ n)$：a与b被n除余数相同 $(a-b)\\equiv 0(mod \\ n)$：等价于$n\\mid (a-b)$ $\\lceil x\\rceil$：大于等于x的最小整数 $\\lfloor x\\rfloor$：小于等于x的最大整数 集合 $|A|$：A中元素的个数 $N$：自然数集 $Z$：整数集 $Q$：有理数集 $R$：实数集 $C$：复数集 逻辑 $p\\rightarrow q$：如果p，则q $p\\leftrightarrow q$：当且仅当q与q同时为真或同时为假 $A\\Rightarrow B$：表示$A\\rightarrow B$恒真，若A真，则B一定真 $A\\Leftrightarrow B$：$p\\leftrightarrow q$恒真，A与B要么同时为真，要么同时为假 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:1:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"集合 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:2:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"规律 $A\\oplus A=\\empty$ $\\cap$对$\\oplus$的分配律：$A\\cap (B\\oplus C)=(A\\cap B)\\oplus (A\\cap C)$ $\\oplus$对$\\cap$没有分配律 $\\oplus$的消去律：$A\\oplus B=A\\oplus C\\Rightarrow B=C$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:2:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"证明集合包含或相等 根据定义证明（等式两边互为子集），通常取元素$\\forall x\\in A$ 利用已知集合等式或包含式，通过集合演算证明 命题逻辑 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:2:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"基本概念 命题：判断结果唯一的陈述句 联结词 合取式：$A\\land B$ 析取式：$A\\lor B$ 否定式：$\\neg A$ 蕴含式：$A\\rightarrow B$ （1 0 0） ​ 当$p$为假时，$p\\rightarrow q$为真 ​ 除非$q$，否则$\\neg p$ 等价式：$A\\leftrightarrow B$ （同时为真或同时为假，同或） 与非式：$A\\uparrow B$ 或非式：$A\\downarrow B$ 赋值：给公式A中命题变项$p_1,p_2,\\ldots,p_n$指定的一组真值$\\alpha =\\alpha_1,\\alpha_2,\\ldots,\\alpha_n$，按使公式为真/假分为真/假赋值。 命题公式分类 永真式：也叫重言式，在各种赋值下取值均为真（一定是可满足式） 永假式：也叫矛盾式，在各种赋值下取值均为假 可满足式：若A不是矛盾式，则其为可满足式（等价定义：A至少存在一个成真赋值） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:3:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"等值演算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:4:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"概念 等值式：若A和B构成的等价式$A\\leftrightarrow B$为重言式，则称A和B是等值的，记作$A\\Leftrightarrow B$ 等值演算：根据已知的等值式推演出与原命题公式等值的新的命题公式的过程 n个命题变量的可能真值表共有$2^{2^n}$个 哑元：在 B 中出现，但不在 A 中出现的命题变项称作 A 的哑元。哑元的出现不影响命题公式的真值。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:4:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"真值表法 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:4:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"等值演算法 基本等值式 着重考虑置换规则：若$A\\Leftrightarrow B$，则$\\Phi(B)\\Leftrightarrow \\Phi(A)$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:4:3","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"联结词完备集 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:5:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"真值函数 称$F:{0,1}^n\\rightarrow {0,1}$为$n$元真值函数 特征 $n$元真值函数共有$2^{2^n}$个 每个命题公式对应一个真值函数 每个真值函数对应无穷个命题公式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:5:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"联结词完备集 设$S$是一个联结词集合，如果任何$n(n\\ge 1)$元真值函数都可以由仅含$S$中的联结词构成的公式表示，则称$S$是联结词完备集 定理 $S={\\neg,\\land,\\lor}$是联结词完备集 推论：$S={\\neg,\\land},\\quad S={\\neg,\\lor}\\quad S={\\neg,\\rightarrow}$ ${\\uparrow}\\quad{\\downarrow}$都是联结词完备集 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:5:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"范式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:6:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"析取范式与合取范式 定义： 命题变量及其否定统称作文字，仅由有限个文字构成的析/合取式称作简单析/合取式 由有限个简单合取式构成的析取式称为析取范式（与或） 由有限个简单析取式构成的合取式称为合取范式（或与） 定理 一个简单析取式是重言式$\\Leftrightarrow$他同时包含某个命题变量和他的否定 一个简单合取式是矛盾式$\\Leftrightarrow$他同时包含某个命题变量和他的否定 一个析取范式是矛盾式$\\Leftrightarrow$他每个简单合取式都是矛盾式 一个析取合式是重言式$\\Leftrightarrow$他每个简单析取式都是重言式 （范式存在定理）任意命题公式都存在着与之等值的析取范式和合取范式 求范式 消去联结词$\\rightarrow,\\leftrightarrow$ 否定号的消去（双重否定律）或内移（德摩根定律） 利用分配律 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:6:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"主析取范式与主合取范式 极小项与极大项 $$ \\neg m_i\\Leftrightarrow M_i \\ ,\\quad \\neg M_i\\Leftrightarrow m_i $$ 定义：若由n个命题变项构成的析\\合取范式中所有的简单合\\析取式都是极小\\大项，则称其为主析\\合取范式 定理：任意命题公式都存在着与之等值的主析取范式和主合取范式 求主范式步骤 求析\\合取范式 展开（乘一\\加零） 用途 求取成真赋值和成假赋值 判断公式类型 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:6:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"推理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:7:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"推理的形式结构 称 $$ (A_1\\land A_2\\land \\ldots\\land A_k)\\rightarrow B $$ 为由前提$A_1,A_2\\ldots A_k$推结论$B$的推理的形式结构 当推理正确（重言式）时，记为 $$ (A_1\\land A_2\\land \\ldots\\land A_k)\\Rightarrow B $$ 判断推理正确的方式 真值表法 等值演算法 主析取范式法 观察法（?） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:7:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"推理的证明 永真的蕴含式称为推理定律 把一个公式换成任何与它等值的公式，称作等值置换，简称置换 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:7:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"证明方法 附加前提证明法 定义：当推理的结论为蕴含式$A\\rightarrow B$时，把$A$加入推理的前提，把$B$作为推理的结论。$A$即为附加前提。 ​ 即，把证明推理 $$ (A_1\\land A_2\\land \\ldots\\land A_k)\\rightarrow (C\\rightarrow B) $$ ​ 转换成证明推理 $$ (A_1\\land A_2\\land \\ldots\\land A_k\\land C)\\rightarrow B $$ 归谬法 定义：把结论的否定加入前提，而要推出矛盾（以0为结论）。 ​ 即，把证明推理 $$ (A_1\\land A_2\\land \\ldots\\land A_k)\\rightarrow B $$ ​ 转换成证明推理 $$ (A_1\\land A_2\\land \\ldots\\land A_k\\land \\neg B)\\rightarrow 0 $$ 归结证明法 归结规则 显然有 $$ (L\\lor C_1)\\land(\\neg L \\lor C_2)\\Rightarrow C_1\\lor C_2 $$ ​ $L$是一个变元，$C_1$和$C_2$是简单析取式。称上式为归结定律 $$ \\ \\ L\\lor C_1 \\ \\underline{\\neg L\\lor C_2}\\ \\ C_1\\lor C_2 \\ $$ 基本思想：采用归谬法，把结论的否定引入前提。若推出空简单析取式（推出0），则证明推理正确。 步骤 把结论的否定引入前提 把所有前提化成合取范式，将其中的所有简单析取式作为前提 应用归结规则进行推理 若推出空简单析取式（推出0），则证明推理正确 一阶逻辑 一阶逻辑也叫一阶谓词逻辑或谓词逻辑 在一阶逻辑中，公式的可满足性、永真性、永假性是不可能判定的。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:7:3","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"基本概念 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:8:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"个体词，谓词与量词 个体词 可以独立存在的具体或抽象的客体，分个体常项和个体变项 个体域：个体变项的取值范围 全总个体域：宇宙一切事物 谓词 刻画个体值性质及个体词间的关系，分谓词常项和谓词变项 n元谓词：$P(x_1,x_2,\\ldots,x_n)$，值为0或1 0元谓词：不带个体变项的谓词 特性谓词：将个体词与其他事物区别开来的谓词，$M(x)$ 量词 表示个体间的数量关系 全称量词：$\\forall$ 存在量词：$\\exists$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:8:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"符号化 一般而言，全称量词用蕴含，存在量词用合取。 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:8:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"一阶逻辑公式与分类 一阶语言字母表$\\mathscr{L}$ 个体常项：$a,b,c,\\ldots,a_i,b_i,c_i,\\ldots,i\\ge1$ 个体变项：$x,y,z,\\ldots,x_i,y_i,z_i,\\ldots,i\\ge1$ 函数符号：$f,g,h,\\ldots,f_i,g_i,h_i,\\ldots,i\\ge1$ 谓词符号：$F,G,H,\\ldots,F_i,G_i,H_i,\\ldots,i\\ge1$ 量词符号：$\\forall,\\exists$ 联结词符号：$\\neg,\\land,\\lor,\\rightarrow,\\leftrightarrow$ 括号与逗号：$(),,$ 公式 称$R(x_1,x_2,\\ldots,x_n)$为原子公式（谓词+项） 单一的原子公式或原子公式的各种组合称为合式公式（谓词公式），简称公式 辖域 在公式 $\\forall xA$ 和 $\\exists xA$ 中，称 $x$ 为指导变元，$A$ 为相应量词的辖域 在 $\\forall x$ 和 $\\exists x$ 的辖域中，$x$ 的所有出现都成为约束出现，$A$ 中不是约束出现的其他变项均称为是自由出现的 若公式 $A$ 中不含自由出现的个体变项，则称 $A$ 为封闭的公式，简称闭式 解释与赋值 闭式在任何解释下都变成命题 公式在给定解释和赋值后即成为命题 代换实例：用一阶逻辑替代命题逻辑所得的公式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:8:3","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"一阶逻辑的等值演算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:9:0","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"四个等值式 $\\forall$ 与 $\\lor$、$\\exists$ 与 $\\and$ 无分配律 例题 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:9:1","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"置换、换名规则 一阶逻辑的等值演算同样满足置换规则和换名规则（换名只能换约束变量） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:9:2","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"前束范式 定义：前面只能是量词的公式 定理：一阶逻辑任何公式都能化为前束范式 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/:9:3","tags":["离散数学"],"title":"离散数学1 第1-3章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A31-3/"},{"categories":["专业课"],"content":"关系 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:0:0","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的定义 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:1:0","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"有序对 两个元素按照一定次序构成的二元组称为一个有序对，记作 \u003cx, y\u003e​，区分第一元素和第二元素（即拥有有序性） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:1:1","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"笛卡尔积 设A，B为集合，以A中元素作为第一元素，B中元素为第二元素，构成的所有有序对叫做笛卡尔积，记为$A\\times B$，即 $$ A\\times B={\u003cx,y\u003e|x\\in A\\land y\\in B} $$ 性质 A，B有空集时，笛卡尔积为空集 不适合交换律 不适合结合律 对于并或交运算满足分配律 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:1:2","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"有序n元组和n阶笛卡尔积 $$ \u003cx_1,x_2,\\ldots,x_n\u003e \\ A_1\\times A_2\\times \\ldots\\times A_n={\u003cx_1,x_2,\\ldots,x_n\u003e|x_i\\in A_i} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:1:3","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"二元关系 若集合满足以下条件之一： 集合非空，它的元素都是有序对 集合是空集 则该集合是一个二元关系，简称关系，记作$R$ 如$\u003cx,y\u003e\\in R$，可记作$xRy$；如$\u003cx,y\u003e\\notin R$，可记作$x\\not Ry$ 例 从 $A$ 到 $B$ 的二元关系 $A\\times B$ 的任何自己所定义的二元关系叫做从 $A$ 到 $B$ 的二元关系，当 $A=B$ 时则叫做$A$上的二元关系 。==从 $A$ 到 $B$ 的二元关系近似看作 $A\\times B$ 的子集== 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:1:4","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的重要实例 全域关系 $$ E_A={\\langle x,y\\rangle|x\\in A\\land y\\in A}=A\\times A $$ 恒等关系 $$ I_A={\\langle x,x\\rangle|x\\in A} $$ 小于等于关系 $$ L_A={\\langle x,y\\rangle|x,y\\in A\\land x\u003cy}\\qquad A\\subseteq R $$ 整除关系 $$ D_A={\\langle x,y\\rangle|x,y\\in A\\land x整除y} \\qquad B\\subseteq Z^* $$ 包含关系 $$ R_{\\subseteq}={\\langle x,y\\rangle|x,y\\in A\\land x\\subseteq y} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:1:5","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的表示 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:2:0","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的集合表达式 懂的都懂 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:2:1","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系矩阵 设$R$是从$A$到$B$的关系，$R$ 的关系矩阵是布尔矩阵$M_R=(r_{ij}){m\\times n}$，其中$r{ij}=1\\Leftrightarrow \\langle x_i,y_j\\rangle\\in R $ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:2:2","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系图 $R$的关系图是$G_R=\\langle A,R\\rangle$，其中 A 为 G 的节点集 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:2:3","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的运算 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:3:0","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"基本运算 域 定义域：第一元素的集合，$domR$ 值域：第二元素的集合，$ranR$ 域：全体元素的集合，$fldR$ 逆 $$ R^{-1}={\\langle y,x\\rangle|\\langle x,y\\rangle\\in R} $$ 小于关系的逆是大于关系 整数关系的逆是倍数关系 合成运算 $$ R\\circ S={\\langle x,z\\rangle|\\exists y(\\langle x,y\\rangle\\in R\\land\\langle y,z\\rangle\\in S)} $$ 定理1：设$F$是任意的关系，则 $(F^{-1})^{-1}=F$ $domF^{-1}=ranF,ranF^{-1}=domF$ 定理2：设$F,G,H$是任意的关系，则 $(F\\circ G)\\circ H=F\\circ(G\\circ H)$ ==$(F\\circ G)^{-1}=G^{-1}\\circ F^{-1}$== 定理3：设$R$为$A$上的关系，则 $R\\circ I_A=I_A\\circ R=R$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:3:1","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"幂运算 定义 设$R$为$A$上的关系，则$R$的 n 次幂的定义为 $R^0={\\langle x,x\\rangle|x\\in A}=I_A$ $R^{n+1}=R^n\\circ R$ 定理 设$A$为$n$元集，$R$为$A$上的关系，则存在自然数 s 和 t，使得 $R^s=R^t$ 设$R$为$A$上的关系，有 $R^m\\circ R^n=R^{m+n}$ $(R^{m})^n=R^{mn}$ 设$R$为$A$上的关系，若存在自然数s和t$(s\u003ct)$，使得$R^s=R^t$，则 对任何$k\\in N$有$R^{s+k}=R^{t+k}$ 对任何$k,i\\in N$ 有 $R^{s+kp+i}=R^{s+i}$，其中 $p=t-s$ 令$S{R^o,R^1,\\ldots,R^{t-1}}$，则对于任意的$q\\in N$有$R^q\\in S$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:3:2","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的性质 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:4:0","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"定义及判别 自反 设$R$为$A$上的关系，有 若$\\forall x(x\\in A\\rightarrow\\langle x,x\\rangle \\in R)$，则称$R$在$A$上自反 若$\\forall x(x\\in A\\rightarrow\\langle x,x\\rangle \\notin R)$，则称$R$在$A$上反自反 自反：对角线全为 1 反自反：对角线全为 0 除空关系外，一个关系不可能同时是自反和反自反的 对称 设$R$为$A$上的关系，有 若 $\\forall x\\forall y(x,y\\in A\\ \\land\\langle x,y\\rangle \\in R\\rightarrow \\langle y,x\\rangle\\in R)$，则称$R$在$A$上对称 若 $\\forall x\\forall y(x,y\\in A\\ \\land\\langle x,y\\rangle \\in R\\land \\langle y,x\\rangle\\in R\\rightarrow x=y)$，则称$R$在$A$上反对称 对称：每个元素要么自我相等要么两两相反 反对称：每个元素不能两两相反（但可以自我相等） 一个关系可以同时是对称和反对称的 传递 设$R$为$A$上的关系，有 $$ \\forall x\\forall y\\forall z(x,y,z\\in A\\land \\langle x,y\\rangle\\in R\\land \\langle y,z\\rangle\\in R\\rightarrow \\langle x,z\\rangle\\in R) $$ 则称$R$是传递的 判别 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:4:1","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"关系的闭包 设$R$为$A$上的关系，若$R$不具有某种性质，可以通过在$R$中加入最少数量的有序对来补充$R$，使其具有某种性质 定义 设$R$为非空集合$A$上的关系，$R$的自反（对称或传递）闭包是$A$上的关系$R’$，使$R’$满足以下条件 $R’$是自反的（对称的或传递的） $R\\subseteq R'$ 对$A$上任何包含$R$的自反（对称或传递）关系$R’’$有$R’\\subseteq R’'$ 自反闭包：$r(R)$ 对称闭包：$s(R)$ 传递闭包：$t(R)$ 理解 想使一个关系拥有某一性质，向其中尽量少地添加一些有序对，形成的新关系称为闭包。 定理 设$R$为$A$上的关系，有 $r(R)=R\\cup R^0$ $s(R)=R\\cup R^{-1}$ $t(R)=R\\cup R^2\\cup R^3\\cup\\ldots$ 用矩阵关系表示 $M_r=M+E$ $M_S=M+M'$ $M_t=M+M^2+M^3+\\ldots$ 用图关系表示 $G_r$：在图$G$中每一个缺少环的结点都加一个环 $G_s$：将$G$中的单向边变成双向边 $G_t$： WarShall算法 例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:4:2","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"等价关系与偏序关系 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:5:0","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"等价关系 设$R$为非空集合$A$上的关系，若$R$是自反的，对称的，传递的，则称$R$为$A$上的等价关系， 对于任何元素 $x,y\\in A$，若$xRy$，则称 x, y 等价，记为$x\\sim y$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:5:1","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"等价类和商集 定义 按某一等价关系，将A的元素划分成若干个子集，彼此等价的元素被分在同一个子集里，这些子集称作这个等价关系产生的等价类。记作$[x]$ 性质 $\\forall x\\in A, $是$A$的非空子集 $\\forall x,y\\in A$，如果$xRy$，则$ =[y]$ $\\forall x,y\\in A$，如果$xRy$不成立，则$ $与$[y]$不交 $\\bigcup_{x\\in A} =A$，即$A$中元素构成的所有等价类的并集等于$A$ 商集 $A$上的全体等价类构成的集合称作$A$关于等价关系$R$的商集，记作$A/R$，即 $$ A/R={[x]_R|x\\in A} $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:5:2","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"集合的划分 定义 设$A$为非空集合，若$A$的子集族 $\\pi(\\pi\\subseteq P(A))$满足下面条件 $\\emptyset\\notin\\pi$（无空集） $\\forall x\\forall y(x,y\\in\\pi\\land x\\neq y\\rightarrow x\\cap y=\\emptyset)$（元素无公共部分） $\\bigcup_{x\\in\\pi}x=A$（拼起来是完整的） 则$\\pi$称是$A$的一个划分，称$\\pi$中的元素为$A$的划分块 商集$A/R$就是$A$的一个划分，所以又可以定义商集$R$ $$ R={\\langle x,y\\rangle|x,y\\in A\\land x与y在\\pi 的同一划分块中 } $$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:5:3","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"偏序关系 非空集合$A$上的自反、反对称和传递的关系称为$A$上的偏序关系，简称偏序，记作$\\preceq$ 若$\\langle x,y\\rangle\\in\\preceq$，则记作$x\\preceq y$，读作 x “小于等于” y​ 可比 设 $R$ 为非空集合 $A$ 上的偏序关系，$\\forall x,y\\in A$，若$x\\preceq y\\lor y\\preceq x$，则称 x 与 y 可比 拟序 设$R$为非空集合$A$上的偏序关系，若$R$是反自反的和传递的，则称$R$是$A$上的拟序关系，简称为拟序，记作$\\prec$ 全序 设$R$为非空集合$A$上的偏序关系，$\\forall x,y\\in A$，x与y都是可比的，则称$R$为全序关系，简称全序（或线序） 覆盖 设$R$为非空集合$A$上的偏序关系，$\\forall x,y\\in A$，若$x\\prec y$且不存在$z\\in A$使得$x\\prec z\\prec y$，则称y覆盖x​ 定义偏序关系$R$的一个子关系——覆盖关系$T$ $$ T={\\langle x,y\\rangle|\\langle x,y\\rangle\\in R且y覆盖x} $$ $T$的自反传递闭包$rt(T)$就等于$R$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:5:4","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"偏序集 集合$A$和$A$上的偏序关系$\\preceq$一起叫做偏序集，记作$\\langle A,\\preceq\\rangle$ 哈斯图 定义 利用偏序自反、反对称、传递性简化的关系图 特点 每个结点没有环 两个联通结点之间的序关系通过结点位置的高低表示，位置低的元素顺序在前 具有覆盖关系的两个结点之间连边 特殊元素或子集 设$\\langle A,\\preceq\\rangle$为偏序集，$B\\subseteq A,y\\in B$ 若$\\forall x(x\\in B\\rightarrow y\\preceq x) $成立，则称$y$为$B$的最小元 若$\\forall x(x\\in B\\rightarrow x\\preceq y) $成立，则称$y$为$B$的最大元 若$\\forall x(x\\in B\\land x\\preceq y\\rightarrow x=y) $成立，则称$y$为$B$的极小元 若$\\forall x(x\\in B\\land y\\preceq x\\rightarrow x=y) $成立，则称$y$为$B$的极大元 有性质如下 对于有穷集，极小元和极大元一定存在，还可能存在多个 最小元和最大元不一定存在，如果存在一定唯一 最小元一定是极小元，最大元一定是极大元 孤立结点既是极小元，也是极大元 设$\\langle A,\\preceq\\rangle$为偏序集，$B\\subseteq A,y\\in A$ 若$\\forall x(x\\in B\\rightarrow x\\preceq y) $成立，则称$y$为$B$的上界 若$\\forall x(x\\in B\\rightarrow y\\preceq x) $成立，则称$y$为$B$的下界 令$C={y|y为B的上界}$，则称$C$的最小元为$B$的最小上界或上确界 令$D={y|y为B的下界}$，则称$D$的最大元为$B$的最大下界或下确界 有性质如下 上界，下界，最大下界，最小上界不一定存在 如果下界，上界存在，也不一定是唯一的 最大下界，最小上界如果存在，则是唯一的 子集$B$的最小元就是他的最大下界，最大元就是他的最小上界；反之不对 理解 最小元素就是在子集中处于最低层且每个元素通过图中路径都可以找到它且它的下面没有元素。 极大元素就是在子集中它的上面没有元素。 极小元素就是在子集中它的下面没有元素。 （记住：这里如果是子集，应当将子集当成一个单独的整体，而不受全集的影响。） 上届：所有子集内的元素沿着路径向上都可以找到的元素（这里包括子集和子集以外的元素）。根据上面所说的话，我们可以断定上届也可以是子集内的元素。 下届：所有子集内的元素沿着路径向下都可以找到的元素（这里包括子集和子集以外的元素）。根据上面所说的话，我们可以断定下届也可以是子集内的元素。 上确界：这里我们可以将上届元素看成一个独立的整体，而上确界就是这个集合的最小元，我们称为最小上届。根据上面所说的话，我们可以断定上届也可以是上确界。 下确界：这里我们可以将下届元素看成一个独立的整体，而下确界就是这个集合的最大元，我们称为最大下届。根据上面所说的话，我们可以断定下届也可以是下确界。 特殊子集 设$\\langle A,\\preceq\\rangle$为偏序集，$B\\subseteq A$ 若$\\forall x,y\\in B$，$x$与$y$都是可比的，则称$B$是$A$中的一条链，$B$中的元素个数称为链的长度。 若$\\forall x,y\\in B,x\\neq y$，$x$与$y$都是不可比的，则称$B$是$A$中的一条反链，$B$中的元素个数称为反链的长度。 有定理 设$\\langle A,\\preceq\\rangle$为偏序集，若$A$中最长链的长度为$n$，则该偏序集可以分解为$n$条不相交的反链 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/:5:5","tags":["离散数学"],"title":"离散数学1 第4章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A34/"},{"categories":["专业课"],"content":"函数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:0:0","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"函数的定义及性质 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:1:0","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"定义 函数的定义 设 $f$ 为二元关系，若对于任意 $x\\in dom f$，都存在唯一的 $y\\in ran f$，使得 $xfy$ 成立，则称 $f$ 为函数（或映射），这时也称 $y$ 为 $f$ 在 $x$的 值，记作 $y=f(x)$ 函数相等 设$f,g$为函数，则 $$ f=g\\Leftrightarrow f\\subseteq g\\land g\\subseteq f $$ 根据上述定义，若$f$和$g$相等，一定满足下面两个条件 $domf=domg$，定义域相等 $\\forall x\\in domf=domg$ 都有 $f(x)=g(x)$，值相等 从A到B的函数 设$A,B$为集合，若 $$ f为函数,domf=A,ranf\\subseteq B $$ 则称$f$为从$A$到$B$的函数，记作$f:A\\rightarrow B$ B上A 所有从$A$到$B$的函数的集合记作 $B^A$，符号化表示为 $$ B^A={f|f:A\\rightarrow B} $$ 若 $|A|=m,|B|=n\\quad m,n\\neq 0$，则 $|B^A|=n^m$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:1:1","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"重要的函数实例 设 $f:A\\rightarrow B$，若存在 $c\\in B$ 使得对所有的 $x\\in A$ 都有 $f(x)=c$，则称 $f:A\\rightarrow B$ 是常函数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:1:2","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"函数的像与完全原像 像：一些 $f(x)$ 的集合 完全原像：一些 $x$ 的集合 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:1:3","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"函数的==性质== 。满射：大家都有对象 。单射：一夫一妻 。双射：一夫一妻，大家都有对象 单射一定是单调的，满射的值域一定等于 $B$ ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:1:4","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"函数的复合 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:2:0","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"反函数 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/:3:0","tags":["离散数学"],"title":"离散数学1 第5章","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A61/%E7%A6%BB%E6%95%A35/"},{"categories":["专业课"],"content":"离散数学二 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:0:0","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"捋一捋 图论 50 分；代数系统 50 分 选择不定项 选择判断填空各 2 分，共 30 分，七道大题 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:1:0","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"图 4 道大题 基本概念 概念为多，知道即可 握手定理必考，特别是在涉及到度数时 重点：简单图、完全图 连通性 割集割点等，简单考判断，复杂考找 矩阵表示 书例 6.10 考计算题，求通路数、回路数、邻接矩阵 特殊的图 哈密顿图的两个充分条件用处不大，找哈密顿回路即可 判断是否是欧拉图 / 哈密顿图（找回路就完事），找欧拉回路、哈密顿回路或说明理由。第二道大题 平面图 两道大题会涉及，一个计算一个证明 会计算顶点数、边数、面数；要用到握手定理、面次和公式、欧拉公式 小题：判断是不是平面图；大题：证明不是平面图 (?) P160 例 6.18 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:1:1","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"树 是图知识的应用 定理小看一哈 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:1:2","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"代数系统 二元运算 第一个大题：证明交换、结合、幂等；求单位元、零元、可逆元；判断系统是半群、群还是独异点 群 第二个大题：同态，证明子群 大题：循环群的生成元、子群、子群格 置换群的乘法、逆：考填空 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:1:3","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"图 图论是解决现实世界离散客体之间的关系的有力工具 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:2:0","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"基本概念 无向图与有向图 无序对与多重集合 无序对: 2 个元素构成的集合, 记作 (a,b) 无序积: $A \u0026 B={(x,y) | x\\in A\\land y\\in B}$ 多重集合: 元素可以重复出现的集合。 重复度: 元素在多重集合中出现的次数 无向图 $G=\u003cV, E\u003e$ 其中 $V\\neq \\empty$ 称为顶点集，其元素称为顶点或结点; E 是 V\u0026V 的多重子集，称为边集，其元素称为无向边，简称边。 有时用 V(G) 和 E(G) 分别表示 V 和 E 有向图 $D=\u003cV, E\u003e$ 其中 $V\\neq \\empty$ 称为顶点集，其元素称为顶点或结点； E是 V × V 的多重子集，称为边集，其元素称为有向边，简称边。 有时用 V(D) 和 E(D) 分别表示 V 和 E 关联与相邻（无向图） 关联：点和边 顶点相邻：顶点间有边 边相邻：两个边有公共端点 关联与相邻（有向图） 顶点相邻：顶点间有边 边相邻：两个边头对屁股 特殊的图 有限图: V, E 都是有穷集合的图 n 阶图: n 个顶点的图 零图: E = 空集的图 平凡图: 1 阶零图 空图: V = 空集的图 顶点的度数与握手定理（重点） 顶点的度数（无向图） 顶点的度数（有向图） 握手定理 定理：任何图（无向图和有向图）的所有顶点度数之和都等于边数的 2 倍 ​ 理解：在计算各顶点度数之和时, 每条边均提供 2 度, m 条边共提供 2m 度 推论：任何图（无向图和有向图）都有偶数个奇度顶点 定理：有向图所有顶点的入度之和等于出度之和等于边数 ​ 理解：每条边恰好提供1个入度和1个出度 事实上，一个度数列可图化当且仅当度数之和为偶数。 图的度数列（无向图） 图的度数列（有向图） 例 简单图、完全图、正则图、圈图、轮图、方体图 简单图 无向图中，关联同一对顶点的 2 条或 2 条以上的边, 称为平行边, 平行边的条数称为重数 在有向图中, 具有相同始点和终点的 2 条或 2 条以上的边称为有向平行边, 简称平行边, 平行边的条数称为重数 含平行边的图称为多重图 既无平行边也无环的图称为简单图 完全图 正则图 圈图 轮图 方体图 子图、补图 子图 补图 顶点集合相同，边集合取补集 图的同构 （重点） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:2:1","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"连通性 通路与回路 定义 初级通 / 回路：点各异，更彻底 简单通 / 回路：边各异 说明 定理 无向图的连通性与连通度 定义 例 连通分支并不是连通图独有，而是都有 短程线与距离 定量评价连通性 减号概念 点割集 点割集：是个集合，点割集里的点被删掉后，图的连通分支数会增加，且点割集的子集不能是点割集 点割集只能是顶点集的真子集，因此完全图没有点割集 割点：只有一个元素的点割集 边割集 边割集是边集的子集 完全图没有点割集 零图没有点割集（删点变小）和边割集（无边） 连通图删掉边割集后，p = 2；删点则不一定 点连通度与边连通度 点连通度：长度最小的点割集的元素个数，或删点删到平凡图所删点的个数，两者取最小值 边连通度：长度最小的边割集的元素个数 点连通度与边连通度不会大于最小度 有向图的连通性及其分类 定义 有圈：强连通 有穿起所有点的线：单项连通 强连通图与单向连通图的判定定理 有向图中的短程线与距离 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:2:2","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"矩阵表示 无向图的关联矩阵 行为点，列为边 定义 性质 有向无环图的关联矩阵 有向图的邻接矩阵 表示点和点的邻接关系 定义 性质 某顶点的行之和 = 此顶点的出度 某顶点的列之和 = 此顶点的入度 总和 = 边数 对角线和 = 环数 有向图中的通路数与回路数 代表 v~4~ 到 v~1~ 有三条长为 2 通路 $a_{ij}^{(n)}$ 表示 v~i~ 到 v~j~ 长为 n 的通路的条数 例 为 2 1 1 0 为 4 3 2 0 有 15 条，3 条回路 有 10 条 无向图的相邻矩阵 定义 图的可达矩阵 综合例题 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:2:3","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"几种特殊的图 二部图 定义 顶点分成两部分，使所有边都从一部分连到另一部分，同一部分内的顶点不能相邻 判别定理 二部图当且仅当没有奇长度回路 匹配 匹配：不相邻的边集 极大匹配：不能再加边 最大匹配：边数最多 完备匹配：一边中的点都被连到 完美匹配：所有点都被连到 存在完备匹配的条件 存在完备匹配当且仅当 v~1~ 中任意 k 个顶点至少连接 V~2~ 中 k 个顶点 例 欧拉图 一笔画，简单通路（回路） 存在 “经过所有顶点、每条边恰好经过一次” 的回路 定义 无向欧拉图判别定理 无奇度顶点的连通图 有向欧拉图判别定理 所有顶点的入读等于出度的连通图 求欧拉图中欧拉回路的算法 ==能不走桥就不走桥== 例 哈密顿图 找哈密顿图的技巧 找出二度点，列出必经之路，连接 定义 存在 “每个点经过且只经过一次” 的回路 必要条件 定理 6.12 用逆否命题可以证伪，不可以证真 另一种必要条件 二部图（r 和 s） 个数差一，通路； 个数相同，回路； 个数差二以上，没有路 充分条件 任意两个不相邻点度数和大于等于 n 可以证真，不可证伪 欧拉图与哈密顿图的判别方法 平面图 定义 平面图与平面嵌入 平面图的面及其次数 面次和定理 极大平面图 不能加平行边，因为基于简单图 概念 充要条件：每个面的次数都是 3 故，次数是 4 可以加边，次数是 3 加不了 性质 极小非平面图 例子：K~5~ 和 K~3，3~ 欧拉公式（重要） 推论 推广 例 库拉图斯基定理 同胚与收缩 定理 例 平面图的对偶图 定义 性质 定理 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:2:4","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"树 只学习无向树 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:3:0","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"定义 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:3:1","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"性质 证明 其他性质 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:3:2","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"树与各种特殊图的关系 树是二部图 树一定不是欧拉图（没有回路） 树一定不是哈密顿图（没有回路） 树一定是平面图 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:3:3","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"实例 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:3:4","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"生成树 定义 存在 最小生成树 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:3:5","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"代数系统 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:4:0","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"二元运算及其性质 二元运算与一元运算的定义 运算 -\u003e 函数 -\u003e 关系 $\\langle\\langle x,y\\rangle,z \\rangle$ 二元运算 一元运算 算符 运算表 二元运算的性质 交换、结合、幂等 分配、吸收 二元运算的特异元素 单位元 零元 可逆元素及其逆元 唯一性定理 当一个运算同时拥有左右单位元，其左右单位元必然相等 当一个运算同时拥有左右零元，其左右零元必然相等 当一个运算同时拥有左右逆元，其左右逆元必然相等 一个运算，可以有两个左单位元，但同时不可能再有右单位元。零元、逆元同理 消去律 封闭性、结合律、有单位元、有逆元，符合这四个条件的运算，即具有消去律 交换律看对称，结合律很麻烦，幂等律看对角线 单位元看行均为列值，零元看行列均为本身，逆元看表中为单位元的组合 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:4:1","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"代数系统 代数系统的定义与实例 定义 实例 代数系统的分类 公理系统 1（环） 第一个运算有：结合律、单位元、逆元 第二个运算：结合律 第二运算对第一运算可分配 公理系统 3（域） 第一个运算有：交换律、结合律、单位元、逆元 非零元素全体对第二个运算：交换律、结合律、单位元、逆元 第二运算对第一运算可分配 V~1~ 和 V~2~ 是环，V~3~ 不是环 V~1~ 是域 子代数系统 定义 术语 例 意义 积代数系统 定义 $\\langle x_1,y_1\\rangle \\centerdot \\langle x_1.y_2\\rangle =\\langle x_1\\circ x_2,y_1*y_2\\rangle$ 积代数可以推广到多个运算。 性质 意义 代数系统的同态与同构 同态映射的定义 同态映射的分类 满同态映射的性质（意义） ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:4:2","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["专业课"],"content":"几个典型的代数系统 入个门儿 半群与独异点 定义 半群：封闭性、结合律 独异点：封闭性、结合律、单位元 实例 幂运算 子代数 也叫子半群、子独异点 积代数 两个半群的积代数也是半群 两个独异点的积代数也是独异点 同态 群 定义 封闭性、结合律、单位元、逆元 实例 术语 性质 幂运算规则 群方程存在唯一解 消去律 群中元素阶的性质 应用 子群 定义 判定定理 证明题必考 定理一：封闭性 + 逆元即可判定 定理二：定理一的合并 重要子群的实例 子群格 必考！ 就是哈斯图 同态与同构 同态的定义与分类 群同态的性质 群同态的实例 循环群 必考，大题写子群、子群格 定义 循环群可由生成元来生成 分类 无限循环群：生成元的阶是无限阶 n 阶循环群：生成元的阶数为 n 循环群的生成元 无限循环群的生成元只有两个：a 和 a^-1^ n 阶循环群生成元的个数为：小于 n 且与 n 互素的整数 r 的个数；而且所有 a^r^ 都是 G 的生成元 循环群的子群 置换群 小题，考置换运算 n 元置换的定义 下图 $\\sigma$ 也可以写成轮换 $\\sigma=(134)(25)$ 两个置换的乘积即函数的复合 k 阶轮换与对换 一阶轮换可以省略 轮换几乎总是从 1 开始 例：n 元置换分解为轮换 例：求 (15236) (78) 的逆 (16325) (78) 分解为对换（不考） 奇置换与偶置换 n 元置换的乘法与求逆 n 元置换群及其实例 n 元对称群的子群叫 n 元置换群 S~3~ 的置换表 ","date":"2021-10-23","objectID":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/:4:3","tags":["离散数学"],"title":"离散数学2","uri":"/Notes/posts/courses/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A62/"},{"categories":["其他"],"content":"66号公路 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/66%E5%8F%B7%E5%85%AC%E8%B7%AF/:0:0","tags":["Overwatch"],"title":"破坏球点位-66 号公路","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/66%E5%8F%B7%E5%85%AC%E8%B7%AF/"},{"categories":["其他"],"content":"进攻 视野 两个绕后点，上高台 撞下，压 超级跳去压高台，难度大 荡上高台 撞人下桥 C段：抬头乱钩 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/66%E5%8F%B7%E5%85%AC%E8%B7%AF/:1:0","tags":["Overwatch"],"title":"破坏球点位-66 号公路","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/66%E5%8F%B7%E5%85%AC%E8%B7%AF/"},{"categories":["其他"],"content":"防守 开局视野 开局视野 压完后来到这里 上高台 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/66%E5%8F%B7%E5%85%AC%E8%B7%AF/:2:0","tags":["Overwatch"],"title":"破坏球点位-66 号公路","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/66%E5%8F%B7%E5%85%AC%E8%B7%AF/"},{"categories":["其他"],"content":"阿努比斯 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:0:0","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"进攻A点 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:1:0","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"左路 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:1:1","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"右路 或者荡过去 荡，压 或者绕道房间里 利用拱桥高低差，压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:1:2","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"中走，绕后 荡，撞，压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:1:3","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"其他钩点 可压点，也可压右边高台 点内、左右高台均可压 转一圈，撞下高台，难度高 可下压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:1:4","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"进攻B点 压点，铺雷；或者将人撞下小桥 砖石柱均可蹭墙下压 可下压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:2:0","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"防守A点 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:3:0","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"赶路 荡到高台，下压进点 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:3:1","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"视野 荡到长平台上 荡到船上（钩外面狗头也可） ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:3:2","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"绕后 荡上长平台切狙 从长平台跳下，把敌人撞进去 撞，压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:3:3","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"防守B点 1、蹲人 2、视野 荡上高台，可以跳下撞人 绕侧面荡上高台切狙 3、前压收过路费，站高台 biubiubiu 4、撞下小桥，造成暂时减员 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/:4:0","tags":["Overwatch"],"title":"破坏球点位-阿努比斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E9%98%BF%E5%8A%AA%E6%AF%94%E6%96%AF/"},{"categories":["其他"],"content":"国王大道 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:0:0","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"进攻 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:1:0","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"A点 上高台，绕后 好视野，撞，压（落地低一点再撞） 赶路，点里铺雷 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:1:1","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"B段 绕后位，视野 反向 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:1:2","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"C段 抬头可钩 两个高台位 骚气绕后点位 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:1:3","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"防守 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:2:0","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"A段 钩到左边高台 视野 向左或向右 B 段和 C 段，思路基本与进攻类似，防守当进攻打了属于是 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/:2:1","tags":["Overwatch"],"title":"破坏球点位-国王大道","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%9B%BD%E7%8E%8B%E5%A4%A7%E9%81%93/"},{"categories":["其他"],"content":"哈瓦那 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:0:0","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"进攻 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:1:0","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"A段 若对面打前点，绕后视野 或 上高台 视野，绕后撞、压 抓高台洞口的人 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:1:1","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"B段 抬头可抓 视野，将对面撞下二楼 视野，偷车 绕后，逃跑 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:1:2","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"C段 绕后压 上左侧高台，或 难度较高 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:1:3","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"防守 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:2:0","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"A段 开心蹭车点位 视野 拐角荡，压 团战结束后的落位视野 压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:2:1","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"B段 两个抓钩点 落位视野 落位视野，对面走二楼直接撞下去 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:2:2","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"C段 视野 荡，压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/:2:3","tags":["Overwatch"],"title":"破坏球点位-哈瓦那","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%93%88%E7%93%A6%E9%82%A3/"},{"categories":["其他"],"content":"努巴尼 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:0:0","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"进攻 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:1:0","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"视野 看狙 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:1:1","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"绕后 撞后点（大概率奶），或者荡下去压前点 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:1:2","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"打楼梯高台 荡，压 或者绕后撞 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:1:3","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"点内铺雷 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:1:4","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"BC段 思路：绕后撞，踩二楼 视野，原地下压 逃跑路线 压，撞 绕后撞，或车旁铺雷 站高台，切挂后奶 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:1:5","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"防守 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:2:0","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"视野 对面正面打 —— 绕后撞或压 对面上高台 —— 绕后撞 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:2:1","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"B段防守 绕后视野 撞 或者上高台压 地形杀 站高台，视野，压 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:2:2","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"C段防守 占高台，撞 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/:2:3","tags":["Overwatch"],"title":"破坏球点位-努巴尼","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E5%8A%AA%E5%B7%B4%E5%B0%BC/"},{"categories":["其他"],"content":"伊利奥斯 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:0:0","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"深井 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:1:0","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"地形杀落位 这是第一种 第二种 最终到达这个小房间进行地形杀 这里也能地形杀 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:1:1","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"前点 荡 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:1:2","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"绕后 绕后，荡 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:1:3","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"点内铺雷 荡一会儿 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:1:4","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"灯塔 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:2:0","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"赶路 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:2:1","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"地形杀 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:2:2","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"废墟 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:3:0","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"落位 这个点还可以上高台抓狙 前压落位 堵门落位 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:3:1","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"地形杀 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:3:2","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"钩点 可上高台 ","date":"2021-10-23","objectID":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/:3:3","tags":["Overwatch"],"title":"破坏球点位-伊利奥斯","uri":"/Notes/posts/games/overwatch/%E7%A0%B4%E5%9D%8F%E7%90%83%E7%82%B9%E4%BD%8D/%E4%BC%8A%E5%88%A9%E5%A5%A5%E6%96%AF/"},{"categories":["其他"],"content":"文明六 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:0:0","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"战斗技巧 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:1:0","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"城墙的处理 一般套路： 小马打无墙； 火枪 + 破城槌 / 攻城塔打远古 / 中世纪城墙； 热气球 + 大炮 支援单位 破城槌：针对远古城墙（100 点），跟近战和抗骑兵配合 攻城塔：针对中世纪城墙（200 点） 以上两者对文艺复兴城墙（300 点）无效 攻城单位 石弩（工程科技）- 射石炮 - 大炮 - 火箭炮 石弩不能走 A，可配合大将军食用，实现走 1 打 1；同时波斯和哥伦比亚文明可以加移速 一般情况下 3 石弩可以秒城墙 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:1:1","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"兵种 近战 兵种：勇士（远古）- 剑客（古典）- 火枪手（文艺复兴）- 步兵（现代）- 机械化步兵（信息时代） 特点：对抗骑兵 +10，移速慢 关系：克制抗骑兵 定位：杀抗，清野蛮人营地 侦察兵 兵种：侦察兵（远古）- 散兵（中世纪） - 游骑兵（工业） - 特种部队（原子能） 定位：顾名思义 远程 兵种：投石兵（默认）- 弓箭手（远古）- 弩手（中世纪）- 野战加农炮（工业）- 机关枪队（原子能） 特点：防御比攻击低 10；移速慢；终极兵种较弱，一旦低于世代就降一个档次； 关系：克制近战与枪兵；怕骑兵（移速快） 定位：集火，克制近战与枪兵 重骑兵 兵种：重型战车（远古）- 骑士（中世纪）- 胸甲骑兵（工业）- 坦克（现代）- 现代坦克（信息时代） 特点：比时代平均战斗力高，无视区域移动 4；当与城墙力差超过 23 时，可以无脑攻城 关系：怕抗骑兵 定位：最强大的兵种，用于击杀对方主力战队，有时即使是硬刚抗骑兵也不见得是劣势 轻骑兵 兵种：骑手（小马，古典）- 追猎者（中世纪）- 骑兵（工业）- 直升飞机（原子能） 特点：作战能力弱于重骑兵，但是科技线更友好；移速快；直升机垃圾，所以这种兵种无后期 定位：掠夺，护送单位，利用高移动力去击杀远程和攻城 抗骑兵 兵种：枪兵（远古）- 长矛兵（中世纪）- 枪刺与射击方针（文艺复兴）- 反坦克组（现代）- 现代反坦克组（信息时代） 特点：对骑兵 +10，对近战 -10，移速慢 关系：克制骑兵（但是追不上），怕近战 定位：用于防守，比较拉跨 攻城兵 兵种：石弩（古典）- 射石炮（文艺复兴）- 大炮（现代）- 火箭炮（信息时代） 特点：大炮前防御 -12，很脆，几乎就用来攻城 定位：攻城（文艺复兴城墙后也没得选）；吸引伤害（优先被 AI 集火） 空军 指战斗机和轰炸机 兵种：双翼机（现代）- 战斗机、轰炸机（原子能）- 喷气式战斗机、喷气式轰炸机（信息时代） 特点：要很多铝 定位：很强，但用不上，吉祥物 海军 1 指海军近战和航空母舰 兵种：桨帆船（远古）- 轻快帆船（文艺复兴）- 装甲舰（工业）- 驱逐舰、航空母舰（原子能） 定位：前期海军近战很强；后期航空母舰无敌 海军 2 指海军远程和海军袭击 兵种：四段帆船（古典）- 私掠船、护卫舰（文艺复兴）- 战舰、潜艇（现代）- 导弹巡航舰、核潜艇（信息时代） 特点：四段帆船很垃圾，文艺复兴后的海战以远程和袭击为主 定位：后期海战主力、攻城主力；盘古大陆没啥用 支援单位 破城槌 近战和抗骑兵对远古城墙伤害 100% 实际效果比攻城塔好，因为墙破了可以直接骑兵直接撞 最好在机械科技完成前做一个 攻城塔 近战单位攻击远古城墙、中世纪城墙的城市直接扣血 观测气球、无人机 远程 +1 范围，相当于城防打不到你 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:1:2","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"战术 节奏 远古时期 科技优先走箭术、铸铜；人文走帝国初期 视马资源决定走弓兵线还是骑兵线，弓兵线在早期出大量投石升级弓箭或直接出弓箭，骑兵线需要出一定量建造者砍树爆发 远古或古典一波 在 50t 左右发动，目的是歼灭一个文明，大概在 70t 左右完成，主要是利用电脑铁资源匮乏、古典兵种没有大规模应用的弱点 中世纪一波 通过雇佣兵获得一个时代的军队，可以针对科技强的 AI 下手，100t 左右拿下一家 文艺复兴一波 文艺复兴时期优势不大，在收支平衡的前提下发展科技和人文 工业革命一波 优势很大，果断进攻，新兵老兵合成军团 弓棒一波 远古时代一波 思路 点箭术，早期多造投石弓箭，差不多 6 个，勇士 2-3 个即可 弓棒一波，拿下第一家，然后锤两台战车，卡好节奏，攒好钱，工程出来了直接买石弩，一台石弩顶着拆第二家，期间机械能研究出来，直接升级，打第三家的时候有铁骑，打第四家有野战炮，打第五家有军团，打第六第七家有大炮坦克，150t 稳定征服胜利，核心就是高科技兵种 六弓一棒第一波打下第一家邻居，然后锤两台重型战车，科技直奔工程，攒好钱，研究完成直接买一台石弩直奔第二家，期间可以买或者锤第二台石弩，顺便升弩手，推第三家的时候升铁骑，推第四家升射石炮，推第五家升野战炮和胸甲骑，推第六家组军团，最后一家升大炮坦克 小马一波 古典一波 思路 科技集中走畜牧、箭术、骑马、采矿和铸铜术，因为只需 5 个科技，可以较快解锁骑手 利用马总督 + 砍树几回合就能造出骑手，骑手移动力高，可以赶在对手未出城墙前攻下城市 一般征服：狗，移民，农民开，开局科技走畜牧找马，一分落地圈马、锤小碑（纪念碑） 评价 等对方建好城墙，骑手打城墙就只能发挥15%实力了 古典时期打下来两个国家。差不多这局就赢了 铁剑一波 古典时代一波 思路 出寡头，勇士可以直升，铁资源要求很高 可以纯铁流或剑弓流 弩剑一波 中世纪一波 人文必出雇佣兵 古典剑弓流升级版，剑客比较弱，负责适当攻城，打枪兵很强 小马流可以升级追猎流 中世纪混合 骑兵系远程系杀敌，火枪手攻城 工业革命混合 工业革命优势最大 出民族主义 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:1:3","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"一回合快速攻城 奇技淫巧！ 远古时期 没有城墙 4 勇士 古典时期 远古城墙 2 投石机，3 剑客 中世纪时期 中世纪城墙 3 射石炮，2 披甲勇士 文艺复兴时期 文艺复兴城墙 9 射石炮，3 火枪手 工业时期 13 射石炮，3 列线步兵 现代 14 大炮，3 步兵 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:1:4","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"开局技巧 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:2:0","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"坐城 三环内多于三棵树 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:2:1","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"生产顺序 猴，投石兵，开拓者，建造者 第一个锤最好改良奢侈品，交易直接换现金 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:2:2","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"理念 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:3:0","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":["其他"],"content":"种田 锤粮平衡 若粮食 / 生产力以人口 * 3 为界限 远古、古典：粮 \u003e 锤，最好（有人口的） 4 倍以上 中世纪、文艺复兴：粮 = 锤，都保持 3 - 4 倍以上，锤要慢慢超过 4 倍 工业革命后：粮 \u003c 锤，粮食保持 3 倍以上，锤子追求 5 倍以上 前期妹子锤地块的优先度：1 粮 \u003e 1 锤 \u003e 1 科技 / 文化 / 信仰 \u003e 1 金 ","date":"2021-10-23","objectID":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/:3:1","tags":["Game"],"title":"文明六小技巧","uri":"/Notes/posts/games/%E6%96%87%E6%98%8E%E5%85%AD/"},{"categories":null,"content":"棋盘覆盖问题 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"实验分析 使用分治思想解题，比较合理。 将棋盘分为四块，为使得每个子棋盘都含有一个特殊方格，取一个 L 型骨牌覆盖在棋盘汇合之处，作为子棋盘的特殊方格；递归分割，直到 1×1 棋盘为止。 pos = 特殊方块位置 for 子棋盘s in 子棋盘集: if pos in 子棋盘s: 递归 else: 将子棋盘汇合处的方块设为特殊方块 递归 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"实验代码 本实验使用 Python 完成编写，使用 numpy 处理矩阵数据、matplotlib 完成逐帧画图功能。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"代码实现 import numpy as np import matplotlib.pyplot as plt class Board: def __init__(self, size: int, x: int, y: int, case_id: int = 1): ''' 棋盘 :param size: 棋盘长 :param x: 特殊点横坐标 :param y: 特殊点纵坐标 :param case_id: 样例号 ''' self.special_block = (x, y) # 特殊块的坐标 self.board = np.zeros((size, size), dtype=int) self.board[x][y] = (size ** 2 - 1) / 3 + 1 # 给特殊块一个最大的标号 self.count = 1 # 骨牌号码，递增 self.size = size self.case_id = case_id # 样例号 self.chess_board(0, 0, self.size, x, y) plt.ion() # 开启画图窗口 def frame_img_show(self): \"\"\" 展示棋盘 \"\"\" plt.clf() # 清空图像 plt.imshow(self.board, cmap=plt.get_cmap('seismic')) # 热力图 plt.colorbar() # plt.show() plt.pause(0.1) plt.ioff() # 关闭画图窗口 def img_show(self): \"\"\" 展示棋盘 \"\"\" plt.imshow(self.board, cmap=plt.get_cmap('OrRd')) # 热力图 plt.colorbar() plt.show() def matrix_show(self): \"\"\" 展示矩阵 \"\"\" board = self.board print('Case {}: n={}'.format(self.case_id, self.size)) for row in board: for col in row: if col == (self.size ** 2 - 1) / 3 + 1: print('#\\t', end='') else: print(str(col)+'\\t', end='') print('') def fill_block(self, x, y): ''' 填充点(x, y) :param x: 横坐标 :param y: 纵坐标 ''' if self.board[x][y] == 0: self.board[x][y] = self.count else: raise Exception def chess_board(self, start_row, start_col, size, special_row, special_col): ''' 递归覆盖棋盘 :param start_row: 区块左上角横坐标 :param start_col: 区块左上角纵坐标 :param size: 区块长 :param special_row: 特殊方块横坐标 :param special_col: 特殊方块纵坐标 ''' if size == 1: return # 算出特殊方块处于哪个子区块中，其值将是sub_block_pos之一 pos = ( round((special_row - start_row + 1) / size), round((special_col - start_col + 1) / size) ) # 算出区块的中心偏左上坐标 center = (round(start_row + size / 2 - 1), round(start_col + size / 2 - 1)) sub_block_pos = ((0, 0), (0, 1), (1, 0), (1, 1)) # 代表四个子区块 # 将骨牌覆盖至中心汇合处 for i in sub_block_pos: if i != pos: # 若特殊快不在此区块，则构造特殊点并填充 x = center[0] + i[0] y = center[1] + i[1] self.fill_block(x, y) self.count += 1 # 为下一骨牌标号 self.frame_img_show() # 递归 for i in sub_block_pos: if i != pos: # 若特殊方块不在此区块中，构造特殊点，递归 x = center[0] + i[0] y = center[1] + i[1] start_x = start_row + i[0] * (size / 2) start_y = start_col + i[1] * (size / 2) self.chess_board(start_x, start_y, size / 2, x, y) else: # 若特殊方块就在此区块中，递归 start_x = start_row + i[0] * (size / 2) start_y = start_col + i[1] * (size / 2) self.chess_board(start_x, start_y, size / 2, special_row, special_col) if __name__ == '__main__': print('请输入正整数 k(棋盘大小为 2^k,2^k)、特殊块的横坐标、特殊块的纵坐标: ') lines = [] while True: try: lines.append(input()) except: break for (i, line) in enumerate(lines): try: k, x, y = (int(i) for i in line.split(' ')) b = Board(size=2 ** k, x=x, y=y, case_id=i) b.matrix_show() b.img_show() except ValueError: print(\"输入数据不正确！\") ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"输入 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"矩阵输出 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:2:3","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"可视化展示 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:2:4","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"体会 本实验算法的思路并不难，用 python 来构建再合适不过，我使用 numpy 的矩阵数据结构来处理棋盘，借用 matplotlib 中的热力图来展示棋盘，尽可能利用语言、功能库本身的强大属性来构建我所想要的效果。 本实验也让我对分治思想有了进一步的理解。 可视化只起到了锦上添花的作用，而算法思路始终是重中之重，不可喧宾夺主。今后我也会朝着 “用尽量精简的代码做出更丰富完整的可视化展示” 的方向继续努力。 代码的编写过程中我也遇到了一些问题，如怎么让图片逐步、逐帧展示、怎么用渐变颜色来代表递归深度，最后都在绘图模块中找到了答案。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%80/"},{"categories":null,"content":"装载问题 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/"},{"categories":null,"content":"问题分析 装载问题适合用回溯法来解。 对 n 个集装箱，共有 2^n^ 种装载方法，可以用一个完全二叉树来包含所有的情况。每一层代表一个集装箱，共 n 层，除叶子结点外，对任意一层 i 而言，每个结点有两个分支，分别代表将集装箱 i 搬至船 c~1~ 或 c~2~，如图所示 用递归的形式访问每一层结点；可以设置一个限界函数：当当前 c~1~ 上集装箱的总重 + 岸上剩余集装箱的总重 \u003e 当前 c~1~ 的最佳总重时，允许访问右子树，继续寻找最优解，这样可以对那些确定找不到最优解的结点完成剪枝，加快运行效率。 用回溯法解此问题，时间复杂度为 $O(2^n)$ ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/"},{"categories":null,"content":"实验代码 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/"},{"categories":null,"content":"代码实现 from typing import List class Load: def __init__(self, n: int, weight: List[int], c1: int, c2: int): self.n = n # 集装箱总个数 self.weight = weight # 集装箱重量数组 self.c1 = c1 self.c2 = c2 self.best_weight = 0 # 船c1的最佳载重量 self.current_weight = 0 # 当前船c1的载重量 self.remaining_weight = sum(weight) # 剩余集装箱的总重 self.x = [0 for _ in range(self.n)] # 当前解 self.best_x = [0 for _ in range(self.n)] # 当前最优解 def get_result(self): self.backtrack(0) c2_weight = 0 for (index, x) in enumerate(self.best_x): c2_weight += self.weight[index] if x == 0 else 0 if c2_weight \u003e self.c2: print('No') else: print(self.best_weight, end=' ') print(''.join(map(str, self.best_x))) def backtrack(self, i: int): \"\"\" 搜索第i层结点 :param i: 当前二叉树深度 \"\"\" if i \u003e= self.n: # 到达叶结点 if self.current_weight \u003e self.best_weight: self.best_x = self.x[:] self.best_weight = self.current_weight # 更新 return self.remaining_weight -= self.weight[i] # 搜索左子树 if self.current_weight+self.weight[i] \u003c= self.c1: # c1仍能承载当前集装箱的话 self.x[i] = 1 # 记录第i个集装箱装进c1 self.current_weight += self.weight[i] self.backtrack(i+1) self.current_weight -= self.weight[i] # 还原当前载重量 # 搜索右子树 if self.current_weight+self.remaining_weight \u003e self.best_weight: # 满足限界函数，才有可能找到最优解 self.x[i] = 0 self.backtrack(i+1) self.remaining_weight += self.weight[i] # 还原岸上剩余重量 if __name__ == '__main__': count = 1 while True: n = int(input(\"请输入集装箱个数: \")) weight = list(map(int, input(\"请依次输入集装箱重量: \").split())) c = list(map(int, input(\"请依次输入船c1和c2的载重量: \").split())) load = Load(n=n, weight=weight, c1=c[0], c2=c[1]) print('Case {}'.format(str(count))) load.get_result() count += 1 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/"},{"categories":null,"content":"输出 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/"},{"categories":null,"content":"体会 题目的思路就是尽可能地装满一条船，然后考虑剩余的集装箱能否装上另一条船，那么用深度优先的回溯思想来处理这个问题是一个非常好的思路，界限函数也可以剪掉一些分支加快运行速度。 对于递归函数中那些全局变量，我没有使用 python 中的 global 关键字将他们定义为全局变量，而是将算法封装在一个类中，把全局变量作为类的成员函数来用。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%83/"},{"categories":null,"content":"最长公共子序列 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"实验分析 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"概念 子序列：若给定序列 $X={x_1,x_2,…,x_m}$，则另一序列 $Z={z_1,z_2,…,z_k}$是 X 的子序列，是指存在一个严格递增下标序列 ${i_1,i_2,…,i_k}$ 使得对于所有 j=1,2,…,k 有：$Z_j=X_{ij}$ 公共子序列：给定两个序列 X 和 Y，当另一序列 Z 既是 X 的子序列又是 Y 的子序列时，称 Z 是序列 X 和 Y 的公共子序列 设序列 $X={x_1,x_2,…,x_m}$ 和 $Y={y_1,y_2,…,y_n}$ 的最长公共子序列为 $Z={z_1,z_2,…,z_k}$，则 若 $x_m=y_n$，则 $z_k=x_m=y_n$，且 Z~k-1~ 是 X~m-1~ 和 Y~n-1~ 的最长公共子序列 若 $x_m≠y_n$ 且 $z_k≠x_m$，则 Z 是 X~m-1~ 和 Y 的最长公共子序列 若 $x_m≠y_n$ 且 $z_k≠y_n$，则 Z 是 X 和 Y~n-1~ 的最长公共子序列 当 i=0 或 j=0 时，空序列是 $X_i$ 和 $Y_j$ 的最长公共子序列，此时 $c[i][j]=0$。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:1:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"动态方程 $$ c[i][j]=\\begin{cases}0,i=0、j=0\\c[i-1][j-1]+1,i、j＞0;x_i=y_j\\max(c[i][j-1],c[i-1][j]),i、j\u003e0;x_i≠y_j\\end{cases} $$ ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:1:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"实验代码 使用 Python 编写 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"代码实现 # 最长公共子序列 from typing import List def lcs(a, b): lena = len(a) lenb = len(b) c = [[0 for i in range(lenb+1)] for j in range(lena+1)] # 存储Xi和Yj的最长公共子序列的长度 flag = [[0 for i in range(lenb+1)] for j in range(lena+1)] # 记录c[i][j]的值是由哪个子问题的解得到的 for i in range(lena): for j in range(lenb): if a[i] == b[j]: c[i+1][j+1] = c[i][j]+1 flag[i+1][j+1] = '↖' elif c[i+1][j] \u003e c[i][j+1]: c[i+1][j+1] = c[i+1][j] flag[i+1][j+1] = '←' else: c[i+1][j+1] = c[i][j+1] flag[i+1][j+1] = '↑' return c, flag def print_all_lcs(c, i, j, a, b, lcs_list: List[str]): \"\"\" 输出所有最长公共子序列 :param c: c表 :param a: 序列a :param b: 序列b :param i: 序列a长度 :param j: 序列b长度 :param lcs_list: 倒序存放最长公共子序列字符的列表 \"\"\" if i == 0 or j == 0: print(''.join(lcs_list[::-1])) return if a[i-1] == b[j-1]: lcs_list.append(a[i-1]) print_all_lcs(c, i-1, j-1, a, b, lcs_list[:]) else: if c[i-1][j] \u003e c[i][j-1]: print_all_lcs(c, i-1, j, a, b, lcs_list[:]) elif c[i-1][j] \u003c c[i][j-1]: print_all_lcs(c, i, j-1, a, b, lcs_list[:]) else: # 左与上相等，说明有两个最长公共子序列，递归寻找 print_all_lcs(c, i - 1, j, a, b, lcs_list[:]) print_all_lcs(c, i, j-1, a, b, lcs_list[:]) def get_lcs(a, b): \"\"\" 最长公共子序列入口函数 \"\"\" c, flag = lcs(a, b) print('输出c表') for i in c: print(i) print('') print('输出b表') for row in flag: for col in row: print(str(col)+'\\t', end='') print('') print('\\n输出所有最长公共子序列') print_all_lcs(c, len(a), len(b), a, b, []) if __name__ == '__main__': while True: a = input(\"请输入序列A: \") if a == 'q': break b = input(\"请输入序列B: \") get_lcs(a, b) print('') ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"输入 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"输出 c 表 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:2:3","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"输出 b 表 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:2:4","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"输出所有最长公共子序列 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:2:5","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"体会 输出所有最长公共子序列的进阶要求比较有挑战性，研究中我发现只要左边的长度与上面的长度相等，即表明会有不一样的分支出现；利用这一点可以递归地输出所有最长公共子序列。而 python 简单有效的字符串处理功能与数据结构帮助我很好地实现了整个程序。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%B8%89/"},{"categories":null,"content":"矩阵连乘问题 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"实验分析 分析最优解的结构 记 $A[i:j]$ 为 A~i~A~i+!~…A~j~，记 $m[i][j]$ 是计算 A~i~A~i+!~…A~j~ 时的最少乘法次数，显然 $A[i:i]=A_i$，$m[i][i]=0$ 特征：计算 $A[i:k]$ 和 $A[k+1:j]$ 的次序是最优的。 建立递归关系 假定计算 $A[1:n]$ 的一个最优次序在矩阵 A~k~ 和A~k+1~ 之间将矩阵链断开，1≤k\u003cn $m[1][n]=m[1][k]+m[k+1][n]+p_0p_kp_n$ 一般情况 假定计算 $A[i:j]$ 的一个最优次序在矩阵 A~k~ 和 A~k+1~ 之间将矩阵链断开，i≤k\u003cj m[1] [n]=m[1] [k]+m[k+1] [n]+p~i-1~p~k~p~j~ 动态方程如下 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"实验代码 本实验使用 Python 完成编写 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"代码实现 from typing import List def matrix_chain(n: int, p: List[int]) -\u003e tuple: \"\"\" 计算最优值关系矩阵 :param n: 连乘矩阵的个数 :param p: 矩阵序列维度的列表 :return: 最优断开位置的二维列表, 备忘录 \"\"\" m: List[List[int]] = [ [0 for i in range(n + 1)] for j in range(n + 1)] # 初始记录矩阵全设为零 s: List[List[int]] = [ [0 for i in range(n + 1)] for j in range(n + 1)] # 记录最优断开位置的数组 for r in range(2, n + 1): # 对每个对角线 for i in range(1, n - r + 2): # 对每行 j = i + r - 1 # 对角线长 m[i][j] = m[i][i] + m[i + 1][j] + \\ p[i - 1] * p[i] * p[j] # 初始化 m[i][j] s[i][j] = i # 记录断开位置 for k in range(i + 1, j): # 寻找m[i][j]最小值 t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if t \u003c m[i][j]: m[i][j] = t s[i][j] = k # 记录断开位置 return s, m def trace_back(row: int, col: int, s: List[List[int]]) -\u003e None: \"\"\" 根据s记录的各个子段的最优解，将其输出 :param row: 行 :param col: 列 :param s: 记录断开位置的二维列表 :return: None \"\"\" if row == col: print(\"A{}\".format(row), end='') return print('(', end='') trace_back(row, s[row][col], s) trace_back(s[row][col] + 1, col, s) print(')', end='') if __name__ == '__main__': print('请分别输入连乘矩阵的维数：') print('如: 4 8 3 5 2') count = 1 while True: p = list(map(int, input().split())) # 连乘矩阵维数 n = len(p) - 1 # 矩阵个数 print('Case {}'.format(str(count))) count += 1 s, m = matrix_chain(n=n, p=p) print('矩阵表达式为') trace_back(row=1, col=n, s=s) print('\\n乘法次数为\\n{}'.format(m[1][n])) ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"输入 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"矩阵输出 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:2:3","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"体会 在如何输出括号的问题上，我纠结了很久，一开始是直接将需要添加括号的两个矩阵输出，像这样： 为此我专门写了一个函数来处理加括号的问题，避免括号会加到已经括起来的若干矩阵中间，而不是其前面或后面。非常复杂繁琐。 后来发现，直接在 trace_back 函数中输出括号即可解决全部问题。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%8C/"},{"categories":null,"content":"Dijkstra 算法 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/"},{"categories":null,"content":"实验分析 按路径长度递增的次序来产生最短路径；先求路径最短的一条，然后参照它进行刷新，求出长度次短的一条，以此类推，被求出长度的顶点放入集合 S 中，当 S 满，代表算法结束 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/"},{"categories":null,"content":"实验代码 代码引入 dist[]，存储 v 到 v~i~ 当前找到的最短路径长度；引入 path[]，存储 v~i~ 的直接前驱节点 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/"},{"categories":null,"content":"代码实现 from typing import List INFINITY = 50000 def dijkstra(graph: List[List[int]], start_index: int, end_index: int): start_index -= 1 end_index -= 1 vex_num = len(graph) tag: List[bool] = [False for _ in range(vex_num)] dist: List[int] = [-1 for _ in range(vex_num)] # 存储当前找到的最短路径长度 path: List[int] = [-1 for _ in range(vex_num)] # 存储目标顶点的直接前驱节点 for i in range(vex_num): dist[i] = graph[start_index][i] if dist[i] != -1: # 若此路径存在，添加前驱节点 path[i] = start_index else: path[i] = -1 tag[start_index] = True # 记录自身 for _ in range(1, vex_num): # 按递增序列求最短路径 minimum = INFINITY final_vex = start_index for j in range(vex_num): # 查询最小的最短路径, 找出final_vex if not tag[j] and dist[j] != -1 and dist[j] \u003c minimum: minimum = dist[j] final_vex = j tag[final_vex] = True # 找到一条最短路径，记录 for j in range(vex_num): # 从上一次找到的最短路径的顶点出发, 依次判断各顶点的最短路径能否更新 if not tag[j] and graph[final_vex][j] != -1 and (dist[j] == -1 or minimum+graph[final_vex][j] \u003c dist[j]): dist[j] = minimum+graph[final_vex][j] path[j] = final_vex # 打印输出 road: List[int] = [] j = end_index road.append(str(j+1)) while True: road.append(str(path[j]+1)) j = path[j] if path[j] == -1: break road_str: str = '-\u003e'.join(road[::-1]) print(\"The least distance from {}-\u003e{}is {}\".format( start_index+1, end_index+1, dist[end_index])) print(\"The path is {}\".format(road_str)) if __name__ == '__main__': count = 1 while True: print(\"Case {}\".format(count)) n = int(input('输入结点数量:')) graph = [] print(\"输入矩阵: \") for _ in range(n): graph.append(list(map(int, input().split()))) print('输入两点: ') start_index, end_index = list(map(int, input().split())) dijkstra(graph, start_index, end_index) count += 1 print('\\n') ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/"},{"categories":null,"content":"运行结果 输入样例 5 -1 10 -1 30 100 -1 -1 50 -1 -1 -1 -1 -1 -1 10 -1 -1 20 -1 60 -1 -1 -1 -1 -1 1 5 6 -1 1 12 -1 -1 -1 -1 -1 9 3 -1 -1 -1 -1 -1 -1 5 -1 -1 -1 4 -1 13 13 -1 -1 -1 -1 -1 4 -1 -1 -1 -1 -1 -1 1 6 输出 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/"},{"categories":null,"content":"体会 Dijkstra 算法本质也是一个贪心算法，它按路径长度递增的次序，每次找到长度最短的一条路径。在实际操作中需要设置一个极大值 INFINITY 以便通过遍历的方式获得最短路径长度。 Dijkstra 的思路并不复杂，不过在编写程序时要考虑很多细节，比如按递增序列求最短路径循环中各个部分的顺序问题；Python 清晰简洁的语法很大程度上帮助我完成了算法的编写。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E4%BA%94/"},{"categories":null,"content":"跳马问题 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/"},{"categories":null,"content":"问题分析 跳马问题用 BFS 来解特别合适 除去出界的情况，马走一次有八种选择，可以从起点出发，对存储在队列中的每一个点进行广度搜索，处理过的点做上访问标记，每次更新八个点入队，重复操作，直到队列为空 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/"},{"categories":null,"content":"实验代码 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/"},{"categories":null,"content":"代码实现 from typing import List move_x = [1, 2, 2, 1, -1, -2, -2, -1] move_y = [2, 1, -1, -2, -2, -1, 1, 2] def is_out_of_border(x, y) -\u003e bool: \"\"\" 是否出界 \"\"\" if x \u003c 0 or x \u003e= 8 or y \u003c 0 or y \u003e= 8: return True return False def BFS_chess(x, y, board: List[List[int]], move_num: int = 0): \"\"\" 广度搜索 \"\"\" global move_list global move_x global move_y board[x][y] = 1 queue = [[x, y, 0]] while queue: x, y, count = queue.pop(0) if board[x][y] == -1: # 到达 move_list.append(count) else: board[x][y] = 1 # 标记走过 for i in range(8): # 下八个位置入列 next_x = x+move_x[i] next_y = y+move_y[i] if not is_out_of_border(next_x, next_y) and board[next_x][next_y] != 1: queue.append([next_x, next_y, count+1]) def translate(coor_str: str): coor_list = [] alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'] if coor_str[0] in alphabet: coor_list.append(alphabet.index(coor_str[0])) else: raise ValueError(\"Wrong!\") coor_list.append(int(coor_str[1])-1) return coor_list if __name__ == '__main__': while True: start, end = list(map(str, input().split())) start_coor = translate(start) target_coor = translate(end) # 设置棋盘 board = [[0 for _ in range(8)] for _ in range(8)] board[target_coor[0]][target_coor[1]] = -1 move_list = [] BFS_chess(*start_coor, board) print(\"{}==\u003e{}: {}moves\".format(start, end, str(min(move_list)))) ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/"},{"categories":null,"content":"输出 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/"},{"categories":null,"content":"体会 用 BFS 来解这个问题相当简单，用遍历 + 队列的思想即可完成，在 8×8 的棋盘中效率也很高。 若用 DFS 回溯的方法求解，递归的深度最高可到 64 层，最多有 $8^8$ 种可能，而且许多路径在第一步就是错的，也会一直递归到底；即使可以到达，步数也不一定是最小，相当耗时。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%85%AD/"},{"categories":null,"content":"哈夫曼编码 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/"},{"categories":null,"content":"实验分析 哈夫曼编码是一种前缀码，解码时没有歧义，相比于等长编码可以节省空间 计算字母频率作为权值，构造哈夫曼树 叶子结点具有哈夫曼编码 规定左子树为 0，右子树为 1，写出字母编码 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/"},{"categories":null,"content":"实验代码 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/"},{"categories":null,"content":"代码实现 from typing import List class Node: def __init__(self, weight: int): self.weight = weight # 权值（顺便作为结点名） self.left_child = None self.right_child = None self.parent = None def is_left_child(self) -\u003e bool: return self.parent.left_child == self class HuffmanTree: def __init__(self, weight_list: List[int]): self.weight_list = weight_list self.nodes = self._init_nodes() self.root = self._create_huffman_tree() self.huffman_codes = self._get_huffman_code() def _init_nodes(self) -\u003e List[Node]: \"\"\" 获取初始叶子结点列表 \"\"\" return [Node(weight) for weight in self.weight_list] def _create_huffman_tree(self) -\u003e Node: nodes = self.nodes.copy() # 浅拷贝，旨在更新每个节点的变化 nodes.sort(key=lambda x: x.weight) # 结点按权值升序 while len(nodes) \u003e 1: right_node = nodes.pop(0) left_node = nodes.pop(0) new_node = Node(weight=left_node.weight+right_node.weight) new_node.left_child = left_node new_node.right_child = right_node left_node.parent = right_node.parent = new_node for i, node in enumerate(nodes): if node.weight \u003e= new_node.weight: nodes.insert(i, new_node) break else: # 若new_node权值最大，放到末尾 nodes.append(new_node) return nodes[0] # 返回根结点 def _get_huffman_code(self): codes = [] for node in self.nodes: code = [node.weight, ''] while node.parent is not None: if node.is_left_child(): code[1] += '0' else: code[1] += '1' node = node.parent code[1] = code[1][::-1] # 倒转 codes.append(code) return codes def show_huffman_code(self): for code in self.huffman_codes: print(str(code[0])+' '+code[1]) if __name__ == '__main__': num = int(input()) weight_list_list: List[List[int]] = [] for i in range(num): n = input() weight_list_list.append(list(map(int, input().split()))) for i in range(num): print('Case {}'.format(i+1)) huffman_tree = HuffmanTree(weight_list=weight_list_list[i]) huffman_tree.show_huffman_code() ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/"},{"categories":null,"content":"运行结果 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/"},{"categories":null,"content":"体会 题目的哈夫曼树和平常的定义有所不同，左权值大而右权值小，还有各种为了保持输出唯一性而定的条件，需要一一遵守。 在编写代码过程中，我遇到了 python 浅拷贝和深拷贝的问题。经过一番求证和思考，发现浅拷贝仅仅拷贝父对象，对于子对象则创建其引用，这给性质可以用来修改在创建哈夫曼树的过程中，各个结点的变化。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/algorithm/%E6%8A%A5%E5%91%8A%E5%9B%9B/"},{"categories":null,"content":"作业一 selectCNO,CNAMEfromCwhereTNAME=\"LIU\" selectSNO,SNAMEfromSwhereAGE\u003e23ANDSEX=\"男\" selectCNAME,TNAMEfromCinnerjoinSConC.CNO=SC.CNOwhereSNO=\"S3\" selectCNAMEfromSwhereSEX=\"女\"ANDexists(select*fromCinnerjoinSConC.CNO=SC.CNOwhereTNAME=\"LIU\"andC.SNO=S.SNO) selectCNOfromCwhereCNOnotin(selectC.CNOfromSCinnerjoinSonSC.SNO=S.SNOinnerjoinConSC.CNO=C.CNOwhereS.SNAME=\"WANG\") selectCNOfromSCgroupbyCNOhavingcount(CNO)\u003e2 selectSC.CNO,C.CNAMEfromSC,CwhereSC.CNO=C.CNOgroupbySC.CNO,C.CNAMEhavingcount(SNO)=(selectcount(SNO)fromS) selectSNOfromSasawhereexists(select*fromSCinnerjoinConSC.CNO=C.CNOwhereTNAME=\"LIU\"andSC.SNO=a.SNO) selectcount(CNO)fromSCgroupbyCNOselectcount(distinctCNO) selectavg(S.AGE)fromSinnerjoinSConS.SNO=SC.SNOwhereCNO=\"C4\" selctavg(SC.GRADE)fromCinnerjoinSConC.CNO=SC.CNOwhereC.TNAME=\"LIU\"groupbyC.CNO selectCNO,count(SNO)fromSCgroupbyCNOhavingcount(SNO)\u003e10orderbycount(SNO)desc,CNOasc selectSNAMEfromSwhereSNO\u003e(selectSNOfromSwhereSNAME=\"WANG\")andAGE\u003c(selectSNOfromSwhereSNAME=\"WANG\") selectSNAME,AGEfromSwhereSNAMElike\"WANG%\" selectSNO,CNOfromSCwhereGRADEisnull selectSNAME,AGEfromSwhereSEX=\"男\"andAGE\u003e(selectavg(AGE)fromSwhereSEX=\"女\") selectSNAME,AGEfromSwhereSEX=\"男\"andAGE\u003e(selectmax(AGE)fromSwhereSEX=\"女\") insertintoSvalues('S9',\"WU\",18) insertintoSTUDENTselectS.SNO,SNAME,SEXfromSinnerjoinSConS.SNO=SC.SNOgroupbyS.SNO,SNAME,SEXhavingmin(SC.GRADE)\u003e=80 deletefromSCwhereGRADEisnull dfromSCwhereSNOin(selectSNOfromSwhereSNAME=\"WANG\") updateSCsetgrade=nullwhereCNOin(selectCNOfromCwhereCNAME=\"MATHS\")andGRADE\u003c60 updateSCsetgrade=grade*1.05whereCNOin(selectCNOfromSwhereSEX=\"女\")andgrade\u003c(selectavg(grade)fromsc) updateSCsetgrade=grade*1.05whereCNO=\"C4\"andgrade\u003c=75updateSCsetgrade=grade*1.04whereCNO=\"C4\"andgrade\u003e75 ","date":"0001-01-01","objectID":"/Notes/posts/homework/database/%E4%BD%9C%E4%B8%9A%E4%B8%80/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/database/%E4%BD%9C%E4%B8%9A%E4%B8%80/"},{"categories":null,"content":"研讨 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"题目 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"命令 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"fg （foreground） 将后台运行的或挂起的任务切换到前台运行 fg \u003cjob_id\u003e ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"bg （background） b将挂起的任务切换到后台运行 bg \u003cjob_id\u003e ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"ctrl + z 挂起：将一个正在前台执行的命令放到后台，并且暂停 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:3","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"\u0026 当在前台运行某个作业时，终端被该作业占据；可以在命令后面加上 \u0026 实现后台运行。 不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。 \u003ccommand\u003e \u0026 如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中： command \u003e out.file 2\u003e\u00261 \u0026 使用 \u0026 命令后，作业被提交到后台运行，当前控制台没有被占用，但是一但把当前控制台关掉（退出帐户时），作业就会停止运行 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:4","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"nohup （no hang up） 用于不挂断地运行命令 nohup \u003ccommand\u003e \u0026 为啥要加 nohup： 使用 nohup 命令，退出终端不会影响程序的运行 nohup 命令将输出重定向至 nohup.out，\u0026 则直接将输出打印到屏幕上 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:5","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"ps 显示进程信息 -e: 显示所有进程； -f: 显示丰富格式信息； -A：所有的进程均显示出来，与 -e 具有同样的效用； -a： 显示现行终端机下的所有进程，包括其他用户的进程； -u：以用户为主的进程状态 ； -x：通常与 a 这个参数一起使用，可列出较完整信息； -l：较长、较详细的将该PID 的的信息列出； -j：工作的格式 (jobs format)； -f：做一个更为完整的输出。 将本次登入的 PID 与相关信息列示出来 ps -l 列出目前所有的正在内存当中的程序 ps -aux 列出所有用户的进程详细信息（包括优先级 PRI 和nice值 NI） ps -efl 参数解释 F（Process Flag）：进程标志 若 4 表示此进程的权限 root ； 若 1 表示此子进程仅能 fork S（State）：状态 R (Running)：该进程正在运行； S (Sleep)：该进程正在睡眠，可被唤醒。 D ：不可被唤醒 T ：停止状态(stop)； Z (Zombie)：僵尸进程。 ADDR：在内存的起始位置 如果是个 running 进程，一般就会显示 - SZ：内存使用量 WCHAN：是否正在运行 若为 - 表示正在工作中 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:6","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"pstree 展示进程树 -p 显示进程号 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:7","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"renice 设置进程 / 用户 / 群组的优先级 用例 renice -n N –u username renice -n N –g gid renice -n N –p pid 选项 -n = priority：优先级 -u = name：用户名，用于设置用户的优先级 -g = gid：组号，用于设置组的优先级 -p = PID：进程号，用于设置进程的优先级 PRI 与 NI 的区别 详见：https://blog.csdn.net/u010317005/article/details/80531985 优先运行序 (priority, PRI)：其值越低，代表优先度越高；PRI 由核心动态调整，用户无权更改其值 nice 值（NI）：反应一个进程优先级状态的值，其范围在 -20-19 之间（校正值、偏移量） 两者关系：PRI(new) = PRI(old) + nice ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:8","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"nice 在执行命令时设置其优先级 nice -N \u003ccommand\u003e -N：要设置的优先级 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:2:9","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"步骤 Linux 环境下进程信息查看和作业控制 平常使用 Linux 的习惯：打开命令行终端，输入一行命令，等待运行，屏幕实时输出 遇到的情况：find 查找一个文件，查找的过程可能相当耗时，find 进程始终占用着屏幕输出，只能干等在电脑前，直到程序运行完毕，才能进行其他操作，效率低下 问题：如果想让进程挂起或是转移到后台运行，从而腾出命令行终端去做别的事情，该怎么操作 又一个问题：多道进程准备就绪等待执行时，该如何手动修改优先级 通过一个具体的例子，来了解 Linux 中的进程操作 （了解 Linux 中实现进程后台运行、挂起的操作） （了解 Linux 中查看进程信息、修改优先级的操作） 在 root 用户下创建 f1.txt 文件，挂起 vi f1.txt 用 jobs 命令查看被挂起的进程 jobs jobs 命令可以用来查看所有当前位于后台的作业 中括号内的数字 “1” 是作业号 “+” 号代表最近一个放入后台的作业（被当作默认作业） Stopped 表示此作业已经挂起 后台启动 find 进程 要想让进程在后台运行，只要在书写命令的末尾添上 \u0026 符号 不过还不够 作业在后台运行时，一样会将结果输出到屏幕上，干扰你的工作 而且，一但把当前控制台关掉（退出帐户时），作业就会停止运行 还需要用到 nohup 命令，保证在关闭终端后，程序得以继续运行 每个进程都会接受一个 SIGHUP (Signal Hang UP) 信号，负责退出终端时终止该进程，而 nohup 的作用是屏蔽这个信号，退出终端进程仍然存在。 nohup 还会将将输出重定向至当前路径的 nohup.out 上，不会在屏幕上输出了 nohup find \u0026 显示当前所有进程和进程号 ps (Process Status) -e 参数显示所有用户的进程 ps -e 显示所有进程含优先级的详细信息 -l 参数显示更多信息 long format -f 参数显示进程的完整信息 full format ps -efl 我们还可以打印进程树来展示进程间的父子关系 打印进程家族树 -p 参数显示进程号 pstree -p 终止 find 进程的后台运行 kill \u003cpid\u003e 此时查看进程，find 进程已被终结 下面演示：如何修改单个进程的优先级和单个用户的优先级 切换到 student 用户，创建 f2 文件并设置优先级（nice 值）为 5，挂起 这里要讲讲 Linux 优先级机制 我们在进程表里可以观察到两个参数 优先运行序 (priority, PRI)：其值越低，代表优先度越高；PRI 由核心动态调整，用户无权更改其值 nice 值（NI）：反应一个进程优先级状态的值，其范围在 -20-19 之间（校正值、偏移量） 两者关系：PRI(new) = PRI(old) + nice Linux 提供一个 nice 值作为偏移量，给予用户修改优先级的权限 su student nice -5 vi f2.txt 后台启动 find 进程 nohup find \u0026 显示所有进程含优先级的详细信息 ps -efl 可以看到，vi f2.txt 命令的优先级被设为了 5 将 student 的用户进程优先数改为 -5 要点：切换到 root 用户，因为 Linux 规定非 root 用户无法将优先级别调高 su root # 或 sudo su renice -n -5 -u student 显示所有进程含优先级的详细信息 ps -efl 可以看到，student 用户所有进程的优先级都被设为了 -5 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester1/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"研讨 https://zhuanlan.zhihu.com/p/183238194 文件共享的含义是什么？ 文件共享类型有哪几种形式，举例说明。 Linux 基于索引节点的文件共享方式有哪两种？（这个不讲） 对文件 abc.txt 给出实现两种共享方式的相应命令 并请从文件共享链接的时空观、链接目标文件要求、删除目标文件独立性方面比较 Linux 的两种共享方式的主要区别或特点。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"文件共享的含义是什么？ 操作系统提供的文件共享功能，让多个用户共享的使用同一个文件，而系统中只需保留该文件的一份副本。 如果系统不能提供共享功能，那么每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。 共享 vs 复制 多个用户共享一个文件，意味着系统中只有一份文件数据。并且只要某个用户修改了文件的数据，其他用户也可以看到文件数据的变化。 如果是多用户都复制了同一个文件，那么系统中会有多份文件数据。其中一个用户修改了自己的那份文件，对其他用户的文件数据并没有影响。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"Linux 中的文件 文件包括两个部分：文件本身数据和文件的描述数据/元数据。 文件本身的数据就是文件的实际内容，存储在硬盘上； 文件的元数据有两个功能 提供必要的文件信息（文件名） 指明文件的唯一性：inode 号可以唯一地标识某个文件（而文件名不能） 这里我们引入了一个名词：索引节点 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"索引节点 inode 索引节点 inode 是类 UNIX 系统中的一种数据结构，它记录了文件的一些基本信息。 文件的访问权限 文件大小 UID、GID 最近一次修改/访问/更改的时间（都包含在内） 当然还有最重要的 索引号，就是它唯一地标识了一个文件 文件的链接数目 值得注意是，文件名并不在 inode 的存储范围之内，普通文件的文件名被记录到目录文件中（文件名实际上是身外之物）这也就说明了一个文件可以拥有多个不同的文件名。 注意到 Linux 里一切皆文件的特性——目录也是文件——目录的实际内容就是存放在此目录中的文件名和指向这些文件的指针 了解了 linux 中文件的基本结构后，我们来介绍两种实现文件共享的方式。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"基于索引节点的共享方式（硬链接） 硬链接可以理解为对现有的一个文件的引用。 我们已经了解到，任何文件拥有一个唯一的索引节点，那么任何指向一个索引节点的指针本质上都指向了同一个文件实例，所以我们只要在不同用户的目录下创建若干个索引节点指针，不就完成了文件的共享吗 硬链接的实现就是基于这个原理 我们在索引节点结构体中添加一个计数器属性 count，设初值为 1，称为引用计数器。 当一个文件被用户 1 创建时，我们首先创建一个指向该文件索引节点的指针，视为创建了一个硬链接 当有用户 2 需要使用到这个文件的时候，可以不用复制，直接建立一个指向该文件索引节点的指针，此时引用计数器的值 +1；以此类推 在这种基于索引节点的文件共享策略中，用户文件目录里只设置了文件名和指向索引节点的指针，由于我们是用这个指针来唯一地确定要链接的文件实例，那么文件名就无所谓了，可以随意改变。 如果这时候用户 2 不再需要此文件，准备把它删掉了，这个删除的步骤体现在系统层面上就是，首先索引节点中的 count 值 -1，然后删除 user2 目录中相应的目录项，用户 2 的硬链接就这样被切断了。 我们注意到删除用户 2 的文件，并不会影响原文件和其他硬链接，这个文件的信息一直会保存在硬盘， 直到计数器的 count 为 0 的时候，表明已经没有硬链接，即该文件已经没人使用，此时系统才会清空其所有数据。 硬链接有以下几个特点： 所有的硬链接指向相同的 inode 以及数据块； 新建立的文件本身就是一个硬链接； 同一个文件的硬链接允许拥有不同的文件名（因为文件名在目录中记录，inode 不记录） 删除一个硬链接不影响其他的硬链接；在有多个硬链接的情况下删除某个硬链接，数据不会被删除；删除最后一个硬链接，对应数据全部清空。 不可以对目录建立硬链接；（linux 的目录是树形结构，如果在一个目录里面创建另一个目录的硬链接，岂不成了一个环状结构？） 硬链接与被链接文件有着相同的文件属性（权限、时间戳等）因为它们本质上就指向同一个 inode 新建一个硬链接，count+1 不可以创建跨文件系统的硬链接（磁盘中有多个文件系统分区，每个文件系统分区都有自己独立的一套 inode 节点。如果跨区保存，就无法通过 inode 节点找到唯一的源文件了） ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"基于符号链接的共享方式（软链接） 软连接类似于 windows 上的快捷方式，它仅仅记录了目标文件的路径名。 具体来说，若某文件 F’ 的数据块中存放的是另一文件 F 或的路径名，称“某文件”是“另一文件”的软链接，这个路径名被视为符号链。 注意，软链接文件本质上是一个独立的文件，拥自己的 inode 节点，文件数据中保存了源文件的路径，通过这个路径访问源文件的数据。 删除一个软链接，不会影响其他软链接和原文件。 软链接的文件占用的数据块与被链接文件不同，而且有自己的 inode 和文件属性信息。 特点 每个软链接都有自己的 inode 以及数据块； 原文件不存在时，亦可以创建软链接； 删除一个软链接，不影响被链接的文件；删除被链接的文件，则软链接无法找到原文件，变成悬挂的软链接；但原文件被重新创建（按原路径）时，软链接又重新发挥作用； 可以对目录建立软链接； 软链接与被链接文件有不同的文件属性（权限、时间戳等）； 新建和删除软链接不改变 count 值。 最后我们总结一下软硬链接两种文件共享方式的区别 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:5:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"软硬链接的区别 链接文件的独立性不同 硬链接文件本质上和源文件没有什么不同（他们共同使用一个 inode 节点，只是文件名不同罢了） 软链接文件本质上是一个独立的文件，拥自己的 inode 节点（它与源文件的唯一联系就是它保存了源文件的路径） 创建的条件不同 源文件不存在时，不能创建硬链接（因为连索引节点都不存在，自然也就无法创建指向它的指针） 源文件不存在，也可以创建软连接（即存储一个无效的路径地址） 删除操作的不同 删除任意一个硬链接，其他硬链接仍然有效（硬链接的删除操作不会涉及到文件实体的改变） 删除任意一个软链接，其他软链接显然生效；但是一旦删除软链接的源文件，所有的软链接就会变成死链接（因为此时所有软链接记录的文件路径是找不到一个有效的文件的） 硬链接之间的地位是平等的；而软链接与源文件的地位并不平等 索引节点中引用计数器 count 变化的策略不同 新建/删除一个硬链接，count+1/-1； 新建/删除一个软链接，源文件的 count 不变（因为软链接与其源文件的索引结点各自独立） 对目录文件的支持不同 不允许创建一个目录的硬链接（由于 linux 的目录是一个树形结构，是一个有向无循环图，如果在一个目录里面创建另一个目录，那就变成了一个环状结构，造成混乱） 允许创建一个目录的软链接（因为软链接的本质就是一个路径地址，所以它对于源文件没有什么特别的要求，甚至可以为空） 对跨文件系统的支持不同 不允许创建跨文件系统的硬链接（磁盘中有多个文件系统分区，每个文件系统分区都有自己独立的一套索引节点。一旦产生跨区硬链接，索引节点就不能维护它的唯一性，也就不能找到唯一的源文件了） 允许创建跨文件系统的软链接（因为它仅仅是一个路径而已） 我们可以利用软链接的这一特性来解决解决磁盘空间不足问题，比如某个文件系统空间已经用完了，但是现在必须在该文件系统下创建一个新的目录并存储大量的文件，那么可以把另一个剩余空间较多的文件系统中的目录软链接到该文件系统中。这在用户层面是察觉不到的。 检索开销、内存开销不同 检索软链接，需要系统根据路径名逐个分量地查找，造成多次读盘，开销较大 软链接本质是一个单独的文件，有他独立的 inode 结点，也要耗费一定的存储空间 在时空对比上，硬链接显然更胜一筹 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:6:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"例题 设文件 file 的 inode 当前的引用计数器值为 3，先对 file 建立软链接 f1，再对 file 建立硬链接 f2，再对 f1 建立硬链接f3，再删除 f2、f3。分别求 file、f1 中的引用计数器值。 解：对 file 建立软链接 f1，不影响 file 的引用计数器的值，故还是 3；对 file 建立硬链接 f2，故引用计数器 +1，变为 4；软链接 f1 本身就是一个文件，故初始 f1 中的引用计数器值为1，对 f1 建立硬链接 f3，故引用计数器值 +1，变为 2；最后删除 f2，被硬链接文件 file 的引用计数器的值 -1，变为 3，删除 f3，被硬链接文件 f1 的引用计数器的值 -1，变为 1。 因此最终答案为：file 的引用计数器的值：3；f1的引用计数器的值：1 ","date":"0001-01-01","objectID":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/:7:0","tags":null,"title":"","uri":"/Notes/posts/homework/os/semester2/%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"Tie Breaker ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/"},{"categories":null,"content":"后端架构 TieBreaker 游戏架构 比赛模块 备战管理 比赛进程状态展示 比赛结果保存 实例生成模块 联赛生成 俱乐部生成 球员生成 日程表生成与更新 转会模块 球员买入 球员卖出 球员薪资谈判 财政模块 奖金收入 比赛票务收入 人事工资支出 转会利润统计 用户管理 登录鉴权 存档管理 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/"},{"categories":null,"content":"界面特点 主色辅色：在保持清爽简洁的同时，使整体界面富于变化 用户可以自由选择喜爱的主色 以卡片为信息载体：清晰明了 圆角设计降低突兀感 阴影设计突出信息区块的独立性 瀑布流 灵动 丰富的图表 提供多样的数据可视化呈现 导航栏、侧边栏设计 侧边栏设计：便于路由跳转 导航栏设计：将常用操作放置在导航栏部分，快捷方便 转移动画、滚动条重绘 使整体风格趋于统一 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/"},{"categories":null,"content":"功能模块设计 代码结构 assets：静态文件，如人名库、国家名库 core：数据库与ORM框架的相关配置 crud：使用对象关系映射模型构建的原子性数据库操作集合 game_configs：游戏的参数配置和算法权重配置文件 如头像生成概率、能力值的地域修正、联赛和俱乐部的初始数据、各个职责能力值的计算公式、token生成密钥等 logs：日志文件 models：ORM模型定义 负责与对象关系映射模型与数据库的交互转换 modules：游戏运行的核心模块集合 computed_data_app：数据对象的计算属性统计模块，负责将数据库中的初始数据构建为成体系的结构化数据，便于展示给用户 game_app：比赛逻辑模块 AI 之间的比赛逻辑和人机比赛逻辑 数十种动作对抗的函数定义 五种进攻战术的脚本 比赛实时数据的记录 两种球员挑选算法 根据对手特性调整战术比重的算法 generate_app：生成联赛、俱乐部、球、日程表的工厂类模块 next_turn_app：推动游戏行进的消息转发模块，负责接受前端请求调用相应的功能 transfer_app：球员市场转会模块 AI 间的球员交易、玩家和 AI 俱乐部间的球员交易 球员合同谈判过程模拟 routers：提供 API，负责前后端的通信和数据交换 schemas：数据交换格式的规范化模块，定义了每个数据实体的数据类型 utils：工具模块 date：日期生成和计算工具 dependencies 与 token_validator：用户鉴权工具 logger：日志记录类 utils：提供常用的工具函数，如时间序列生成算法、随机数生成算法等 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/"},{"categories":null,"content":"机器学习的引入 游戏核心架构引入了机器学习方法，便于对游戏参数进行调整和优化。 球员在某位置的综合能力值算法通过确定各项能力对于此位置的重要程度来实现。举个例子，前锋对于射门素质要求相当之高，故射门属性权重自然就高；相反，防守拦截能力也就相对不重要。 在游戏设计之初，这些权重都由编程设计人员凭借对于比赛逻辑和战术思想的了解估算而出。这样的估计有着一定的误差。在游戏构建到一定程度时，不准确的综合能力值权重参数给球员生成算法、球队选人算法、转会推荐算法和玩家的评估标准等一系列功能造成了不小的麻烦。后来，我们使用了机器学习中的回归算法，准确快速地揭示了各项属性和位置之间的联系。 我们模拟了数十万场比赛，生成了一个庞大的数据集：在每场比赛中，只有一位球员的属性是随机生成的，其余球员均设置为默认值，这样我们就能通过比赛的最终比分，评估这位球员的能力强弱。通过线性回归算法，对这些样本进行训练，最后得出了一个稳定准确的权重系数。 当前，这些样本还可以做更多的事情： 前锋的综合能力与射门属性之间的关系，可以看出有明显的正比关系 前锋的综合能力与射门属性之间的关系，曲线斜率较之前略小 前锋的综合能力与防守属性之间的关系，可以看出两者没有关系 各个阵型失球数分布图，可以看出 4-4-2 阵型的进攻能力冠绝群雄，4-1-4-1 阵型的进攻能力相对不足 各个阵型进球数分布图，也印证了进攻与防守难以兼得 以下的箱线图更为清晰： 最后是各个阵型与净胜球的点估计图 可以看到估计值极为接近。只有 0.1 左右的差距，侧面证明了六大阵型设计的合理性。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/about-tie-breaker/"},{"categories":null,"content":"稿 Tie Breaker 《平分决胜》是一款足球模拟经营类的网页游戏。在游戏中，你将化身一位足球俱乐部教头，训练麾下球员，培养青年才俊；赢得比赛，争夺荣誉。 游戏的主页面涵盖了玩家俱乐部本赛季的基本情况。下一场比赛、球员的表现展示、俱乐部的财政概况和联赛积分榜等等信息，都直观地展示出来，让玩家对球队的当前情况有一个全方面的了解。 （点球员）球员无疑是这款游戏的灵魂所在。我们为球员定制了多维度的能力属性，保证每一位球员都是独一无二的存在。在卡片页面中，我们能够总览俱乐部的所有球员及其概况；（翻页）射门、传球、过人等九项属性是判断球员好坏的硬性指标，我们用条形图和醒目的渐变色来直观地展示球员的能力维度。我们还用机器学习中的回归算法计算出最适合球员的场上职责及其对应的综合评估能力值，用浅色的字母缩写展示在了卡片背景上。 （点 LM/RM）点开卡片，我们来到了球员的个人主页，这里记录着球员更加详细的信息。不仅给出了球员擅长的场上位置，球员的身价、薪水，还有赛季比赛数据也可以供玩家参考。除此之外，我们还为每位球员定制了多样的可视化图表，能力条形图、最近五场比赛的综合评分，以及球员各位置的出场次数占比，可以让玩家全方面地了解自己的球员状态。 （点数据）游戏还拥有丰富的数据供玩家参考。我们来到球员数据中心页面 在球员能力表格中，你可以方便地对球员的能力数值进行横向对比，通过升降序排列来分析每位球员的优势与不足； 在球员表现表格中，涵盖了俱乐部球员本赛季所有比赛的数据统计，我们可以清晰地查看和比较每位球员的出场次数、进球助攻次数、平均评分，还有各种详细的动作统计；玩家可以根据这些丰富详实的数据来判断球员的比赛状态和优势位置，这也是游戏策略性的体现。 游戏以一天为一回合，每一次点击下一天的按钮，（下一天）后端都会根据日程表对新一天的各项事务进行处理。当下一场比赛即将到来之时，界面会弹出信息框来提醒玩家进行赛前阵容布置的操作。（点击现在开始） 在赛前准备页面，玩家可以拖动右边的球员头像到左边的战术面板中，游戏拥有多达 12 个各具特色的场上位置供玩家选择，玩家也可以点击头像来查看球员的擅长位置，尽量发挥每个球员的长处。 完成排兵布阵之后，我们点击开始比赛按钮，便来到了比赛页面。 我们从真实的足球比赛中汲取灵感，并且简化作战方式，打造了一套独特的比赛模拟系统：我们将球员间的进攻配合抽象为形形色色的进攻战术；将球员在球场上的每一次动作抽象为数值之间的判定与对抗 而玩家的任务就是通过场上局势的变化，选择最适合的进攻战术，取得进球。 我们手动选择几个战术（选），发现场上的各种数据都在实时发生着变化，我们可以根据这些实时的变化，灵活地选取战术；通过分析球员的场上位置、体力、评分来决定下一次的进攻思路。当然，游戏提供了自动比赛选项（自动化），你可以设置每种战术的占比，系统每回合就会按概率选取一个战术来自动比赛。 （自动的过程中）比赛界面呈对称布局，左右上方的战术板是两队球员在场上的实时位置，每一回合都会有动态变化，下方的表格呢记录着两队球员的实时数据；中间的卡片流依次记录着比赛时间与比分，战术选择按钮组、解说和数据对抗图。 我们手动完成剩余的比赛 90 分钟比赛结束，便跳转到比赛结束页面，在这里我们可以对整场比赛进行完整的回顾。我们有丰富的图表信息给到玩家，便于做一个详实的赛后分析和总结。 其中包括了两队的雷达图、进攻战术柱状图、MVP 展示，和完整的比赛解说。 值得一提的是，我们用机器学习中的聚类算法，提取出每支俱乐部 logo 的主色调，运用到这个界面上，使左右两边的颜色分别对应两支俱乐部的颜色，清晰又美观。 球员转会是另一项富有乐趣和策略的玩法，是挥金如土、引进大牌球员，还是挖掘潜力之星、培养青年才俊，一切由玩家决定。在转会大名单中，我们可以总览来自各个俱乐部的挂牌球员，货比三家，找到最适合球队阵容的新星。左键点击心仪的球员即可发起交易。在弹出的交易框中，你可以尝试做出报价，所有报价将在第二天被处理。这就是转会的基本流程。 以上就是 Tie Breaker 这款游戏的基本介绍。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/tiebreaker%E8%A7%86%E9%A2%91%E7%A8%BF/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/tiebreaker%E8%A7%86%E9%A2%91%E7%A8%BF/"},{"categories":null,"content":"Tie Breaker——基于机器学习优化策略的足球模拟经营应用 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"项目简介 （限150-200字） 本项目基于WEB技术和机器学习理论，打造一款前后端分离的足球模拟经营游戏。玩家将扮演一名俱乐部足球经理，训练麾下球员，培养青年才俊；排兵布阵，与 AI 对手进行比赛，争夺荣誉。项目着眼于游玩逻辑的丰富，运行效率的提升和界面的美化，并且使用机器学习和nlp技术提供个性化、智能化的功能。旨在激发玩家对于足球体育产业的兴趣，力图做到娱乐性与深度兼备。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"项目论证 （1.本项目国内外研究现状述评及研究意义；2．本项目研究的主要内容、基本思路、研究方法、重点难点、基本观点和创新之处；3．前期相关研究成果和主要参考文献） ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"本项目国内外研究现状述评及研究意义 作为互联网的重要载体之一，WEB已经演化成一个庞大的分布式应用系统。近年来逐渐流行的前后端分离思想使得WEB开发更为高效简洁：它既能支撑庞大的后台数据计算工作，又能让用户以近乎零成本的时间空间消耗享受到良好流畅的交互使用体验。 足球模拟经营游戏从1992年《Championship Manager》（冠军足球经理系列）系列发售后初现端倪，这一门独特的游戏门类凭着精密严谨又富于变化的模拟引擎，媲美现实的转会谈判体验、真实详尽的球员数据库等等优势获得了球迷们的追捧。现阶段足球模拟经营游戏的主战场是安装在主机或PC上的游戏客户端，庞大精细却笨重繁杂，而一款轻量级的、便于随时游玩的游戏系列在市场上一直处于空缺状态。依前文所述，WEB无疑是这类应用的最佳载体。本项目正基于这此点，计划打造一款基于WEB前后分离技术的足球经理应用。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"本项目研究的主要内容、基本思路、研究方法、重点难点、基本观点和创新之处 主要内容 本项目基于WEB技术和机器学习理论，计划打造一款前后端分离的足球模拟经营游戏： 自由选择俱乐部，体验一段独一无二的足球教练之旅 以文字与数据形式呈现比赛，随时进行换人操作 建立适合球员的战术体系，在球场上运筹帷幄 使用大数据全面分析球员优劣 引入 nlp 情感分析引擎，为你与球队打造个性化交流 基本思路 构建游戏核心逻辑 - 设计数据库表结构 - 编写后端接口 - 设计并构建前端页面 - 完成前后端的交接 - 引入机器学习优化 AI 球队的比赛决策 - 引入 nlp 情感分析编写个性化功能 研究方法 Vue3 配合 TypeScript 进行前端开发，可维护，规范性、复用性强 使用 Naive UI 构建页面，TailwindCSS 美化界面 使用 FastAPI 异步框架构建 API 重点难点 技术栈的学习与使用 游戏核心系统的设计 应用功能的迭代与文档维护 基本观点 通过对现代足球理论的思考，设计一套符合现实、体现一定深度、具有竞技技巧的比赛逻辑系统； 通过运用WEB技术和前后端分离思想，构建一个高效运行，体验流畅的现代WEB应用； 通过提供具有沉浸感、真实感的游戏游玩过程，激发玩家对于足球运动与足球产业的兴趣和热爱。 创新之处 采用WEB技术构建轻量化、移动化的游戏应用，将设备要求、时间空间成本作最大的压缩。 以现代足球系统为参照，构建一套完整丰富、逻辑自洽的虚拟足球世界，提供模拟经营类游戏的真实感。 自创比赛逻辑引擎，以概率为核心玩法，提供一个复杂有深度又充满不确定性的比赛体验。 前期相关研究成果和主要参考文献 后端部分，游戏的比赛逻辑已经基本完成；通过建立日程表的方式已经实现了一个赛季的事务分配；联赛系统、转会模块也正在构建中。 前端部分，页面的登录、存档等基本功能已经实现；球员数据展示、信息呈现部分也构建完毕；比赛交互界面正在编写。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"项目方案 （包括项目的训练目标、前期准备、组织实施、过程管理、实践环节、教师指导、项目结题等） ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"训练目标 通过组员之间的配合沟通，通过认真严谨的思考与实践，完成既定目标，即足球经理WEB应用的设计与构建工作，使其成功运行，投入使用，并保证日常维护；并在实践的过程中，锻炼组员的团队协作能力、代码编写能力和结构设计能力。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"前期准备 学习构建WEB应用所需的相关技术栈 学习机器学习与自然语言处理的理论 将足球比赛过程抽象为一套严谨的代码逻辑系统 技术文档和功能文档的编写 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"组织实施 每个组员将分配相应的任务大板块，由项目负责人根据进度统一制定工作计划，每周开一次组会进行项目进度的评估和新任务的分配，由指导老师监督项目推进状态。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:3","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"过程管理 第一阶段：构建游戏核心逻辑、设计数据库表结构 第二阶段：编写后端接口、设计并构建前端页面 第三阶段：完成前后端的交接 第四阶段：引入机器学习优化 AI 球队的比赛决策；引入 nlp 情感分析编写个性化功能 第五阶段：整体优化，测试维护 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:4","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"实践环节 对于构建WEB应用过程中出现的相关问题，定期与指导老师汇报交流，提出过程中的重点难点并且设法解决或优化。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:5","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"教师指导 为项目设计层面提出改进意见；监督项目的进展状况；项目报告编写指导。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:6","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"项目结题 完成足球模拟经营WEB应用的构建，根据实际情况对其功能进行迭代或扩充。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:3:7","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"完成项目研究的条件和保障 （1.申请人或团队情况，包括自身具备的知识条件、自己的特长、兴趣、已有的实践创新成果等；2.学校提供的条件，包括项目开展所需的实验实训情况、配套经费、相关扶持政策等。） 申请人或团队情况 团队成员均来自计算机学院，专业能力出色，拥抱新技术，具有学习热情和一定的自学能力，立项前已经对项目整体架构、未来方向有了相当程度的了解。 学校提供的条件 学院开展的专业课程提供了基础知识 学校图书馆提供了相关方向的专业书籍借阅 导师提供了系统设计层面的建议和文档、报告的编写指导 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"预期成果 完成一款足球模拟经营WEB应用的构建。 保证应用可以投入使用，满足预期功能要求，并且承担日常维护。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:5:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"经费预算 经费预算总额：4000元 云服务器和云数据库租用：1000元 办公易耗品购置：1000元 研发业务费：2000元（系统测试以及项目所需的电脑配件） ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/:6:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%85%B6%E4%BB%96/%E5%88%9B%E6%96%B0%E9%A1%B9%E7%9B%AE%E5%BC%80%E9%A2%98/"},{"categories":null,"content":"如果让你来做一个模拟足球比赛的程序，你会怎么做？ 复杂的思想：球员差不多每1/10秒做出一次决断（根据不同情况有所不同），所有在球场上的移动和效果都尽可能用真实世界中的物理模型进行建模，确保所有可以在现实世界中发生的事都可以在游戏中发生。 更粗略地、基于统计的模拟 大局观 将一场比赛分为若干个进攻与防守地 不要具体到球员的个人意识上，而是再往上抽象一层 还原一场比赛 引入 这些爬下来的游戏数据，如果脱离了 fifa 这个游戏，本身其实没有多大意义 为了让这些数据有用起来，我们何不自己写足球比赛的模拟引擎呢？ 精彩的比赛不是天天都有 爬的数据有啥用，数据屁用都没有，只要我们赋予它的意义他就有意义 自己做一个足球比赛模拟系统 足球比赛模拟系统 由简入繁 随机比分 某种程度上实现了足球的结果，并未实现过程 甚至没有体现两个队的实力差距 根据球队能力值生成比分 细化到每个球员的能力值 这样就可以与爬取的数据做联动了 考虑什么？球员场上的职责？球员之间的配合？战术？战略？意外情况？ 为球员赋予意识——球场上瞬息万变，有这么多的不确定因素影响着比赛的进程，为每一个位场上球员建立极其复杂精细的模型，做不了 怎么在不丢掉精髓的情况下，尽量还原一场比赛呢？ 注意到，我们是站在一个观者角度俯瞰一场比赛的，这个比赛引擎本身是一个黑盒，观者可以不知道比赛的运作原理，但是这个系统的输出必须富有真实感：它可以没有画面，但有文字的解说，实时播报、有球队进攻防守的各项数据统计、根据球员表现的打分等等等等，这一切的一切呈现给观者，让观者觉得欸，他们确实在打一场比赛啊 那么我们大可不必过分地关注球员作为个体在场上的决策，而将重点转移到战术层面上 抽象到战术层面上 会发现不论绿茵场上的情形如何千变万化，本质上就是两队间进攻与防守战术的对抗 在这种思想里面，球员聚合成一个整体，他们互相配合，共同完成战术中的动作 虽然这看起来像有一双无形的手控制每个球员的思想，但是他的确在保留了大部分真实性的基础上，简化了比赛流程 战术分割成一个个小动作，动作的共性：对抗性（引入球员的能力值，为能力值赋予了意义） 动作成对出现——进攻球员与防守球员的对抗 动作的成功率能否用球员的能力属性来量化呢？ 能力值如何与动作上的对抗产生联系？ 对抗必然有输赢（一次对抗仅仅有一次结果，不能说明任何问题，而当对抗的次数足够多时，这些结果便具有了统计学上的意义） 例 我跟 C 罗比过人，一次尝试并不能证明 C 罗就比我强 当尝试的样本量足够大时，我跟 C 罗的对抗数据便具有统计意义 这些对抗数据最终量化成我的能力值和 C 罗的能力值 所以我们可以根据球员的能力值来预判动作的成功率 最后动作成功率外化为球员对应属性的能力值 如何预判动作的结果？动作上的对抗——数值的对抗——本质上就是概率的对抗 如何设计动作？传球（传接球技术，加上对球路的预判）、过人与拦截、争顶、速度、射门与扑救 如何设计战术？动作的集合，中路进攻、边路进攻、特殊的防反 阵容：每个球员要有一个固定的位置 定义一些最基本的位置：守门员、中锋、边锋、中场、中卫、边卫 另外的职位呢？前腰、后腰、自由人 —— 每一回合开始时按一定概率转变成六大基本职责之一 前腰：中路组织、在禁区抓机会 一场比赛分为若干回合，每一回合有个持球方，由持球方来选择他们的进攻战术 差点意思 实时播报 以此代替画面，营造真实性 以后能加 … 赛事生成机制（联赛） 过渡 单单一场比赛体现不出两个球队的真实差距 不满足于两支球队之间的对抗，构造一个联赛 球员需要有轮换 引入体力——能力 怎么挑选球员获得最优解 算法是死的，人是活的 勾起了我自己排兵布阵的欲望 一个基本的比赛系统就完成了 画饼，痛点 由我自己亲手排兵布阵的球队在联赛上大杀四方，勇夺冠军 观察一个球员生涯的起起伏伏 打造一支拥有独特风格的俱乐部 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E5%89%8D%E6%B2%BF%E7%A0%94%E8%AE%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E5%89%8D%E6%B2%BF%E7%A0%94%E8%AE%A8/"},{"categories":null,"content":"地铁满载率的计算与预测 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"背景介绍与说明 400 便利的交通系统是现代社会的一大基本特征。而地铁又是公共交通的代表类型。近几年来，随着国家现代化建设加速，居民交通出行需求也在持续不断增长，公共交通的拥堵状况日益频，包含地铁作为一种重要的城市轨道交通系统，自然首先遇到拥挤带来的负卖能影响。在地铁近百年的运营历史中，如何对地铁的客运满载率进行准确的计算，如何根据外界因素预测地铁载客量的变化，一直是设计人员与工程师致力于解决与优化的课题。 满载率指列车装载的乘客数量与列车所能承载的最大乘客数量的比值，是衡量列车拥挤程度的唯一性指标。满载率会在列车运行时发生实时性的变化，但是其变化具有大致的规律性，会受到一系列外部因素的影响。 对地铁载客率算法的探究具有重要的现实意义：对影响地铁载客量因素的探索与权重比较可以优化地铁站、车厢等设施的建造设计；准确的载客量预测有助于地铁频次的调度分配和列车时刻表的修正；各个地铁站满载率的比较研究可以帮助工程师设计出更加合理快速的地铁线路。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"国内外研究现状 2000 对于地铁满载率的计算，现在主要有三大研究方向：传统的统计学方法、设备记录方法、自动检票系统与机器学习结合的方法。 使用传统的统计学理论，实地调研获取真实数据，这类方法拥有最高的准确度，却也有它的局限性：首先，它需要调用大量的人力物力、花费不可接受的时间成本来换取准确度；其次，以此法调查出来的数据拥有极大的地域局限性，很难推广到所有的地铁站；最后，数据的实时性明显不足 设备记录方法的使用相对比较广泛。各种方案的准确率、成本上的差异也比较大。其中，车辆称重与票务清分是使用最为广泛的两种满载率的计算方法。 车辆称重是指使用轨道车辆称重调簧及轮重减载率测试系统对整个列车车身进行质量测算，与已有的重量分级表进行比较，估算出乘客数量的技术。车厢称重系统在每次到站时，将测量的数据通过站台区域覆盖的无线网络上传至数据中心，完成一次数据采集过程。此法准确率有限，计算得到的结果只能以分级的形式呈现，数据精度难以达到目标；而且设备的维护成较高。 票务清分通过清分模型，将地铁运营的票款收入分配至各个运营线路上；其中保有每位乘客的进出站信息，可以根据这个信息粗略地得到乘客的出行数据，进而推测出乘客的线路乘坐情况。现代票务情分基本上由计算机程序进行控制，乘客的进出站数据的收集难度较小，可以使用最短路径清分法、k短路径清分法或多路径选择概率清分算法来大致刻画乘客的出行路线。票务清分系统使用了当前广泛普及的自动检票系统来完成客流走向的估算，成本较低；但是在准确度上尚有不足。乘客的进出站数据不能完美复现其行车走向；其步行到站时间、等车时间、漏乘到下一班的可能性都将被忽略，换乘的出现也将加大分析的难度，若没有一个精确可靠的数学模型来支撑这些数据，此种方法仍然不能较好地完成满载率测算的任务。 另一种新兴的测量方法是WIFI探针采集技术。这种技术将对开启WIFI的乘客设备进行数据采集，获取设备的MAC地址等可以识别身份的关键性、唯一性信息以记录乘客的数量。该方法的准确度较高，信号传输不易受到非视距误差和多径衰落影响，而且可以和传统的车联称重、票务分析的测算方法结合进行综合分析，准确度可以达到一个较高水准；但是此种方法也有一定缺陷：首先，WIFI探针具有一定的设备成本，使用时，还需要工作人员高举探针设备进行数据采集，而且普及率不高；其次，地下信号波动较大，而地面的信号干扰有比较大，WIFI探针的实际使用将会受这两个缺点的影响，工作场景并不是完美的；最后，这种放法针对的目标是具有WIFI功能的智能设备而不是乘客实体，没有考虑到一人多机的情况，也没有考虑到并不携带此种设备的乘客，这将会加大测算结果的偏差。 自动检票系统与机器学习结合是一种成本较低、准确率较高的测算方法，这种方法通过分析乘客的进出站时间、站点等数据，附加上天气、站点地理位置、列车班次表等因素，运用人工智能机器学习方法，构建一个估计乘客乘坐班次的数学模型，从而达到计算每个班次列车满载率的目标。这也是之后章节将要涉及的方向。这种方法的优点是人力、物力成本极小，不需要添置新的技术设备，也不需要工作人员做实时数据的采集，最为重要的乘客进出站数据已由自动检票系统代为收集；而且其维护成本低，一旦迭代出一个较为准确的数学模型，它就拥有一个极长的生命周期，不需要在使用时做很大的改动，全程自动化的特性极大方便了相关人员的使用；不仅对维护人员友好，这种测算方法也对乘客友好，相比于传统的人工收集、设备收集对于乘客较强的侵入性，自动检票系统更被大众接受，后台的机器学习模型也不会对乘客产生任何干扰和影响。综合来说，这种方法是最优的。不过如何构建出一个稳定、具有泛用性的数学模型，成了一个难题。 其中一种方法是使用SVR模型。支持向量机回归（SVR）是一种将特征向量映射到高维空间中再进行回归的支持向量机方法。通过提取耗时最短乘车事务的方法，可以得到一个不同起点站和终点站的矩阵，结合站台人数的变化确定列车驶离站台的时间，前后波峰波谷的插值估算出每班列车展台上的装载人数，再将这些数据作为特征输入到模型中进行训练，最后以均方根误差和平均绝对误差为评判指标不断优化迭代模型。 在对列车满载率进行实时估算之上的目标，就是预测出未来班次列车的满载率了。预测相较于估算有着更高的不确定性，传统的人工采集、设备采集的方法几乎不能再这个领域起到任何作用。这时候，基于机器学习算法的预测模型成为了最佳选择。 对列车满载率的预测，需要大量已知数据作为训练集，也需要收集许多可能影响乘客行程耗时的因素，组成一个庞大的多维度特征向量群来提高预测精确度。天气、温度、以天为单位的时刻、星期、节假日、站点的地理位置、站点容量、列车时间表等等变量都将对乘客的行程耗时造成影响，如何分析这些因素，是否可以得出其间的依赖关系，筛选去无关信息，是国内外研究的重点。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"关键问题难点分析 1000 本章节将简述使用自动检票系统与机器学习结合的方法对列车满载率进行测算和预估的一些难点介绍与分析 由于自动检票系统只能提供乘客的进出站时间、进出站站点信息，乘客实际上做了哪一班车无从而知，需要进行推测。 首先对普通乘客乘坐列车的常规行为进行分析。乘客的行程分为以下几个部分：进站——步行至站台——等候列车到站——上车——列车行进——到站下车——步行至出站闸机——出站。 其次，根据具体行为的不同，乘客也可以分为一般乘客和逗留乘客。前者按照通用的行程路线上下列车、进出站点，没有延长乘车时间的行为。后者还会因为种种原因在地铁站内进行长短时间不定的逗留，如天气影响、列车延误、等待同行者、站点属性（商住文教）等等。后者还可再次细分：主观逗留乘客和被动逗留乘客。 明确上述信息后，我们对直达乘客的乘坐班次问题进行进一步研究。这个问题主要想实现在输入乘客i进站时间、乘客i的出站时间、站点O的列车班次时间表和站点D的列车班次时间表之后，得到乘客i的乘车班次（上车时间）。目前构想的思路是：根据乘客的出站时间，将时间相近的乘客进行聚类，通过比较该类乘客最后一人的出站时间，结合列车班次的乘车时长，推算出这一批乘客在站台上车的具体时间点。 对于单次换乘乘客乘坐班次，我们进行如下分析：通过输入乘客i的O站进站时刻，O站到换乘站的乘车时间，换乘站的上车时刻，换乘站列车到站时刻，最后得到乘客i的乘车班次（上车时间）。目前构想的思路是：设置乘客的步行速度，得出进出站与换乘的步行时间；通过已知的输入数据计算乘客候车的时间总和，以耗时相同为标准将乘客进行分类：乘坐第一班次列车、乘坐后一班次列车。其中，留候的乘客又分为在O站候车和在换乘站候车两种情况。最后，结合乘客换乘站列车到站时刻的数据，减去对应的乘车时间便可得到乘客i的O站的乘坐班次，即上车时间。 在讨论的过程中，我们遇到不少的挑战。 对于一个单次换乘乘客而言，在已知其O站进站时刻、各线路乘车时间、换乘站列车到站时刻以及换乘点平均候车时间之后，如何得出乘客i的最优换乘路径？要达到最优状态，就得确保乘客换乘次数最少和耗时较少。而有时两者却不可兼得。我们的假想是对相应数据设置权重，运用图论建立站点之间的联系并计算。 此外，在乘坐班次的相关问题中，我们要对逗留乘客进行更加细致的分类：先等候后上车和先上车后等候。若该逗留乘客与同某一班次列车的乘客一同出站的话，就可以通过逗留乘客入站时间减去该批次乘客的平均入站时间得到i乘客的逗留时间，若逗留时间与列车班次的时间比值接近整数，则可得到逗留乘客是先等候后上车类型的乘客，进而推断出其等候的班次数，最后推导出乘坐班次。但这仅仅是一种未验证的设想。具体的实践需要结合大量样本的测试和验证。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"研究探索与尝试 2000 本章节主要运用到了两个关键技术来研究地铁客流量。第一个是EM算法，利用该算法与已有的进出站数据模拟乘客留乘的模型。第二个是K-means算法，结合EM算法对乘客耗时、天气温度、高峰期等因素进行聚类，从而使实验结果更接近真实的地铁客流量 EM算法又称最大期望算法，是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐性变量。最大期望算法经过两个步骤交替进行计算，第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。EM算法的具体思想就是：给隐变量θ自主规定个初值；根据给定观测数据和当前的参数θ，求未观测数据z的条件概率分布的期望；z已经求出来了，于是根据极大似然估计求最优的θ’；因为第二步和第三步的结果可能不是最优的，所以重复第二步和第三步，直到收敛。 K-means算法又称K均值聚类算法，是一种迭代求解的聚类分析算法，其步骤是，预先将数据分为K组，则随机选取K个对象作为初始的聚类中心，然后计算每个对象与各个种子聚类中心之间的距离，把每个对象分配给距离它最近的聚类中心。聚类中心以及分配给它们的对象就代表一个聚类。每分配一个样本，聚类的聚类中心会根据聚类中现有的对象被重新计算。这个过程将不断重复直到满足某个终止条件。终止条件可以是没有（或最小数目）对象被重新分配给不同的聚类，没有（或最小数目）聚类中心再发生变化，误差平方和局部最小。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"总结 300 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/:5:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%89%8D%E6%B2%BF/%E6%8A%A5%E5%91%8A/"},{"categories":null,"content":"实验三 https://blog.csdn.net/l4kjih3gfe2dcba1/article/details/119145719 用频率分析破解单表代换密码。 对密文进行单字频率分析 双字频率分析 三字频率分析 由此可以进行猜测 三字频率最大可能是单词 “the” 单字频率最大可能是 “e” 单字频率第二第三可能是 “t” 和 “a” 双字频率前三可能是 “th”，“he”，“in” 四种猜测可能性降序排列。 又发现，猜测 1 和猜测 4 可以互相验证，基本可以确定密文 “ytn” 对应明文 “the”，密文 “v” 对应明文 “a” 预览变化 猜测双字频率很高的 “mu” 对应 “in” “er”、“re”、“ed” 也是使用频次很高的二元字母序列，已知密文 “n” 对应明文 “e”，所以这三个序列可以完美对应频次表中的 “nh”、“nq”、“hn”；得： 密文 “h” 对应 “r” 密文 “q” 对应 “d” 接下来分析叠字的频率： 将结果与常用叠字作比较 可以肯定的是：“nn” 对应 “ee”，“yy” 对应 “tt”，因为这些字母均与之前的猜想互相印证 前文中密文 “q” 对应 “d” 的猜测需要做出更改，因为 “dd” 并不是常用的叠字；“q” 更有可能对应 “s”，因为 “es” 也是常用的二字序列之一。 又做出猜测：“ii” 对应 “ll”、“xx” 对应 “oo”（“x” 频率很高，“o” 在常用单字里频率也很高 ） 预览变化（以大写字母表示已经做过代换的字母） 发现一些常用词，如 “the”、“this”、“on”，已经显示出来了。 分析结果，我们可以发现一些规律： 多次出现了 “Ob” 单词，且其后多跟着 “the” 和 “this”；又有单词 ”ObTEN“；猜测对应 “of”，则密文 ”b“ 对应明文 ”f“ 出现 “NEfER” 字眼，猜测为 “never”，则密文 “f” 对应 “v” 出现 “lITH”、“lILL”、“lERE”、“lHEN” 字眼，猜测密文 “l” 对应 “w” 出现 “gETlEEN” 字眼，若 “l” 对应 “w”，则单词明显是 “between”，则密文 “g” 对应 “b” 预览这些猜想： 又可以发现一些规律 出现 “FIrHT” 字眼，又有 “mur” (已经可以写成 “INr”) 为高频三字序列，猜测密文 “r” 对应 “g” 出现 “FvVORITE” 字眼，猜测为 “favorite”，则密文 “v” 对应 “a”（同时 “v” 作为单字在密文中也相当高频） 出现 “ALTHOzGH”、“BzT”、“ABOzT” 字眼，猜测密文 “z” 对应 “u” 出现 “ANp”、“pOLLARS”、“AWARpS”、“AppRESS” 字眼，猜测密文 “p” 对应 “d” 出现 “HOLLdWOOD”、“ONLd”、“EVERd”、“dEARS”、“Bd” 字眼，猜测密文 “d” 对应 “y“ 出现 “aONTINUES”、“ADVANaE”、“WHIaH” 字眼，猜测密文 “a” 对应 “c“ 出现 “Ue”、“HAeeENS”、“eEOeLE” 字眼，猜测密文 “e” 对应 “p” 出现 “DREAc”、“CEREcONY”、“ACADEcY” 字眼，猜测密文 “c” 对应 “m” 出现 “oUST”、“oUBILANT” 字眼，且 “o” 频次很低，猜测对应 “j” 出现 “THANsS”、“BLACs”、“LIsELY” 字眼，猜测密文 “s” 对应 “k” “w” 仅出现在 “PRIwE” 中，猜测为频率很低的 “z” “j” 出现在 “jUALLY”、“jUESTION” 中，猜测为频率很低的 “q” “k” 出现在 “SEkUAL”、“EkPERTS” 中，猜测为频率很低的 “x” 自此，26 个字母的破解全部完成，密钥如下： 破解出的原文如下： the oscars turn on sunday which seems about right after this long strange awards trip the bagger feels like a nonagenarian too the awards race was bookended by the demise of harvey weinstein at its outset and the apparent implosion of his film company at the end and it was shaped by the emergence of metoo times up blackgown politics armcandy activism and a national conversation as brief and mad as a fever dream about whether there ought to be a president winfrey the season didnt just seem extra long it was extra long because the oscars were moved to the first weekend in march to avoid conflicting with the closing ceremony of the winter olympics thanks pyeongchang one big question surrounding this years academy awards is how or if the ceremony will address metoo especially after the golden globes which became a jubilant comingout party for times up the movement spearheaded by powerful hollywood women who helped raise millions of dollars to fight sexual harassment around the country signaling their support golden globes attendees swathed themselves in black sported lapel pins and sounded off about sexist power imbalances from the red carpet and the stage on the air e was called out about pay inequity after its former anchor catt sadler quit once she learned that she was making far less than a male cohost and during the ceremony natalie portman took a blunt and satisfying dig at the allmale roster of nominated directors how could that be topped as it turns out at least in terms of the oscars it probably wont be women involved in times up said that although the globes signified the initiatives launch they never intended it to be just an awards season campaign or one that became associated only with redcarpet actions instead a spokeswoman said the group is working behind closed doors and has since amassed million for its legal defense fund which after the globes was flooded with thousands of donations of or less from people in some countries no call to wear black gowns went out in advance of the oscars though the movement will almost certainly be referenced before and during the ceremony especially since vocal metoo supporters like ashley judd laura dern and nicole kidman are scheduled presenters another feature of this season no one really knows who is going to win best picture arguably this happens a lot of the time ina","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/ex3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/ex3/"},{"categories":null,"content":"实验四 https://zhuanlan.zhihu.com/p/48249182 推导 rsa 私钥 随机选择两个不相等的质数 p 和 q 计算 p 和 q 的乘积 n 计算 n 的欧拉函数 φ(n) = (p-1)(q-1) 随机选择一个整数 e，满足 1\u003c e \u003c φ(n)，且 e 与 φ(n) 互质 计算 e对于 φ(n) 的模反元素 d 即 ed ≡ 1 (mod φ(n)) 等价于 ed - 1 = kφ(n) 将 n 和 e 封装成公钥，n 和 d 封装成私钥 公钥加密算法 设加密信息 m，其必须是整数（字符串可以取 ascii 值或 unicode 值），且 m \u003e n。 求出对应的密文 c： m^e^ ≡ c (mod n) 私钥解密算法 c^d^ ≡ m (mod n) ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/ex4/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/ex4/"},{"categories":null,"content":"scanit ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"开发目的 端口扫描是指发送特特定的数据包到指定主机的端口，以获取端口状态的一种技术，它能用来了解与目标端口绑定的计算机网络服务类型。 端口扫描在计算机安全领域发挥着重要的作用，通常，一个开放的端口就是一个潜在的入侵点，通过端口扫描，我们能全盘了解网站可能暴露的漏洞，对网络安全方面有着不可或缺的贡献。所以，了解如何使用端口扫描技术是一门重要的课题 半开放端口扫描（又名SYN scan）技术，是利用TCP建立连接三次握手中的半开放状态进行端口扫描的一种方式：开放的目标端口在接到主机发来的SYN包后，会返回一个SYN+ACK回应，若此时主机受到这样的响应包，就没有必要进行接下来的握手步骤，在半开放的状态下即终止连接。半开放端口扫描技术发出的探测包，不会被目标主机记录，安全性更高，扫描速度也比传统的全连接扫描更快。 本项目使用Golang编写完成了一个TCP半开放扫描工具，Go拥有接近C语言的速度和便捷的并发编程语法，还提供了基于libpcap的gopacket库，所以它成为了项目的不二之选。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"系统功能 系统实现了对指定ip地址或域名地址的所有端口（1-65535）进行TCP半开放端口扫描的功能。 系统提供了编译后可在命令行界面运行的指令语法，可以使用不同的命令参数（flag）来选择解析ip地址或域名的端口状态，也可以指定扫描的端口序列范围。 命令执行后会打印目标主机开放的端口列表。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"系统设计 系统主要由三部分组成 一些与网络接口处理相关的工具函数 端口扫描器Scanner的结构及其方法定义 命令行语法构建程序 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"网络接口工具函数 在进行端口扫描事前，系统需要寻找一个合适的网络接口设备来承担收发数据包的工作，core/utils中的函数功能实现了这一过程的全自动化操作，即： 获取出站ip地址 -\u003e 在一众网络接口中选取与出站ip匹配的接口设备 -\u003e 获取其mac地址 getOutboundIP()调用net标准库中的通讯模块，向特定ip地址发送udp包的方法来自动化地获取本地主机的出站ip chooseDevice()负责遍历本地主机的所有网络接口设备，并且找出匹配出站ip的设备接口名 getLocalMAC()则找出该设备的mac地址 为什么要获取mac地址和出站ip地址？ tcp包的构建不仅需要tcp协议的支持，也依赖于底层的ip协议层和以太网（Ethernet）协议层，而ip地址和mac地址在这两层中分别都起到了定位作用，必不可少。 同理，我们也需要知晓目标主机的ip地址和mac地址，才能构建对应的协议包头 GetDstMAC()发送了一个ARP请求包，期望获取目标主机的mac地址以构建以太网协议层的数据包头。函数循环发送5次ARP请求包，并且创建一个goroutine（go协程）专门等待响应；一旦监听到返回的数据包即返回其中的mac地址。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"端口扫描器Scanner Scanner的结构体定义如下： // Scanner 端口扫描器 维护一个ip地址的端口扫描工作 type Scanner struct { mac net.HardwareAddr // 本地主机mac地址 deviceName string // 本地发送设备名 handle *pcap.Handle // 本地设备句柄 srcIP, dstIP, gatewayIP net.IP // 出站ip 目标ip 网关ip // opts 和 buf 被用于 send 方法 opts gopacket.SerializeOptions // 配置项 buf gopacket.SerializeBuffer // 待发送的序列缓冲 openPort []string // 开放的端口 } 在初始化Scanner时，一个对应网络接口设备的句柄（handle）将会生成，数据包的收发工作都由它完成； // 创建句柄 实现tcp包的发送和接收 handle, err := pcap.OpenLive(deviceName, 65536, true, pcap.BlockForever) 接下来介绍Scanner核心逻辑的实现 发送SYN包 send()封装了gopacket库中的方法，将字节数组写进序列化缓冲中发送 sendSYNPackets() 以goroutine的方式被扫描程序调用；它对目标地址从1到25565循环使用send()方法发送SYN数据包，试图对相应的端口建立TCP连接；在循环结束后，向一个channel（管道）内冲进一个标记以提示主程序发送完毕 // 循环发送SYN包 for portNum := 1; portNum \u003c= 65535; portNum++ { s.send(ethLayer, ip4Layer, tcpLayer) } 对发向不同的端口的TCP数据包来说，它们之间的唯一不同就是TCP包头中的DstPort。所以我们使用一个统一的getLayers()函数来构建包头信息的相同部分（包括IP协议层与以太网协议层）。 值得注意的是，在手动构建TCP数据包的过程中，TCP包头中的校验和被包裹住（wrap）它的IP协议层所决定。gopacket为我们提供了一个简便的解决方案SetNetworkLayerForChecksum()来实现自动计算校验和的目的： // 使用ipv4协议包裹tcp层 以方便计算校验和 err := tcpLayer.SetNetworkLayerForChecksum(\u0026ip4Layer) 监听响应 并发优化 发送与监听如果设计成线性运行，将会相当耗时。得益于Golang中的goroutine语法，我们可以方便地做到发送和监听功能并发执行： quit := make(chan int) // 发送syn包 go s.sendSYNPackets(quit) // 阻塞以读取响应包 s.handleResponse(quit) go关键字开启了一个goroutine，保证发送逻辑在一个全新的协程中运行，与主进程互不干扰；所以在sendSYNPackets()仍未完成时，handleResponse()即可以开始监听收到的响应包 handleResponse()接受一个channal信号quit，quit管道将在sendSYNPackets()结束后被写入标志，提醒监听结束，程序退出。也就是说，监听会在发送完65536个SYN包外加一段人为添加的时间间隔之后结束： // ...此逻辑在sendSYNPackets()中 log.Print(\"all ports are sent\") time.Sleep(time.Second) // 等一秒钟 保证接收端不遗漏有效响应 quit \u003c- 1 监听过程 gopacket提供了监听响应包的相关函数，该函数返回一个channel，一旦有新的数据包被此网络接口接收，它会作为Packet类型被送入channel中，并被handleResponse()方法捕捉到进行分析处理。 // handleResponse 处理响应包 func (s *Scanner) handleResponse(quit \u003c-chan int) { packetSource := gopacket.NewPacketSource(s.handle, s.handle.LinkType()) packetChan := packetSource.Packets() // 监听 for { select { case \u003c-quit: log.Printf(\"seems like we find all open port of %v\", s.dstIP) return case packet := \u003c-packetChan: s.judgePortStatus(packet) } } } select case为Golang的语法糖，它阻塞程序，直到任意一个case上的channel有新数据读出 过滤数据包 监听时，任何流经此接口设备的数据包（甚至是发送至目标端口上的SYN包）都会被捕捉到，所以，过滤数据包、从中筛选出对象端口的响应数据是必要的过程。 过滤算法要求尽可能更早地将无用数据淘汰，因此，判断条件应该按淘汰命中率降序排列： // judgePortStatus 拆解响应包 分析端口状态 并在s中添加活跃端口 func (s *Scanner) judgePortStatus(packet gopacket.Packet) { if networkLayer := packet.NetworkLayer(); networkLayer == nil { // 检查是否有网络层 // log.Printf(\"packet has no network layer\") } else if ipl := packet.Layer(layers.LayerTypeIPv4); ipl == nil { // 检查是否有ip层 // log.Printf(\"packet has no IPv4 layer\") } else if tcpl := packet.Layer(layers.LayerTypeTCP); tcpl == nil { // 检查是否有TCP层 // log.Printf(\"packet has no TCP layer\") } else if recvIPLayer, _ := ipl.(*layers.IPv4); !net.IP.Equal(recvIPLayer.SrcIP, s.dstIP) || !net.IP.Equal(recvIPLayer.DstIP, s.srcIP) { // 检查目标ip和源ip是否匹配 // log.Printf(\"packet does not match our src IP / dst IP\") } else if recvTCPLayer, ok := tcpl.(*layers.TCP); !ok { // 基本不会发生 // log.Printf(\"tcp layer is not tcp layer\") } else if recvTCPLayer.DstPort != SRC_PORT { // log.Printf(\"dst port %v does not match\", recvTCPLayer.DstPort) } else if recvTCPLayer.RST { // log.Printf(\"port %v closed\", recvTCPLayer.SrcPort) } else if recvTCPLayer.SYN \u0026\u0026 recvTCPLayer.ACK { log.Printf(\"port %v open\", recvTCPLayer.SrcPort) s.openPort = append(s.openPort, recvTCPLayer.SrcPort.String()) } else { log.Printf(\"ignoring useless packet\") } } “检查目标ip和源ip是否匹配”的判断可以过滤掉绝大多数的无用信息。 对于目标端口的响应，主要有三种类型： 若目标端口返回SYN+ACK的数据包，则代表此端口处于开放状态 若目标端口返回RST数据包，则代表此端口处于关闭状态 若目标端口没有回应，则发出去的SYN包可能被包过滤机制过滤，也可以认为此端口处于关闭状态 在目标返回一个SYN+ACK类型的数据包之后，我们已经达到了探测的目的，可以省略发送RST复位信息以断开连接这一步。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"命令行语法 系统采用cobra构建命令行程序，提供丰富的自定义选项 指定ip地址 -i [ip address]或--ipaddr [ip address] 扫描指定ip地址中的所有端口 ip address允许以ipv4和ipv6格式输入 ./scanit -i 192.168.0.1 指定域名 -d [domain name]或--domain [domain name] 扫描指定域名下的所有端口 ./scanit -d baidu.com 若同时输入-i和-d选项，程序将默认优先识别-d，如果域名不合法才会尝试-i 指定端口范围 -p [port range]或--port [port range] 扫描指定范围内的端口，默认为1-65535 [port range]的语法格式为int-int，如114-514 ./scanit -d github.com -p 123-6547 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:3:3","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"系统实现 开发环境：Windows10-21H2 IDE：GoLand 2021.3.1 开发语言：Go 1.17.4 测试环境： Windows10-21H2 Ubuntu 20.04.2 扫描ip地址 扫描域名 值得注意的是，在Linux上程序的运行耗时（3-5s）大大少于在Windows上运行（半分钟左右） 指定端口范围进行扫描 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"项目开发总结 本项目基于libpcap、使用Go语言开发了一个半开放端口扫描工具，并提供了ip地址和域名的查询选择，允许用户以命令行指令的形式运行程序，具有比较完备的命令行语法检查，而且速度较快，可以接近nmap等传统端口扫描工具；同时准确率较高；但是项目需要完善的地方也有很多。 如何在有限的监听时间段内全面地接收到所有端口的响应，项目采用了一个较为简单的策略：在发送完所有SYN包后，系统将等待一段固定的时间间隔，超时则停止监听。但这样的策略对于一些后发迟发端口，可能会有遗漏的情况发生。 对于每一个单独的端口，指令只会发送一个SYN包；探测包如果在途中丢失，对于此端口的扫描实际上是失败的，系统没有检测机制来防止这样的情况发生。若对一个端口重复发包，效率上又失去了优势。因此，速度与准确率，向来是个两难的抉择。 另外，命令行界面尽管效率高，但是稍显简单；日后可以计划构建对用户更加友好的图形界面。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:5:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"心得体会 十周的《计算机安全与保密技术》课程，我获益良多。不论是在课堂上，在实验课中，还是在课外学习期间，我都能收获到其他课程所无法给予的网络安全知识与实战经验。 老师对于整个课程的规划非常合理完备：课上主讲专业知识，提供理论保障；实验课引入了一套齐全、循序渐进的教学方案，非常考验我们的英语能力、阅读文档和自学的能力；又以开发一个实战项目为期末考核内容，而不是简单机械地用卷面考试来评判成绩。得幸于这样的教学安排，我可以在短短十周接触到网络安全技术的诸多内容。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:6:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"参考文献 https://pkg.go.dev/github.com/google/gopacket?utm_source=godoc https://tutorialedge.net/projects/building-security-tools-in-go/building-port-scanner-go/#what-is-port-scanning ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/:7:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"实验一 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/"},{"categories":null,"content":"问题描述 编写程序，实现图像任意角度的旋转（注意精度） ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/"},{"categories":null,"content":"实验分析 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/"},{"categories":null,"content":"实现 图像旋转通常以中心为原点进行，基本步骤为 将矩阵坐标转换为笛卡尔坐标系 将该点旋转 $\\theta$ 度 将旋转后的点再转换为矩阵坐标 有 值得注意的是，图像旋转后，新图像的大小会发生改变 取旋转后四个绝对值最大的点，定义新图像的大小 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/"},{"categories":null,"content":"代码 show_rotate1 函数调用了 cv2 的 warpAffine 函数，运用仿射变换原理完成了图像的旋转 show_rotate2 函数则手动实现了朴素的旋转算法 # ex1 图像任意角度旋转 import math import numpy as np import cv2 def show_rotate1(file_path: str, angle: float = 0): \"\"\" 按照指定角度旋转头像 :param file_path: 图片路径 :param angle: 旋转角度 \"\"\" img = cv2.imread(file_path) rows, cols = img.shape[:2] M = cv2.getRotationMatrix2D((cols/2, rows/2), angle, 1) img = cv2.warpAffine(img, M, (cols, rows), borderValue=(255, 255, 255)) cv2.imshow('img', img) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() def show_rotate2(file_path: str, angle: float = 0): img = cv2.imread(file_path) height, width = img.shape[:2] angle_pi = angle*math.pi/180.0 cos_A = math.cos(angle_pi) sin_A = math.sin(angle_pi) # 确定新图的大小 new_x1 = math.ceil(abs(0.5*height*cos_A + 0.5*width*sin_A)) new_x2 = math.ceil(abs(0.5*height*cos_A - 0.5*width*sin_A)) new_y1 = math.ceil(abs(-0.5*height*sin_A + 0.5*width*cos_A)) new_y2 = math.ceil(abs(-0.5*height*sin_A - 0.5*width*cos_A)) new_height = int(2*max(new_y1, new_y2)) new_width = int(2*max(new_x1, new_x2)) new_img = np.zeros(shape=(new_height, new_width, 3), dtype=np.uint8) for i in range(height): for j in range(width): x = int( cos_A*i-sin_A*j-0.5*width*cos_A+0.5*height*sin_A+0.5*new_width) y = int( sin_A*i+cos_A*j-0.5*width*sin_A-0.5*height*cos_A+0.5*new_height) new_img[x, y] = img[i, j] cv2.imshow('img', new_img) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() if __name__ == '__main__': file_path = r\"D:\\Repo\\PythonLearning\\cv2Learning\\assets\\pic.jpg\" show_rotate2(file_path, 66.71) ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/"},{"categories":null,"content":"示例 cv2 函数效果 手动实现的算法效果 可以看到手动实现的图像新添了很多“蜂窝煤”状的坏点 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/"},{"categories":null,"content":"实验二 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/"},{"categories":null,"content":"问题描述 编写程序，实现图像的实数倍放大 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/"},{"categories":null,"content":"实验分析 采用复制行/列可以实现整数倍的放大图像，采用删除行/列可以实现整数倍的缩小图像，但两种方法都无法实现任意倍数和任意位置的放大和缩小图像 步骤 计算新的像素在原图的对应位置； 为这些对应位置赋灰度值。 计算新像素在原图的对应位置 f(x,y) 表示输出图像，g(u,v) 表示输入图像。几何运算（图像的放大或缩小也是图像的几何运算）可定义为： 如果令：$u_0 = a(x,y) = x$; $v_0 = b(x,y) = y$ 那么仅仅是把 g 拷贝到 f 而不加任何改动的恒等运算。 如果令：$u_0 = a(x,y) = x + x_0$; $v_0 = b(x,y) = y + y_0$ 那么得到平移运算，其中点 (x~0~,y~0~) 被平移到原点 如果令：$u_0 = a(x,y) = x/c$; $v_0 = b(x,y) = y/d$ 那么会使图像在 x 轴方向放大 c 倍，在 y 轴放大 d 倍。 例如：将一幅 200x200 的图像 g(u,v) 放大 1.5 倍，那么将得到 300x300 的新图像 f(x,y)。 产生新图像的过程，实际就是为 300x300 的像素赋值的过程。 假如为 f(150,150) 赋值 $f(150,150) = g(150/1.5,150/1.5) = g(100,100)$; 假如为 f(100,100) 赋值 $f(100,100) = g(100/1.5,100/1.5) = g(66.7,66.7)$ 由于图像像素都是在整数坐标中，所以没有坐标值为 (66.7,66.7) 的像素。所以要采用插值的方法给其赋值。 为这些对应位置赋灰度值 因为 (u~0~, v~0~) 不一定要在坐标点上，故需要插值求 g(u~0~, v~0~)； 最近邻内插 取点 (u~0~, v~0~) 最近的整数坐标 (u, v)。在上述例子中，为了求 (66.7, 66.7) 的灰度值，则用 (67, 67) 的灰度值来做插值 双线性插值 根据四个邻点的灰度值通过插值计算 g(u~0~, v~0~) 更多邻点的内插 更高次内插，这种方法往往能取得更为精确的结果，但是相应的计算量也会更大） 使用最邻近插值法实现图像的缩放，比较简单方便；cv2 中同样也提供了图像缩放的函数 resize ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/"},{"categories":null,"content":"实现 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/"},{"categories":null,"content":"代码 show_scale1 函数调用了 cv2.resize show_scale2 函数手动实现了以便最邻近插值 # ex2 图像的实数倍放大，并且实现图像的规定长度和宽度缩放. import numpy as np import cv2 file_path = r\"D:\\Repo\\PythonLearning\\cv2Learning\\assets\\seg.png\" def show_scale1(file_path: str, x_scale: float = 1, y_scale: float = 1): \"\"\" 按照规定长度和宽度缩放图像 :param file_path: 图片路径 :param x_scale: 水平缩放倍数 :param y_scale: 垂直缩放倍数 \"\"\" img = cv2.imread(file_path) img = cv2.resize(img, dsize=None, fx=x_scale, fy=y_scale) cv2.imshow('img', img) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() def show_scale2(file_path: str, x_scale: float = 1, y_scale: float = 1): img = cv2.imread(file_path) cv2.imshow('ori', img) ori_height, ori_width = img.shape[:2] # 将图片尺寸记录下来 tar_height = round(ori_height*x_scale) tar_width = round(ori_width*y_scale) new_img = np.zeros(shape=(tar_height, tar_width, 3), dtype=np.uint8) for x in range(tar_height): for y in range(tar_width): src_x = int(x/x_scale) src_y = int(y/y_scale) if src_x \u003c ori_height and src_y \u003c ori_width: new_img[x, y] = img[src_x, src_y] cv2.imshow('final', new_img) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() if __name__ == '__main__': show_scale2(file_path, 2.31, 3.34) ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/"},{"categories":null,"content":"示例 实现了纵向 2.31 倍、横向 3.34 倍的图像放大 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex2/"},{"categories":null,"content":"实验三 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/"},{"categories":null,"content":"问题描述 编写程序，对图象进行中值滤波，并与实现相同功能的 Matlab 函数（或 cv2 函数）进行运算速度比较 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/"},{"categories":null,"content":"实验分析 平滑滤波是低频增强的空间域滤波技术。它的目的有两类：一类是模糊；另一类是消除噪音。 空间域的平滑滤波一般采用简单平均法进行，就是求掩模内像素点的平均亮度值。此题则是求掩模内像素点的中位数。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/"},{"categories":null,"content":"实现 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/"},{"categories":null,"content":"代码 median_blur1 函数是调用了 cv2 的 medianBlur 函数 median_blur2 手动实现了简单的中值滤波 # ex3 中值滤波 import numpy as np import cv2 import time file_path = r\"D:\\Repo\\PythonLearning\\cv2Learning\\assets\\dog.png\" def median_blur1(file_path: str, ksize: int = 5): \"\"\" opencv中值滤波 :param file_path: 图片路径 :param ksize: 滤波模板的尺寸大小，必须是大于1的奇数 \"\"\" start_time = time.time() img = cv2.imread(file_path) img = cv2.medianBlur(img, ksize) cv2.imshow('img', img) end_time = time.time() print('耗时{}s'.format(end_time - start_time)) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() def median_blur2(file_path: str, ksize: int = 5, is_grey: bool = False): \"\"\" 手动实现的中值滤波 :param file_path: 图片路径 :param ksize: 滤波模板的尺寸大小，必须是大于1的奇数 \"\"\" start_time = time.time() edge = int((ksize-1)/2) img = cv2.imread(file_path) if is_grey: img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) height, width = img.shape[:2] # 将图片尺寸记录下来 for i in range(height): for j in range(width): if i \u003c= edge-1 or i \u003e= height-edge-1 or j \u003c edge-1 or j \u003e= width-edge-1: # 忽略出界点 continue if is_grey: img[i, j] = np.median( img[i-edge:i+1+edge, j-edge:j+edge+1]) else: img[i, j, 0] = np.median( img[i-edge:i+1+edge, j-edge:j+edge+1, 0]) img[i, j, 1] = np.median( img[i-edge:i+1+edge, j-edge:j+edge+1, 1]) img[i, j, 2] = np.median( img[i-edge:i+1+edge, j-edge:j+edge+1, 2]) cv2.imshow('img', img) end_time = time.time() print('耗时{}s'.format(end_time - start_time)) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() if __name__ == '__main__': median_blur2(file_path, 7) ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/"},{"categories":null,"content":"示例 原图 使用 cv2 的中值滤波函数 自己实现的中值滤波函数 可以看到，cv2 中的中值滤波函数经过优化，耗时非常短。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex3/"},{"categories":null,"content":"实验四 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/"},{"categories":null,"content":"问题描述 编写程序，实现阈值分割算法 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/"},{"categories":null,"content":"实验分析 阈值分割法是一种基于区域的图像分割技术，cv2 提供了丰富优秀的阈值分割算法。 cv2.threshold(src, thresh, maxval, type[, dst]) 参数 thresh：阈值 maxval：最大阈值，一般为 25./.,.5 type：阈值方式，最主要有五种 阈值 小于阈值的像素点 大于阈值的像素点 0 置0 置填充色 1 置填充色 置0 2 保持原色 置灰色 3 置0 保持原色 4 保持原色 置0 返回值 ret dst：阈值分割后的图像 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/"},{"categories":null,"content":"实现 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/"},{"categories":null,"content":"代码 # ex9 阈值分割算法 import cv2 import matplotlib.pyplot as plt # 灰度图读入 img = cv2.imread(r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\dog.png', 0) # 5种不同的阈值方法 ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) ret, th2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV) ret, th3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC) ret, th4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO) ret, th5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV) titles = ['Original', 'BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV'] images = [img, th1, th2, th3, th4, th5] # 使用Matplotlib显示 # 两行三列图 for i in range(6): plt.subplot(2, 3, i + 1) plt.imshow(images[i], 'gray') plt.title(titles[i], fontsize=8) plt.xticks([]), plt.yticks([]) # 隐藏坐标轴 plt.show() ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/"},{"categories":null,"content":"示例 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex4/"},{"categories":null,"content":"实验五 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"问题描述 编写程序，对图像的分割区域进行标记，并提取标记区域特征． ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"实验分析 图像的分割算法可以参考实验四的阈值分割来完成 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"连通域标记算法 要对图像进行区域标记，常用的方法是连通域标记算法，其又分为四邻域标记算法与八邻域标记算法 四邻域标记算法 判断此点四邻域中的最左，最上有没有点，如果都没有点，则表示一个新的区域的开始。 如果此点四邻域中的最左有点，最上没有点，则标记此点为最左点的值；如果此点四邻域中的最左没有点，最上有点，则标记此点为最上点的值。 如果此点四邻域中的最左有点，最上都有点，则标记此点为这两个中的最小的标记点，并修改大标记为小标记。 八邻域标记算法 判断此点八邻域中的最左，左上，最上，上右点的情况。 如果都没有点，则表示一个新的区域的开始。 如果此点八邻域中的最左有点，上右都有点，则标记此点为这两个中的最小的标记点，并修改大标记为小标记。 如果此点八邻域中的左上有点，上右都有点，则标记此点为这两个中的最小的标记点，并修改大标记为小标记。 否则按照最左，左上，最上，上右的顺序，标记此点为四个中的一个。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:2:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"轮廓检测 除了连通域标记算法，直接对图像进行轮廓检测也是一种很好的思路，对于一个经过处理的二值图像（如阈值分割、Canny、拉普拉斯等边缘检测算子处理），容易用 findContours 得到其轮廓数据 cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]]) 参数 image：目标图像 mode：轮廓的检索模式 cv2.RETR_EXTERNAL 表示只检测外轮廓 cv2.RETR_LIST 检测的轮廓不建立等级关系 cv2.RETR_CCOMP 建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。 cv2.RETR_TREE 建立一个等级树结构的轮廓。 method：轮廓的近似办法 cv2.CHAIN_APPROX_NONE：存储所有的轮廓点，相邻的两个点的像素位置差不超过 1，即 max(abs(x1-x2), abs(y2-y1)) == 1 cv2.CHAIN_APPROX_SIMPLE：压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息 cv2.CHAIN_APPROX_TC89_L1，CV_CHAIN_APPROX_TC89_KCOS 使用 teh-Chinl chain 近似算法 返回值 函数返回两个值，一个是轮廓本身，还有一个是每条轮廓对应的属性。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:2:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"区域特征提取 SIFT (Scale-Invariant Feature Transform) 是最成功的图像局部描述子之一。SIFT 特征包括兴趣点检测器和描述子，其中 SIFT 描述子具有非常强的稳健性，这在很大程度上也是 SIFT 特征能够成功和流行的主要原因。SIFT特征对于尺度、旋转、亮度都具有不变性。 可以用 sift 算法找出图像的角点分布 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:2:3","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"实现 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"连通域标记 使用四邻域标记算法标记区域，并且区域用不同颜色划分开来 代码 import cv2 import numpy as np import matplotlib.pyplot as plt # Read image img = cv2.imread(r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\seg.png').astype(np.float32) height, weight, color = img.shape label = np.zeros((height, weight), dtype=np.int) label[img[..., 0] \u003e 0] = 1 LUT = [0 for _ in range(height*weight)] n = 1 for y in range(height): for x in range(weight): if label[y, x] == 0: continue c3 = label[max(y-1, 0), x] c5 = label[y, max(x-1, 0)] if c3 \u003c 2 and c5 \u003c 2: n += 1 label[y, x] = n else: _vs = [c3, c5] vs = [a for a in _vs if a \u003e 1] v = min(vs) label[y, x] = v minv = v for _v in vs: if LUT[_v] != 0: minv = min(minv, LUT[_v]) for _v in vs: LUT[_v] = minv count = 1 for l in range(2, n+1): flag = True for i in range(n+1): if LUT[i] == l: if flag: count += 1 flag = False LUT[i] = count COLORS = [[0, 0, 255], [0, 255, 0], [255, 0, 0], [255, 255, 0]] out = np.zeros((height, weight, color), dtype=np.uint8) for i, lut in enumerate(LUT[2:]): out[label == (i+2)] = COLORS[(lut-2) % 4] # Save result cv2.imwrite(\"out.png\", out) cv2.imshow(\"result\", out) cv2.waitKey(0) cv2.destroyAllWindows() 示例 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:3:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"轮廓检测 代码 思路 查出地图上湖水的 RGB 值，根据这个值来对整个图像进行阈值分割 调用 findContours 找出湖泊轮廓 调用 drawContours 绘制轮廓线 import cv2 import numpy as np img = cv2.imread(r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\map.png') lake_BGR = np.array([224, 182, 156]) mask_img = cv2.inRange(img, lake_BGR-10, lake_BGR+10) # ret, binary = cv2.threshold(img, 127, 255, 0) # 阈值处理 contours, hierarchy = cv2.findContours( mask_img.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE) # 查找检测物体的轮廓，只检测最外轮廓 all_lakes_img = img cv2.drawContours( all_lakes_img, contours, -1, (0, 0, 255), 3) # 绘制轮廓 cv2.imshow(\"final\", all_lakes_img) if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() 示例 使用红线将江河的轮廓标记了出来 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:3:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"区域特征提取 代码 # SIFT 算法提取图像特征 import cv2 import matplotlib.pyplot as plt img = cv2.imread( r'D:\\Repo\\PythonLearning\\cv2Learning\\assets\\selina.jpg', 0) # 输入灰度图 # 构造生成器 sift = cv2.xfeatures2d.SIFT_create() # 检测图片 kp, des = sift.detectAndCompute(img, None) # 关键点（Keypoint）和描述子（Descriptor） # 绘出关键点 img2 = cv2.drawKeypoints(img, kp, None, (255, 0, 0), 4) # 显示 plt.figure(figsize=(10, 10)) # 画布放大10倍 plt.axis('off') # 隐藏坐标轴 plt.imshow(img2) # 打印图像 plt.show() # 显示画布 if cv2.waitKey() == ord('q'): cv2.destroyAllWindows() 示例 原图 找出图像的角点分布 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/:3:3","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex5/"},{"categories":null,"content":"第二章 能，需要用到一个远紫外的单一照明源，它能够检测到所有物体（看到一个物体所需的照明源的波长必须小于等于该物体波长） 按顺序摆放一个红色、绿色和蓝色的单色相机镜头，若三个镜头都工作，则是白色。 $$ f(x,y)=i(x,y)r(x,y)=255e^{-[(x-x_0)^2+(y-y_0)^2]}\\times 1.0=255e^{-[(x-x_0)^2+(y-y_0)^2]}\\ \\Delta G=(255+1)/2^k=4\\ k=6 $$ (a) 总数据量 M = 2048 × 2048 ×（8+2） ​ 时间 T = M/33600 = 1248.3s (b) T = M/3000000 = 13.98s 找出一个像素点的所有邻接情况，将对角元素转化成相应的四邻接元素。 产品的纵向结构不应过于复杂，因为“金”图像只能检测出一个面的缺失情况 （a）可能范围是 -511 到 255 （b）不会 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter2/"},{"categories":null,"content":"第三章 3-1 为了展开一幅图像的灰度，使其最低灰度为 C，最高灰度为 L-1，试给出一个单调的变换函数 $$ s=T(r)= \\begin{cases} \\ C, \\ if \\ r\u003cC \\ \\ r, \\ Others \\end{cases} $$ 3-5 将低有效比特平面设为零对图像的直方图有什么影响？将高有效比特平面设为零对图像的直方图有什么影响？ 将低有效比特平面设为零，图像中具有不同灰阶值的像素数目将降低。而像素的总数目不变，因此最终直方图中各分量的幅值将增加。灰阶值的减少通常会导致对比度下降。 高有效比特平面设为零，将导致图像亮度和对比度的下降。并且因为丢失了大量的细节信息，造成图像质量严重下降。例如，若将 8bit 图像的最高位丢掉，图像的最高亮度就由 255 变成 127。同样，像素总数保持不变，最终直方图中某些分量的幅值将升高。直方图的整体形状就是高而窄，并且在大于 127 的灰度上没有直方图分量。 3-6 为什么离散直方图均衡技术一般不能得到平坦的直方图？ 直方图均衡即在灰阶尺度上重新影射各直方图分量。 为了获得均匀平坦的直方图，要求在各灰阶上都具有相同的像素数目。即，假设共有 L 个灰阶，总的像素数目为 n，则每个直方图分量中都有 n/L 个像素。 而直方图均衡并不能确保实现上述分布。 3-14 具有相同灰度直方图的图像，用同一模板处理后，直方图应该还是相同的，因为其均值模板处理时是针对灰度值的，并不是针对图像像素的，所以其直方图还是相同的 3-15 (1) 对于 3×3 的掩模： $$ R_{new}=R_{old}+(C_3-C_1) $$ 而对于 n×n 的掩模，计算 $C_n$ 需要 $(n-1)$ 次加法，计算 $R_{new}$ 需要 1 次减法和 1 次加法，共计 $(n+1)$ 次运算 (2) $$ A=\\frac{n^2-1}{n+1}=n-1 $$ 3-21 当 n=25 的方形均值掩模向右平移时，掩模所覆盖的属于竖直条的像素的个数并不发生变换，因而其输出的像素平均值不变。因此，竖条间没有间隔。 3-23 拉普拉斯模板和均值模板都是线性操作，交换顺序不会影响结果 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/"},{"categories":null,"content":"imadjust ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/"},{"categories":null,"content":"语法 imadjust() 用于调节灰度图像的亮度或彩色图像的颜色矩阵。 常用语法有 J = imadjust(I) J = imadjust(I, [low_in; high_in], [low_out; high_out], gamma) ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/:1:1","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/"},{"categories":null,"content":"描述 J = imadjust(I) 将灰度图像 I 中的灰度值映射成输出图像 J 中的新值，使得灰度图像 I 在低灰度值和高灰度值上 1% 的数据是饱和的。这增强了输出图像 J 的对比度。 本语法相当于 imadjust(I, stretchlim(I))。 J = imadjust(I, [low_in; high_in], [low_out; high_out], gamma) 将灰度图像 I 中的灰度值映射成输出图像 J 中的新值，使得 low_in 和 high_in 之间的值映射成 low_out 和 high_out 之间的值。 low_in，high_in，low_out，high_out 的值必须在 0 到 1 之间。 低于 low_in 的值和高于 high_in 的值被去除，也就是说，低于 low_in 的值映射成 low_out，高于 high_in 的值映射成 high_out。 你可以用一个空矩阵 [] 来替代 [low_in; high_in] 或者 [low_out; high_out]，这样就默认为 [0 1]。 参数 gamma 指定了曲线的形状，该曲线用来映射 I 的亮度值。如果 gamma 小于 1，映射被加权到更高的输出值。如果 gamma 大于 1，映射被加权到更低的输出值。如果省略了函数的参量，则 gamma 默认为 1（线性映射）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/:1:2","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/"},{"categories":null,"content":"类型支持 对于包含输入图像（而不是色彩表）的语法变体，输入图像的类型可以是 uint8, uint16, int16, single 和 double，输出图像的类型与输入图像相同。对于包含色彩表的语法变体，输入和输出色彩表的类型都是 double。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/:1:3","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/"},{"categories":null,"content":"medfilt2 在 matlab 中，medfilt2 函数用于执行二维中值滤波，使用方法如下： B = medfilt2(A, [m n]) // 其中[m n]表示邻域块的大小，默认值为[3 3]。 B = medfilt2(A) B = medfilt2(A, ’indexed’, ...) ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter3/"},{"categories":null,"content":"第四章 不会有区别。因为无论哪种填充方式，都能同样地分离图像 上述的操作中，“取该变换的复共轭” 一步，将傅里叶变换中的 j 改为了 -j，从而将原图函数 f(x, y) 转换为 f(-x, -y)，造成图像的镜面翻转 如果只进行了高通操作，戒指会有一个黑暗的中心。但是这个黑暗的中心区域被低通滤波器平均化了。 戒指中心明亮的原因是，环状物边界上的不连续边缘比图像中其他地方高得多 不会，因为傅里叶变换进行滤波是一个线性过程。 (a) 是的，图像不会发生变化。存在一个 K 值，使图像中所有像素灰度值的平均值为 0。 (b) 中值滤波以消除孤立亮点 高通滤波以增强对比度 直方图均衡 计算平均灰度为 V~0~，再对于所有像素加上 (V-V~0~) 灰度 对所有像素执行以下函数： ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter4/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter4/"},{"categories":null,"content":"第六章 rgb2hsv，hsv2rgb 两函数完成了图像在 RGB 颜色空间和 HSV 颜色空间的互相转换 HSV 的定义与 HSI 类似，只是 V（亮度）是 RGB 中的最大值 max(max(r,g),b)，I （强度）指 RGB 的平均值 (r+g+b) / 3。函数严格遵循以下公式： 6-3 可以得出，落在边上的颜色坐标取决于边的两个顶点代表的颜色和两个顶点到此点的长度之比，而第三个点对于此点的没有影响。 如图，$\\frac{p_1}{p_2}=\\frac{c_1c_0}{c_2c_0}$，$p_1+p_2=100-p_3$，对于 $c_1$ 和 $c_2$ 亦如是，即可得出三个颜色在新颜色上的占比 $p_1, p_2, p_3$ 6-5 $$ \\frac{1}{2}R+\\frac{1}{2}B+G=midgray+\\frac{1}{2}G $$ 图像颜色为纯绿色加上中灰色，显示一个亮度更亮的绿色。 6-14 （a）8bit 图像的色调最多只能被分为 255 个值；又因为色调在 0°-360° 的范围内，故 8bit 图像中，每一级色调的增量为 360/255，也就是说，[0,360] 的色调范围被压缩到了 [0, 255]。 黄色 60°，灰度值为 43 绿色 120°，灰度值为 85 可得另外两个区域的灰度值为 170 和 213，中间的纯白色区域为 0，黑色背景则为 255 （b）圆圈区域饱完全饱和，灰度值为 255；中心区域是白色的，灰度值为 0 （c）中心区域白色，灰度值为 255；红色、蓝色、绿色的亮度是相等的；故浅灰色部分为 170，深灰色部分为 85 6-25 （a）因为图像完全饱和，所以图像 S 恒为 1；所有方块的亮度 I 均为 1/3；H：故红色部分最灰，绿色部分次灰，蓝色部分灰色最浅。 （c）在方块内部，颜色恒定不变，在方块边界的值将介于几个方快之间，并取决于模板中不同颜色方块所占的比例。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter6/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter6/"},{"categories":null,"content":"第八章 (a) 直方图均衡过后，每个灰度级概率趋于相等，使用变长编码毫无优势。 (b) 直方图均衡后，像素点之间仍然存在空间相关性，所以有空间冗余；同时也允许包含时间冗余。 (a) $C=\\frac{8}{5.3}=1.509$ (b) 不能 (c) 在哈夫曼编码之前消除图像中的空间冗余 a3a6a6a2a5a2a2a2a4 1.544 Mbps 的传输率在 6s 内可以传输 $$ (1.544\\times 10^6)\\times 6=9.264\\times 10^6 $$ 比特信息，所以可得压缩比为 $$ C=\\frac{4096\\times 4096\\times 12}{9.264\\times 10^6}=21.73 $$ JPEG 变换编码可以实现此压缩。 要在 5-6s 内做一次细化，1min 内完成，相当于要做 10-12 次细化。不妨假设做 12 次细化，每次细化针对 12bit 其一，那每个比特的压缩率为 $$ C=\\frac{4096\\times 4096\\times 1}{9.264\\times 10^6}=1.81 $$ 压缩比必须小于 2。 为了体验每幅图像之间的差异，可以在压缩图像每个像素每个比特位置与原始图像进行异或操作，值为 1 则代表此比特位置与原始值不同。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter8/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/homework/chapter8/"},{"categories":null,"content":"题目 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第1讲 概述 1.一帧视频图像由640*400个像素组成，其灰度级如果用8bit的二进制数表示，那么一帧视频的数据量为多少（2048000bit）。 2.数字图像处理相对于模拟图像处理的优点有（A.精度高B.再现性好D.通用性好）。 3.数字图像处理的特点有（A.处理信息量大B.占用频带较宽C.像素相关性大D.处理的效果评价受人的主观影响较大）。 4.以下方面属于数字图像处理的应用有（B.人脸识别C.视频监控D.智能机器人）。 5.本课程研究的图像是二维的，是三维景物在二维平面上的投影（正确）。 6.图像占用的带宽与语音占用的带宽大小相当，属于相同数量级（错误）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:1:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第2讲 数字图像处理的基础 1.已知某个像素点P的坐标为（25，10），则其4邻域包含如下像素【A.（24，10）C.（26，10）D.（25，9）】。 2.已知某个像素点P的坐标为（25，10），则其对角邻域包含如下像素【B.（24，9）C.（26，9）D.（24，11）】。 3.已知图像上的2个像素p，q的坐标分别为（26，15）和（20，23），则p和q之间城市街区距离为（14）。 4.已知图像上的2个像素p，q的坐标分别为（26，15）和（20，23），则p和q之间欧式距离为（10）。 5.已知图像上的2个像素p，q的坐标分别为（26，15）和（20，23），则p和q之间棋盘距离为（8）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:2:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第3讲 图像基本运算 1.In a linear stretching transformation ( s=ar+b ),when a and b take any value,can be gray value respectively from 24 and 156 to 15 and 213（a=1.5, b=-21）。 2.在灰度线性变换 s=ar+b 中，要使输出图像对比度增大，则（a\u003e1）。 3.采用幂次变换进行灰度变换时，当幂次取小于1时，该变换可以改善如下哪一类图像（图像整体偏暗）。 4.下列哪种运算不是几何运算（灰度变换）。 5.关于图像缩小处理，下列说法正确的是（图像的缩小是从原始图像中选择合适的像素点，使图像缩小后可以尽量保持原有图像的概貌特征不丢失）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:3:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第4讲 图像变换 1.The 2-D DFT can be computed by computing 1-D DFT transforms along the rows of the image, followed by 1-D transforms along the columns of the result. （正确）。 2.The Fourier transform of a real function is conjugate symmetric, which implies that the spectrum has even symmetry about the origin.（正确）。 3.傅里叶频谱的低频主要反映图像的边缘和噪声等细节（错误）。 4.傅里叶频谱的高频主要反映图像平坦区域中灰度的总体分布（错误）。 5.根据傅里叶变换的周期性，只需一个周期的变换就可以获得整个变换的频谱（正确）。 6.根据傅里叶变换的共轭对称性，只需半个周期的变换就可以获得整个变换的频谱（正确）。 7.功率谱定义为频谱的平方，反映了离散信号的能量在频率域上的分布情况（正确）。 8.DCT是正交变换，但不是可分离变换（错误）。 9.对图像进行DCT变换，可以去除图像中像素间的相关性（正确）。 10.图像经过DCT变换后，将得到一个非实数的复数矩阵（错误）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:4:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第5讲 图像增强 1.图像与灰度直方图间的对应关系是（多对一）。 2.关于图像平滑下面说法正确的是（A.图像平滑可以采用空间邻域均值滤波方法或者频率域低通滤波方法B.图像平滑的主要目的是消除图像中的噪声C.图像空间平滑效果与采用的平滑模板大小相关，模板越大，平滑后的图像越模糊D.由于空间平滑算子采用邻域平均方法，故该类算子具有的特点是包含一个其分母值等于算子中各元素值之和的分数系数）。 3.关于图像锐化下面说法正确的是（A.空间锐化滤波运算是同时对图像中的某一邻域的多个像素进行运算处理B.空间域锐化算子具有特点是算子中各元素值之和应为0；D.图像锐化可以采用频率域高通滤波方法）。 4.f(x,y)=[ f(0,0) f(0,1) f(0,2) f(0,3) ​ f(1,0) f(1,1) f(1,2) f(1,3) ​ f(2,0) f(2,1) f(2,2) f(2,3) ​ f(3,0) f(3,1) f(3,2) f(3,3) ] ​ = [ 1 3 2 4 ​ 5 9 6 5 ​ 4 3 4 7 ​ 10 5 8 5 ] 已知图像块如上图所示，则用3*3均值模板对图像进行平滑时，得到f(2,1)的灰度值是（6）。 5.关于巴特沃思低通滤波器（BLPF），实践应用中，下列说法正确的是（一般选择2阶，2阶BLPF是在有效的低通滤波和可接受的振铃特性之间的折中）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:5:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第7讲 图像压缩编码 1.如果一个图像的灰度级编码所需要的比特数大于理论上表示该图像所需要的最小比特数，就称图像中包含了（信息熵冗余）。 2.无失真编码定理确定的是（每个信源符号的最小平均码字长度）。 3.有损预测编码引起的信息失真是由下列哪个部分产生的（量化器）。 4.对于1个大小为10*10具有4个灰度级的图像块，经过统计，这4个灰度级{0，1，2，3}在图像块中出现的次数依次是{35，30，25，10}，不通过编码计算，判断进行霍夫曼编码后对应码字最长的灰度级是（3）。 5.下列因素中与客观保真度有关的是（输入图与输出图之间的均方根误差）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:6:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第8讲 图像分割 1.图像分割可以依据图像的灰度、颜色、纹理等特性来进行（正确）。 2.图像微分增强了边缘和其他突变的信息（正确）。 3.边缘检测与连接法分割图像是利用图像灰度的不连续性性质（正确）。 4.区域生长方法中选取的种子点只能是单个像素（错误）。 5.在使用区域合并分裂方法进行图像分割时，不需要用到每个子块的属性（错误）。 6.对二值图像进行标记处理是对二值图像的每个不同的连通域进行不同的编号，来区分不同的连通域（正确）。 7.形态学处理中最基本的运算是腐蚀与膨胀。其中，膨胀通常在去除小颗粒以及消除目标物之间的粘连是非常有效的（错误）。 8.形态学处理中最基本的运算是腐蚀与膨胀。其中，腐蚀通常用以填补目标物中存在的某些空洞（错误）。 9.开运算是用结构元素对二值图像先膨胀在腐蚀（错误）。 10.阈值分割法分割图像是基于图像灰度的相似性性质（正确）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:7:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第9讲 彩色图像处理 1.在减色混色模型中，白色-红色=黄色（错误）。 2.在加色混色模型中，红色+绿色=青色（错误）。 3.在RGB空间中，若某个像素点的值是（0，255，0），则表示该颜色为蓝色（错误）。 4.在RGB空间中，若某个像素点的值是（0，0，0），则表示该颜色为白色（错误）。 5.最接近人类视觉特性的彩色空间是HSI颜色空间（正确）。 6.The term full-color image is used often to denote a 24-bit RGB color image（正确）。 7.In the CMYK color model, C means cyan, M means magenta, Y means yellow, K means black（正确）。 8.根据需要设计一个颜色表，进而将灰度值作为颜色表的索引值完成从灰度到彩色的映射。这种伪方法称为基于灰度颜色表的伪彩色方法（正确）。 9.由彩色向量梯度计算得到的图像边缘一般比由3个分量图像计算得到边缘合成的效果要好（正确）。 10.RGB彩色图像的锐化可以对彩色图像的三个分量图像分别进行锐化处理得到（正确）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:8:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"第10讲 图像表示与描述 1.区域特征主要有（A.区域面积B.位置和方向C.周长D.长轴和短轴）。 2.四方向链码03000032321212111的归一化链码是（00003232121211103）。 3.八方向链码07000065653434222的一阶差分码是（67100067176171600）。 4.常用的形状描述有（A.矩形度B.圆形度C.偏心度）。 5.常用的边界表达形式有（B.链码C.多边形近似D.标记图）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:9:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"网上期末考试客观试卷部分1 1.数字图像是指（空间坐标离散变化，颜色或灰度离散变化）。 2.关于韦伯比，下列说法错误的是（韦伯比越大，亮度分辨率能力越好）。 3.对一幅对比度小且整体偏暗的图像进行线性变换时，a，b的取值应为（a\u003e1, b\u003e0）。 4.关于无损预测编码和有损预测编码，下列说法错误的是（无损预测编码需要量化器）。 5.灰度对数变换可以（拉伸低灰度区，压缩高灰度区）。 6.对被随机噪声污染的图像，要消减噪声，通常采用如下代数运算方法（加法求平均）。 7.关于图像的DFT频谱，说法错误的是（低频反映图像的边缘和噪声）。 8.对具有同一背景和目标，但成像效果不同的图像进行直方图均衡化处理，下列说法正确的是（对不同条件下图像直方图均衡化效果一样）。 9.在利用Butterworth滤波器对图像进行滤波时，一般选用2阶，其理由是（二阶Butterworth滤波器只有轻微的振铃现象和希望的滤波性能）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:10:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"网上期末考试客观试卷部分2 10.关于RGB颜色模型，以下说法不正确的是的（RGB颜色模型是减色系统）。 11.像素点(15, 10)与(9, 18)之间的城市街区距离为（14）。 12.在具有64级的灰度图像中，白色像素点的灰度级为（63）。 13.一幅200*300的具有16个灰度级的图像需要存储的字节数为（30000）。 14.用一个线性变换s=ar+b，使灰度值分别从15和150变换为45和315，则a为（2）。 15.闭运算是使用同一个结构元素对图像先（膨胀）再进行腐蚀的运算。 16.对被“盐粉”噪声污染的图像进行复原，采用逆谐波滤波器复原，应选Q的符号为（负）。 17.在图像复原中，为了得到好的滤波效果，需要计算噪声的功率谱和图像的功率谱，这样的滤波器是（维纳）滤波器。 18.在加色混色系统中，由三种基色红色、绿色、蓝色进行两两相加产生三种二次色分别是品红色、黄色和（青色）。 19.在频率域图像增强中，平滑滤波器的传递函数与其对应的锐化滤波器的传递函数之和应为（1）。 20.设一幅图像有5个灰度级{0，1，2，3，4}，经过统计这5个灰度级出现的概率分别为{1/8，1/8，1/8，1/2，1/8}，则该图像的熵为（bit/灰度级）（2）。 21.图像的压缩编码方法分为无失真压缩编码和有限失真压缩编码（正确）。 22.人的视觉系统能够适应的光强度级别范围是很宽的，但是与整个适应范围相比，能同时鉴别的光强度级的总范围很小（正确）。 23.图像分割算法基于灰度的两个性质：连续性和相似性（错误）。 24.在图像处理系统中，输入的是图像，输出的也是图像（正确）。 25.当图像的灰度级数降低时，图像中会出现伪轮廓信息（正确）。 26.人眼的视网膜上存在大量能在适当亮度下分辨颜色的杆状细胞（错误）。 27.对图像进行傅里叶变换可以将空间域复杂的卷积运算转化为频率域中简单的乘积运算（正确）。 28.区域分裂合并法通常需要人工交互以获得种子点（错误）。 29.功率谱定义为频谱的平方，反映离散信号的能量在频率域上的分布情况（正确）。 30.低通滤波法是使高频成分受到抑制而让低频成分顺利通过，从而实现图像平滑（正确）。 31.二值图像的欧拉数是连接成分数与孔数之差（正确）。 32.二维DCT的正反变换核相同（正确）。 33.图像变换，是指将图像信号从空间域变换到另外的域上进行分析的手段（正确）。 34.形状数对每阶都是唯一的，不随边界的旋转和尺度的变化而改变（正确）。 35.常用于彩色打印机的颜色模型是RGB模型（正确）。 36.空间滤波增强是一种利用模板或掩模，对图像像素点的邻域进行处理的运算 （正确）。 37.灰度共生矩阵可用于分析图像的局部特征以及纹理的分布规律（正确）。 38.一般而言，逆滤波对图像复原的效果好于维纳滤波（错误）。 39.图像增强和图像复原都需要知道图像退化的机制和过程等先验知识（错误）。 40.由运动造成的图像模糊可以通过图像增强方法进行处理恢复（错误）。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/:11:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%A2%98%E7%9B%AE/"},{"categories":null,"content":"作业一 编译概述 19120198 孙天野 解释下列术语 编译程序：把用高级程序设计语言书写的源程序，翻译成等价的机器语言格式目标程序的翻译程序 源程序：使用源语言编写的程序 目标程序：是源程序经编译可直接被计算机运行的机器码集合，在计算机文件上以 .obj 作扩展名。 前端：主要依赖于源语言而与目标机无关，包括词法分析、语法分析、语义分析、中间代码生成这些阶段，以及相关的出错处理工作、符号表管理工作 后端：依赖于目标机而一般不依赖于源语言，只与中间代码有关的工作，包括目标代码生成，及其相关的出错处理工作、符号表管理工作 遍：一个编译过程可由一遍、两遍、或多遍完成。 编译程序的主要构成成分，及其主要功能： 词法分析：从左到右一个字符一个字符地读入源程序，对构成源程序的字符流进行扫描和分解，从而识别出一个个符号 语法分析：在词法分析的基础上将单词序列分解成各类语法短语。 语义分析：审查源程序有误语义错误，为代码生成阶段搜集类型信息。 中间代码生成：一种结构简单、含义明确的记号系统。 代码优化：对前一阶段产生的中间代码进行变换或进行改造，使生成的目标代码更为高效，即省时间和省空间。 目标代码生成：把中间打吗变换成特定机器上的绝对值零代码或可重定位的指令代码或汇编指令代码。 表格管理程序：记录源程序中使用的名字，收集每个名字的各种属性信息，如类型、作用域、分配存储信息。 出错处理程序：检查错误、报告出错信息、排错、恢复编译工作。 什么是解释程序？它与编译程序的主要不同是什么？ 解释程序接受某个语言的程序并立即运行这个源程序。 它与编译程序的区别： 对于编译程序，它把高级语言程序翻译成某个机器的汇编语言程序或二进制代码程序，这个二进制代码程序在机器上运行以生成结果。编译和运行的、是两个独立分开的阶段。 对于解释程序，它不需要在运行前先把源程序翻译成目标程序，也可以实现在某台机器上运行程序并生成结果。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/chapter1/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/chapter1/"},{"categories":null,"content":"作业二 文法与语言 19120198 孙天野 全部元素：{abc} 全体非负整数 $$ G(E)=E=E+T=E+T*F $$ 故 $E+T*F$ 是它的一个右句型 短语：$E+T*F$ 直接短语：$T*F$ 句柄：$T*F$ 允许 0 打头 $$ \\begin{flalign} \u0026\\ G(S) \\ \u0026\\ S \\rightarrow C|AC \\ \u0026\\ C \\rightarrow B|AB \\ \u0026\\ A \\rightarrow 0|1|2|3|4|5|6|7|8|9 \\ \u0026\\ B \\rightarrow 0|2|4|6|8 \\end{flalign} $$ 不允许 0 打头 $$ \\begin{flalign} \u0026\\ G(S) \\ \u0026\\ S \\rightarrow 0|C|AC \\ \u0026\\ C \\rightarrow B|AB \\ \u0026\\ A \\rightarrow 1|2|3|4|5|6|7|8|9 \\ \u0026\\ B \\rightarrow 2|4|6|8 \\end{flalign} $$ ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/chapter2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/chapter2/"},{"categories":null,"content":"作业三 词法分析 19120198 孙天野 划分成两个子集 $P_1={A,D,E},P_2={B,C,F}$ 区分 $P_2$：$P_{21}={C,F},P_{22}={B}$ 区分 $P_1$：$P_{11}={A,E},P_{22}={D}$ $A,E$ 可区分 $P={{A},{B},{D},{E},{C,F}}$ $I$ $I_a$ $I_b$ A[S] B[Q,V] C[Q,U] B[Q,V] D[V,Z] C[Q,U] C[Q,U] E[V] F[Q,U,Z] D[V,Z] G[Z] G[Z] (a) 先用子集法转换为 DFA $I$ $I_a$ $I_b$ A[0] B[0,1] C[1] B[0,1] B[0,1] C[1] C[1] A[0] (b) 已是 DFA 划分成两个子集 $P_1={0},P_2={1,2,3,4,5}$ 区分 $P_2$：$P_{21}={4},P_{22}={1,2,3,5}$ 区分 $P_{22}$：$P_{221}={1,5},P_{222}={2,3}$ 区分 $P_{221}$：$P_{2211}={1},P_{2212}={5}$ 区分 $P_{222}$：$P_{2221}={2},P_{2222}={3}$ $P={{0},{1,5},{2},{3},{4}}$ 正规式：$(0|(10))^*$ 正规文法： $$ \\begin{flalign} \u0026\\ G(A) \\ \u0026\\ A \\rightarrow 1C|0A|\\epsilon \\ \u0026\\ C \\rightarrow 0A \\ \\end{flalign} $$ $S=01S|10S|01|10=(01|10)S|(01|10)=(01|10)^*$ 所以正规式为 $(01|10)$ ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/chapter3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/chapter3/"},{"categories":null,"content":"ex2 https://stackoverflow.com/questions/35931736/mpich-cluster-test-error-unable-to-change-wdir 安装 ssh 客户端 sudo apt-get install openssh-server 安装 mpich sudo apt-get install mpich 实现 ssh 无密登录：https://blog.csdn.net/weixin_33725126/article/details/91726998 多节点测试用例 /* * Copyright (C) by Argonne National Laboratory * See COPYRIGHT in top-level directory */ #include \"mpi.h\"#include \u003cstdio.h\u003e#include \u003cmath.h\u003e double f(double); double f(double a) { return (4.0 / (1.0 + a * a)); } int main(int argc, char *argv[]) { int n, myid, numprocs, i; double PI25DT = 3.141592653589793238462643; double mypi, pi, h, sum, x; double startwtime = 0.0, endwtime; int namelen; char processor_name[MPI_MAX_PROCESSOR_NAME]; MPI_Init(\u0026argc, \u0026argv); MPI_Comm_size(MPI_COMM_WORLD, \u0026numprocs); MPI_Comm_rank(MPI_COMM_WORLD, \u0026myid); MPI_Get_processor_name(processor_name, \u0026namelen); fprintf(stdout, \"Process %d of %d is on %s\\n\", myid, numprocs, processor_name); fflush(stdout); n = 10000; /* default # of rectangles */ if (myid == 0) startwtime = MPI_Wtime(); MPI_Bcast(\u0026n, 1, MPI_INT, 0, MPI_COMM_WORLD); h = 1.0 / (double) n; sum = 0.0; /* A slightly better approach starts from large i and works back */ for (i = myid + 1; i \u003c= n; i += numprocs) { x = h * ((double) i - 0.5); sum += f(x); } mypi = h * sum; MPI_Reduce(\u0026mypi, \u0026pi, 1, MPI_DOUBLE, MPI_SUM, 0, MPI_COMM_WORLD); if (myid == 0) { endwtime = MPI_Wtime(); printf(\"pi is approximately %.16f, Error is %.16f\\n\", pi, fabs(pi - PI25DT)); printf(\"wall clock time = %f\\n\", endwtime - startwtime); fflush(stdout); } MPI_Finalize(); return 0; } 编译 mpicxx -g -Wall -o mpi_hello.o mpi_hello.cpp 将编译文件通过 rcp 传递给其他主机 rcp mpi_hello.o melon@192.168.163.129:~/src rcp mpi_hello.o melon@192.168.163.130:~/src 运行多节点 mpirun --machinefile ./hostlist -np 6 ./mpi_hello.o 运行单节点 mpirun -np 6 ./mpi_hello.o #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cmath.h\u003e#include \u003ctime.h\u003e#include \u003cmpi.h\u003e void read_num(long long int *num_point,int my_rank,MPI_Comm comm); void compute_pi(long long int num_point,long long int* num_in_cycle,long long int* local_num_point,int comm_sz,long long int *total_num_in_cycle,MPI_Comm comm,int my_rank); int main(int argc,char** argv){ long long int num_in_cycle,num_point,total_num_in_cycle,local_num_point; int my_rank,comm_sz; double begin,end; MPI_Comm comm; MPI_Init(NULL,NULL);//初始化 comm=MPI_COMM_WORLD; MPI_Comm_size(comm,\u0026comm_sz);// 得到进程总数 MPI_Comm_rank(comm,\u0026my_rank);// 得到进程编号 read_num(\u0026num_point,my_rank,comm);// 读取输入数据 begin=MPI_Wtime(); compute_pi(num_point,\u0026num_in_cycle,\u0026local_num_point,comm_sz,\u0026total_num_in_cycle,comm,my_rank); end=MPI_Wtime(); if(my_rank==0){ printf(\"Elapsing time: %fs\\n\",end-begin); } MPI_Finalize(); return 0; } void read_num(long long int* num_point,int my_rank,MPI_Comm comm){ if(my_rank==0){ printf(\"请输入正方形中的点数 \\n\"); scanf(\"%lld\",num_point); } MPI_Bcast(num_point,1,MPI_LONG_LONG,0,comm); // 将num_point广播给各个进程 } void compute_pi(long long int num_point,long long int* num_in_cycle,long long int* local_num_point,int comm_sz,long long int *total_num_in_cycle,MPI_Comm comm,int my_rank){ *num_in_cycle=0; *local_num_point=num_point/comm_sz; double x,y,distance_squared; srand(time(NULL)); for(long long int i=0;i\u003c *local_num_point;i++){ x=(double)rand()/(double)RAND_MAX; x=x*2-1; y=(double)rand()/(double)RAND_MAX; y=y*2-1; distance_squared=x*x+y*y; if(distance_squared\u003c=1) *num_in_cycle=*num_in_cycle+1; } // 求出 num_in_cycle 总和 MPI_Reduce(num_in_cycle,total_num_in_cycle,1,MPI_LONG_LONG,MPI_SUM,0,comm); if(my_rank==0){ double pi=(double)*total_num_in_cycle/(double)num_point*4; printf(\"最终pi的值为 %lf\\n\",pi); } } ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/ex2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/ex2/"},{"categories":null,"content":"ex3 实验目的： ​ 理解并掌握程序性能分析与优化方法 实验任务： ​ 选择你喜欢的编程语言写的源程序（不限于自己编写），用合适的性能分析工具（performance profiler），分析此程序的性能瓶颈、发现此程序的缺陷，回答下列问题： 你的实验环境配置，性能分析工具及其获取方式 优化前、后，程序中各部分（各函数）运行时间占比 优化前、后，程序的内存使用情况，是否有内存泄漏？ 列出你能实现的所有优化措施，并作解释 上述答案，不要使用附件形式。 注：根据你所选的程序的特点，可以把运行时间、内存使用这2个性能指标换成其它指标，例如并发数、响应时间等等。 ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/ex3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/ex3/"},{"categories":null,"content":"https://dev.to/excceedd/how-to-solve-coding-issues-in-four-easy-steps-3j5g This article tells about how to solve coding problems in a four-steps way. It really helps me because problem solving is an important indicator in a job interview. Recognize the issue. Although job interview won’t give you much time to think, you still need to fully understand the issue before solving. Make a strategy. Strategy is a kind of plan before coding. There are several ways to design a strategy. Pseudo-code seems a good choice for me. “consider systematically how a human solves the problem.” this principle helps me a lot. Execute the plan. This is a core part of solving, the step needs you to write actual code. The author offers a useful skill: Ignore the difficult part of the problem that you don’t understand for the time being and write out the other parts. Take a look back. Examining your code is a essential step. You should consider all situations, especially some border conditions. ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/1/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/1/"},{"categories":null,"content":"1 https://dev.to/excceedd/how-to-solve-coding-issues-in-four-easy-steps-3j5g This article tells about how to solve coding problems in a four-steps way. It really helps me because problem solving is an important indicator in a job interview. Recognize the issue. Although job interview won’t give you much time to think, you still need to fully understand the issue before solving. Make a strategy. Strategy is a kind of plan before coding. There are several ways to design a strategy. Pseudo-code seems a good choice for me. “consider systematically how a human solves the problem.” this principle helps me a lot. Execute the plan. This is a core part of solving, the step needs you to write actual code. The author offers a useful skill: Ignore the difficult part of the problem that you don’t understand for the time being and write out the other parts. Take a look back. Examining your code is a essential step. You should consider all situations, especially some border conditions. 2 https://dev.to/latobibor/should-we-have-test-managers-again-mkf This article argues about whether we should have test engineer. Compare to a bunch of manual testers, the author prefer a professional testing team. A test automation engineer will dedicating his/her time to what to test, how to test effectively and when to avoid writing expensive or weak test suites. This makes test unit more powerful and robust. Tested by who developed is a bad idea, according to the article. The closer testers are to the actual creator of the code, the less likely they will find a bug. And developer will not have much time to learn a series of professional testing methods. More over, they even ghosting responsibilities when it comes to multiple teams testing together. 3 https://dev.to/fastcodeinc/low-code-platforms-full-code-developers-a-match-made-in-hell-32ie Low-code development has been a hot trend in recent years. But it is controversial at the same time. This article mainly discuss what are the disadvantage of low-code platform. Low-code mode actually provides a visual platform to build your application, it’s like a toy: strong in building little project, weak in writing a large app. And how to test it has become a bottleneck for its future. The article also tells that low-code platform will limits career mobility. Different company have different low-code solutions, it’s really hard to reuse, and the traditional technical skills in open programming languages and frameworks will disappear gradually. However, a low-code platform especially built for professional developers is a better idea, it will eliminates the disadvantages of proprietary low-code platforms. 4 https://dev.to/anthonyjdella/why-you-should-use-a-developer-font-2gio The most important feature of a program developer is a editor that has a cool style. We look at codes all day long, so font of codes is often overlooked but vital for the coding experience. This article emphasizes the importance of code fonts. A good code font will help you find typos, variables and functions quickly. Code highlighting makes developers more efficient. Companies which design IDE usually have their own code font. For example, Jetbrains Mono. It has a higher height, makes code easier to recognize. And it has some useful ligatures to identify special characters (though I don’t really like it). Each character is distinct, 1, l and I is easy to read, while they look the same with a lot of standard fonts. 5 https://dev.to/ben/what-are-your-tips-for-an-effective-developer-resume-ep4 This is not a traditional article, it’s like a discussion in forums. Many developers left their wise advise in this posting. The subject is What are your tips for an effective developer resumé. It helps me a lot because I happen to be looking for an internship as well. Here are some suggestions that I have benefited from. Don’t list every technology you have ever done “hello world” in. Just list the knowledge and skills that you are really good at and that","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/19120198-%E5%AD%99%E5%A4%A9%E9%87%8E-%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E8%8B%B1%E8%AF%AD%E4%BD%9C%E4%B8%9A1000/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/19120198-%E5%AD%99%E5%A4%A9%E9%87%8E-%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E8%8B%B1%E8%AF%AD%E4%BD%9C%E4%B8%9A1000/"},{"categories":null,"content":"https://dev.to/latobibor/should-we-have-test-managers-again-mkf This article argues about whether we should have test engineer. Compare to a bunch of manual testers, the author prefer a professional testing team. A test automation engineer will dedicating his/her time to what to test, how to test effectively and when to avoid writing expensive or weak test suites. This makes test unit more powerful and robust. Tested by who developed is a bad idea, according to the article. The closer testers are to the actual creator of the code, the less likely they will find a bug. And developer will not have much time to learn a series of professional testing methods. More over, they even ghosting responsibilities when it comes to multiple teams testing together. ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/2/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/2/"},{"categories":null,"content":"https://dev.to/fastcodeinc/low-code-platforms-full-code-developers-a-match-made-in-hell-32ie Low-code development has been a hot trend in recent years. But it is controversial at the same time. This article mainly discuss what are the disadvantage of low-code platform. Low-code mode actually provides a visual platform to build your application, it’s like a toy: strong in building little project, weak in writing a large app. And how to test it has become a bottleneck for its future. The article also tells that low-code platform will limits career mobility. Different company have different low-code solutions, it’s really hard to reuse, and the traditional technical skills in open programming languages and frameworks will disappear gradually. However, a low-code platform especially built for professional developers is a better idea, it will eliminates the disadvantages of proprietary low-code platforms. ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/3/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/3/"},{"categories":null,"content":"https://dev.to/anthonyjdella/why-you-should-use-a-developer-font-2gio The most important feature of a program developer is a editor that has a cool style. We look at codes all day long, so font of codes is often overlooked but vital for the coding experience. This article emphasizes the importance of code fonts. A good code font will help you find typos, variables and functions quickly. Code highlighting makes developers more efficient. Companies which design IDE usually have their own code font. For example, Jetbrains Mono. It has a higher height, makes code easier to recognize. And it has some useful ligatures to identify special characters (though I don’t really like it). Each character is distinct, 1, l and I is easy to read, while they look the same with a lot of standard fonts. ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/4/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/4/"},{"categories":null,"content":"https://dev.to/ben/what-are-your-tips-for-an-effective-developer-resume-ep4 This is not a traditional article, it’s like a discussion in forums. Many developers left their wise advise in this posting. The subject is What are your tips for an effective developer resumé. It helps me a lot because I happen to be looking for an internship as well. Here are some suggestions that I have benefited from. Don’t list every technology you have ever done “hello world” in. Just list the knowledge and skills that you are really good at and that fit the target position. You will never be expert of every field. Make sure to link to your socials. Especially GitHub, this is the perfect platform to showcase yourself. Try and showcase how well you will perform in a team. Try to tailor the descriptions of your project experience to match the job you are applying for. ","date":"0001-01-01","objectID":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/5/:0:0","tags":null,"title":"","uri":"/Notes/posts/homework/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/5/"},{"categories":null,"content":"巧巧红妆花间客，朵朵轻云芳柔甚 片月风流夜搅衣，风雨归去空留恨 愿莫效此薄情郎，伤心万尺倾国色 少小臣嗣玉金环，暇时万把腰千缠 缠得非金却何是？罗红绮蓝葱头簪 碧眼丹容含春意，多情自小现端倪 不喜舞剑喜柳面，不爱经籍爱芳仪 锦缎丝袍穿巷井，璎珞摇鸣逐娇影 借齿伶俐讨巧笑，凭笔生花画蛾螓 拥衾兰语如梦令，阁床狂酒醉花阴 好晴悠游江城子，云黑卧看雨霖铃 Ver1 聪明的红花化妆盛开的软云 浪漫的月夜摇摆着衣裳，风雨归来，恨意在身后。 我希望你充满悲伤，不要模仿这个瘦弱的情人 年轻大臣继承金戒指 但它是什么？罗红旗葱花簪 蓝眼睛的子弹代表春天，感伤的线索来自童年。 不喜欢剑舞柳面，不喜欢经书爱芳仪 锦织的丝袍穿过小巷，璎珞尖叫着追着那人影。 用你的牙齿微笑，用笔画花和飞蛾。 被窝里的对话如梦，床醉醉醺醺 玉江城子好，云淡风轻，可以看到玉林岭 Ver2 花儿很美，有红饰，有明云，有云彩 夜里，风、光波和他的衣服跟着风雨增加 希望不要跟着瘦子的理想走 年轻的牧师找到了金戒指。 但这罗那古青葱发烫到底是什么东西？ 蓝色沙漏看起来像春天他年轻时就表现出愤怒 我不喜欢跳舞，但阿富汗书里的婚姻 英拉的车掉进了阴影里。 用你美丽的微笑牙齿，把它们放在花或月亮铅笔上 有失眠、失眠、酗酒等作用 安昌昌喜欢在乌云中陪他走 她的行为激怒了辛哈，羞辱了她的家人，使她成为了一个好领导 病毒蔓延到了胡成的梦墙，所有的烟雾都消失了。 最近，由强大的约翰王带领的精神开始了 好没有坏马保险 然而，即墨遇到一个年轻人就睡不着觉 纸鱼缓慢移动，查纳的风不像月亮 学校的乐趣，老鼠的乐趣，问和冲刺的练习 回家前症状略有缓解 “他把妻子留在家里，爱上了她两年。当时，敏明住在一个红色的六角形区域。” ","date":"0001-01-01","objectID":"/Notes/posts/poetry/%E8%B0%B7%E6%AD%8C%E7%9A%84%E8%AF%97/%E5%B7%A7%E5%B7%A7%E7%BA%A2%E5%A6%86%E8%8A%B1%E9%97%B4%E5%AE%A2/:0:0","tags":null,"title":"","uri":"/Notes/posts/poetry/%E8%B0%B7%E6%AD%8C%E7%9A%84%E8%AF%97/%E5%B7%A7%E5%B7%A7%E7%BA%A2%E5%A6%86%E8%8A%B1%E9%97%B4%E5%AE%A2/"},{"categories":null,"content":"认识 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"窗口 Windows 窗口用于保存控件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"创建方法 由 add_window() 方法启动窗口并在结束调 end() 方法 使用 dearpygui.simple 包和相应的窗口管理器（推荐） # method 1 from dearpygui.core import * add_window(\"Tutorial\") add_text(\"This is some text on window 1\") end() # method 2 from dearpygui.simple import * with window(\"Tutorial##2\"): add_text(\"This is some text on window 2\") start_dearpygui() 代码最终必须以 start_dearpygui() 方法结束 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:1:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"主窗口 如何设置主窗口？ 使用 start_dearpygui 方法的 primary_window 参数 使用 set_primary_window 方法 start_dearpygui(primary_window=\"Tutorial\") ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:1:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"全局设置 add_additional_font('三极中柔宋.ttf', 18, glyph_ranges='chinese_simplified_common') ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:1:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"控件 Widgets 控件必须有一个唯一的 name，默认情况下，name 会被当成 label 使用（视具体控件而定） 如何改变 label 使用 ## 进行字符拼接，左边的字符串为要显示的名称，右边则为隐藏名称 通过设置 label 参数的值，显式设置要显示的名称 # Display 'Apply' add_button(\"Apply##1\") add_button(\"Apply2\", label=\"Apply\") ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"值 value 每个输入窗口控件都有一个 value 可以在创建时使用 default_value 参数设置 可以在运行时通过 set_value 方法进行设置。 可以使用 get_value 方法访问控件的 value from dearpygui.core import * from dearpygui.simple import * with window(\"Tutorial\"): add_checkbox(\"Radio Button\", default_value=False) print(\"First value of the Radio Button is: \", get_value(\"Radio Button\")) set_value(\"Radio Button\", True) print(\"Value after setting the Radio Button is: \", get_value(\"Radio Button\")) start_dearpygui() 控制相同值 添加新的窗口控件时，会将 value 添加到 Value存储系统 中，默认情况下，此 value 的标识符是控件的 name。我们可以使用 source 参数覆盖标识符，这样做有一个好处，就是让多个控件控制同一个 value from dearpygui.core import * from dearpygui.simple import * def plus_one(sender, data): count = get_value('count_value') set_value('count_value', str(int(count)+1)) show_logger() with window(\"Tutorial\"): add_input_text(\"input text##1\", source='count_value') add_button('plus 1', callback=plus_one) start_dearpygui() 存储其他数据结构 Dear PyGui 还支持传入任意 Python 数据对象类型（甚至可以自定义数据类型）用于数据存储。使用 add_data，我们可以传入任意数据类型，并通过 get_data(\"name\") 进行访问。 from dearpygui.core import * from dearpygui.simple import * def store_data(sender, data): custom_data = { \"Radio Button\": get_value(\"Radio Button\"), \"Checkbox\": get_value(\"Checkbox\"), \"Text Input\": get_value(\"Text Input\"), } add_data(\"stored_data\", custom_data) def print_data(sender, data): log_debug(get_data(\"stored_data\")) show_logger() with window(\"Tutorial\"): add_radio_button(\"Radio Button\", items=[\"opt 1\", \"opt 2\"]) add_checkbox(\"Checkbox\", label=\"tag\") add_input_text(\"Text Input\", label=\"text\") add_button(\"store data\", callback=store_data) add_button(\"print data\", callback=print_data) start_dearpygui() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"回调 Callback 添加回调 生成控件时使用 callback 参数设置 创建后使用 set_item_callback 分配给窗口控件 参数 每个回调方法都必须包含一个 sender 和 data 参数 sender 记录哪个控件通过发送 name 来触发回调 data 显示控件指定的 callback_data 参数 获取控件值 可以在回调函数中获取控件值 from dearpygui.core import * from dearpygui.simple import * def update_var(sender, data): my_var = get_value(sender) log_debug(my_var) show_logger() with window(\"Tutorial\"): add_checkbox(\"check box\", callback=update_var) add_input_text(\"input text\", callback=update_var) add_input_int(\"input int\", callback=update_var) start_dearpygui() 窗口的特殊回调 on_close：在窗口关闭时触发 set_resize_callback()：在窗口被调整大小时触发 set_render_callback() from dearpygui.core import * from dearpygui.simple import * def close_info(sender, data): log_debug(f\"{sender}has been closed\") def resize_info(sender, data): log_debug(f'{sender}has been resized') show_logger() with window(\"Tutorial\", on_close=close_info): add_text('Hello World!') set_resize_callback(resize_info, handler=\"Tutorial\") start_dearpygui() 运行时添加和删除控件 Dear PyGui 支持在运行时动态添加和删除任何控件或窗口 通过使用回调运行所需控件的 add_*** 方法并指定该控件所属的 parent 来完成 默认情况下，如果未指定 parent，则将控件添加到主窗口。 而通过在添加控件时使用 before 参数，可以设置将新控件放在哪个控件之前，默认情况下，会将新控件放在最后。 from dearpygui.core import * from dearpygui.simple import * def add_buttons(sender, data): add_button(\"New Button 2\", parent=\"Secondary Window\") add_button(\"New Button\", before=\"New Button 2\") def delete_buttons(sender, data): delete_item(\"New Button\") delete_item(\"New Button 2\") show_debug() with window(\"Tutorial\"): add_button(\"Add Buttons\", callback=add_buttons) add_button(\"Delete Buttons\", callback=delete_buttons) with window(\"Secondary Window\"): pass start_dearpygui() 删除窗口 删除窗口时，默认情况下，会删除窗口及其子控件，如果只想删除子控件，可以将 children_only 参数设置为 True 值 from dearpygui.core import * from dearpygui.simple import * def add_widgets(sender, data): with window(\"Secondary Window\"): add_button(\"New Button 2\") add_button(\"New Button\") add_button(\"New Button 3\", parent=\"Secondary Window\") def delete_widgets(sender, data): delete_item(\"Secondary Window\") def delete_children(sender, data): delete_item(\"Secondary Window\", children_only=True) with window(\"Tutorial\"): add_button(\"add\", callback=add_widgets) add_button(\"delete window and widgets\", callback=delete_widgets) add_button(\"delete widgets\", callback=delete_children) start_dearpygui() 控件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"表格 Table Dear PyGui has a simple table API that is well suited for static and dynamic tables. The table widget is started by calling add_table(). To edit the table widget we can use the methods add_row() add_column() which will append the row/column to the last slot in the table. Alternatively, we can insert rows/columns using insert_row insert_column. Columns and Rows are inserted according to their index argument. If the specified index already exists the exiting columns/rows will be bumped and the new row/column will be inserted at the specified index. Also an added or inserted row/column will by default fill unspecified cells with empty cells. from dearpygui.core import * from dearpygui.simple import * with window(\"Tutorial\"): add_table(\"Table Example\", [\"Header 0\", \"Header 1\"]) add_row(\"Table Example\", [\"row 0\", \"text\"]) add_row(\"Table Example\", [\"row 2\", \"text\"]) add_column(\"Table Example\", \"Header 3\", [\"data\", \"data\"]) insert_row(\"Table Example\", 1, [\"row 1\", \"inserted row\", \"inserted row\"]) insert_column(\"Table Example\", 2, \"Header 2\", [\"inserted with column\", \"inserted column\", \"inserted column\"]) start_dearpygui() 修改 coord_list = get_table_selections(“Table name”) 获取选中的表格项 set_table_item(“Table name”, coordinates[0], coordinates[1], “New Value”) set_headers(“Table name”, header_list)* 修改表头，传入表头名列表 from dearpygui.core import * from dearpygui.simple import * def modify_tables(sender, data): log_debug(f\"Table Called: {sender}\") coord_list = get_table_selections(\"Table Example\") log_debug(f\"Selected Cells (coordinates): {coord_list}\") for coordinates in coord_list: set_table_item(\"Table Example\", coordinates[0], coordinates[1], \"New Value\") set_headers(\"Table Example\", [\"New Header 0\", \"New Header 1\", \"New Header 2\"]) show_logger() with window(\"Tutorial\"): add_spacing(count=5) add_button(\"Modify Selected Table Values\", callback=modify_tables) add_spacing(count=5) add_table(\"Table Example\", [\"Header 0\", \"Header 1\"]) add_row(\"Table Example\", [\"awesome row\", \"text\"]) add_row(\"Table Example\", [\"super unique\", \"unique text\"]) add_column(\"Table Example\", \"Header 2\", [\"text from column\", \"text from column\"]) add_row(\"Table Example\", [\"boring row\"]) start_dearpygui() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"分隔件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"同排 add_same_line spacing 分隔距 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"行距 add_spacing ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"分隔线 add_separator ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:4:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"输入框 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"文本框 add_input_text add_input_text(\"Label\", default_value=\"Test Window\") ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"整型数框 add_input_int ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:5:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"浮点数框 add_input_float ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:5:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"选择框 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"按钮 add_button ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:6:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"复选框 add_checkbox ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:6:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"窗体 autosize 是否自动规划窗口大小 width 宽 height 高 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/dearpygui/"},{"categories":null,"content":"一、执行文件 manim yourfile.py [className] [-params] One can also specify the render quality by using the flags -ql, -qm, -qh, or -qk, for low, medium, high, and 4k quality, respectively. flag abbr function --help -h Show the help message and exit --output_file OUTPUT_FILE -o OUTPUT_FILE Specify the name of the output file --preview -p Automatically open the saved file once its done --show_in_file_browser -f Show the output file in the File Browser --write_all -a Write all the scenes from a file --save_last_frame -s Save the last frame only (no movie file is generated) --save_pngs -g Save each frame as a png --save_as_gif -i Save the video as gif --background_color BACKGROUND_COLOR -c BACKGROUND_COLOR Specify background color --dry_run Do a dry run (render scenes but generate no output files) --transparent -t Render a scene with an alpha channel --low_quality -ql Render at low quality --medium_quality -qm Render at medium quality --high_quality -qh Render at high quality --fourk_quality -qk Render at 4K quality 若要在 Jupyter 中使用 %%manim Test1 [CLI options] Mobject Mobject 是屏幕中出现的所有物体的超类 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"通用方法 所有方法以 Mobject. 开头 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"移动 to_edge(edge, buff=) 移动到指定方向及其线性组合 edge：DIRECTION buff：两者的边界距离 to_corner(corner, buff=) 移动到四角 corner： buff：两者的边缘的距离 move_to(…) 在当前位置移动到对应的位置 参数可以是 mobject：另一个Mobject aligned_edge：DIRECTION 的线性组合 coor_mask：numpy 向量，默认为 np.array([1, 1, 1]) next_to(mobject, direction, buff=) 移动到指定对象的相对位置 mobject：另一个 Mobject 对象 direction：DIRECTION buff：两者的边界距离，默认为 0.25 aligned_edge：对齐的方向 align_to(mobject, direction) 与指定对象对齐 mobject：另一个 Mobject 对象 direction：DIRECTION shift(aligned_edge) 向自己的垂直方向平移 aligned_edge：DIRECTION 的线性组合 center() 放到画面中心 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"旋转 rotate(angle) 逆时针旋转 angle：PI * number flip(direction) 按照指定方向翻转 180 度，方向遵循右手定则 direction：DIRECTION ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"变形 become(mobject) 变成其他图形 mobject：另一个 Mobject 对象 set_color(color) 变色 color：COLOR set_color_by_gradient(gradient): text.set_color_by_gradient(BLUE, GREEN) text[7:12].set_color_by_gradient(BLUE, GREEN) scale(scale_factor) 缩放大小 scale_factor：缩放倍数 fade(drakness=0.5) 变暗 darkness：暗度 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"获取信息 get_center() 获取位置信息 get_height() 获取高度 get_width() 获取宽度 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"组合 arrange(direction, buff=0.25, center=True, **kwargs) 排列子物体，sort mobjects next to each other on screen. class Example(Scene): def construct(self): s1 = Square() s2 = Square() s3 = Square() s4 = Square() x = VGroup(s1, s2, s3, s4).arrange(buff=1.0) self.add(x) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"VMobject 独有方法 VMobject 是 Mobject 的子类，使用贝塞尔曲线来表示物体 set_fill(color,opacity) 在图案中填充颜色 color：COLOR opacity：int 透明度 set_opacity(opacity) 设置 fill 、 stroke 和 background_stroke 的不透明度 setstroke(color, width, opacity, background) 设置 stroke 样式（边框样式） set_style(fill_color=None, fill_opacity=None, stroke_color=None, stroke_width=None, stroke_opacity=None, background_stroke_color=None, background_stroke_width=None, background_stroke_opacity=None, sheen_factor=None, sheen_direction=None, background_image_file=None, family=True) 允许设置全部样式 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:1:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"SVG ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Text Mobjects used for displaying (non-LaTeX) text. Tex(*text_strings, **kwargs) 可传入多个 text_strings class HelloWorld(Scene): def construct(self): text = Text('Hello world').scale(3) self.add(text) Parameters color 改变全部文字的颜色 接收一个str，如'#FFFFFF' 或者是定义在 constants.py 里的颜色常量，如 BLUE t2c: text2color 的缩写，改变指定文字的颜色 接收一个 dict，如{'text': color} 或者切片模式，如 {'[1:4]': color} gradient: 渐变色 接收一个tuple，如 (BLUE, GREEN, '#FFFFFF') t2g: text2gradient的缩写，改变指定文字的渐变色 接收一个dict，如{'text': (BLUE, GREEN, '#FFFFFF')} 或者切片模式，如{'[1:4]': (BLUE, GREEN, '#FFFFFF')} font: 改变全部文字的字体 接收一个str，如'Source Han Sans' t2f: text2font的缩写，改变指定文字的字体 接收一个dict，如{'text': 'Source Han Sans'} 或者切片模式，如{'[1:4]': 'Source Han Sans'} slant: 斜体选项: NORMAL或者ITALIC t2s: text2slant 的缩写，改变指定文字成斜体 接收一个dict，如{'text': ITALIC} 或者切片模式，如{'[1:4]': ITALIC} weight: 字重(粗细)选项: NORMAL 或 BOLD t2w: text2weight 的缩写，改变指定文字成粗体 接收一个dict，如{'text': BOLD} 或者切片模式，如{'[1:4]': BOLD} 其余 Mobject 属性 Methods set_color_by_t2c(self, t2c): text.set_color_by_t2c({'world':BLUE}) set_color_by_t2g(self, t2g): text.set_color_by_t2g({'world':(BLUE, GREEN)}) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"切片 from manim import * class test(Scene): def construct(self): text = Text('Google', t2c={ '[:1]': '#3174f0', '[1:2]': '#e53125', '[2:3]': '#fbb003', '[3:4]': '#3174f0', '[4:5]': '#269a43', '[5:]': '#e53125', }) self.play(Write(text)) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Tex A string compiled with LaTeX in normal mode. Tex(*tex_strings, **kwargs) 可传入多个 tex_strings class HelloLaTeX(Scene): def construct(self): tex = Tex(r'\\LaTeX').scale(3) self.add(tex) we are using a raw string (r'---') instead of a regular string ('---'). ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"MathTex Whereas in a MathTex mobject everything is math-mode by default. ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Code Code 使用 pygments 给代码生成带语法高亮的 html 文件，然后再转换为物体。 Code(file_name=None, **kwargs) 结构 Code[0] 是代码的背景 ( Code.background_mobject ) 如果 background == \"rectangle\" 则是一个Rectangle 如果 background == \"window\" 则是一个带有矩形和三个点的VGroup Code[1] 是行号 ( Code.line_numbers 一个Paragraph)，可以使用 Code.line_numbers[0] 或者 Code[1][0] 来访问行号中的第一个数字 Code[2] 是代码 (Code.code)，一个带有颜色的Paragraph parameters file_name Name of the code file to display. code If file_name is not specified, a code string can be passed directly. background 代码背景块形状 默认 'rectangle' from manim import * class test(Scene): def construct(self): heading = Text(\"\\\"Hello, World\\\"Program\", stroke_width=0).scale(1.3) heading.to_edge(UP) helloworldc = Code(\"helloworldc.c\", ) helloworldcpp = Code(\"helloworldcpp.cpp\", ) helloworldc.move_to(np.array([-3.6, 0, 0])) helloworldcpp.move_to(np.array([3.1, 0, 0])) self.play(Write(heading), run_time=0.5) self.play(Write(helloworldc), run_time=2) self.draw_code_all_lines_at_a_time(helloworldcpp) self.wait() def draw_code_all_lines_at_a_time(self, Code): self.play(Write(Code.background_mobject), run_time=0.3) self.play(Write(Code.line_numbers), run_time=0.3) self.play(*[Write(Code.code[i]) for i in range(Code.code.__len__())], run_time=2) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Brace 大括号 Brace(mobject, direction, **kwargs) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"ImageMobject 注意：ImageMobject 不是 VMobject 的子类，所以有很多动画无法使用 ImageMobject(filename, **kwargs) parameters height：插入图片的高度，默认为 2 Methods set_opacity(alpha) 设置图片不透明度 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:2:7","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Geometry ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"通用参数 color：颜色 fill_opacity：图形内不透明度，默认为 0 （透明） ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"圆 Circle(**kwargs) 正圆 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"点 Dot(point, radius, stroke_width, fill_opacity, color, **kwargs) point：np.array 或 DIRECTION，默认为 array([0.0, 0.0, 0.0]) radius：半径，默认为 0.08 stroke_width：边框宽度，默认为 0 fill_opacity：不透明度，默认为 1.0 color：颜色，默认为 '#FFFFFF' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"三角形 Triangle(**kwargs) 正三角形 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"矩形 Rectangle(**kwargs) 矩形 paramters height : 矩形高度 width : 矩形宽度 Square(**kwargs) 正方形 parameters side_length ：正方形边长 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"线 Line(start, end, **kwargs) start：起点，默认 LEFT 或 array([- 1.0, 0.0, 0.0]) end：终点，默认 RIGHT 或 array([1.0, 0.0, 0.0]) methods set_length(length)** 缩放到 length 长度 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"箭头 Arrow(*args, **kwargs) start：起点，默认 LEFT end：终点，默认 RIGHT Animation ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:3:7","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"通用 所有方法以 self. 开头 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"wait() wait(seconds) 等待动画停留时间，如果没有参数则默认等待到将动画播放完为止 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"add() add(someObject1, someObject2, …) 无动画添加文字 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"remove() remove(someObject1, someObject2, …) 移除 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:4:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"play() play(SomePlayMethod(someObject), run_time=seconds) 播放某种动画方法 class concurrent(Scene): def construct(self): dot1 = Dot() dot2 = Dot() dot2.shift(UP) dot3 = Dot() dot3.shift(DOWN) # 单个动画的演示 self.play(Write(dot1)) # 多个动画演示 self.play(*[ Transform(i.copy(), j) for i, j in zip([dot1, dot1], [dot2, dot3]) ]) # 故意使用i,j是为了显示zip的使用 self.wait() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:4:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"ApplyMethod() ApplyMethod(method, *args, **kwargs) 因为 ApplyMethod 是Transform的子类，所以每次只能对同一个物体执行一次操作（最后一次） from manim import * class test16(Scene): def construct(self): A = Text(\"Text-A\").to_edge(LEFT) self.add(A) self.play(ApplyMethod(A.shift, RIGHT * 7 + UP * 2)) self.wait() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:4:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"PlayMethod ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Mobject.animate.method() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Creation manim.animation.creation DrawBorderThenFill(mobject) Draw the border first and then show the fill. from manim import * class test(Scene): def construct(self): cir = Circle(fill_opacity=1, color=GREEN) rec = Rectangle(fill_opacity=1, color=BLUE) text = Text('Text.') group = VGroup(cir, rec, text).arrange(LEFT) self.play(*[DrawBorderThenFill(mob) for mob in group]) self.wait() ShowCreation(mobject) Incrementally show a VMobject. from manim import * class test(Scene): def construct(self): cir1 = Circle(fill_opacity=1) cir2 = Circle(color=BLUE) text = Text('These are two circles.') cir_group = VGroup(cir1, cir2, text) cir_group.arrange(RIGHT) self.play(*[ShowCreation(mob) for mob in cir_group]) self.wait() Uncreate(mobject) Like ShowCreation but in reverse. Write(mobject) Simulate hand-writing a Text or hand-drawing a VMobject. ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Fading manim.animation.fading FadeIn(mobject) 淡入 FadeInFrom(mobject, direction) 从指定方向淡入 FadeInFromPoint(mobject, point) 从指定位置以点淡入 from manim import * class test(Scene): def construct(self): cir = Circle(fill_opacity=1, color=GREEN) rec = Rectangle(fill_opacity=1, color=BLUE) text = Text('Text.') group = VGroup(cir, rec, text).arrange(LEFT) self.play(*[FadeInFromPoint(mob, UP * 3) for mob in group]) self.wait() FadOut(mobject) 淡出 FadeOutAndShift(mobject, direction) 从指定方向淡出 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Movement MoveAlongPath(mobject, path) Make one mobject move along the path of another mobject ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Rotate Animations related to rotation. Rotate(mobject, angle) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Transform Animations transforming one mobject into another. Transform(mobject, target_mobject=None, **kwargs)\\ TransformFromCopy(mobject, target_mobject, **kwargs) from manim import * class test(Scene): def construct(self): A = Text(\"Text-A\").scale(3) B = Text(\"Text-B\").scale(3).shift(UP * 2) self.add(A) self.play(TransformFromCopy(A, B)) self.wait() Restore(mobject, **kwargs) 返回之前保存的状态 from manim import * class test(Scene): def construct(self): A = Text(\"Text-A\").to_edge(LEFT) A.save_state() # 记录下现在状态，restore会回到此时 A.scale(3).shift(RIGHT * 7 + UP * 2) self.add(A) self.play(Restore(A)) self.wait() ApplyFunction(function, mobject, **kwargs) 执行函数操作 from manim import * class test(Scene): def construct(self): A = Text(\"Text-A\").to_edge(LEFT) def function(mob): return mob.scale(3).shift(RIGHT * 7 + UP * 2) # 需要return一个mobject self.add(A) self.wait() self.play(ApplyFunction(function, A)) self.wait() Swap(*mobjects, **kwargs) 互换位置 from manim import * class test19(Scene): def construct(self): A = Text(\"Text-A\").scale(3) B = Text(\"Text-B\").scale(3) VGroup(A, B).arrange(RIGHT) self.add(A, B) self.play(Swap(A, B)) # 或CyclicReplace(A, B) self.wait() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Grow GrowArrow(arrow, **kwargs) GrowFromPoint(mobject, point, **kwargs) 从指定方向由小变大进入 from manim import * class test(Scene): def construct(self): mobjects = VGroup(Circle(), Circle(fill_opacity=1), Text(\"Text\").scale(2)) mobjects.arrange(LEFT) directions = [UP, LEFT, DOWN, RIGHT] for direction in directions: self.play(*[ GrowFromPoint(mob, mob.get_center() + direction * 3) for mob in mobjects ]) self.wait() GrowFromCenter(mobject, **kwargs) SpinInFromNothing(mobject, **kwargs) from manim import * class test(Scene): def construct(self): mobjects = VGroup(Square(), Square(fill_opacity=1, color=BLUE), Text(\"Text\").scale(2)) mobjects.scale(1.5) mobjects.arrange(RIGHT, buff=2) self.play(*[SpinInFromNothing(mob) for mob in mobjects]) self.wait() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:7","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Indication FocusOn(focus_point, **kwargs) focus_point：Mobject or point from manim import * class test(Scene): def construct(self): mobjects = VGroup(Dot(), Text(\"x\")) mobjects.arrange(RIGHT, buff=2) colors = [GRAY, RED] self.add(mobjects) for obj, color in zip(mobjects, colors): self.play(FocusOn(obj, color=color)) self.wait(0.3) Indicate(mobject, target_mobject=None, **kwargs) from manim import * class test(Scene): def construct(self): formula = Tex(\"f(\", \"x\", \")\") dot = Dot() VGroup(formula, dot).scale(3).arrange(DOWN, buff=3) self.add(formula, dot) for mob in [formula[1], dot]: self.play(Indicate(mob)) self.wait(0.3) Flash(point, color, **kwargs) 一闪一闪 from manim import * class test(Scene): def construct(self): mobjects = VGroup(Dot(), TexMobject(\"x\")).scale(2) mobjects.arrange(RIGHT, buff=2) mobject_or_coord = [ *mobjects, # Mobjects: Dot and \"x\" mobjects.get_right() + RIGHT * 2 # Coord ] colors = [GRAY, RED, BLUE] self.add(mobjects) for obj, color in zip(mobject_or_coord, colors): self.play(Flash(obj, color=color, flash_radius=0.5)) self.wait(0.3) CircleIndicate(mobject, **kwargs) 画圈圈 from manim import * class test8(Scene): def construct(self): mobjects = VGroup(Dot(), TexMobject(\"x\")).scale(2) mobjects.arrange(RIGHT, buff=2) self.add(mobjects) self.wait(0.2) for obj in mobjects: self.play(CircleIndicate(obj)) ShowCreationThenDestructionAround(mobject, **kwargs) 展示方框 from manim import * class test(Scene): def construct(self): mobjects = VGroup(Circle(), Circle(fill_opacity=1), Text(\"Text\").scale(2)) mobjects.scale(1.5) mobjects.arrange(RIGHT, buff=2) self.add(mobjects) self.play( *[ShowCreationThenDestructionAround(mob) for mob in mobjects]) self.wait(0.3) ApplyWave(mobject, **kwargs) 水波效果 from manim import * class test(Scene): def construct(self): mobjects = VGroup(Circle(), Circle(fill_opacity=1), Text(\"Text\").scale(2)) mobjects.scale(1.5) mobjects.arrange(RIGHT, buff=2) self.add(mobjects) self.play(*[ApplyWave(mob) for mob in mobjects]) self.wait() WiggleOutThenIn(mobject, **kwargs) 扭一扭 from manim import * class test(Scene): def construct(self): mobjects = VGroup(Circle(), Circle(fill_opacity=1), Text(\"Text\").scale(2)) mobjects.scale(1.5) mobjects.arrange(RIGHT, buff=2) self.add(mobjects) self.play(*[WiggleOutThenIn(mob) for mob in mobjects]) self.wait() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:8","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Movement MoveAlongPath(mobject, path, **kwargs) from manim import * class test11(Scene): def construct(self): line = Line(LEFT, RIGHT * 10, color=RED, buff=1) line.move_to(ORIGIN) dot = Dot() dot.move_to(line.get_start()) self.add(line, dot) self.play(MoveAlongPath(dot, line)) self.wait(0.3) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:9","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Numbers ChangingDecimal(decimal_mob, number_update_func, **kwargs) 计数动画 from manim import * class test(Scene): def construct(self): number = DecimalNumber(0).scale(2) def update_func(t): return t * 10 self.add(number) self.wait() self.play(ChangingDecimal(number, update_func), run_time=3) self.wait() ChangeDecimalToValue(decimal_mob, target_number, **kwargs) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:10","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Rotation Rotate 目前是 Transform 的子类，即带有 path_arc 的 Transform ，所以会有扭曲 Rotating 直接继承自 Animation ，根据角度插值，比较顺滑，推荐使用 Rotating(mobject, **kwargs) from manim import * class test(Scene): def construct(self): square = Square().scale(2) self.add(square) self.play(Rotating(square, radians=PI / 4, run_time=2)) self.wait(0.3) self.play(Rotating(square, radians=PI, run_time=2, axis=RIGHT)) self.wait(0.3) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:11","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Update UpdateFromFunc() 实时更新 from manim import * class test(Scene): def construct(self): square = Square().to_edge(UP) mobject = Text(\"Text\").scale(2).next_to(square, RIGHT) def update_func(mob): mob.next_to(square, RIGHT) self.add(square, mobject) self.play(ApplyMethod(square.to_edge, DOWN), UpdateFromFunc(mobject, update_func)) self.wait() # equal to # group = VGroup(square, mobject) # self.add(group) # self.play(ApplyMethod(group.to_edge, DOWN)) # self.wait() UpdateFromAlphaFunc(mobject, update_function, **kwargs) 传入的函数含有参数alpha，表示动画完成度(0~1之间) from manim import * class test(Scene): def construct(self): square = Square().to_edge(UP) mobject = Text(\"Text\").scale(2) mobject.next_to(square, RIGHT, buff=0.05) def update_func(mob, alpha): mob.next_to(square, RIGHT, buff=0.05 + alpha) self.add(square, mobject) self.play(square.animate.to_edge(DOWN), UpdateFromAlphaFunc(mobject, update_func)) self.wait() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:12","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Composition AnimationGroup(*animations, **kwargs) 传入一系列动画，一起执行（不能通过下标访问动画） lag_ratio：默认为0（即上一个动画运行到0%的时候运行下一个动画） from manim import * class test22(Scene): def construct(self): cir1 = Circle() cir2 = Circle(fill_opacity=1) text = Text(\"Text\").scale(2) mobjects = VGroup(cir1, cir2, text).scale(1.5).arrange(RIGHT, buff=2) anims = AnimationGroup(ShowCreation(cir1), Write(cir2), FadeIn(text)) self.play(anims) self.wait() Camera Camera 类及其子类用于获取当前屏幕上的画面， 然后作为每帧图像传递给 SceneFileWriter 来生成视频 Constants ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:5:13","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"Module Attributes ORIGIN The center of the coordinate system. UP One unit step in the positive Y direction. DOWN One unit step in the negative Y direction. RIGHT One unit step in the positive X direction. LEFT One unit step in the negative X direction. IN One unit step in the negative Z direction. OUT One unit step in the positive Z direction. UL One step up plus one step left. UR One step up plus one step right. DL One step down plus one step left. DR One step down plus one step right. PI The ratio of the circumference of a circle to its diameter. TAU The ratio of the circumference of a circle to its radius. DEGREES The exchange rate between radians and degrees. 六 其他 公式怎么对齐 直接在TexMobject中使用\u0026对齐 两个mobject对齐，使用obj2.next_to(obj1, DOWN, aligned_edge=LEFT)使obj2在obj1下方，并左对齐 VGroup内对齐，使用group.arrange(DOWN, aligned_edge=LEFT)使VGroup中的子元素依次向下排开，并左对齐 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/manim/"},{"categories":null,"content":"简介 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"模块 QtWidgets ：包含了一整套的 UI 元素控件，用于建立符合系统风格的界面 QtGui：涵盖了多种基本图形功能的类(字体，图形，图标，颜色) QtCore：涵盖了包的核心的非 GUI 界面的功能(时间，文件，目录，数据类型，文本流，链接，线程进程等) QtWebKit：显示网页 QtTest：对 Qt 应用程序和库进行单元测试的类 QtSql：提供对 SQL 数据库支持的基本模块 QtMultimedia：多媒体，比如音频，视频 QtMultimediaWidgets：多媒体，比如音频，视频 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"程序基本结构分析 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"导入需要的包和模块 from PyQt5.Qt import * # 别问为什么这么写，问就是懒，这样做的好处是可以不管什么包都导入，不需要一点点导包，缺点就是占点内存 import sys sys是什么 # sys是什么 # 我们的代码，到时候的执行方式，1、右击run去执行，2、命令行Python代码名称 # argv:当别人通过命令行启动这个程序的时候，可以设定一种功能(接收命令行传递的参数来执行不同的业务逻辑) args = sys.argv print(args) if args[1] == '1': print(\"hello world\") else: print(\"hello pyqt\") # exit(退出码)，正常退出是0，程序内部错误是其他的错误码，通过传递不同的错误码，可以知道怎么退出的。 sys.exit() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"创建一个应用程序对象 app = QApplication(sys.argv) sys.argv 参数是来自命令行的参数列表。 Python 脚本可以从 shell 运行。 写了这句话就能让我们的程序从命令行启动 QApplication 管理 GUI 程序的控制流和主要设置。对于用 Qt 写的任何一个 GUI 应用，不管这个应用有没有窗口或多少个窗口，有且只有一个 QApplication 对象。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"控件操作 # 创建控件，设置控件(大小，位置，样式)，事件，信号的处理 # 1、创建控件 # 控件创建好后(没有父控件)，则把它当作顶层控件(窗口)，系统会自动的给窗口添加一些装饰(标题栏)，窗口控件具备一些性质(设置标题，图标) window = QWidget() # 2、设置控件 window.setWindowTitle(\"程序基本结构分析\") # 设置窗口标题 window.resize(300,150) # 设置窗口尺寸，长宽 w.move(300,300) # 移动窗口(显示时在哪),长高 # 控件也可以作为一个容器承载其他控件 label = QLabel(window) label.setText('hello world') lable.move(100,100) # 3、展示控件 # 刚创建好一个控件后(没父控件)，需要手动展示 window.show() QWidget 控件（所有的窗口和控件都直接或者间接继承自 QWidget）是一个用户界面的基础控件，它提供了基本的应用构造器。默认情况下，构造器是没有父级的，没有父级的构造器被称为窗口（window）。 PyQt5 创建的窗口默认是隐藏的，需要调用 show() 显示 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"应用程序的执行，进入到消息循环 # 让整个程序开始执行，并且进入到消息循环(无限循环) # 监测整个程序所接收到的用户交互信息 sys.exit(app.exec_()) 为了让 GUI 启动，需要使用 app.exec_() 启动事件循环（启动应用，直至用户关闭它）。 app.exec_() 的作用是运行主循环，必须调用此函数才能开始事件处理，调用该方法进入程序的主循环直到调用 exit() 结束 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:2:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"将面向过程的代码改为面向对象版本 可以理解为界面与逻辑分离 设置控件的代码需要被维护，控件的设置又是通过类来完成的，那么只要在类的内部去添加就可以，但是类又是封装好的，所以要通过继承去实现，然后通过 __init__ 方法，再加上 super 来继承父类的所有方法，以后就只需要在 __init__ 方法内部去写设置就可以了。 from PyQt5.QtWidgets import QApplication, QWidget, QLabel class Window(QWidget): def __init__(self): super().__init__() self.resize(300, 150) self.move(300, 300) self.setWindowTitle('第一个基于PyQt5的桌面应用') self.setup_ui() def setup_ui(self): label = QLabel(self) label.setText('hello world') label.move(100, 100) 使用的时候，只需要在引入时，引入这个文件就可以 import sys from PyQt5.QtWidgets import QApplication, QWidget, QLabel from ui import Window if __name__ == '__main__': # 创建一个QApplication类的实例 app = QApplication(sys.argv) # 创建一个窗口 window = Window() # 显示窗口 window.show() # 进入程序主循环，并通过exit函数确保主循环安全结束 sys.exit(app.exec_()) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:2:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"事件与信号处理 (signals and slots) GUI 应用程序是事件驱动的。在事件模型中，有三个参与者： 事件来源：状态被更改的对象，它生成了事件 事件对象：（event）将状态的更改封装在事件源中 事件目标：要通知的对象 PyQt5 具有独特的信号和插槽机制来处理事件。 信号和槽用于对象之间的通信。 发生特定事件时发出信号。 槽可以是任何 Python 可调用的函数。 当发射连接的信号时会调用一个槽。槽是对信号作出反应的方法。 重写事件 知晓事件发送者 若有多个信号连接到同一个槽，需要调用 sender() 方法来确定 发出自定义信号 从 QObject 创建的对象可以发出信号 窗口 窗口就是没有父部件的部件，所以又称为顶级部件 QMainWindow 窗口可以包含菜单栏、工具栏、状态栏和标题栏等，是最常见的窗口形式，是 GUI 程序的主窗口。 QDialog 是对话框的基类，对话框主要用来执行短期任务和与用户进行互动任务，有模态和非模态两种形式。 QWidget 可以用作嵌入其他窗口。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"父类操作 QWidget QWidget 类是所有用户界面对象的基类，被称为基础窗口部件。像主窗口、对话框、标签、还有按钮、文本输入框等都是窗口部件 客户区 (Client Area)：不包含边框的部分，即用户操作的界面，可以添加子控件。 窗口：整一个界面 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"获取大小 QWidget.size() 返回 PyQt5.QtCore.QSize(width, height) QWidget.width()、QWidget.height() 返回客户区 width 和 height 值 QWidget.frameGeometry().width()、QWidget.frameGeometry().height() 返回窗口 width 和 height 值 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"设置大小 QWidget.resize(width, height) 改变客户区的大小，可以通过鼠标的来改变尺寸 QWidget.setFixedWidth(int width)、QWidget.setFixedHeight(int height) 设定不可使用鼠标修改的宽度或者高度 QWidget.setFixedSize(width, height) 设定不可使用鼠标修改的宽度和高度 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"获取位置 QWidget.pos() 返回窗口左上角坐标 QWidget.x()、QWidget.y() 返回窗口横、纵坐标 QWidget.geometry().x()、QWidget.geometry().y() 返回客户区横、纵坐标 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"设置位置 QWidget.move(int x, int y) 设置窗口的位置 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"同时设置 QWidget.frameGeometry() 返回窗口的大小和位置 QWidget.setGeometry(int x, int y, int width, int height) 同时客户区设置大小和位置 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"初始化 QWidget.setWindowIcon(QIcon) 设置窗口图标 QWidget.setWindowTitle(title) 设置窗口标题 QWidget.setToolTip(str) 显示气泡提示信息 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:4:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"设置主窗口类 QMainWindow QWidget 可以作为嵌套型的窗口存在，结构简单，而 QMainWindow 是一个程序框架，有自己的布局，可以在布局中添加控件，如将工具栏添加到布局管理器中。它常常作为 GUI 的主窗口 主窗口在 GUI 程序是唯一的，是所有窗口中的最顶层窗口，其他窗口都是它的直接或间接子窗口 QMainWindow 继承自 QWidget 类，拥有 QWidget 所有的派生方法和属性。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"状态栏 statusBar QMAinWindow.statusBar() 设置并返回状态栏对象 QMAinWindow.StatusBar().showMessage(message, int timeout)：显示状态栏信息 message：str，文本信息 timeout：int，显示时间，单位毫秒，默认为0，表示一直显示状态栏信息 import sys from PyQt5.QtWidgets import QMainWindow, QApplication class MainWidget(QMainWindow): def __init__(self, parent=None): super().__init__(parent) # 设置主窗体标签 self.setWindowTitle(\"QMainWindow 例子\") self.resize(400, 200) self.status = self.statusBar() # 秒后状态栏消失 self.status.showMessage(\"这是状态栏提示\", 5000) if __name__ == \"__main__\": app = QApplication(sys.argv) main = MainWidget() main.show() sys.exit(app.exec_()) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"菜单栏 menuBar 菜单栏是一组命令的集合 QMAinWindow.menuBar() 设置并返回菜单栏对象 menuBar.addMenu(str) 在菜单栏中添加菜单 str：菜单名 menu.addMenu(qmenu) 往菜单中添加子菜单 qmenu：QMenu 对象 menu.addAction(qaction) 往菜单中添加操作 qaction：QAction 对象 menu.addSeperator() 往菜单中添加分隔线 简单菜单例 import sys from PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplication from PyQt5.QtGui import QIcon class Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): # 初始化 self.statusBar() self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Simple menu') # 创建一个图标、一个 exit 的标签和一个快捷键组合，都执行了一个动作 exitAct = QAction(QIcon('7092.gif'), '\u0026Exit', self) exitAct.setShortcut('Ctrl+Q') # 创建了一个状态栏，当鼠标悬停在菜单栏的时候，能显示当前状态 exitAct.setStatusTip('Exit application') # 当执行这个指定的动作时，就触发了一个事件。 # 这个事件跟 QApplication 的 quit() 行为相关联，所以这个动作就能终止这个应用。 exitAct.triggered.connect(qApp.quit) # 创建菜单栏 menubar = self.menuBar() fileMenu = menubar.addMenu('\u0026File') fileMenu.addAction(exitAct) self.show() def main(): app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) if __name__ == '__main__': main() 在上面的例子中，我们用一个菜单创建一个菜单。 此菜单将包含一个选择时终止应用程序的操作。 还创建状态栏。 该操作可通过Ctrl + Q快捷方式访问 QAction 是使用菜单栏，工具栏或自定义键盘快捷方式执行操作的抽象。在上述三行中，我们创建一个具有特定图标和“退出”标签的动作。此外，为此操作定义了快捷方式。当我们选择这个特定的动作时，发出触发信号。 信号连接到 QApplication 小部件的 quit() 方法。 这终止了应用程序。 子菜单例 # coding=utf-8 from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, qApp, QMenu from PyQt5.QtGui import QIcon import sys class Example(QMainWindow): def __init__(self): super().__init__() self.InitUI() def InitUI(self): self.statusBar().showMessage('准备就绪') self.setGeometry(300, 300, 400, 300) self.setWindowTitle('关注微信公众号：学点编程吧--子菜单') exitAct = QAction(QIcon('exit.png'), '退出(\u0026E)', self) exitAct.setShortcut('Ctrl+Q') exitAct.setStatusTip('退出程序') exitAct.triggered.connect(qApp.quit) saveMenu = QMenu('保存方式(\u0026S)', self) saveAct = QAction(QIcon('save.png'), '保存...', self) saveAct.setShortcut('Ctrl+S') saveAct.setStatusTip('保存文件') saveasAct = QAction(QIcon('saveas.png'), '另存为...(\u0026O)', self) saveasAct.setStatusTip('文件另存为') saveMenu.addAction(saveAct) saveMenu.addAction(saveasAct) newAct = QAction(QIcon('new.png'), '新建(\u0026N)', self) newAct.setShortcut('Ctrl+N') menubar = self.menuBar() fileMenu = menubar.addMenu('文件(\u0026F)') fileMenu.addAction(newAct) fileMenu.addMenu(saveMenu) fileMenu.addSeparator() fileMenu.addAction(exitAct) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) 在这个例子中，我们有三个菜单项： 其中两个位于文件菜单中（新建、退出），另一个位于文件的保存子菜单中 上下文菜单 import sys from PyQt5.QtWidgets import QMainWindow, qApp, QMenu, QApplication class Example(QMainWindow): def __init__(self): super().__init__() self.initUI() def initUI(self): self.setGeometry(300, 300, 300, 200) self.setWindowTitle('Context menu') self.show() def contextMenuEvent(self, event): cmenu = QMenu(self) newAct = cmenu.addAction(\"New\") openAct = cmenu.addAction(\"Open\") quitAct = cmenu.addAction(\"Quit\") # 使用 exec_() 方法显示菜单。从鼠标右键事件对象中获得当前坐标。 # mapToGlobal() 方法把当前组件的相对坐标转换为窗口（window）的绝对坐标。 action = cmenu.exec_(self.mapToGlobal(event.pos())) def main(): app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) if __name__ == '__main__': main() 要使用上下文菜单，我们必须重新实现 contextMenuEvent() 方法 使用 exec_() 方法显示上下文菜单。 从事件对象获取鼠标指针的坐标。 mapToGlobal() 方法将窗口小部件坐标转换为全局屏幕坐标 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:5:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"工具栏 各项命令都是在菜单栏当中，但是我们可以把一些常用的命令放在工具栏上，例如新建、打开、保存等等 QMAinWindow.addToolBar() 设置并返回工具栏对象 tool.addAction(qaction) 往工具栏中添加操作 qaction：QAction 对象 # coding=utf-8 from PyQt5.QtWidgets import QApplication, QMainWindow, QAction, qApp, QMenu from PyQt5.QtGui import QIcon import sys class Example(QMainWindow): def __init__(self): super().__init__() self.InitUI() def InitUI(self): self.statusBar().showMessage('准备就绪') self.setGeometry(300, 300, 400, 300) self.setWindowTitle('Toolbar') exitAct = QAction(QIcon('exit.png'), '退出(\u0026E)', self) exitAct.setShortcut('Ctrl+Q') exitAct.setStatusTip('退出程序') exitAct.triggered.connect(qApp.quit) saveMenu = QMenu('保存方式(\u0026S)', self) saveAct = QAction(QIcon('save.png'), '保存...', self) saveAct.setShortcut('Ctrl+S') saveAct.setStatusTip('保存文件') saveasAct = QAction(QIcon('saveas.png'), '另存为...(\u0026O)', self) saveasAct.setStatusTip('文件另存为') saveMenu.addAction(saveAct) saveMenu.addAction(saveasAct) newAct = QAction(QIcon('new.png'), '新建(\u0026N)', self) newAct.setShortcut('Ctrl+N') newAct.setStatusTip('新建文件') menubar = self.menuBar() fileMenu = menubar.addMenu('文件(\u0026F)') fileMenu.addAction(newAct) fileMenu.addMenu(saveMenu) fileMenu.addSeparator() fileMenu.addAction(exitAct) toolbar = self.addToolBar('工具栏') toolbar.addAction(newAct) toolbar.addAction(exitAct) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() sys.exit(app.exec_()) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:5:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"居中展示 QMainWindow 利用 QDesktopWidget 类实现窗口居中显示 from PyQt5.QtWidgets import QDesktopWidget, QApplication, QMainWindow import sys class Winform(QMainWindow): def __init__(self, parent=None): super().__init__(parent) self.setWindowTitle('主窗口放在屏幕中间例子') self.resize(300, 200) self.center() def center(self): # 获取屏幕信息 screen = QDesktopWidget().screenGeometry() size = self.geometry() x = int((screen.width() - size.width()) / 2) y = int((screen.height() - size.height()) / 2) self.move(x, y) if __name__ == \"__main__\": app = QApplication(sys.argv) win = Winform() win.show() sys.exit(app.exec_()) 也可以直接使用 QDesktopWidget().availableGeometry().center() 设置窗口居中 import sys from PyQt5.QtWidgets import QWidget, QDesktopWidget, QApplication class CenterWin(QWidget): def __init__(self): super().__init__() self.initUI() def initUI(self): self.resize(250, 150) self.center() self.setWindowTitle('Center') self.show() def center(self): qr = self.frameGeometry() # 获得主窗口所在的框架 # 获取显示器的分辨率，然后得到屏幕中间点的位置 cp = QDesktopWidget().availableGeometry().center() # 然后把主窗口框架的中心点放置到屏幕的中心位置 qr.moveCenter(cp) # 然后通过 move 函数把主窗口的左上角移动到其框架的左上角，这样就把窗口居中了 self.move(qr.topLeft()) if __name__ == '__main__': app = QApplication(sys.argv) ex = CenterWin() sys.exit(app.exec_()) 布局 一般有两种方式：绝对布局 （absolute positioning）和 PyQt5 的 Layout 类 Layout 布局方式分为盒布局、网格布局、表单布局。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:5:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"绝对布局 (absolute positioning) 绝对布局主要是在窗口程序中指定每一个控件的显示坐标和大小来实现布局 缺点 窗口中控件的大小和位置不会随着我们更改窗口的位置和大小而变化。 不能适用于不同的平台和不同分辨率的显示器。 改变字体时可能会破坏布局。 如果我们决定重构这个应用，需要全部计算一下每个元素的位置和大小，既烦琐又费时。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"盒布局 采用 QBoxLayout 类可以在水平和垂直方向上排列控件，分别为：QHBoxLayout 和 QVBoxLayout QBoxLayout.addStretch(int stretch) 添加伸缩量 strentch：均分的比例，默认为0 QBoxLayout.addSpacing(int size) 添加一个固定大小的间距 size：间距 QBoxLayout.addWidget(QWidget) 在布局中添加控件 QBoxLayout.addLayout(QBoxLayout) 添加一个盒布局对象 QWidget.setLayout(QBoxLayout) 设置窗口的主要布局 #coding = 'utf-8' import sys from PyQt5.QtWidgets import (QWidget, QPushButton, QApplication, QHBoxLayout,QVBoxLayout) class Example(QWidget): def __init__(self): super().__init__() self.Init_UI() def Init_UI(self): self.setGeometry(300, 300, 400, 300) self.setWindowTitle('学点编程吧') bt1 = QPushButton('剪刀', self) bt2 = QPushButton('石头', self) bt3 = QPushButton('布', self) hbox = QHBoxLayout() hbox.addStretch(1) # 增加伸缩量 hbox.addWidget(bt1) hbox.addStretch(1) # 增加伸缩量 hbox.addWidget(bt2) hbox.addStretch(1) # 增加伸缩量 hbox.addWidget(bt3) hbox.addStretch(1) # 增加伸缩量 vbox = QVBoxLayout() vbox.addStretch(1) vbox.addLayout(hbox) self.setLayout(vbox) self.show() if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() app.exit(app.exec_()) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"网格布局 QGridLayout（网格布局）是将窗口分隔成行和列的网格来进行排列 QBoxLayout.addWidget(QWidget, frontRow, fromColumn, rowSpan, columnSpan) 在布局中添加控件 frontRow：起始行数 fromColumn：起始列数 rowSpan：跨越的行数 columnSpan：跨越的列数 QBoxLayout.addWidget(QWidget, row, column) 在布局中添加控件 row：行数 column：列数 QWidget.setLayout(QGridLayout) 设置窗口的主要布局 QBoxLayout.setSpacing(int spacing) 控制控件在水平方向的间隔 spacing：间隔 #coding = 'utf-8' import sys from PyQt5.QtWidgets import ( QWidget, QPushButton, QApplication, QGridLayout, QLCDNumber) class Example(QWidget): def __init__(self): super().__init__() self.Init_UI() def Init_UI(self): self.setGeometry(300, 300, 400, 300) self.setWindowTitle('学点编程吧-计算器') grid = QGridLayout() self.setLayout(grid) self.lcd = QLCDNumber() grid.addWidget(self.lcd, 0, 0, 3, 0) grid.setSpacing(10) names = ['Cls', 'Bc', '', 'Close', '7', '8', '9', '/', '4', '5', '6', '*', '1', '2', '3', '-', '0', '.', '=', '+'] positions = [(i, j) for i in range(4, 9) for j in range(4, 8)] for position, name in zip(positions, names): if name == '': continue button = QPushButton(name) grid.addWidget(button, *position) button.clicked.connect(self.Cli) self.show() def Cli(self): sender = self.sender().text() ls = ['/', '*', '-', '=', '+'] if sender in ls: self.lcd.display('A') else: self.lcd.display(sender) if __name__ == '__main__': app = QApplication(sys.argv) ex = Example() app.exit(app.exec_()) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"表单布局 QFormLayout 是 label-field 式的表单布局，顾名思义，就是实现表单方式的布局。表单是提示用户进行交互的一种模式，其主要由两列组成，第一列用于显示信息，给用户提示，一般叫作 label 域；第二列需要用户进行选择或输入，一般叫作 field 域。label 与 field 的关系就是 label 关联 field。 QFormLayout 是一个方便的布局类，其中的控件以两列的形式被布局在表单中。左列包括标签，右列包含输入控件，例如：QLineEdit、QSpinBox、QTextEdit 等 QFormLayout.addRow(label, field) 添加一行表单 import sys from PyQt5.QtWidgets import QApplication, QWidget, QFormLayout, QLineEdit, QLabel, QTextEdit class Winform(QWidget): def __init__(self, parent=None): super().__init__(parent) self.setWindowTitle(\"窗体布局管理例子\") self.resize(350, 100) formlayout = QFormLayout() forms = [ ['姓名', '阿芒'], ['性别', '男'], ['年龄', '17'] ] for name, value in forms: formlayout.addRow(QLabel(name), QLabel(value)) introductionLabel = QLabel(\"简介\") introductionLineEdit = QTextEdit(\"\") formlayout.addRow(introductionLabel, introductionLineEdit) self.setLayout(formlayout) if __name__ == \"__main__\": app = QApplication(sys.argv) form = Winform() form.show() sys.exit(app.exec_()) 显示类控件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"QLabel QLabel 对象作为一个占位符可以显示不可编辑的文本、图片或者 GIF 动画等 QLabel 是 GUI 中的标签类，它继承自 QFrame（是 QWidget 的子类） ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"API 修改内容 setText(str text) 设置文本内容 text：文本内容 setPixmap(QPixmap) 设置图片 setMovie(QMovie) 设置视频 QMovie 类是用 QImageReader 播放动画的便捷类。 这个类用来显示没有声音的简单的动画 文字设置 setAlignment() 按固定值方式对齐文本 Qt.AlignLeft：水平方向靠左对齐； Qt.AlignRight:水平方向靠右对齐； Qt.AlignCenter：水平方向居中对齐； Qt.AlignJustify：水平方向调整间距两端对齐； Qt.AlignTop：垂直方向靠上对齐； Qt.AlignBottom：垂直方向靠下对齐； Qt.AlignVCenter：垂直方向居中对齐。 serIndent() 设置文本缩进值 setWordWrap() 设置是否允许换行 setFont(QFont) 设置字体的大小样式 setStyleSheet(str cssStyle) 设置 CSS 样式 cssStyle：CSS 样式，如 \"border-radius: 25px;border: 1px solid black;\" 返回 text() 返回文本内容 selectedText() 返回所选中的字符 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:10:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":" 文本框类控件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:10:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"QLineEdit QLineEdit 类是一个单行文本框控件，可以输入单行字符串 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/pyqt5/"},{"categories":null,"content":"窗口 import tkinter as tk # 引入tkinter库，并取个别名（即外号)tk root = tk.Tk() # 创建窗口 root.mainloop() # 窗口循环显示 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"属性设置 root['bg'] = 'red' # 背景色，或root['background'] = 'red' root['height'] = 700 # 窗口的高 root['width'] = 1000 # 窗口的宽 root['highlightthickness'] = 100 # 加亮区域的宽度 root['highlightcolor'] = 'yellow' # 设置加亮区域在 有焦点 时的颜色 root['highlightbackground'] = 'black' # 设置加亮区域在 无焦点 时的颜色 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"常用方法 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"标题设置 root.title('你好') ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"移除窗口栏 root.overrideredirect(True) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"窗口大小和位置 # 大小为1000x700，位置为距离屏幕，左右距即x轴100，上下距即y轴50 root.geometry('1000x700+100+50') ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"窗口刷新 root.update() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"获取窗口位置 # 获取位置前必须刷新窗口 root.update() print( root.winfo_x() ) print( root.winfo_y() ) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"窗口最大最小尺寸 # 使窗口能拉取的大小在一个范围内 root.maxsize(200, 300) root.minsize(20, 100) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"窗口高宽是否可变 # True表示可以拉伸，False反之，该例子表示可拉伸宽度但固定了高度 root.resizable( width=True, height=False ) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:7","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"修改图标 # 参数是*.ico格式的图标路径 root.iconbitmap('path\\python.ico') ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:2:8","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"事件绑定 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"格式 root.bind(event,handler) event：系统事件，比如按键的点击，鼠标的点击。其接受的参数是 python 指定的格式 handler：事件发生后，要执行的方法的名称，执行的方法要有个固定的参数 event 方法格式为: def handler_name(event): pass 下面例子，点击窗口会改变窗口颜色： import tkinter as tk root = tk.Tk() # 绑定的方法：点击窗口改变颜色 def callback(event): print('点击改变颜色') if root['bg'] == 'black': root['bg'] = 'white' else: root['bg'] = 'black' # 窗口绑定 root.bind( '\u003cButton-1\u003e', callback ) root.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"事件 Tkinter 使用所谓的 事件队列 (event sequences) 暴露接口以绑定 handler 到相关事件. 事件以字符串的形式给出 \u003cmodifier-type-detail\u003e 事件序列是包含在尖括号（\u003c…\u003e）中 type 部分的内容是最重要的，它通常用于描述普通的事件类型，例如鼠标点击或键盘按键点击（详见下方）。 modifier 部分的内容是可选的，它通常用于描述组合键，例如 Ctrl + c，Shift + 鼠标左键点击（详见下方）。 detail 部分的内容是可选的，它通常用于描述具体的按键，例如 Button-1 表示鼠标左键。 例如 事件序列 含义 \u003cButton-1\u003e 用户点击鼠标左键 \u003cKeyPress-H\u003e 用户点击 H 按键 \u003cControl-Shift-KeyPress-H\u003e 用户同时点击 Ctrl + Shift + H ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"type type 含义 Activate 当组件的状态从“未激活”变为“激活”的时候触发该事件 Button 1. 当用户点击鼠标按键的时候触发该事件 2. detail 部分指定具体哪个按键：\u003cButton-1\u003e鼠标左键，\u003cButton-2\u003e鼠标中键，\u003cButton-3\u003e鼠标右键，\u003cButton-4\u003e滚轮上滚（Linux），\u003cButton-5\u003e滚轮下滚（Linux） ButtonRelease 1. 当用户释放鼠标按键的时候触发该事 2. 在大多数情况下，比 Button 要更好用，因为如果当用户不小心按下鼠标，用户可以将鼠标移出组件再释放鼠标，从而避免不小心触发事件 Configure 当组件的尺寸发生改变的时候触发该事件 Deactivate 当组件的状态从“激活”变为“未激活”的时候触发该事件 Destroy 当组件被销毁的时候触发该事件 Enter 1. 当鼠标指针进入组件的时候触发该事件 2. 注意：不是指用户按下回车键 Expose 当窗口或组件的某部分不再被覆盖的时候触发该事件 FocusIn 1. 当组件获得焦点的时候触发该事件 2. 用户可以用 Tab 键将焦点转移到该组件上（需要该组件的 takefocus 选项为 True） 3. 你也可以调用 focus_set() 方法使该组件获得焦点（见上方例子） FocusOut 当组件失去焦点的时候触发该事件 KeyPress 1. 当用户按下键盘按键的时候触发该事件 2. detail 可以指定具体的按键，例如 \u003cKeyPress-H\u003e表示当大写字母 H 被按下的时候触发该事件 3. KeyPress 可以简写为 Key KeyRelease 当用户释放键盘按键的时候触发该事件 Leave 当鼠标指针离开组件的时候触发该事件 Map 1. 当组件被映射的时候触发该事件 2. 意思是在应用程序中显示该组件的时候，例如调用 grid() 方法 Motion 当鼠标在组件内移动的整个过程均触发该事件 MouseWheel 1. 当鼠标滚轮滚动的时候触发该事件 2. 目前该事件仅支持 Windows 和 Mac 系统，Linux 系统请参考 Button Unmap 1. 当组件被取消映射的时候触发该事件 2. 意思是在应用程序中不再显示该组件的时候，例如调用 grid_remove() 方法 Visibility 当应用程序至少有一部分在屏幕中是可见的时候触发该事件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"modifier 在事件序列中，modifier 部分的内容可以是以下这些： modifier 含义 Alt 当按下 Alt 按键的时候 Any 1. 表示任何类型的按键被按下的时候 2. 例如 \u003cAny-KeyPress\u003e 表示当用户按下任何按键时触发事件 Control 当按下 Ctrl 按键的时候 Double 1. 当后续两个事件被连续触发的时候 2. 例如 \u003cDouble-Button-1\u003e 表示当用户双击鼠标左键时触发事件 Lock 当打开大写字母锁定键（CapsLock）的时候 Shift 当按下 Shift 按键的时候 Triple 跟 Double 类似，当后续三个事件被连续触发的时候 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"Event 属性 当 Tkinter 去回调你定义的函数的时候，都会带着 Event 对象（作为参数）去调用，Event 对象以下这些属性你可以使用： 属性 含义 widget 产生该事件的组件 x, y 当前的鼠标位置坐标（相对于窗口左上角，像素为单位） x_root, y_root 当前的鼠标位置坐标（相对于屏幕左上角，像素为单位） char 按键对应的字符（键盘事件专属） keysym 按键名，见下方 Key names（键盘事件专属） keycode 按键码，见下方 Key names（键盘事件专属） num 按钮数字（鼠标事件专属） width, height 组件的新尺寸（Configure 事件专属） type 该事件类型 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"Key names 当事件为 \u003cKey\u003e，\u003cKeyPress\u003e，\u003cKeyRelease\u003e 的时候，detail 可以通过设定具体的按键名（keysym）来筛选。例如 表示按下键盘上的大写字母 H 时候触发事件，\u003cKey-Tab\u003e 表示按下键盘上的 Tab 按键的时候触发事件。 下表列举了键盘所有特殊按键的 keysym 和 keycode： （下边按键码是对应美国标准 101 键盘的“Latin-1”字符集，键盘标准不同对应的按键码不同，但按键名是一样的） 按键名（keysym） 按键码（keycode） 代表的按键 Alt_L 64 左边的 Alt 按键 Alt_R 113 右边的 Alt 按键 BackSpace 22 Backspace（退格）按键 Cancel 110 break 按键 Caps_Lock 66 CapsLock（大写字母锁定）按键 Control_L 37 左边的 Ctrl 按键 Control_R 109 右边的 Ctrl 按键 Delete 107 Delete 按键 Down 104 ↓ 按键 End 103 End 按键 Escape 9 Esc 按键 Execute 111 SysReq 按键 F1 67 F1 按键 F2 68 F2 按键 F3 69 F3 按键 F4 70 F4 按键 F5 71 F5 按键 F6 72 F6 按键 F7 73 F7 按键 F8 74 F8 按键 F9 75 F9 按键 F10 76 F10 按键 F11 77 F11 按键 F12 96 F12 按键 Home 97 Home 按键 Insert 106 Insert 按键 Left 100 ← 按键 Linefeed 54 Linefeed（Ctrl + J） KP_0 90 小键盘数字 0 KP_1 87 小键盘数字 1 KP_2 88 小键盘数字 2 KP_3 89 小键盘数字 3 KP_4 83 小键盘数字 4 KP_5 84 小键盘数字 5 KP_6 85 小键盘数字 6 KP_7 79 小键盘数字 7 KP_8 80 小键盘数字 8 KP_9 81 小键盘数字 9 KP_Add 86 小键盘的 + 按键 KP_Begin 84 小键盘的中间按键（5） KP_Decimal 91 小键盘的点按键（.） KP_Delete 91 小键盘的删除键 KP_Divide 112 小键盘的 / 按键 KP_Down 88 小键盘的 ↓ 按键 KP_End 87 小键盘的 End 按键 KP_Enter 108 小键盘的 Enter 按键 KP_Home 79 小键盘的 Home 按键 KP_Insert 90 小键盘的 Insert 按键 KP_Left 83 小键盘的 ← 按键 KP_Multiply 63 小键盘的 * 按键 KP_Next 89 小键盘的 PageDown 按键 KP_Prior 81 小键盘的 PageUp 按键 KP_Right 85 小键盘的 → 按键 KP_Subtract 82 小键盘的 - 按键 KP_Up 80 小键盘的 ↑ 按键 Next 105 PageDown 按键 Num_Lock 77 NumLock（数字锁定）按键 Pause 110 Pause（暂停）按键 Print 111 PrintScrn（打印屏幕）按键 Prior 99 PageUp 按键 Return 36 Enter（回车）按键 Right 102 → 按键 Scroll_Lock 78 ScrollLock 按键 Shift_L 50 左边的 Shift 按键 Shift_R 62 右边的 Shift 按键 Tab 23 Tab（制表）按键 Up 98 ↑ 按键 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"例 # 捕获点击鼠标的位置 import tkinter as tk root = tk.Tk() def callback(event): print(\"点击位置：\", event.x, event.y) frame = tk.Frame(root, width = 200, height = 200) frame.bind(\"\u003cButton-1\u003e\", callback) frame.pack() root.mainloop() # 捕获键盘事件 import tkinter as tk root = tk.Tk() def callback(event): print(\"点击的键盘字符为：\", event.char) frame = tk.Frame(root, width = 200, height = 200) frame.bind(\"\u003cKey\u003e\", callback) frame.focus_set() frame.pack() root.mainloop() # 捕获鼠标在组件上的运动轨迹 import tkinter as tk root = tk.Tk() def callback(event): print(\"当前位置为：\", event.x, event.y) frame = tk.Frame(root, width = 200, height = 200) frame.bind(\"\u003cMotion\u003e\", callback) frame.pack() root.mainloop() 控件 目前有 15 种 Tkinter 的控件。下表简单简单介绍各个控件： 控件 描述 Button 按扭控件：添加按钮 Canvas 画布控件：显示图形元素，用于绘图 Checkbutton 多选框控件：提供多个选项的选择框，嗯用来制作多选题不可少 Entry 输入控件：接受用户的输入 Frame 框架控件：显示一个矩形区域，用于布局美观 Label 标签控件：可以显示文本和位图 LabelFrame 简单的容器控件： 常用于复杂的窗口布局 Listbox 列表框控件：一个选项列表，用户可以从中选择 Menubutton 菜单按钮控件：显示菜单项 Menu 菜单控件：显示菜单栏，下拉菜单和弹出菜单 Message 消息控件：展示一些文字短消息，与Label类似，但更好 Radiobutton 单选按钮控件：显示一个单选的按钮 Scale 范围控件：显示一个数值刻度，为输出限定范围的数字区间 Scrollbar 滚动条控件：为方便查看超出可视化区域的内容 Text 文本控件：显示和处理多行文本 tkMessageBox 显示您应用程序的消息框 Toplevel 容器控件：显示和处理多行文本 Spinbox 输入控件：与Entry类似，但可以指定输入范围值 PanedWindow 窗口布局管理的插件：可以包含一个或者多个子控件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:3:7","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"标签 Label Label（标签）组件用于在屏幕上显示文本或图像。Label 组件仅能显示单一字体的文本，但文本可以跨越多行。另外，还可以为其中的个别字符加上下划线（例如用于表示键盘快捷键）。 import tkinter as tk master = tk.Tk() w = tk.Label(master, text=\"Hello World!\") w.pack() master.mainloop() 如果你没有指定 Label 的大小，那么 Label 的尺寸是正好可以容纳其内容而已 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 Label(master=None, **options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法 选项 含义 activebackground 1. 设置当 Label 处于活动状态（通过 state 选项设置状态）的背景色 2. 默认值由系统指定 activeforeground 1. 设置当 Label 处于活动状态（通过 state 选项设置状态）的前景色 2. 默认值由系统指定 anchor 1. 控制文本（或图像）在 Label 中显示的位置 2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或者 “center” 来定位（ewsn 代表东西南北，上北下南左西右东） 3. 默认值是 “center” background 1. 设置背景颜色 2. 默认值由系统指定 bg 跟 background 一样 bitmap 1. 指定显示到 Label 上的位图 2. 如果指定了 image 选项，则该选项被忽略 borderwidth 1. 指定 Label 的边框宽度 2. 默认值由系统指定，通常是 1 或 2 像素 bd 跟 borderwidth 一样 compound 1. 控制 Label 中文本和图像的混合模式 2. 默认情况下，如果有指定位图或图片，则不显示文本 3. 如果该选项设置为 “center”，文本显示在图像上（文本重叠图像） 4. 如果该选项设置为 “bottom”，“left”，“right” 或 “top”，那么图像显示在文本的旁边（如 “bottom”，则图像在文本的下方） 5. 默认值是 NONE cursor 1. 指定当鼠标在 Label 上飘过的时候的鼠标样式 2. 默认值由系统指定 disabledforeground 1. 指定当 Label 不可用的时候前景色的颜色 2. 默认值由系统指定 font 1. 指定 Label 中文本的字体(注：如果同时设置字体和大小，应该用元组包起来，如（“楷体”, 20） 2. 一个 Label 只能设置一种字体 3. 默认值由系统指定 foreground 1. 设置 Label 的文本和位图的颜色 2. 默认值由系统指定 fg 跟 foreground 一样 height 1. 设置 Label 的高度 2. 如果 Label 显示的是文本，那么单位是文本单元 3. 如果 Label 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Label 的内容计算出高度 highlightbackground 1. 指定当 Label 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定，通常是标准背景颜色 highlightcolor 1. 指定当 Label 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 0（不带高亮边框） image 1. 指定 Label 显示的图片 2. 该值应该是 PhotoImage，BitmapImage，或者能兼容的对象 3. 该选项优先于 text 和 bitmap 选项 justify 1. 定义如何对齐多行文本 2. 使用 “left”，“right” 或 “center” 3. 注意，文本的位置取决于 anchor 选项 4. 默认值是 “center” padx 1. 指定 Label 水平方向上的额外间距（内容和边框间） 2. 单位是像素 pady 1. 指定 Label 垂直方向上的额外间距（内容和边框间） 2. 单位是像素 relief 1. 指定边框样式 2. 默认值是 “flat” 3. 另外你还可以设置 “groove”, “raised”, “ridge”, “solid” 或者 “sunken” state 1. 指定 Label 的状态 2. 这个标签控制 Label 如何显示 3. 默认值是 “normal 4. 另外你还可以设置 “active” 或 “disabled” takefocus 1. 如果是 True，该 Label 接受输入焦点 2. 默认值是 False text 1. 指定 Label 显示的文本 2. 文本可以包含换行符 3. 如果设置了 bitmap 或 image 选项，该选项则被忽略 textvariable 1. Label 显示 Tkinter 变量（通常是一个 StringVar 变量）的内容 2. 如果变量被修改，Label 的文本会自动更新 underline 1. 跟 text 选项一起使用，用于指定哪一个字符画下划线（例如用于表示键盘快捷键） 2. 默认值是 -1 3. 例如设置为 1，则说明在 Button 的第 2 个字符处画下划线 width 1. 设置 Label 的宽度 2. 如果 Label 显示的是文本，那么单位是文本单元 3. 如果 Label 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Label 的内容计算出宽度 wraplength 1. 决定 Label 的文本应该被分成多少行 2. 该选项指定每行的长度，单位是屏幕单元 3. 默认值是 0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"按钮 Button Button（按钮）组件用于实现各种各样的按钮。Button 组件可以包含文本或图像，你可以将一个 Python 的函数或方法与之相关联，当按钮被按下时，对应的函数或方法将被自动执行 Button 组件仅能显示单一字体的文本，但文本可以跨越多行。另外，还可以为其中的个别字符加上下划线（例如用于表示键盘快捷键）。默认情况下，tab 按键被用于在按钮间切换 import tkinter as tk master = tk.Tk() def callback(): print(\"我被调用了！\") b = tk.Button(master, text=\"执行\", command=callback) b.pack() master.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 Button(master=None, **options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 activebackground 1. 设置当 Button 处于活动状态（通过 state 选项设置状态）的背景色 2. 默认值由系统指定 activeforeground 1. 设置当 Button 处于活动状态（通过 state 选项设置状态）的前景色 2. 默认值由系统指定 anchor 1. 控制文本（或图像）在 Button 中显示的位置2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或者 “center” 来定位（ewsn 代表东西南北，上北下南左西右东） 3. 默认值是 “center” background 1. 设置背景颜色 2. 默认值由系统指定 bg 跟 background 一样 bitmap 1. 指定显示到 Button 上的位图 2. 如果指定了 image 选项，则该选项被忽略 borderwidth 1. 指定 Button 的边框宽度 2. 默认值由系统指定，通常是 1 或 2 像素 bd 跟 borderwidth 一样 compound 1. 控制 Button 中文本和图像的混合模式 2. 默认情况下，如果有指定位图或图片，则不显示文本3. 如果该选项设置为 “center”，文本显示在图像上（文本重叠图像） 4. 如果该选项设置为 “bottom”，“left”，“right” 或 “top”，那么图像显示在文本的旁边（如 “bottom”，则图像在文本的下方） 5. 默认值是 NONE cursor 1. 指定当鼠标在 Button 上飘过的时候的鼠标样式 2. 默认值由系统指定 default 1. 如果设置该选项（“normal”），该按钮会被绘制成默认按钮 2. Tkinter 会根据平台的具体指标来绘制（通常就是绘制一个额外的边框） 2. 默认值是 “disable” disabledforeground 1. 指定当 Button 不可用的时候前景色的颜色 2. 默认值由系统指定 font 1. 指定 Button 中文本的字体 2. 一个 Button 只能设置一种字体 3. 默认值由系统指定 foreground 1. 设置 Button 的文本和位图的颜色 2. 默认值由系统指定 fg 跟 foreground 一样 height 1. 设置 Button 的高度 2. 如果 Button 显示的是文本，那么单位是文本单元 3. 如果 Button 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Button 的内容计算出高度 highlightbackground 1. 指定当 Button 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightcolor 1. 指定当 Button 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 0（不带高亮边框） image 1. 指定 Button 显示的图片 2. 该值应该是 PhotoImage，BitmapImage，或者能兼容的对象 3. 该选项优先于 text 和 bitmap 选项 justify 1. 定义如何对齐多行文本2. 使用 “left”，“right” 或 “center” 3. 注意，文本的位置取决于 anchor 选项 4. 默认值是 “center” overrelief 1. 定义当鼠标飘过时 Button 的样式 2. 如果不设置，那么总是使用 relief 选项指定的样式 padx 指定 Button 水平方向上的额外间距（内容和边框间） pady 指定 Button 垂直方向上的额外间距（内容和边框间） relief 1. 指定边框样式 2. 通常当按钮被按下时是 “sunken”，其他时候是 “raised” 3. 另外你还可以设置 “groove”、“ridge” 或 “flat” 4. 默认值是 “raised” repeatdelay 见下方 repeatinterval 选项的描述 repeatinterval 1. 通常当用户鼠标按下按钮并释放的时候系统认为是一次点击动作。如果你希望当用户持续按下按钮的时候（没有松开），根据一定的间隔多次触发按钮，那么你可以设置这个选项。 2. 当用户持续按下按钮的时候，经过 repeatdelay 时间后，每 repeatinterval 间隔就触发一次按钮事件。 3. 例如设置 repeatdelay=1000，repeatinterval=300，则当用户持续按下按钮，在 1 秒的延迟后开始每 300 毫秒触发一次按钮事件，直到用户释放鼠标。 state 1. 指定 Button 的状态 2. 默认值是 “normal” 3. 另外你还可以设置 “active” 或 “disabled” takefocus 1. 指定使用 Tab 键可以将焦点移到该 Button 组件上（这样按下空格键也相当于触发按钮事件） 2. 默认是开启的，可以将该选项设置为 False 避免焦点在此 Button 上 text 1. 指定 Button 显示的文本 2. 文本可以包含换行符 3. 如果设置了 bitmap 或 image 选项，该选项则被忽略 textvariable 1. Button 显示 Tkinter 变量（通常是一个 StringVar 变量）的内容 2. 如果变量被修改，Button 的文本会自动更新 underline 1. 跟 text 选项一起使用，用于指定哪一个字符画下划线（例如用于表示键盘快捷键） 2. 默认值是 -1 3. 例如设置为 1，则说明在 Button 的第 2 个字符处画下划线 width 1. 设置 Button 的宽度 2. 如果 Button 显示的是文本，那么单位是文本单元 3. 如果 Button 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Button 的内容计算出宽度 wraplength 1. 决定 Button 的文本应该被分成多少行 2. 该选项指定每行的长度，单位是屏幕单元 3. 默认值是 0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"方法 flash() – 刷新 Button 组件，该方法将重绘 Button 组件若干次（在 “active” 和 “normal” 状态间切换）。 invoke() – 调用 Button 中 command 选项指定的函数或方法，并返回函数的返回值。 – 如果 Button 的state (状态)是 “disabled”（不可用）或没有指定 command 选项，则该方法无效。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:5:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"多选按钮 Checkbutton Checkbutton（多选按钮）组件用于实现确定是否选择的按钮，当你希望表达“多选多”选项的时候，可以将一系列 Checkbutton 组合起来使用。 from tkinter import * master = Tk() var = IntVar() c = Checkbutton(master, text=\"我是帅锅\", variable=var) c.pack() mainloop() 默认情况下，variable 选项设置为 1 表示选中状态，反之设置为 0 如果你的 Tkinter 代码是放在类中的（在实际编程中你就应该这么干），那么将 variable 选项的值作为属性存储可能是更好的选择： def __init__(self, master): self.var = tk.IntVar() c = tk.Checkbutton(master, text=\"DUANG~\", variable=self.var, command=self.cb) c.pack() def cb(self, event): print \"variable is\", self.var.get() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *Checkbutton(master=None, *options) (class) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 activebackground 1. 设置当 Checkbutton 处于活动状态（通过 state 选项设置状态）的背景色 2. 默认值由系统指定 activeforeground 1. 设置当 Checkbutton 处于活动状态（通过 state 选项设置状态）的前景色 2. 默认值由系统指定 anchor 1. 控制文本（或图像）在 Checkbutton 中显示的位置 2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或者 “center” 来定位（ewsn 代表东西南北，上北下南左西右东） 3. 默认值是 “center” background 1. 设置背景颜色 2. 默认值由系统指定 bg 跟 background 一样 bitmap 1. 指定显示到 Checkbutton 上的位图 2. 如果指定了 image 选项，则该选项被忽略 borderwidth 1. 指定 Checkbutton 的边框宽度 2. 默认值由系统指定，通常是 1 或 2 像素 bd 跟 borderwidth 一样 command 1. 指定于该按钮相关联的函数或方法 2. 当按钮被按下时由 Tkinter 自动调用对应的函数或方法 3. 如果不设置此选项，那么该按钮被按下后啥事儿也不会发生 compound 1. 控制 Checkbutton 中文本和图像的混合模式 2. 默认情况下，如果有指定位图或图片，则不显示文本 3. 如果该选项设置为 “center”，文本显示在图像上（文本重叠图像） 4. 如果该选项设置为 “bottom”，“left”，“right” 或 “top”，那么图像显示在文本的旁边（如 “bottom”，则图像在文本的下方） 5. 默认值是 NONE cursor 1. 指定当鼠标在 Checkbutton 上飘过的时候的鼠标样式 2. 默认值由系统指定 disabledforeground 1. 指定当 Checkbutton 不可用的时候前景色的颜色 2. 默认值由系统指定 font 1. 指定 Checkbutton 中文本的字体 2. 一个 Checkbutton 只能设置一种字体 3. 默认值由系统指定 foreground 1. 设置 Checkbutton 的文本和位图的颜色 2. 默认值由系统指定 fg 跟 foreground 一样 height 1. 设置 Checkbutton 的高度 2. 如果 Checkbutton 显示的是文本，那么单位是文本单元 3. 如果 Checkbutton 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Checkbutton 的内容计算出高度 highlightbackground 1. 指定当 Checkbutton 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定，通常是标准背景颜色 highlightcolor 1. 指定当 Checkbutton 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 1 image 1. 指定 Checkbutton 显示的图片 2. 该值应该是 PhotoImage，BitmapImage，或者能兼容的对象 3. 该选项优先于 text 和 bitmap 选项 indicatoron 1. 指定前边作为选择的小方块是否绘制 2. 默认是绘制的 3. 该选项会影响到按钮的样式，如果设置为 False，则点击后该按钮变成 “sunken”（凹陷），再次点击变为 “raised”（凸起） justify 1. 定义如何对齐多行文本 2. 使用 “left”，“right” 或 “center” 3. 注意，文本的位置取决于 anchor 选项 4. 默认值是 “center” offvalue 1. 默认情况下，variable 选项设置为 1 表示选中状态，反之设置为 0。2. 设置 offvalue 的值可以自定义未选中状态的值（详见上方用法举例） onvalue 1. 默认情况下，variable 选项设置为 1 表示选中状态，反之设置为 0。2. 设置 onvalue 的值可以自定义选中状态的值（详见上方用法举例） padx 1. 指定 Checkbutton 水平方向上的额外间距（内容和边框间） 2. 默认值是 1 pady 1. 指定 Checkbutton 垂直方向上的额外间距（内容和边框间） 2. 默认值是 1 relief 1. 指定边框样式 2. 该值通常是 “flat”，除非你设置 indicatoron 选项为 False 3. 如果 indicatoron 为 False，你还可以设置 “sunken”，“raised”，“groove” 或 “ridge” selectcolor 1. 选择框的颜色（就是打勾勾的那个正方形小框框） 2. 默认值由系统指定 selectimage 1. 设置当 Checkbutton 为选中状态的时候显示的图片 2. 如果没有指定 image 选项，该选项被忽略 state 1. 指定 Checkbutton 的状态 2. 默认值是 “normal” 3. 另外你还可以设置 “active” 或 “disabled” takefocus 1. 如果是 True，该组件接受输入焦点（用户可以通过 tab 键将焦点转移上来） 2. 默认值是 False text 1. 指定 Checkbutton 显示的文本 2. 文本可以包含换行符 3. 如果设置了 bitmap 或 image 选项，该选项则被忽略 textvariable 1. Checkbutton 显示 Tkinter 变量（通常是一个 StringVar 变量）的内容 2. 如果变量被修改，Checkbutton 的文本会自动更新 underline 1. 跟 text 选项一起使用，用于指定哪一个字符画下划线（例如用于表示键盘快捷键） 2. 默认值是 -1 3. 例如设置为 1，则说明在 Checkbutton 的第 2 个字符处画下划线 variable 1. 将 Checkbutton 跟一个 Tkinter 变量关联 2. 当按钮按下时，该变量在 onvalue 和 offvalue 之间切换 3. 这个切换的过程是完全自动的 width 1. 设置 Checkbutton 的宽度 2. 如果 Checkbutton 显示的是文本，那么单位是文本单元 3. 如果 Checkbutton 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Checkbutton 的内容计算出宽度 wraplength 1. 决定 Checkbutton 的文本应该被分成多少行 2. 该选项指定每行的长度，单位是屏幕单元 3. 默认值是 0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:6:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"方法 deselect() – 取消 Checkbutton 组件的选中状态，也就是设置 variable 为 offvalue。 select() – 将 Checkbutton 组件设置为选中状态，也就是设置 variable 为 onvalue。 toggle() – 切换 Checkbutton 组件的状态（选中 -\u003e 未选中 / 未选中 -\u003e 选中） flash() – 刷新 Checkbutton 组件，该方法将重绘 Checkbutton 组件若干次（在\"active” 和 “normal” 状态间切换）。 invoke() – 调用 Checkbutton 中 command 选项指定的函数或方法，并返回函数的返回值。 – 如果 Checkbutton 的state(状态)“disabled\"是 （不可用）或没有指定 command 选项，则该方法无效。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:6:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"单选按钮 Radiobutton Radiobutton（单选按钮）组件用于实现多选一的问题，它几乎总是成组地被使用，其中所有成员共用相同的变量 import tkinter as tk master = tk.Tk() v = tk.IntVar() v.set(2) tk.Radiobutton(master, text=\"One\", variable=v, value=1).pack(anchor=\"w\") tk.Radiobutton(master, text=\"Two\", variable=v, value=2).pack(anchor=\"w\") tk.Radiobutton(master, text=\"Three\", variable=v, value=3).pack(anchor=\"w\") master.mainloop() 如果按钮（选项）比较多，强烈建议您使用以下方式来初始化 Radiobutton 组件： import tkinter as tk master = tk.Tk() GIRLS = [ (\"西施\", 1), (\"王昭君\", 2), (\"貂蝉\", 3), (\"杨玉环\", 4)] v = tk.IntVar() for girl, num in GIRLS: b = tk.Radiobutton(master, text=girl, variable=v, value=num) b.pack(anchor=\"w\") master.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 Radiobutton(master=None, **options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 activebackground 1. 设置当 Radiobutton 处于活动状态（通过 state 选项设置状态）的背景色 2. 默认值由系统指定 activeforeground 1. 设置当 Radiobutton 处于活动状态（通过 state 选项设置状态）的前景色 2. 默认值由系统指定 anchor 1. 控制文本（或图像）在 Radiobutton 中显示的位置 2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或者 “center” 来定位（ewsn 代表东西南北，上北下南左西右东） 3. 默认值是 “center” background 1. 设置背景颜色 2. 默认值由系统指定 bg 跟 background 一样 bitmap 1. 指定显示到 Radiobutton 上的位图 2. 如果指定了 image 选项，则该选项被忽略 borderwidth 1. 指定 Radiobutton 的边框宽度 2. 默认值由系统指定，通常是 1 或 2 像素 bd 跟 borderwidth 一样 command 1. 指定于该按钮相关联的函数或方法 2. 当按钮被按下时由 Tkinter 自动调用对应的函数或方法 3. 如果不设置此选项，那么该按钮被按下后啥事儿也不会发生 compound 1. 控制 Radiobutton 中文本和图像的混合模式 2. 默认情况下，如果有指定位图或图片，则不显示文本 3. 如果该选项设置为 “center”，文本显示在图像上（文本重叠图像） 4. 如果该选项设置为 “bottom”，“left”，“right” 或 “top”，那么图像显示在文本的旁边（如 “bottom”，则图像在文本的下方） 5. 默认值是 NONE cursor 1. 指定当鼠标在 Radiobutton 上飘过的时候的鼠标样式 2. 默认值由系统指定 disabledforeground 1. 指定当 Radiobutton 不可用的时候前景色的颜色 2. 默认值由系统指定 font 1. 指定 Radiobutton 中文本的字体 2. 一个 Radiobutton 只能设置一种字体 3. 默认值由系统指定 foreground 1. 设置 Radiobutton 的文本和位图的颜色 2. 默认值由系统指定 fg 跟 foreground 一样 height 1. 设置 Radiobutton 的高度 2. 如果 Radiobutton 显示的是文本，那么单位是文本单元 3. 如果 Radiobutton 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Radiobutton 的内容计算出高度 highlightbackground 1. 指定当 Radiobutton 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定，通常是标准背景颜色 highlightcolor 1. 指定当 Radiobutton 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值由系统指定，通常是 1 或 2 像素 image 1. 指定 Radiobutton 显示的图片 2. 该值应该是 PhotoImage，BitmapImage，或者能兼容的对象 3. 该选项优先于 text 和 bitmap 选项 indicatoron 1. 指定前边作为选择的小圆圈是否绘制 2. 默认是绘制的 3. 该选项会影响到按钮的样式，如果设置为 False，则点击后该按钮变成 “sunken”（凹陷），再次点击变为 “raised”（凸起） justify 1. 定义如何对齐多行文本 2. 使用 “left”，“right” 或 “center” 3. 注意，文本的位置取决于 anchor 选项 4. 默认值是 “center” padx 1. 指定 Radiobutton 水平方向上的额外间距（内容和边框间） 2. 默认值是 1 pady 1. 指定 Radiobutton 垂直方向上的额外间距（内容和边框间） 2. 默认值是 1 relief 1. 指定边框样式 2. 可以设置 “sunken”，“raised”，“groove”，“ridge” 或 “flat” 3. 如果 indicatoron 选项设置为 True，则默认值是 “flat”，否则为 “raised” selectcolor 1. 选择框的颜色 2. 默认值由系统指定 selectimage 1. 设置当 Radiobutton 为选中状态的时候显示的图片 2. 如果没有指定 image 选项，该选项被忽略 state 1. 指定 Radiobutton 的状态 2. 默认值是 “normal” 3. 另外你还可以设置 “active” 或 “disabled” takefocus 1. 如果是 True，该组件接受输入焦点（用户可以通过 tab 键将焦点转移上来） 2. 默认值是 False text 1. 指定 Radiobutton 显示的文本 2. 文本可以包含换行符 3. 如果设置了 bitmap 或 image 选项，该选项则被忽略 textvariable 1. Radiobutton 显示 Tkinter 变量（通常是一个 StringVar 变量）的内容 2. 如果变量被修改，Radiobutton 的文本会自动更新 underline 1. 跟 text 选项一起使用，用于指定哪一个字符画下划线（例如用于表示键盘快捷键） 2. 默认值是 -1 3. 例如设置为 1，则说明在 Radiobutton 的第 2 个字符处画下划线 value 1. 标志该单选按钮的值 2. 在同一组中的所有按钮应该拥有各不相同的值 3. 通过将该值与 variable 选项的值对比，即可判断用户选中了哪个按钮 variable 1. 与 Radiobutton 组件关联的变量 2. 同一组中的所有按钮的 variable 选项应该都指向同一个变量 3. 通过将该变量与 value 选项的值对比，即可判断用户选中了哪个按钮 width 1. 设置 Radiobutton 的宽度 2. 如果 Radiobutton 显示的是文本，那么单位是文本单元 3. 如果 Radiobutton 显示的是图像，那么单位是像素（或屏幕单元） 4. 如果设置为 0 或者干脆不设置，那么会自动根据 Radiobutton 的内容计算出宽度 wraplength 1. 决定 Radiobutton 的文本应该被分成多少行 2. 该选项指定每行的长度，单位是屏幕单元 3. 默认值是 0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:7:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"方法 deselect() – 取消该按钮的选中状态。 select() – 将 Radiobutton 组件设置为选中状态。 flash() – 刷新 Radiobutton 组件，该方法将重绘 Radiobutton 组件若干次（在\"active” 和 “normal” 状态间切换）。 – 该方法在调试的时候很有用，也可以使用此方法提醒用户激活了该按钮。 invoke() – 调用 Radiobutton 中 command 选项指定的函数或方法，并返回函数的返回值。 – 如果 Radiobutton 的 state(状态)“disabled\"是 （不可用）或没有指定 command 选项，则该方法无效。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:7:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"框架 Frame Frame（框架）组件是在屏幕上的一个矩形区域。Frame 主要是作为其他组件的框架基础，或为其他组件提供间距填充 Frame 组件主要用于在复杂的布局中将其他组件分组，也用于填充间距和作为实现高级组件的基类 import tkinter as tk master = tk.Tk() tk.Label(text=\"天王盖地虎\").pack() separator = tk.Frame(height=2, bd=1, relief=\"sunken\") separator.pack(fill=\"x\", padx=5, pady=5) tk.Label(text=\"小鸡炖蘑菇\").pack() master.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 Frame(master=None, **options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 background 1. 设置 Frame 组件的背景颜色 2. 默认值由系统指定 3. 为了防止更新，可以将颜色值设置为空字符串 bg 跟 background 一样 borderwidth 1. 指定 Frame 的边框宽度 2. 默认值是 0 bd 跟 borderwidth 一样 class_ 默认值是 Frame colormap 1. 有些显示器只支持 256 色（有些可能更少），这种显示器通常提供一个颜色映射来指定要使用要使用的 256 种颜色 2. 该选项允许你指定用于该组件以及其子组件的颜色映射 3. 默认情况下，Frame 使用与其父组件相同的颜色映射 4. 使用此选项，你可以使用其他窗口的颜色映射代替（两窗口必须位于同个屏幕并且具有相同的视觉特性） 5. 你也可以直接使用 “new” 为 Frame 组件分配一个新的颜色映射 6. 一旦创建 Frame 组件实例，你就无法修改这个选项的值 container 1. 该选项如果为 True，意味着该窗口将被用作容器，一些其它应用程序将被嵌入 2. 默认值是 False cursor 1. 指定当鼠标在 Frame 上飘过的时候的鼠标样式 2. 默认值由系统指定 height 1. 设置 Frame 的高度 2. 默认值是 0 highlightbackground 1. 指定当 Frame 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定，通常是标准背景颜色 highlightcolor 1. 指定当 Frame 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 0（不带高亮边框） padx 水平方向上的边距 pady 垂直方向上的边距 relief 1. 指定边框样式 2. 默认值是 “flat” 3. 另外你还可以设置 “sunken”，“raised”，“groove” 或 “ridge” 4. 注意，如果你要设置边框样式，记得设置 borderwidth 或 bd 选项不为 0，才能看到边框 takefocus 1. 指定该组件是否接受输入焦点（用户可以通过 tab 键将焦点转移上来） 2. 默认值是 False visual 1. 为新窗口指定视觉信息 2. 该选项没有默认值 width 1. 设置 Frame 的宽度 2. 默认值是 0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:8:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"标签框架 LabelFrame LabelFrame 组件是 Frame 组件的变体。默认情况下，LabelFrame 会在其子组件的周围绘制一个边框以及一个标题 当你想要将一些相关的组件分为一组的时候，可以使用 LabelFrame 组件，比如一系列 Radiobutton（单选按钮）组件 import tkinter as tk master = tk.Tk() group = tk.LabelFrame(master, text=\"你从哪里得知CSDN？\", padx=5, pady=5) group.pack(padx=10, pady=10) v = tk.IntVar() r1 = tk.Radiobutton(group, text=\"同学/同事介绍\", variable=v, value=1).pack(anchor=\"w\") r2 = tk.Radiobutton(group, text=\"老婆大人介绍\", variable=v, value=2).pack(anchor=\"w\") r3 = tk.Radiobutton(group, text=\"老师/学长介绍\", variable=v, value=3).pack(anchor=\"w\") master.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 LabelFrame(master=None, **options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 background 1. 设置 LabelFrame 组件的背景颜色 2. 默认值由系统指定 3. 为了防止更新，可以将颜色值设置为空字符串 bg 跟 background 一样 borderwidth 1. 指定 LabelFrame 的边框宽度 2. 默认值是 2 像素 bd 跟 borderwidth 一样 class 默认值是 LabelFrame colormap 1. 有些显示器只支持 256 色（有些可能更少），这种显示器通常提供一个颜色映射来指定要使用要使用的 256 种颜色 2. 该选项允许你指定用于该组件以及其子组件的颜色映射 3. 默认情况下，Frame 使用与其父组件相同的颜色映射 4. 使用此选项，你可以使用其他窗口的颜色映射代替（两窗口必须位于同个屏幕并且具有相同的视觉特性） 5. 你也可以直接使用 “new” 为 Frame 组件分配一个新的颜色映射 6. 一旦创建 Frame 组件实例，你就无法修改这个选项的值 container 1. 该选项如果为 True，意味着该窗口将被用作容器，一些其它应用程序将被嵌入 2. 默认值是 False cursor 1. 指定当鼠标在 LabelFrame 上飘过的时候的鼠标样式 2. 默认值由系统指定 foreground 1. 设置 LabelFrame 的文本颜色 2. 默认值由系统指定 fg 跟 foreground 一样 font 1. 指定 LabelFrame 中文本的字体 2. 默认值由系统指定 height 1. 设置 LabelFrame 的高度 2. 单位是像素 highlightbackground 1. 指定当 LabelFrame 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定，通常是标准背景颜色 highlightcolor 1. 指定当 LabelFrame 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 1 或 2 像素 labelanchor 1. 控制文本在 LabelFrame 的显示位置 2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或 “center” 来定位（ewsn代表东西南北，上北下南左西右东） 3. 默认值是 NW labelwidget 1. 指定一个组件替代默认的文本 Label 2. 如果同时设置此选项和 text 选项，则忽略 text 选项的内容 padx 1. 指定 FrameLabel 水平方向上的额外间距（内容和边框间） 2. 默认值是 0 pady 1. 指定 FrameLabel 垂直方向上的额外间距（内容和边框间） 2. 默认值是 0 relief 1. 指定边框样式 2. 默认值是 “groove” 3. 另外你还可以设置 “flat”，“sunken”，“raised” 或 “ridge” 4. 注意，如果你要设置边框样式，记得设置 borderwidth 或 bd 选项不为 0，才能看到边框 takefocus 1. 指定该组件是否接受输入焦点（用户可以通过 tab 键将焦点转移上来） 2. 默认值是 False text 1. 指定 LabelFrame 显示的文本 2. 文本可以包含换行符 visual 1. 为新窗口指定视觉信息 2. 该选项没有默认值 width 1. 设置 LabelFrame 的宽度 2. 默认值是 0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:9:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"输入框 Entry Entry（输入框）组件通常用于获取用户的输入文本。 Entry 组件仅允许用于输入一行文本，如果用于输入的字符串长度比该组件可显示空间更长，那内容将被滚动。这意味着该字符串将不能被全部看到（你可以用鼠标或键盘的方向键调整文本的可见范围）。 import tkinter as tk master = tk.Tk() e = tk.Entry(master) e.pack(padx=20, pady=20) e.delete(0, \"end\") e.insert(0, \"默认文本...\") master.mainloop() Entry 组件允许通过以下几种方式指定字符的位置 数字索引号：常规的 Python 索引号，从 0 开始 “anchor”：对应第一个被选中的字符（如果有的话） “end”：对应已存在文本的后一个位置 “insert”：对应插入光标的当前位置 使用鼠标坐标（\"@x”）：x 是鼠标位置与 Entry 左侧边缘的水平距离，这样就可以通过鼠标相对地定位字符的位置 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *Entry(master=None, *options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 background 1. 设置 Entry 的背景颜色 2. 默认值由系统指定 bg 跟 background 一样 borderwidth 1. 设置 Entry 的边框宽度 2. 默认值是 1 或 2 像素 bd 跟 borderwidth 一样 cursor 1. 指定当鼠标在 Entry 上飘过的时候的鼠标样式 2. 默认值由系统指定 exportselection 1. 指定选中的文本是否可以被复制到剪贴板 2. 默认值是 True 3. 可以修改为 False 表示不允许复制文本 font 1. 指定 Entry 中文本的字体 2. 默认值由系统指定 foreground 1. 设置 Entry 的文本颜色 2. 默认值由系统指定 fg 跟 foreground 一样 highlightbackground 1. 指定当 Entry 没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightcolor 1. 指定当 Entry 获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 1 或 2 像素 insertbackground 指定输入光标的颜色 insertborderwidth 1. 指定输入光标的边框宽度 2. 如果被设置为非 0 值，光标样式会被设置为 RAISED 3. 小甲鱼温馨提示：将 insertwidth 设置大一点才能看到效果哦 insertofftime 1. 该选项控制光标的闪烁频率（灭） 2. 单位是毫秒 insertontime 1. 该选项控制光标的闪烁频率（亮） 2. 单位是毫秒 insertwidth 1. 指定光标的宽度 2. 默认值是 1 或 2 像素 invalidcommand 1. 指定当输入框输入的内容“非法”时调用的函数 2. 也就是指定当 validateCommand 选项指定的函数返回 False 时的函数 3. 详见本内容最下方小甲鱼关于验证详解 invcmd 跟 invalidcommand 一样 justify 1. 定义如何对齐输入框中的文本 2. 使用 “left”，“right” 或 “center” 3. 默认值是 “left” relief 1. 指定边框样式 2. 默认值是 “sunken” 3. 其他可以选择的值是 “flat”，“raised”，“groove” 和 “ridge” selectbackground 1. 指定输入框的文本被选中时的背景颜色 2. 默认值由系统指定 selectborderwidth 1. 指定输入框的文本被选中时的边框宽度（选中边框） 2. 默认值由系统指定 selectforeground 1. 指定输入框的文本被选中时的字体颜色 2. 默认值由系统指定 show 1. 设置输入框如何显示文本的内容 2. 如果该值非空，则输入框会显示指定字符串代替真正的内容 3. 将该选项设置为 “*\"，则是密码输入框 state 1. Entry 组件可以设置的状态：“normal”，“disabled” 或 “readonly”（注意，它跟 “disabled” 相似，但它支持选中和拷贝，只是不能修改，而 “disabled” 是完全禁止） 2. 默认值是 “normal” 3. 注意，如果此选项设置为 “disabled” 或 “readonly”，那么调用 insert() 和 delete() 方法都会被忽略 takefocus 1. 指定使用 Tab 键可以将焦点移动到输入框中 2. 默认是开启的，可以将该选项设置为 False 避免焦点在此输入框中 textvariable 1. 指定一个与输入框的内容相关联的 Tkinter 变量（通常是 StringVar） 2. 当输入框的内容发生改变时，该变量的值也会相应发生改变 validate 1. 该选项设置是否启用内容验证 2. 详见本内容最下方小甲鱼关于验证详解 validatecommand 1. 该选项指定一个验证函数，用于验证输入框内容是否合法 2. 验证函数需要返回 True 或 False 表示验证结果 3. 注意，该选项只有当 validate 的值非 “none” 时才有效 3. 详见本内容最下方小甲鱼关于验证详解 vcmd 跟 validatecommand 一样 width 1. 设置输入框的宽度，以字符为单位 2. 默认值是 20 3. 对于变宽字体来说，组件的实际宽度等于字体的平均宽度乘以 width 选项的值 xscrollcommand 1. 与 scrollbar（滚动条）组件相关联 2. 如果你觉得用户输入的内容会超过该组件的输入框宽度，那么可以考虑设置该选项 3. 使用方法可以参考：Scrollbar 组件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:10:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"方法 delete(first, last=None) – 删除参数 first 到 last 范围内（包含 first 和 last）的所有内容 – 如果忽略 last 参数，表示删除 first 参数指定的选项 – 使用 delete(0, END) 实现删除输入框的所有内容 get() – 获得当前输入框的内容 index(index) – 返回与 index 参数相应的选项的序号（例如 e.index(END)） insert(index, text) – 将 text 参数的内容插入到 index 参数指定的位置 – 使用 insert(INSERT, text) 将 text 参数指定的字符串插入到光标的位置 – 使用 insert(END, text) 将 text 参数指定的字符串插入到输入框的末尾 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:10:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"文本 Text Text（文本）组件用于显示和处理多行文本。在 Tkinter 的所有组件中，Text 组件显得异常强大和灵活，适用于多种任务。虽然该组件的主要目的是显示多行文本，但它常常也被用于作为简单的文本编辑器和网页浏览器使用 import tkinter as tk root = tk.Tk() text = tk.Text(root) text.pack() # \"insert\" 索引表示插入光标当前的位置 text.insert(\"insert\", \"I love \") text.insert(\"end\", \"Python.com!\") root.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *Text(master=None, *options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 autoseparators 1. 指定实现“撤销”操作的时候是否自动插入一个“分隔符”（用于分隔操作记录） 2. 默认值是 True 3. 详见上方用法【“撤销”和“恢复”操作】 background 1. 设置 Text 组件的背景颜色 2. 注意：通过使用 Tags 可以使 Text 组件中的文本支持多种背景颜色显示（请参考上方【Tags 用法】） bg 跟 background 一样 borderwidth 1. 设置 Entry 的边框宽度 2. 默认值是 1 像素 bd 跟 borderwidth 一样 cursor 1. 指定当鼠标在 Text 组件上飘过的时候的鼠标样式 2. 默认值由系统指定 exportselection 1. 指定选中的文本是否可以被复制到剪贴板 2. 默认值是 True 3. 可以修改为 False 表示不允许复制文本 font 1. 设置 Text 组件中文本的默认字体 2. 注意：通过使用 Tags 可以使 Text 组件中的文本支持多种字体显示（请参考上方【Tags 用法】） foreground 1. 设置 Text 组件中文本的颜色 2. 注意：通过使用 Tags 可以使 Text 组件中的文本支持多种颜色显示（请参考上方【Tags 用法】） fg 跟 foreground 一样 height 1. 设置 Text 组件的高度 2. 注意：单位是行数，不是像素噢 highlightbackground 1. 指定当 Text 组件没有获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightcolor 1. 指定当 Text 组件获得焦点的时候高亮边框的颜色 2. 默认值由系统指定 highlightthickness 1. 指定高亮边框的宽度 2. 默认值是 0 insertbackground 1. 设置插入光标的颜色 2. 默认是 BLACK（或 “black”） insertborderwidth 1. 设置插入光标的边框宽度 2. 默认值是 0 3. 提示：你得设置 insertwidth 选项为比较大的数值才能看出来噢 insertofftime 1. 该选项控制光标的闪烁频率（灭） 2. 单位是毫秒 insertontime 1. 该选项控制光标的闪烁频率（亮） 2. 单位是毫秒 insertwidth 1. 指定光标的宽度 2. 默认值是 2 像素 maxundo 1. 设置允许“撤销”操作的最大次数 2. 默认值是 0 3. 设置为 -1 表示不限制 padx 1. 指定水平方向上的额外间距（内容和边框间） 2. 默认值是 1 pady 1. 指定垂直方向上的额外间距（内容和边框间） 2. 默认值是 1 relief 1. 指定边框样式 2. 默认值是 “sunken” 3. 其他可以选择的值是 “flat”，“raised”，“groove” 和 “ridge” selectbackground 1. 指定被选中文本的背景颜色 2. 默认值由系统指定 selectborderwidth 1. 指定被选中文本的边框宽度 2. 默认值是 0 selectforeground 1. 指定被选中文本的字体颜色 2. 默认值由系统指定 setgrid 1. 指定一个布尔类型的值，确定是否启用网格控制 2. 默认值是 False spacing1 1. 指定 Text 组件的文本块中每一行与上方的空白间隔 2. 注意：自动换行不算 3. 默认值是 0 spacing2 1. 指定 Text 组件的文本块中自动换行的各行间的空白间隔 2. 注意：换行符（’\\n’）不算 3. 默认值是 0 spacing3 1. 指定 Text 组件的文本中每一行与下方的空白间隔 2. 注意：自动换行不算 3. 默认值是 0 state 1. 默认情况下 Text 组件响应键盘和鼠标事件（“normal”） 2. 如果将该选项的值设置为 “disabled”，那么上述响应就不会发生，并且你无法修改里边的内容 tabs 1. 定制 Tag 所描述的文本块中 Tab 按键的功能 2. 默认 Tab 被定义为 8 个字符的宽度 3. 你还可以定义多个制表位：tabs=(‘3c’, ‘5c’, ‘12c’) 表示前 3 个 Tab 宽度分别为 3厘米，5厘米，12厘米，接着的 Tab 按照最后两个的差值计算，即：19厘米，26厘米，33厘米 4. 你应该注意到了，它上边 ‘c’ 的含义是“厘米”而不是“字符”，还可以选择的单位有 ‘i’（英寸），’m’（毫米）和 ‘p’（DPI，大约是 ‘1i’ 等于 ‘72p’） 5. 如果是一个整型值，则单位是像素 takefocus 1. 指定使用 Tab 键可以将焦点移动到 Text 组件中 2. 默认是开启的，可以将该选项设置为 False 避免焦点在此 Text 组件中 undo 1. 该选项设置为 True 开启“撤销”功能 2. 该选项设置为 False 关闭“撤销”功能 3. 默认值是 False width 1. 设置 Text 组件的宽度 2. 注意：单位是字符数，因此 Text 组件的实际宽度还取决于字体的大小 wrap 1. 设置当一行文本的长度超过 width 选项设置的宽度时，是否自动换行 2. 该选项的值可以是：“none”（不自动换行），“char”（按字符自动换行）和 “word”（按单词自动换行） xscrollcommand 1. 与 scrollbar（滚动条）组件相关联（水平方向） 2. 使用方法可以参考：Scrollbar 组件 yscrollcommand 1. 与 scrollbar（滚动条）组件相关联（垂直方向） 2. 使用方法可以参考：Scrollbar 组件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:11:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"方法 bbox(index) – 返回给定索引指定的字符的边界框 – 返回值是一个 4 元组：(x, y, width, height) – 如果该字符是不可见的，那么返回 None – 注意：只有当 Text 组件被更新的时候该方法才有效，可以使用 update_idletasks() 方法先更新 Text 组件 compare(index1, op, index2) – 返回对比 index1 和 index2 指定的两个字符的结果 – op 是操作符：’\u003c’, ‘\u003c=’, ‘==’, ‘\u003e=’, ‘\u003e’ 或 ‘!=’（不支持 Python 的 ‘\u003c\u003e’ 操作符） – 返回布尔类型的值表示对比的结果 debug(boolean=None) – 开启或关闭 Debug 状态 delete(start, end=None) – 删除给定范围的文本或嵌入对象 – 如果在给定范围内有任何 Marks 标记的位置，则将 Marks 移动到 start 参数开始的位置 dlineinfo(index) – 返回给定索引指定的字符所在行的边界框 – 返回值是一个 5 元组：(x, y, width, height, offset)，offset 表示从该行的顶端到基线的偏移 – 如果该行不可见，则返回 None – 注意：只有当 Text 组件被更新的时候该方法才有效，可以使用 update_idletasks() 方法先更新 Text 组件 *dump(index1, index2=None, command=None, *kw) – 返回 index1 和 index2 之间的内容 – 返回的值是一个由 3 元组（关键词，值，索引）组成的列表，关键词参数的顺序为：all, image, mark, tag, text, window – 默认关键词是 ‘all’，表示全部关键词均为选中状态 – 如果需要筛选个别关键词，可以用 dump(index1, index2, image=True, text=True) 这样的形式调用 – 如果指定了 command 函数，那么会为列表中的每一个三元组作为参数调用一次该函数（这种情况下，dump() 不返回值） edit_modified(arg=None) – 该方法用于查询和设置 modified 标志（该标标志用于追踪 Text 组件的内容是否发生变化） – 如果不指定 arg 参数，那么返回 modified 标志是否被设置 – 你可以传递显式地使用 True 或 False 作为参数来设置或清除 modified 标志 – 任何代码或用户的插入或删除文本操作，“撤销”或“恢复”操作，都会是的 modified 标志被设置 edit_redo(self) – “恢复”上一次的“撤销”操作 – 如果 undo 选项为 False，该方法无效 – 详见上方用法【“撤销”和“恢复”操作】 edit_reset() – 清空存放操作记录的栈 edit_separator() – 插入一个“分隔符”到存放操作记录的栈中，用于表示已经完成一次完整的操作 – 如果 undo 选项为 False，该方法无效 – 详见上方用法【“撤销”和“恢复”操作】 edit_undo() – 撤销最近一次操作 – 如果 undo 选项为 False，该方法无效 – 详见上方用法【“撤销”和“恢复”操作】 get(index1, index2=None) – 返回 index1 到 index2（不包含）之间的文本 – 如果 index2 参数忽略，则返回一个字符 – 如果包含 image 和 window 的嵌入对象，均被忽略 – 如果包含有多行文本，那么自动插入换行符（’\\n’） image_cget(index, option) – 返回 index 参数指定的嵌入 image 对象的 option 选项的值 – 如果给定的位置没有嵌入 image 对象，则抛出 TclError 异常 *image_configure(index, *options) – 修改 index 参数指定的嵌入 image 对象的一个或多个 option 选项的值 – 如果给定的位置没有嵌入 image 对象，则抛出 TclError 异常 *image_create(index, cnf={}, *kw) – 在 index 参数指定的位置嵌入一个 image 对象 – 该 image 对象必须是 Tkinter 的 PhotoImage 或 BitmapImage 实例 – 可选选项 align：设定此图像的垂直对齐，可以是 “top”、“center”、“bottom” 或 “baseline” – 可选选项 image：PhotoImage 或 BitmapImage 对象 – 可选选项 name：你可以为该图像实例命名，如果你忽略此选项，那么 Tkinter 会自动为其取一个独一无二的名字。 – 可选选项 padx：设置水平方向上的额外间距 – 可选选项 pady：设置垂直方向上的额外间距 image_names() – 返回 Text 组件中嵌入的所有 image 对象的名字 index(index) – 将 index 参数指定的位置以 “line.column” 的索引形式返回 – index 参数支持任何格式的索引 insert(index, text, *tags) – 在 index 参数指定的位置插入字符串 – 可选参数 tags 用于指定文本的样式 – 详见上方【Tags 用法】 mark_gravity(self, markName, direction=None) – 设置 Mark 的方向，可以是 “left” 或 “right”（默认是 “right”，即如果在 Mark 处插入文本的话，Mark 将发生相应的移动以保持在插入文本的右侧） – 如果设置为 “left”，那么在 Mark 处插入文本并不会移动 Mark（因为 Mark 在插入文本的左侧） – 如果忽略 direction 参数，则返回指定 Mark 的方向 – 详见上方【Marks 用法】 mark_names() – 返回 Text 组件中所有 Marks 的名字 – 包括两个特殊 Mark：“insert” 和 “current” – 注意：“end” 是特殊的索引，不是 Mark mark_next(index) – 返回在 index 指定的位置后边的一个 Mark 的名字 – 如果不存在则返回空字符串 mark_previous(index) – 返回在 index 指定的位置前边的一个 Mark 的名字 – 如果不存在则返回空字符串 mark_set(markName, index) – 移动 Mark 到 index 参数指定的位置 – 如果 markName 参数指定的 Mark 不存在，则创建一个新的 Mark mark_unset(*markNames) – 删除 markNames 指定的 Marks – 不能删除预定义的 “insert” 和 “current” replace(index1, index2, chars, *args) – 将 index1 到 index2 之间的内容替换为 chars 参数指定的字符串 – 如果需要为替换的内容添加 Tag，可以在 args 参数指定 Tag – 详见上方【Tags 用法】 scan_dragto(x, y) – 详见下方 scan_mark(x, y) scan_mark(x, y) – 使用这种方式来实现 Text 组件内容的滚动 – 需要将鼠标按钮事件以及鼠标当前位置绑定到 scan_mark(x, y) 方法，然后将 事件及当前鼠标位置绑定到 scan_dragto(x, y) 方法，就可以实现 Text 组件的内容在当前位置和 scan_mark(x, y) 指定的位置 (x, y) 之间滚动 search(pattern, index, stopindex=None, forwards=None, backwards=None, exact=None, regexp=None, nocase=None, count=None) – 从 index 开始搜索 pattern，到 stopindex 结束（不指定表示搜索到末尾） – 如果成功找到，以 “line.column” 返回第一个匹配的字符；否则返回空字符串 – forwards 参数设置为 True 表示向前（-\u003e）搜索 – backwards 参数设置为 True 表示向后（\u003c-）搜索 – exact 参数设置为 True 表示搜索与 pattern 完全匹配的结果 – regexp 参数设置为 True，则 pattern 被解释为 Tcl 格式的正则表达式 – nocase 参数设置为 True 是忽略大小写，默认是区分大小写的搜索 – count 参数指定为一个 IntVar 的 Tkinter 变量，用于存放当找到匹配的字符个数（如果匹配结果中没有嵌入的 image 或 window 对象的话，一般该值等于 pattern 的字符个数） see(index) – 滚动内容，确保 index 指定的位置可见 tag_add(tagName, index1, index2=None) – 为 index1 到 index2 之间的内容添加一个 Tag（tagName 参数指定） – 如果 index2 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:11:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"顶层窗口 Toplevel Toplevel（顶级窗口）组件类似于 Frame 组件，但 Toplevel 组件是一个独立的顶级窗口，这种窗口通常拥有标题栏、边框等部件 Toplevel 组件通常用在显示额外的窗口、对话框和其他弹出窗口上 import tkinter as tk root = tk.Tk() def create(): top = tk.Toplevel() top.title(\"Python\") msg = tk.Message(top, text=\"I love Python!\") msg.pack() tk.Button(root, text=\"创建顶级窗口\", command=create).pack() root.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:12:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *Toplevel(master=None, *options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 background 1. 设置背景颜色 2. 默认值由系统指定 3. 为了防止更新，可以将颜色值设置为空字符串 bg 跟 background 一样 borderwidth 设置边框宽度 bd 跟 borderwidth 一样 class_ 默认值是 Toplevel colormap 1. 有些显示器只支持 256 色（有些可能更少），这种显示器通常提供一个颜色映射来指定要使用要使用的 256 种颜色 2. 该选项允许你指定用于该组件以及其子组件的颜色映射 3. 默认情况下，Toplevel 使用与其父组件相同的颜色映射 4. 使用此选项，你可以使用其他窗口的颜色映射代替（两窗口必须位于同个屏幕并且具有相同的视觉特性） 5. 你也可以直接使用 “new” 为 Toplevel 组件分配一个新的颜色映射 6. 一旦创建 Toplevel 组件实例，你就无法修改这个选项的值 container 1. 该选项如果为 True，意味着该窗口将被用作容器，一些其它应用程序将被嵌入 2. 默认值是 False cursor 1. 指定当鼠标在 Toplevel 上飘过的时候的鼠标样式 2. 默认值由系统指定 height 设置高度 highlightbackground 指定当 Toplevel 没有获得焦点的时候高亮边框的颜色 highlightcolor 指定当 Toplevel 获得焦点的时候高亮边框的颜色 highlightthickness 指定高亮边框的宽度 menu 设置该选项为 Toplevel 窗口提供菜单栏 padx 水平方向上的边距 pady 垂直方向上的边距 relief 1. 指定边框样式 2. 默认值是 “flat” 3. 另外你还可以设置 “sunken”，“raised”，“groove” 或 “ridge” 4. 注意，如果你要设置边框样式，记得设置 borderwidth 或 bd 选项不为 0，才能看到边框 takefocus 1. 指定该组件是否接受输入焦点（用户可以通过 tab 键将焦点转移上来） 2. 默认值是 False width 设置宽度 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:12:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"菜单 Menu Menu（菜单）组件用于实现顶级菜单、下拉菜单和弹出菜单 import tkinter as tk root = tk.Tk() def callback(): print(\"~被调用了~\") # 创建一个顶级菜单 menubar = tk.Menu(root) # 创建一个下拉菜单“文件”，然后将它添加到顶级菜单中 filemenu = tk.Menu(menubar, tearoff=False) filemenu.add_command(label=\"打开\", command=callback) filemenu.add_command(label=\"保存\", command=callback) filemenu.add_separator() filemenu.add_command(label=\"退出\", command=root.quit) menubar.add_cascade(label=\"文件\", menu=filemenu) # 创建另一个下拉菜单“编辑”，然后将它添加到顶级菜单中 editmenu = tk.Menu(menubar, tearoff=False) editmenu.add_command(label=\"剪切\", command=callback) editmenu.add_command(label=\"拷贝\", command=callback) editmenu.add_command(label=\"粘贴\", command=callback) menubar.add_cascade(label=\"编辑\", menu=editmenu) # 显示菜单 root.config(menu=menubar) root.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:13:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *Menu(master=None, *options) master – 父组件 **options – 组件选项，下方表格详细列举了各个选项的具体含义和用法： 选项 含义 activebackground 设置当 Menu 处于 “active” 状态（通过 state 选项设置状态）的背景色 activeborderwidth 设置当 Menu 处于 “active” 状态（通过 state 选项设置状态）的边框宽度 activeforeground 设置当 Menu 处于 “active” 状态（通过 state 选项设置状态）的前景色 background 设置背景颜色 bg 跟 background 一样 borderwidth 指定边框宽度 bd 跟 borderwidth 一样 cursor 指定当鼠标在 Menu 上飘过的时候的鼠标样式 disabledforeground 指定当 Menu 处于 “disabled” 状态的时候的前景色 font 指定 Menu 中文本的字体 foreground 设置 Menu 的前景色 fg 跟 foreground 一样 postcommand 将此选项与一个方法相关联，当菜单被打开的时候该方法将自动被调用 relief 1. 指定边框样式 2. 默认值是 “flat” 3. 另外你还可以设置 “sunken”，“raised”，“groove” 或 “ridge” selectcolor 指定当菜单项显示为单选按钮或多选按钮时选择中标志的颜色 tearoff 1. 默认情况下菜单可以被“撕下”（点击 IDLE 菜单上边的 ——— 试试） 2. 将该选项设置为 Flase 关闭这一特性 tearoffcommand 如果你希望当用户“撕下”你的菜单时通知你的程序，那么你可以将该选项与一个方法相关联，那么当用户“撕下”你的菜单时，Tkinter 会带着两个参数去调用你的方法（一个参数是当前窗口的 ID，另一个参数是承载被“撕下”的菜单的窗口 ID） title 默认情况下，被“撕下”的菜单标题是其主菜单的名字，不过你也可以通过修改此项的值来修改标题 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:13:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"方法 add(type, **options) – type 参数指定添加的菜单类型，可以是：“command”，“cascade”，“checkbutton”，“radiobutton” 或 “separator” – 还可以通过 options 选项设置菜单的属性，下表列举了 options 可以使用的选项和具体含义： 选项 含义 accelerator 1. 显示该菜单项的加速键（快捷键） 2. 例如 accelerator = “Ctrl+N” 3. 该选项仅显示，并没有实现加速键的功能（通过按键绑定实现） activebackground 设置当该菜单项处于 “active” 状态（通过 state 选项设置状态）的背景色 activeforeground 设置当该菜单项处于 “active” 状态（通过 state 选项设置状态）的前景色 background 设置该菜单项的背景颜色 bitmap 指定显示到该菜单项上的位图 columnbreak 从该菜单项开始另起一列显示 command 将该选项与一个方法相关联，当用户点击该菜单项时将自动调用此方法 compound 1. 控制菜单项中文本和图像的混合模式 2. 如果该选项设置为 “center”，文本显示在图像上（文本重叠图像） 3. 如果该选项设置为 “bottom”，“left”，“right” 或 “top”，那么图像显示在文本的旁边（如 “bottom”，则图像在文本的下方 font 指定文本的字体 foreground 设置前景色 hidemargin 是否显示菜单项旁边的空白 image 1. 指定菜单项显示的图片 2. 该值应该是 PhotoImage，BitmapImage，或者能兼容的对象 label 指定菜单项显示的文本 menu 1. 该选项仅在 cascade 类型的菜单中使用 2. 用于指定它的下级菜单 offvalue 1. 默认情况下，variable 选项设置为 1 表示选中状态，反之设置为 0 2. 设置 offvalue 的值可以自定义未选中状态的值 onvalue 1. 默认情况下，variable 选项设置为 1 表示选中状态，反之设置为 0 2. 设置 onvalue 的值可以自定义选中状态的值 selectcolor 指定当菜单项显示为单选按钮或多选按钮时选择中标志的颜色 selectimage 如果你在单选按钮或多选按钮菜单中使用图片代替文本，那么设置该选项指定被菜单项被选中时显示的图片 state 1. 跟 text 选项一起使用，用于指定哪一个字符画下划线（例如用于表示键盘快捷键） underline 1. 用于指定在该菜单项的某一个字符处画下划线 2. 例如设置为 1，则说明在该菜单项的第 2 个字符处画下划线 value 1. 当菜单项为单选按钮时，用于标志该按钮的值 2. 在同一组中的所有按钮应该拥有各不相同的值 3. 通过将该值与 variable 选项的值对比，即可判断用户选中了哪个按钮 4. 如在使用上有不懂具体可以参照 Radiobutton 组件的说明 variable 1. 当菜单项是单选按钮或多选按钮时，与之关联的变量 2. 如在使用上有不懂具体可以参照：Checkbutton 和 Radiobutton 组件的说明 ==add_cascade(**options)== – 添加一个父菜单 – 相当于 add(“cascade”, **options) *add_checkbutton(*options) – 添加一个多选按钮的菜单项 – 相当于 add(“checkbutton”, **options) ==add_command(**options)== – 添加一个普通的命令菜单项 – 相当于 add(“command”, **options) *add_radiobutton(*options) – 添加一个单选按钮的菜单项 – 相当于 add(“radiobutton”, **options) *add_separator(*options) – 添加一条分割线 – 相当于 add(“separator”, **options) delete(index1, index2=None) – 删除 index1 ~ index2（包含）的所有菜单项 – 如果忽略 index2 参数，则删除 index1 指向的菜单项 – 注意：对于一个被“撕下”的菜单，你无法使用该方法 entrycget(index, option) – 获得指定菜单项的某选项的值 *entryconfig(index, *options) – 设置指定菜单项的选项 – 选项的参数及具体含义请参考上方 add() 方法 *entryconfigure(index, *options) – 跟 entryconfig() 一样 index(index) – 返回与 index 参数相应的选项的序号（例如 e.index(“end”)） *insert(index, itemType, *options) – 插入指定类型的菜单项到 index 参数指定的位置 – itemType 参数指定添加的菜单类型，可以是：“command”，“cascade”，“checkbutton”，“radiobutton” 或 “separator” – 选项的参数及具体含义请参考上方 add() 方法 *insert_cascade(index, *options) – 在 index 参数指定的位置添加一个父菜单 – 相当于 insert(“cascade”, **options) *insert_checkbutton(index, *options) – 在 index 参数指定的位置添加一个多选按钮 – 相当于 insert(“checkbutton”, **options) *insert_command(index, *options) – 在 index 参数指定的位置添加一个普通的命令菜单项 – 相当于 insert(“command”, **options) *insert_radiobutton(index, *options) – 在 index 参数指定的位置添加一个单选按钮 – 相当于 insert(“radiobutton”, **options) *insert_separator(index, *options) – 在 index 参数指定的位置添加一条分割线 – 相当于 insert(“separator”, **options) invoke(index) – 调用 index 指定的菜单项相关联的方法 – 如果是单选按钮，设置该菜单项为选中状态 – 如果是多选按钮，切换该菜单项的选中状态 post(x, y) – 在指定的位置显示弹出菜单 – 参考上创建弹窗菜单的例子 type(index) – 获得 index 参数指定菜单项的类型 – 返回值可以是：“command”，“cascade”，“checkbutton”，“radiobutton” 或 “separator” unpost() – 移除弹出菜单 yposition(index) – 返回 index 参数指定的菜单项的垂直偏移位置 – 该方法的目的是为了让你精确放置相对于当前鼠标的位置弹出菜单 布局管理器 pack、grid 和 place 均用于管理同在一个父组件下的所有组件的布局，其中： pack 是按添加顺序排列组件 grid 是按行/列形式排列组件 place 则允许程序员指定组件的大小和位置 我们常常会遇到的一个情况是将一个组件放到一个容器组件中，并填充整个父组件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:13:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"pack 默认下，pack 是将添加的组件依次纵向排列 如果想要组件横向挨个儿排放，你可以使用 side 选项 import tkinter as tk root = tk.Tk() listbox = tk.Listbox(root) listbox.pack(fill=\"both\", expand=True) for i in range(10): listbox.insert(\"end\", str(i)) root.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:14:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *pack(*options) – 下方表格详细列举了各个选项的具体含义和用法： 选项 含义 anchor 1. 控制组件在 pack 分配的空间中的位置 2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或者 “center” 来定位（ewsn 代表东西南北，上北下南左西右东） 3. 默认值是 “center” expand 1. 指定是否填充父组件的额外空间 2. 默认值是 False fill 1. 指定填充 pack 分配的空间 2. 默认值是 NONE，表示保持子组件的原始尺寸 3. 还可以使用的值有：“x”（水平填充），“y”（垂直填充）和 “both”（水平和垂直填充） in_ 1. 将该组件放到该选项指定的组件中 2. 指定的组件必须是该组件的父组件 ipadx 指定水平方向上的内边距 ipady 指定垂直方向上的内边距 padx 指定水平方向上的外边距 pady 指定垂直方向上的外边距 side 1. 指定组件的放置位置 2. 默认值是 “top” 3. 还可以设置的值有：“left”，“bottom”，“right” ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:14:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"grid 使用 grid 排列组件，只需告诉它你想要将组件放置的位置（行/列，row 选项指定行，cloumn 选项指定列）。此外，你并不用提前指出网格（grid 分布给组件的位置称为网格）的尺寸，因为管理器会自动计算 import tkinter as tk root = tk.Tk() # column 默认值是 0 tk.Label(root, text=\"用户名\").grid(row=0) tk.Label(root, text=\"密码\").grid(row=1) tk.Entry(root).grid(row=0, column=1) tk.Entry(root, show=\"*\").grid(row=1, column=1) root.mainloop() 默认情况下组件会居中显示在对应的网格里，你可以使用 sticky 选项来修改这一特性 有时候你可能需要用几个网格来放置一个组件，你只需要指定 rowspan 和 columnspan 就可以实现跨行和跨列的功能 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:15:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *grid(*options) – 下方表格详细列举了各个选项的具体含义和用法： 选项 含义 column 1. 指定组件插入的列（0 表示第 1 列） 2. 默认值是 0 columnspan 指定用多少列（跨列）显示该组件 in_ 1. 将该组件放到该选项指定的组件中 2. 指定的组件必须是该组件的父组件 ipadx 指定水平方向上的内边距 ipady 指定垂直方向上的内边距 padx 指定水平方向上的外边距 pady 指定垂直方向上的外边距 row 指定组件插入的行（0 表示第 1 行） rowspan 指定用多少行（跨行）显示该组件 sticky 1. 控制组件在 grid 分配的空间中的位置 2. 可以使用 “n”, “e”, “s”, “w” 以及它们的组合来定位（ewsn代表东西南北，上北下南左西右东） 3. 使用加号（+）表示拉长填充，例如 “n” + “s” 表示将组件垂直拉长填充网格，“n” + “s” + “w” + “e” 表示填充整个网格 4. 不指定该值则居中显示 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:15:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"place 通常情况下不建议使用 place 布局管理器，因为对比起 pack 和 grid，place 要做更多的工作。不过纯在即合理，place 在一些特殊的情况下可以发挥妙用 import tkinter as tk root = tk.Tk() def callback(): print(\"正中靶心\") tk.Button(root, text=\"点我\", command=callback).place(relx=0.5, rely=0.5, anchor=\"center\") root.mainloop() relx 和 rely 选项指定的是相对于父组件的位置，范围是 00 ~ 1.0，因此 0.5 表示位于正中间。那么 relwidth 和 relheight 选项则是指定相对于父组件的尺寸 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:16:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 *place(*options) – 下方表格详细列举了各个选项的具体含义和用法： 选项 含义 anchor 1. 控制组件在 place 分配的空间中的位置 2. “n”, “ne”, “e”, “se”, “s”, “sw”, “w”, “nw”, 或 “center” 来定位（ewsn代表东西南北，上北下南左西右东） 3. 默认值是 “nw” bordermode 1. 指定边框模式（“inside” 或 “outside”） 2. 默认值是 “inside” height 指定该组件的高度（像素） in_ 1. 将该组件放到该选项指定的组件中 2. 指定的组件必须是该组件的父组件 relheight 1. 指定该组件相对于父组件的高度 2. 取值范围 0.0 ~ 1.0 relwidth 1. 指定该组件相对于父组件的宽度 2. 取值范围 0.0 ~ 1.0 relx 1. 指定该组件相对于父组件的水平位置 2. 取值范围 0.0 ~ 1.0 rely 1. 指定该组件相对于父组件的垂直位置 2. 取值范围 0.0 ~ 1.0 width 指定该组件的宽度（像素） x 1. 指定该组件的水平偏移位置（像素） 2. 如同时指定了 relx 选项，优先实现 relx 选项 y 1. 指定该组件的垂直偏移位置（像素） 2. 如同时指定了 rely 选项，优先实现 rely 选项 标准对话框 Tkinter 为了提供了三种标准对话框模块，它们分别是： messagebox filedialog colorchooser ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:16:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"messagebox（消息对话框） import tkinter as tk from tkinter import messagebox messagebox.askokcancel(\"Python Demo\", \"发射核弹？\") tk.mainloop() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:17:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"标准对话框样式 使用函数 对话框样式 askokcancel(title, message, options) askquestion(title, message, options) askretrycancel(title, message, options) askyesno(title, message, options) showerror(title, message, options) showinfo(title, message, options) showwarning(title, message, options) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:17:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 所有的这些函数都有相同的参数： title 参数毋庸置疑是设置标题栏的文本 message 参数是设置对话框的主要文本内容，你可以用 ‘\\n’ 来实现换行 options 参数可以设置的选项和含义如下表所示 选项 含义 default 1. 设置默认的按钮（也就是按下回车响应的那个按钮） 2. 默认是第一个按钮（像“确定”，“是”或“重试”） 3. 可以设置的值根据对话框函数的不同可以选择：CANCEL，IGNORE，OK，NO，RETRY 或 YES icon 1. 指定对话框显示的图标 2. 可以指定的值有：ERROR，INFO，QUESTION 或 WARNING 3. 注意：不能指定自己的图标 parent 1. 如果不指定该选项，那么对话框默认显示在根窗口上 2. 如果想要将对话框显示在子窗口 w 上，那么可以设置 parent=w ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:17:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"返回值 askokcancel()，askretrycancel() 和 askyesno() 返回布尔类型的值： 返回 True 表示用户点击了“确定”或“是”按钮 返回 False 表示用户点击了“取消”或“否”按钮 askquestion() 返回“yes”或“no”字符串表示用户点击了“是”或“否”按钮 showerror()，showinfo() 和 showwarning() 返回“ok”表示用户按下了“是”按钮 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:17:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"filedialog（文件对话框） 当你的应用程序需要使用打开文件或保存文件的功能时，文件对话框显得尤为重要 import tkinter as tk from tkinter import filedialog root = tk.Tk() def callback(): fileName = filedialog.askopenfilename() print(fileName) tk.Button(root, text=\"打开文件\", command=callback).pack() root.mainloop() filedialog 模块提供了两个函数：askopenfilename(**option) 和 asksaveasfilename(**option)，分别用于打开文件和保存文件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:18:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"参数 两个函数可供设置的选项是一样的，下边列举了可用的选项及含义： 选项 含义 defaultextension 1. 指定文件的后缀 2. 例如：defaultextension=\".jpg”，那么当用户输入一个文件名 “logo” 的时候，文件名会自动添加后缀为 “logo.jpg” 3. 注意：如果用户输入文件名包含后缀，那么该选项不生效 filetypes 1. 指定筛选文件类型的下拉菜单选项 2. 该选项的值是由 2 元祖构成的列表 3. 每个 2 元祖由（类型名，后缀）构成，例如：filetypes=[(“PNG”, “.png”), (“JPG”, “.jpg”), (“GIF”, “.gif”)] initialdir 1. 指定打开/保存文件的默认路径 2. 默认路径是当前文件夹 parent 1. 如果不指定该选项，那么对话框默认显示在根窗口上 2. 如果想要将对话框显示在子窗口 w 上，那么可以设置 parent=w title 指定文件对话框的标题栏文本 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:18:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"返回值 如果用户选择了一个文件，那么返回值是该文件的完整路径 如果用户点击了取消按钮，那么返回值是空字符串 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:18:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"colorchooser（颜色选择对话框） 颜色选择对话框提供一个友善的界面让用户选择需要的颜色 import tkinter as tk from tkinter import colorchooser root = tk.Tk() def callback(): fileName = colorchooser.askcolor() print(fileName) tk.Button(root, text=\"选择颜色\", command=callback).pack() root.mainloop() 参数 askcolor(color, **option) 函数的 color 参数用于指定初始化的颜色，默认是浅灰色； option 参数可以指定的选项及含义如下： 选项 含义 title 指定颜色对话框的标题栏文本 parent 1. 如果不指定该选项，那么对话框默认显示在根窗口上 2. 如果想要将对话框显示在子窗口 w 上，那么可以设置 parent=w 返回值 如果用户选择一个颜色并按下“确定”按钮后，返回值是一个 2 元祖，第 1 个元素是选择的 RGB 颜色值，第 2 个元素是对应的 16 进制颜色值 如果用户按下“取消”按钮，那么返回值是 (None, None) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/:19:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/tkinter/"},{"categories":null,"content":"概述 wordcloud 是优秀的词云展示第三方库，以词语为基本单位，通过图形可视化的方式，更加直观和艺术的展示文本 示例 from matplotlib import pyplot as plt from wordcloud import WordCloud string = 'Importance of relative word frequencies for font-size. With relative_scaling=0, only word-ranks are considered. With relative_scaling=1, a word that is twice as frequent will have twice the size. If you want to consider the word frequencies and not only their rank, relative_scaling around .5 often looks good.' font = r'C:\\Windows\\Fonts\\FZSTK.TTF' wc = WordCloud(font_path=font, #如果是中文必须要添加这个，否则会显示成框框 background_color='white', width=1000, height=800, ).generate(string) wc.to_file('ss.png') #保存图片 plt.imshow(wc) #用plt显示图片 plt.axis('off') #不显示坐标轴 plt.show() #显示图片 filename = r'D:\\Repo\\Jupyter\\Crawler\\Result\\心灵奇旅短评.txt' with open(filename,encoding='UTF-8') as file_project: text = file_project.read() cut = jieba.cut(text) #text为你需要分词的字符串/句子 chinese = ' '.join(cut) #将分开的词用空格连接 font = r'C:\\Windows\\Fonts\\msyhbd.ttc' img = Image.open(r'D:\\Repo\\Jupyter\\Data\\22.png') #打开图片 img_array = np.array(img) #将图片装换为数组 wc = WordCloud( font_path=font, background_color='white', width=10000, height=8000, mask=img_array, ) wc.generate_from_text(chinese)#绘制图片 plt.imshow(wc) plt.axis('off') plt.figure() plt.show() #显示图片 wc.to_file(r'new.png') #保存图片 对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/"},{"categories":null,"content":"WordCloud from wordcloud import WordCloud WordCloud() 词云对象，Word cloud object for generating and drawing ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/"},{"categories":null,"content":"参数 font_path：字体路径，string，Font path to the font that will be used (OTF or TTF). width：int (default=400)，Width of the canvas height：int (default=200)，Height of the canvas. background_color：color value (default=”black”)，Background color for the word cloud image. mask：nd-array or None (default=None)，传入转换为数组后的图片作为底片，必须白底 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/:1:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/"},{"categories":null,"content":"方法 .generate(text)：向 WordCloud 对象中加载文本 txt，Generate wordcloud from text. .to_file(filename)：将词云输出为图像文件，.png 或 .jpg 格式，Export to image file. .to_array()：将词云转换成 numpy array 对象，Convert to numpy array. ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/:1:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%8F%AF%E8%A7%86%E5%8C%96/wordcloud/"},{"categories":null,"content":"认识 Asynchronous HTTP Client/Server for asyncio and Python. 用于 asyncio 和 Python 的异步 HTTP 客户端/服务器。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/aiohttp/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/aiohttp/"},{"categories":null,"content":"同步与异步的比较 同步 from datetime import datetime import requests from lxml import etree headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\" \"/537.36 (KHTML, like Gecko) \" \"Chrome/72.0.3626.121 Safari/537.36\"} def get_movie_url(): req_url = \"https://movie.douban.com/chart\" response = requests.get(url=req_url, headers=headers) html = etree.HTML(response.text) movies_url = html.xpath( \"//*[@id='content']/div/div[1]/div/div/table/tr/td/a/@href\") return movies_url def get_movie_content(movie_url): response = requests.get(movie_url, headers=headers) result = etree.HTML(response.text) movie = dict() name = result.xpath('//*[@id=\"content\"]/h1/span[1]//text()') author = result.xpath('//*[@id=\"info\"]/span[1]/span[2]//text()') movie[\"name\"] = name movie[\"author\"] = author return movie if __name__ == '__main__': start = datetime.now() movie_url_list = get_movie_url() movies = dict() for url in movie_url_list: movies[url] = get_movie_content(url) print(movies) print(\"同步用时为：{}\".format(datetime.now() - start)) 异步 import asyncio from datetime import datetime import aiohttp from lxml import etree headers = {\"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit\" \"/537.36 (KHTML, like Gecko) \" \"Chrome/72.0.3626.121 Safari/537.36\"} async def get_movie_url(): req_url = \"https://movie.douban.com/chart\" async with aiohttp.ClientSession(headers=headers) as session: async with session.get(url=req_url, headers=headers) as response: result = await response.text() result = etree.HTML(result) return result.xpath(\"//*[@id='content']/div/div[1]/div/div/table/tr/td/a/@href\") async def get_movie_content(movie_url): async with aiohttp.ClientSession(headers=headers) as session: async with session.get(url=movie_url, headers=headers) as response: result = await response.text() result = etree.HTML(result) movie = dict() name = result.xpath('//*[@id=\"content\"]/h1/span[1]//text()') author = result.xpath('//*[@id=\"info\"]/span[1]/span[2]//text()') movie[\"name\"] = name movie[\"author\"] = author return movie if __name__ == '__main__': start = datetime.now() loop = asyncio.get_event_loop() movie_url_list = loop.run_until_complete(get_movie_url()) tasks = [get_movie_content(url) for url in movie_url_list] movies = loop.run_until_complete(asyncio.gather(*tasks)) print(movies) print(\"异步用时为：{}\".format(datetime.now() - start)) 客户端 import aiohttp import asyncio async def main(): async with aiohttp.ClientSession() as session: async with session.get('http://httpbin.org/get') as resp: print(resp.status) print(await resp.text()) asyncio.run(main()) 通过status来获取响应状态码，text()来获取到响应内容 读取二进制内容使用 read() 方法 用法与 requests 类似 服务端 from aiohttp import web async def handle(request): name = request.match_info.get('name', \"Anonymous\") text = \"Hello, \" + name return web.Response(text=text) app = web.Application() app.add_routes([web.get('/', handle), web.get('/{name}', handle)]) if __name__ == '__main__': web.run_app(app) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/aiohttp/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/aiohttp/"},{"categories":null,"content":"apscheduler https://www.cnblogs.com/gdjlc/p/11432526.html ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/apscheduler/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/apscheduler/"},{"categories":null,"content":"认识 collections 实现了特定目标的容器，以提供 Python 标准内建容器 dict、list、set、tuple 的替代选择 Counter：计数器，字典的子类，提供了可哈希对象的计数功能 defaultdict：默认字典，字典的子类，提供了一个工厂函数，为字典查询提供了默认值 OrderedDict：有序字典，字典的子类，保留了他们被添加的顺序 namedtuple：可命名元组，创建命名元组子类的工厂函数 deque：双向队列，类似列表容器，实现了在两端快速添加 (append) 和弹出 (pop) ChainMap：类似字典的容器类，将多个映射集合到一个视图里面 Counter ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/collections/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/collections/"},{"categories":null,"content":"说明 Counter作为字典dicit（）的一个子类用来进行 hashtable 计数，将元素进行数量统计 计数后返回一个字典，键值为元素，值为元素个数 a=Counter('hello world hello world hello nihao'.split()) print(a) # Counter({'hello': 3, 'world': 2, 'nihao': 1}) 允许进行 Counter 对象之间的加减操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/collections/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/collections/"},{"categories":null,"content":"方法 elements() 返回一个迭代器，每个元素重复计算的个数，如果一个元素的计数小于1,就会被忽略。 most_common([n]) 返回一个嵌套着元组的列表，提供 n 个访问频率最高的元素和计数 subtract([iterable-or-mapping]) 从迭代对象中减去元素，输入输出可以是 0 或者负数 update([iterable-or-mapping]) 从迭代对象计数元素或者从另一个 映射对象 (或计数器) 添加。 print(list(a.elements())) # ['hello', 'hello', 'hello', 'world', 'world', 'nihao'] for x in a.elements(): print(x) # hello # hello # hello # world # world # nihao print(a.most_common(2)) # [('hello', 3), ('world', 2)] a.subtract({'nihao':2}) print(a) # Counter({'hello': 3, 'world': 2, 'nihao': -1}) a.update({'wow':5}) print(a) # Counter({'wow': 5, 'hello': 3, 'world': 2, 'nihao': -1}) defaultdict 默认字典，字典的一个子类，继承所有字典的方法，默认字典在进行定义初始化的时候得指定字典值有默认类型 暂时没啥用 OrderedDict Python 字典中的键的顺序是任意的:它们不受添加的顺序的控制。 collections.OrderedDict类提供了保留他们添加顺序的字典对象。 d1 = collections.OrderedDict() d1['a'] = 'A' d1['b'] = 'B' d1['c'] = 'C' d1['1'] = '1' d1['2'] = '2' for k,v in d1.items(): print k,v 输出 a A b B c C 1 1 312 2 namedtuple namedtuple 由自己的类工厂 namedtuple() 进行创建，而不是由表中的元组进行初始化 通过 namedtuple 创建类的参数包括类名称和一个包含元素名称的字符串 # 三种声明方式 Person1 = namedtuple('Person1', ['name', 'age', 'sex']) Person2 = namedtuple('Person2', 'name, age, sex') Person3 = namedtuple('Person3', 'name age sex') zhangsan=Person1('zhangsan',20,'male') print(zhangsan) # Person1(name='zhangsan', age=20, sex='male') deque collections.deque返回一个新的双向队列对象，从左到右初始化(用方法 append()) ，从 iterable （迭代对象) 数据创建。如果 iterable 没有指定，新队列为空。 collections.deque 队列支持线程安全，对于从两端添加(append)或者弹出(pop)，复杂度 O(1) maxlen：属性参数，队列的最大长度，没有限定则为 None append(x)：添加 x 到右端 appendleft(x)：添加 x 到左端 clear()：清除所有元素，长度变为 0 copy()：创建一份浅拷贝 count(x)：计算队列中 x 元素的个数 extend(iterable)：在队列右侧添加 iterable 中的元素 extendleft(iterable)：在队列左侧添加 iterable 中的元素，注：在左侧添加时，iterable参数的顺序将会反过来添加 index(x[,start[,stop]])：返回第 x 个元素（从 start 开始计算，在 stop 之前）。返回第一个匹配，如果没找到的话，升起 ValueError insert(i,x)：在位置 i 插入 x 。注：如果插入会导致一个限长deque超出长度 maxlen 的话，就升起一个 IndexError 。 pop()：移除最右侧的元素 popleft()：移除最左侧的元素 remove(value)：移去找到的第一个 value。没有抛出ValueError reverse()：将deque逆序排列。返回 None 。 a=deque([],maxlen=10) a.append('1') a.appendleft('2') print(a) # deque(['2', '1'], maxlen=10) ChainMap 一个 ChainMap 将多个字典或者其他映射组合在一起，创建一个单独的可更新的视图。若没有 maps 被指定，就提供一个默认的空字典 ChainMap 是管理嵌套上下文和覆盖的有用工具 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/collections/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/collections/"},{"categories":null,"content":"认识 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/"},{"categories":null,"content":"类 类名 功能说明 date 日期对象,常用的属性有 year, month, day time 时间对象 datetime 日期时间对象,常用的属性有 hour, minute, second, microsecond datetime_CAPI 日期时间对象 C 语言接口 timedelta 时间间隔，即两个时间点之间的长度 tzinfo 时区信息对象 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/"},{"categories":null,"content":"常量 常量 功能说明 用法 返回值 MAXYEAR 返回能表示的最大年份 datetime.MAXYEAR 9999 MINYEAR 返回能表示的最小年份 datetime.MINYEAR 1 date date（year，month，day) \u003e\u003e\u003e a = datetime.date.today() \u003e\u003e\u003e a datetime.date(2021, 5, 11) \u003e\u003e\u003e a.year 2021 \u003e\u003e\u003e a.month 5 \u003e\u003e\u003e a.day 11 可以进行大小比较，加减运算 a = datetime.date.today() b = datetime.date(2021,4,5) print(a-b) print(a\u003cb) # days, 0:00:00 # False ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/"},{"categories":null,"content":"方法 .isoformat() 返回 ISO 格式字符串 .isocalendar() 返回 ISO 格式元组 .isoweekday 返回所在的星期数，周一为1…周日为7 .timetuple() 该方法为了兼容 time.localtime(...) 返回一个类型为 time.struct_time 的数组，但有关时间的部分元素值为 0 .toordinal() 返回公元公历开始到现在的天数。公元 1 年 1 月 1 日为 1 .fromtimestamp(time_float) 根据给定的时间戮，返回一个 date 对象 datetime.date.fromtimestamp(time.time()) .today() 返回当前日期 .strftime(format) 将日期对象转化为字符串对象 a.strftime(\"%Y%m%d\") strptime(str,format) 将字符串对象转化为日期对象 time time([hour[, minute[, second[, microsecond[, tzinfo]]]]]) 方法与 date 类似 datetime datetime 类其实是可以看做是 date 类和 time 类的合体，其大部分的方法和属性都继承于这二个类 datetime(year, month, day[, hour[, minute[, second[, microsecond[,tzinfo]]]]]) a = datetime.datetime.now() print(a) # 2021-05-11 11:35:00.048964 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/"},{"categories":null,"content":"专属属性 .date() 返回日期部分 .time() 返回时间部分 .utctimetuple() 返回 UTC 时间元组 例：time.struct_time(tm_year=2021, tm_mon=5, tm_mday=11, tm_hour=11, tm_min=35, tm_sec=0, tm_wday=1, tm_yday=131, tm_isdst=0) .combine(date,time) 将一个 date 对象和一个 time 对象合并生成一个 datetime 对象 .now() 返回当前日期时间的 datetime 对象 loguru==0.5.3 pydantic==1.8.1 jieba==0.42.1 aiohttp==3.7.4.post0 nb-cli nonebot-plugin-test nonebot-adapter-cqhttp nonebot_plugin_apscheduler ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/datetime/"},{"categories":null,"content":"faker ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"认识 faker 主要用来创建伪数据，使用 faker 包，无需再手动生成或者手写随机数来生成数据，只需要调用 faker 提供的方法，即可完成数据的生成。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"创建 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"通过工厂函数来创建 from faker import Factory fake1 = Factory.create() # 通过工厂函数来创建 fake1.name() # 调用方法-随机生成一个姓名 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"通过构造函数来创建 from faker import Faker # 主要使用的是Factory类，而导入Faker，会同时导入Factory fake2 = Faker() # 通过构造函数来创建 fake2.address() # 调用方法-随机生成一个地址 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"本地化 fake = Faker(locale='zh_CN') faker 接受的本地化参数 locale，创建的对象会生成对应语言的数据，如果没有找到对应的语言，会使用默认的 “en_US” 可选择的文化信息 ar_EG - Arabic (Egypt) ar_PS - Arabic (Palestine) ar_SA - Arabic (Saudi Arabia) bg_BG - Bulgarian cs_CZ - Czech de_DE - German dk_DK - Danish el_GR - Greek en_AU - English (Australia) en_CA - English (Canada) en_GB - English (Great Britain) en_US - English (United States) es_ES - Spanish (Spain) es_MX - Spanish (Mexico) et_EE - Estonian fa_IR - Persian (Iran) fi_FI - Finnish fr_FR - French hi_IN - Hindi hr_HR - Croatian hu_HU - Hungarian it_IT - Italian ja_JP - Japanese ko_KR - Korean lt_LT - Lithuanian lv_LV - Latvian ne_NP - Nepali nl_NL - Dutch (Netherlands) no_NO - Norwegian pl_PL - Polish pt_BR - Portuguese (Brazil) pt_PT - Portuguese (Portugal) ru_RU - Russian sl_SI - Slovene sv_SE - Swedish tr_TR - Turkish uk_UA - Ukrainian zh_CN - Chinese (China) zh_TW - Chinese (Taiwan) 本地化特有属性 详见 https://www.cnblogs.com/hellangels333/p/9039784.html ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"属性 更多：https://www.cnblogs.com/pywen/p/14245369.html from faker import Faker fake = Faker() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"人名类 fake.name() # 人名 fake.name_male() # 男子名 fake.name_femal() # 女子名 # 'Mallory Walker' # Melissa Arias fake.first_name() # 名 fake.last_name() # 姓 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"身份信息类 fake.ssn() # 身份证号 # '220112193612070575' # '391-38-4757' fake.phone_number() # 手机号码 # '070-1015-0220' fake.ipv4_private() # ip地址 # '10.112.246.54' fake.profile() # 个人配置信息 '''{'job': '电脑操作员/打字员', 'company': '网新恒天传媒有限公司', 'ssn': '37132220000210765X', 'residence': '湖北省婷婷市永川马街Y座 292199', 'current_location': (Decimal('40.609137'), Decimal('14.068631')), 'blood_group': 'B-', 'website': ['https://minma.cn/', 'https://www.liu.cn/'], 'username': 'luoli', 'name': '钟帆', 'sex': 'F', 'address': '河北省巢湖市高坪邵街r座 998657', 'mail': 'min70@gmail.com', 'birthdate': datetime.date(1948, 6, 7)}''' fake.job() # 工作名 # 公認会計士 # 售前/售后技术支持工程师 # Electrical engineer # Herpetologist # 电子技术研发工程师 fake.password() # 随机密码 # 5%8TIiwbL3 # SIf7xvOg%0 # trD2!1ZlM) # ngPHeq1_!3 # @OpYOrqt1B # I4P^(yaD!c fake.uuid4() # 随机UUID # bcc48179-b9e3-4da2-a8e9-95681650e56f # 47ee89a8-f845-48af-8894-4d6a28cbfdc8 # 1f3b9a27-8870-48bd-9861-5d3fedc7f972 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"地区名称类 fake.address() # 街道，好像是假的 # '千葉県新島村二つ室20丁目17番16号 雷門パレス775' # '38987 Henry Lights Suite 406\\nNataliefurt, PA 10973' # '辽宁省关岭县清河淮安街D座 373511' fake.company() # 公司名称 # '恒聪百汇科技有限公司' # 'Cruz-Martin' # '森運輸合同会社' fake.city() # 城市，真实 # 'Stewartborough' # '昭島市' # 'East Jacob' # '杭州市' fake.city_suffix() # 各地城市后缀 # 'chester' # 'burgh' fake.country() # 国家，会以所选地区的语言来展示 # リビア国 # Korea # Jersey # 瓜德罗普岛 fake.current_country() # fake对象所在地区的国家 # Japan # United States # People's Republic of China fake.country_code() # 国家编码 fake.current_country_code() # 对象所在国家编码 # SV # NR # RS ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:3:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"日期时间类 fake.date(pattern='%Y-%m-%d', end_datetime=None) # 日期 # 1982-02-13 # 1989-10-24 # 2018-01-12 # 2005-04-27 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:3:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"进阶 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"使用复合对象 from collections import OrderedDict from faker import Faker # Generate a name based on the provided weights # en_US - 16.67% of the time (1 / (1 + 2 + 3)) # en_PH - 33.33% of the time (2 / (1 + 2 + 3)) # ja_JP - 50.00% of the time (3 / (1 + 2 + 3)) locales = OrderedDict( [ (\"en-US\", 1), (\"zh_CN\", 2), (\"ja_JP\", 3), ] ) fake = Faker(locales) # usage fake.phone_number() fake['en-US'].name() fake['ja_JP'].zipcode() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/faker/"},{"categories":null,"content":"认识 输出日志 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"导入 import logging ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"初始化 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"级别排序 CRITICAL \u003e ERROR \u003e WARNING \u003e INFO \u003e DEBUG 级别 何时使用 DEBUG 细节信息，仅当诊断问题时适用。 INFO 确认程序按预期运行 WARNING 表明有已经或即将发生的意外（例如：磁盘空间不足）。程序仍按预期进行 ERROR 由于严重的问题，程序的某些功能已经不能正常执行 CRITICAL 严重的错误，表明程序已不能继续执行 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"创建实例 使用模块级记录器 Logger 是一个记录器类 logger = logging.getLogger(__name__) 这意味着记录器名称跟踪包或模块的层次结构，并且直观地从记录器名称显示记录事件的位置。 配置 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"全局配置 basicConfig() 默认情况下，没有为任何日志记录消息设置目标。 你可以使用 basicConfig() 指定目标 通过使用默认的 Formatter 创建一个 StreamHandler 并将其加入根日志记录器来为日志记录系统执行基本配置。 如果没有为根日志记录器定义处理程序则 debug(), info(), warning(), error() 和 critical() 等函数将自动调用 basicConfig() 参数 filename：指定日志文件名 filemode：指定日志文件的打开模式，‘w’ 或者 ‘a’，默认为 ‘a’ format：指定输出的格式和内容 参数 作用 %(levelno)s 日志级别的数值 %(levelname)s 日志级别的名称 %(pathname)s 当前执行程序的路径，其实就是sys.argv[0] %(filename)s 当前执行程序名 %(funcName)s 当前函数 %(lineno)d 当前行号 %(asctime)s 时间 %(thread)d 线程 ID %(threadName)s 线程名称 %(process)d 进程 ID %(message)s 日志信息 datefmt：指定时间格式，同 time.strftime() level：设置日志级别，默认为 logging.WARNNING stream：指定将日志的输出流，可以指定输出到 sys.stderr，sys.stdout 或者文件，默认输出到 sys.stderr，与 filename 不兼容 例 import logging logging.basicConfig(level=logging.DEBUG, format='%(asctime)s- %(levelname)s- %(message)s') logger = logging.getLogger(__name__) logger.info(\"Start print log\") logger.debug(\"Do something\") logger.warning(\"Something maybe fail.\") logger.info(\"Finish\") 输出 2021-04-27 11:23:53,973 - INFO - Start print log 2021-04-27 11:23:53,973 - DEBUG - Do something 2021-04-27 11:23:53,973 - WARNING - Something maybe fail. 2021-04-27 11:23:53,973 - INFO - Finish 对 basicConfig() 的调用应该在 debug() ， info() 等的前面。因为它被设计为一次性的配置，只有第一次调用会进行操作，随后的调用不会产生有效操作。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"对实例的配置 对记录器类进行配置，实际上都是 Logger 类的成员函数 import logging # create logger logger = logging.getLogger(__name__) logger.setLevel(logging.DEBUG) # create console handler and set level to debug ch = logging.StreamHandler() ch.setLevel(logging.DEBUG) # create formatter formatter = logging.Formatter('%(asctime)s- %(name)s- %(levelname)s- %(message)s') # add formatter to ch ch.setFormatter(formatter) # add ch to logger logger.addHandler(ch) # 'application' code logger.debug('debug message') logger.info('info message') logger.warning('warn message') logger.error('error message') logger.critical('critical message') setLevel(level) 设置记录器级别，高于 level 会被输出 level：级别，默认为 logging.WARNING 级别 数值 CRITICAL 50 ERROR 40 WARNING 30 INFO 20 DEBUG 10 NOTSET 0 addHandler(hdlr) 将指定的处理器 hdlr 添加到此记录器 removeHandler(hdlr) 移除指定处理器 addFilter(filter) 将指定的过滤器 filter 添加到此记录器 removeFilter(filter) 移除指定过滤器 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"调用外部配置文件 fileConfig() import logging import logging.config logging.config.fileConfig('logging.conf') # create logger logger = logging.getLogger(__name__) # 'application' code logger.debug('debug message') logger.info('info message') logger.warning('warn message') logger.error('error message') logger.critical('critical message') 配置文件例 (.conf) [loggers] keys=root,simpleExample [handlers] keys=consoleHandler [formatters] keys=simpleFormatter [logger_root] level=DEBUG handlers=consoleHandler [logger_simpleExample] level=DEBUG handlers=consoleHandler qualname=simpleExample propagate=0 [handler_consoleHandler] class=StreamHandler level=DEBUG formatter=simpleFormatter args=(sys.stdout,) [formatter_simpleFormatter] format=%(asctime)s - %(name)s - %(levelname)s - %(message)s datefmt= 或使用 YAML 格式 version:1formatters:simple:format:'%(asctime)s - %(name)s - %(levelname)s - %(message)s'handlers:console:class:logging.StreamHandlerlevel:DEBUGformatter:simplestream:ext://sys.stdoutloggers:simpleExample:level:DEBUGhandlers:[console]propagate:noroot:level:DEBUGhandlers:[console] 也可以使用 json 格式 { \"version\":1, \"disable_existing_loggers\":false, \"formatters\":{ \"simple\":{ \"format\":\"%(asctime)s- %(name)s- %(levelname)s- %(message)s\" } }, \"handlers\":{ \"console\":{ \"class\":\"logging.StreamHandler\", \"level\":\"DEBUG\", \"formatter\":\"simple\", \"stream\":\"ext://sys.stdout\" }, \"info_file_handler\":{ \"class\":\"logging.handlers.RotatingFileHandler\", \"level\":\"INFO\", \"formatter\":\"simple\", \"filename\":\"info.log\", \"maxBytes\":\"10485760\", \"backupCount\":20, \"encoding\":\"utf8\" }, \"error_file_handler\":{ \"class\":\"logging.handlers.RotatingFileHandler\", \"level\":\"ERROR\", \"formatter\":\"simple\", \"filename\":\"errors.log\", \"maxBytes\":10485760, \"backupCount\":20, \"encoding\":\"utf8\" } }, \"loggers\":{ \"my_module\":{ \"level\":\"ERROR\", \"handlers\":[\"info_file_handler\"], \"propagate\":\"no\" } }, \"root\":{ \"level\":\"INFO\", \"handlers\":[\"console\",\"info_file_handler\",\"error_file_handler\"] } } 传入到程序中 import json import logging.config import os def setup_logging(default_path = \"logging.json\",default_level = logging.INFO,env_key = \"LOG_CFG\"): path = default_path value = os.getenv(env_key,None) if value: path = value if os.path.exists(path): with open(path,\"r\") as f: config = json.load(f) logging.config.dictConfig(config) else: logging.basicConfig(level = default_level) def func(): logging.info(\"start func\") logging.info(\"exec func\") logging.info(\"end func\") if __name__ == \"__main__\": setup_logging(default_path = \"logging.json\") func() 实际上将 json 格式转化为字典，借用了字典的配置 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"字典配置 dictConfig() 处理器 Handler Handler 对象负责将适当的日志消息（基于日志消息的严重性）分派给处理程序的指定目标 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"API setLevel(level) 为处理器设置等级 setFormatter(fmt) addFilter(filter) 将指定的过滤器 filter 添加到处理器 removeFilter(filter) 移除指定过滤器 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"FileHandler 要将日志打印到文件中，使用 basicConfig 中的 filename 参数指定日志文件 更建议使用 FileHandler 实现 生成实例时，传入日志文件名即可 import logging logger = logging.getLogger(__name__) logger.setLevel(level = logging.INFO) handler = logging.FileHandler(\"log.txt\") handler.setLevel(logging.INFO) formatter = logging.Formatter('%(asctime)s- %(name)s- %(levelname)s- %(message)s') handler.setFormatter(formatter) logger.addHandler(handler) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"StreamHandler 默认的 basicConfig 配置即支持打印日志 但更建议使用 StreamHandler 实现 以下例为同时输出到控制台与文件 import logging logger = logging.getLogger(__name__) logger.setLevel(level = logging.INFO) fileHdlr = logging.FileHandler(\"log.txt\") fileHdlr.setLevel(logging.INFO) formatter = logging.Formatter('%(asctime)s- %(name)s- %(levelname)s- %(message)s') fileHdlr.setFormatter(formatter) consoleHdlr = logging.StreamHandler() consoleHdlr.setLevel(logging.INFO) logger.addHandler(fileHdlr) logger.addHandler(consoleHdlr) 过滤器 Filter 格式化程序对象配置日志消息的最终顺序、结构和内容 其构造函数有三个可选参数 —— 消息格式字符串、日期格式字符串和样式指示符 logging.Formatter.__init__(fmt=None, datefmt=None, style='%') 参数形式与 basicConfig 中的 foramt 参数相同 formatter = logging.Formatter('%(asctime)s- %(name)s- %(levelname)s- %(message)s') 样本 import logging import sys from os import makedirs from os.path import dirname, exists from cmreslogging.handlers import CMRESHandler loggers = {} LOG_ENABLED = True # 是否开启日志 LOG_TO_CONSOLE = True # 是否输出到控制台 LOG_TO_FILE = True # 是否输出到文件 LOG_TO_ES = True # 是否输出到 Elasticsearch LOG_PATH = './runtime.log' # 日志文件路径 LOG_LEVEL = 'DEBUG' # 日志级别 LOG_FORMAT = '%(levelname)s- %(asctime)s- process: %(process)d- %(filename)s- %(name)s- %(lineno)d- %(module)s- %(message)s' # 每条日志输出格式 ELASTIC_SEARCH_HOST = 'eshost' # Elasticsearch Host ELASTIC_SEARCH_PORT = 9200 # Elasticsearch Port ELASTIC_SEARCH_INDEX = 'runtime' # Elasticsearch Index Name APP_ENVIRONMENT = 'dev' # 运行环境，如测试环境还是生产环境 def get_logger(name=None): \"\"\" get logger by name :param name: name of logger :return: logger \"\"\" global loggers if not name: name = __name__ if loggers.get(name): return loggers.get(name) logger = logging.getLogger(name) logger.setLevel(LOG_LEVEL) # 输出到控制台 if LOG_ENABLED and LOG_TO_CONSOLE: stream_handler = logging.StreamHandler(sys.stdout) stream_handler.setLevel(level=LOG_LEVEL) formatter = logging.Formatter(LOG_FORMAT) stream_handler.setFormatter(formatter) logger.addHandler(stream_handler) # 输出到文件 if LOG_ENABLED and LOG_TO_FILE: # 如果路径不存在，创建日志文件文件夹 log_dir = dirname(log_path) if not exists(log_dir): makedirs(log_dir) # 添加 FileHandler file_handler = logging.FileHandler(log_path, encoding='utf-8') file_handler.setLevel(level=LOG_LEVEL) formatter = logging.Formatter(LOG_FORMAT) file_handler.setFormatter(formatter) logger.addHandler(file_handler) # 输出到 Elasticsearch if LOG_ENABLED and LOG_TO_ES: # 添加 CMRESHandler es_handler = CMRESHandler(hosts=[{'host': ELASTIC_SEARCH_HOST, 'port': ELASTIC_SEARCH_PORT}], # 可以配置对应的认证权限 auth_type=CMRESHandler.AuthType.NO_AUTH, es_index_name=ELASTIC_SEARCH_INDEX, # 一个月分一个 Index index_name_frequency=CMRESHandler.IndexNameFrequency.MONTHLY, # 额外增加环境标识 es_additional_fields={'environment': APP_ENVIRONMENT} ) es_handler.setLevel(level=LOG_LEVEL) formatter = logging.Formatter(LOG_FORMAT) es_handler.setFormatter(formatter) logger.addHandler(es_handler) # 保存到全局 loggers loggers[name] = logger return logger 使用时，调用定义的方法获取一个 logger，然后 log 对应的内容即可 logger = get_logger() logger.debug('this is a message') 简单的配置方式 import logging logging.basicConfig(level = logging.INFO,format = '%(asctime)s- %(name)s- %(levelname)s- %(message)s') logger = logging.getLogger(__name__) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/logging/"},{"categories":null,"content":"loguru 比 logging 更加轻便简单的日志记录器 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/loguru/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/loguru/"},{"categories":null,"content":"基本使用 from loguru import logger import os import time LOG_FOLDER = os.getcwd()+'\\\\logs' if not os.path.exists(LOG_FOLDER): os.mkdir(LOG_FOLDER) t = time.strftime(\"%Y_%m_%d\") logger = logger logger.add(\"{}\\\\log_{}.log\".format(LOG_FOLDER, t), rotation=\"00:00\", encoding=\"utf-8\", retention=\"300 days\") ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/loguru/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/loguru/"},{"categories":null,"content":"简介 os模块提供了多数操作系统的功能接口函数。当os模块被导入后，它会自适应于不同的操作系统平台，根据不同的平台进行相应的操作，在python编程时，经常和文件、目录打交道，这时就离不了os模块 import os 文件路径操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.getcwd() 查看当前路径（get current dictory） os.getcwd() \u003c\u003c 'D:\\\\repo\\\\PythonLearning\\\\Jupyter\\\\LearningTest' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.listdir(path) 列举 path 目录下所有文件，返回列表 无参数时，默认为当前路径 os.listdir(\"..\") \u003c\u003c ['.ipynb_checkpoints', 'CrawlerTest.ipynb', 'MatplotlibTest.ipynb', 'NumpyTest.ipynb', 'osTest.ipynb', 'PandasTest.ipynb'] ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.abspath(path): 返回 path 的绝对路径 os.path.abspath('..') \u003c\u003c 'D:\\\\repo\\\\PythonLearning\\\\Jupyter' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.split(path) 将路径分解为（文件夹,文件名），返回的是元组类型 若路径字符串最后一个字符是\\，则只有文件夹部分有值；若路径字符串中均无\\，则只有文件名部分有值 单纯地分析路径 os.path.split('D:\\\\pythontest\\\\ostest\\\\Hello.py') \u003c\u003c ('D:\\\\pythontest\\\\ostest', 'Hello.py') os.path.split('.') \u003c\u003c ('', '.') os.path.split('D:\\\\pythontest\\\\ostest\\\\') \u003c\u003c ('D:\\\\pythontest\\\\ostest', '') ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.join(path1,path2,…) 将 path 进行组合，返回组合后的路径 若其中有绝对路径，则之前的 path 将被删除 os.path.join('D:\\\\pythontest', 'ostest') \u003c\u003c 'D:\\\\pythontest\\\\ostest' os.path.join('D:\\\\pythontest\\\\b', 'D:\\\\pythontest\\\\a') \u003c\u003c 'D:\\\\pythontest\\\\a' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.dirname(path) 返回 path 中的文件夹部分，结果不包含 ‘\\’ 单纯地分析路径 os.path.dirname('D:\\\\pythontest\\\\ostest\\\\hello.py') \u003c\u003c 'D:\\\\pythontest\\\\ostest' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:6:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.basename(path) 返回 path 中的文件名 单纯地分析路径 os.path.basename('D:\\\\pythontest\\\\ostest\\\\hello.py') \u003c\u003c 'hello.py' os.path.basename('D:\\\\pythontest\\\\ostest\\\\') \u003c\u003c '' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:7:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.isfile(path) 判断 path 是否是一个存在的文件，返回布尔类型 os.path.isfile('D:\\\\pythontest\\\\ostest\\\\Hello.py') #尽管是格式正确的路径，凭空存在的话会返回False \u003c\u003c False os.path.isfile('C:\\\\Users\\\\13759\\\\shopName_2015.csv') #应输入存在于本计算机上的路径 \u003c\u003c True ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:8:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.isdir(path) 判断 path 是否为一个存在的目录，返回布尔类型 os.path.isdir('D:\\\\pythontest\\\\ostest') #尽管是格式正确的路径，凭空存在的话会返回False \u003c\u003c False os.path.isdir(os.getcwd()) \u003c\u003c True os.path.isdir('.') \u003c\u003c True ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:9:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.exists(path) 检验 path 是否存在，返回布尔类型 os.path.exists('.') \u003c\u003c True os.path.exists('C:\\\\Users\\\\13759\\\\shopName_2015.csv') \u003c\u003c True 查看文件信息 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:10:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.getsize(path) 查看文件大小 ，单位为字节 (Byte) os.path.getsize('D:\\\\repo\\\\PythonLearning\\\\Jupyter\\\\LearningTest\\\\NumpyTest.ipynb') \u003c\u003c 3499 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:11:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.getmtime(path) 查看文件或文件夹的最后修改时间（modify time），从新纪元到访问时的秒数 os.path.getmtime('NumpyTest.ipynb') \u003c\u003c 1609932700.1095462 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:12:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.getatime(path) 文件或文件夹的最后访问时间（access time），从新纪元到访问时的秒数 os.path.getatime('NumpyTest.ipynb') \u003c\u003c 1610524866.1898422 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:13:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.path.getctime(path) 文件或文件夹的创建时间（change time），从新纪元到访问时的秒数 os.path.getctime('NumpyTest.ipynb') \u003c\u003c 1609920794.9881816 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:14:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.stat() 获取文件或目录信息 os.stat('.') \u003c\u003c os.stat_result(st_mode=16895, st_ino=1688849860358640, st_dev=1957125357, st_nlink=1, st_uid=0, st_gid=0, st_size=4096, st_atime=1610524887, st_mtime=1609680144, st_ctime=1607355357) 文件操作 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:15:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.chdir(path) （change dir）转到指定 path，相当于cd ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:16:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.mkdir(path) 创建path指定的目录，可以写相对路径也可以写绝对路径 os.mkdir('aaa') os.mkdir('D:\\\\repo\\\\PythonLearning\\\\aaa') ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:17:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.rmdir(path) 删除path指定的目录，可以写相对路径也可以写绝对路径 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:18:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.remove(path) 删除path指定的文件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:19:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.makedirs(path) 生成多层递归目录 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:20:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.removedirs(path) 递归删除空目录（危险！） ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:21:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.rename(oldname, newname) 重命名文件或目录 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:22:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"os.system(cmd) 执行shell命令。返回值是脚本的退出状态码，0代表成功，1代表不成功 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/:23:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/os/"},{"categories":null,"content":"pygtrans 官方文档：https://pygtrans.readthedocs.io/zh_CN/latest/index.html ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pygtrans/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pygtrans/"},{"categories":null,"content":"快速开始 from pygtrans import Translate class Translator: def __init__(self): self.translator = Translate() def translate(self, text: str, target_lang: str = 'zh-CN')-\u003estr: return self.translator.translate(text, target=target_lang).translatedText def detect(self, text: str): return self.translator.detect(text) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pygtrans/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pygtrans/"},{"categories":null,"content":"步骤 在 cmd 中使用命令找到 py 程序所在目录 使用命令 pyinstaller -F \u003cname\u003e.py ​ dist 文件夹中的 exe 即为我们所需要的可执行文件 常用参数 语法 pyinstaller 选项 Python 源文件 参数 描述 -h 查看帮助 –clean 清理打包过程中的临时文件 -D, –onedir 默认值，生成dist文件夹 -F, –onefile 在dist文件夹中只生成独立的打包文件 -i \u003c图标文件名.ico\u003e 指定打包程序使用的图标（icon）文件 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstaller/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstaller/"},{"categories":null,"content":"pyinstrument ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/"},{"categories":null,"content":"Profile a Python script Call Pyinstrument directly from the command line. Instead of writing python script.py, type pyinstrument script.py. Your script will run as normal, and at the end (or when you press ^C), Pyinstrument will output a colored summary showing where most of the time was spent. Here are the options you can use: Usage: pyinstrument [options] scriptfile [arg] ... Options: --version show program's version number and exit -h, --help show this help message and exit --load-prev=ID instead of running a script, load a previous report -m MODULE_NAME run library module as a script, like 'python -m module' --from-path (POSIX only) instead of the working directory, look for scriptfile in the PATH environment variable -o OUTFILE, --outfile=OUTFILE save to \u003coutfile\u003e -r RENDERER, --renderer=RENDERER how the report should be rendered. One of: 'text', 'html', 'json', or python import path to a renderer class -t, --timeline render as a timeline - preserve ordering and don't condense repeated calls --hide=EXPR glob-style pattern matching the file paths whose frames to hide. Defaults to '*/lib/*'. --hide-regex=REGEX regex matching the file paths whose frames to hide. Useful if --hide doesn't give enough control. --show=EXPR glob-style pattern matching the file paths whose frames to show, regardless of --hide or --hide-regex. For example, use --show '*/\u003clibrary\u003e/*' to show frames within a library that would otherwise be hidden. --show-regex=REGEX regex matching the file paths whose frames to always show. Useful if --show doesn't give enough control. --show-all show everything --unicode (text renderer only) force unicode text output --no-unicode (text renderer only) force ascii text output --color (text renderer only) force ansi color text output --no-color (text renderer only) force no color text output Protip: -r html will give you a interactive profile report as HTML - you can really explore this way! ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/"},{"categories":null,"content":"Profile a specific chunk of code Pyinstrument also has a Python API. Just surround your code with Pyinstrument, like this: from pyinstrument import Profiler profiler = Profiler() profiler.start() # code you want to profile profiler.stop() profiler.print() If you get “No samples were recorded.” because your code executed in under 1ms, hooray! If you still want to instrument the code, set an interval value smaller than the default 0.001 (1 millisecond) like this: profiler = Profiler(interval=0.0001) ... Experiment with the interval value to see different depths, but keep in mind that smaller intervals could affect the performance overhead of profiling. Protip: To explore the profile in a web browser, use profiler.open_in_browser(). To save this HTML for later, use profiler.output_html(). ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/"},{"categories":null,"content":"Profile a web request in Django To profile Django web requests, add pyinstrument.middleware.ProfilerMiddleware to MIDDLEWARE_CLASSES in your settings.py. Once installed, add ?profile to the end of a request URL to activate the profiler. Your request will run as normal, but instead of getting the response, you’ll get pyinstrument’s analysis of the request in a web page. If you’re writing an API, it’s not easy to change the URL when you want to profile something. In this case, add PYINSTRUMENT_PROFILE_DIR = 'profiles' to your settings.py. Pyinstrument will profile every request and save the HTML output to the folder profiles in your working directory. If you want to show the profiling page depending on the request you can define PYINSTRUMENT_SHOW_CALLBACK as dotted path to a function used for determining whether the page should show or not. You can provide your own function callback(request) which returns True or False in your settings.py. def custom_show_pyinstrument(request): return request.user.is_superuser PYINSTRUMENT_SHOW_CALLBACK = \"%s.custom_show_pyinstrument\" % __name__ ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/"},{"categories":null,"content":"Profile a web request in Flask A simple setup to profile a Flask application is the following: from flask import Flask, g, make_response, request app = Flask(__name__) @app.before_request def before_request(): if \"profile\" in request.args: g.profiler = Profiler() g.profiler.start() @app.after_request def after_request(response): if not hasattr(g, \"profiler\"): return response g.profiler.stop() output_html = g.profiler.output_html() return make_response(output_html) This will check for the ?profile query param on each request and if found, it starts profiling. After each request where the profiler was running it creates the html output and returns that instead of the actual response. ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/pyinstrument/"},{"categories":null,"content":"认识 生成各种随机数 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/"},{"categories":null,"content":"导入 import random 模块中主要使用 random 类 API 下述方法均为 random 类的成员函数 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/"},{"categories":null,"content":"基本 random() 生成 [0,1) 的随机浮点数 seed(a: int=None) 初始化随机数生成器 a：随机数种子。若空，则使用当前系统时间 uniform(a: float, b: float) 生成浮点数 randint(a: int, b: int) 生成整型数 randrange(start, stop[, step]) 从 range(start, stop[, step]) 中随机选择一个元素 choice(seq) 从序列 seq 中获取一个随机元素 shuffle(seq) 将序列 seq 中的元素打乱，不返回，会打乱原有序列 要改变一个不可变的序列并返回一个新的打乱列表，请使用 sample(x, k=len(x)) sample(seq, len) 从序列 seq 中随机获取指定长度 len 的片段并返回 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/"},{"categories":null,"content":"分布 normalvariate(mu, sigma) 返回符合指定均值方差的正态分布的一个随机数 c = [random.normalvariate(15, 10) for i in range(1000)] ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/random/"},{"categories":null,"content":"概念 import threading threading 模块中包含了关于线程操作的丰富功能，包括：常用线程函数，线程对象，锁对象，递归锁对象，事件对象，条件变量对象，信号量对象，定时器对象，栅栏对象 此类表示在单独的控制线程中运行的活动，有两种方法可以指定该活动，一是将可调用对象传递给构造函数，二是通过覆盖子类中的 run() 方法。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/"},{"categories":null,"content":"常用属性与方法 Thread 对象数据属性 描述 name 线程名 ident 线程的标识符 daemon 布尔标志，表示这个线程是否是守护线程 Thread 对象方法 描述 init(group=None, tatget=None,args=(), kwargs ={}, verbose=None, daemon=None) 实例化一个线程对象，需要有一个可调用的 target，以及其参数 args或 kwargs。 start() 开始执行该线程 run() 定义线程功能的方法（通常在子类中被应用开发者重写） join (timeout=None) 直至启动的线程终止之前一直挂起；除非给出了 timeout（秒），否则会一直阻塞 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/"},{"categories":null,"content":"Thread 的生命周期 创建对象时，代表 Thread 内部被初始化。 调用 start() 方法后，thread 会开始运行。 thread 代码正常运行结束或者是遇到异常，线程会终止。 调用方法 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/"},{"categories":null,"content":"直接创建对象 threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) import threading import time def test(): for i in range(5): print('test ',i) time.sleep(1) thread = threading.Thread(target=test, name='TestThread') thread.start() for i in range(5): print('main ', i) time.sleep(1) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/"},{"categories":null,"content":"子类覆盖 import threading import time count = 0 # 这个MyThread类继承了threading模块的Thread类，对其下面的run方法进行了重写\"\"\" class MyThread(threading.Thread): def __init__(self , threadName): super(MyThread,self).__init__(name=threadName) \"\"\"一旦这个MyThread类被调用，自动的就会运行底下的run方法中的代码， 因为这个run方法所属的的MyThread类继承了threading.Thread\"\"\" def run(self): global count for i in range(100): count += 1 time.sleep(0.3) print(self.getName() , count) for i in range(2): MyThread(\"MyThreadName:\" + str(i)).start() ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/threading/"},{"categories":null,"content":"Time ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"概念 import time **时间戳：**格林威治时间1970年01月01日00分00秒（北京时间1970年01月01日08时00分00秒）起至现在的总秒数，是个数字。 Python中获取时间的常用方法是，先得到时间戳，再将其转换成想要的时间格式。 **元组struct_time：**日期、时间是包含许多变量的，所以在Python中定义了一个元组struct_time将所有这些变量组合在一起，包括：年、月、日、小时、分钟、秒等。 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"时间获取函数 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"time() 获取当前时间戳，返回浮点数 time.time() \u003c\u003c 1610015368.4228694 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"ctime() 获取当前时间并以易读方式表示，返回字符串 time.ctime() \u003c\u003c 'Thu Jan 7 18:30:37 2021' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"gmtime() 获取当前时间并以计算机可处理的格式表示，返回元组struct_time time.gmtime() \u003c\u003c time.struct_time(tm_year=2021, tm_mon=1, tm_mday=7, tm_hour=10, tm_min=32, tm_sec=36, tm_wday=3, tm_yday=7, tm_isdst=0) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:3","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"mktime() 把时间元组，转换为秒 time.mktime(time.gmtime()) \u003c\u003c 1609986979.0 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:4","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"asctime() 把时间元组，转换为易读形式 time.asctime(time.gmtime()) \u003c\u003c 'Thu Jan 7 10:36:57 2021' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:5","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"localtime(seconds) 将秒数转化为对应的时间元组 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:2:6","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"时间格式化 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"strftime(tpl, ts) 时间元组转字符串 tpl：时间格式化模板字符串，用来定义输出效果 形式 解释 %Y 年份 %m 月份 %B 月份名称 January %b 月份名称缩写 Jan %d 日期 %A 星期 Monday %a 星期缩写 Mon %H 小时 24 %h 小时 12 %p 上下午 %M 分钟 %S 秒 ts：是计算机内部时间类型变量。 t=time.gmtime() time.strftime(\"%Y-%m-%d%H:%M:%S\", t) \u003c\u003c '2021-01-07 10:40:34' time.strftime(\"%Y-%B-%d-%A-%H-%p-%S\") \u003c\u003c '2021-January-07-Thursday-18-PM-57' time.strftime(\"%A-%p\") \u003c\u003c 'Thursday-PM' time.strftime(\"%M:%S\") \u003c\u003c '48:37' 如果strftime没有第二个参数，则默认获取当前时间 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:3:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"strptime(timestr, tpl) 字符串转时间元组 根据时间字符串以及格式化输出，转换成结构体。 timestr：时间字符串 tpl：时间格式化模板字符串，用来定义输出效果 timestr = '2018-01-26 12:55:33' time.strptime(timestr, \"%Y-%m-%d%H:%M:%S\") \u003c\u003c time.struct_time(tm_year=2018, tm_mon=1, tm_mday=26, tm_hour=12, tm_min=55, tm_sec=33, tm_wday=4, tm_yday=26, tm_isdst=-1) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:3:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"程序计时 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"perf_counter() 测量时间，返回一个CPU级别的精确时间计数值，单位为秒 由于这个计数值起点不确定，连续调用差值才有意义 start = time.perf_counter () end = time.perf_counter() end - start \u003c\u003c 4.5900000259280205e-05 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:4:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"sleep(s) 产生时间，s为单位为秒的休眠时间，可以是浮点数，如time.sleep(3.5) time.sleep(10) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:4:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"例 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:5:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"秒数化为时间元组 second_a = 1610524866.1898422 struct_a = time.localtime(second_a) time.asctime(struct_a) \u003c\u003c 'Wed Jan 13 16:01:06 2021' time.strftime(\"%Y-%m-%d%H:%M:%S\", struct_a) \u003c\u003c '2021-01-13 16:01:06' ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:5:1","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"各种时间类型的互相转换 # datetime时间转为字符串 def datetime2str(_datetime): _str = _datetime.strftime(\"%Y-%m-%d%H:%M:%S\") return _str # 字符串时间转为时间戳 def str2stamp(_str): unix_timestamp = time.mktime(time.strptime(_str, \"%Y-%m-%d%H:%M:%S\")) return unix_timestamp # datetime时间转为时间戳 def datetime2stamp(_datetime): timestamp = time.mktime( time.strptime(_datetime.strftime(\"%Y-%m-%d%H:%M:%S\"), \"%Y-%m-%d%H:%M:%S\") ) return timestamp # 时间戳转为datetime时间 def stamp2datetime(timestamp): _datetime = datetime.datetime.fromtimestamp(timestamp) return _datetime # 时间戳转换为字符串 def stamp2str(timestamp: int): _str = time.strftime(\"%Y-%m-%d%H:%M:%S\", time.localtime(timestamp)) return _str # 字符串转换为datetime时间 def str2datetime(_str): _datetime = datetime.datetime.strptime(_str, \"%Y-%m-%d%H:%M:%S\") return _datetime ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/:5:2","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/time/"},{"categories":null,"content":"tqdm Tqdm 是一个快速，可扩展的 Python 进度条，可以在 Python 长循环中添加一个进度提示信息，用户只需要封装任意的迭代器tqdm(iterator)。 tqdm(iterator, color) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/:0:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/"},{"categories":null,"content":"使用方法一: tqdm tqdm(list) 方法可以传入任意一种list,比如数组 from tqdm import tqdm for i in tqdm(range(1000)): #do something pass 12345 或者 string 的数组 for char in tqdm([\"a\", \"b\", \"c\", \"d\"]): #do something pass123 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/:1:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/"},{"categories":null,"content":"使用方法二: trange trange(i) 是 tqdm(range(i)) 的简单写法 from tqdm import trange for i in trange(100): #do something pass1234 ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/:2:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/"},{"categories":null,"content":".set_description() 实时查看每次处理的数据 from tqdm import tqdm import time pbar = tqdm([\"a\",\"b\",\"c\",\"d\"]) for c in pbar: time.sleep(1) pbar.set_description(\"Processing %s\"%c) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/:3:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/"},{"categories":null,"content":"控制进度 from tqdm import tqdm import time #total参数设置进度条的总长度 with tqdm(total=100) as pbar: for i in range(100): time.sleep(0.05) #每次更新进度条的长度 pbar.update(1) ","date":"0001-01-01","objectID":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/:4:0","tags":null,"title":"","uri":"/Notes/posts/python/%E5%B8%B8%E7%94%A8%E5%BA%93/tqdm/"},{"categories":null,"content":"Minecraft 开服教程 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"开服步骤 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"前置步骤 在云服务器的安全组中放行 25565 的 TCP 端口 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:1","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"服务端选择 官方服务器：https://www.minecraft.net/zh-hans/download/server，下载核心 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:2","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"搭建 Java 环境 1.16 及之前版本，需要安装 Java8 sudo apt install openjdk-8-jdk 1.17 及之后版本，需要安装 Java16 sudo apt install openjdk-16-jdk 检查 Java 环境是否安装正确。 java -version 如果出现以下情况，说明安装成功： openjdk version \"1.8.0_265\" OpenJDK Runtime Environment (build 1.8.0_265-8u265-b01-0ubuntu2~18.04-b01) OpenJDK 64-Bit Server VM (build 25.265-b01, mixed mode) ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:3","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"运行服务端 官方服务端 运行核心 java -Xms512M -Xmx1024M -jar \u003c服务器核心的文件名\u003e nogui 将会收到如下的报错信息，需要我们同意相关协议： [14:58:23] [main/ERROR]: Failed to load properties from file: server.properties [14:58:23] [main/WARN]: Failed to load eula.txt [14:58:23] [main/INFO]: You need to agree to the EULA in order to run the server. Go to eula. 同意相关协议 vim eula.txt 把最后一行的 false 修改为 true ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:4","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"修改配置 vim server.properties ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:5","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"安装 Mod 下载对应版本的 forge，拷贝到服务端根目录 运行命令： java -jar \u003cforge_name\u003e --install 等待下载完成，出现如下提示： The server installed successfully You can delete this installer file now if you wish 失败就多来几次 之后开服都用这个命令： java -jar -Xms512M -Xmx1024M \u003cforge_name 去掉 installer\u003e ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"优化 java -server -Xincgc -Xmx最大内存M -Xms最小内存M -Xss512K -XX:+AggressiveOpts -XX:+UseCompressedOops -XX:+UseCMSCompactAtFullCollection -XX:+UseFastAccessorMethods -XX:ParallelGCThreads=4 -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=2 -XX:CMSInitiatingOccupancyFraction=70 -XX:-DisableExplicitGC -XX:TargetSurvivorRatio=90 -jar 服务端核心.jar 详见：https://www.mcbbs.net/thread-839828-1-1.html ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"优质 Mod 动物谷：https://www.mcmod.cn/class/1467.html 魔戒：https://www.mcmod.cn/class/2525.html 矿物树：https://www.mcmod.cn/class/4106.html 水产养殖：https://www.mcmod.cn/class/281.html ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:4:0","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"物品分类思路 搭配储物抽屉 mod ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:0","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"矿石 金、铁、红石：压缩 钻石、青金石、煤、木炭：1*1 留空 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:1","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"食物 马铃薯（1*1）、猪排、牛排、鸡肉、兔肉、羊肉、鲑鱼、鳕鱼：生熟1*2 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:2","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"种子 南瓜、苹果、蘑菇煲、河豚、蛋糕：2*2 西瓜片、小麦、干海带、面包、胡萝卜、甜菜根 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:3","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"木材 橡木、白桦、深色橡木、云杉、丛林、金合欢的原木：1*1 橡木、白桦、深色橡木、云杉、丛林、金合欢的木板：1*1 橡木、白桦、深色橡木、云杉、丛林、金合欢的树苗：2*2 橡木、白桦、深色橡木、云杉、丛林、金合欢的楼梯：2*2 橡木、白桦、深色橡木、云杉、丛林、金合欢的台阶：2*2 （不重要）橡木、白桦、深色橡木、云杉、丛林、金合欢的原木的栅栏:2*2 （不重要）橡木、白桦、深色橡木、云杉、丛林、金合欢的原木的栅栏门：2*2 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:4","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"合成材料 木棒、皮革、海草：1*2 燃料 15、幻翼膜、恶魂泪：2*2 萤石粉、烈焰棒、末影珍珠：1*1 各种其他植物（包括染料植物）：留出9个2*2 腐肉：1*1 骨头：压缩 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:5","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"多色物品 羊毛 15、混凝土 15、玻璃、玻璃板 15：2*2 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:6","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"武器装备 钓鱼竿、打火石、剪刀 锹、镐、斧、锄 剑、弓 箭 盔、甲、腿、靴 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:7","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"工具 火把 梯子、工作台、熔炉、箱子、展示框、活塞、铁轨、充能铁轨、命名牌、拴绳、鞍等等：预留9个2*2 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:8","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"建筑材料 部分建筑材料归类到多色物品中 玻璃、石英块：1*2 （不重要）原石墙 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:9","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"其他方块 书架、灵魂沙、菌丝、末地石、TNT、冰：2*2 （不重要）泥土、圆石、花岗岩、闪长岩、安山岩：1*2 沙子、沙砾、砂土：1*1 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:10","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"载具 仪表盘 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:11","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"不做分类的物品 床、铁栏杆、告示牌、压力板、按钮、门、船 ","date":"0001-01-01","objectID":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:12","tags":null,"title":"","uri":"/Notes/posts/useful/minecraft-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Steam 开服教程 Linux 系统：ubuntu 20.04 LTS 支持创建服务器的游戏：https://steamdb.info/search/?a=app\u0026q=server 游戏名 编号 Unturned 1110390 注意事项 关闭 Linux 防火墙 在控制台开启相应端口 n 与 n+1 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"准备 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"安装依赖 apt-get install lib32gcc1 -y ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:1","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"下载 SteamCMD cd ~ mkdir SteamCMD cd SteamCMD wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz # 下载 tar -xvzf steamcmd_linux.tar.gz # 解压 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:1:2","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"配置 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"启动 SteamCMD cd ~/SteamCMD ./steamcmd.sh ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:1","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"登录 SteamCMD login \u003cusername\u003e \u003cpassword\u003e # or login anonymous # 匿名登陆 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:2","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"设置安装目录 # force_install_dir \u003c安装目录\u003e force_install_dir GameServer/UnturnedServer # 这是相对路径 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:3","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"安装游戏 App_update \u003cgame_id\u003e validate ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:4","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"退出 quit ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:2:5","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"设置自动更新 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"创建脚本文件 cd ~ mkdir sh cd sh vi updateUnturned.sh ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:3:1","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"编写脚本 内容如下例： ~/SteamCMD/steamcmd.sh +login anonymous +force_install_dir GameServer/UnturnedServer +App_update 1110390 validate +quit ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:3:2","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"设置自动执行 crontab -e # 打开自动执行设置 # * * * * * \u003c执行对象\u003e 用法: *(min) *(hour) *(day) *(month) *(year) * * 1 * * ~/sh/updateUnturned.sh ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:3:3","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"启动服务器 cd ~/GameServer/UnturnedServer # 用法: ./ServerHelper.sh +InternetServer/\u003c名称\u003e  ./ServerHelper.sh +InternetServer/ApparentServer-UN save 保存，shutdown 关闭 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:4:0","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"游戏配置 ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:0","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Unturned 配置文件为 Servers/ApparentServer-UN/Server/Commands.dat Name \u003c服务器名称\u003e #设置服务器名称 Port \u003c端口号\u003e #设置服务器端口 Password \u003c密码\u003e #设置服务器密码 Maxplayers \u003c最大人数\u003e #设置服务器最大人数 Map \u003c地图（英文名）\u003e #设置服务器地图 Mode Easy | Normal | Hard #设置服务器难度（简单 | 普通 | 困难） Perspective first-person | third-person | both #设置服务器视角（第一人称 | 第三人称 | 全部） pve|pvp #设置服务器模式（pve 关闭队友伤害， pvp 打开队友伤害） Welcome \u003c欢迎语\u003e #设置服务器欢迎语 cheats disable | on #设置服务器作弊（关闭 | 打开） loadout \u003cID/ID/ID...\u003e #设置出生装备 Owner \u003cID\u003e #服务器所有者 英灵神殿：App_update 892970 validate ","date":"0001-01-01","objectID":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/:5:1","tags":null,"title":"","uri":"/Notes/posts/useful/steam-%E5%BC%80%E6%9C%8D%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一些老是忘掉的常识 字节与比特 字节 B 用来表示文件的大小，KB，MB，GB 互隔 2^10^ 作为存储容量时，有时会互隔 1000 比特每秒 bps 用来表示网络速度，Kbps，Mbps，Gbps 互隔 2^10^ 移位运算 \u003c\u003c 左移：右边空出的位置补 0，其值相当于乘以 2 \u003e\u003e 右移：左边空出的位 如果是正数则补 0，若为负数则补 0 或 1，取决于所用的计算机系统 OS X 中补1 其值相当于除以 2，向下取整 按位运算 \u0026 按位与 只要任何一位是 0，\u0026 运算的结果就是 0，所以可以用 \u0026 把某个变量不必要的位设为 0 比如某个变量的二进制表示为 0 1 0 0 1 0 0 1, 我想保留低 4 位，消除高 4 位，用 \u0026 0x0F 就可以了（注：0x0F 为 16 进制表示法，对应的二进制为 0 0 0 0 1 1 1 1），这个特性在编码中使用很广泛。 一个整数 n，n\u00261 这个表达式可以用来判断 a 的奇偶性。 二进制的末位为 0 表示偶数，末位为 1 表示奇数。 使用 n%2 来判断奇偶性 和 n\u00261 是一样的作用，但是 n\u00261 要快好多。 | 按位或 ^ 按位异或 ~ 取反 动态类型语言 动态性语言是指在运行期间才去做数据类型检查的语言 使用动态类型语言编程时，永远不用给任何变量指定数据类型，该语言会在第一次赋值给变量时，在内部将数据类型记录下来。 Python 和 Ruby 就是一种典型的动态类型语言，其他的各种脚本语言如 VBScript 也多少属于动态类型语言 静态类型语言 静态类型语言的数据类型在编译期间检查 使用静态类型语言写程序时要声明所有变量的数据类型 C/C++ 是静态类型语言的典型代表，其他静态语言还有 C#、Java 等 强类型语言 强制类型定义的语言 即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就死该数据类型。 强类型语言包括：Java、.net、Python、C++ 等语言 其中 Python 是动态语言，是强类型定义语言，是类型安全的语言 Java 是静态语言，是强类型定义语言，也是类型安全的语言 弱类型语言 某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换。 弱类型语言包括：VB，PHP，JavaScript 等语言。 其中 VBScript 是动态语言，是一种类型不安全的原因 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E4%B8%80%E4%BA%9B%E8%80%81%E6%98%AF%E5%BF%98%E6%8E%89%E7%9A%84%E5%B8%B8%E8%AF%86/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E4%B8%80%E4%BA%9B%E8%80%81%E6%98%AF%E5%BF%98%E6%8E%89%E7%9A%84%E5%B8%B8%E8%AF%86/"},{"categories":null,"content":"配置 Gitbook ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-gitbook/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-gitbook/"},{"categories":null,"content":"插件 theme-comscore：颜色主题 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-gitbook/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-gitbook/"},{"categories":null,"content":"客户端 ubuntu ssh 配置：https://blog.csdn.net/netwalk/article/details/12952051 ubuntu ssh 实现无密码登录：https://blog.csdn.net/weixin_33725126/article/details/91726998 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-ssh/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-ssh/"},{"categories":null,"content":"配置私钥 ssh-keygen ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-ssh/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-ssh/"},{"categories":null,"content":"连接服务端 ssh username@ip [-p port] 在 .ssh 目录中打开 bash，将客户端的公钥放到服务端上 ssh-copy-id username@ip 然后就可以使用私钥登录 ssh username@ip [-p port] -i id_rsa ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-ssh/:2:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-ssh/"},{"categories":null,"content":"配置 Typora ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-typora/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-typora/"},{"categories":null,"content":"自动添加标题序号 新建 base.user.css 文件，内容如下 /** initialize css counter */ #write { counter-reset: h1; } h1 { counter-reset: h2; } h2 { counter-reset: h3; } h3 { counter-reset: h4; } h4 { counter-reset: h5; } h5 { counter-reset: h6; } /** put counter result into headings */ #write h1:before { counter-increment: h1; /**content: counter(h1) \" \";**/ } #write h2:before { counter-increment: h2; content: counter(h2) \". \"; } #write h3:before, h3.md-focus.md-heading:before /** override the default style for focused headings */ { counter-increment: h3; content: counter(h2) \".\" counter(h3) \" \"; } #write h4:before, h4.md-focus.md-heading:before { counter-increment: h4; content: counter(h2) \".\" counter(h3) \".\" counter(h4) \" \"; } #write h5:before, h5.md-focus.md-heading:before { counter-increment: h5; content: counter(h5) \") \"; } #write h6:before, h6.md-focus.md-heading:before { counter-increment: h6; content: counter(h6) \". \"; } /** override the default style for focused headings */ #write \u003e h3.md-focus:before, #write \u003e h4.md-focus:before, #write \u003e h5.md-focus:before, #write \u003e h6.md-focus:before, h3.md-focus:before, h4.md-focus:before, h5.md-focus:before, h6.md-focus:before { color: inherit; border: inherit; border-radius: inherit; position: inherit; left: initial; float: none; top: initial; font-size: inherit; padding-left: inherit; padding-right: inherit; vertical-align: inherit; font-weight: inherit; line-height: inherit; } ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-typora/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-typora/"},{"categories":null,"content":"配置 Visual Studio ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/"},{"categories":null,"content":"美化 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/"},{"categories":null,"content":"主题 One Dark Pro ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/:1:1","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/"},{"categories":null,"content":"代码配色优化 配色参考 http://www.360doc.com/content/13/1023/17/1427138_323568638.shtml http://www.360doc.com/content/14/0730/07/12530471_398042223.shtml 注释 (85, 107, 80) (127, 132, 142) 变量（标识符） (200, 200, 169) (178, 200, 187) ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/:1:2","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-visual-studio/"},{"categories":null,"content":"配置 Windows Terminal ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"设置 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"主题 放在 schemes 中 https://windowsterminalthemes.dev/ { \"name\": \"Afterglow\", \"black\": \"#151515\", \"red\": \"#ac4142\", \"green\": \"#7e8e50\", \"yellow\": \"#e5b567\", \"blue\": \"#6c99bb\", \"purple\": \"#9f4e85\", \"cyan\": \"#7dd6cf\", \"white\": \"#d0d0d0\", \"brightBlack\": \"#505050\", \"brightRed\": \"#ac4142\", \"brightGreen\": \"#7e8e50\", \"brightYellow\": \"#e5b567\", \"brightBlue\": \"#6c99bb\", \"brightPurple\": \"#9f4e85\", \"brightCyan\": \"#7dd6cf\", \"brightWhite\": \"#f5f5f5\", \"background\": \"#212121\", \"foreground\": \"#d0d0d0\", \"selectionBackground\": \"#303030\", \"cursorColor\": \"#d0d0d0\" }, ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:1:1","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"其他配置 放在 defaults 中 \"acrylicOpacity\": 0.85, //背景透明度(0-1) \"useAcrylic\": true, // 启用毛玻璃 //\"backgroundImage\": \"D:/User/chuchur/OneDrive/图片/stack.jpg\", //背景图片 //\"backgroundImageOpacity\": 0.1, //图片透明度（0-1） //\"experimental.retroTerminalEffect\": true, //复古的CRT 效果 //\"backgroundImageStretchMode\": \"uniformToFill\", //填充模式 //\"icon\": \"ms-appx:///ProfileIcons/{9acb9455-ca41-5af7-950f-6bca1bc9722f}.png\", //图标 \"fontFace\": \"MesloLGM NF\", //\"fontSize\": 12, //文字大小 //\"fontWeight\": \"normal\", //文字宽度，可设置加粗 \"colorScheme\": \"Afterglow\", //主题名字 //\"cursorColor\": \"#FFFFFF\", //光标颜色 \"cursorShape\": \"bar\", //光标形状 //\"cursorHeight\": 10, \"startingDirectory\": \"D://Repo\", //起始目录 //\"antialiasingMode\": \"cleartype\" //消除文字锯齿 \"showTabsInTitlebar\": false ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:2:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"美化 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:3:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"字体 Nerd Fonts 下载：https://www.nerdfonts.com/font-downloads 修改配置 \"fontFace\": \"DejaVuSansMono Nerd Font\" // Cousine Nerd Font Meslo LGM NF 下载：https://github.com/ryanoasis/nerd-fonts/releases/download/v2.1.0/Meslo.zip ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:3:1","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"oh-my-posh 官网：https://ohmyposh.dev/docs/ 安装 第一条命令（绕过power shell执行策略，使其可以执行脚本文件\u003c后面会用到\u003e） Set-ExecutionPolicy Bypass 第二条命令（oh-my-posh提供主题） Install-Module oh-my-posh -Scope CurrentUser 第三条命令（posh-git将git信息添加到提示中） Install-Module posh-git -Scope CurrentUser PowerShell 配置 第一条（启动编辑power shell配置文件的引擎） if (!(Test-Path -Path $PROFILE )) { New-Item -Type File -Path $PROFILE -Force } 第二条（使用记事本打开配置文件） notepad $PROFILE 2.在打开的记事本中写入如下内容（脚本文件），并保存 Import-Module posh-git Import-Module oh-my-posh Set-PoshPrompt -Theme blueish # Set-PoshPrompt -Theme marcduiker # Set-PoshPrompt -Theme remk # Set-PoshPrompt -Theme powerlevel10k_rainbow 第一条命令表示导入posh-git 第二条命令表示导入oh-my-posh 第三条命令表示设置主题为JanDeDobbeleer 配置完后，每次打开Windows Terminal中的Power shell都会执行脚本文件中的三条命令。 查看操作 预览所有主题 Get-PoshThemes ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:3:2","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"在 vscode 中配置 power shell 样式 设置中查找 Integrated:Font Family 输入 Cousine Nerd Font DejaVuSansMono Nerd Font MesloLGM NF ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:3:3","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"添加 SSH { \"guid\": \"{4cbd411b-c4a8-d899-abb1-e2f69c6be01c}\", \"hidden\": false, \"name\": \"CentOS\", \"commandline\": \"ssh u@ip\" } ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/:4:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%85%8D%E7%BD%AE-windowsterminal/"},{"categories":null,"content":"项目介绍 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/:0:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"TieBreaker ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/:1:0","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"比赛模拟系统 功能设计 因为这个游戏的本质是对现实世界中足球比赛的模拟，所以要模拟到多细，决定了整体设计的难度上限，我们的选择是：将数值对抗的粒度细分到了球员层面，将战术执行的粒度细分到球队体系层面。 球员之间的数值对抗：我们为球员设计了一个多维度的能力体系；传球、防守、射门……每个球员都有自己的强项和弱项；球员能力的强弱体现在动作对抗中成功率的高低。（最直观的例子就是进攻球员的射门属性与守门员的扑救属性之间的对抗），属性越高，赢得这次对抗的几率自然就越大。一场比赛的胜负就是在一次次的对抗中见分晓的。 球队之间的战术选择：因为足球比赛的本质就是两队之间战术思想的碰撞，我们只要把一个个进攻与防守的战术思想实现在代码中，就把握住了一场比赛的精髓。 我们选取了几个经典的足球战术，将其抽象成了脚本代码，何时跑位，把球传给谁，拿到球了是过人还是传中？这些作为球员个体的选择和考量，都被提前到了战术层面解决了。 有了战术，球员就有了场上职责的划分，后卫专注于防守，中场球员专注于球权的控制，而前锋负责临门一脚，不同职责所要求的能力也不同，这也突出了球员的个性化分类 所以，整场比赛被划分成了若干个回合，每个回合由一支队伍发起战术进攻 细化到每个球员的能力值 考虑什么？球员场上的职责？球员之间的配合？战术？战略？意外情况？ 为球员赋予意识——球场上瞬息万变，有这么多的不确定因素影响着比赛的进程，为每一个位场上球员建立极其复杂精细的模型，做不了 怎么在不丢掉精髓的情况下，尽量还原一场比赛呢？ 注意到，我们是站在一个观者角度俯瞰一场比赛的，这个比赛引擎本身是一个黑盒，观者可以不知道比赛的运作原理，但是这个系统的输出必须富有真实感：它可以没有画面，但有文字的解说，实时播报、有球队进攻防守的各项数据统计、根据球员表现的打分等等等等，这一切的一切呈现给观者，让观者觉得欸，他们确实在打一场比赛啊 那么我们大可不必过分地关注球员作为个体在场上的决策，而将重点转移到战术层面上 抽象到战术层面上 会发现不论绿茵场上的情形如何千变万化，本质上就是两队间进攻与防守战术的对抗 在这种思想里面，球员聚合成一个整体，他们互相配合，共同完成战术中的动作 虽然这看起来像有一双无形的手控制每个球员的思想，但是他的确在保留了大部分真实性的基础上，简化了比赛流程 战术分割成一个个小动作，动作的共性：对抗性（引入球员的能力值，为能力值赋予了意义） 动作成对出现——进攻球员与防守球员的对抗 动作的成功率能否用球员的能力属性来量化呢？ 能力值如何与动作上的对抗产生联系？ 对抗必然有输赢（一次对抗仅仅有一次结果，不能说明任何问题，而当对抗的次数足够多时，这些结果便具有了统计学上的意义） 例 我跟 C 罗比过人，一次尝试并不能证明 C 罗就比我强 当尝试的样本量足够大时，我跟 C 罗的对抗数据便具有统计意义 这些对抗数据最终量化成我的能力值和 C 罗的能力值 所以我们可以根据球员的能力值来预判动作的成功率 最后动作成功率外化为球员对应属性的能力值 如何预判动作的结果？动作上的对抗——数值的对抗——本质上就是概率的对抗 如何设计动作？传球（传接球技术，加上对球路的预判）、过人与拦截、争顶、速度、射门与扑救 如何设计战术？动作的集合，中路进攻、边路进攻、特殊的防反 阵容：每个球员要有一个固定的位置 定义一些最基本的位置：守门员、中锋、边锋、中场、中卫、边卫 另外的职位呢？前腰、后腰、自由人 —— 每一回合开始时按一定概率转变成六大基本职责之一 前腰：中路组织、在禁区抓机会 一场比赛分为若干回合，每一回合有个持球方，由持球方来选择他们的进攻战术 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/:1:1","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"用到的一些设计模式思想 里氏替换原则 所有引用父类的地方必须能透明地使用其子类的对象。人机比赛的逻辑继承自 AI 间比赛的逻辑，他们的方法参数和返回值类型都被设计成相同的格式，这让两种比赛模式的对外接口保持一致， 子类拓展了父类的功能，并没有重写父类的功能：每一回合结束时，人机比赛要求保存当前回合的一些临时数据，并将场上实时数据的变化发送给前端，这是子类特有的功能，至于其他选择战术、执行战术、球权转换判断、加时判断等基础功能原封不动地继承自 AI 比赛。 单例模式 只使用一个球员生成器来生成成千上万个虚拟球员信息，符合单例模式的思想，避免造成资源的浪费。因为生成器在实例化的过程中会访问一些静态文件（人名啊国籍啊什么的），反复实例化会造成性能的大量消耗。 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/:1:2","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"遇到的一些困难 提升比赛速度 db.commit() eval() 一些小算法 获取随机数：一条直线，随机地掉落一颗球，看看它在哪个区域 生成联赛日程：随机挑一半，跟另一半匹配 选人算法 以球员最擅长位置为标准挑 以每个位置最高能力值为标准挑 ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/:1:3","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"学到的东西 没有任何一个项目是十全十美，你需要在开发效率和程序运行效率上做权衡取舍 出于对开发效率和程序性能的考虑，你可能需要去打破一些既定的规范 将 json 字符串作为字串存在了关系型数据库中。 日程表： 第一范式、json：回合制游戏 - 一天一回合 - 后端需要知道下一天该做什么 - 转会、比赛 - 需要构建一张日程表来推动游戏发展 - 如何去设计数据类型？ - json、嵌套显然最适合 - 列表：存储着日程关键字 - 简单的关键字：转会 - 复杂的关键字：比赛，什么比赛，跟谁打 - 考虑前后端交互的问题：json - 放在 NoSQL 里很适合 - 个人局限、开发效率：不会花额外时间去重构模块 - 存在了 MySQL 里 球员头像 球员头像用的一个开源库 - 一个头像有很多部分组成：眼睛、鼻子、耳朵 - 每一个属性都有很多 - 封装成一个 JS 的对象 - 唯一的确定一个头像的样子 - 这个 json 就需要存储到数据库里 - 传统：需要建一张表：这个球员的眼睛是什么样子的 - 麻烦 为啥不用 NOSQL： 开发效率：不是很熟悉；引入 NoSQL 的时间成本太高 未来肯定是第一选择 为啥不分表： 表连接带来的开销肯定比解析一个 json 字符串来得大 为啥不用 MySQL 的 JSON 字段 不怎么需要修改 ORM 库不支持 不合时宜的优雅需要摒弃 优化 索引 save_id 适当冗余 game_id save_id ","date":"0001-01-01","objectID":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/:1:4","tags":null,"title":"","uri":"/Notes/posts/useful/%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"31. 下一个排列 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。 必须 原地 修改，只允许使用额外常数空间。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/31.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/31.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":null,"content":"解 其实就是从数组倒着查找，找到 nums[i] 比 nums[i+1] 小的时候，就将 nums[i] 跟 nums[i+1] 到nums[len(nums) - 1] 当中找到一个最小的比 nums[i] 大的元素交换。交换后，再把 nums[i+1] 到 nums[len(nums) - 1] 排序，就 ok 了 func nextPermutation(nums []int) { i, j := 0, 0 for i = len(nums) - 2; i \u003e= 0; i-- { if nums[i] \u003c nums[i+1] { break } } if i \u003e= 0 { for j = len(nums) - 1; j \u003e i; j-- { if nums[j] \u003e nums[i] { break } } swap(\u0026nums, i, j) } reverse(\u0026nums, i+1, len(nums)-1) } func reverse(nums *[]int, i, j int) { for i \u003c j { swap(nums, i, j) i++ j-- } } func swap(nums *[]int, i, j int) { (*nums)[i], (*nums)[j] = (*nums)[j], (*nums)[i] } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/31.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/31.-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"categories":null,"content":"搜索旋转排序数组 binary search 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/33.-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/33.-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":null,"content":"二分 如果中间的数小于最右边的数，则右半段是有序的，若中间数大于最右边数，则左半段是有序的，我们只要在有序的半段里用首尾两个数组来判断目标值是否在这一区域内，这样就可以确定保留哪半边了 // 二分法 func search(nums []int, target int) int { if len(nums) == 0 { return -1 } low, high := 0, len(nums)-1 for low \u003c= high { // 开始二分 mid := low + (high-low)\u003e\u003e1 if nums[mid] == target { return mid } else if nums[mid] \u003e nums[high] { // 中间值大于右边值 左边必然有序 if nums[low] \u003c= target \u0026\u0026 target \u003c nums[mid] { // 落在左边部分 high = mid - 1 } else { low = mid + 1 } } else { // 中间值小于右边值 右边必然有序 if nums[mid] \u003c target \u0026\u0026 target \u003c= nums[high] { // 落在右边部分 low = mid + 1 } else { high = mid - 1 } } } return -1 } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/33.-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/33.-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/"},{"categories":null,"content":"在排序数组中查找元素的第一个和最后一个位置 mid binary search 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/34.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/34.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"categories":null,"content":"二分 这一题是经典的二分搜索变种题。二分搜索有 4 大基础变种题： 查找第一个值等于给定值的元素 查找最后一个值等于给定值的元素 查找第一个大于等于给定值的元素 查找最后一个小于等于给定值的元素 这一题的解题思路可以分别利用变种 1 和变种 2 的解法就可以做出此题。 或者用一次变种 1 的方法，然后循环往后找到最后一个与给定值相等的元素。不过后者这种方法可能会使时间复杂度下降到 O(n)，因为有可能数组中 n 个元素都和给定元素相同。(4 大基础变种的实现见代码) package leetcode func searchRange(nums []int, target int) []int { return []int{searchFirstEqualElement(nums, target), searchLastEqualElement(nums, target)} } // 二分查找第一个与 target 相等的元素，时间复杂度 O(logn) func searchFirstEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if nums[mid] \u003e target { high = mid - 1 } else if nums[mid] \u003c target { low = mid + 1 } else { if (mid == 0) || (nums[mid-1] != target) { // 找到第一个与 target 相等的元素 return mid } high = mid - 1 } } return -1 } // 二分查找最后一个与 target 相等的元素，时间复杂度 O(logn) func searchLastEqualElement(nums []int, target int) int { low, high := 0, len(nums)-1 for low \u003c= high { mid := low + ((high - low) \u003e\u003e 1) if nums[mid] \u003e target { high = mid - 1 } else if nums[mid] \u003c target { low = mid + 1 } else { if (mid == len(nums)-1) || (nums[mid+1] != target) { // 找到最后一个与 target 相等的元素 return mid } low = mid + 1 } } return -1 } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/34.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/34.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"categories":null,"content":"一次二分 一次二分，找到某一个与 target 相等的元素，然后再前后找。比较慢，可能下降到 O(n) func searchRange(nums []int, target int) []int { if len(nums) == 0 { return []int{-1, -1} } firstIndex, lastIndex := -1, -1 low, high := 0, len(nums)-1 for low \u003c= high { mid := (low + high) \u003e\u003e 1 if target \u003e nums[mid] { low = mid + 1 } else if target \u003c nums[mid] { high = mid - 1 } else { firstIndex, lastIndex = mid, mid for firstIndex \u003e= low \u0026\u0026 nums[firstIndex] == target { firstIndex-- } for lastIndex \u003c= high \u0026\u0026 nums[lastIndex] == target { lastIndex++ } return []int{firstIndex + 1, lastIndex - 1} } } return []int{-1, -1} } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/array/34.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/array/34.-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/"},{"categories":null,"content":"剑指 Offer 13. 机器人的运动范围 mid DFS BFS DP 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。 一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。 请问该机器人能够到达多少个格子？ 示例 1： 输入：m = 2, n = 3, k = 1 输出：3 示例 2： 输入：m = 3, n = 1, k = 0 输出：1 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"categories":null,"content":"分析 题目特点： 无论是 DFS 还是 BFS，向右和向下走就能覆盖所有位置 可达范围呈三角形状 各位之和算法： // 获取各位数之和 func getSum(num int) (res int) { for num != 0 { res += num % 10 num /= 10 } return } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"categories":null,"content":"DFS // DFS func movingCount(m int, n int, k int) int { visited := make([][]bool, m) // 存储已遍历过的坐标 for i, _ := range visited { visited[i] = make([]bool, n) } res := 0 var backtracking func(i, j int) backtracking = func(i, j int) { if i \u003c 0 || i \u003e m-1 || j \u003c 0 || j \u003e n-1 { // 越界 return } if visited[i][j] { // 已被遍历过 return } visited[i][j] = true if getSum(i)+getSum(j) \u003c= k { res++ backtracking(i+1, j) // 下 backtracking(i, j+1) // 右 } } backtracking(0, 0) return res } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"categories":null,"content":"BFS // BFS func movingCount2(m int, n int, k int) int { visited := make([][]bool, m) // 存储已遍历过的坐标 for i, _ := range visited { visited[i] = make([]bool, n) } res := 0 stack := list.New() stack.PushBack([2]int{0, 0}) var curPos [2]int var i, j int for stack.Len() != 0 { // 出栈 curPos = stack.Front().Value.([2]int) stack.Remove(stack.Front()) i, j = curPos[0], curPos[1] if i \u003c 0 || i \u003e m-1 || j \u003c 0 || j \u003e n-1 { // 越界 continue } if visited[i][j] { // 已经遍历过 continue } visited[i][j] = true if getSum(i)+getSum(j) \u003c= k { res++ // 右边和下边入队 stack.PushBack([2]int{i + 1, j}) stack.PushBack([2]int{i, j + 1}) } } return res } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/:3:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"categories":null,"content":"DP 位置 i, j 是否可达取决于： i-1, j 或 i,j-1 任意一个是否可达 i, j 位数和是否小于等于 k // dp func movingCount3(m int, n int, k int) int { visited := make(map[[2]int]bool) visited[[2]int{0, 0}] = true res := 1 for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { if getSum(i)+getSum(j) \u003c= k \u0026\u0026 (visited[[2]int{i - 1, j}] || visited[[2]int{i, j - 1}]) { res++ visited[[2]int{i, j}] = true } } } return res } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/:4:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-13.-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"},{"categories":null,"content":"剑指 Offer 34. 二叉树中和为某一值的路径 mid DFS 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点路径总和等于给定目标和的路径。 叶子节点是指没有子节点的节点。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"categories":null,"content":"DFS 每个递归维护一个数组，保存历史路径上的节点值；每次查到底，发现路径和满足要求就将数组添加到结果中。 注意 road 是一个切片，底层是指针，添加到 res 中时需要深拷贝 func sum(nums []int) (sum int) { for _, num := range nums { sum += num } return } func pathSum(root *TreeNode, target int) [][]int { res := make([][]int, 0) var backtracking func(root *TreeNode, road []int) backtracking = func(root *TreeNode, road []int) { if root == nil { return } road = append(road, root.Val) if sum(road) == target \u0026\u0026 root.Left == nil \u0026\u0026 root.Right == nil { // 到叶子节点 且路径和等于目标值 tmp := make([]int, len(road)) // 拷贝切片 copy(tmp, road) res = append(res, tmp) return } backtracking(root.Left, road) backtracking(root.Right, road) } backtracking(root, []int{}) return res } 回溯函数还可以传值，road 由一个变量统一维护： func pathSum(root *TreeNode, target int) [][]int { res := make([][]int, 0) road := make([]int, 0) var backtracking func(root *TreeNode, leftVal int) backtracking = func(root *TreeNode, leftVal int) { if root == nil { return } road = append(road, root.Val) defer func() { road = road[:len(road)-1] // 收回最后一步 }() leftVal -= root.Val if leftVal == 0 \u0026\u0026 root.Left == nil \u0026\u0026 root.Right == nil { // 到叶子节点 且路径和等于目标值 res = append(res, append([]int{}, road...)) // 拷贝 因为road唯一 会不断变化 return } backtracking(root.Left, leftVal) backtracking(root.Right, leftVal) } backtracking(root, target) return res } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-34.-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"},{"categories":null,"content":"剑指 Offer 36. 二叉搜索树与双向链表 mid 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 以下面的二叉搜索树为例： 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"DFS 二叉树中序遍历模板 双指针记录头结点和前驱 中序遍历顺着 Left 指针入栈，为了不破坏次序。利用 Right 指针在回溯的过程中指向上一层的节点（强行解释）。但已经回溯到上一层时怎么利用之前的节点呢。那就用 pre 变量保存前驱节点。当前节点（实际上已经回溯到上一层了）的 Left 指针指向前驱。这样约定好了之后。递归处理即可 置为双向循环链表 func treeToDoublyList(root *TreeNode) *TreeNode { if root == nil { return nil } var pre, head *TreeNode var inOrder func(root *TreeNode) inOrder = func(root *TreeNode) { if root == nil { return } inOrder(root.Left) if pre == nil { // 遍历到头节点 head = root } root.Left = pre pre.Right = root pre = root inOrder(root.Right) } inOrder(root) // pre最终指向尾结点 pre.Right = head head.Left = pre return head } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-36.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"剑指 Offer 54. 二叉搜索树的第k大节点 给定一棵二叉搜索树，请找出其中第 k 大的节点的值。 示例 1: 输入: root = [3,1,4,null,2], k = 1 3 / \\ 1 4 \\ 2 输出: 4 输入: root = [5,3,6,2,4,null,null,1], k = 3 5 / \\ 3 6 / \\ 2 4 / 1 输出: 4 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"DFS 中序遍历倒序，即中右左，这样就能转化为求中序遍历倒序第 k 个结点值 func kthLargest(root *TreeNode, k int) int { var dfs func(root *TreeNode) var i, res int dfs = func(root *TreeNode) { if root == nil { return } dfs(root.Right) i++ if i == k { res = root.Val } dfs(root.Left) } dfs(root) return res } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/back-tracking/%E5%89%91%E6%8C%87-offer-54.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"剑指 Offer 10- I. 斐波那契数列 easy 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N \u003e 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：1 示例 2： 输入：n = 5 输出：5 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":null,"content":"解 还省去了一张 O(n) 的表，妙哉 // DP func fib2(n int) int { const mod int = 1e9 + 7 if n \u003c 2 { return n } a, b, sum := 0, 0, 1 for i := 2; i \u003c= n; i++ { a = b b = sum sum = (a + b) % mod } return sum } func totalFruit(fruits []int) int { if len(fruits) == 0 { return 0 } dp := make([]int, len(fruits)) dp[0] = 1 a, b, aIndex, bIndex := -1, fruits[0], -1, 0 maxResult := 1 for i := 1; i \u003c len(fruits); i++ { if fruits[i] == a || fruits[i] == b { // 加老果子 if fruits[i] == a { aIndex = i } if fruits[i] == b { bIndex = i } dp[i] = dp[i-1] + 1 } else { // 换新果子 var length int // 计算最近一类果实的长度 并覆盖掉丢弃果子的种类 if aIndex \u003e bIndex { length = aIndex - bIndex b = fruits[i] bIndex = i } else { length = bIndex - aIndex a = fruits[i] aIndex = i } dp[i] = length + 1 } if maxResult \u003c dp[i] { maxResult = dp[i] } } return maxResult } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":null,"content":"滑动窗口 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-i.-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"},{"categories":null,"content":"剑指 Offer 10- II. 青蛙跳台阶问题 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 示例 1： 输入：n = 2 输出：2 示例 2： 输入：n = 7 输出：21 示例 3： 输入：n = 0 输出：1 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"解 这就是斐波那契数列嘛 func numWays(n int) int { const mod = 1e9 + 7 a, b, sum := 0, 1, 1 for i := 2; i \u003c= n; i++ { a = b b = sum sum = (a + b) % mod } return sum } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-10-ii.-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"剑指 Offer 42. 连续子数组的最大和 easy 输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 要求时间复杂度为O(n)。 示例1: 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"categories":null,"content":"DP 用 f(i) 代表以第 i 个数结尾的「连续子数组的最大和」 f(i)=max{f(i−1)+nums[i],nums[i]} func maxSubArray(nums []int) int { dp := make([]int, len(nums)) dp[0] = nums[0] maxResult := dp[0] for i := 1; i \u003c len(nums); i++ { if dp[i-1]+nums[i] \u003e nums[i] { dp[i] = dp[i-1] + nums[i] } else { dp[i] = nums[i] } if dp[i] \u003e maxResult { maxResult = dp[i] } } return maxResult } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"categories":null,"content":"更简便的方法 因为 dp[i] 只与 dp[i-1] 相关，所以用一个 pre 变量接住 dp[i-1] 将空间复杂度降至 O(1) func maxSubArray(nums []int) int { maxResult := nums[0] pre := nums[0] for i := 1; i \u003c len(nums); i++ { if pre \u003e 0 { pre = pre + nums[i] } else { pre = nums[i] } if pre \u003e maxResult { maxResult = pre } } return maxResult } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-42.-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"},{"categories":null,"content":"剑指 Offer 46. 把数字翻译成字符串 mid 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 输入: 12258 输出: 5 解释: 12258有5种不同的翻译，分别是\"bccfi\", \"bwfi\", \"bczi\", \"mcfi\"和\"mzi\" ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"DP 字符串的第 ii 位置： 可以单独作为一位来翻译 如果第 i - 1i−1 位和第 ii 位组成的数字在 1010 到 2525 之间，可以把这两位连起来翻译 func translateNum(num int) int { s := strconv.Itoa(num) if len(s) == 0 { return 0 } dp := make([]int, len(s)) dp[0] = 1 if len(s) == 1 { return 1 } if s[0:2] \u003c= \"25\" \u0026\u0026 s[0:2] \u003e= \"10\" { dp[1] = 2 } else { dp[1] = 1 } for i := 2; i \u003c len(s); i++ { pre := s[i-1 : i+1] if pre \u003c= \"25\" \u0026\u0026 pre \u003e= \"10\" { dp[i] = dp[i-1] + dp[i-2] } else { dp[i] = dp[i-1] } } return dp[len(s)-1] } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"优化 将空间压缩为 O(1) func translateNum(num int) int { s := strconv.Itoa(num) if len(s) == 0 { return 0 } a1, a2 := 1, 1 // dp[i-1]和dp[i-2] result := 1 for i := 1; i \u003c len(s); i++ { pre := s[i-1 : i+1] // 当前位和上一位组成的二位数字 if pre \u003c= \"25\" \u0026\u0026 pre \u003e= \"10\" { result = a1 + a2 } else { result = a1 } a2 = a1 a1 = result } return result } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-46.-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"剑指 Offer 47. 礼物的最大价值 mid 在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。 你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"},{"categories":null,"content":"DP $$ f(i,j)=max[f(i,j−1),f(i−1,j)]+grid(i,j) $$ func maxValue(grid [][]int) int { if len(grid) == 0 { return 0 } m, n := len(grid), len(grid[0]) dp := make([][]int, 0) for i := 0; i \u003c m; i++ { tmp := make([]int, n) dp = append(dp, tmp) } var up, left int for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { if i == 0 \u0026\u0026 j == 0 { dp[i][j] = grid[i][j] continue } if i \u003e 0 { up = dp[i-1][j] + grid[i][j] } else { up = 0 } if j \u003e 0 { left = dp[i][j-1] + grid[i][j] } else { left = 0 } if up \u003e left { dp[i][j] = up } else { dp[i][j] = left } } } return dp[m-1][n-1] } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"},{"categories":null,"content":"优化 可以原地修改数组 func maxValue(grid [][]int) int { if len(grid) == 0 { return 0 } m, n := len(grid), len(grid[0]) var up, left int for i := 0; i \u003c m; i++ { for j := 0; j \u003c n; j++ { if i == 0 \u0026\u0026 j == 0 { continue } if i \u003e 0 { up = grid[i-1][j] + grid[i][j] } else { up = 0 } if j \u003e 0 { left = grid[i][j-1] + grid[i][j] } else { left = 0 } if up \u003e left { grid[i][j] = up } else { grid[i][j] = left } } } return grid[m-1][n-1] } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"},{"categories":null,"content":"极致优化 以上代码逻辑清晰，和转移方程直接对应，但仍可提升效率：当 grid 矩阵很大时，i=0 或 j = 0 的情况仅占极少数，相当循环每轮都冗余了一次判断。因此，可先初始化矩阵第一行和第一列，再开始遍历递推。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/:3:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-47.-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/"},{"categories":null,"content":"剑指 Offer 48. 最长不含重复字符的子字符串 请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 示例 1: 输入: \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"DP ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"哈希表 可以用一张哈希表来存放每个出现过的字母的最后位置 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } hash := make(map[byte]int) // 记录每个字母最大的索引 dp := make([]int, len(s)) dp[0] = 1 hash[s[0]] = 0 maxResult := 1 for i := 1; i \u003c len(s); i++ { index, ok := hash[s[i]] if !ok { // s[i]未出现过 dp[i] = dp[i-1] + 1 } else { if i-index \u003e dp[i-1] { // 上一个与s[i]相等的字母下标在dp[i-1]之前 可以加1 dp[i] = dp[i-1] + 1 } else { // 上一个与s[i]相等的字母下标在dp[i-1]之中 没有办法 dp[i] = i - index } } hash[s[i]] = i if maxResult \u003c dp[i] { maxResult = dp[i] } } return maxResult } dp 表还可以省略 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } hash := make(map[byte]int) // 记录每个字母最大的索引 hash[s[0]] = 0 maxResult := 1 pre := 1 // 记录dp[i-1] var curResult int // 记录dp[i] for i := 1; i \u003c len(s); i++ { index, ok := hash[s[i]] if !ok { // s[i]未出现过 curResult = pre + 1 } else { if i-index \u003e pre { // 上一个与s[i]相等的字母下标在dp[i-1]之前 可以加1 curResult = pre + 1 } else { // 上一个与s[i]相等的字母下标在dp[i-1]之中 没有办法 curResult = i - index } } hash[s[i]] = i // 更新 pre = curResult if maxResult \u003c curResult { maxResult = curResult } } return maxResult } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:1","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"线性遍历 左边界 i 获取方式： 遍历到 s[j] 时，初始化索引 i = j - 1，向左遍历搜索第一个满足 s[i] = s[j] 的字符即可 。 不想写代码了 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:2","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"双指针 滑动窗口 其实原理是一样的，用一个 i 来框定左边界，保证 i+1 到 j 的字串无重复 // 双指针 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } hash := make(map[byte]int) // 记录每个字母最大的索引 maxResult := 1 i := -1 // 左指针 定义左边界 保证i+1到j的字串无重复 for j := 0; j \u003c len(s); j++ { lastIndex, ok := hash[s[j]] if ok \u0026\u0026 lastIndex \u003e i { // 上一个与s[j]相等的字母下标在左边界i右边 以其为新左边界 i = lastIndex } hash[s[j]] = j // 更新 if maxResult \u003c j-i { maxResult = j - i } } return maxResult } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-48.-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"剑指 Offer 63. 股票的最大利润 假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ 示例 1: 输入: [7,1,5,3,6,4] 输出: 5 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 示例 2: 输入: [7,6,4,3,1] 输出: 0 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":null,"content":"一次遍历 我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？ 显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。 因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。 func max(a, b int) int { if a \u003e b { return a } return b } func min(a, b int) int { if a \u003c b { return a } return b } // 一次遍历 func maxProfit(prices []int) int { curMinPrice := math.MaxInt maxPro := 1 for i := 0; i \u003c len(prices); i++ { maxPro = max(maxPro, prices[i]-curMinPrice) curMinPrice = min(curMinPrice, prices[i]) } return maxPro } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":null,"content":"DP 前 i 日最大利润 = max(前 (i−1) 日最大利润, 第 i 日价格 − 前 i 日最低价格) dp[i] = max(dp[i−1],prices[i]−min(prices[0:i])) // DP func maxProfit2(prices []int) int { if len(prices) == 0 { return 0 } dp := make([]int, len(prices)) minPrice := prices[0] for i := 1; i \u003c len(prices); i++ { if dp[i-1] \u003e= prices[i]-minPrice { dp[i] = dp[i-1] } else { dp[i] = prices[i] - minPrice } if prices[i] \u003c minPrice { minPrice = prices[i] } } return dp[len(prices)-1] } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/dp/%E5%89%91%E6%8C%87-offer-63.-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/"},{"categories":null,"content":"剑指 Offer 06. 从尾到头打印链表 easy 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 示例 1： 输入：head = [1,3,2] 输出：[2,3,1] ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"辅助栈 // 辅助栈 func reversePrint(head *ListNode) []int { var stack []int for p := head; p != nil; p = p.Next { stack = append(stack, p.Val) } var result []int for i := len(stack) - 1; i \u003e= 0; i-- { result = append(result, stack[i]) } return result } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"递归 // 递归 func reversePrint2(head *ListNode) []int { if head == nil { return []int{} } return append(reversePrint2(head.Next), head.Val) } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-06.-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"剑指 Offer 18. 删除链表的节点 easy 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 返回删除后的链表的头节点。 注意：此题对比原题有改动 示例 1: 输入: head = [4,5,1,9], val = 5 输出: [4,1,9] 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 1 -\u003e 9. 示例 2: 输入: head = [4,5,1,9], val = 1 输出: [4,5,9] 解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u003e 5 -\u003e 9. 题目保证链表中节点的值互不相同 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"双指针 preNode 和 curNode func deleteNode(head *ListNode, val int) *ListNode { if head.Val == val { return head.Next } preNode := head curNode := head for curNode != nil { if curNode.Val == val { preNode.Next = curNode.Next return head } preNode = curNode curNode = curNode.Next } return head } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"递归 func deleteNode(head *ListNode, val int) *ListNode { if head == nil { return nil } if head.Val == val { return head.Next } head.Next = deleteNode(head.Next, val) return head } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-18.-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"剑指 Offer 24. 反转链表 easy 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 示例: 输入: 1-\u003e2-\u003e3-\u003e4-\u003e5-\u003eNULL 输出: 5-\u003e4-\u003e3-\u003e2-\u003e1-\u003eNULL ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"三指针 // 三指针 func reverseList(head *ListNode) *ListNode { var prev, next *ListNode // 默认为nil cur := head for cur != nil { next = cur.Next cur.Next = prev prev = cur cur = next } return prev } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"递归 // 递归 func reverseList2(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } newHead := reverseList2(head.Next) head.Next.Next = head head.Next = nil return newHead } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-24.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"剑指 Offer 25. 合并两个排序的链表 easy 输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 示例1： 输入：1-\u003e2-\u003e4, 1-\u003e3-\u003e4 输出：1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"合并排序 本质上也是个双指针 func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { fakeHead := \u0026ListNode{} // 伪头节点 curNode := fakeHead for l1 != nil || l2 != nil { if l1 == nil { curNode.Next = l2 break } if l2 == nil { curNode.Next = l1 break } if l1.Val \u003e l2.Val { curNode.Next = l2 l2 = l2.Next } else { curNode.Next = l1 l1 = l1.Next } curNode = curNode.Next } return fakeHead.Next } 伪头节点真的能减少很多边界条件的考虑！ 不用伪头节点的情况，很繁琐： func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode { if l1 == nil { return l2 } else if l2 == nil { return l1 } var head *ListNode if l1.Val \u003e l2.Val { head = l2 l2 = l2.Next } else { head = l1 l1 = l1.Next } curNode := head for l1 != nil || l2 != nil { if l1 == nil { curNode.Next = l2 break } if l2 == nil { curNode.Next = l1 break } if l1.Val \u003e l2.Val { curNode.Next = l2 l2 = l2.Next } else { curNode.Next = l1 l1 = l1.Next } curNode = curNode.Next } return head } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-25.-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"剑指 Offer 35. 复杂链表的复制 mid 请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。 示例 1： 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] 示例 2： 输入：head = [[1,1],[2,1]] 输出：[[1,1],[2,1]] 示例 3： 输入：head = [] 输出：[] 解释：给定的链表为空（空指针），因此返回 null。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"categories":null,"content":"哈希表 在赋值的过程中，将新链表的每个结点与原链表的每个结点用散列表一一对应起来 // 哈希表 func copyRandomList(head *Node) *Node { if head == nil { return head } nodeMap := make(map[*Node]*Node) newHead := \u0026Node{} // 空头结点 for p, k := head, newHead; p != nil; p, k = p.Next, k.Next { k.Next = \u0026Node{Val: p.Val} nodeMap[p] = k.Next } for p, k := head, newHead; p != nil; p, k = p.Next, k.Next { if p.Random != nil { k.Next.Random = nodeMap[p.Random] } } return newHead.Next } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"categories":null,"content":"原地转换 复制一个新的节点在原有节点之后，如 1 -\u003e 2 -\u003e 3 -\u003e null 复制完就是 1 -\u003e 1 -\u003e 2 -\u003e 2 -\u003e 3 - \u003e 3 -\u003e null 从头开始遍历链表，通过 cur.next.random = cur.random.next 可以将复制节点的随机指针串起来，当然需要判断 cur.random 是否存在 将复制完的链表一分为二 // 原地转换 func copyRandomList2(head *Node) *Node { if head == nil { return head } // 复制结点插入到原节点后面 for p := head; p != nil; p = p.Next.Next { p.Next = \u0026Node{Val: p.Val, Next: p.Next} } // 设置Random指针 for p := head; p != nil; p = p.Next.Next { k := p.Next if p.Random != nil { k.Random = p.Random.Next } } newHead := head.Next // 拆分原节点和新节点 for p := head; p != nil; p = p.Next { k := p.Next p.Next = k.Next if k.Next != nil { k.Next = k.Next.Next } } return newHead } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-35.-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/"},{"categories":null,"content":"剑指 Offer 52. 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共节点。 如下面的两个链表： 在节点 c1 开始相交。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"哈希 时间复杂度：O(m+n)；空间复杂度：O(m)，链表 A 的长度 // 哈希 func getIntersectionNode2(headA, headB *ListNode) *ListNode { vis := map[*ListNode]bool{} for tmp := headA; tmp != nil; tmp = tmp.Next { vis[tmp] = true } for tmp := headB; tmp != nil; tmp = tmp.Next { if vis[tmp] { return tmp } } return nil } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"补差值 虽然也是两个指针，但是感觉不能叫双指针… func getIntersectionNode(headA, headB *ListNode) *ListNode { // 分别计算两链表的长度 i := headA aNum := 0 for i != nil { aNum++ i = i.Next } i = headB bNum := 0 for i != nil { bNum++ i = i.Next } var diff int // 两链表的差值 var fastNode, slowNode *ListNode // 要往前跑diff步的链表头 停在原地的链表头 // 选出长链表的头节点为fastNode if aNum \u003e bNum { fastNode, slowNode = headA, headB diff = aNum - bNum } else { fastNode, slowNode = headB, headA diff = bNum - aNum } // 往前跑diff步 for diff != 0 { fastNode = fastNode.Next diff-- } // 一起跑 直到相遇 for fastNode != nil \u0026\u0026 fastNode != slowNode { fastNode = fastNode.Next slowNode = slowNode.Next } return fastNode } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"双指针 太妙了！！！ func getIntersectionNode2(headA, headB *ListNode) *ListNode { if headA == nil || headB == nil { return nil } pa, pb := headA, headB for pa != pb { if pa == nil { pa = headB } else { pa = pa.Next } if pb == nil { pb = headA } else { pb = pb.Next } } return pa } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/:3:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/link-list/%E5%89%91%E6%8C%87-offer-52.-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/"},{"categories":null,"content":"整数转罗马数字 mid 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。 示例 1: 输入: num = 3 输出: \"III\" 示例 2: 输入: num = 4 输出: \"IV\" 示例 3: 输入: num = 9 输出: \"IX\" 示例 4: 输入: num = 58 输出: \"LVIII\" 解释: L = 50, V = 5, III = 3. 示例 5: 输入: num = 1994 输出: \"MCMXCIV\" 解释: M = 1000, CM = 900, XC = 90, IV = 4. ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"},{"categories":null,"content":"解 依照题意，优先选择大的数字，解题思路采用贪心算法。将 1-3999 范围内的罗马数字从大到小放在数组中，从头选择到尾，即可把整数转成罗马数字。 func intToRoman(num int) string { values := []int{1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1} symbols := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"} res, i := \"\", 0 for num != 0 { for values[i] \u003e num { i++ } num -= values[i] res += symbols[i] } return res } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/12.-%E6%95%B4%E6%95%B0%E8%BD%AC%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/"},{"categories":null,"content":"13. 罗马数字转整数 easy 给定一个罗马数字，将其转换成整数。 示例 1: 输入: s = \"III\" 输出: 3 示例 2: 输入: s = \"IV\" 输出: 4 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/13.-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/13.-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":null,"content":"解 建立一个HashMap来映射符号和值，然后对字符串从左到右来，如果当前字符代表的值不小于其右边，就加上该值；否则就减去该值。以此类推 func romanToInt(s string) int { roman := map[string]int{ \"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000, } result := 0 for i := 0; i \u003c len(s); i++ { if i+1 \u003c len(s) \u0026\u0026 roman[string(s[i])] \u003c roman[string(s[i+1])] { result -= roman[string(s[i])] } else { result += roman[string(s[i])] } } return result } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/13.-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/13.-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/"},{"categories":null,"content":"14. 最长公共前缀 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 \"\"。 示例 1： 输入：strs = [\"flower\",\"flow\",\"flight\"] 输出：\"fl\" 示例 2： 输入：strs = [\"dog\",\"racecar\",\"car\"] 输出：\"\" 解释：输入不存在公共前缀。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/14.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/14.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":null,"content":"解 func longestCommonPrefix(strs []string) string { prefix := strs[0] // 先随便找一个作为前缀 在遍历过程中再慢慢剔除 for i := 1; i \u003c len(strs); i++ { // 遍历每个字符串 for j := 0; j \u003c len(prefix); j++ { // 遍历每个前缀字母 if len(strs[i]) \u003c= j || strs[i][j] != prefix[j] { prefix = prefix[:j] break } } } return prefix } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/14.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/14.-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/"},{"categories":null,"content":"无重复字符的最长子串 mid https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 示例 4: 输入: s = \"\" 输出: 0 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":null,"content":"滑动窗口 func lengthOfLongestSubstring(s string) int { if len(s) == 0 { return 0 } hash := make(map[byte]bool) // 记录每个字符是否出现过 var left, right, maxLen int = 0, 0, 0 for right \u003c len(s) { for hash[s[right]] { // 出现重复 左边界一直右移 直到不重复 hash[s[left]] = false left++ } if right-left+1 \u003e maxLen { maxLen = right - left + 1 } hash[s[right]] = true right++ } return maxLen } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/3.-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"},{"categories":null,"content":"最长回文子串 mid 给你一个字符串 s，找到 s 中最长的回文子串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/5.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/5.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":null,"content":"中心扩散法 从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。 func longestPalindrome(s string) string { var maxLen, maxLeftIndex int = 0, 0 for i := 0; i \u003c len(s); i++ { leftIndex := i rightIndex := i // 寻找回文中心相同部分 for leftIndex-1 \u003e= 0 \u0026\u0026 s[leftIndex-1] == s[i] { // 往左扩散 直到遇到与i不相等的字符为止 leftIndex-- } for rightIndex+1 \u003c len(s) \u0026\u0026 s[rightIndex+1] == s[i] { // 往右扩散 直到遇到与i不相等的字符为止 rightIndex++ } // 左右扩散 for leftIndex-1 \u003e= 0 \u0026\u0026 rightIndex+1 \u003c len(s) \u0026\u0026 s[leftIndex-1] == s[rightIndex+1] { leftIndex-- rightIndex++ } if rightIndex-leftIndex+1 \u003e maxLen { maxLen = rightIndex - leftIndex + 1 maxLeftIndex = leftIndex } } return s[maxLeftIndex : maxLeftIndex+maxLen] } class Solution: def longestPalindrome(self, s: str) -\u003e str: maxl,max_len,n = 0,0,len(s) for i in range(2*n-1): l,r = i//2,i//2+i%2 while l\u003e=0 and r \u003c n and s[l]==s[r]: if r-l+1\u003emax_len: maxl,max_len = l,r-l+1 l-=1 r+=1 return s[maxl:maxl+max_len] ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/5.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/5.-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":null,"content":"Z 字型变换 将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 比如输入字符串为 “PAYPALISHIRING” 行数为 3 时，排列如下： P A H N A P L S I I G Y I R 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：“PAHNAPLSIIGYIR” ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/6.-z-%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/6.-z-%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/"},{"categories":null,"content":"解 这一题没有什么算法思想，考察的是对程序控制的能力。 func convert(s string, numRows int) string { step := numRows*2 - 2 // 到达下一层要跳转的步长 if step \u003c= 0 { return s } result := make([]byte, 0) for i := 0; i \u003c numRows; i++ { // 遍历每一层 for j := i; j \u003c len(s); j = j + step { // 控制步长来遍历一层中的每一个元素 result = append(result, s[j]) row := j%step + 1 // j所在层数 以1为始 if row \u003e 1 \u0026\u0026 row \u003c= numRows-1 \u0026\u0026 j+(numRows-row)*2 \u003c len(s) { // 添加z型拐弯处的字母 result = append(result, s[j+(numRows-row)*2]) } } } return string(result) } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/6.-z-%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/6.-z-%E5%AD%97%E5%9E%8B%E5%8F%98%E6%8D%A2/"},{"categories":null,"content":"字符串转换整数 (atoi) 请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 函数 myAtoi(string s) 的算法如下： 读入字符串并丢弃无用的前导空格 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 将前面步骤读入的这些数字转换为整数（即，“123” -\u003e 123， “0032” -\u003e 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 返回整数作为最终结果。 注意： 本题中的空白字符只包括空格字符 ’ ’ 。 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/8.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/8.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"},{"categories":null,"content":"题解 这道题真的好奇怪。。。 func myAtoi(s string) int { sign := 1 // 符号 默认为正 index := 0 for index \u003c len(s) { // 去除前导空格 if s[index] == ' ' { index++ continue } // 判断正负 if s[index] == '+' { sign = 1 index++ } else if s[index] == '-' { sign = -1 index++ } break } result := 0 for ; index \u003c len(s); index++ { if s[index] \u003e= '0' \u0026\u0026 s[index] \u003c= '9' { result = result*10 + int(s[index]-'0') if sign*result \u003e math.MaxInt32 { return math.MaxInt32 } else if sign*result \u003c math.MinInt32 { return math.MinInt32 } } else { break } } return sign * result } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/8.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/8.-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"},{"categories":null,"content":"剑指 Offer 50. 第一个只出现一次的字符 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 示例 1: 输入：s = \"abaccdeff\" 输出：'b' 示例 2: 输入：s = \"\" 输出：' ' ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"categories":null,"content":"哈希表 哈希表存放每个出现过字母的出现位置索引 func firstUniqChar(s string) byte { hash := make(map[byte][]int) for i := 0; i \u003c len(s); i++ { hash[s[i]] = append(hash[s[i]], i) } resultWord := byte(' ') index := math.MaxInt for k, v := range hash { if len(v) == 1 \u0026\u0026 v[len(v)-1] \u003c index { resultWord = k index = v[len(v)-1] } } return resultWord } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"categories":null,"content":"不用哈希表 先遍历一遍字符串，将其出现次数存储在数组中，在按字符串遍历一次，同时按字母查询数组，如果次数为1则返回。 更快一点。 func firstUniqChar2(s string) byte { var list [26]int length := len(s) for i := 0; i \u003c length; i++ { list[s[i]-'a']++ } for i := 0; i \u003c length; i++ { if list[s[i]-'a'] == 1 { return s[i] } } return ' ' } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-50.-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/"},{"categories":null,"content":"剑指 Offer 58 - I. 翻转单词顺序 输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\"I am a student. “，则输出\"student. a am I”。 示例 1： 输入: \"the sky is blue\" 输出: \"blue is sky the\" 示例 2： 输入: \" hello world! \" 输出: \"world! hello\" 解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 示例 3： 输入: \"a good example\" 输出: \"example good a\" 解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"},{"categories":null,"content":"双指针 func reverseWords(s string) string { words := make([]string, 0) i, j := len(s)-1, len(s)-1 for i \u003e= 0 \u0026\u0026 j \u003e= 0 { // j先移动到一个单词的右边界 for j \u003e= 0 \u0026\u0026 s[j] == ' ' { j-- } if j \u003c 0 { break } i = j // i移动到一个单词的左边界 for i \u003e= 0 \u0026\u0026 s[i] != ' ' { i-- } words = append(words, s[i+1:j+1]) j = i } return strings.Join(words, \" \") } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-i.-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/"},{"categories":null,"content":"剑指 Offer 58 - II. 左旋转字符串 easy 字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。 请定义一个函数实现字符串左旋转操作的功能。 比如，输入字符串\"abcdefg\"和数字2，该函数将返回左旋转两位得到的结果\"cdefgab\"。 示例 1： 输入: s = \"abcdefg\", k = 2 输出: \"cdefgab\" 示例 2： 输入: s = \"lrloseumgh\", k = 6 输出: \"umghlrlose\" ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"语法糖 func reverseLeftWords(s string, n int) string { return s[n:] + s[:n] } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"三次倒转 三次反转即可得到所求答案，空间复杂度降低为 O(1)，属于是原地旋转 // reverse 倒转字节数组 s将会被修改 func reverse(s []byte) { n := len(s) for i := 0; i \u003c n/2; i++ { // 交换头尾位置 tmp := s[i] s[i] = s[n-i-1] s[n-i-1] = tmp } } // 三次倒转 func reverseLeftWords2(s string, n int) string { bytes := []byte(s) reverse(bytes[:n]) // 左边部分转 reverse(bytes[n:]) // 右边部分转 reverse(bytes) // zheng'ti'z return string(bytes) } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/string/%E5%89%91%E6%8C%87-offer-58-ii.-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"剑指 Offer 32 - III. 从上到下打印二叉树 III mid 请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回其层次遍历结果： [ [3], [20,9], [15,7] ] ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/"},{"categories":null,"content":"解 隔一个倒序一下 func levelOrder(root *TreeNode) [][]int { if root == nil { return [][]int{} } result := make([][]int, 0) queue := make([]*TreeNode, 0) queue = append(queue, root) curCount := 1 curLevel := 0 nextCount := 0 isAscending := true for len(queue) != 0 { curNodes := make([]int, 0) for curCount \u003e 0 { curNode := queue[0] queue = queue[1:] curNodes = append(curNodes, curNode.Val) if curNode.Left != nil { queue = append(queue, curNode.Left) nextCount++ } if curNode.Right != nil { queue = append(queue, curNode.Right) nextCount++ } curCount-- } if !isAscending { // 倒序 reversedNodes := make([]int, 0) for i := len(curNodes) - 1; i \u003e= 0; i-- { reversedNodes = append(reversedNodes, curNodes[i]) } result = append(result, reversedNodes) } else { result = append(result, curNodes) } curCount = nextCount nextCount = 0 curLevel++ isAscending = !isAscending } return result } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-32-iii.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/"},{"categories":null,"content":"剑指 Offer32 - I. 从上到下打印二叉树.md easy 从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 例如: 给定二叉树: [3,9,20,null,null,15,7], 3 / \\ 9 20 / \\ 15 7 返回： [3,9,20,15,7] ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/:0:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"categories":null,"content":"队列 就是一个层序遍历 // 队列实现层序遍历 func levelOrder(root *TreeNode) []int { if root == nil { return []int{} } queue := make([]*TreeNode, 0) queue = append(queue, root) result := make([]int, 0) for len(queue) != 0 { curNode := queue[0] queue = queue[1:] result = append(result, curNode.Val) if curNode.Left != nil { queue = append(queue, curNode.Left) } if curNode.Right != nil { queue = append(queue, curNode.Right) } } return result } ","date":"0001-01-01","objectID":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/:1:0","tags":null,"title":"","uri":"/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer32-i.-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"}]