---
title: "面试八股文"
date: 2022-02-25
draft: false
author: "MelonCholi"
tags: [面试]
categories: [有用的东东]
---

# 八股文

未看：https://blog.csdn.net/u012027907/article/details/56908268?spm=1001.2014.3001.5502

## 计算机网络

### HTTP 相关

#### 常见的 HTTP 状态码有哪些?

- **1×× : 请求处理中**，请求已被接受，正在处理

- **2×× : 请求成功**，请求被成功处理 200 OK

    - 200-OK：成功。如果是非 HEAD 请求，响应头会有 body 数据

    - 202-Accepted
        - 已接受。已经接受请求，但未处理完成

    - 204-No Content：与 200 基本相同，但响应没有 body 数据

    - 206-Partial Content：应用于 HTTP 断点续传，返回的 body 是资源的一部分

- **3×× : 重定向**，要完成请求必须进行进一步处理

    - 301-Moved Permanently：永久重定向

    - 302-Found：临时重定向 

    - 304-Not Modified：已缓存（资源没修改，用之前缓存就行）


- **4×× : 客户端错误，请求报文不合法** 

    - 400-Bad Request：请求有语法问题 
    - 401-Unauthorized：需要通过HTTP认证

    - 403-Forbidden：服务器禁止访问资源，不是客户端的问题

    - 404-Not Found：请求的资源在服务器上找不到


- **5×× : 服务器端错误，服务器不能处理合法请求** 

    - 500-Internal Server Error：发生错误（比较笼统）

    - 501-Not Implemented：该功能还不支持
    - 502-Bad Gateway：服务器作为网关/代理返回，表示服务器自身工作正常，但访问后端服务器发送错误
    - 503-Service Unavailable：当前忙，暂时无法响应
        - 此响应代码表明 HTTP 服务器正常，只是下层 web 服务不能正常工作
        - 最可能的理由是资源不足：服务器**突然收到太多请求**，以至于无法全部处理
        - 由于此问题多半由客户端反复发送请求造成，因此 HTTP 服务器可以选择拒绝客户端请求并返回 503
        - 重试
            - 服务器可以在响应头的 Retry-After 字段告知客户端何时可以重试
    - 504-Gateway Timeout：网关超时
    - 502 和 504 的区别
        - 从网络角度，502已经与后端建立了连接，但超时（电话打通了，但没人接）；504与后端连接未建立，超时（电话没打通）。

#### http 中常见的 header 字段有哪些？

- **通用首部字段**

    - 请求/响应报文都会使用的首部

    - Cache-Control 字段

        - 控制缓存的工作机制

        - no-cache/max-age=.../public/private

    - Connection 字段

        - 控制不再转发给代理的首部字段

        - 管理持久连接

    - Date 字段
        - 创建 HTTP 报文的日期和时间

- **请求首部字段**

    - **Accept 字段**

        - 客户端接受的媒体类型和优先级（加权）

        - text/html  q=0.3,text/plain

    - Accept-Encoding 字段

        - 客户端接受的内容编码和优先级（加权）

        - gzip

    - Authorization 字段
        - 客户端的认证信息

    - **Host 字段**

        - 请求的资源所处的互联网主机名和端口号

        - HTTP1.1 规定的唯一一个必须包含的请求首部字段

    - Range 字段
        - 获取指定资源范围

    - **Referer 字段**

        - 可以用来防御 CSRF 攻击

        - 告知服务器请求的原始资源 URI，可以知道 URI 是从哪个 Web 页面发起的

    - User-Agent 字段
        - 浏览器/用户代理等信息

    - Cookie 字段

        - 告知服务端，想获取 Cookie 支持

        - Status=enable

- **响应首部字段**

    - Accept-Ranges 字段

        - 能否处理范围请求

        - bytes--能，none--不能

    - Age 字段
        - 源服务器多少秒前创建响应，单位为秒

    - Location 字段
        - 引导至指定 URL（重定向）

    - **Set-Cookie 字段**

        - 告知客户端信息

        - NAME, expires, path, domain, HttpOnly

        - HttpOnly 使得 JavaScript 脚本无法获得 Cookie，从而防止了跨站脚本攻击（XSS）

- **实体首部字段**

    - 针对请求/响应报文的实体部分使用的首部

    - **Allow 字段**
        - 服务端允许的 HTTP 方法

    - Content-Encoding 字段
        - 服务端内容编码格式

    - Content-Length 字段
        - 实体主题部分大小，单位字节

    - Content-Range 字段
        - 针对范围请求，指定返回实体的部分

    - Content-Type 字段
        - 实体主题内对象的媒体类型

#### 请求方式

##### GET 与 POST 的区别

GET 一般用来从服务器上获取资源，POST 一般用来创建资源；

- GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的。

- 从请求参数形式上看，GET 请求的数据会附在`URL之后`；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的`请求体`中。
- POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而 POST 请求参数则被包装到请求体中，相对更安全。
- GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。

### 说说 OSI 七层、TCP/IP 四层的关系和区别？

OSI 七层从下往上依次是：`物理层`、`数据链路层`、`网络层`、`传输层`、`会话层`、`表示层`、`应用层`。

TCP/IP 四层从下往上依次是：`网络接口层`、`网络层`、`传输层`、`应用层`

**特点：**

- 层与层之间相互独立又相互依靠
- 上层依赖于下层，下层为上层提供服务

TCP/IP 四层是 OSI 七层的简化版，已经成为事实国际标准

### 说说 TCP 与 UDP 的区别？

![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-4e57dcabfc7814f50199ffbd444c5eed_b.jpg)

### TCP 是如何实现数据的可靠性？

一句话：通过`校验和`、`序列号`、`确认应答`、`超时重传`、`连接管理`、`流量控制`、`拥塞控制`等机制来保证可靠性。

**校验和**

在数据传输过程中，将发送的数据段都当做一个 16 位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。

发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。

**序列号**

TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。

**确认应答**

TCP 传输过程中，每次接收方接收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。

**超时重传**

在进行 TCP 传输时，由于存在确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟都没有接收到接收方传来的 ACK 报文，那么就对刚刚发送的数据进行重发。

**连接管理**

就是指三次握手、四次挥手的过程。

**流量控制**

如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。

具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。

**拥塞控制**

TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了`慢启动机制`，在开始发送数据的时候，先发少量的数据探探路。

### 说说 TCP 协议如何提高传输效率？

一句话：TCP 协议提高效率的方式有`滑动窗口`、`快重传`、`延迟应答`、`捎带应答`等。

**滑动窗口**

如果每一个发送的数据段，都要收到 ACK 应答之后再发送下一个数据段，这样的话我们效率很低，大部分时间都用在了等待 ACK 应答上了。

为了提高效率我们可以一次发送多条数据，这样就能使等待时间大大减少，从而提高性能。 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。

**快重传**

`快重传` 也叫 `高速重发控制`。

那么如果出现了丢包，需要进行重传。一般分为两种情况：

情况一：数据包已经抵达，ACK 被丢了。这种情况下，部分 ACK 丢了并不影响，因为可以通过后续的 ACK 进行确认；

情况二：数据包直接丢了。发送端会连续收到多个相同的 ACK 确认，发送端立即将对应丢失的数据重传。

**延迟应答**

如果接收数据的主机立刻返回 ACK 应答，这时候返回的窗口大小可能比较小。

- 假设接收端缓冲区为 1M，一次收到了 512K 的数据；如果立刻应答，返回的窗口就是 512K；
- 但实际上可能处理端处理速度很快，10ms 之内就把 512K 的数据从缓存区消费掉了；
- 在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来；
- 如果接收端稍微等一会在应答，比如等待 200ms 再应答，那么这个时候返回的窗口大小就是 1M；

窗口越大，网络吞吐量就越大，传输效率就越高；我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。

**捎带应答**

在延迟应答的基础上，很多情况下，客户端服务器在应用层也是一发一收的。这时候常常采用捎带应答的方式来提高效率，而 ACK 响应常常伴随着数据报文共同传输。如：三次握手。

### 你知道 TCP 如何处理拥塞吗？

- 拥塞避免机制
- 慢开始
- 设置门限变量
- 区分不同的丢包事件

### 讲一下三次握手和四次挥手全过程

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210528101829778.png" alt="image-20210528101829778" style="zoom:50%;" />

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210528102538934.png" alt="image-20210528102538934" style="zoom:50%;" />

### 为什么 TCP 链接需要三次握手，两次不可以么，为什么？

**两次握手只能保证单向连接是畅通的**

第一步，客户端给服务端发送一条消息：你好，服务端。 第二步，服务端收到消息，同时给客户端回复一条消息：收到！你好客户端。

这样的两次握手过程， 客户端给服务端打招呼，服务端收到了，说明客户端可以正常给服务端发送数据。但是服务端给客户端打招呼，服务端没有收到反馈，也就不能确保服务端是否能正常给客户端发送消息。

**只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据** 

第三步，客户端收到服务端发送的消息，回复：收到！这样就证明了客户端能正常收到服务端的消息。

### IP 地址是怎样分类的，你知道吗？

先说一下 IP 的基本特点：

- IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。
- IP 地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。

IP 地址主要分为 A、B、C 三类及特殊地址 D、E 这五类，甩一张图：

![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c9ee6f1b6a90d30aa94aad7d62019444_b.jpg)

A 类：(1.0.0.0-126.0.0.0) 一般用于大型网络。

B 类：(128.0.0.0-191.255.0.0) 一般用于中等规模网络。

C 类：(192.0.0.0-223.255.255.0) 一般用于小型网络。

D 类：是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。

E 类：是保留地址。地址的网络号取值于 240~255 之间。

### 讲一下 http1.1 和 http2 有什么区别？

**HTTP1.1**

- 持久连接
    - 在一个 TCP 连接上可以传送多个 HTTP 请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

- 请求管道化
- 增加缓存处理（新的字段如 cache-control）
- 增加 Host 字段、支持断点传输等

**HTTP2.0**

- 二进制分帧
    - 引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列 id，服务器就可以进行并行传输数据。
    - 头部压缩

- 多路复用（或连接共享）
    - 多路复用前，文件时串行传输的，请求 a 文件，b 文件只能等待，并且连接数过多。引入多路复用，a 文件 b 文件可以同时传输。

- 服务器推送

### 说说 HTTP 和 HTTPS 的区别？

- HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。

- HTTP 是超文本传输协议，信息是**明文传输**，HTTPS 则是具有安全性的 SSL **加密传输**协议

- HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443
- HTTP 的连接很简单，是**无状态**的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。

### 你知道对称加密和非对称加密的区别和原理吗？

对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即`如何安全地将密钥发给对方`;

而非对称加密是指使用一对非对称密钥，即`公钥`和`私钥`，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。

由于非对称加密的方式不需要发送用来解密的私钥，所以可以`保证安全性`；但是和对称加密比起来，它比较`慢`，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。

### DNS 的寻址过程你知道吗？

1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器

2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找

3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器

4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址

5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器

6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息

7、客户机的本地的dns服务器会将查询结果返回给我们的客户机

8、客户机根据得到的ip信息访问目标主机，完成解析过程

### 在浏览器中输入一个 [http://www.baidu.com](https://link.zhihu.com/?target=http%3A//www.baidu.com) 后执行的全部过程？

域名解析 -> 建立 TCP 连接（三次握手）-> 发起 http 请求 -> 服务器响应 http 请求，浏览器得到 html 代码 -> 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）-> 浏览器对页面进行渲染呈献给用户。

### Session、Cookie 的区别

- session 存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号 sessionId，通常存放于 cookie 中。服务器收到 cookie 后解析出 sessionId，再去 session 列表中查找，才能找到相应 session。
- cookie 类似一个令牌，装有 sessionId，存储在客户端，浏览器通常会自动添加。
- token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。
- jwt 只是一个跨域认证的方案

**补充 JWT**

JWT 就是 token 的一种实现方式，并且基本是 java web 领域的事实标准。

JWT 全称是 JSON Web Token。基本可以看出是使用 JSON 格式传输 token

JWT 由 3 部分构成:

- Header：描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。
- Payload（负载）：用来存放实际需要传递的数据
- Signature（签名）：服务器通过 Payload、Header 和一个密钥 (secret) 使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。

流程：

- 在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过 Payload、Header 和一个密钥(secret) 创建令牌（Token）并将 Token 发送给客户端，
- 然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization 字段中

### 有哪些 web 性能优化技术?

- DNS 查询优化
- 客户端缓存
- 优化 TCP 连接
- 避免重定向
- 网络边缘的缓存
- 条件缓存
- 压缩和代码极简化
- 图片优化

### 什么是 XSS 攻击？

XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。

XSS 的重点不在于跨站点，而在于脚本的执行。

XSS的原理是：恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。

XSS 攻击最主要有如下分类：`反射型`、`存储型`、及 `DOM-based 型`。 反射性和 DOM-baseed 型可以归类为`非持久性 XSS 攻击`。存储型可以归类为`持久性 XSS 攻击`。

### 什么是跨站攻击 CSRF？

CSRF（Cross Site Request Forgery，跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一，也被称为『One Click Attack』或者 『Session Riding』，通常缩写为`CSRF`或者`XSRF`，是一种对网站的恶意利用。

听起来像跨站脚本（XSS），但它与 XSS 非常不同，并且攻击方式几乎相左。

XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。

与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。

### **简述 TCP 粘包现象**

TCP 是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个 tcp 报文中发出去的可能性。 可以简单的理解成客户端调用了两次 send，服务器端一个 recv 就把信息都读出来了。

### **TCP 粘包现象处理方法**

固定发送信息长度，或在两个信息之间加入分隔符。

### **简述半连接队列**

TCP 握手中，当服务器处于 SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。

### **简述 SYN 攻击**

泛洪攻击

SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费 CPU 和内存资源。

优化方式：

1. 缩短 SYN Timeout 时间
2. 记录 IP，若连续受到某个IP的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。

### **https 的连接过程**

1. 浏览器将支持的加密算法信息发给服务器
2. 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
3. 客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为 client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。
4. 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端对称密钥发送给服务器
5. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
6. 服务器将加密后的密文发送给客户端
7. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成

### **了解 REST API 吗**

REST API 全称为表述性状态转移（Representational State Transfer，REST）即利用 HTTP 中 get、post、put、delete 以及其他的 HTTP 方法构成 REST 中数据资源的增删改查操作：

- Create ： POST
- Read ： GET
- Update ： PUT/PATCH
- Delete： DELETE

### 转发和重定向的区别

- 转发是服务器行为。
    - 服务器直接向目标地址访问 URL，将相应内容读取之后发给浏览器，用户浏览器地址栏 URL 不变，转发页面和转发到的页面可以共享 request 里面的数据。

- 重定向是利用服务器返回的状态码来实现的，如果服务器返回 301 或者 302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。
    - 用户的地址栏 url 会发生改变，而且不能共享数据。

## 操作系统

### **操作系统有哪些分类？**

批处理操作系统、分时操作系统、实时操作系统。

若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。

### **什么是内核态和用户态？**

都是处理机的执行状态

用户程序运行在用户态，操作系统内核运行在内核态。

**用户态**

非特权状态、目态

在此状态下，执行的代码被硬件限定，不能执行特权指令

**内核态**

特权状态、管态

核心态是操作系统内核所运行的模式，运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。

### **如何实现内核态和用户态的切换？**

处理器从用户态切换到内核态的方法有三种：**系统调用**、**异常**和**外部中断**。

1. 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。
2. 异常，也叫做**内中断**，是由错误引起的，如文件损坏、缺页故障等。
3. 外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。

### 并发和并行的区别

1. 并发（concurrency）：指**宏观上**看起来两个程序在**同时运行**，比如说在单核 cpu 上的多任务。但是从**微观上**看两个程序的指令是**交织着运行**的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。
2. 并行（parallelism）：指**严格物理意义上的同时运行**，比如多核 cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。

### 进程和线程的区别

进程

- 进程是**进程实体**的运行过程，是系统进行**资源分配和独立调度的基本单位**
- 进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。

进程是资源分配的最小单位，线程是程序执行的最小单位。

进程有自己的**独立地址空间**，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。

而线程是**共享进程中的数据**的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很位。

线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据。而进程之间的通信需要以通信的方式 (IPC) 进行。不过如何处理好同步与互斥是编写多线程程序的难点。

但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。

### **进程间通信方法**

进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。

管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字 socket。（socket 会比较常用）

### 线程间通信方式

锁机制：包括互斥锁、条件变量、读写锁。

- 互斥锁：提供了以排他方式防止数据结构被并发修改的方法。
- 读写锁：允许多个线程同时读共享数据，而对写操作是互斥的。

条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。

- 条件变量始终与互斥锁一起使用。

信号量机制 (Semaphore)：包括无名线程信号量和命名线程信号量。

信号机制 (Signal)：类似进程间的信号处理。

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。

### **进程调度的时机**

1. 当前运行的进程运行结束。
2. 当前运行的进程由于某种原因阻塞。
3. 执行完系统调用等系统程序后返回用户进程。
4. 在使用抢占调度的系统中，具有更高优先级的进程就绪时。
5. 分时系统中，分给当前进程的时间片用完。

### **不能进行进程调度的情况**

1. 在中断处理程序执行时。
2. 在操作系统的内核程序临界区内。
3. 其它需要完全屏蔽中断的原子操作过程中。、

### **进程的调度策略**

1. 先到先服务调度算法
2. 短作业优先调度算法
3. 优先级调度算法
4. 时间片轮转调度算法
5. 高响应比优先调度算法
6. 多级队列调度算法
7. 多级反馈队列调度算法

### **什么是信号**

一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的 30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。

- 发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：

    - 内核检测到一个系统事件，比如除零错误或者子进程终止。

    - —个进程调用了 kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。

- 接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序 (signal handler) 的用户层函数捕获这个信号。

### **进程调度策略的基本设计指标**

1. CPU 利用率
2. 系统吞吐率，即单位时间内 CPU 完成的作业的数量。
3. 响应时间。
4. 周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键

    - 平均周转时间

    - 带权周转时间

    - 平均带权周转时间


### **进程的状态与状态转换**

进程在运行时有三种基本状态：就绪态、运行态和阻塞态。

1. 运行（running）态：进程占有处理器正在运行的状态。进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。

2. 就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。

3. 阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。

各状态之间的转换：

1. 就绪 → 执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。
2. 执行 → 就绪：处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。
3. 执行 → 阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。
4. 阻塞 → 就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。

### **什么是孤儿进程？僵尸进程?**

1. 孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程（1 号进程）所收养，并由 init 进程对他们完成状态收集工作。

2. 僵尸进程： 进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 获 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这些进程是僵尸进程。

### **多线程模型**

1. 多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。
2. 一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。
3. 多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。

### **死锁是怎样产生的？**

死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。 产生死锁需要满足下面四个条件：

1. 互斥条件（Mutual Exclusion）
    - 资源要求互斥访问
2. 请求和保持条件（Hold and wait）
    - 提出的请求得不到满足，手头的资源释放不出来
3. 不可抢占条件（No preemption）
    - 资源只能由占有者资源释放
4. 循环等待条件（Circular wait）
    - 必有一个进程-资源的环形链，环路中的进程形成等待链

### **如何解决死锁问题？**

解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下:

1. 不让死锁发生
    - 预防死锁：静态策略，破坏死锁产生的必要条件
    - 避免死锁：动态策略，不限制必要条件，而去防止系统进入不安全状态（银行家算法）
2. 让死锁发生
    - 检测死锁：通过检测机构及时发现死锁，再采取措施（资源分配图）
    - 解除死锁：当死锁发生，撤销一些进程，回收资源再分配

### **优先级反转是什么？如何解决**

由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转 (Priority Inversion)。其实，优先级反转是在高优级 (假设为 A) 的任务要访问一个被低优先级任务 (假设为 C) 占有的资源时，被阻塞；而此时又有优先级高于占有资源的任务(C) 而低于被阻塞的任务 (A) 的优先级的任务 (假设为 B) 时,于是，占有资源的任务就被挂起 (占有的资源仍为它占有)，因为占有资源的任务优先级很低，所以,它可能一直被另外的任务挂起；而它占有的资源也就一直不能释放；这样，引起任务 A 一直没办法执行，而比它优先低的任务却可以执行。

目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承 (priority inheritance)；另一种被称作优先级极限 (priority ceilings)。

1. **优先级继承** (priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。
2. **优先级天花板** (priority ceilings) 优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级. (这个优先级称为该资源的优先级天花板)。

### 什么是死锁

死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象

#### 产生死锁的必要条件

- 互斥条件：一个资源每次只能被一个进程使用。
- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。
- 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

## 数据库

### 事务并发可能出现的情况

- 脏读（Dirty Read）
    - 一个事务读到了另一个未提交事务修改过的数据
    - 脏读只在读未提交隔离级别才会出现
- 不可重复读（Non-Repeatable Read）
    - 一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值。
    - 不可重复读在读未提交和读已提交隔离级别都可能会出现
- 幻读（Phantom）
    - 一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来。
    - 幻读在读未提交、读已提交、可重复读隔离级别都可能会出现

### 事务的隔离级别

MySQL 的隔离级别的作用就是让事务之间互相隔离，互不影响，这样可以保证事务的一致性。

> MySQL 默认的隔离级别是可重复读

- **读未提交**（READ UNCOMMITTED）
    - 事务 A 可以读取到事务 B 修改过但未提交的数据。
    - 可能发生脏读、不可重复读和幻读问题，一般很少使用此隔离级别。
- **读已提交**（READ COMMITTED）
    - 事务 A 只能在事务 B 修改过并且已提交后才能读取到事务 B 修改后的数据。
    - 读已提交隔离级别解决了脏读的问题，但可能发生不可重复读和幻读问题，一般很少使用此隔离级别。
- **可重复读**（REPEATABLE READ）
    - 事务 A 只能在事务 B 修改过数据并提交后，自己也提交事务后，才能读取到事务 B 修改的数据。
    - 可重复读隔离级别解决了脏读和不可重复读的问题，但可能发生幻读问题。
- **可串行化**（SERIALIZABLE）
    - 读读操作不会阻塞
    - 读写操作会阻塞
    - 写读操作会阻塞
    - 写写操作会阻塞
    - 各种问题（脏读、不可重复读、幻读）都不会发生，通过加锁实现（读锁和写锁）。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220314133108492.png" alt="image-20220314133108492" style="zoom:67%;" />

### 数据库优化

https://www.cnblogs.com/jiajialeps/p/10162767.html

### 事务的四个特性

原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

- **原子性**是指事务是一个**不可再分割**的工作单元，事务中的操作要么都发生，要么都不发生。
- **一致性**是指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。
- **隔离性**是指多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。
- **持久性**，意味着在事务完成以后，该事务所对数据库所作的更改便持久地保存在数据库之中，并不会被回滚。（完成的事务是系统永久的部分，对系统的影响是永久性的，该修改即使出现致命的系统故障也将一直保持）

## 测试开发

### 定位测试方法

确认网络环境是否正常

抓包看接口返回

查看服务端日志

## 其他

### 爬虫 url 去重方法

https://blog.csdn.net/weixin_42425970/article/details/102532185

- 放到列表中（烂中之烂）
- 放到数据库中（利用唯一性索引）
- 放到 HashSet 中
- md5 编码后放到 HashSet 中
- 位图 Bitmap
