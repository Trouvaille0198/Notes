---
title: "数据库原理（2）"
date: 2022-02-25
draft: true
author: "MelonCholi"
tags: [数据库]
categories: [专业课]
---

# 数据库原理二

## 第五章 规范化设计

### 关系模式的设计问题

#### 关系模式的外延和内涵

一个关系模型包括外延和内涵两个方面的内容。

- 外延：关系、表或当前值。

- 内涵：对数据的定义以及对数据完整性约束的定义。

#### 泛关系模式与数据库模式

关系模式 R(U)

- R：关系名字
- U：所有属性的全集
- 关系 r 是关系模式 R(U) 的当前值，是元组的集合
- 这样的关系模式和关系称为**泛关系模式**和泛关系。

实际使用时，用一个关系模式的集合 $\rho = \{ R_1,\dots,R_k\}$ 来代替 R(U)，其中每个 R~i~ 是 U 的子集，$\rho$ 称为**数据库模式**。

#### 关系模式的冗余和异常问题

冗余、修改异常、插入异常、删除异常

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151401739.png" alt="image-20220308151401739" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151410230.png" alt="image-20220308151410230" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151420363.png" alt="image-20220308151420363" style="zoom: 60%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151430051.png" alt="image-20220308151430051" style="zoom:60%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151446399.png" alt="image-20220308151446399" style="zoom:50%;" />

### 函数依赖

#### 函数依赖 FD 的定义

通俗定义：当 X 有一个确定值时，Y 一定有一个唯一的值与其对应

严格定义：

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151831420.png" alt="image-20220308151831420" style="zoom: 67%;" />

或者说，**属性 X 函数决定属性 Y，记作 X→Y**。 其中 X 叫决定因素，Y 叫被决定因素。

此定义可简单表述为：如果属性 X 的值决定属性 Y 的值,那么属性 Y 函数依赖于属性 X。 

换一种说法是，如果知道  X 的值，就可以获得 Y 的值。 

- 不依赖：$X \nrightarrow Y$

- 互相依赖：$X \leftrightarrow Y$

##### 例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153147662.png" alt="image-20220308153147662" style="zoom: 67%;" />

#### FD 的逻辑蕴涵、函数依赖集 F 的闭包

函数依赖集 F 的闭包：F 能推出的所有依赖组成的集合

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153351885.png" alt="image-20220308153351885" style="zoom:60%;" />

#### 函数依赖的推理规则

##### Armstrong 公理系统

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153406619.png" alt="image-20220308153406619" style="zoom:60%;" />

##### 另外三个推理规则

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308155923071.png" alt="image-20220308155923071" style="zoom:67%;" />

#### FD 与关键码的联系

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308160717162.png" alt="image-20220308160717162" style="zoom:67%;" />

##### 找候选键的方法

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161331535.png" alt="image-20220308161331535" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161440201.png" alt="image-20220308161440201" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161447918.png" alt="image-20220308161447918" style="zoom:67%;" />

#### 属性集的闭包

人话：属性 X 可以推出的所有属性的集合

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161457792.png" alt="image-20220308161457792" style="zoom:67%;" />

##### 求闭包

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161928927.png" alt="image-20220308161928927" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161942842.png" alt="image-20220308161942842" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162000436.png" alt="image-20220308162000436" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162008294.png" alt="image-20220308162008294" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162421014.png" alt="image-20220308162421014" style="zoom: 67%;" />

#### FD 的最小依赖集

##### 函数依赖集的等价

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162436812.png" alt="image-20220308162436812" style="zoom:67%;" />

##### 最小函数依赖集

最大函数依赖集就是闭包

- 保证右边都是单属性
- 消除左边的多余属性

- 消除多余的函数依赖

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151127771.png" alt="image-20220315151127771" style="zoom:67%;" />

##### 例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151412567.png" alt="image-20220315151412567" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151417206.png" alt="image-20220315151417206" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315153009173.png" alt="image-20220315153009173" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315153021337.png" alt="image-20220315153021337" style="zoom:67%;" />

### 关系模式的分解特性

#### 模式分解问题

分解：把一张表拆成多张表

投影定义重要！

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154036857.png" alt="image-20220315154036857" style="zoom: 67%;" />



函数依赖保持性：

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154427612.png" alt="image-20220315154427612" style="zoom:67%;" />

#### 无损分解

无损连接：分解后的表进行自然连接之后的表与原表的内容不多不少

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154616981.png" alt="image-20220315154616981" style="zoom:67%;" />

#### 无损分解的测试方法

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160031794.png" alt="image-20220315160031794" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160151601.png" alt="image-20220315160151601" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160202135.png" alt="image-20220315160202135" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160209405.png" alt="image-20220315160209405" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160217009.png" alt="image-20220315160217009" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160236362.png" alt="image-20220315160236362" style="zoom:67%;" /><img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160241704.png" alt="image-20220315160241704" style="zoom:67%;" />

##### 第二种方法

只分解成两个子模式时适用

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161148857.png" alt="image-20220315161148857" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161820582.png" alt="image-20220315161820582" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161848712.png" alt="image-20220315161848712" style="zoom:67%;" />

#### 保持函数依赖的分解

函数依赖保持性：F 在 Z 这个属性集合上的投影得到的小函数依赖集们的并集是否与 F 等价

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161858815.png" alt="image-20220315161858815" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161907624.png" alt="image-20220315161907624" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161915181.png" alt="image-20220315161915181" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161923688.png" alt="image-20220315161923688" style="zoom:67%;" />

### 关系模式的范式

![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png)

#### 第一范式 1NF

##### 反例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150648406.png" alt="image-20220322150648406" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150805914.png" alt="image-20220322150805914" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150818141.png" alt="image-20220322150818141" style="zoom:50%;" />

##### 定义

原子性：每一个属性都不可分解

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150848377.png" alt="image-20220322150848377" style="zoom: 67%;" />

##### 修改后的例子

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150953681.png" alt="image-20220322150953681" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151003707.png" alt="image-20220322151003707" style="zoom:67%;" />

#### 第二范式 2NF

##### 定义

第一范式有部分依赖的问题，而第二范式**消除了部分依赖**

在满足第一范式的条件下，其他属性都必须**完全依赖**于某个候选键属性

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151718007.png" alt="image-20220322151718007" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151741366.png" alt="image-20220322151741366" style="zoom: 67%;" />

#### 第三范式 3NF

（码 = 候选键）

第二范式会有传递依赖的问题，而第三范式**消除了传递依赖**

在满足第二范式的前提下，**每一个非主属性都不传递依赖于候选键（主属性）**。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322152917085.png" alt="image-20220322152917085" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322152926667.png" alt="image-20220322152926667" style="zoom:67%;" />

##### 例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154419167.png" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154517415.png" alt="image-20220322154517415" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154654654.png" alt="image-20220322154654654" style="zoom:67%;" />

#### 巴克斯范式 BCNF

消除主属性之间的部分函数依赖和传递函数依赖

每一个决定因素都包含码

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160029125.png" alt="image-20220322160029125" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160222855.png" alt="image-20220322160222855" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160458916.png" alt="image-20220322160458916" style="zoom:67%;" />

#### 分解成 BCNF 模式集的方法

![image-20220327171535911](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161210743.png" alt="image-20220322161210743" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161220977.png" alt="image-20220322161220977" style="zoom:67%;" />

#### 分解成 3NF 模式集的方法

保函依赖分解题，先求最小依赖集。

依赖两侧未出现，分成子集放一边，剩余依赖变子集。

若要连接成无损，再添候选做子集。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161229166.png" alt="image-20220322161229166" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161233794.png" alt="image-20220322161233794" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161242727.png" alt="image-20220322161242727" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161936938.png" alt="image-20220322161936938" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161941646.png" alt="image-20220322161941646" style="zoom:67%;" />

## 第七章 数据库设计

数据库设计概述
规划
需求分析
概念结构设计
逻辑结构设计
物理结构设计
数据库的实现
数据库的运行和维护

## 第八章 数据库管理

### 事务的概念

#### 事务的定义

事务是由若干数据库操作组成的一个逻辑工作单位，是一个**不可分割**的工作单位。

- 一个应用程序可以包括多个事务。
- 事务以 BEGIN TRANSACTION 语句的成功执行开始，以 COMMIT 或 ROLLBACK 语句的成功执行结束。
- COMMIT（提交）语句表示一事务的全部操作都已成功，它对 DB 的所有更新可真正写到 DB 中。
- ROLLBACK（回退）语句表示事务没有成功地完成全部操作，系统将撤消该事务对 DB 已作的更新。 

#### 事务的性质

事务有四个重要性质：原子性、一致性、隔离性和持久性。通常称为 “**ACID 性质**”。

- 原子性（atomicity）
    - 事务对数据库的更新要么全部起作用，要么完全不起作用。（不可分割）
    - DBMS 的事务管理子系统	
- 一致性（consistency）
    - 事务将数据库从一个一致性状态转变为另一个一致性状态。
    - 程序员（正确地编写事务）DBMS 的完整性子系统	
- 隔离性（isolation ）
    - 事务相互隔离，在多个事务并发执行时，任一事务的更新操作在该事务成功提交前对其他事务都是不可见的。	
    - DBMS 的并发控制子系统	
- 持久性（durability）
    - 事务一旦成功提交，其对数据库的更新就永久有效，不会因系统崩溃等而丢失。	
    - DBMS 的恢复管理子系统	 

#### 事物的状态变迁

![image-20220503151741223](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png)

### 数据库的恢复

#### 数据库恢复的定义原则和方法

##### 数据库恢复的定义

系统能把数据库从被破坏、不正确的状态、恢复到最近一个正确的状态，DBMS 的这种能力称为数据库的可恢复性。

##### 数据库恢复的基本策略和实现方法 

恢复的基本策略：**冗余**（数据重复存储）

实现方法：

- **备份**：定期对数据库复制或转储（静态转储和动态转储，海量转储和增量转储）。
- **日志**：执行事务时，记录其开始、结束和对DB的每次更新操作。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503152715965.png" alt="image-20220503152715965" style="zoom:67%;" />

#### 故障类型

常见的故障有：

- 事务故障
    - 非预期事务故障：运算错误、数据错误、死锁等，故障事务夭折	
    - 可预期事务故障：在事务中可预期出错的地方所加的 ROLLBACK 语句		
- 系统故障：硬件、系统软件出错，停电等，事务执行被打断，内存中数据被破坏	
- 介质故障：磁头、磁盘控制器或磁盘损坏，盘上数据丢失，病毒破坏等，DB 遭破坏	

#### 恢复方法

当系统运行过程中发生故障，利用数据库后备副本和日志文件将数据库恢复到故障前的某个一致性状态。不同故障其恢复技术不一样

##### 事务故障的恢复

> 事务故障的恢复是由系统自动完成的，不需要用户干预。

事务故障是指事务在运行至正常终止点前被中止，此时恢复子系统应撤销（UNDO）此事务已对数据库进行的修改

**恢复步骤**

1. 反向扫描日志文件（即从最后向前扫描日志文件）
    - 查找该事务的更新操作。
2. 对该事务的更新操作执行逆操作。
    - 即将日志记录中“更新前的值”写入数据库
        - 若记录中是插入操作，则相当于做删除操作
        - 若记录中是删除操作，则做插入操作
        - 若是修改操作，则用修改前值代替修改后值。       
3. 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。
4. 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了

##### 系统故障的恢复

> 系统故障的恢复也由系统自动完成的，不需要用户干预。

系统故障造成数据库不一致状态的**原因**有两个

- 未完成事务对数据库的更新已写数据库
- 已提交事务对数据库的更新还留在缓冲区没来得及真正写入数据库。 

**恢复办法**

- 撤销故障发生时未完成的事务
- 重做已完成的事务

**恢复步骤**

1. 正向扫描日志文件 (即从头开始扫描日志文件)，找出在故障发生前
    - 已提交事务 (既有 `<Ti, START>` 记录，也有 `<Ti, COMMIT>` 记录)，将其事务标识记入**重做队列**
    - 尚未完成的事务 (有 `<Ti, START>` 记录，无 `<Ti,COMMIT>` 记录), 将其事务标识记入**撤销队列**
2. 对撤销队列中的各个事务进行**撤销**（UNDO）处理
    - **反向扫描**日志文件，对每个 UNDO 事务的更新操作执行**逆操作**，即将日志记录中“更新前的值”写入数据库
3. 对重做队列中的各个事务进行**重做**（REDO）处理
    - 正向扫描日志文件，对每个 REDO 事务重新执行登记操作，即将日志记录中“更新后的值”写入数据库

##### 介质故障的恢复

在发生介质故障和遭受病毒破坏时，磁盘上的物理数据库遭到毁灭性破坏。此时恢复的过程如下

1. 装入最新的后备副本到新的磁盘，使数据库恢复到最近一次转储时的一致状态
2. 装入有关的日志文件副本，重做已提交的所有事务

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503161657955.png" alt="image-20220503161657955" style="zoom:67%;" />

#### 检查点机制

检查点（Checkpoint）方法 ：DBMS 定时设置检查点，在检查点时刻才真正做到把对 DB 的修改写到磁盘，并在日志文件写入一条检查点记录。

**恢复方法**

1. 根据日志文件建立重做队列和事务撤消队列。
2. 对重做队列中的事务进行 REDO 处理，对撤消队列中的事务进行 UNDO 处理

##### 检查点方法

DBMS 定时设置检查点，在检查点时，做下列事情

1. 将日志缓冲区中的日志记录写入磁盘
2. 将数据库缓冲区中修改过的缓冲块内容写入磁盘
3. 写一个检查点记录到磁盘，内容包括
    - 检查点时刻，所有活动事务
    - 每个事务最近日志记录地址
4. 把磁盘中日志检测点记录的地址写入“重新启动文件中”

##### 检查点恢复步骤

1. 正向扫描日志文件，建立事务重做队列和事务撤消队列
    - 将已完成的事务加入重做队列
    - 撤销队列：未完成的事务加入撤销队列。
2. 对撤销队列做 UNDO 处理的方法是
    - 反向扫描日志文件，根据撤销队列的记录对每一个撤销事务的更新操作执行逆操作，使其恢复到原状态
3. 对重做队列做 REDO 处理的方法是
    - 正向扫描日志文件，根据重做队列的记录对每一个重做事务实施对数据库的更新操作

#### 运行记录优先原则

运行记录优先原则包括两点

- 将一个更新结果写到 DB 中前，必须确保**先在日志中成功登记**了这个更新。
- 直至对一事务的日志登记全部完成，方能够允许该事务完成 COMMIT 处理。

这个原则确保了发生故障后能够根据日志对事务进行 REDO 或 UNDO。 

### 数据库的并发控制

### 数据库的完整性

### 数据库的安全性
