---
title: "数据库原理（2）"
date: 2022-02-25
draft: false
author: "MelonCholi"
tags: [数据库]
categories: [专业课]
---

# 数据库原理二

## 第五章 规范化设计

### 关系模式的设计问题

#### 关系模式的外延和内涵

一个关系模型包括外延和内涵两个方面的内容。

- 外延：关系、表或当前值。

- 内涵：对数据的定义以及对数据完整性约束的定义。

#### 泛关系模式与数据库模式

关系模式 R(U)

- R：关系名字
- U：所有属性的全集
- 关系 r 是关系模式 R(U) 的当前值，是元组的集合
- 这样的关系模式和关系称为**泛关系模式**和泛关系。

实际使用时，用一个关系模式的集合 $\rho = \{ R_1,\dots,R_k\}$ 来代替 R(U)，其中每个 R~i~ 是 U 的子集，$\rho$ 称为**数据库模式**。

#### 关系模式的冗余和异常问题

冗余、修改异常、插入异常、删除异常

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151401739.png" alt="image-20220308151401739" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151410230.png" alt="image-20220308151410230" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151420363.png" alt="image-20220308151420363" style="zoom: 60%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151430051.png" alt="image-20220308151430051" style="zoom:60%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151446399.png" alt="image-20220308151446399" style="zoom:50%;" />

### 函数依赖

#### 函数依赖 FD 的定义

通俗定义：当 X 有一个确定值时，Y 一定有一个唯一的值与其对应

严格定义：

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151831420.png" alt="image-20220308151831420" style="zoom: 67%;" />

或者说，**属性 X 函数决定属性 Y，记作 X→Y**。 其中 X 叫决定因素，Y 叫被决定因素。

此定义可简单表述为：如果属性 X 的值决定属性 Y 的值,那么属性 Y 函数依赖于属性 X。 

换一种说法是，如果知道  X 的值，就可以获得 Y 的值。 

- 不依赖：$X \nrightarrow Y$

- 互相依赖：$X \leftrightarrow Y$

##### 例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153147662.png" alt="image-20220308153147662" style="zoom: 67%;" />

#### FD 的逻辑蕴涵、函数依赖集 F 的闭包

函数依赖集 F 的闭包：F 能推出的所有依赖组成的集合

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153351885.png" alt="image-20220308153351885" style="zoom:60%;" />

#### 函数依赖的推理规则

##### Armstrong 公理系统

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153406619.png" alt="image-20220308153406619" style="zoom:60%;" />

##### 另外三个推理规则

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308155923071.png" alt="image-20220308155923071" style="zoom:67%;" />

#### FD 与关键码的联系

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308160717162.png" alt="image-20220308160717162" style="zoom:67%;" />

##### 找候选键的方法

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161331535.png" alt="image-20220308161331535" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161440201.png" alt="image-20220308161440201" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161447918.png" alt="image-20220308161447918" style="zoom:67%;" />

#### 属性集的闭包

人话：属性 X 可以推出的所有属性的集合

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161457792.png" alt="image-20220308161457792" style="zoom:67%;" />

##### 求闭包

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161928927.png" alt="image-20220308161928927" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161942842.png" alt="image-20220308161942842" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162000436.png" alt="image-20220308162000436" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162008294.png" alt="image-20220308162008294" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162421014.png" alt="image-20220308162421014" style="zoom: 67%;" />

#### FD 的最小依赖集

##### 函数依赖集的等价

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162436812.png" alt="image-20220308162436812" style="zoom:67%;" />

##### 最小函数依赖集

最大函数依赖集就是闭包

- 保证右边都是单属性
- 消除左边的多余属性

- 消除多余的函数依赖

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151127771.png" alt="image-20220315151127771" style="zoom:67%;" />

##### 例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151412567.png" alt="image-20220315151412567" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151417206.png" alt="image-20220315151417206" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315153009173.png" alt="image-20220315153009173" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315153021337.png" alt="image-20220315153021337" style="zoom:67%;" />

### 关系模式的分解特性

#### 模式分解问题

分解：把一张表拆成多张表

投影定义重要！

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154036857.png" alt="image-20220315154036857" style="zoom: 67%;" />



函数依赖保持性：

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154427612.png" alt="image-20220315154427612" style="zoom:67%;" />

#### 无损分解

无损连接：分解后的表进行自然连接之后的表与原表的内容不多不少

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154616981.png" alt="image-20220315154616981" style="zoom:67%;" />

#### 无损分解的测试方法

<img src="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160031794.png" alt="image-20220315160031794" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160151601.png" alt="image-20220315160151601" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160202135.png" alt="image-20220315160202135" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160209405.png" alt="image-20220315160209405" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160217009.png" alt="image-20220315160217009" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160236362.png" alt="image-20220315160236362" style="zoom:67%;" /><img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160241704.png" alt="image-20220315160241704" style="zoom:67%;" />

##### 第二种方法

只分解成两个子模式时适用

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161148857.png" alt="image-20220315161148857" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161820582.png" alt="image-20220315161820582" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161848712.png" alt="image-20220315161848712" style="zoom:67%;" />

#### 保持函数依赖的分解

函数依赖保持性：F 在 Z 这个属性集合上的投影得到的小函数依赖集们的并集是否与 F 等价

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161858815.png" alt="image-20220315161858815" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161907624.png" alt="image-20220315161907624" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161915181.png" alt="image-20220315161915181" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161923688.png" alt="image-20220315161923688" style="zoom:67%;" />

### 关系模式的范式

![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png)

#### 第一范式 1NF

##### 反例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150648406.png" alt="image-20220322150648406" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150805914.png" alt="image-20220322150805914" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150818141.png" alt="image-20220322150818141" style="zoom:50%;" />

##### 定义

原子性：每一个属性都不可分解

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150848377.png" alt="image-20220322150848377" style="zoom: 67%;" />

##### 修改后的例子

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150953681.png" alt="image-20220322150953681" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151003707.png" alt="image-20220322151003707" style="zoom:67%;" />

#### 第二范式 2NF

##### 定义

第一范式有部分依赖的问题，而第二范式**消除了部分依赖**

在满足第一范式的条件下，其他属性都必须**完全依赖**于某个候选键属性

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151718007.png" alt="image-20220322151718007" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151741366.png" alt="image-20220322151741366" style="zoom: 67%;" />

#### 第三范式 3NF

（码 = 候选键）

第二范式会有传递依赖的问题，而第三范式**消除了传递依赖**

在满足第二范式的前提下，**每一个非主属性都不传递依赖于候选键（主属性）**。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322152917085.png" alt="image-20220322152917085" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322152926667.png" alt="image-20220322152926667" style="zoom:67%;" />

##### 例

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154419167.png" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154517415.png" alt="image-20220322154517415" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154654654.png" alt="image-20220322154654654" style="zoom:67%;" />

#### 巴克斯范式 BCNF

消除主属性之间的部分函数依赖和传递函数依赖

每一个决定因素都包含码

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160029125.png" alt="image-20220322160029125" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160222855.png" alt="image-20220322160222855" style="zoom: 67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160458916.png" alt="image-20220322160458916" style="zoom:67%;" />

#### 分解成 BCNF 模式集的方法

![image-20220327171535911](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png)

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161210743.png" alt="image-20220322161210743" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161220977.png" alt="image-20220322161220977" style="zoom:67%;" />

#### 分解成 3NF 模式集的方法

保函依赖分解题，先求最小依赖集。

依赖两侧未出现，分成子集放一边，剩余依赖变子集。

若要连接成无损，再添候选做子集。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161229166.png" alt="image-20220322161229166" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161233794.png" alt="image-20220322161233794" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161242727.png" alt="image-20220322161242727" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161936938.png" alt="image-20220322161936938" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161941646.png" alt="image-20220322161941646" style="zoom:67%;" />

## 第七章 数据库设计

数据库设计概述
规划
需求分析
概念结构设计
逻辑结构设计
物理结构设计
数据库的实现
数据库的运行和维护

## 第八章 数据库管理

### 事务的概念

#### 事务的定义

事务是由若干数据库操作组成的一个逻辑工作单位，是一个**不可分割**的工作单位。

- 一个应用程序可以包括多个事务。
- 事务以 BEGIN TRANSACTION 语句的成功执行开始，以 COMMIT 或 ROLLBACK 语句的成功执行结束。
- COMMIT（提交）语句表示一事务的全部操作都已成功，它对 DB 的所有更新可真正写到 DB 中。
- ROLLBACK（回退）语句表示事务没有成功地完成全部操作，系统将撤消该事务对 DB 已作的更新。 

#### 事务的性质（ACID）

事务有四个重要性质：原子性、一致性、隔离性和持久性。通常称为 “**ACID 性质**”。

- **原子性**（atomicity）
    - 事务对数据库的更新要么全部起作用，要么完全不起作用。（不可分割）
    - DBMS 的事务管理子系统	
- **一致性**（consistency）
    - 事务将数据库从一个一致性状态转变为另一个一致性状态。
    - 程序员（正确地编写事务）DBMS 的完整性子系统	
- **隔离性**（isolation ）
    - 事务相互隔离，在多个事务并发执行时，任一事务的更新操作在该事务成功提交前对其他事务都是不可见的。	
    - DBMS 的并发控制子系统	
- **持久性**（durability）
    - 事务一旦成功提交，其对数据库的更新就永久有效，不会因系统崩溃等而丢失。	
    - DBMS 的恢复管理子系统	 

#### 事物的状态变迁

![image-20220503151741223](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png)

### 数据库的恢复

#### 数据库恢复的定义

系统能把数据库从被破坏、不正确的状态、恢复到最近一个正确的状态，DBMS 的这种能力称为**数据库的可恢复性**。

#### 数据库恢复的基本策略和实现方法 

**基本策略**：**冗余**（数据重复存储）

**实现方法**：

- **备份**：定期对数据库复制或转储（静态转储和动态转储，海量转储和增量转储）。
- **日志**：执行事务时，记录其开始、结束和对 DB 的每次更新操作。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503152715965.png" alt="image-20220503152715965" style="zoom:67%;" />

#### 故障类型

- **事务故障**
    - 非预期事务故障：运算错误、数据错误、死锁等，故障事务夭折	
    - 可预期事务故障：在事务中可预期出错的地方所加的 ROLLBACK 语句		
- **系统故障**：硬件、系统软件出错，停电等，事务执行被打断，内存中数据被破坏	
- **介质故障**：磁头、磁盘控制器或磁盘损坏，盘上数据丢失，病毒破坏等，DB 遭破坏	

#### 恢复方法

当系统运行过程中发生故障，利用数据库后备副本和日志文件将数据库恢复到故障前的某个一致性状态。不同故障其恢复技术不一样

##### 事务故障的恢复

> 事务故障的恢复是由系统自动完成的，不需要用户干预。

事务故障是指事务在运行至正常终止点前被中止，此时恢复子系统应撤销（UNDO）此事务已对数据库进行的修改

**恢复步骤**

1. 反向扫描日志文件（即从最后向前扫描日志文件）
    - 查找该事务的更新操作。
2. 对该事务的更新操作执行逆操作。
    - 即将日志记录中“更新前的值”写入数据库
        - 若记录中是插入操作，则相当于做删除操作
        - 若记录中是删除操作，则做插入操作
        - 若是修改操作，则用修改前值代替修改后值。       
3. 继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。
4. 如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了

##### 系统故障的恢复

> 系统故障的恢复也由系统自动完成的，不需要用户干预。

系统故障造成数据库不一致状态的**原因**有两个

- 未完成事务对数据库的更新已写数据库
- 已提交事务对数据库的更新还留在缓冲区没来得及真正写入数据库。 

**恢复办法**

- 撤销故障发生时未完成的事务
- 重做已完成的事务

**恢复步骤**

1. 正向扫描日志文件 (即从头开始扫描日志文件)，找出在故障发生前
    - 已提交事务 (既有 `<Ti, START>` 记录，也有 `<Ti, COMMIT>` 记录)，将其事务标识记入**重做队列**
    - 尚未完成的事务 (有 `<Ti, START>` 记录，无 `<Ti,COMMIT>` 记录), 将其事务标识记入**撤销队列**
2. 对撤销队列中的各个事务进行**撤销**（UNDO）处理
    - **反向扫描**日志文件，对每个 UNDO 事务的更新操作执行**逆操作**，即将日志记录中“更新前的值”写入数据库
3. 对重做队列中的各个事务进行**重做**（REDO）处理
    - 正向扫描日志文件，对每个 REDO 事务重新执行登记操作，即将日志记录中“更新后的值”写入数据库

##### 介质故障的恢复

在发生介质故障和遭受病毒破坏时，磁盘上的物理数据库遭到毁灭性破坏。此时恢复的过程如下

1. 装入最新的后备副本到新的磁盘，使数据库恢复到最近一次转储时的一致状态
2. 装入有关的日志文件副本，重做已提交的所有事务

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503161657955.png" alt="image-20220503161657955" style="zoom:67%;" />

#### 检查点机制

检查点（Checkpoint）方法 ：DBMS 定时设置检查点，在检查点时刻才真正做到把对 DB 的修改写到磁盘，并在日志文件写入一条检查点记录。

**恢复方法**

1. 根据日志文件建立重做队列和事务撤消队列。
2. 对重做队列中的事务进行 REDO 处理，对撤消队列中的事务进行 UNDO 处理

##### 检查点方法

DBMS 定时设置检查点，在检查点时，做下列事情

1. 将日志缓冲区中的日志记录写入磁盘
2. 将数据库缓冲区中修改过的缓冲块内容写入磁盘
3. 写一个检查点记录到磁盘，内容包括
    - 检查点时刻，所有活动事务
    - 每个事务最近日志记录地址
4. 把磁盘中日志检测点记录的地址写入“重新启动文件中”

##### 检查点恢复步骤

1. 正向扫描日志文件，建立事务重做队列和事务撤消队列
    - 将已完成的事务加入重做队列
    - 未完成的事务加入撤销队列。
2. 对撤销队列做 UNDO 处理的方法是
    - 反向扫描日志文件，根据撤销队列的记录对每一个撤销事务的更新操作执行逆操作，使其恢复到原状态
3. 对重做队列做 REDO 处理的方法是
    - 正向扫描日志文件，根据重做队列的记录对每一个重做事务实施对数据库的更新操作

#### 运行记录优先原则

运行记录优先原则包括两点

- 将一个更新结果写到 DB 中前，必须确保**先在日志中成功登记**了这个更新。
- 直至对一事务的日志登记全部完成，方能够允许该事务完成 COMMIT 处理。

这个原则确保了发生故障后能够根据日志对事务进行 REDO 或 UNDO。 

### 数据库的并发控制

#### 并发操作带来三个问题

为了充分利用数据库这个共享资源，DBMS 允许多个事务并发地存取数据库。

如果不对并发操作进行恰当的控制，可能导致如下的数据不一致性问题：

- 丢失更新问题：（更新被覆盖）一事务所作的更新操作因另一事务的操作而丢失。
- 不一致分析问题：（前后读取不一致）指事务从数据库中读取了处于不一致状态的数据，并因此进行了不一致的分析。 
- 读 “脏数据” 问题（读取的数据被撤销）：又称为未提交依赖，指一事务取用了别的事务未提交随后又被**撤消**的数据。

##### 丢失更新

> Lost Update

指事务 Ti 与事务 Tj 从数据库中读入同一数据并修改，事务 Tj 的提交结果破坏了事务 Ti 提交的结果，导致事务 Ti 的修改被丢失。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516210506608.png" alt="image-20220516210506608" style="zoom:67%;" />

##### 不一致分析

> 不可重复读 nonrepeatable  read

指事务 Ti 读取数据后，事务 Tj 执行更新操作，使事务 Ti 无法再读取前一次结果

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516211547543.png" alt="image-20220516211547543" style="zoom:67%;" />

##### 读“脏”数据

> diriy  read

事务 Ti 修改某一数据，并将其写回磁盘，事务 Tj 读取同一数据后，事务 Ti 由于某种原因被撤销，这时事务 Ti 已修改过的数据恢复原值，事务 Tj 读到的数据就与数据库中的数据不一致，是不正确的数据，称为“脏”数据。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516212059994.png" alt="image-20220516212059994" style="zoom:67%;" />

#### 封锁机制

封锁是实现并发控制的重要技术。

所谓封锁，是指事务向系统发出对某数据对象**加锁**的请求，以取得对该对象一定的控制权。

基本的封锁有两类：

- **排它型封锁**（写锁，X 封锁）：一个事务对数据对象加了 X 锁后，在它释放 X 锁之前不允许其他事务再对该数据对象加任何锁。
- **共享型锁**（读锁，S 封锁） ：一个事务对数据对象加了 S 锁后，允许其他事务再对该数据对象加 S 锁，但在它释放 S 锁之前不允许其他事务加 X 锁。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516213308761.png" alt="image-20220516213308761" style="zoom: 50%;" /> 

##### 排它型封锁

**PX 协议**主要内容是：

- 事务若要更新数据，则必须先提出对此数据对象的 X 封锁请求；
- 事务如果未获准 X 封锁，那么进入等待状态，直至获准在此数据对象上的 X 封锁，才能继续执行。

PX 协议可以解决因多事务同时更新同一数据对象而引起的更新丢失问题。 

**PXC 协议** 是在 PX 协议上再加一规定：解除 X 锁的操作合并到事务的结束（COMMIT 或 ROLLBACK）操作中。

PXC 协议可以解决因事务 ROLLBACK 而引起的更新丢失问题。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516212541732.png" alt="image-20220516212541732" style="zoom: 67%;" />

##### 共享型封锁

**PS 协议**，其主要内容是：

- 事务若要存取数据，则必须先提出对此数据对象的 S 封锁请求；
- 事务如果未获准 S 封锁，那么进入等待状态，直至获准在此数据对象上 S 封锁，才能继续执行；
- 事务在更新数据前必须先将它在该数据对象上的 S 封锁升级（UPGRADE）为 X 封锁。 

**PSC协议**是在 PS 协议上再加一规定：解锁操作合并到事务的结束（COMMIT 或 ROLLBACK）操作中。

PSC 协议可以解决丢失更新、读 “脏数据” 和不一致分析问题。 

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516212728567.png" alt="image-20220516212728567" style="zoom:67%;" />

#### 活锁和死锁

恰当地运用封锁技术，可以保证并发调度的正确性、有效地避免数据不一致，但有可能引起活锁和死锁问题。

##### 活锁

出现某个事务永远处于等待状态得不到执行的现象。

避免活锁的一个简便方法是采用“先来先服务”排队的策略。封锁子系统按请求在时间上的先后次序对事务排序，数据对象上原有的锁一释放，即执行队列中第一个事务的封锁请求。 

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516213848559.png" alt="image-20220516213848559" style="zoom:67%;" />

##### 死锁

出现若干事务因循环等待而无法继续执行的现象。

例： 两个事务 T1 和 T2 已分别封锁了数据 D1 和 D2。 T1 和 T2 由于需要各自分别申请封锁 D2 和 D1，但是由于D2 和 D1 已被对方封锁，因而 T1 和 T2 只能等待。 而 T1 和 T2 由于等待封锁而不能结束，从而使对方的封锁申请也永远不能被选中，这就形成了死锁。

死锁的诊断：DBMS 周期地测试系统中是否出现了死锁。用事务依赖图的形式可以测试系统中是否存在死锁。如果在事务依赖图中，沿着箭头方向存在一个循环，那么表示已出现死锁现象。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214047843.png" alt="image-20220516214047843" style="zoom:67%;" />

#### 并发事务的可串行化调度

##### 事务的调度、串行调度和并发调度

- 调度：事务的**执行次序**

- 串行调度：多个事务**依次**执行

- 并发调度：设法（例如利用分时的方法）使多个事务**同时**被处理（即交错执行）

在应用环境中，事务的任一串行调度都是有效的（正确的），但是事务的并发调度不一定是正确的，有可能产生前面提到的不一致性问题。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214740738.png" alt="image-20220516214740738" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214754739.png" alt="image-20220516214754739" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214801766.png" alt="image-20220516214801766" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214807748.png" alt="image-20220516214807748" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214840390.png" alt="image-20220516214840390" style="zoom:50%;" />

了保证并行操作的正确性，DBMS 的并行控制机制必须提供一定的手段来保证调度是可串行化的。

从理论上讲，在某一事务执行时禁止其他事务执行的调度策略一定是可串行化的调度，这也是最简单的调度策略，但这种方法实际上是不可行的，因为它使用户不能充分共享数据库资源。

##### 可串行化与两端封锁协议

**可串行化**：如果一个并发调度与某一串行调度具有相同的执行结果，那么称这个并发调度是“可串行化的调度”（即正确的并发调度），否则是不可串行化的调度。

**两段封锁协议**：事务在对数据对象存取之前必须先获得对此数据对象的封锁，事务在解除了一个锁之后不再获得任何锁。

- :star: 若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的；

- 但若并发事务的一个调度是可串行化的，并不一定所有事务都符合两段封锁协议。 

- 两段封锁协议与防止死锁的一次封锁法是不同的。一次封锁法符合两段封锁协议，但两段封锁协议并不要求一

    次封锁法。因此，遵守两段封锁协议的事务也有可能发生死锁。

**封锁粒度**：封锁对象的规模称为封锁粒度（Granularity）。

#### SQL 中事务的存取模式和隔离级别

事务的存取模式

- READ ONLY（只读型）
- READ WRITE（读写型）

事务的隔离级别

- SERIALIZABLE（可串行化）
- REPEATABLE READ （可重复读）
- READ COMMITED（读提交数据）
- READ UNCOMMITED（读未提交数据）

### 数据库的完整性

#### 完整性子系统和完整性规则

##### 定义

**完整性**：是指数据的正确性、有效性和相容性。

**完整性约束条件**：为保证数据的完整性而规定的条件。

**完整性检查**：检查 DB 中数据是否满足完整性约束条件。

**完整性子系统**：DBMS 中执行完整性检查的子系统。其功能有：

- 监督事务的执行，测试其是否违反完整性约束条件；
- 若有违反，则按进行预定的处理。 

##### 完整性规则的组成

每个规则包括三部分：

- **触发条件**：规定何时执行本规则进行检查；
- **约束条件**：又称谓词，定义应满足的条件；
- **否则子句**：规定不满足条件时该作的处理。

在关系 DB 中，完整性规则可分为三类：

- **域完整性规则**：定义属性取值范围。
- **域联系的规则**：定义属性间的联系、影响和约束。
- **关系完整性规则**：定义更新操作对值的影响和限制。

完整性规则用 DDL 描述，由系统执行检查。 

#### SQL 中的完整性约束

完整性约束分为三大类：

- 域约束
- 基本表约束
- 断言

##### 域完整性规则

域完整性规则：定义属性的取值范围——属性值约束。

包括：**域约束子句**、**非空值约束**、**基于属性的检查子句**

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516223852029.png" alt="image-20220516223852029" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516223859244.png" alt="image-20220516223859244" style="zoom:67%;" />

##### 基本表约束

**主键约束**

可用主键约束来描述实体完整性规则。主键约束可用两种形式表示：**主键子句**和**主键短语**。

主码可在定义关系的 CREATE TABLE 语句中使用 PRIMARY KEY 关键字加以定义。

有两种定义主键的方法，一种是在属性后增加关键字，另一种是在属性表中加入额外的定义主键的子句：

```sql
PRIMARY KEY(主键属性名表)
```

使用关键字 UNIQUE，说明该属性（或属性组）的值不能重复出现。

**外键约束**

```sql
FOREIGN  KEY(<列名序列1>).
   REFERENCES  <参照表>  [(<列名序列2>)]
   [ ON  DELETE <参照动作> ]
   [ ON  UPDATE <参照动作> ]
```

外部码的取值只有两种情况：

1. 取空值；②
2. 取参照关系中的主码值。

当用户的删除或修改操作违反了上述规则时，如何保持此种约束呢？SQL 中提供了五种可选方案供数据库实现者使用：

- NO ACTION（无影响）
- CASCADE（级联方式）
- RESTRICT（受限方式）
- SET  NULL（置空值）
- SET  DEFAULT（置缺省值）

**检查约束**

对单个关系的元组值加以约束。

对表内元组说明约束时，在 CREATE TABLE 语句中的属性表、主码、外部码的说明之后加上 CHECK 子句。每当对元组进行插入或修改操作时，都要对 CHECK 子句的条件表达式求值，如果条件为假，违背了约束，系统将拒绝该插入或修改操作。

CHECK 子句的一般格式为： ` CHECK <条件>`

##### 断言

如果完整性约束与多个关系有关，或者与聚合操作有关，SQL 提供“断言”（Assertions）机制让用户书写完整性约束。

定义：

```sql
CREATE ASSERTION 断言名 CHECK（条件）
```

撤消：
```sql
DROP ASSERTION 断言名
```

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224400263.png" alt="image-20220516224400263" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224612538.png" alt="image-20220516224612538" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224414554.png" alt="image-20220516224414554" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224425631.png" alt="image-20220516224425631" style="zoom:50%;" />

断言也可以在关系定义中用检查子句形式定义，但是检查子句不一定能保证完整性约束彻底实现，而断言能保证不出差错。

#### SQL3 的触发器

**定义**

- 触发器（Trigger）不仅能实现完整性规则，而且能保证一些较复杂业务规则的实施。
- 所谓触发器就是一类由事件驱动的特殊过程，一旦由某个用户定义，任何用户对该触发器指定的数据进行增、删或改操作时，系统将**自动**激活相应的触发器，在核心层进行集中的完整性控制。

**触发器结构分三部分**

- **事件**：对数据库的插入、删除和修改等操作。
- **条件**：触发器将测试条件是否成立。
- **动作**：如果测试满足预定的条件，就由 DBM S执行这些动作。

**触发器结构组成**

触发事件包括表中行的插入、删除和修改，即执行 INSERT、DELETE、UPDATE 语句

在修改操作（UPDATE）中，还可以指定，特定的属性或属性组的修改为触发条件。

事件的触发还有两个相关的时间：Before 和 After。Before 触发器是在事件发生之前触发，After 触发器是在事件发生之后触发。

触发动作实际上是一系列 SQL 语句，可以有两种方式：

1. 对被事件影响的每一行（FOR EACH ROW）——每一元组执行触发过程，称为行级触发器。
2. 对整个事件只执行一次触发过程（FOR EACH STATEMENT）称为语句级触发器。该方式是触发器的默认方式。所以综合触发时间和触发方式，触发器的基本类型如下表所示。

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153502055.png" alt="image-20220517153502055" style="zoom:50%;" />

##### 实例

###### 一

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153550774.png" alt="image-20220517153550774" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153613756.png" alt="image-20220517153613756" style="zoom:50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153620490.png" alt="image-20220517153620490" style="zoom: 50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153626559.png" alt="image-20220517153626559" style="zoom: 67%;" />

###### 二

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517160117909.png" alt="image-20220517160117909" style="zoom: 50%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153714566.png" alt="image-20220517153714566" style="zoom:67%;" />

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517160156102.png" alt="image-20220517160156102" style="zoom: 67%;" />

#### SQL Server 的数据库完整性及实现方法

SQL Server 具有较健全的数据库完整性控制机制。

SQL Server 使用约束、缺省，规则和触发器4种方法

定义和实施数据库完整性功能。

### 数据库的安全性

```
Options:
  -h, --help            show this help message and exit
  --configure           Invoke interactive (re)configuration tool. Optionally
                        use as '--configure s3://some-bucket' to test access
                        to a specific bucket instead of attempting to list
                        them all.
  -c FILE, --config=FILE
                        Config file name. Defaults to $HOME/.s3cfg
  --dump-config         Dump current configuration after parsing config files
                        and command line options and exit.
  --access_key=ACCESS_KEY
                        AWS Access Key
  --secret_key=SECRET_KEY
                        AWS Secret Key
  --access_token=ACCESS_TOKEN
                        AWS Access Token
  -n, --dry-run         Only show what should be uploaded or downloaded but
                        don't actually do it. May still perform S3 requests to
                        get bucket listings and other information though (only
                        for file transfer commands)
  -s, --ssl             Use HTTPS connection when communicating with S3.
                        (default)
  --no-ssl              Don't use HTTPS.
  -e, --encrypt         Encrypt files before uploading to S3.
  --no-encrypt          Don't encrypt files.
  -f, --force           Force overwrite and other dangerous operations.
  --continue            Continue getting a partially downloaded file (only for
                        [get] command).
  --continue-put        Continue uploading partially uploaded files or
                        multipart upload parts.  Restarts parts/files that
                        don't have matching size and md5.  Skips files/parts
                        that do.  Note: md5sum checks are not always
                        sufficient to check (part) file equality.  Enable this
                        at your own risk.
  --upload-id=UPLOAD_ID
                        UploadId for Multipart Upload, in case you want
                        continue an existing upload (equivalent to --continue-
                        put) and there are multiple partial uploads.  Use
                        s3cmd multipart [URI] to see what UploadIds are
                        associated with the given URI.
  --skip-existing       Skip over files that exist at the destination (only
                        for [get] and [sync] commands).
  -r, --recursive       Recursive upload, download or removal.
  --check-md5           Check MD5 sums when comparing files for [sync].
                        (default)
  --no-check-md5        Do not check MD5 sums when comparing files for [sync].
                        Only size will be compared. May significantly speed up
                        transfer but may also miss some changed files.
  -P, --acl-public      Store objects with ACL allowing read for anyone.
  --acl-private         Store objects with default ACL allowing access for you
                        only.
  --acl-grant=PERMISSION:EMAIL or USER_CANONICAL_ID
                        Grant stated permission to a given amazon user.
                        Permission is one of: read, write, read_acp,
                        write_acp, full_control, all
  --acl-revoke=PERMISSION:USER_CANONICAL_ID
                        Revoke stated permission for a given amazon user.
                        Permission is one of: read, write, read_acp,
                        write_acp, full_control, all
  -D NUM, --restore-days=NUM
                        Number of days to keep restored file available (only
                        for 'restore' command). Default is 1 day.
  --restore-priority=RESTORE_PRIORITY
                        Priority for restoring files from S3 Glacier (only for
                        'restore' command). Choices available: bulk, standard,
                        expedited
  --delete-removed      Delete destination objects with no corresponding
                        source file [sync]
  --no-delete-removed   Don't delete destination objects [sync]
  --delete-after        Perform deletes AFTER new uploads when delete-removed
                        is enabled [sync]
  --delay-updates       *OBSOLETE* Put all updated files into place at end
                        [sync]
  --max-delete=NUM      Do not delete more than NUM files. [del] and [sync]
  --limit=NUM           Limit number of objects returned in the response body
                        (only for [ls] and [la] commands)
  --add-destination=ADDITIONAL_DESTINATIONS
                        Additional destination for parallel uploads, in
                        addition to last arg.  May be repeated.
  --delete-after-fetch  Delete remote objects after fetching to local file
                        (only for [get] and [sync] commands).
  -p, --preserve        Preserve filesystem attributes (mode, ownership,
                        timestamps). Default for [sync] command.
  --no-preserve         Don't store FS attributes
  --exclude=GLOB        Filenames and paths matching GLOB will be excluded
                        from sync
  --exclude-from=FILE   Read --exclude GLOBs from FILE
  --rexclude=REGEXP     Filenames and paths matching REGEXP (regular
                        expression) will be excluded from sync
  --rexclude-from=FILE  Read --rexclude REGEXPs from FILE
  --include=GLOB        Filenames and paths matching GLOB will be included
                        even if previously excluded by one of
                        --(r)exclude(-from) patterns
  --include-from=FILE   Read --include GLOBs from FILE
  --rinclude=REGEXP     Same as --include but uses REGEXP (regular expression)
                        instead of GLOB
  --rinclude-from=FILE  Read --rinclude REGEXPs from FILE
  --files-from=FILE     Read list of source-file names from FILE. Use - to
                        read from stdin.
  --region=REGION, --bucket-location=REGION
                        Region to create bucket in. As of now the regions are:
                        us-east-1, us-west-1, us-west-2, eu-west-1, eu-
                        central-1, ap-northeast-1, ap-southeast-1, ap-
                        southeast-2, sa-east-1
  --host=HOSTNAME       HOSTNAME:PORT for S3 endpoint (default:
                        s3.amazonaws.com, alternatives such as s3-eu-
                        west-1.amazonaws.com). You should also set --host-
                        bucket.
  --host-bucket=HOST_BUCKET
                        DNS-style bucket+hostname:port template for accessing
                        a bucket (default: %(bucket)s.s3.amazonaws.com)
  --reduced-redundancy, --rr
                        Store object with 'Reduced redundancy'. Lower per-GB
                        price. [put, cp, mv]
  --no-reduced-redundancy, --no-rr
                        Store object without 'Reduced redundancy'. Higher per-
                        GB price. [put, cp, mv]
  --storage-class=CLASS
                        Store object with specified CLASS (STANDARD,
                        STANDARD_IA, ONEZONE_IA, INTELLIGENT_TIERING, GLACIER
                        or DEEP_ARCHIVE). [put, cp, mv]
  --access-logging-target-prefix=LOG_TARGET_PREFIX
                        Target prefix for access logs (S3 URI) (for [cfmodify]
                        and [accesslog] commands)
  --no-access-logging   Disable access logging (for [cfmodify] and [accesslog]
                        commands)
  --default-mime-type=DEFAULT_MIME_TYPE
                        Default MIME-type for stored objects. Application
                        default is binary/octet-stream.
  -M, --guess-mime-type
                        Guess MIME-type of files by their extension or mime
                        magic. Fall back to default MIME-Type as specified by
                        --default-mime-type option
  --no-guess-mime-type  Don't guess MIME-type and use the default type
                        instead.
  --no-mime-magic       Don't use mime magic when guessing MIME-type.
  -m MIME/TYPE, --mime-type=MIME/TYPE
                        Force MIME-type. Override both --default-mime-type and
                        --guess-mime-type.
  --add-header=NAME:VALUE
                        Add a given HTTP header to the upload request. Can be
                        used multiple times. For instance set 'Expires' or
                        'Cache-Control' headers (or both) using this option.
  --remove-header=NAME  Remove a given HTTP header.  Can be used multiple
                        times.  For instance, remove 'Expires' or 'Cache-
                        Control' headers (or both) using this option. [modify]
  --server-side-encryption
                        Specifies that server-side encryption will be used
                        when putting objects. [put, sync, cp, modify]
  --server-side-encryption-kms-id=KMS_KEY
                        Specifies the key id used for server-side encryption
                        with AWS KMS-Managed Keys (SSE-KMS) when putting
                        objects. [put, sync, cp, modify]
  --encoding=ENCODING   Override autodetected terminal and filesystem encoding
                        (character set). Autodetected: UTF-8
  --add-encoding-exts=EXTENSIONs
                        Add encoding to these comma delimited extensions i.e.
                        (css,js,html) when uploading to S3 )
  --verbatim            Use the S3 name as given on the command line. No pre-
                        processing, encoding, etc. Use with caution!
  --disable-multipart   Disable multipart upload on files bigger than
                        --multipart-chunk-size-mb
  --multipart-chunk-size-mb=SIZE
                        Size of each chunk of a multipart upload. Files bigger
                        than SIZE are automatically uploaded as multithreaded-
                        multipart, smaller files are uploaded using the
                        traditional method. SIZE is in Mega-Bytes, default
                        chunk size is 15MB, minimum allowed chunk size is 5MB,
                        maximum is 5GB.
  --list-md5            Include MD5 sums in bucket listings (only for 'ls'
                        command).
  -H, --human-readable-sizes
                        Print sizes in human readable form (eg 1kB instead of
                        1234).
  --ws-index=WEBSITE_INDEX
                        Name of index-document (only for [ws-create] command)
  --ws-error=WEBSITE_ERROR
                        Name of error-document (only for [ws-create] command)
  --expiry-date=EXPIRY_DATE
                        Indicates when the expiration rule takes effect. (only
                        for [expire] command)
  --expiry-days=EXPIRY_DAYS
                        Indicates the number of days after object creation the
                        expiration rule takes effect. (only for [expire]
                        command)
  --expiry-prefix=EXPIRY_PREFIX
                        Identifying one or more objects with the prefix to
                        which the expiration rule applies. (only for [expire]
                        command)
  --progress            Display progress meter (default on TTY).
  --no-progress         Don't display progress meter (default on non-TTY).
  --stats               Give some file-transfer stats.
  --enable              Enable given CloudFront distribution (only for
                        [cfmodify] command)
  --disable             Disable given CloudFront distribution (only for
                        [cfmodify] command)
  --cf-invalidate       Invalidate the uploaded filed in CloudFront. Also see
                        [cfinval] command.
  --cf-invalidate-default-index
                        When using Custom Origin and S3 static website,
                        invalidate the default index file.
  --cf-no-invalidate-default-index-root
                        When using Custom Origin and S3 static website, don't
                        invalidate the path to the default index file.
  --cf-add-cname=CNAME  Add given CNAME to a CloudFront distribution (only for
                        [cfcreate] and [cfmodify] commands)
  --cf-remove-cname=CNAME
                        Remove given CNAME from a CloudFront distribution
                        (only for [cfmodify] command)
  --cf-comment=COMMENT  Set COMMENT for a given CloudFront distribution (only
                        for [cfcreate] and [cfmodify] commands)
  --cf-default-root-object=DEFAULT_ROOT_OBJECT
                        Set the default root object to return when no object
                        is specified in the URL. Use a relative path, i.e.
                        default/index.html instead of /default/index.html or
                        s3://bucket/default/index.html (only for [cfcreate]
                        and [cfmodify] commands)
  -v, --verbose         Enable verbose output.
  -d, --debug           Enable debug output.
  --version             Show s3cmd version (2.2.0) and exit.
  -F, --follow-symlinks
                        Follow symbolic links as if they are regular files
  --cache-file=FILE     Cache FILE containing local source MD5 values
  -q, --quiet           Silence output on stdout
  --ca-certs=CA_CERTS_FILE
                        Path to SSL CA certificate FILE (instead of system
                        default)
  --ssl-cert=SSL_CLIENT_CERT_FILE
                        Path to client own SSL certificate CRT_FILE
  --ssl-key=SSL_CLIENT_KEY_FILE
                        Path to client own SSL certificate private key
                        KEY_FILE
  --check-certificate   Check SSL certificate validity
  --no-check-certificate
                        Do not check SSL certificate validity
  --check-hostname      Check SSL certificate hostname validity
  --no-check-hostname   Do not check SSL certificate hostname validity
  --signature-v2        Use AWS Signature version 2 instead of newer signature
                        methods. Helpful for S3-like systems that don't have
                        AWS Signature v4 yet.
  --limit-rate=LIMITRATE
                        Limit the upload or download speed to amount bytes per
                        second.  Amount may be expressed in bytes, kilobytes
                        with the k suffix, or megabytes with the m suffix
  --no-connection-pooling
                        Disable connection re-use
  --requester-pays      Set the REQUESTER PAYS flag for operations
  -l, --long-listing    Produce long listing [ls]
  --stop-on-error       stop if error in transfer
  --content-disposition=CONTENT_DISPOSITION
                        Provide a Content-Disposition for signed URLs, e.g.,
                        "inline; filename=myvideo.mp4"
  --content-type=CONTENT_TYPE
                        Provide a Content-Type for signed URLs, e.g.,
                        "video/mp4"

Commands:
  Make bucket
      s3cmd mb s3://BUCKET
  Remove bucket
      s3cmd rb s3://BUCKET
  List objects or buckets
      s3cmd ls [s3://BUCKET[/PREFIX]]
  List all object in all buckets
      s3cmd la
  Put file into bucket
      s3cmd put FILE [FILE...] s3://BUCKET[/PREFIX]
  Get file from bucket
      s3cmd get s3://BUCKET/OBJECT LOCAL_FILE
  Delete file from bucket
      s3cmd del s3://BUCKET/OBJECT
  Delete file from bucket (alias for del)
      s3cmd rm s3://BUCKET/OBJECT
  Restore file from Glacier storage
      s3cmd restore s3://BUCKET/OBJECT
  Synchronize a directory tree to S3 (checks files freshness using size and md5 checksum, unless overridden by options, see below)
      s3cmd sync LOCAL_DIR s3://BUCKET[/PREFIX] or s3://BUCKET[/PREFIX] LOCAL_DIR or s3://BUCKET[/PREFIX] s3://BUCKET[/PREFIX]
  Disk usage by buckets
      s3cmd du [s3://BUCKET[/PREFIX]]
  Get various information about Buckets or Files
      s3cmd info s3://BUCKET[/OBJECT]
  Copy object
      s3cmd cp s3://BUCKET1/OBJECT1 s3://BUCKET2[/OBJECT2]
  Modify object metadata
      s3cmd modify s3://BUCKET1/OBJECT
  Move object
      s3cmd mv s3://BUCKET1/OBJECT1 s3://BUCKET2[/OBJECT2]
  Modify Access control list for Bucket or Files
      s3cmd setacl s3://BUCKET[/OBJECT]
  Modify Bucket Policy
      s3cmd setpolicy FILE s3://BUCKET
  Delete Bucket Policy
      s3cmd delpolicy s3://BUCKET
  Modify Bucket CORS
      s3cmd setcors FILE s3://BUCKET
  Delete Bucket CORS
      s3cmd delcors s3://BUCKET
  Modify Bucket Requester Pays policy
      s3cmd payer s3://BUCKET
  Show multipart uploads
      s3cmd multipart s3://BUCKET [Id]
  Abort a multipart upload
      s3cmd abortmp s3://BUCKET/OBJECT Id
  List parts of a multipart upload
      s3cmd listmp s3://BUCKET/OBJECT Id
  Enable/disable bucket access logging
      s3cmd accesslog s3://BUCKET
  Sign arbitrary string using the secret key
      s3cmd sign STRING-TO-SIGN
  Sign an S3 URL to provide limited public access with expiry
      s3cmd signurl s3://BUCKET/OBJECT <expiry_epoch|+expiry_offset>
  Fix invalid file names in a bucket
      s3cmd fixbucket s3://BUCKET[/PREFIX]
  Create Website from bucket
      s3cmd ws-create s3://BUCKET
  Delete Website
      s3cmd ws-delete s3://BUCKET
  Info about Website
      s3cmd ws-info s3://BUCKET
  Set or delete expiration rule for the bucket
      s3cmd expire s3://BUCKET
  Upload a lifecycle policy for the bucket
      s3cmd setlifecycle FILE s3://BUCKET
  Get a lifecycle policy for the bucket
      s3cmd getlifecycle s3://BUCKET
  Remove a lifecycle policy for the bucket
      s3cmd dellifecycle s3://BUCKET
  List CloudFront distribution points
      s3cmd cflist
  Display CloudFront distribution point parameters
      s3cmd cfinfo [cf://DIST_ID]
  Create CloudFront distribution point
      s3cmd cfcreate s3://BUCKET
  Delete CloudFront distribution point
      s3cmd cfdelete cf://DIST_ID
  Change CloudFront distribution point parameters
      s3cmd cfmodify cf://DIST_ID
  Display CloudFront invalidation request(s) status
      s3cmd cfinvalinfo cf://DIST_ID[/INVAL_ID]

For more information, updates and news, visit the s3cmd website:
http://s3tools.org
```

