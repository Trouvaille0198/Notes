---
title: "编译原理"
date: 2021-03-08
draft: true
author: "MelonCholi"
tags: [编译原理]
categories: [专业课]
---

# 编译原理

## pre: 编译过程

### 编译目标

目标：把源代码变成目标代码

1. 如果源代码在操作系统上运行：目标代码就是“汇编代码”。再通过汇编和链接的过程形成可执行文件，然后通过加载器加载到操作系统执行。

2. 如果源代码在虚拟机(解释器)上运行：目标代码就是“解释器可以理解的中间形式的代码”，比如字节码 (中间代码) IR、AST 语法树。

编译过程可以分为这几个阶段，每个阶段做了一定的任务，层级的让下一个阶段进行。
![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1454456-20201031102308523-1286792681.png)

### 词法分析

编译器读入源代码，经过词法分析器识别出 Token，把字符串转换成一个个 Token。
Token 的类型包括：关键字、标识符、字面量、操作符、界符等

比如下面的 C 语言代码源文件，经过词法分析器识别出的 token 有：int、foo、a、b、=、+、return、(){} 等token

```cpp
int foo(int a){
    int b = a + 3;
    return b;
}
```

**为什么要这样做呢，把代码里的单词进行分类，编译器后面的阶段不就更好处理理解代码了嘛！**

### 语法分析

> 每一个程序代码，实际上可以通过树这种结构表现出其语法规则。

语法分析阶段把 Token 串，转换成一个体现语法规则的、树状数据结构，即抽象语法树 AST。

**AST 树反映了程序的语法结构。**

比如下面对应的一段 C 语言代码，对应的 AST 抽象语法树如下所示：

```cpp
int foo(int a){
    int b = a + 3;
    return b;
}
```

![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1454456-20201031102308523-1286792681.png)

AST 树长成什么样，由语法的结构有关。

比如，上面 C 语言代码中对函数的语法定义如下：语法分析器就按照语法定义进行解析，就是从上到下匹配的过程。
也就是先匹配 function 的规则，匹配函数类型 type、函数名 name、函数参数 parameters、函数体

当匹配函数参数时，就去匹配 parameters 的规则

当匹配函数体时，函数体由一个个语句组成，就去匹配各个语句stmt的规则。

```go
function := type name parameters functionBody
parameters:= parameter*                          
functionBody:= stmt returnStatement
```

生成 AST 以后，程序的语法结构就很清晰了，但这棵树到底代表了什么意思，我们目前仍然不能完全确定，要在语义分析阶段确定。

**为什么要把程序转换成 AST 这么一颗树，因为编译器不像人能直接理解语句的含义，AST 树更有结构性，后续阶段可以针对这颗树做各种分析！**

### 语义分析

语义分析阶段的任务：理解语义，语句要做什么。

比如 + 号要执行加法、= 号要执行赋值、for 结构要去实现循环、if 结构实现判断。

所以语义阶段要做的内容有：上下文分析（包括引用消解、类型分析与检查等）

引用消解：找到变量所在的作用域，一个变量作用范围属于全局还是局部。

类型识别：比如执行 a+3，需要识别出变量 a 的类型，因为浮点数和整型执行不一样，要执行不同的运算方式。

类型检查：比如 int b = a + 3，是否可以进行定义赋值。等号右边的表达式必须返回一个整型的数据、或则能够自

动转换成整型的数据，才能够对类型为整型的变量 b 进行复制。

比如之前的一段 C 语言代码，经过语义分析后获得的信息（引用消解信息、类型信息），可以在 AST 上进行标注，形成下面的“带有标注的语法树”，让编译器更好的理解程序的语义。
![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1454456-20201031102308523-1286792681.png)

也会将这些上下文信息存入“符号表”结构中，便于各阶段查询上下文信息。
符号表是有层次的结构：我们只需要逐级向上查找就能找到变量、函数等的信息(作用域、类型等)
![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1454456-20201031102308523-1286792681.png)

接下来就可以 解释执行：实现一门解释型的语言

Tip：编译型语言需要生成目标代码，而解释性语言只需要解释器去执行语义就可以了。

实现 AST 的解释器：在语法分析后有了程序的抽象语法树，在语义分析后有了 “带有标注的 AST” 和符号表后，就可以深度优先遍历 AST，并且一边遍历一边执行结点的语义规则。整个遍历的过程就是执行代码的过程。

举一个解释执行的例子，比如执行下面的语义：

- 遇到语法树中的 add “+” 节点：把两个子节点的值进行相加，作为 “+” 节点的值。
- 遇到语法树中的变量节点(右值)：就取出变量的值。
- 遇到字面量比如数字 2：返回这个字面量代表的数值 2。

### 中间代码生成

在编译前端完成后(编译器已经理解了词法和语义)，编译器可以直接解释执行、或则直接生成目标代码。对于不同架构的 CPU，还需要生成不同的汇编代码，如果对每一种汇编代码做优化就很繁琐了。所以我们需要增加一个环节：生成中间代码 IR，统一优化后中间代码，再去将中间代码生成目标代码。

中间代码 IR 的两个用途：解释执行 、代码优化

解释执行：解释型语言，比如 Python 和 Java，生成 IR 后就能直接执行了，也就是前面举出的例子。

优化代码：比如 LLVM 等工具；在生成代码后需要做大量的优化工作，而很多优化工作没必要使用汇编代码来做(因为不同 CPU 体系的汇编语言不同)，而可以基于 IR 用统一的算法来完成，降低编译器适配不同 CPU 的复杂性。

### 代码优化

一种方案：基于基本块作代码优化

分类：本地优化、全局优化、过程间优化

- 本地优化：可用表达式分析、活跃性分析

- 全局优化：基于控制流图 CFG 作优化。
    - 控制流图 CFG ：是一种有向图，它体现了基本块之前的指令流转关系，如果从BLOCK1的最后一条指令是跳转到  BLOCK2， 就连一条边，如果通过分析 CFG，发现某个变量在其他地方没有被使用，就可以把这个变量所在代码行删除。

- 过程间优化：跨越函数的优化，多个函数间作优化

优化案例：

代数优化：

比如删除 “x:=x+0 ”，乘法优化掉 “x:=x 乘以 0” 可以简化成  “x:=0”，乘法优化成移位运算：“x:=x*8” 可以优化成“x:=x<<3”。

常数折叠：

对常数的运算可以在编译时计算，比如 “x:= 20 乘以 3” 可以优化成 “x:=60”
删除公共子表达式：作“可用表达式分析”

```go
x := a + b
y := a + b //优化成y := x
```

拷贝传播：作 “可用表达式分析”

```go
x := a + b
y := x
z := 2 * y //优化成z:= 2 * x
```

常数传播：

```go
x := 20
y := 10
z := x + y//优化成z := 30
```

死代码删除：作变量的 “活跃性分析”
活跃性分析（优化删除死代码，没用到的变量） 数据流分析：使用 “半格理论” 解决多路径的 V 值计算集合问题，不在代码下面集合的变量就是死代码。

### 目标代码生成

目标代码生成，也就是生成虚拟机执行的字节码，或则操作系统执行的汇编代码

**代码生成的过程，其实很简单，就是将中间代码IR逐个翻译成想要的汇编的代码**

那么目标代码生成阶段的任务就有：

- 选择合适指令，生成性能最高的代码。
- 优化寄存器的分配，让频繁访问的变量，比如循环语句中的变量放到寄存器中，寄存器比内存快
- 在不改变运行结果下，对指令做重排序优化，从而充分运用CPU内部的多个功能部件的并行能力

## 引论

### 什么是编译程序

一个编译程序就是一个语言翻译程序

> 判断题：编译程序就是解释程序 （:x:）

**编译程序与解释程序的异同**

- 相同点：都是进行翻译，将源程序翻译成目标程序
- 不同点：
    - 编译程序进行整体翻译
    - 解释程序进行逐条翻译

![image-20220308092338370](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308092338370.png)

### 编译过程和编译程序的结构

#### 编译过程概述

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308092425642.png" alt="image-20220308092425642" style="zoom:80%;" />

- **词法分析**
    - 识别单词，至少分以下几大类：关键字（保留字）、标识符、字面量、特殊符号；
- **语法分析**
    - 得到语言结构并以树的形式表示；
- **语义分析**
    - 考察结构正确的句子是否语义合法，修改树结构；
- **中间代码生成**（可选）
    - 生成一种既接近目标语言，又与具体机器无关的表示，便于优化与代码生成；
        （到目前为止，编译器与解释器可以一致）
- **中间代码优化**（可选）
    - 局部优化、循环优化、全局优化等；优化实际上是一个等价变换，变换前后的指令序列完成同样的功能，但在占用的空间上和程序执行的时间上都更省、更有效。
- **目标代码生成**
    - 不同形式的目标代码－汇编、可重定位、内存形式（Load-and-Go）;
- **符号表管理**
    - 合理组织符号，便于各阶段查找、填写等；
- **出错处理**
    - 错误的种类－词法错、语法错、静态语义错、动态语义错。



<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308083443092.png" alt="image-20220308083443092" style="zoom:67%;" />

####  编译程序的结构

![image-20220308092524454](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308092524454.png)

**出错处理主要的三个错误**

- 词法错误
- 语法错误
- 语义错误

**表格管理程序**
负责收集记录查询编译当中所缺的信息，像常量表、符号表、数组信息表。

#### 编译阶段的组合

有时把编译的过程分为前端和后端

|      | 阶段                                           |
| ---- | ---------------------------------------------- |
| 前端 | 词法分析、语法分析、语义分析、中间代码生成阶段 |
| 后端 | 目标代码生成、相关出错处理、符号表操作         |

<img src="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308083611420.png" alt="image-20220308083611420" style="zoom: 50%;" />

### 理解编译过程

