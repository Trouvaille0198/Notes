---
title: "设计模式"
date: 2022-04-02
draft: true
author: "MelonCholi"
tags: []
categories: [专业课]
---

# 设计模式

## 六大原则

### 开闭原则

（Open Close Principle）

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

### 里氏代换原则

（Liskov Substitution Principle）

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

### 依赖倒转原则

（Dependence Inversion Principle）

这个是开闭原则的基础，具体内容：是对接口编程，依赖于抽象而不依赖于具体。

### 接口隔离原则

（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

### 迪米特法则

（最少知道原则）（Demeter Principle）

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

### 合成复用原则

（Composite Reuse Principle）

原则是尽量使用合成/聚合的方式，而不是使用继承。

## 创建型模式

这类模式提供创建对象的机制， 能够提升已有代码的灵活性和可复用性。

### 简单工厂模式

（Simple Factory）

> 严格来说，简单工厂模式不是 GoF 总结出来的 23 种设计模式之一。

**简单工厂方法模式在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。**

工厂方法返回的对象通常被称作 “**产品**”。

所有产品都必须使用同一接口。

在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。

#### 适用场景

1. 当一个类不知道它所必须创建的对象的类的时候。
2. 当一个类希望由它的子类来指定它所创建的对象的时候。
3. 当类将创建对象的职责委托给多个子类中的某一个。

#### 实现方式

1. 创建所有产品的弗雷，使所有产品都**遵循同一接口**。 该接口必须声明对所有产品都有意义的方法。
2. 添加一个**空的工厂方法**。 该方法的返回类型必须遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。 将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。
4. 你可能需要在工厂方法中添加临时参数（比如一个代表产品名的字符串）来控制返回的产品类型。
5. 工厂方法的代码看上去可能非常糟糕。 其中可能会有复杂的 `switch` 分支运算符， 用于选择各种需要实例化的产品类。 我们将在**工厂模式**中修复这个问题。

#### 示例

##### Python

```python
class Shape(object):
    '''
    父类
    '''
    def draw(self):
        raise NotImplementedError
 
class Circle(Shape):
    '''
    Shape子类
    '''
    def draw(self):
        print('draw circle')
 
class Rectangle(Shape):
    '''
    Shape的子类
    '''
    def draw(self):
        print('draw Rectangle')
 
class ShapeFactory(object):
    '''
    工厂模式：暴露给用户去调用的，
    用户可通过该类进行选择Shape的子类进行实例化
    '''
    def create(self, shape):
        if shape == 'Circle':
            return Circle()
        elif shape == 'Rectangle':
            return Rectangle()
        else:
            return None
 
fac = ShapeFactory() #实例化工厂类
obj = fac.create('Circle') #实例化Shape的Circle子类
obj.draw()
```

- Shape（父类 or 基类）：提取出所有子类的重复方法代码**作为接口**
- Circle（Shape 子类 or 派生类）：作用为画圆形
- Rectangle（Shape 子类 or 派生类）：作用为画矩形
- ShapeFactory（新式类）：该类作用为用户可根据该类对象创建指定的 Shape 子类对象（Circle or Rectangle）

#### 特点

优点：客户端（调用时）不需要修改代码。

缺点： 当需要增加新的运算类的时候，不仅需新加运算类，还要修改工厂类，违反了开闭原则。

### 工厂方法模式

（Factory Method，虚拟构造函数，Virtual Constructor）

简单工厂模式只有一个工厂，工厂方法模式对每一个产品都有相应的工厂

工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。

- 首先完全实现‘开－闭 原则’，实现了可扩展。
- 其次更复杂的层次结构，可以应用于产品结果复杂的场合。 　　

工厂方法模式的对简单工厂模式进行了抽象。有一个抽象的 Factory 类（可以是抽象类和接口），这个类将不在负责具体的产品生产，而是只制定一些规范，具体的生产工作由其子类去完成。在这个模式中，工厂类和产品类往往可以依次对应。即**一个抽象工厂对应一个抽象产品，一个具体工厂对应一个具体产品，**这个具体的工厂就负责生产对应的产品。 　　

工厂方法模式是最典型的**模板方法模式**应用。

#### 适用场景

1. 当你在编写代码的过程中，如果无法预知对象确切类别及其依赖关系时，可使用工厂方法。
2. 如果你希望用户能扩展你软件库或框架的内部组件， 可使用工厂方法。
3. 如果你希望复用现有对象来节省系统资源， 而不是每次都重新创建对象， 可使用工厂方法。

#### 实现方式

1. 在简单工厂模式的基础上，为工厂方法中的每种产品编写一个创建者子类， 然后在子类中重写工厂方法， 并将基本方法中的相关创建代码移动到工厂方法中。

2. 如果应用中的产品类型太多， 那么为每个产品创建子类并无太大必要， 这时你也可以在子类中复用基类中的控制参数。

    例如， 设想你有以下一些层次结构的类。 基类 `邮件`及其子类 `航空邮件`和 `陆路邮件` ；  `运输`及其子类 `飞机`, `卡车`和 `火车` 。  `航空邮件`仅使用 `飞机`对象， 而 `陆路邮件`则会同时使用 `卡车`和 `火车`对象。 你可以编写一个新的子类 （例如 `火车邮件` ） 来处理这两种情况， 但是还有其他可选的方案。 客户端代码可以给 `陆路邮件`类传递一个参数， 用于控制其希望获得的产品。

3. 如果代码经过上述移动后， 基础工厂方法中已经没有任何代码， 你可以将其转变为抽象类。 如果基础工厂方法中还有其他语句， 你可以将其设置为该方法的默认行为。

#### 示例

##### Python

```python
class Shape(object):
    '''抽象产品'''
    def getShape(self):
        return self.shape_name
 
class Circle(Shape):
    def __init__(self):
        self.shape_name = "Circle"
        
    def draw(self):
        print('draw circle')
 
class Rectangle(Shape):
    def __init__(self):
        self.shape_name = "Retangle"
 
    def draw(self):
        print('draw Rectangle')
 
 
class ShapeFactory(object):
    '''抽象工厂'''
    def create(self):
        '''把要创建的工厂对象装配进来'''
        raise  NotImplementedError
 
class CircleFactory(ShapeFactory):
    def create(self):
        return Circle()
 
class RectangleFactory(ShapeFactory):
    def create(self):
        return Rectangle()
 
 
circle_factory = CircleFactory()
circle = circle_factory.create()
circle.getShape()
circle.draw()
 
rectangle_factory = RectangleFactory()
rectangle = rectangle_factory.create()
rectangle.draw()
```

#### 特点

优点：增加一个运算类（例如 N 次方类），只需要增加运算类和相对应的工厂，两个类，不需要修改工厂类。

缺点：增加运算类，会修改客户端代码，工厂方法**只是把简单工厂的内部逻辑判断移到了客户端进行**

### 抽象工厂模式

（Abstract Factory）

> 每一个模式都是针对一定问题的解决方案。

抽象工厂模式与工厂方法模式的最大区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。

![img](https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/20190204053344610.png)

假设一个子系统需要一些产品对象，而这些产品又属于一个以上的产品等级结构。那么为了将消费这些产品对象的责任和创建这些产品对象的责任分割开来，可以引进抽象工厂模式。这样的话，消费产品的一方不需要直接参与产品的创建工作，而只需要向一个公用的工厂接口请求所需要的产品。

抽象工厂模式可以创建出**分属于不同产品等级结构的一个产品族中的所有对象**。对应于每一个产品族都有一个具体工厂。而每一个具体工厂负责创建属于同一个产品族，但是分属于不同等级结构的产品。

通过使用抽象工厂模式，可以处理具有相同（或者相似）等级结构中的多个产品族中的产品对象的创建问题。

#### 适用场景

1. 如果代码需要与多个不同系列的相关产品交互， 但是由于无法提前获取相关信息， 或者出于对未来扩展性的考虑， 你不希望代码基于产品的具体类进行构建， 在这种情况下， 你可以使用抽象工厂。
2. 如果你有一个基于一组抽象方法的类， 且其主要功能因此变得不明确， 那么在这种情况下可以考虑使用抽象工厂模式。

#### 实现方式

1. 以不同的产品类型与产品变体为维度绘制矩阵。
2. 为所有产品声明抽象产品接口。 然后让所有具体产品类实现这些接口。
3. 声明抽象工厂接口， 并且在接口中为所有抽象产品提供一组构建方法。
4. 为每种产品变体实现一个具体工厂类。
5. 在应用程序中开发初始化代码。 该代码根据应用程序配置或当前环境， 对特定具体工厂类进行初始化。 然后将该工厂对象传递给所有需要创建产品的类。
6. 找出代码中所有对产品构造函数的直接调用， 将其替换为对工厂对象中相应构建方法的调用。

#### 示例

##### Python

```python
class AbstractFactory(object):
    computer_name = ''
    def createCpu(self):
        pass
    def createMainboard(self):
        pass
 
class IntelFactory(AbstractFactory):
    computer_name = 'Intel I7-series computer '
    def createCpu(self):
        return IntelCpu('I7-6500')
 
    def createMainboard(self):
        return IntelMainBoard('Intel-6000')
 
class AmdFactory(AbstractFactory):
    computer_name = 'Amd 4 computer '
 
    def createCpu(self):
        return AmdCpu('amd444')
 
    def createMainboard(self):
        return AmdMainBoard('AMD-4000')
 
class AbstractCpu(object):
    series_name = ''
    instructions = ''
    arch=''
 
class IntelCpu(AbstractCpu):
    def __init__(self,series):
        self.series_name = series
 
class AmdCpu(AbstractCpu):
    def __init__(self,series):
        self.series_name = series
 
class AbstractMainboard(object):
    series_name = ''
 
class IntelMainBoard(AbstractMainboard):
    def __init__(self,series):
        self.series_name = series
 
class AmdMainBoard(AbstractMainboard):
    def __init__(self,series):
        self.series_name = series
 

class ComputerEngineer(object):
 
    def makeComputer(self,factory_obj):
        self.prepareHardwares(factory_obj)
 
    def prepareHardwares(self,factory_obj):
        self.cpu = factory_obj.createCpu()
        self.mainboard = factory_obj.createMainboard()
 
        info = '''------- computer [%s] info:
    cpu: %s
    mainboard: %s
 -------- End --------
        '''% (factory_obj.computer_name,self.cpu.series_name,self.mainboard.series_name)
        print(info)
        
if __name__ == "__main__":
    engineer = ComputerEngineer()     # 装机工程师
 
    intel_factory = IntelFactory()    # intel工厂
    engineer.makeComputer(intel_factory)
 
    amd_factory = AmdFactory()        # adm工厂
    engineer.makeComputer(amd_factory)
```

#### 特点

优点

-  确保同一工厂生成的产品相互匹配。
-  避免客户端和具体产品代码的耦合。
-  *单一职责原则*。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
-  *开闭原则*。 向应用程序中引入新产品变体时， 你无需修改客户端代码。

缺点

- 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

### 建造者模式

（Builder，生成器模式）

## 结构型模式

这类模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

## 行为模式

这类模式负责对象间的高效沟通和职责委派。