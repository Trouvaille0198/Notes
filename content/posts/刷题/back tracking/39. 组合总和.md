---
title: "39. 组合总和"
date: 2022-03-24
draft: false
author: "MelonCholi"
tags: [算法,回溯, 组合]
categories: [刷题]
hiddenFromHomePage: true
---

# 39. 组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target`，找出 `candidates` 中可以使数字和为目标数 `target` 的 *所有* **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```

## DFS 回溯

注意到这是个**组合**问题，所以要用 `startIndex` 避免重复

```go
func combinationSum(candidates []int, target int) [][]int {
	res := make([][]int, 0)
	comb := make([]int, 0)
	var dfs func(sum, startIndex int)
	dfs = func(sum, startIndex int) {
		if sum == target {
			combCopy := make([]int, len(comb))
			copy(combCopy, comb)
			res = append(res, combCopy)
			return
		}
		if sum > target {
			return
		}
		for i := startIndex; i < len(candidates); i++ {
			comb = append(comb, candidates[i])
			dfs(sum+candidates[i], i)
			comb = comb[:len(comb)-1]
		}
	}
	dfs(0, 0)
	return res
}
```

