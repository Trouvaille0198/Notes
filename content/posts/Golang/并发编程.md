# 并发编程

## 认识

**进程**是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。

**线程**是进程的一个执行实体，是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。

**协程**拥有独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。

> 一个线程上可以跑多个协程，协程是轻量级的线程。

## Goroutine

goroutine 奉行**通过通信来共享内存，而不是共享内存来通信**

goroutine 的概念类似于线程，但 goroutine 是由 Go 的运行时（runtime）调度和管理的。Go 程序会智能地将 goroutine 中的任务合理地分配给每个 CPU。

### 启动

#### 单个 goroutine

```go
func hello() {
    fmt.Println("Hello Goroutine!")
}
func main() {
    go hello()
    fmt.Println("main goroutine done!")
}
```

执行结果：只打印了 main goroutine done!，并没有打印 Hello Goroutine!。

原因

- 在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine
- 当 main() 函数返回的时候该 goroutine 就结束了，所有在 main() 函数中启动的 goroutine 会一同结束
- 创建新的 goroutine 的时候需要花费一些时间，而此时 main 函数所在的 goroutine 是继续执行的

让 main() 等一等他的子协程

```go
func main() {
    go hello() // 启动另外一个goroutine去执行hello函数
    fmt.Println("main goroutine done!")
    time.Sleep(time.Second)
}
```

#### 多个 goroutine

这里使用了sync.WaitGroup 来实现 goroutine 的同步

```go
var wg sync.WaitGroup

func hello(i int) {
    defer wg.Done() // goroutine结束就登记-1
    fmt.Println("Hello Goroutine!", i)
}
func main() {

    for i := 0; i < 10; i++ {
        wg.Add(1) // 启动一个goroutine就登记+1
        go hello(i)
    }
    wg.Wait() // 等待所有登记的goroutine都结束
}
```

多次执行上面的代码，会发现每次打印的数字的顺序都不一致。这是因为 10 个 goroutine 是并发执行的，而goroutine 的调度是随机的。