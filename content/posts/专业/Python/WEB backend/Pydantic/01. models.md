---
title: pydantic models
date: 2022-11-22
author: MelonCholi
draft: false
tags: [Python, åç«¯, pydantic]
categories:
  - Python
date created: 24-04-10 09:58
date modified: 24-04-24 11:16
aliases: [models]
permalink: https://docs.pydantic.dev/dev/concepts/models/
---

# models

é€šè¿‡åˆ›å»ºä¸€ä¸ªç»§æ‰¿ `BaseModel` çš„å­ç±»ï¼ˆmodelï¼‰æ¥å®šä¹‰ä¸€ç±»å¯¹è±¡ï¼ˆdefining objectsï¼‰

æ¨¡å‹ï¼ˆmodelï¼‰å¯ä»¥æ˜¯å¼ºç±»å‹è¯­è¨€ä¸­çš„ç±»å‹ï¼ˆtypesï¼‰ï¼Œä¹Ÿå¯ä»¥æ˜¯ API æ¥å£ä¸­çš„å‚æ•°

æœªç»éªŒè¯çš„ raw data å¯ä»¥è¢«ä¼ å…¥ modelï¼Œmodel ä¼šæ ¹æ®è‡ªèº«çš„çš„å­—æ®µå®šä¹‰å¯¹ untrusted data è¿›è¡ŒéªŒè¯

> pydantic ä¸ä»…ä»…æ˜¯ä¸€ä¸ªéªŒè¯æ¨¡å—ï¼ˆvalidation libraryï¼‰ï¼Œæ›´æ˜¯ä¸€ä¸ªè§£ææ¨¡å—ï¼ˆparsing libraryï¼‰ï¼ŒéªŒè¯åªæä¾›å¯¹ä¼ å…¥æ•°æ®çš„ç±»å‹ä¸çº¦æŸï¼Œè€Œ pydantic å¯ä»¥ä¿è¯ä¼ å‡ºæ•°æ®çš„ç±»å‹ä¸çº¦æŸéƒ½æ˜¯ç¬¦åˆè§„åˆ™çš„ã€‚
>
> *pydantic* is primarily a parsing library, **not a validation library**. Validation is a means to an end: building a model which conforms to the types and constraints provided.
>
> In other words, *pydantic* guarantees the types and constraints of the output model, not the input data

## åŸºç¡€ä½¿ç”¨

```python
from pydantic import BaseModel

class User(BaseModel):
    id: int
    name = 'Jane Doe' # has default value, not required then
```

`name` å­—æ®µçš„ç±»å‹è¢«å®ƒçš„é»˜è®¤å€¼æ‰€æŒ‡å‡ºï¼Œæ‰€ä»¥å°±ä¸ç”¨æ˜¾å¼åœ°å®šä¹‰äº†

```python
user = User(id='123') # str was cast to an int
user_x = User(id='123.45') # float was cast to an int
```

èªæ˜çš„å®ä¾‹åŒ–

```python
assert user.__fields_set__ == {'id'}
```

`__fields_set__` æŒ‡å‡ºäº†åœ¨å®ä¾‹åŒ–æ—¶ä¼ å…¥çš„å­—æ®µ

`<model>.dict()` å’Œ `dict(<model>)` èƒ½å°† model è½¬æ¢ä¸ºå­—å…¸ï¼›ä¸è¿‡ `<model>.dict()` å¯èƒ½ä¼šåŒ…å«ä¸€äº›å…¶ä»–æ•°æ®ï¼ˆæ¯”å¦‚é€’å½’è§£æå‡ºåµŒå¥—çš„ dict å­—æ®µï¼‰

## model å¸¸ç”¨çš„æ–¹æ³•ä¸å±æ€§

å±æ€§

- ==`model_fields`==
    - model å®šä¹‰å­—æ®µçš„é›†åˆ
- `model_computed_fields`
	- model çš„è®¡ç®—å±æ€§ dict
- `model_fields_set`
	- model å®ä¾‹åŒ–æ—¶ä¼ å…¥çš„å­—æ®µ

æ–¹æ³•

- `model_dump()`
    - è¿”å›å­—å…¸
    - åŸæ¥çš„ `dict()` å·²å¼ƒç”¨
- `model_dump_json()`
    - è¿”å› json å­—ç¬¦ä¸²
- `model_copy()`
    - è¿”å›æ‹·è´ï¼ˆé»˜è®¤æµ…æ‹·è´ shallow copyï¼‰
- ==`model_validate()`==
    - æ›¾ç”¨ `parse_obj()`
    - class methodï¼Œå°†ä¸€ä¸ª dict è½¬æ¢ä¸º model çš„æ–¹æ³•
- `model_validate_json()`
    - æ›¾ç”¨ `parse_raw()`
    - class methodï¼Œå°†å­—ç¬¦ä¸²è½¬æ¢ä¸º model çš„æ–¹æ³•
- `model_construct()`
    - class methodï¼Œç”Ÿæˆä¸€ä¸ªè·³è¿‡æ ¡éªŒçš„å®ä¾‹

## åµŒå¥— model

```python
from typing import Optional
from pydantic import BaseModel


class Foo(BaseModel):
    count: int
    size: Optional[float] = None


class Bar(BaseModel):
    apple = 'x'
    banana = 'y'


class Spam(BaseModel):
    foo: Foo
    bars: list[Bar]


m = Spam(foo={'count': 4}, bars=[{'apple': 'x1'}, {'apple': 'x2'}])
print(m)
#> foo=Foo(count=4, size=None) bars=[Bar(apple='x1', banana='y'),
#> Bar(apple='x2', banana='y')]
print(m.dict())
"""
{
    'foo': {'count': 4, 'size': None},
    'bars': [
        {'apple': 'x1', 'banana': 'y'},
        {'apple': 'x2', 'banana': 'y'},
    ],
}
"""
```

## ORM Mode

models æ”¯æŒ ORM æ¨¡å¼

```python
from typing import List

from sqlalchemy import Column, Integer, String
from sqlalchemy.dialects.postgresql import ARRAY
from sqlalchemy.orm import declarative_base
from typing_extensions import Annotated

from pydantic import BaseModel, ConfigDict, StringConstraints

Base = declarative_base()


class CompanyOrm(Base):
    __tablename__ = 'companies'

    id = Column(Integer, primary_key=True, nullable=False)
    public_key = Column(String(20), index=True, nullable=False, unique=True)
    name = Column(String(63), unique=True)
    domains = Column(ARRAY(String(255)))


class CompanyModel(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    id: int
    public_key: Annotated[str, StringConstraints(max_length=20)]
    name: Annotated[str, StringConstraints(max_length=63)]
    domains: List[Annotated[str, StringConstraints(max_length=255)]]


co_orm = CompanyOrm(
    id=123,
    public_key='foobar',
    name='Testing',
    domains=['example.com', 'foobar.com'],
)
print(co_orm)
#> <__main__.CompanyOrm object at 0x0123456789ab>
co_model = CompanyModel.model_validate(co_orm)
print(co_model)
"""
id=123 public_key='foobar' name='Testing' domains=['example.com', 'foobar.com']
"""
```

è¦ç‚¹

- `Config` å±æ€§ `orm_mode` å¿…é¡»ä¸º `True`
- ä½¿ç”¨ `.from_orm()` ç±»æ–¹æ³•æ¥åˆ›å»º model

### ä¿ç•™å­—

You may want to name aÂ `Column`Â after a reserved SQLAlchemy field. In that case,Â `Field`Â aliases will be convenient:

```python
import typing

import sqlalchemy as sa
from sqlalchemy.orm import declarative_base

from pydantic import BaseModel, ConfigDict, Field


class MyModel(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    metadata: typing.Dict[str, str] = Field(alias='metadata_')


Base = declarative_base()


class SQLModel(Base):
    __tablename__ = 'my_table'
    id = sa.Column('id', sa.Integer, primary_key=True)
    # 'metadata' is reserved by SQLAlchemy, hence the '_'
    metadata_ = sa.Column('metadata', sa.JSON)


sql_model = SQLModel(metadata_={'key': 'val'}, id=1)

pydantic_model = MyModel.model_validate(sql_model)

print(pydantic_model.model_dump())
#> {'metadata': {'key': 'val'}}
print(pydantic_model.model_dump(by_alias=True))
#> {'metadata_': {'key': 'val'}}
```

### åµŒå¥—çš„å±æ€§

When using attributes to parse models, model instances will be created from both top-level attributes and deeper-nested attributes as appropriate.

```python
from typing import List

from pydantic import BaseModel, ConfigDict


class PetCls:
    def __init__(self, *, name: str, species: str):
        self.name = name
        self.species = species


class PersonCls:
    def __init__(self, *, name: str, age: float = None, pets: List[PetCls]):
        self.name = name
        self.age = age
        self.pets = pets


class Pet(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    name: str
    species: str


class Person(BaseModel):
    model_config = ConfigDict(from_attributes=True)

    name: str
    age: float = None
    pets: List[Pet]


bones = PetCls(name='Bones', species='dog')
orion = PetCls(name='Orion', species='cat')
anna = PersonCls(name='Anna', age=20, pets=[bones, orion])
anna_model = Person.model_validate(anna)
print(anna_model)
"""
name='Anna' age=20.0 pets=[Pet(name='Bones', species='dog'), Pet(name='Orion', species='cat')]
"""
```

## é”™è¯¯å¤„ç†

æ ¡éªŒè¿‡ç¨‹ä¸­ï¼Œä¸€æ—¦å‡ºé”™ï¼Œpydantic å°†ä¼šæŠ›å‡º `ValidationError` é”™è¯¯

```python
from typing import List

from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    list_of_ints: List[int]
    a_float: float


data = dict(
    list_of_ints=['1', 2, 'bad'],
    a_float='not a float',
)

try:
    Model(**data)
except ValidationError as e:
    print(e)
    """
    2 validation errors for Model
    list_of_ints
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='bad', input_type=str]
    a_float
      Input should be a valid number, unable to parse string as a number [type=float_parsing, input_value='not a float', input_type=str]
    """

```

## è§£ææ•°æ®çš„è¾…åŠ©å‡½æ•°

pydantic ä¸º model æä¾›ä¸¤ä¸ª helper ç±»æ–¹æ³•ä¾›å…¶åœ¨ parsing data æ—¶ä½¿ç”¨

- `model_validate()`
	- è·Ÿ `__init__` æ–¹æ³•å¾ˆåƒï¼Œåªä¸è¿‡å®ƒæ¥æ”¶ä¸€ä¸ª dict è€Œä¸æ˜¯å…³é”®å­—å‚æ•°ï¼ˆè¯´å®è¯ï¼Œåœ¨ `__init__` é‡Œç”¨ `**kwargs` ä¼ å­—å…¸ä¹Ÿèƒ½èµ·åˆ°ç›¸åŒçš„ä½œç”¨ï¼‰
- `model_validate_json()`
	- str / bytes éƒ½èƒ½ä¼ ï¼Œå®ƒé¦–å…ˆä¼šè½¬æ¢æˆ jsonï¼Œç„¶åå†æŠŠ json ä¼ è¿› `model_validate()`

```python
from datetime import datetime
from typing import Optional

from pydantic import BaseModel, ValidationError


class User(BaseModel):
    id: int
    name: str = 'John Doe'
    signup_ts: Optional[datetime] = None


m = User.model_validate({'id': 123, 'name': 'James'})
print(m)
#> id=123 name='James' signup_ts=None

try:
    User.model_validate(['not', 'a', 'dict'])
except ValidationError as e:
    print(e)
    """
    1 validation error for User
      Input should be a valid dictionary or instance of User [type=model_type, input_value=['not', 'a', 'dict'], input_type=list]
    """

m = User.model_validate_json('{"id": 123, "name": "James"}')
print(m)
#> id=123 name='James' signup_ts=None

try:
    m = User.model_validate_json('{"id": 123, "name": 123}')
except ValidationError as e:
    print(e)
    """
    1 validation error for User
    name
      Input should be a valid string [type=string_type, input_value=123, input_type=int]
    """

try:
    m = User.model_validate_json('invalid JSON')
except ValidationError as e:
    print(e)
    """
    1 validation error for User
      Invalid JSON: expected value at line 1 column 1 [type=json_invalid, input_value='invalid JSON', input_type=str]
    """
```

å¦‚æœä½ æƒ³è½¬æ¢å…¶ä»–æ ¼å¼çš„æ•°æ®ï¼Œé‚£å…ˆæŠŠå®ƒè½¬æˆ dictï¼Œå†è°ƒç”¨ `model_validate()` ä¹ˆå¥½äº†

å¦‚æœä½ åœ¨ `model_validate()` é‡Œä¼ äº†ä¸€ä¸ª model å®ä¾‹ï¼Œé™¤éä½ è®¾ç½®äº† [`revalidate_instances`](https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict.revalidate_instances)ï¼Œå¦åˆ™ä¸ä¼šå†éªŒè¯ä¸€éäº†ï¼š

```python
from pydantic import BaseModel, ConfigDict, ValidationError


class Model(BaseModel):
    a: int

    model_config = ConfigDict(revalidate_instances='always')


m = Model(a=0)
# note: the `model_config` setting validate_assignment=True` can prevent this kind of misbehavior
m.a = 'not an int'

try:
    m2 = Model.model_validate(m)
except ValidationError as e:
    print(e)
    """
    1 validation error for Model
    a
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='not an int', input_type=str]
    """
```

### è·³è¿‡éªŒè¯ï¼Œåˆ›å»º model

 `construct()` æ–¹æ³•å…è®¸ä½ ä¸ç»éªŒè¯å°±åˆ›å»º modelï¼Œå½“ä¿¡æ¯æºç»å¯¹å¯é æ—¶ï¼Œè¿™æ ·åšå¯ä»¥æé«˜æ•ˆç‡ï¼ˆ==ä¸éªŒè¯æ¯”éªŒè¯å¿« 30 å€==ï¼‰

```python
from pydantic import BaseModel


class User(BaseModel):
    id: int
    age: int
    name: str = 'John Doe'


original_user = User(id=123, age=32)

user_data = original_user.model_dump()
print(user_data)
#> {'id': 123, 'age': 32, 'name': 'John Doe'}
fields_set = original_user.model_fields_set
print(fields_set)
#> {'age', 'id'}

# ...
# pass user_data and fields_set to RPC or save to the database etc.
# ...

# you can then create a new instance of User without
# re-running validation which would be unnecessary at this point:
new_user = User.model_construct(_fields_set=fields_set, **user_data)
print(repr(new_user))
#> User(id=123, age=32, name='John Doe')
print(new_user.model_fields_set)
#> {'age', 'id'}

# construct can be dangerous, only use it with validated data!:
bad_user = User.model_construct(id='dog')
print(repr(bad_user))
#> User(id='dog', name='John Doe')
```

`_fields_set` å‚æ•°æ˜¯å¯é€‰çš„ï¼Œå®ƒå¯ä»¥å‡†ç¡®åœ°åŒºåˆ†å‡º**ä¼ å…¥çš„**å’Œ**é»˜è®¤èµ‹å€¼çš„**å‚æ•°ï¼›å¦‚æœå®ƒè¢«å¿½ç•¥ï¼Œ`__fields_set__` å°±æ˜¯ä¼ å…¥çš„æ‰€æœ‰å­—æ®µäº†

For example, in the example above, ifÂ `_fields_set`Â was not provided,Â `new_user.model_fields_set`Â would beÂ `{'id', 'age', 'name'}`.

## Generic Models æ³›å‹ç±»

ä¸ºäº†æ–¹ä¾¿ model çš„å¤ç”¨ï¼Œpydantic æ”¯æŒåˆ›å»º generic models

æŒ‰ç…§ä»¥ä¸‹æ­¥éª¤å»åˆ›å»ºä¸€ä¸ª generic model

1. å£°æ˜ä¸€ä¸ªæˆ–å¤šä¸ª `typing.TypeVar` å®ä¾‹ï¼Œç”¨äºå‚æ•°åŒ–ä½ çš„ model
2. å£°æ˜ä¸€ä¸ªç»§æ‰¿è‡ª `pydantic.generics.GenericModel` å’Œ `typing.Generic` çš„ pydantic modelï¼Œå¹¶åœ¨å…¶ä¸­ä¼ å…¥ä½ åˆšåˆšå£°æ˜çš„ `typing.TypeVar` å®ä¾‹ä½œä¸º `typing.Generic` çš„å‚æ•°
3. åœ¨ä½ æƒ³è¦çš„å­—æ®µä¸Šï¼Œä½¿ç”¨ `typing.TypeVar` å®ä¾‹ä½œä¸ºæ ‡æ³¨

> Python 3.12 åº”è¯¥æ”¯æŒæ›´ç®€ä¾¿çš„æ³›å‹è¯­æ³•ï¼Œå¦‚ `class Response[T](BaseModel)`

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå¯å¤ç”¨çš„ HTTP å“åº”è´Ÿè½½å¤„ç†ç±»ï¼ˆeasily-reused HTTP response payload wrapperï¼‰çš„ä¾‹å­

```python
from typing import Generic, List, Optional, TypeVar

from pydantic import BaseModel, ValidationError

DataT = TypeVar('DataT')


class DataModel(BaseModel):
    numbers: List[int]
    people: List[str]


class Response(BaseModel, Generic[DataT]):
    data: Optional[DataT] = None


print(Response[int](data=1))
#> data=1
print(Response[str](data='value'))
#> data='value'
print(Response[str](data='value').model_dump())
#> {'data': 'value'}

data = DataModel(numbers=[1, 2, 3], people=[])
print(Response[DataModel](data=data).model_dump())
#> {'data': {'numbers': [1, 2, 3], 'people': []}}
try:
    Response[int](data='value')
except ValidationError as e:
    print(e)
    """
    1 validation error for Response[int]
    data
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='value', input_type=str]
    """
```

å¦‚æœåœ¨ generic model å®šä¹‰æ—¶è®¾ç½®äº† model_configï¼Œæˆ–è€…ç”¨äº† @field_validator ä»¥åŠå…¶ä»– Pydantic è£…é¥°å™¨ï¼Œå®ƒä»¬ä¹Ÿéœ€è¦è¢«æ³›å‹åŒ–

å¦‚æœè¦ç»§æ‰¿ä¸€ä¸ª GenericModel å¹¶ä¸”ä¸æ›¿æ¢ `TypeVar` å®ä¾‹çš„è¯ï¼Œè¿™ä¸ªå­—ç±»ä¹Ÿå¿…é¡»ç»§æ‰¿ä¸€ä¸ª `typing.Generic`

```python
from typing import Generic, TypeVar

from pydantic import BaseModel

TypeX = TypeVar('TypeX')


class BaseClass(BaseModel, Generic[TypeX]):
    X: TypeX


class ChildClass(BaseClass[TypeX], Generic[TypeX]):
    # Inherit from Generic[TypeX]
    pass


# Replace TypeX by int
print(ChildClass[int](X=1))
#> X=1
```

å½“ç„¶ï¼Œå¯ä»¥éƒ¨åˆ†ç»§æ‰¿çˆ¶ç±»çš„ `TypeVar` å®ä¾‹ï¼Œä¹Ÿå¯ä»¥æ–°å¢ `TypeVar` å®ä¾‹

```python
from typing import Generic, TypeVar

from pydantic import BaseModel

TypeX = TypeVar('TypeX')
TypeY = TypeVar('TypeY')
TypeZ = TypeVar('TypeZ')


class BaseClass(BaseModel, Generic[TypeX, TypeY]):
    x: TypeX
    y: TypeY


class ChildClass(BaseClass[int, TypeY], Generic[TypeY, TypeZ]):
    z: TypeZ


# Replace TypeY by str
print(ChildClass[str, int](x='1', y='y', z='3'))
#> x=1 y='y' z=3
```

ç”šè‡³å¯ä»¥è‡ªå®šä¹‰æ³›å‹å®ä¾‹åŒ–åçš„åå­— QAQ

```python
from typing import Any, Generic, Tuple, Type, TypeVar

from pydantic import BaseModel

DataT = TypeVar('DataT')


class Response(BaseModel, Generic[DataT]):
    data: DataT

    @classmethod
    def model_parametrized_name(cls, params: Tuple[Type[Any], ...]) -> str:
        return f'{params[0].__name__.title()}Response'


print(repr(Response[int](data=1)))
#> IntResponse(data=1)
print(repr(Response[str](data='a')))
#> StrResponse(data='a')
```

å½“ç„¶ï¼Œå¯ä»¥å°†æ³›å‹ model åµŒå¥—è¿›å…¶ä»– model ä¸­å»

```python
from typing import Generic, TypeVar

from pydantic import BaseModel

T = TypeVar('T')


class ResponseModel(BaseModel, Generic[T]):
    content: T


class Product(BaseModel):
    name: str
    price: float


class Order(BaseModel):
    id: int
    product: ResponseModel[Product]


product = Product(name='Apple', price=0.5)
response = ResponseModel[Product](content=product)
order = Order(id=1, product=response)
print(repr(order))
"""
Order(id=1, product=ResponseModel[Product](content=Product(name='Apple', price=0.5)))
"""
```

åœ¨åµŒå¥— model ä¸­ä½¿ç”¨ç›¸åŒçš„ `TypeVar` å®ä¾‹å¯ä»¥ä¿è¯ä¸€è‡´æ€§

```python
from typing import Generic, TypeVar

from pydantic import BaseModel, ValidationError

T = TypeVar('T')


class InnerT(BaseModel, Generic[T]):
    inner: T


class OuterT(BaseModel, Generic[T]):
    outer: T
    nested: InnerT[T]


nested = InnerT[int](inner=1)
print(OuterT[int](outer=1, nested=nested))
#> outer=1 nested=InnerT[int](inner=1)
try:
    nested = InnerT[str](inner='a')
    print(OuterT[int](outer='a', nested=nested))
except ValidationError as e:
    print(e)
    """
    2 validation errors for OuterT[int]
    outer
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]
    nested
      Input should be a valid dictionary or instance of InnerT[int] [type=model_type, input_value=InnerT[str](inner='a'), input_type=InnerT[str]]
    """
```

ä¸é‚£äº›å†…ç½®ç±»å‹ï¼ˆå¦‚ `List` å’Œ `Dict`ï¼‰ç±»ä¼¼ï¼ŒGenericModel çš„è¡Œä¸ºä¼šè¢«ä»¥ä¸‹è§„å®šæ‰€å®šä¹‰ï¼š

- å¦‚æœåœ¨å®ä¾‹åŒ–ï¼ˆinstantiateï¼‰ generic model ä¹‹å‰æ²¡æœ‰è¢«æŒ‡å®šç±»å‹ï¼ˆspecify parametersï¼‰ä¹‹å‰ï¼Œä¼ å‚ä¼šè¢«è§†ä¸º `Any` ç±»å‹
- å¦‚æœ `TypeVar` æœªè®¾ç½®ä»»ä½•ä¸Šé™ï¼ˆboundsï¼‰ï¼Œä¼ å‚ä¼šè¢«è§†ä¸º `Any` ç±»å‹

ç±»ä¼¼äº `List` å’Œ `Dict`ï¼Œä»»ä½•ä½¿ç”¨ `TypeVar` ä¼ å…¥ model çš„å‚æ•°éƒ½èƒ½è¢«æ›´å…·ä½“çš„ç±»å‹æ›¿æ¢

```python
from typing import Generic, TypeVar

from pydantic import BaseModel, ValidationError

AT = TypeVar('AT')
BT = TypeVar('BT')


class Model(BaseModel, Generic[AT, BT]):
    a: AT
    b: BT


print(Model(a='a', b='a'))
#> a='a' b='a'

IntT = TypeVar('IntT', bound=int)
typevar_model = Model[int, IntT]
print(typevar_model(a=1, b=1))
#> a=1 b=1
try:
    typevar_model(a='a', b='a')
except ValidationError as exc:
    print(exc)
    """
    2 validation errors for Model[int, TypeVar]
    a
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]
    b
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]
    """

concrete_model = typevar_model[int]
print(concrete_model(a=1, b=1))
#> a=1 b=1
```

## åŠ¨æ€å®šä¹‰ model

æœ‰äº›æ—¶å€™ï¼Œmodel çš„å®šä¹‰ç›´åˆ°ç¨‹åºè¿è¡Œæ—¶æ‰ä¼šå®Œæ•´ï¼Œpydantic æä¾› `create_model` æ–¹æ³•ï¼Œå…è®¸ model åœ¨è¿è¡Œæ—¶è¢«å®šä¹‰

```python
from pydantic import BaseModel, create_model

DynamicFoobarModel = create_model('DynamicFoobarModel', foo=(str, ...), bar=123)

# same as below
class StaticFoobarModel(BaseModel):
    foo: str
    bar: int = 123
```

`StaticFoobarModel` å’Œ `DynamicFoobarModel` åœ¨è¿™é‡Œæ˜¯å®Œå…¨ä¸€æ ·çš„

åŠ¨æ€ model å­—æ®µçš„å®šä¹‰ï¼Œä»¥ä¸‹å‡ ç§å‡å¯ï¼š

- `(<type>, <default value>)` çš„å…ƒç»„æ ¼å¼
- `(<type>, Field(...))` çš„å…ƒç»„æ ¼å¼
- `typing.Annotated[<type>, Field(...)]`

 `__config__` å’Œ `__base__` è¿™ä¸¤ä¸ªç‰¹æ®Šå‚æ•°å¯ä»¥ç”¨æ¥è‡ªå®šä¹‰ modelï¼Œæ¯”å¦‚æ·»åŠ é¢å¤–å­—æ®µæ¥æ‰©å±•å·²æœ‰çš„ model ä¹‹ç±»çš„

```python
from pydantic import BaseModel, create_model


class FooModel(BaseModel):
    foo: str
    bar: int = 123


BarModel = create_model(
    'BarModel',
    apple=(str, 'russet'),
    banana=(str, 'yellow'),
    __base__=FooModel,
)
print(BarModel)
#> <class '__main__.BarModel'>
print(BarModel.model_fields.keys())
#> dict_keys(['foo', 'bar', 'apple', 'banana'])
```

ä½ ç”šè‡³è¿˜èƒ½åœ¨ `__validators__` å‚æ•°ä¸­ä¼ å…¥å­—å…¸æ¥å®ç° validator çš„åŠŸèƒ½ï¼ˆéœ‡æƒŠï¼‰

```python
from pydantic import ValidationError, create_model, field_validator


def username_alphanumeric(cls, v):
    assert v.isalnum(), 'must be alphanumeric'
    return v


validators = {
    'username_validator': field_validator('username')(username_alphanumeric)
    # ...
}

UserModel = create_model(
    'UserModel', username=(str, ...), __validators__=validators
)

user = UserModel(username='scolvin')
print(user)
#> username='scolvin'

try:
    UserModel(username='scolvi%n')
except ValidationError as e:
    print(e)
    """
    1 validation error for UserModel
    username
      Assertion failed, must be alphanumeric [type=assertion_error, input_value='scolvi%n', input_type=str]
    """
```

## è‡ªå®šä¹‰æ ¹ç±»å‹ä¸ `RootModel`

é€šè¿‡ç»§æ‰¿ `RootModel` å­—æ®µï¼ŒPydantic models å¯ä»¥è¢«å®šä¹‰ä¸ºä¸€ä¸ªæ ¹ç±»å‹ï¼ˆcustom root typeï¼‰

æ ¹ç±»å‹å¯ä»¥æ˜¯ä»»ä½• pydantic æ”¯æŒçš„ç±»å‹ï¼Œè¢« `RootModel` çš„ç±»å‹æ‰€æŒ‡å®š

```python
from typing import Dict, List

from pydantic import RootModel

Pets = RootModel[List[str]]
PetsByName = RootModel[Dict[str, str]]


print(Pets(['dog', 'cat']))
#> root=['dog', 'cat']
print(Pets(['dog', 'cat']).model_dump_json())
#> ["dog","cat"]
print(Pets.model_validate(['dog', 'cat']))
#> root=['dog', 'cat']
print(Pets.model_json_schema())
"""
{'items': {'type': 'string'}, 'title': 'RootModel[List[str]]', 'type': 'array'}
"""

print(PetsByName({'Otis': 'dog', 'Milo': 'cat'}))
#> root={'Otis': 'dog', 'Milo': 'cat'}
print(PetsByName({'Otis': 'dog', 'Milo': 'cat'}).model_dump_json())
#> {"Otis":"dog","Milo":"cat"}
print(PetsByName.model_validate({'Otis': 'dog', 'Milo': 'cat'}))
#> root={'Otis': 'dog', 'Milo': 'cat'}
"""
```

å½“ç„¶ï¼Œæ”¯æŒå®ç° `__iter__`Â å’ŒÂ `__getitem__` æ–¹æ³•ï¼Œè¿™ä¸ªæ—¶å€™å°±è¦ç”¨åˆ°ä¼ ç»Ÿè€Œæ­£ç»çš„å†™æ³•ï¼š

 ```python
from typing import List

from pydantic import RootModel


class Pets(RootModel):
    root: List[str]

    def __iter__(self):
        return iter(self.root)

    def __getitem__(self, item):
        return self.root[item]


pets = Pets.model_validate(['dog', 'cat'])
print(pets[0])
#> dog
print([pet for pet in pets])
#> ['dog', 'cat']
 ```

å½“ç„¶å½“ç„¶ï¼Œç›´æ¥ç»§æ‰¿ä¸€ä¸ªæŒ‡å®šç±»å‹çš„ `RootModel` çš„å†™æ³•ä¹Ÿæ˜¯åˆæ³•çš„ï¼š

```python
from typing import List

from pydantic import RootModel


class Pets(RootModel[List[str]]):
    def describe(self) -> str:
        return f'Pets: {", ".join(self.root)}'


my_pets = Pets.model_validate(['dog', 'cat'])

print(my_pets.describe())
#> Pets: dog, cat
```

> Calling the `parse_obj` method on a dict with the single key `"__root__"` for non-mapping custom root types is currently supported for backwards compatibility, but is not recommended and may be dropped in a future version.

å¦‚æœä½ æƒ³è¦ç›´æ¥å–åˆ° `__root__` å­—æ®µä¸­çš„å€¼ï¼Œæˆ–æ˜¯æƒ³è¦è¿­ä»£ä¹‹ï¼Œä½ å¯ä»¥å®ç°å¯¹åº”çš„ `__iter__` å’Œ `__getitem__`

```python
from pydantic import BaseModel


class Pets(BaseModel):
    __root__: list[str]

    def __iter__(self):
        return iter(self.__root__)

    def __getitem__(self, item):
        return self.__root__[item]


pets = Pets.parse_obj(['dog', 'cat'])
print(pets[0])
#> dog
print([pet for pet in pets])
#> ['dog', 'cat']
```

## â€œè™šå‡â€ çš„ä¸å¯å˜æ€§è´¨

è®¾ç½® `model_config['frozen'] = True` å¯ä»¥è®© model ä¸å¯å˜ï¼Œæ‰€æœ‰å¯¹å…¶å€¼çš„ä¿®æ”¹éƒ½ä¼šæŠ›å‡ºé”™è¯¯

```python
from pydantic import BaseModel, ConfigDict, ValidationError


class FooBarModel(BaseModel):
    model_config = ConfigDict(frozen=True)

    a: str
    b: dict


foobar = FooBarModel(a='hello', b={'apple': 'pear'})

try:
    foobar.a = 'different'
except ValidationError as e:
    print(e)
    """
    1 validation error for FooBarModel
    a
      Instance is frozen [type=frozen_instance, input_value='different', input_type=str]
    """

print(foobar.a)
#> hello
print(foobar.b)
#> {'apple': 'pear'}
foobar.b['apple'] = 'grape'
print(foobar.b)
#> {'apple': 'grape'}
```

a ä¸èƒ½å˜ï¼Œä½†æ˜¯å­—å…¸ç±»å‹çš„ b æ˜¯å¯ä»¥å˜çš„å“¦~

> é†’é†’å§ï¼Œéƒ½æ˜¯å‡çš„ï¼ŒPython é‡Œä»æ¥æ²¡æœ‰ä¸¥æ ¼çš„ä¸å¯å˜æ€§
> Immutability in Python is never strict. If developers are determined/stupid they can always modify a so-called "immutable" object.

## ç»§æ‰¿è‡ªæŠ½è±¡åŸºç±» ABC

model èƒ½è·ŸæŠ½è±¡åŸºç±»ï¼ˆAbstract Base Classesï¼ŒABCï¼‰ä¸€èµ·ä½¿ç”¨

```python
import abc

from pydantic import BaseModel


class FooBarModel(BaseModel, abc.ABC):
    a: str
    b: int

    @abc.abstractmethod
    def my_abstract_method(self):
        pass
```

## å­—æ®µé¡ºåº

å­—æ®µé¡ºåºæ˜¯éå¸¸é‡è¦çš„ï¼š

- æ ¡éªŒæ˜¯æŒ‰ç…§å­—æ®µé¡ºåºè¿›è¡Œçš„
- å­—æ®µé¡ºåºåœ¨ model schema ä¸­ä¿ç•™
- å­—æ®µé¡ºåºåœ¨æ ¡éªŒé”™è¯¯ä¸­ä¿ç•™
- å­—æ®µé¡ºåºåœ¨ `.model_dump()` and `.model_dump_json()` ä¸­ä¿ç•™

```python
from pydantic import BaseModel, ValidationError


class Model(BaseModel):
    a: int
    b: int = 2
    c: int = 1
    d: int = 0
    e: float


print(Model.model_fields.keys())
#> dict_keys(['a', 'b', 'c', 'd', 'e'])
m = Model(e=2, a=1)
print(m.model_dump())
#> {'a': 1, 'b': 2, 'c': 1, 'd': 0, 'e': 2.0}
try:
    Model(a='x', b='x', c='x', d='x', e='x')
except ValidationError as err:
    error_locations = [e['loc'] for e in err.errors()]

print(error_locations)
#> [('a',), ('b',), ('c',), ('d',), ('e',)]
```

> ä»ä¸Šé¢çš„ä¾‹å­å¯ä»¥çœ‹å‡ºï¼ŒæŠŠå¸¦æ³¨é‡Šå’Œä¸å¸¦æ³¨é‡Šçš„å­—æ®µæ··åœ¨ä¸€èµ·ï¼Œæœ‰æ—¶ä¼šé€ æˆæ„æƒ³ä¸åˆ°çš„ç»“æœï¼Œè¿™å…¶å®æ˜¯ Python çš„ç¼ºé™·
>
> å³ä½¿é»˜è®¤å€¼ä¹Ÿèƒ½è·Ÿç±»å‹æ ‡æ³¨ä¸€æ ·æ¥ä¿è¯é¡ºåºï¼Œæˆ‘ä»¬è¿˜æ˜¯å»ºè®®ç»™æ‰€æœ‰å­—æ®µéƒ½å¸¦ä¸Šç±»å‹æ ‡æ³¨

## å¿…å¡«å­—æ®µ

ç»™ä¸ªç±»å‹æ ‡æ³¨å°±èƒ½è®©ä¸€ä¸ªå­—æ®µå˜æˆå¿…è¦å­—æ®µï¼ˆrequired fieldsï¼‰ï¼Œæˆ–è€…åŠ ä¸ª `...` çœç•¥

```python
from pydantic import BaseModel, Field


class Model(BaseModel):
    a: int
    b: int = ...
    c: int = Field(..., alias='C')
```

ä»¥ä¸Šä¸‰ä¸ªå­—æ®µéƒ½æ˜¯å¿…å¡«çš„ã€‚ä¸è¿‡ï¼Œå•ç”¨çœç•¥ç¬¦å·æ˜¯ä¸è¢«æ¨èçš„ï¼Œè·Ÿ mypy ä¹Ÿä¸æ˜¯å¾ˆå¥‘åˆ

## å…·æœ‰ä¸å¯å“ˆå¸Œé»˜è®¤å€¼çš„å­—æ®µ

> Fields with non-hashable default values

Python ä¸­å¸¸è§çš„ä¸€ç±» Bug æ¥æºï¼Œæ˜¯ä½¿ç”¨å¯å˜å­—æ®µä¸ºé»˜è®¤å€¼ï¼Œç„¶ååœ¨æ¯æ¬¡è°ƒç”¨æ—¶éƒ½é™„ä¸Šäº†æ–°å€¼ã€‚ã€‚ã€‚

TheÂ `dataclasses`Â module actually raises an error in this case, indicating that you should use theÂ `default_factory`Â argument toÂ `dataclasses.field`.

å½“ç„¶ Pydantic åŒæ ·æ”¯æŒä½¿ç”¨ `default_factory` æ¥å¤„ç†è¿™äº›å¯å˜çš„é»˜è®¤å€¼ï¼Œä½†è¿™å¹¶ä¸æ˜¯å¿…è¦çš„ï¼å› ä¸º Pydantic ä¼šè‡ªåŠ¨å°†å®ƒä»¬ä½œæ·±æ‹·è´å¤„ç†

```python
from typing import Dict, List

from pydantic import BaseModel


class Model(BaseModel):
    item_counts: List[Dict[str, int]] = [{}]


m1 = Model()
m1.item_counts[0]['a'] = 1
print(m1.item_counts)
#> [{'a': 1}]

m2 = Model()
print(m2.item_counts)
#> [{}]
```

ç‰›çš„

## æ‹¥æœ‰åŠ¨æ€é»˜è®¤å€¼çš„å­—æ®µ

ä½¿ç”¨ `default_factory` æ¥åˆ›å»ºä¸€ä¸ªæ‹¥æœ‰åŠ¨æ€é»˜è®¤å€¼çš„å­—æ®µ

```python
from datetime import datetime, timezone
from uuid import UUID, uuid4

from pydantic import BaseModel, Field


def datetime_now() -> datetime:
    return datetime.now(timezone.utc)


class Model(BaseModel):
    uid: UUID = Field(default_factory=uuid4)
    updated: datetime = Field(default_factory=datetime_now)


m1 = Model()
m2 = Model()
assert m1.uid != m2.uid
```

## è‡ªåŠ¨æ’é™¤çš„å±æ€§

ä»¥ä¸‹åˆ’çº¿å¼€å¤´çš„ç±»å˜é‡ï¼ˆè¢«è§†ä¸ºç§æœ‰å±æ€§ï¼‰å’Œç±»å‹æ ‡æ³¨ä¸º `typing.ClassVar` çš„å±æ€§å°†è¢«è‡ªåŠ¨ä» model ä¸­æ’é™¤

```python
from typing import ClassVar

from pydantic import BaseModel


class Model(BaseModel):
    x: int = 2
    y: ClassVar[int] = 1


m = Model()
print(m)
#> x=2
print(Model.y)
#> 1
```

> As of Pydantic v2.1.0, you will receive a NameError if trying to use theÂ [`Field`Â function](https://docs.pydantic.dev/dev/concepts/fields/)Â with a private attribute. Because private attributes are not treated as fields, the Field() function cannot be applied.

å¦‚æœä½ æƒ³è¦ä¿®æ”¹æˆ–æ“ä½œ model å®ä¾‹çš„å†…éƒ¨å±æ€§ï¼Œä½¿ç”¨ `PrivateAttr` æ¥å£°æ˜ä¹‹

```python
from datetime import datetime
from random import randint

from pydantic import BaseModel, PrivateAttr


class TimeAwareModel(BaseModel):
    _processed_at: datetime = PrivateAttr(default_factory=datetime.now)
    _secret_value: str

    def __init__(self, **data):
        super().__init__(**data)
        # this could also be done with default_factory
        self._secret_value = randint(1, 5)


m = TimeAwareModel()
print(m._processed_at)
#> 2032-01-02 03:04:05.000006
print(m._secret_value)
#> 3
```

ç§æœ‰å±æ€§å¿…é¡»ä»¥ä¸‹åˆ’çº¿å¼€å¤´ï¼Œ`_attr` è¡Œï¼Œ `__attr__` ä¸è¡Œï¼

## æ•°æ®è½¬æ¢

pydantic å¯èƒ½ä¼šæ”¹å˜ input data ä»¥ä½¿å…¶é€šè¿‡ç±»å‹æ£€æŸ¥ï¼Œä½†æœ‰æ—¶å€™ï¼Œè¿™ç§è¡Œä¸ºå¯èƒ½ä¼šå¯¼è‡´ä¿¡æ¯çš„ä¸¢å¤±

```python
from pydantic import BaseModel


class Model(BaseModel):
    a: int
    b: float
    c: str


print(Model(a=3.000, b='2.72', c=b'binary data').model_dump())
#> {'a': 3, 'b': 2.72, 'c': 'binary data'}
```

è¿™ç§è¡Œä¸ºæ˜¯ pydantic ç»è¿‡æ·±æ€ç†Ÿè™‘ä¹‹åçš„ç»“æœï¼Œè€Œä¸”ä¸€èˆ¬æ¥è¯´ï¼Œè›®æœ‰ç”¨çš„

ä¸è¿‡ï¼Œä¸¥æ ¼çš„ç±»å‹æ£€æŸ¥ä¹Ÿæ˜¯æ”¯æŒçš„

## â¤â€ğŸ”¥ model ç­¾å

æ‰€æœ‰çš„ model éƒ½ä¼šæ ¹æ®å…¶å­—æ®µç”Ÿæˆç­¾åï¼ˆsignatureï¼‰

```python
import inspect

from pydantic import BaseModel, Field


class FooModel(BaseModel):
    id: int
    name: str = None
    description: str = 'Foo'
    apple: int = Field(alias='pear')


print(inspect.signature(FooModel))
#> (*, id: int, name: str = None, description: str = 'Foo', pear: int) -> None
```

ä¸€ä¸ªç²¾ç¡®çš„ç­¾åå¯¹äºåƒ `FastAPI` å’Œ `hypothesis` è¿™æ ·ç»å¸¸è¿›è¡Œå¯¹è±¡**è‡ªçœ**çš„åº“æ˜¯å¾ˆæœ‰ç”¨çš„

ç”Ÿæˆçš„ç­¾åä¹Ÿå°†éµå¾ªè‡ªå®šä¹‰çš„ `__init__` å‡½æ•°

```python
import inspect

from pydantic import BaseModel


class MyModel(BaseModel):
    id: int
    info: str = 'Foo'

    def __init__(self, id: int = 1, *, bar: str, **data) -> None:
        """My custom init!"""
        super().__init__(id=id, bar=bar, **data)


print(inspect.signature(MyModel))
#> (id: int = 1, *, bar: str, info: str = 'Foo') -> None
```

ä¸ºäº†è¢«ç­¾åæ”¶çº³ï¼Œå­—æ®µçš„åå­—ï¼ˆnameï¼‰æˆ–è€…åˆ«åï¼ˆaliasï¼‰å¿…é¡»æ˜¯ä¸€ä¸ªåˆæ³•çš„ python æ ‡è¯†ç¬¦ï¼Œpydantic ä¼šä¼˜å…ˆé€‰æ‹©åˆ«åï¼Œå½“åˆ«åä¸åˆæ³•æ—¶åˆ™ä¼šé€‰æ‹©åå­—

å¦‚æœä¸€ä¸ªå­—æ®µçš„åˆ«åå’Œåç§°éƒ½æ˜¯æ— æ•ˆçš„æ ‡è¯†ç¬¦ï¼Œé‚£å°†æ·»åŠ ä¸€ä¸ª `**data` å‚æ•°ã€‚ä¸è¿‡ï¼Œå¦‚æœ `model_config['extra'] == 'allow'`ï¼Œé‚£ä¹ˆ `**data` å‚æ•°å°†æ€»æ˜¯å‡ºç°åœ¨ç­¾åä¸­ã€‚

## ç»“æ„åŒ–æ¨¡å¼åŒ¹é…

model æ”¯æŒç»“æ„åŒ–æ¨¡å¼åŒ¹é…ï¼ˆstructural pattern matchingï¼‰ï¼Œè¿™æ˜¯ Python 3.10 çš„æ–°ç‰¹æ€§

```python
from pydantic import BaseModel


class Pet(BaseModel):
    name: str
    species: str


a = Pet(name='Bones', species='dog')

match a:
    # match `species` to 'dog', declare and initialize `dog_name`
    case Pet(species='dog', name=dog_name):
        print(f'{dog_name} is a dog')
#> Bones is a dog
    # default case
    case _:
        print('No dog matched')
```

> match-case è¯­å¥çœ‹èµ·æ¥åƒæ˜¯åˆ›å»ºäº†ä¸€ä¸ªå…¨æ–°çš„ modelï¼Œç„¶è€Œå¹¶æ²¡æœ‰
> ä»–åªæ˜¯ä¸€ä¸ªç”¨æ¥è·å–å±æ€§ã€æ¯”è¾ƒå®ƒã€å£°æ˜å®ƒã€åˆå§‹åŒ–å®ƒçš„è¯­æ³•ç³–

## å±æ€§å¤åˆ¶

ä¸€èˆ¬æ¥è¯´ï¼Œä¼ å…¥ model çš„å‚æ•°å±æ€§éƒ½ä¼šè¢«å¼ºåˆ¶å¤åˆ¶ä¸€ä»½ä»¥å®ŒæˆéªŒè¯å·¥ä½œ

ä¸‹é¢çš„ç¤ºä¾‹è¡¨æ˜ï¼Œä¸¤æ¬¡å®ä¾‹åŒ–çš„ model çš„ list id æ˜¯ä¸åŒçš„ï¼Œæ˜¯å› ä¸ºåœ¨ä¼ å‚æ—¶ arr_orig è¢«å¤åˆ¶äº†

```python
from typing import List

from pydantic import BaseModel


class C1:
    arr = []

    def __init__(self, in_arr):
        self.arr = in_arr


class C2(BaseModel):
    arr: List[int]


arr_orig = [1, 9, 10, 3]


c1 = C1(arr_orig)
c2 = C2(arr=arr_orig)
print('id(c1.arr) == id(c2.arr):', id(c1.arr) == id(c2.arr))
#> id(c1.arr) == id(c2.arr): False
```

æœ‰è¿™ä¹ˆä¸€äº›æƒ…å†µä¸‹ï¼Œå±æ€§ä¸ä¼šè¢«å¤åˆ¶ï¼Œæ¯”å¦‚ä¼ çš„å‚æ•°æ˜¯ä¸€ä¸ª model å®ä¾‹ï¼Œå› ä¸º model å‚æ•°é»˜è®¤ä¸ä¼šè¢«æ ¡éªŒã€‚ä¸è¿‡å¯ä»¥è®¾ç½® `model_config['revalidate_instances'] = 'always'` å¼ºåˆ¶æ ¡éªŒ model å‚æ•°å°±æ˜¯äº†ï¼‰

## é¢å¤–å­—æ®µ Extra fields

é»˜è®¤æƒ…å†µä¸‹ï¼Œå¦‚æœä¼ äº†ä¸€äº›é¢å¤–çš„å­—æ®µçš„è¯ï¼ŒPydantic æ ¡éªŒæ˜¯ä¸ä¼šå‡ºé”™çš„ï¼Œä»…å¿½ç•¥ä¹‹

```python
from pydantic import BaseModel


class Model(BaseModel):
    x: int


m = Model(x=1, y='a')
assert m.model_dump() == {'x': 1}
```

å½“ç„¶ï¼Œå¯ä»¥è®¾ç½®æˆæŠ¥é”™çš„

```python
from pydantic import BaseModel, ConfigDict, ValidationError


class Model(BaseModel):
    x: int

    model_config = ConfigDict(extra='forbid')


try:
    Model(x=1, y='a')
except ValidationError as exc:
    print(exc)
    """
    1 validation error for Model
    y
      Extra inputs are not permitted [type=extra_forbidden, input_value='a', input_type=str]
    """
```

è¿˜å¯ä»¥é€‰æ‹©ä¿ç•™è¿™äº›é¢å¤–çš„å­—æ®µï¼Œå­˜åˆ° `BaseModel.__pydantic_extra__` ä¸­

```python
from pydantic import BaseModel, ConfigDict


class Model(BaseModel):
    x: int

    model_config = ConfigDict(extra='allow')


m = Model(x=1, y='a')
assert m.__pydantic_extra__ == {'y': 'a'}
```

é»˜è®¤æƒ…å†µä¸‹ï¼Œå­˜åœ¨ `__pydantic_extra__` é‡Œçš„å­—æ®µä¸ä¼šè§¦å‘éªŒè¯ã€‚ä¸è¿‡ï¼Œä½ ç”šè‡³å¯ä»¥ç»™ `__pydantic_extra__` å®šä¹‰ç±»å‹ã€‚ã€‚ã€‚

```python
from typing import Dict

from pydantic import BaseModel, ConfigDict, ValidationError


class Model(BaseModel):
    __pydantic_extra__: Dict[str, int]

    x: int

    model_config = ConfigDict(extra='allow')


try:
    Model(x=1, y='a')
except ValidationError as exc:
    print(exc)
    """
    1 validation error for Model
    y
      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]
    """

m = Model(x=1, y='2')
assert m.x == 1
assert m.y == 2
assert m.model_dump() == {'x': 1, 'y': 2}
assert m.__pydantic_extra__ == {'y': 2}
```
