<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Git 教程 - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="Git 安装 设置名字、邮箱 1 2 git config --global user.name &#34;Your Name&#34; git config --global user.email &#34;email@example.com&#34; 查看名字、邮箱 1 2 git config user.name git config user.email 创建"><meta name=keywords content="Git,快速入门"><meta itemprop=name content="Git 教程"><meta itemprop=description content="Git 安装 设置名字、邮箱 1 2 git config --global user.name &#34;Your Name&#34; git config --global user.email &#34;email@example.com&#34; 查看名字、邮箱 1 2 git config user.name git config user.email 创建"><meta itemprop=datePublished content="2021-12-09T00:00:00+00:00"><meta itemprop=dateModified content="2023-06-14T09:56:49+00:00"><meta itemprop=wordCount content="9426"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="Git,快速入门,"><meta property="og:title" content="Git 教程"><meta property="og:description" content="Git 安装 设置名字、邮箱 1 2 git config --global user.name &#34;Your Name&#34; git config --global user.email &#34;email@example.com&#34; 查看名字、邮箱 1 2 git config user.name git config user.email 创建"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/git/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-09T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-14T09:56:49+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="Git 教程"><meta name=twitter:description content="Git 安装 设置名字、邮箱 1 2 git config --global user.name &#34;Your Name&#34; git config --global user.email &#34;email@example.com&#34; 查看名字、邮箱 1 2 git config user.name git config user.email 创建"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/git/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/mermaid/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/frontend/api-%E8%A7%84%E8%8C%83/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Git 教程","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/git\/"},"genre":"posts","keywords":"Git, 快速入门","wordcount":9426,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/git\/","datePublished":"2021-12-09T00:00:00+00:00","dateModified":"2023-06-14T09:56:49+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Git 教程</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/%E5%B7%A5%E5%85%B7/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;工具</a></span></div><div class=post-meta-line><span title="2021-12-09 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-12-09>2021-12-09</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 9426 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 19 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#安装>安装</a><ul><li><a href=#设置名字邮箱>设置名字、邮箱</a></li><li><a href=#创建版本库repository>创建版本库（<strong>repository</strong>）</a></li></ul></li><li><a href=#文件操作>文件操作</a><ul><li><a href=#添加文件>添加文件</a></li><li><a href=#查看信息>查看信息</a></li><li><a href=#修改文件>修改文件</a></li></ul></li><li><a href=#远程仓库操作>远程仓库操作</a><ul><li><a href=#创建ssh-key>创建SSH Key</a></li><li><a href=#关联远程仓库>关联远程仓库</a></li><li><a href=#初次推送>初次推送</a></li><li><a href=#将本地库推送至远程库>将本地库推送至远程库</a></li><li><a href=#将远程库克隆至本地库>将远程库克隆至本地库</a></li></ul></li><li><a href=#分支操作>分支操作</a><ul><li><a href=#创建并切换到新的分支>创建并切换到新的分支</a></li><li><a href=#创建新的分支>创建新的分支</a></li><li><a href=#切换到已有的分支>切换到已有的分支</a></li><li><a href=#查看分支>查看分支</a></li><li><a href=#合并某分支到当前分支>合并某分支到当前分支</a></li><li><a href=#删除分支>删除分支</a></li><li><a href=#查看分支的合并情况>查看分支的合并情况</a></li><li><a href=#分支策略>分支策略</a></li><li><a href=#暂存工作现场>暂存工作现场</a></li><li><a href=#查看暂存的工作现场>查看暂存的工作现场</a></li><li><a href=#恢复暂存现场>恢复暂存现场</a></li><li><a href=#复制一个特定的提交到当前分支>复制一个特定的提交到当前分支</a></li><li><a href=#整理分支>整理分支</a></li></ul></li><li><a href=#多人协作>多人协作</a><ul><li><a href=#查看远程库的信息>查看远程库的信息</a></li><li><a href=#推送分支>推送分支</a></li><li><a href=#在本地创建和远程分支对应的分支>在本地创建和远程分支对应的分支</a></li><li><a href=#将远程库最新的提交抓下来>将远程库最新的提交抓下来</a></li><li><a href=#主要步骤>主要步骤</a></li><li><a href=#fork-相关操作>fork 相关操作</a></li></ul></li><li><a href=#标签操作>标签操作</a><ul><li><a href=#创建标签>创建标签</a></li><li><a href=#查看标签>查看标签</a></li><li><a href=#查看标签详细信息>查看标签详细信息</a></li><li><a href=#删除标签>删除标签</a></li><li><a href=#推送标签至远程库>推送标签至远程库</a></li></ul></li><li><a href=#个性化>个性化</a><ul><li><a href=#显示更丰富的颜色>显示更丰富的颜色</a></li><li><a href=#配置别名>配置别名</a></li><li><a href=#忽略特殊文件>忽略特殊文件</a></li><li><a href=#删库跑路>删库跑路</a></li></ul></li><li><a href=#规范>规范</a><ul><li><a href=#gitflow>GitFlow</a><ul><li><a href=#分支命名规范>分支命名规范</a></li></ul></li><li><a href=#commit-规范>commit 规范</a></li></ul></li><li><a href=#git-命令补全配置>git 命令补全配置</a></li><li><a href=#git-rebase>git rebase</a><ul><li><a href=#例子>例子</a></li><li><a href=#解决冲突-conflict>解决冲突 CONFLICT</a></li><li><a href=#合并历史-commit>合并历史 commit</a></li></ul></li><li><a href=#git-checkout>git checkout</a><ul><li><a href=#基础>基础</a></li><li><a href=#深入>深入</a></li><li><a href=#拓展>拓展</a><ul><li><a href=#检出某文件>检出某文件</a></li><li><a href=#创建并切换分支>创建并切换分支</a></li><li><a href=#强制创建并覆盖原同名分支>强制创建并覆盖原同名分支</a></li><li><a href=#分出一个没有-commit-历史的干净分支>分出一个没有 commit 历史的干净分支</a></li><li><a href=#切换分支时带走修改的内容>切换分支时带走修改的内容</a></li><li><a href=#比较两个分支的差异>比较两个分支的差异</a></li></ul></li></ul></li><li><a href=#git-stash>git stash</a><ul><li><a href=#stash-当前修改>stash 当前修改</a></li><li><a href=#重新应用缓存的-stash>重新应用缓存的 stash</a></li><li><a href=#查看现有-stash>查看现有 stash</a></li><li><a href=#删除-stash>删除 stash</a></li><li><a href=#查看指定-stash-的-diff>查看指定 stash 的 diff</a></li><li><a href=#从-stash-创建分支>从 stash 创建分支</a></li><li><a href=#暂存指定文件>暂存指定文件</a></li><li><a href=#暂存未跟踪或忽略的文件>暂存未跟踪或忽略的文件</a></li></ul></li><li><a href=#git-cherry-pick>git cherry-pick</a><ul><li><a href=#基本用法>基本用法</a></li><li><a href=#转移多个提交>转移多个提交</a></li><li><a href=#配置项>配置项</a></li><li><a href=#代码冲突>代码冲突</a></li><li><a href=#转移到另一个代码库>转移到另一个代码库</a></li></ul></li><li><a href=#git-bundle>git bundle</a></li><li><a href=#其他>其他</a></li></ul></nav></div></div><div class=content id=content><h1 id=git>Git</h1><h2 id=安装>安装</h2><h3 id=设置名字邮箱>设置名字、邮箱</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git config --global user.name <span class=s2>&#34;Your Name&#34;</span>
</span></span><span class=line><span class=cl>git config --global user.email <span class=s2>&#34;email@example.com&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>查看名字、邮箱</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git config user.name
</span></span><span class=line><span class=cl>git config user.email
</span></span></code></pre></td></tr></table></div></div><h3 id=创建版本库repository>创建版本库（<strong>repository</strong>）</h3><ul><li>创建空目录</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir &lt;repo name&gt;
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> &lt;repo name&gt;
</span></span><span class=line><span class=cl>$ <span class=nb>pwd</span>
</span></span></code></pre></td></tr></table></div></div><p><code>pwd</code>命令用于显示当前目录</p><ul><li>把这个目录变成 Git 可以管理的仓库</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git init
</span></span></code></pre></td></tr></table></div></div><h2 id=文件操作>文件操作</h2><h3 id=添加文件>添加文件</h3><p>把文件往 Git 版本库里添加的时候，是分两步执行的：</p><p>第一步是用 <code>git add</code> 把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用 <code>git commit</code> 提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><ol><li>将工作区文件添加到暂存区</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git add &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>将暂存区文件添加到本地仓库</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git commit -m &lt;message&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=查看信息>查看信息</h3><ol><li>查看仓库当前状态</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git status
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>查看文件修改</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git diff &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><p>查看工作区和版本库里文件的区别</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git diff HEAD -- &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>查看文件内容</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><ol start=4><li>查看版本库状态</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git log
</span></span><span class=line><span class=cl>$ git log --pretty<span class=o>=</span>oneline //简单显示
</span></span></code></pre></td></tr></table></div></div><h3 id=修改文件>修改文件</h3><ol><li>退回上一版本</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset --hard HEAD^
</span></span></code></pre></td></tr></table></div></div><p>上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上 100 个版本写 100 个^比较容易数不过来，所以写成<code>HEAD~100</code></p><ol start=2><li>退回某一版本</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset --hard &lt;id&gt;
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>显示所有历史命令</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reflog
</span></span></code></pre></td></tr></table></div></div><ol start=4><li>清除工作区的修改</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout -- &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><p>实质：用版本库里的版本替换工作区的版本</p><ol start=5><li>清除暂存区的修改</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git reset HEAD &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><ol start=6><li>从工作区中删除文件</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>$ rm &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><ol start=7><li>从版本库中删除文件</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git rm &lt;filename&gt;
</span></span></code></pre></td></tr></table></div></div><p>别忘了<code>git commit</code></p><h2 id=远程仓库操作>远程仓库操作</h2><h3 id=创建ssh-key>创建SSH Key</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ssh-keygen -t rsa -C <span class=s2>&#34;youremail@example.com&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>可以在用户主目录里找到 <code>.ssh</code> 目录，里面有 <code>id_rsa</code> 和 <code>id_rsa.pub</code> 两个文件，这两个就是 SSH Key 的秘钥对，<code>id_rsa</code> 是私钥，不能泄露出去，<code>id_rsa.pub</code> 是公钥，可以放心地告诉任何人</p><h3 id=关联远程仓库>关联远程仓库</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote add origin git@github.com:GitHub-name/Repo-name.git
</span></span></code></pre></td></tr></table></div></div><h3 id=初次推送>初次推送</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push -u origin master
</span></span></code></pre></td></tr></table></div></div><h3 id=将本地库推送至远程库>将本地库推送至远程库</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push origin master
</span></span></code></pre></td></tr></table></div></div><p>若要强制推送覆盖远程文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push -f origin master
</span></span></code></pre></td></tr></table></div></div><h3 id=将远程库克隆至本地库>将远程库克隆至本地库</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git clone git@github.com:GitHub-name/Repo-name.git
</span></span></code></pre></td></tr></table></div></div><h2 id=分支操作>分支操作</h2><p>分支共有 5 种类型</p><ol><li>master/main，最终发布版本，整个项目中有且只有一个</li><li>develop，项目的开发分支，原则上项目中有且只有一个</li><li>feature，功能分支，用于开发一个新的功能</li><li>release，预发布版本，介于 develop 和 master 之间的一个版本，主要用于测试</li><li>hotfix，修复补丁，用于修复 master 上的 bug，直接作用于 master</li></ol><h3 id=创建并切换到新的分支>创建并切换到新的分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git switch -c &lt;name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=创建新的分支>创建新的分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch &lt;name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=切换到已有的分支>切换到已有的分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git switch &lt;name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=查看分支>查看分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch
</span></span></code></pre></td></tr></table></div></div><h3 id=合并某分支到当前分支>合并某分支到当前分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git merge &lt;name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=删除分支>删除分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch -d &lt;name&gt;
</span></span></code></pre></td></tr></table></div></div><p>若要强行删除</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch -D &lt;name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=查看分支的合并情况>查看分支的合并情况</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git log --graph --pretty<span class=o>=</span>oneline --abbrev-commit
</span></span></code></pre></td></tr></table></div></div><h3 id=分支策略>分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，master 分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在 dev 分支上，也就是说，dev 分支是不稳定的，到某个时候，比如 1.0 版本发布时，再把 dev 分支合并到 master 上，在 master 分支发布 1.0 版本；</p><p>你和你的小伙伴们每个人都在 dev 分支上干活，每个人都有自己的分支，时不时地往 dev 分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/111.png alt=111 style=zoom:150%><h3 id=暂存工作现场>暂存工作现场</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git stash
</span></span></code></pre></td></tr></table></div></div><h3 id=查看暂存的工作现场>查看暂存的工作现场</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git stash list
</span></span></code></pre></td></tr></table></div></div><h3 id=恢复暂存现场>恢复暂存现场</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git stash pop
</span></span></code></pre></td></tr></table></div></div><p>若要恢复指定的 stash</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git stash apply stash@<span class=o>{</span>0<span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=复制一个特定的提交到当前分支>复制一个特定的提交到当前分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git cherry-pick &lt;id&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=整理分支>整理分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git rebase
</span></span></code></pre></td></tr></table></div></div><p>rebase 操作可以把本地未 push 的分叉提交历史整理成直线；</p><p>rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比</p><h2 id=多人协作>多人协作</h2><h3 id=查看远程库的信息>查看远程库的信息</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote
</span></span></code></pre></td></tr></table></div></div><p>若要查看更详细的信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git remote -v
</span></span></code></pre></td></tr></table></div></div><h3 id=推送分支>推送分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push origin &lt;branch-name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=在本地创建和远程分支对应的分支>在本地创建和远程分支对应的分支</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git checkout -b &lt;branch-name&gt; origin/&lt;branch-name&gt;
</span></span></code></pre></td></tr></table></div></div><p>分支名字最好一样</p><h3 id=将远程库最新的提交抓下来>将远程库最新的提交抓下来</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git pull
</span></span></code></pre></td></tr></table></div></div><p>若提示 no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;
</span></span><span class=line><span class=cl>或
</span></span><span class=line><span class=cl>$ git pull origin &lt;branch-name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=主要步骤>主要步骤</h3><p>多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用<code>git push origin &lt;branch-name></code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name></code>推送就能成功！</p></li></ol><h3 id=fork-相关操作>fork 相关操作</h3><p>添加一个将被同步给 fork 远程的上游仓库</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git remote add upstream git@github.com:GitHub-name/Repo-name.git
</span></span></code></pre></td></tr></table></div></div><p>从上游仓库拉取更新</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git fetch upstream
</span></span></code></pre></td></tr></table></div></div><p>与自己的分支合并</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git merge upstream/master
</span></span></code></pre></td></tr></table></div></div><h2 id=标签操作>标签操作</h2><h3 id=创建标签>创建标签</h3><p>切换到需要打标签的分支上，然后用以下命令创建标签</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git tag &lt;tag-name&gt;
</span></span></code></pre></td></tr></table></div></div><p>若要根据 commit id 打标签</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git tag &lt;tag-name&gt; &lt;id&gt;
</span></span></code></pre></td></tr></table></div></div><p>若要创建带有说明的标签</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git tag -a &lt;tag-name&gt; -m <span class=s2>&#34;message&#34;</span> &lt;id&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=查看标签>查看标签</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git tag
</span></span></code></pre></td></tr></table></div></div><h3 id=查看标签详细信息>查看标签详细信息</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git show &lt;tag-name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=删除标签>删除标签</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git tag -d &lt;tag-name&gt;
</span></span></code></pre></td></tr></table></div></div><p>若要删除远程库标签，先从本地删除，然后</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push origin :refs/tags/&lt;tag-name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=推送标签至远程库>推送标签至远程库</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push origin &lt;tag-name&gt;
</span></span></code></pre></td></tr></table></div></div><p>若要一次性全部推送</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git push origin --tags
</span></span></code></pre></td></tr></table></div></div><h2 id=个性化>个性化</h2><h3 id=显示更丰富的颜色>显示更丰富的颜色</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git config --global color.ui <span class=nb>true</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=配置别名>配置别名</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git config --global alias.&lt;simple-name&gt; &lt;origin-name&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=忽略特殊文件>忽略特殊文件</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ touch .gitignore
</span></span></code></pre></td></tr></table></div></div><p>或直接创建一个<code>.gitignore</code>文件</p><p>别忘了提交<code>.gitignore</code></p><h3 id=删库跑路>删库跑路</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ rm .git -rf
</span></span></code></pre></td></tr></table></div></div><h2 id=规范>规范</h2><h3 id=gitflow>GitFlow</h3><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/o_git-workflow-release-cycle-4maintenance.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/o_git-workflow-release-cycle-4maintenance.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/o_git-workflow-release-cycle-4maintenance.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/o_git-workflow-release-cycle-4maintenance.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/o_git-workflow-release-cycle-4maintenance.png title=img></p><h4 id=分支命名规范>分支命名规范</h4><ul><li>master：也称 main，存储正式发布的产品。<ul><li>这个分支上的产品要求随时处于可部署状态。</li><li>它只能通过与其他分支合并来更新内容，禁止直接在 <code>master || main</code> 分支进行修改。</li></ul></li><li>develop：汇总开发者完成的工作成果<ul><li><code>develop</code> 分支上的产品可以是缺失功能模块的半成品，但是已有的功能模块不能是半成品</li><li><code>develop</code> 分支只能通过与其他分支合并来更新内容，禁止直接在 <code>develop</code> 分支进行修改。</li></ul></li><li>feature 分支：feature/&lt;功能名>，例如：feature/login<ul><li>当要开发新功能时，从 master 分支创建一个新的 <code>feature</code> 分支，并在 <code>feature</code> 分支上进行开发。</li><li>开发完成后，需要将该 <code>feature</code> 分支合并到 <code>develop</code> 分支，最后删除该 <code>feature</code> 分支</li></ul></li><li>release 分支<ul><li>当 <code>develop</code> 分支上的项目准备发布时，从 <code>develop</code> 分支上创建一个新的 <code>release</code> 分支，新建的 <code>release</code> 分支只能进行质量测试、bug 修复、文档生成等面向发布的任务，不能再添加功能。</li><li>这一系列发布任务完成后，需要将 <code>release</code> 分支合并到 <code>master</code> 分支上，并根据版本号为 <code>master</code> 分支添加 <code>tag</code>，然后将 <code>release</code> 分支创建以来的修改合并回 <code>develop</code> 分支，最后删除 <code>release</code> 分支</li></ul></li><li>hotfix 分支：hotfix/日期，例如：hotfix/0104<ul><li>当 <code>master</code> 分支中的产品出现需要立即修复的 bug 时，从 <code>master</code> 分支上创建一个新的 <code>hotfix</code> 分支，并在 <code>hotfix</code> 分支上进行 BUG 修复。</li><li>修复完成后，需要将 <code>hotfix</code> 分支合并到 <code>master</code> 分支和 <code>develop</code> 分支，并为 <code>master</code> 分支添加新的版本号 <code>tag</code>，最后删除 <code>hotfix</code> 分支。</li></ul></li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/21810c5662374b2bb10e11e307e83d7c~tplv-k3u1fbpfcp-watermark.image data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/21810c5662374b2bb10e11e307e83d7c~tplv-k3u1fbpfcp-watermark.image, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/21810c5662374b2bb10e11e307e83d7c~tplv-k3u1fbpfcp-watermark.image 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/21810c5662374b2bb10e11e307e83d7c~tplv-k3u1fbpfcp-watermark.image 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/21810c5662374b2bb10e11e307e83d7c~tplv-k3u1fbpfcp-watermark.image title=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/21810c5662374b2bb10e11e307e83d7c~tplv-k3u1fbpfcp-watermark.image></p><h3 id=commit-规范>commit 规范</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;
</span></span></code></pre></td></tr></table></div></div><p><strong>type</strong></p><ul><li>feat：新功能（feature）</li><li>fix：问题修复</li><li>docs：文档</li><li>style：调整格式（不影响代码运行 white-space, formatting, missing semi colons, etc）</li><li>perf：优化<strong>性能</strong>或体验</li><li>refactor：重构（既不是新增功能，也不是修補 bug 的程式碼變動）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li><li>merge：代码合并。</li><li>revert：撤销以前的提交</li><li>sync：同步主线或分支的 Bug</li></ul><p>scope：用于说明提交的影响范围，内容根据具体项目而定</p><p>subject：概括提交内容</p><p>详见：https://www.cnblogs.com/daysme/p/7722474.html</p><h2 id=git-命令补全配置>git 命令补全配置</h2><p>配置该功能时，只要下载 <code>git-bash-completion.git</code> 文件，无需下载所有的 <code>git</code> 源码。</p><p>所需文件是 <code>github</code> 上的开源文件</p><p>下载</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@ubuntu:~ git clone https://github.com/markgandolfo/git-bash-completion.git
</span></span><span class=line><span class=cl>root@ubuntu:~ cp git-bash-completion/git-completion.bash ~/.git-completion.bash
</span></span><span class=line><span class=cl>root@ubuntu:~ ll .git-completion.bash
</span></span><span class=line><span class=cl>-rwxr-xr-x <span class=m>1</span> root root <span class=m>27704</span> Feb <span class=m>18</span> 06:16 .git-completion.bash*
</span></span></code></pre></td></tr></table></div></div><p>修改 <code>~/.bashrc</code>，在文件结尾增加：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> -f ~/.git-completion.bash <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        . ~/.git-completion.bash
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></td></tr></table></div></div><p>执行 <code>.bashrc</code> 文件，在同一个窗口执行 <code>git</code> 命令，命令后续部分使用 <code>tab</code> 键补全。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>root@ubuntu:~ <span class=nb>source</span> ~/.bashrc
</span></span><span class=line><span class=cl>root@ubuntu:~ git sta
</span></span><span class=line><span class=cl>stage    stash    status
</span></span></code></pre></td></tr></table></div></div><blockquote><p>上述是 <code>git</code> 命令补全功能。不要和 <code>linux</code> 命令补全功能混淆。<code>linux</code> 命令补全安装方法：<code>apt-get install bash-completion</code>。</p><p>可以使用 <code>git config</code> 命令配置 <code>git</code> 命令别名，减少命令输入。</p></blockquote><h2 id=git-rebase>git rebase</h2><ul><li><code>git merge</code>：当需要保留详细的合并信息的时候建议使用，特别是需要将分支合并进入 <code>master</code> 分支时</li><li><code>git rebase</code>：当发现自己修改某个功能时，频繁进行了<code>git commit</code>提交时，发现其实过多的提交信息没有必要时使用，分支多，内容多时也可以考虑使用</li></ul><p>**与 <code>git merge</code> 一致，<code>git rebase</code> 的目的也是将一个分支的更改并入到另外一个分支中去。**主要特点如下：</p><ul><li>改变当前分支从 <code>master</code> 上拉出分支的位置</li><li><strong>没有多余的合并历史的记录</strong>，且合并后的 <code>commit</code> 顺序不一定按照 <code>commit</code> 的提交时间排列，同一个<code>commit</code>的 SHA 值会发生变化</li></ul><h3 id=例子>例子</h3><p><strong>假设现在有基于远程分支“origin/master”，更新至本地最新“master”，创建一个叫“feature/mywork”的分支</strong>进行说明</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout -b feature/mywork
</span></span></code></pre></td></tr></table></div></div><img src=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef541cf035374f0b83973a199c2c6ea1~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=1.jpg style=zoom:33%><p>现在 在分支<code>feature/mywork</code>做一些修改，然后生成<strong>两个commit</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ vim README.md
</span></span><span class=line><span class=cl>$ git commit -am <span class=s2>&#34;xxxA&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ vim CHANGELOG.md
</span></span><span class=line><span class=cl>$ git commit -am <span class=s2>&#34;xxxB&#34;</span>
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>与此同时，有些人在<code>master</code>分支上做了一些变更，如合并了 release 分支代码准备发布等。这时意味着<code>master</code>和<code>feature/mywork</code>这两个分支各自"前进"了，它们之间"分叉"了。</p><img src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1088600f61e44e1b2d0e2bd7f49ca7c~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=2.jpg style=zoom:33%><p>你可以用<code>pull</code>命令把<code>master</code>分支上的修改拉下来并且和你的修改合并；结果看起来就像一个新的"合并的提交"(merge commit)</p><img src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35d9c22941ea42c9abbf91b73802d7c4~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=3.jpg style=zoom:33%><p>这时 <code>feature/mywork</code> 分支历史看起来已经有分叉了，这还只是两个分支的，试想下有一个大型项目，有 20 个分支，同时迭代一些功能模块或者修改相同的代码块，分支树将会变成什么样？那能避免这种情况吗？答案当然是可以的，<strong>如果你想让 <code>feature/mywork</code> 分支历史看起来像没有经过任何合并一样，可以用 <code>git rebase</code></strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git checkout feature/mywork
</span></span><span class=line><span class=cl>$ git rebase master
</span></span></code></pre></td></tr></table></div></div><p>先来看下效果：</p><img src=https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/98679c766a0c464b81ca1c0bc0cfa7b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=4.jpg style=zoom:33%><p>解释：<strong><code>git rebase</code> 会把 <code>feature/mywork</code> 分支里的每个提交 (commit) 取消掉，并且把它们临时保存为补丁 (patch)，然后把 <code>feature/mywork</code> 分支更新到最新的 <code>master</code> 分支，最后把保存的这些补丁应用到 <code>feature/mywork</code> 分支上</strong></p><p>当 <code>feature/mywork</code> 分支更新之后，它会指向这些新创建的提交 (commit)，而那些老的提交会被丢弃。 如果运行垃圾收集命令 (pruning garbage collection)，这些被丢弃的提交就会删除。</p><img src=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c352046c07f45ee95729ca6a5edefaa~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=5.jpg style=zoom:33%><p>现在我们可以看一下用 merge 和用 rebase 所产生的历史的区别：</p><img src=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d935bcca7af4fbf8d194cb31d8e565f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=6.jpg style=zoom:33%>
<img src=https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/206a02f937aa43b1ad53454a39585275~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp alt=7.jpg style=zoom:33%><h3 id=解决冲突-conflict>解决冲突 CONFLICT</h3><p>在 rebase 的过程中，也许会出现冲突 (conflict)。在这种情况，Git 会停止 rebase 并会让你去解决冲突；在解决完冲突后，用 <code>git add</code> 命令去更新这些内容的索引 (index)，然后，你无需执行 <code>git commit</code>，只要执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git rebase --continue
</span></span></code></pre></td></tr></table></div></div><p>这样 git 会继续应用 (apply) 余下的补丁。</p><p>在任何时候，你可以终止 rebase 的行动，并且 <code>feature/mywork</code> 分支会回到 rebase 开始前的状态。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git rebase --abort
</span></span></code></pre></td></tr></table></div></div><p>在命令行使用 <code>git rebase</code> 存在多个 commit、多个冲突时需要我们<strong>多次解决同一个地方的冲突</strong>，然后执行 <code>git rebase --continue</code>，反复，直到冲突解决为止，稍显麻烦，可以使用 IDE 辅助进行，如 JetBrains 家族的 IDE 系列对 VCS 都有很好的支持，最新版的更是直接将 VCS 变为 Git</p><h3 id=合并历史-commit>合并历史 commit</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 从HEAD版本开始往过去数3个版本</span>
</span></span><span class=line><span class=cl>$ git rebase -i HEAD~3
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 合并指定版本号（不包含此版本）</span>
</span></span><span class=line><span class=cl>$ git rebase -i <span class=o>[</span>commitid<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>-i（--interactive）</code>：弹出交互式的界面进行编辑合并</li><li><code>[commitid]</code>：要合并多个版本之前的版本号，注意：<code>[commitid]</code> 本身不参与合并</li></ul><p>指令解释（交互编辑时使用）：</p><ul><li>p, pick = use commit</li><li>r, reword = use commit, but edit the commit message</li><li>e, edit = use commit, but stop for amending</li><li>s, squash = use commit, but meld into previous commit</li><li>f, fixup = like &ldquo;squash&rdquo;, but discard this commit&rsquo;s log message</li><li>x, exec = run command (the rest of the line) using shell</li><li>d, drop = remove commit</li></ul><h2 id=git-checkout>git checkout</h2><h3 id=基础>基础</h3><p>checkout 最常用的用法莫过于对于工作分支的切换了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout branchName
</span></span></code></pre></td></tr></table></div></div><p>该命令会将当前工作分支切换到 branchName。另外，可以通过下面的命令在新分支创建的同时切换分支：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout -b newBranch
</span></span></code></pre></td></tr></table></div></div><p>该命令相当于下面这两条命令的执行结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>1. git branch newBranch
</span></span><span class=line><span class=cl>2. git checkout newBranch
</span></span></code></pre></td></tr></table></div></div><p>该命令的完全体为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl>  git checkout -b|-B <span class=nt>&lt;new_branch&gt;</span> [<span class=nt>&lt;start</span> <span class=err>point</span><span class=nt>&gt;</span>]
</span></span></code></pre></td></tr></table></div></div><p>该命令的一个应用场景为：当我们刚从 git 上 clone 一个项目后，我们可以查看该项目的分支情况</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https:////upload-images.jianshu.io/upload_images/2147642-72217d4e0d491915.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/454/format/webp data-srcset="https:////upload-images.jianshu.io/upload_images/2147642-72217d4e0d491915.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/454/format/webp, https:////upload-images.jianshu.io/upload_images/2147642-72217d4e0d491915.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/454/format/webp 1.5x, https:////upload-images.jianshu.io/upload_images/2147642-72217d4e0d491915.png?imageMogr2/auto-orient/strip%7cimageView2/2/w/454/format/webp 2x" data-sizes=auto alt=https:////upload-images.jianshu.io/upload_images/2147642-72217d4e0d491915.png?imageMogr2/auto-orient/strip|imageView2/2/w/454/format/webp title=img></p><p>可以看到，克隆完后，只会默认创建一个 master 本地分支，其他都是远程分支，此时如果我们想切换到 newBranch 的远程分支该怎么操作呢？</p><p>方法一：使用 <code>git checkout -b</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout -b newBranch  origin/newBranch
</span></span></code></pre></td></tr></table></div></div><p>方法二：使用 <code>git branch &lt;branchname> [&lt;start-point>]</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git branch newBranch origin/newBranch
</span></span><span class=line><span class=cl>git checkout newBranch
</span></span></code></pre></td></tr></table></div></div><p>方法一其实是方法二的简化版</p><h3 id=深入>深入</h3><p>要想更深入的了解 checkout，我们需要了解 checkout 的作用机制。该命令的主要关联目标其实是.git 文件夹下的 HEAD 文件，我们可以查看工程下面的.git 文件夹：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https:////upload-images.jianshu.io/upload_images/2147642-70674478b9866791.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/631/format/webp data-srcset="https:////upload-images.jianshu.io/upload_images/2147642-70674478b9866791.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/631/format/webp, https:////upload-images.jianshu.io/upload_images/2147642-70674478b9866791.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/631/format/webp 1.5x, https:////upload-images.jianshu.io/upload_images/2147642-70674478b9866791.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/631/format/webp 2x" data-sizes=auto alt=https:////upload-images.jianshu.io/upload_images/2147642-70674478b9866791.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/631/format/webp title=img></p><p>该文件夹下 HEAD 文件记录了当前 HEAD 的信息，继续查看 HEAD 文件：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https:////upload-images.jianshu.io/upload_images/2147642-9e5096caf64ba235.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/620/format/webp data-srcset="https:////upload-images.jianshu.io/upload_images/2147642-9e5096caf64ba235.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/620/format/webp, https:////upload-images.jianshu.io/upload_images/2147642-9e5096caf64ba235.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/620/format/webp 1.5x, https:////upload-images.jianshu.io/upload_images/2147642-9e5096caf64ba235.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/620/format/webp 2x" data-sizes=auto alt=https:////upload-images.jianshu.io/upload_images/2147642-9e5096caf64ba235.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/620/format/webp title=img></p><p>可以看到当前 HEAD 文件指向了 refs/heads 路径下的 master 文件，该文件记录了 master 分支最近的一次 commit id,说明当前 HEAD 指向了 master 分支。如果我们将当前分支切换到 newBranch 分支，我们再看 HEAD 文件：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https:////upload-images.jianshu.io/upload_images/2147642-11092d89be549ea9.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/468/format/webp data-srcset="https:////upload-images.jianshu.io/upload_images/2147642-11092d89be549ea9.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/468/format/webp, https:////upload-images.jianshu.io/upload_images/2147642-11092d89be549ea9.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/468/format/webp 1.5x, https:////upload-images.jianshu.io/upload_images/2147642-11092d89be549ea9.jpeg?imageMogr2/auto-orient/strip%7cimageView2/2/w/468/format/webp 2x" data-sizes=auto alt=https:////upload-images.jianshu.io/upload_images/2147642-11092d89be549ea9.jpeg?imageMogr2/auto-orient/strip|imageView2/2/w/468/format/webp title=img></p><p>可以看到 HEAD 文件内容指向了 newBranch 分支</p><h3 id=拓展>拓展</h3><h4 id=检出某文件>检出某文件</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout <span class=o>[</span>&lt;commit id&gt;<span class=o>]</span> <span class=o>[</span>--<span class=o>]</span> &lt;paths&gt;
</span></span></code></pre></td></tr></table></div></div><p>该命令主要用于检出某一个指定文件。</p><p>如果不填写 commit id，则<strong>默认会从暂存区检出该文件</strong>，如果暂存区为空，则该文件会回滚到最近一次的提交状态。</p><p>例如：当暂存区为空，如果我们想要放弃对某一个文件的修改，可以用这个命令进行撤销：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout  <span class=o>[</span>--<span class=o>]</span> &lt;paths&gt;
</span></span></code></pre></td></tr></table></div></div><p>如果填写 commit id（既可以是 commit hash 也可以是分支名称还可以说 tag，其本质上都是 commit hash），则会从指定 commit hash 中检出该文件。用于恢复某一个文件到某一个提交状态。</p><h4 id=创建并切换分支>创建并切换分支</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl> git checkout -b &lt;new_branch&gt; <span class=o>[</span>&lt;start_point&gt;<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>该命令是文章开头部分所说的 checkout 常见用法的扩展，我们可以指定某一个分支或者某一次提交来创建新的分支，并且切换到该分支下，该命令相当于下面两条命令的执行结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>1. git branch  &lt;new_branch&gt; <span class=o>[</span>&lt;start_point&gt;<span class=o>]</span>
</span></span><span class=line><span class=cl>2. git checkout &lt;new_branch&gt;
</span></span></code></pre></td></tr></table></div></div><h4 id=强制创建并覆盖原同名分支>强制创建并覆盖原同名分支</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout -B &lt;new_branch&gt;
</span></span></code></pre></td></tr></table></div></div><p>该命令主要加了一个可选参数 B，如果已经存在了同名的分支，使用 git checkout -b &lt;new_branch>会提示错误，加入-B 可选参数后会强制创建新分支，并且会覆盖原来存在的同名分支。</p><h4 id=分出一个没有-commit-历史的干净分支>分出一个没有 commit 历史的干净分支</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout --orphan &lt;new_branch&gt;
</span></span></code></pre></td></tr></table></div></div><p>假如你的某个分支上，积累了无数次的提交，你也懒得去打理，打印出的 log 也让你无力吐槽，那么这个命令将是你的神器，它会基于当前所在分支新建一个赤裸裸的分支，没有任何的提交历史，但是当前分支的内容一一俱全。新建的分支，严格意义上说，还不是一个分支，因为 HEAD 指向的引用中没有 commit 值，只有在进行一次提交后，它才算得上真正的分支。</p><h4 id=切换分支时带走修改的内容>切换分支时带走修改的内容</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout --merge &lt;branch&gt;
</span></span></code></pre></td></tr></table></div></div><p>这个命令适用于在切换分支的时候，将当前分支修改的内容一起打包带走，同步到切换的分支下。
有两个需要注意的问题。</p><ol><li>如果当前分支和切换分支间的内容不同的话，容易造成冲突。</li><li>第二，切换到新分支后，当前分支修改过的内容就丢失了。</li></ol><p>所以这个命令，慎用</p><h4 id=比较两个分支的差异>比较两个分支的差异</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git checkout -p &lt;branch&gt;
</span></span></code></pre></td></tr></table></div></div><p>这个命令可以用来打补丁。这个命令主要用来比较两个分支间的差异内容，并提供交互式的界面来选择进一步的操作。这个命令不仅可以比较两个分支间的差异，还可以比较单个文件的差异哦！</p><h2 id=git-stash>git stash</h2><p>使用 git 的时候，我们往往使用分支（branch）解决任务切换问题。</p><p>例如，我们往往会建一个自己的分支去修改和调试代码；如果别人或者自己发现原有的分支上有个不得不修改的 bug，我们往往会把完成一半的代码<code>commit</code>提交到本地仓库，然后切换分支去修改 bug，改好之后再切换回来。这样的话往往 log 上会有大量不必要的记录。</p><p>其实如果我们不想提交完成一半或者不完善的代码，但是却不得不去修改一个紧急 Bug，那么使用 <code>git stash</code> 就可以将你当前未提交到本地（和服务器）的代码推入到 Git 的栈中。</p><p>这时候你的工作区间和上一次提交的内容是完全一样的，所以你可以放心的修 Bug；等到修完 Bug，提交到服务器上后，再使用<code>git stash apply</code>将以前一半的工作应用回来。</p><blockquote><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。</p><p>问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。</p><p>解决这个问题的办法就是 <code>git stash</code> 命令。</p><p>储藏 (stash) 可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p></blockquote><h3 id=stash-当前修改>stash 当前修改</h3><p><code>git stash</code> 会把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。
比如下面的中间状态，通过 <code>git stash</code> 命令推送一个新的储藏，当前的工作目录就干净了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Changes to be committed:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>new file:   style.css
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Changes not staged <span class=k>for</span> commit:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>modified:   index.html
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git stash
</span></span><span class=line><span class=cl>Saved working directory and index state WIP on master: 5002d47 our new homepage
</span></span><span class=line><span class=cl>HEAD is now at 5002d47 our new homepage
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>nothing to commit, working tree clean
</span></span></code></pre></td></tr></table></div></div><p>需要说明一点，stash 是本地的，不会通过 <code>git push</code> 命令上传到 git server 上。</p><p>实际应用中推荐给每个 stash 加一个 message，用于记录版本，**使用 <code>git stash save</code> 取代 <code>git stash</code> 命令。**示例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git stash save <span class=s2>&#34;test-cmd-stash&#34;</span>
</span></span><span class=line><span class=cl>Saved working directory and index state On autoswitch: test-cmd-stash
</span></span><span class=line><span class=cl>HEAD 现在位于 296e8d4 remove unnecessary postion reset in onResume <span class=k>function</span>
</span></span><span class=line><span class=cl>$ git stash list
</span></span><span class=line><span class=cl>stash@<span class=o>{</span>0<span class=o>}</span>: On autoswitch: test-cmd-stash
</span></span></code></pre></td></tr></table></div></div><h3 id=重新应用缓存的-stash>重新应用缓存的 stash</h3><p>可以通过 <code>git stash pop</code> 命令恢复之前缓存的工作目录，输出如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git status
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>nothing to commit, working tree clean
</span></span><span class=line><span class=cl>$ git stash pop
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Changes to be committed:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    new file:   style.css
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Changes not staged <span class=k>for</span> commit:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    modified:   index.html
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Dropped refs/stash@<span class=o>{</span>0<span class=o>}</span> <span class=o>(</span>32b3aa1d185dfe6d57b3c3cc3b32cbf3e380cc6a<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这个指令将缓存堆栈中的第一个 stash 删除，并将对应修改应用到当前的工作目录下。</p><p>你也可以使用 <strong><code>git stash apply</code></strong> 命令，将缓存堆栈中的 stash 多次应用到工作目录中，但<strong>并不删除 stash 拷贝</strong>。</p><p>命令输出如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git stash apply
</span></span><span class=line><span class=cl>On branch master
</span></span><span class=line><span class=cl>Changes to be committed:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    new file:   style.css
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Changes not staged <span class=k>for</span> commit:
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    modified:   index.html
</span></span></code></pre></td></tr></table></div></div><h3 id=查看现有-stash>查看现有 stash</h3><p>可以使用 <code>git stash list</code> 命令，一个典型的输出如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git stash list
</span></span><span class=line><span class=cl>stash@<span class=o>{</span>0<span class=o>}</span>: WIP on master: 049d078 added the index file
</span></span><span class=line><span class=cl>stash@<span class=o>{</span>1<span class=o>}</span>: WIP on master: c264051 Revert <span class=s2>&#34;added file_size&#34;</span>
</span></span><span class=line><span class=cl>stash@<span class=o>{</span>2<span class=o>}</span>: WIP on master: 21d80a5 added number to log
</span></span></code></pre></td></tr></table></div></div><p>在使用 <code>git stash apply</code> 命令时可以通过名字指定使用哪个 stash，默认使用最近的 stash（ 即 <code>stash@{0</code>} ）</p><h3 id=删除-stash>删除 stash</h3><p>可以使用 <code>git stash drop</code> 命令，后面可以跟着 stash 名字。下面是一个示例：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-perl data-lang=perl><span class=line><span class=cl><span class=nv>$</span> <span class=nv>git</span> <span class=n>stash</span> <span class=n>list</span>
</span></span><span class=line><span class=cl><span class=n>stash</span><span class=nv>@</span><span class=p>{</span><span class=mi>0</span><span class=p>}:</span> <span class=n>WIP</span> <span class=n>on</span> <span class=n>master:</span> <span class=mo>04</span><span class=mi>9</span><span class=n>d078</span> <span class=n>added</span> <span class=n>the</span> <span class=nb>index</span> <span class=n>file</span>
</span></span><span class=line><span class=cl><span class=n>stash</span><span class=nv>@</span><span class=p>{</span><span class=mi>1</span><span class=p>}:</span> <span class=n>WIP</span> <span class=n>on</span> <span class=n>master:</span> <span class=n>c264051</span> <span class=n>Revert</span> <span class=s>&#34;added file_size&#34;</span>
</span></span><span class=line><span class=cl><span class=n>stash</span><span class=nv>@</span><span class=p>{</span><span class=mi>2</span><span class=p>}:</span> <span class=n>WIP</span> <span class=n>on</span> <span class=n>master:</span> <span class=mi>21</span><span class=n>d80a5</span> <span class=n>added</span> <span class=n>number</span> <span class=n>to</span> <span class=nb>log</span>
</span></span><span class=line><span class=cl><span class=nv>$</span> <span class=nv>git</span> <span class=n>stash</span> <span class=n>drop</span> <span class=n>stash</span><span class=nv>@</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>Dropped</span> <span class=n>stash</span><span class=nv>@</span><span class=p>{</span><span class=mi>0</span><span class=p>}</span> <span class=p>(</span><span class=mf>364e91</span><span class=n>f3f268f0900bc3ee613f9f733e82aaed43</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>或者使用 <code>git stash clear</code> 命令，删除所有缓存的 stash。</p><h3 id=查看指定-stash-的-diff>查看指定 stash 的 diff</h3><p>可以使用 <code>git stash show</code> 命令，后面可以跟着 stash 名字。示例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=err>$</span> <span class=n>git</span> <span class=n>stash</span> <span class=n>show</span>
</span></span><span class=line><span class=cl> <span class=n>index</span><span class=o>.</span><span class=n>html</span> <span class=o>|</span> <span class=mi>1</span> <span class=o>+</span>
</span></span><span class=line><span class=cl> <span class=n>style</span><span class=o>.</span><span class=n>css</span> <span class=o>|</span> <span class=mi>3</span> <span class=o>+++</span>
</span></span><span class=line><span class=cl> <span class=mi>2</span> <span class=n>files</span> <span class=n>changed</span><span class=p>,</span> <span class=mi>4</span> <span class=n>insertions</span><span class=p>(</span><span class=o>+</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在该命令后面添加 <code>-p</code> 或 <code>--patch</code> 可以查看特定 stash 的全部 diff，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-diff data-lang=diff><span class=line><span class=cl>$ git stash show -p
</span></span><span class=line><span class=cl><span class=gh>diff --git a/style.css b/style.css
</span></span></span><span class=line><span class=cl><span class=gh></span>new file mode 100644
</span></span><span class=line><span class=cl><span class=gh>index 0000000..d92368b
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- /dev/null
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/style.css
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -0,0 +1,3 @@
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=gi>+* {
</span></span></span><span class=line><span class=cl><span class=gi>+  text-decoration: blink;
</span></span></span><span class=line><span class=cl><span class=gi>+}
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gh>diff --git a/index.html b/index.html
</span></span></span><span class=line><span class=cl><span class=gh>index 9daeafb..ebdcbd2 100644
</span></span></span><span class=line><span class=cl><span class=gh></span><span class=gd>--- a/index.html
</span></span></span><span class=line><span class=cl><span class=gd></span><span class=gi>+++ b/index.html
</span></span></span><span class=line><span class=cl><span class=gi></span><span class=gu>@@ -1 +1,2 @@
</span></span></span><span class=line><span class=cl><span class=gu></span><span class=gi>+&lt;link rel=&#34;stylesheet&#34; href=&#34;style.css&#34;/&gt;
</span></span></span></code></pre></td></tr></table></div></div><h3 id=从-stash-创建分支>从 stash 创建分支</h3><p>如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题：如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。</p><p>如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 <code>git stash branch</code>，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ git stash branch testchanges
</span></span><span class=line><span class=cl>Switched to a new branch <span class=s2>&#34;testchanges&#34;</span>
</span></span><span class=line><span class=cl><span class=c1># On branch testchanges</span>
</span></span><span class=line><span class=cl><span class=c1># Changes to be committed:</span>
</span></span><span class=line><span class=cl><span class=c1>#   (use &#34;git reset HEAD &lt;file&gt;...&#34; to unstage)</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1>#      modified:   index.html</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1># Changes not staged for commit:</span>
</span></span><span class=line><span class=cl><span class=c1>#   (use &#34;git add &lt;file&gt;...&#34; to update what will be committed)</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl><span class=c1>#      modified:   lib/simplegit.rb</span>
</span></span><span class=line><span class=cl><span class=c1>#</span>
</span></span><span class=line><span class=cl>Dropped refs/stash@<span class=o>{</span>0<span class=o>}</span> <span class=o>(</span>f0dfc4d5dc332d1cee34a634182e168c4efc3359<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。</p><h3 id=暂存指定文件>暂存指定文件</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git stash push &lt;file_path&gt;
</span></span></code></pre></td></tr></table></div></div><h3 id=暂存未跟踪或忽略的文件>暂存未跟踪或忽略的文件</h3><p>默认情况下，<code>git stash</code> 会缓存下列文件：</p><ul><li>添加到暂存区的修改（staged changes）</li><li>Git 跟踪的但并未添加到暂存区的修改（unstaged changes）</li></ul><p>但不会缓存以下文件：</p><ul><li><strong>在工作目录中新的文件</strong>（untracked files）</li><li>被忽略的文件（ignored files）</li></ul><p><code>git stash</code> 命令提供了参数用于缓存上面两种类型的文件。</p><ul><li>使用 <code>-u</code> 或者 <code>--include-untracked</code> 可以 stash untracked 文件。</li><li>使用 <code>-a</code> 或者 <code>--all</code> 命令可以 stash 当前目录下的所有修改。</li></ul><h2 id=git-cherry-pick>git cherry-pick</h2><h3 id=基本用法>基本用法</h3><p><code>git cherry-pick</code> 命令的作用，就是将指定的提交（commit）应用于其他分支。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git cherry-pick &lt;commitHash&gt;
</span></span></code></pre></td></tr></table></div></div><p>上面命令就会将指定的提交 <code>commitHash</code>，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p><p>举例来说，代码仓库有 <code>master</code> 和 <code>feature</code> 两个分支。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a - b - c - d   Master
</span></span><span class=line><span class=cl>         \
</span></span><span class=line><span class=cl>           e - f - g Feature
</span></span></code></pre></td></tr></table></div></div><p>现在将提交 <code>f</code> 应用到 <code>master</code> 分支。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 切换到 master 分支</span>
</span></span><span class=line><span class=cl>$ git checkout master
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Cherry pick 操作</span>
</span></span><span class=line><span class=cl>$ git cherry-pick f
</span></span></code></pre></td></tr></table></div></div><p>上面的操作完成以后，代码库就变成了下面的样子。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a - b - c - d - f   Master
</span></span><span class=line><span class=cl>         \
</span></span><span class=line><span class=cl>           e - f - g Feature
</span></span></code></pre></td></tr></table></div></div><p>从上面可以看到，<code>master</code> 分支的末尾增加了一个提交 <code>f</code>。</p><p><code>git cherry-pick</code> 命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git cherry-pick feature
</span></span></code></pre></td></tr></table></div></div><p>上面代码表示将 <code>feature</code> 分支的最近一次提交，转移到当前分支。</p><h3 id=转移多个提交>转移多个提交</h3><p>Cherry pick 支持一次转移多个提交。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;
</span></span></code></pre></td></tr></table></div></div><p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p><p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git cherry-pick A..B
</span></span></code></pre></td></tr></table></div></div><p>上面的命令可以转移从 A 到 B（<strong>除了 A</strong>）的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p><p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git cherry-pick A^..B
</span></span></code></pre></td></tr></table></div></div><h3 id=配置项>配置项</h3><p><code>git cherry-pick</code>命令的常用配置项如下。</p><ul><li><p><code>-e</code>，<code>--edit</code></p><ul><li>打开外部编辑器，编辑提交信息。</li></ul></li><li><p><code>-n</code>，<code>--no-commit</code></p><ul><li>只更新工作区和暂存区，不产生新的提交。</li></ul></li><li><p><code>-x</code></p><ul><li>在提交信息的末尾追加一行<code>(cherry picked from commit ...)</code>，方便以后查到这个提交是如何产生的。</li></ul></li><li><p><code>-s</code>，<code>--signoff</code></p><ul><li>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</li></ul></li><li><p><code>-m parent-number</code>，<code>--mainline parent-number</code></p><ul><li><p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p></li><li><p><code>-m</code> 配置项告诉 Git，应该采用哪个分支的变动。它的参数 <code>parent-number</code> 是一个从 <code>1</code> 开始的整数，代表原始提交的父分支编号。</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  $ git cherry-pick -m <span class=m>1</span> &lt;commitHash&gt;
</span></span></code></pre></td></tr></table></div></div></li><li><p>面命令表示，Cherry pick 采用提交 <code>commitHash</code> 来自编号 1 的父分支的变动。</p><p>一般来说，1 号父分支是接受变动的分支（the branch being merged into），2 号父分支是作为变动来源的分支（the branch being merged from）</p></li></ul></li></ul><h3 id=代码冲突>代码冲突</h3><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p><ul><li><p><code>--continue</code></p><ul><li><p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（<code>git add .</code>），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>  $ git cherry-pick --continue
</span></span></code></pre></td></tr></table></div></div></li></ul></li><li><p><code>--abort</code></p><ul><li>发生代码冲突后，放弃合并，回到操作前的样子。</li></ul></li><li><p><code>--quit</code></p><ul><li>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</li></ul></li></ul><h3 id=转移到另一个代码库>转移到另一个代码库</h3><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git remote add target git://gitUrl
</span></span></code></pre></td></tr></table></div></div><p>上面命令添加了一个远程仓库<code>target</code>。</p><p>然后，将远程代码抓取到本地。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git fetch target
</span></span></code></pre></td></tr></table></div></div><p>上面命令将远程代码仓库抓取到本地。</p><p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git log target/master
</span></span></code></pre></td></tr></table></div></div><p>最后，使用<code>git cherry-pick</code>命令转移提交。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>$ git cherry-pick &lt;commitHash&gt;
</span></span></code></pre></td></tr></table></div></div><h2 id=git-bundle>git bundle</h2><p>虽然我们已经了解了网络传输 Git 数据的常用方法（如 HTTP，SSH 等），但还有另外一种不太常见却又十分有用的方式。</p><p>Git 可以将它的数据“打包”到一个文件中。 这在许多场景中都很有用。 有可能你的网络中断了，但你又希望将你的提交传给你的合作者们。 可能你不在办公网中并且出于安全考虑没有给你接入内网的权限。 可能你的无线、有线网卡坏掉了。 可能你现在没有共享服务器的权限，你又希望通过邮件将更新发送给别人， 却不希望通过 <code>format-patch</code> 的方式传输 40 个提交。</p><p>这些情况下 <code>git bundle</code> 就会很有用。 <code>bundle</code> 命令会将 <code>git push</code> 命令所传输的所有内容打包成一个二进制文件， 你可以将这个文件通过邮件或者闪存传给其他人，然后解包到其他的仓库中。</p><p>在一个仓库的根目录下执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git bundle create repo.bundle HEAD master
</span></span></code></pre></td></tr></table></div></div><p>然后你就会有一个名为 <code>repo.bundle</code> 的文件，该文件包含了所有重建该仓库 <code>master</code> 分支所需的数据。 在使用 <code>bundle</code> 命令时，你需要列出所有你希望打包的引用或者提交的区间。 如果你希望这个仓库可以在别处被克隆，你应该像例子中那样增加一个 HEAD 引用。</p><p>你可以将这个 <code>repo.bundle</code> 文件通过邮件或者 U 盘传给别人。</p><p>另一方面，假设别人传给你一个 <code>repo.bundle</code> 文件并希望你在这个项目上工作。 你可以从这个二进制文件中克隆出一个目录，就像从一个 URL 克隆一样。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>git clone repo.bundle repo
</span></span></code></pre></td></tr></table></div></div><h2 id=其他>其他</h2><ul><li><p>不建议使用 <code>git push --force</code>，推荐 <code>--force-with-lease</code> 参数</p></li><li><p>识别大小写</p></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git config core.ignorecase <span class=nb>false</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>修改上一次的 commit 记录</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git commit --amend
</span></span></code></pre></td></tr></table></div></div><ul><li>比较文件</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>git diff &lt;branch_name1&gt; &lt;branch_name2&gt; --stat
</span></span><span class=line><span class=cl>git diff &lt;branch_name1&gt; --stat <span class=c1># 比较当前文件与 branch_name1</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><p>当本地有领先远端的 commit，同时远端也有领先本地的 commit（这种情况经常会发生），并使用 git pull 拉去远端代码时，会产生一条 merge commit，例：merge branch &lsquo;feature/login&rsquo; of ssh://gitlab.aaa.net/project/main-web into feature/login，污染了 commit 记录</p><ul><li><p>原因：<strong>本地分支与远程分支存在分叉</strong>，而 git pull = git fetch + git merge，在 merge 时有冲突就会产生一条 merge commit</p></li><li><p>避免方法</p><ol><li><p>使用 <code>git pull --rebase</code> 代替 git pull，这种方案的原理是不产生额外的合并节点，而是将远端更新拉取到本地，而后将本地的提交附加到远端更新之后。</p><ul><li>一劳永逸：<code>git config --global pull.rebase true</code></li></ul></li><li><p>在本地 commit 之前 stash，pull 之后再 pop 出来</p></li></ol></li></ul></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-06-14 09:56:49">更新于 2023-06-14</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/git/ data-title="Git 教程" data-hashtags=Git,快速入门><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/git/ data-hashtag=Git><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/git/ data-title="Git 教程"><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/git/>Git</a>,&nbsp;<a href=/Notes/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/>快速入门</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/%E5%B7%A5%E5%85%B7/mermaid/ class=prev rel=prev title=mermaid><i class="fa-solid fa-angle-left fa-fw"></i>mermaid</a>
<a href=/Notes/posts/frontend/api-%E8%A7%84%E8%8C%83/ class=next rel=next title="API 规范">API 规范<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>