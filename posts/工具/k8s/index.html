<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>k8s - 伤心肠粉的酱油碟子</title><meta name=Description content><meta property="og:title" content="k8s"><meta property="og:description" content="Kubernetes k8s 是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-06-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="k8s"><meta name=twitter:description content="Kubernetes k8s 是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服"><meta name=application-name content="伤心肠粉的酱油碟子"><meta name=apple-mobile-web-app-title content="伤心肠粉的酱油碟子"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/exec/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/linux/useful/install/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"k8s","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/k8s\/"},"genre":"posts","wordcount":2662,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/k8s\/","datePublished":"2022-06-22T00:00:00+00:00","dateModified":"2022-06-22T00:00:00+00:00","publisher":{"@type":"Organization","name":"MelonCholi"},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/Notes/categories/>分类 </a><a class=menu-item href=/Notes/tags/>标签 </a><a class=menu-item href=/Notes/posts/>文章 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/Notes/categories/ title>分类</a><a class=menu-item href=/Notes/tags/ title>标签</a><a class=menu-item href=/Notes/posts/ title>文章</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">k8s</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/Notes/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>MelonCholi</a></span>&nbsp;<span class=post-category>收录于 <a href=/Notes/categories/%E5%B7%A5%E5%85%B7/><i class="far fa-folder fa-fw"></i>工具</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-06-22>2022-06-22</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 2662 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 6 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#认识>认识</a><ul><li><a href=#集群设计>集群设计</a></li><li><a href=#deployment---应用管理者>Deployment - 应用管理者</a></li><li><a href=#pod---kubernetes-最小调度单位>Pod - Kubernetes 最小调度单位</a></li><li><a href=#service---服务发现---找到每个-pod>Service - 服务发现 - 找到每个 Pod</a></li><li><a href=#rollingupdate---滚动升级>RollingUpdate - 滚动升级</a></li></ul></li><li><a href=#组件>组件</a><ul><li><a href=#master>Master</a><ul><li><a href=#kube-apiserver>kube-apiserver</a></li><li><a href=#etcd>ETCD</a></li><li><a href=#kube-controller-manager>kube-controller-manager</a></li><li><a href=#kube-scheduler>kube-scheduler</a></li></ul></li><li><a href=#node>Node</a><ul><li><a href=#kubelet>kubelet</a></li><li><a href=#kube-proxy>kube-proxy</a></li><li><a href=#container-runtime>Container Runtime</a></li></ul></li></ul></li><li><a href=#对象>对象</a></li></ul></nav></div></div><div class=content id=content><h1 id=kubernetes>Kubernetes</h1><p>k8s 是基于容器的<strong>集群编排引擎</strong>，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服务发现等多种特性能力。</p><ul><li>快速部署应用</li><li>快速扩展应用</li><li>无缝对接新的应用功能</li><li>节省资源，优化硬件资源的使用</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png title="kubernetes 整体架构示意图"></p><table><thead><tr><th style=text-align:left>对比项</th><th style=text-align:left>Linux</th><th style=text-align:left>Kubernetes</th></tr></thead><tbody><tr><td style=text-align:left>隔离单元</td><td style=text-align:left>进程</td><td style=text-align:left>Pod</td></tr><tr><td style=text-align:left>硬件</td><td style=text-align:left>单机</td><td style=text-align:left>数据中心</td></tr><tr><td style=text-align:left>并发</td><td style=text-align:left>线程</td><td style=text-align:left>容器</td></tr><tr><td style=text-align:left>资源管理</td><td style=text-align:left>进程内存&CPU</td><td style=text-align:left>内存、CPU Limit/Request</td></tr><tr><td style=text-align:left>存储</td><td style=text-align:left>文件</td><td style=text-align:left>ConfigMap、Secret、Volume</td></tr><tr><td style=text-align:left>网络</td><td style=text-align:left>端口绑定</td><td style=text-align:left>Service</td></tr><tr><td style=text-align:left>终端</td><td style=text-align:left>tty、pty、shell</td><td style=text-align:left>kubectl exec</td></tr><tr><td style=text-align:left>网络安全</td><td style=text-align:left>IPtables</td><td style=text-align:left>NetworkPolicy</td></tr><tr><td style=text-align:left>权限</td><td style=text-align:left>用户、文件权限</td><td style=text-align:left>ServiceAccount、RBAC</td></tr></tbody></table><h2 id=认识>认识</h2><h3 id=集群设计>集群设计</h3><p>Kubernetes 可以管理大规模的集群，使集群中的每一个节点彼此连接，能够像控制一台单一的计算机一样控制整个集群。</p><p>集群有两种角色，一种是 <strong>master</strong> ，一种是 <strong>Node</strong>（也叫worker）。</p><ul><li><strong>master</strong> 是集群的"大脑"，负责管理整个集群：应用的调度、更新、扩缩容等。</li><li><strong>Node</strong> 就是具体"干活"的<ul><li>一个 Node 一般是<strong>一个虚拟机或物理机</strong>，它上面事先运行着 docker 服务和 kubelet 服务（ Kubernetes 的一个组件）</li><li>当接收到 master 下发的 &ldquo;任务&rdquo; 后，Node 就要去完成任务（用 docker 运行一个指定的应用）</li></ul></li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-ae36c2d33d5afb5215f9e746c6a9bbd4_1440w.jpg alt=img style=zoom:50%><h3 id=deployment---应用管理者>Deployment - 应用管理者</h3><p>当我们拥有一个 Kubernetes 集群后，就可以在上面跑我们的应用了，前提是我们的应用必须支持在 docker 中运行，也就是我们要事先准备好 docker 镜像。</p><p>有了镜像之后，一般我们会通过 Kubernetes 的 <strong>Deployment</strong> 的<strong>配置文件</strong>去描述应用，比如应用叫什么名字、使用的镜像名字、要运行几个实例、需要多少的内存资源、cpu 资源等等。</p><p>有了配置文件就可以通过 Kubernetes 提供的命令行客户端 - <strong>kubectl</strong> 去管理这个应用了。kubectl 会跟 Kubernetes 的 master 通过 RestAPI 通信，最终完成应用的管理。</p><p>比如我们刚才配置好的 Deployment 配置文件叫 app.yaml，我们就可以通过 &ldquo;kubectl create -f app.yaml&rdquo; 来创建这个应用，之后就由 Kubernetes 来保证我们的应用处于运行状态。</p><p>当某个实例运行失败了或者运行着应用的 Node 突然宕机了，Kubernetes 会自动发现并在新的 Node 上调度一个新的实例，保证我们的应用始终达到我们预期的结果。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-de389c70f77d3ade07a9e5f6e2dadcfc_1440w.jpg alt=img style=zoom:50%><h3 id=pod---kubernetes-最小调度单位>Pod - Kubernetes 最小调度单位</h3><p>其实在上一步创建完 Deployment 之后，Kubernetes 的 Node 做的事情并不是简单的 docker run 一个容器。出于像易用性、灵活性、稳定性等的考虑，Kubernetes 提出了一个叫做 Pod 的东西，作为 Kubernetes 的最小调度单位。所以我们的应用在每个 Node 上运行的其实是一个 Pod。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2d769a56fc687409da9151779adafc7f_1440w.jpg alt=img style=zoom:50%><p>Pod 是一组容器（当然也可以只有一个）。容器本身就是一个小盒子了，Pod 相当于在容器上又包了一层小盒子。这个盒子里面的容器有什么特点呢？</p><ul><li>可以直接通过 volume 共享存储。</li><li>有相同的网络空间，通俗点说就是有一样的 ip 地址，有一样的网卡和网络设置。</li><li>多个容器之间可以“了解”对方，比如知道其他人的镜像，知道别人定义的端口等。</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg title=img></p><h3 id=service---服务发现---找到每个-pod>Service - 服务发现 - 找到每个 Pod</h3><p>上面的 Deployment 创建了，Pod 也运行起来了。如何才能访问到我们的应用呢？</p><p>最直接想到的方法就是直接通过 Pod-ip+port 去访问，但如果实例数很多呢？好，拿到所有的 Pod-ip 列表，配置到负载均衡器中，轮询访问。但上面我们说过，Pod 可能会死掉，甚至 Pod 所在的 Node 也可能宕机，Kubernetes 会自动帮我们重新创建新的Pod。再者每次更新服务的时候也会重建 Pod。而每个 Pod 都有自己的 ip。所以 Pod 的 ip 是<strong>不稳定</strong>的，会经常变化的。</p><p>面对这种变化我们就要借助另一个概念：Service。它就是来专门解决这个问题的。不管 Deployment 的 Pod 有多少个，不管它是更新、销毁还是重建，Service 总是能发现并维护好它的 ip 列表。</p><p>Service 对外也提供了多种入口：</p><ol><li><strong>ClusterIP</strong>：Service 在集群内的唯一 ip 地址，我们可以通过这个 ip，均衡的访问到后端的 Pod，而无须关心具体的 Pod</li><li><strong>NodePort</strong>：Service 会在集群的每个 Node 上都启动一个端口，我们可以通过任意 Node 的这个端口来访问到 Pod</li><li><strong>LoadBalancer</strong>：在 NodePort 的基础上，借助公有云环境创建一个外部的负载均衡器，并将请求转发到 <code>NodeIP:NodePort</code>。</li><li><strong>ExternalName</strong>：将服务通过 DNS CNAME 记录方式转发到指定的域名（通过 spec.externlName 设定）</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f0e6d59bb179f1293986625c98fa593f_1440w.jpg alt=img style=zoom:50%><p>好，看似服务访问的问题解决了。但大家有没有想过，Service 是如何知道它负责哪些 Pod 呢？是如何跟踪这些 Pod 变化的？</p><p>最容易想到的方法是使用 Deployment 的名字。一个 Service 对应一个 Deployment 。当然这样确实可以实现。但 kubernetes 使用了一个更加灵活、通用的设计 - Label 标签；通过给 Pod 打标签，Service 可以只负责一个 Deployment 的 Pod 也可以负责多个 Deployment 的 Pod 了。Deployment 和 Service 就可以通过 Label 解耦了。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-3d4c14f108b08a6f05b03a0f46546063_1440w.jpg alt=img style=zoom:50%><h3 id=rollingupdate---滚动升级>RollingUpdate - 滚动升级</h3><p>滚动升级是Kubernetes中最典型的服务升级方案，主要思路是一边增加新版本应用的实例数，一边减少旧版本应用的实例数，直到新版本的实例数达到预期，旧版本的实例数减少为 0，滚动升级结束。</p><p>在整个升级过程中，服务一直处于可用状态。并且可以在任意时刻回滚到旧版本。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp title=动图></p><h2 id=组件>组件</h2><h3 id=master>Master</h3><blockquote><p>也叫控制平面组件（Control Plane Components）</p></blockquote><p>Master 组件提供集群的管理控制中心。</p><p>Master 组件可以在集群中任何节点上运行。但是为了简单起见，通常在一台 VM / 机器上启动所有 Master 组件，并且不会在此 VM / 机器上运行用户容器。</p><h4 id=kube-apiserver>kube-apiserver</h4><p>kube-apiserver 负责公开 Kubernetes API，负责处理接受请求的工作接口进行。</p><h4 id=etcd>ETCD</h4><p><code>etcd</code> 是兼顾一致性与高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><h4 id=kube-controller-manager>kube-controller-manager</h4><p>kube-controller-manager 负责运行控制器进程</p><p>逻辑上，每个控制器是一个单独的进程，但为了降低复杂性，所有的控制器被编译到一个二进制文件里，并作为一个进程运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li><li>服务帐户和令牌控制器（Service Account & Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li></ul><h4 id=kube-scheduler>kube-scheduler</h4><p><code>kube-scheduler</code> 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h3 id=node>Node</h3><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id=kubelet>kubelet</h4><p>kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。</p><h4 id=kube-proxy>kube-proxy</h4><p>kube-proxy 是集群中每个节点（node）所上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><h4 id=container-runtime>Container Runtime</h4><p>容器运行环境是负责运行容器的软件。</p><h2 id=对象>对象</h2><p>对象是Kubernetes系统中的持久实体</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-06-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/exec/ class=prev rel=prev title=os/exec><i class="fas fa-angle-left fa-fw"></i>os/exec</a>
<a href=/Notes/posts/linux/useful/install/ class=next rel=next title="Linux 上的环境安装">Linux 上的环境安装<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>酒困路长惟欲睡，日高人渴漫思茶</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><script type=text/javascript src=/Notes/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/Notes/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:45},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js></script></body></html>