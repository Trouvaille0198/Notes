<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>k8s - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="Kubernetes k8s 是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服"><meta name=keywords content="Theme,Hugo"><meta itemprop=name content="k8s"><meta itemprop=description content="Kubernetes k8s 是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服"><meta itemprop=datePublished content="2022-06-22T00:00:00+00:00"><meta itemprop=dateModified content="2022-08-19T14:39:32+00:00"><meta itemprop=wordCount content="3276"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content><meta property="og:title" content="k8s"><meta property="og:description" content="Kubernetes k8s 是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-06-22T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-19T14:39:32+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="k8s"><meta name=twitter:description content="Kubernetes k8s 是基于容器的集群编排引擎，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/exec/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%8E%92%E5%BA%8F/56.-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"k8s","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/k8s\/"},"genre":"posts","wordcount":3276,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/k8s\/","datePublished":"2022-06-22T00:00:00+00:00","dateModified":"2022-08-19T14:39:32+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>k8s</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/%E5%B7%A5%E5%85%B7/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;工具</a></span></div><div class=post-meta-line><span title="2022-06-22 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-06-22>2022-06-22</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 3276 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 7 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#认识>认识</a><ul><li><a href=#集群设计>集群设计</a></li><li><a href=#deployment---应用管理者>Deployment - 应用管理者</a></li><li><a href=#pod---kubernetes-最小调度单位>Pod - Kubernetes 最小调度单位</a></li><li><a href=#service---服务发现---找到每个-pod>Service - 服务发现 - 找到每个 Pod</a></li><li><a href=#rollingupdate---滚动升级>RollingUpdate - 滚动升级</a></li></ul></li><li><a href=#组件>组件</a><ul><li><a href=#master>Master</a><ul><li><a href=#kube-apiserver>kube-apiserver</a></li><li><a href=#etcd>ETCD</a></li><li><a href=#kube-controller-manager>kube-controller-manager</a></li><li><a href=#kube-scheduler>kube-scheduler</a></li></ul></li><li><a href=#node>Node</a><ul><li><a href=#kubelet>kubelet</a></li><li><a href=#kube-proxy>kube-proxy</a></li><li><a href=#container-runtime>Container Runtime</a></li></ul></li><li><a href=#k8s-组件调用流程>k8s 组件调用流程</a></li></ul></li><li><a href=#对象>对象</a></li></ul></nav></div></div><div class=content id=content><h1 id=kubernetes>Kubernetes</h1><p>k8s 是基于容器的<strong>集群编排引擎</strong>，具备扩展集群、滚动升级回滚、弹性伸缩、自动治愈、服务发现等多种特性能力。</p><ul><li>快速部署应用</li><li>快速扩展应用</li><li>无缝对接新的应用功能</li><li>节省资源，优化硬件资源的使用</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/kubernetes-whole-arch.png title="kubernetes 整体架构示意图"></p><table><thead><tr><th style=text-align:left>对比项</th><th style=text-align:left>Linux</th><th style=text-align:left>Kubernetes</th></tr></thead><tbody><tr><td style=text-align:left>隔离单元</td><td style=text-align:left>进程</td><td style=text-align:left>Pod</td></tr><tr><td style=text-align:left>硬件</td><td style=text-align:left>单机</td><td style=text-align:left>数据中心</td></tr><tr><td style=text-align:left>并发</td><td style=text-align:left>线程</td><td style=text-align:left>容器</td></tr><tr><td style=text-align:left>资源管理</td><td style=text-align:left>进程内存&CPU</td><td style=text-align:left>内存、CPU Limit/Request</td></tr><tr><td style=text-align:left>存储</td><td style=text-align:left>文件</td><td style=text-align:left>ConfigMap、Secret、Volume</td></tr><tr><td style=text-align:left>网络</td><td style=text-align:left>端口绑定</td><td style=text-align:left>Service</td></tr><tr><td style=text-align:left>终端</td><td style=text-align:left>tty、pty、shell</td><td style=text-align:left>kubectl exec</td></tr><tr><td style=text-align:left>网络安全</td><td style=text-align:left>IPtables</td><td style=text-align:left>NetworkPolicy</td></tr><tr><td style=text-align:left>权限</td><td style=text-align:left>用户、文件权限</td><td style=text-align:left>ServiceAccount、RBAC</td></tr></tbody></table><h2 id=认识>认识</h2><h3 id=集群设计>集群设计</h3><p>Kubernetes 可以管理大规模的集群，使集群中的每一个节点彼此连接，能够像控制一台单一的计算机一样控制整个集群。</p><p>集群有两种角色，一种是 <strong>master</strong> ，一种是 <strong>Node</strong>（也叫 worker）。</p><ul><li><strong>master</strong> 是集群的"大脑"，负责管理整个集群：应用的调度、更新、扩缩容等。</li><li><strong>Node</strong> 就是具体"干活"的<ul><li>一个 Node 一般是<strong>一个虚拟机或物理机</strong>，它上面事先运行着 docker 服务和 kubelet 服务（ Kubernetes 的一个组件）</li><li>当接收到 master 下发的 &ldquo;任务&rdquo; 后，Node 就要去完成任务（用 docker 运行一个指定的应用）</li></ul></li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-ae36c2d33d5afb5215f9e746c6a9bbd4_1440w.jpg alt=img style=zoom:50%><h3 id=deployment---应用管理者>Deployment - 应用管理者</h3><p>当我们拥有一个 Kubernetes 集群后，就可以在上面跑我们的应用了，前提是我们的应用必须支持在 docker 中运行，也就是我们要事先准备好 docker 镜像。</p><p>有了镜像之后，一般我们会通过 Kubernetes 的 <strong>Deployment</strong> 的<strong>配置文件</strong>去描述应用，比如应用叫什么名字、使用的镜像名字、要运行几个实例、需要多少的内存资源、cpu 资源等等。</p><p>有了配置文件就可以通过 Kubernetes 提供的命令行客户端 - <strong>kubectl</strong> 去管理这个应用了。kubectl 会跟 Kubernetes 的 master 通过 RestAPI 通信，最终完成应用的管理。</p><p>比如我们刚才配置好的 Deployment 配置文件叫 app.yaml，我们就可以通过 &ldquo;kubectl create -f app.yaml&rdquo; 来创建这个应用，之后就由 Kubernetes 来保证我们的应用处于运行状态。</p><p>当某个实例运行失败了或者运行着应用的 Node 突然宕机了，Kubernetes 会自动发现并在新的 Node 上调度一个新的实例，保证我们的应用始终达到我们预期的结果。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-de389c70f77d3ade07a9e5f6e2dadcfc_1440w.jpg alt=img style=zoom:50%><h3 id=pod---kubernetes-最小调度单位>Pod - Kubernetes 最小调度单位</h3><p>其实在上一步创建完 Deployment 之后，Kubernetes 的 Node 做的事情并不是简单的 docker run 一个容器。出于像易用性、灵活性、稳定性等的考虑，Kubernetes 提出了一个叫做 Pod 的东西，作为 Kubernetes 的最小调度单位。所以我们的应用在每个 Node 上运行的其实是一个 Pod。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2d769a56fc687409da9151779adafc7f_1440w.jpg alt=img style=zoom:50%><p>Pod 是一组容器（当然也可以只有一个）。容器本身就是一个小盒子了，Pod 相当于在容器上又包了一层小盒子。这个盒子里面的容器有什么特点呢？</p><ul><li>可以直接通过 volume 共享存储。</li><li>有相同的网络空间，通俗点说就是有一样的 ip 地址，有一样的网卡和网络设置。</li><li>多个容器之间可以“了解”对方，比如知道其他人的镜像，知道别人定义的端口等。</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-244c75b316d49205ce86776ddb4c1d37_1440w.jpg title=img></p><h3 id=service---服务发现---找到每个-pod>Service - 服务发现 - 找到每个 Pod</h3><p>上面的 Deployment 创建了，Pod 也运行起来了。如何才能访问到我们的应用呢？</p><p>最直接想到的方法就是直接通过 Pod-ip+port 去访问，但如果实例数很多呢？好，拿到所有的 Pod-ip 列表，配置到负载均衡器中，轮询访问。</p><p>但上面我们说过，Pod 可能会死掉，甚至 Pod 所在的 Node 也可能宕机，Kubernetes 会自动帮我们重新创建新的 Pod。再者每次更新服务的时候也会重建 Pod。而每个 Pod 都有自己的 ip。所以 Pod 的 ip 是<strong>不稳定</strong>的，会经常变化的。</p><p>面对这种变化我们就要借助另一个概念：<strong>Service</strong>。它就是来专门解决这个问题的。不管 Deployment 的 Pod 有多少个，不管它是更新、销毁还是重建，Service 总是能发现并维护好它的 ip 列表。</p><p>Service 对外也提供了多种入口：</p><ol><li><strong>ClusterIP</strong>：Service 在集群内的唯一 ip 地址，我们可以通过这个 ip，均衡的访问到后端的 Pod，而无须关心具体的 Pod</li><li><strong>NodePort</strong>：Service 会在集群的每个 Node 上都启动一个端口，我们可以通过任意 Node 的这个端口来访问到 Pod</li><li><strong>LoadBalancer</strong>：在 NodePort 的基础上，借助公有云环境创建一个外部的负载均衡器，并将请求转发到 <code>NodeIP:NodePort</code>。</li><li><strong>ExternalName</strong>：将服务通过 DNS CNAME 记录方式转发到指定的域名（通过 spec.externlName 设定）</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f0e6d59bb179f1293986625c98fa593f_1440w.jpg alt=img style=zoom:50%><p>好，看似服务访问的问题解决了。但大家有没有想过，Service 是如何知道它负责哪些 Pod 呢？是如何跟踪这些 Pod 变化的？</p><p>最容易想到的方法是使用 Deployment 的名字。一个 Service 对应一个 Deployment 。当然这样确实可以实现。但 kubernetes 使用了一个更加灵活、通用的设计 - Label 标签；通过给 Pod 打标签，Service 可以只负责一个 Deployment 的 Pod 也可以负责多个 Deployment 的 Pod 了。Deployment 和 Service 就可以通过 Label 解耦了。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-3d4c14f108b08a6f05b03a0f46546063_1440w.jpg alt=img style=zoom:50%><h3 id=rollingupdate---滚动升级>RollingUpdate - 滚动升级</h3><p>滚动升级是 Kubernetes 中最典型的服务升级方案，主要思路是一边增加新版本应用的实例数，一边减少旧版本应用的实例数，直到新版本的实例数达到预期，旧版本的实例数减少为 0，滚动升级结束。</p><p>在整个升级过程中，服务一直处于可用状态。并且可以在任意时刻回滚到旧版本。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-232d0bd7f74bbf380e0d4f83f4a3bbc9_b.webp title=动图></p><h2 id=组件>组件</h2><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/6eaf44b8963e40c2ac3b1b2ce80c9972~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/6eaf44b8963e40c2ac3b1b2ce80c9972~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/6eaf44b8963e40c2ac3b1b2ce80c9972~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/6eaf44b8963e40c2ac3b1b2ce80c9972~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/6eaf44b8963e40c2ac3b1b2ce80c9972~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp title=img></p><h3 id=master>Master</h3><blockquote><p>也叫控制平面组件（Control Plane Components）</p></blockquote><p>Master 组件提供集群的管理控制中心。</p><p>Master 组件可以在集群中任何节点上运行。但是为了简单起见，通常在一台 VM / 机器上启动所有 Master 组件，并且不会在此 VM / 机器上运行用户容器。</p><h4 id=kube-apiserver>kube-apiserver</h4><blockquote><p>上连其余组件，下接 ETCD，提供各类 api 处理、鉴权，和 Node 上的 kubelet 通信等，只有 apiserver 会连接 ETCD</p></blockquote><p>kube-apiserver 提供 Kubernetes API，是 Kubernetes 控制平台的前端（front-end）</p><p>kubectl / kubernetes dashboard / kuboard 等 Kubernetes 管理工具就是通过 kubernetes API 实现对 Kubernetes 集群的管理</p><h4 id=etcd>ETCD</h4><blockquote><p>整个集群的数据库</p></blockquote><p><code>etcd</code> 是兼顾一致性与高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。</p><h4 id=kube-controller-manager>kube-controller-manager</h4><blockquote><p>控制各类 controller</p></blockquote><p>kube-controller-manager 负责运行控制器进程</p><p>逻辑上，每个控制器（controller）是一个单独的进程，但为了降低复杂性，所有的控制器被编译到一个二进制文件里，并作为一个进程运行。</p><p>这些控制器包括：</p><ul><li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li><li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li><li>端点控制器（Endpoints Controller）：填充端点（Endpoints）对象（即加入 Service 与 Pod）</li><li>服务帐户和令牌控制器（Service Account & Token Controllers）：为新的命名空间创建默认帐户和 API 访问令牌</li></ul><h4 id=kube-scheduler>kube-scheduler</h4><blockquote><p>调度，打分，分配资源</p></blockquote><p><code>kube-scheduler</code> 负责监视新创建的、未指定运行节点（node）的 Pods， 并选择节点来让 Pod 在上面运行。</p><p>调度决策考虑的因素包括单个 Pod 及 Pods 集合的资源需求、软硬件及策略约束、 亲和性及反亲和性规范、数据位置、工作负载间的干扰及最后时限。</p><h3 id=node>Node</h3><p>节点组件会在每个节点上运行，负责维护运行的 Pod 并提供 Kubernetes 运行环境。</p><h4 id=kubelet>kubelet</h4><blockquote><p>agent，负责管理容器的生命周期</p></blockquote><p>kubelet 会在集群中每个节点（node）上运行。 它保证容器（containers）都运行在 Pod 中。</p><h4 id=kube-proxy>kube-proxy</h4><blockquote><p>打通网络</p></blockquote><p>kube-proxy 是集群中每个节点（node）所上运行的网络代理， 实现 Kubernetes 服务（Service） 概念的一部分。</p><p>kube-proxy 维护节点上的一些网络规则， 这些网络规则会允许从集群内部或外部的网络会话与 Pod 进行网络通信。</p><h4 id=container-runtime>Container Runtime</h4><p>容器运行环境是负责运行容器的软件。可以是 Docker</p><h3 id=k8s-组件调用流程>k8s 组件调用流程</h3><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/a64a2f42b9944778b65ba07d1f2bfe94~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/a64a2f42b9944778b65ba07d1f2bfe94~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/a64a2f42b9944778b65ba07d1f2bfe94~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/a64a2f42b9944778b65ba07d1f2bfe94~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/a64a2f42b9944778b65ba07d1f2bfe94~tplv-k3u1fbpfcp-zoom-in-crop-mark:3326:0:0:0.awebp title=img></p><p>下面我们看下<code> kubectl create deployment redis-deployment --image=redis</code> 下发之后，k8s 集群做了什么。</p><ul><li>首先 controller-manager, scheduler, kubelet 都会和 apiserver 开始进行 <strong>List-Watch 模型</strong>，List 是拿到当前的状态，Watch 是拿到期望状态，然后 k8s 集群会致力于将当前状态达到达期望状态。</li><li>kubectl 下发命令到 apiserver，鉴权处理之后将创建信息存入 etcd，Deployment 的实现是使用 ReplicaSet 控制器，当 controller-manager 提前拿到当前的状态（pod=0），接着接收到期望状态，需要创建 ReplicaSet（pod=1），就会开始创建 Pod。</li><li>然后 scheduler 会进行调度，确认 Pod 被创建在哪一台 Node 上。</li><li>之后 Node 上的 kubelet 真正拉起一个 docker。</li></ul><h2 id=对象>对象</h2><p>对象是 Kubernetes 系统中的持久实体</p><p>每个 Kubernetes 对象都包含两个嵌套对象字段，用于管理 Object 的配置：Object Spec 和 Object Status。</p><ul><li>Spec 描述了对象所需的状态 - 希望 Object 具有的特性，</li><li>Status 描述了对象的实际状态，并由 Kubernetes 系统提供和更新。</li></ul><p>例如，通过 Kubernetes Deployment 来表示在集群上运行的应用的对象。</p><ul><li>创建 Deployment 时，可以设置 Deployment Spec，来指定要运行应用的三个副本。</li><li>Kubernetes 系统将读取 Deployment Spec，并启动你想要的三个应用实例 - 来更新状态以符合之前设置的 Spec。</li><li>如果这些实例中有任何一个失败（状态更改），Kuberentes 系统将响应 Spec 和当前状态之间差异来调整，这种情况下，将会开始替代实例。</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-08-19 14:39:32">更新于 2022-08-19</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/ data-title=k8s><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/k8s/ data-title=k8s><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/exec/ class=prev rel=prev title=os/exec><i class="fa-solid fa-angle-left fa-fw"></i>os/exec</a>
<a href=/Notes/posts/%E5%88%B7%E9%A2%98/array/%E6%8E%92%E5%BA%8F/56.-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/ class=next rel=next title="56. 合并区间">56. 合并区间<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>