<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Docker - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="Docker 摘自：https://yeasy.gitbook.io/docker_prac"><meta name=keywords content="快速入门,Golang"><meta itemprop=name content="Docker"><meta itemprop=description content="Docker 摘自：https://yeasy.gitbook.io/docker_prac"><meta itemprop=datePublished content="2022-03-07T00:00:00+00:00"><meta itemprop=dateModified content="2023-01-06T16:23:36+00:00"><meta itemprop=wordCount content="27089"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="快速入门,Golang,"><meta property="og:title" content="Docker"><meta property="og:description" content="Docker 摘自：https://yeasy.gitbook.io/docker_prac"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/docker/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-07T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-06T16:23:36+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Docker 摘自：https://yeasy.gitbook.io/docker_prac"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/docker/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/docker\/"},"genre":"posts","keywords":"快速入门, Golang","wordcount":27089,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E5%B7%A5%E5%85%B7\/docker\/","datePublished":"2022-03-07T00:00:00+00:00","dateModified":"2023-01-06T16:23:36+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Docker</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/golang/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Golang</a>&ensp;<a href=/Notes/categories/%E5%B7%A5%E5%85%B7/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;工具</a></span></div><div class=post-meta-line><span title="2022-03-07 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-07>2022-03-07</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 27089 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 55 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png title=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#什么是-docker>什么是 Docker</a><ul><li><a href=#容器技术-vs-虚拟机>容器技术 vs 虚拟机</a></li><li><a href=#什么是容器>什么是容器</a></li><li><a href=#什么是-docker-1>什么是 docker</a></li><li><a href=#如何使用-docker>如何使用 docker</a></li><li><a href=#docker-是如何工作的>docker 是如何工作的</a><ul><li><a href=#docker-build><code>docker build</code></a></li><li><a href=#docker-run><code>docker run</code></a></li><li><a href=#docker-pull><code>docker pull</code></a></li></ul></li><li><a href=#docker-的底层实现>docker 的底层实现</a></li></ul></li><li><a href=#安装>安装</a><ul><li><a href=#ubuntu>Ubuntu</a><ul><li><a href=#使用-apt-安装>使用 APT 安装</a></li><li><a href=#启动-docker>启动 Docker</a></li><li><a href=#测试>测试</a></li><li><a href=#建立-docker-用户组>建立 docker 用户组</a></li></ul></li></ul></li><li><a href=#使用镜像>使用镜像</a><ul><li><a href=#获取镜像-docker-pull>获取镜像 <code>docker pull</code></a><ul><li><a href=#例>例</a></li><li><a href=#试运行>试运行</a></li></ul></li><li><a href=#列出镜像-docker-image-ls>列出镜像 <code>docker image ls</code></a><ul><li><a href=#镜像体积>镜像体积</a></li><li><a href=#虚悬镜像>虚悬镜像</a></li><li><a href=#中间层镜像>中间层镜像</a></li><li><a href=#列出部分镜像>列出部分镜像</a></li></ul></li><li><a href=#删除本地镜像-docker-image-rm>删除本地镜像 <code>docker image rm</code></a><ul><li><a href=#用-id镜像名摘要删除镜像>用 ID、镜像名、摘要删除镜像</a></li><li><a href=#untagged-和-deleted>Untagged 和 Deleted</a></li><li><a href=#用-docker-image-ls-命令来配合>用 docker image ls 命令来配合</a></li></ul></li></ul></li><li><a href=#操作容器>操作容器</a><ul><li><a href=#启动>启动</a><ul><li><a href=#新建并启动-docker-run>新建并启动 <code>docker run</code></a></li><li><a href=#守护态运行--d>守护态运行 <code>-d</code></a></li></ul></li><li><a href=#终止-docker-container-stop>终止 <code>docker container stop</code></a></li><li><a href=#进入容器>进入容器</a><ul><li><a href=#docker-attach><code>docker attach</code></a></li><li><a href=#docker-exec><code>docker exec</code></a></li></ul></li><li><a href=#导出和导入>导出和导入</a><ul><li><a href=#导出容器-docker-export>导出容器 <code>docker export</code></a></li><li><a href=#导入容器快照-docker-import>导入容器快照 <code>docker import</code></a></li></ul></li><li><a href=#删除>删除</a><ul><li><a href=#删除容器-docker-container-rm>删除容器 <code>docker container rm</code></a></li><li><a href=#清理所有处于终止状态的容器>清理所有处于终止状态的容器</a></li></ul></li></ul></li><li><a href=#访问仓库>访问仓库</a><ul><li><a href=#docker-hub>Docker Hub</a><ul><li><a href=#登录-docker-login>登录 <code>docker login</code></a></li><li><a href=#拉取镜像-docker-pull>拉取镜像 <code>docker pull</code></a></li><li><a href=#推送镜像-docker-push>推送镜像 <code>docker push</code></a></li></ul></li></ul></li><li><a href=#数据管理>数据管理</a><ul><li><a href=#数据卷-volumn>数据卷 volumn</a><ul><li><a href=#创建一个数据卷>创建一个数据卷</a></li><li><a href=#启动一个挂载数据卷的容器>启动一个挂载数据卷的容器</a></li><li><a href=#查看数据卷的具体信息>查看数据卷的具体信息</a></li><li><a href=#删除数据卷>删除数据卷</a></li></ul></li><li><a href=#挂载主机目录-bind-mount>挂载主机目录 bind mount</a><ul><li><a href=#挂载一个主机目录作为数据卷>挂载一个主机目录作为数据卷</a></li><li><a href=#查看数据卷的具体信息-1>查看数据卷的具体信息</a></li><li><a href=#挂载一个本地主机文件作为数据卷>挂载一个本地主机文件作为数据卷</a></li></ul></li><li><a href=#volume-和-bind-的区别>volume 和 bind 的区别</a></li></ul></li><li><a href=#使用网络>使用网络</a><ul><li><a href=#外部访问容器>外部访问容器</a><ul><li><a href=#映射所有接口地址>映射所有接口地址</a></li><li><a href=#映射到指定地址的指定端口>映射到指定地址的指定端口</a></li><li><a href=#映射到指定地址的任意端口>映射到指定地址的任意端口</a></li><li><a href=#查看映射端口配置-docker-port>查看映射端口配置 <code>docker port</code></a></li></ul></li><li><a href=#容器互联>容器互联</a><ul><li><a href=#新建网络-docker-network-create>新建网络 <code>docker network create</code></a></li><li><a href=#连接容器>连接容器</a></li><li><a href=#docker-compose>Docker Compose</a></li></ul></li></ul></li><li><a href=#常用命令>常用命令</a></li><li><a href=#使用-dockerfile-定制镜像->使用 Dockerfile 定制镜像 ⭐</a><ul><li><a href=#from-指定基础镜像>FROM 指定基础镜像</a></li><li><a href=#run-执行命令>RUN 执行命令</a></li><li><a href=#构建镜像-docker->构建镜像 <code>docker</code></a></li><li><a href=#镜像构建上下文context>镜像构建上下文（Context）</a></li><li><a href=#其它-docker-build-的用法>其它 <code>docker build</code> 的用法</a><ul><li><a href=#直接用-git-repo-进行构建>直接用 Git repo 进行构建</a></li><li><a href=#用给定的-tar-压缩包构建>用给定的 tar 压缩包构建</a></li><li><a href=#从标准输入中读取-dockerfile-进行构建>从标准输入中读取 Dockerfile 进行构建</a></li><li><a href=#从标准输入中读取上下文压缩包进行构建>从标准输入中读取上下文压缩包进行构建</a></li></ul></li></ul></li><li><a href=#dockerfile-指令详解>Dockerfile 指令详解</a><ul><li><a href=#copy-复制文件>COPY 复制文件</a></li><li><a href=#add-更高级的复制文件>ADD 更高级的复制文件</a></li><li><a href=#cmd-容器启动命令>CMD 容器启动命令</a></li><li><a href=#entrypoint-入口点>ENTRYPOINT 入口点</a><ul><li><a href=#场景一让镜像变成像命令一样使用>场景一：让镜像变成像命令一样使用</a></li><li><a href=#场景二应用运行前的准备工作>场景二：应用运行前的准备工作</a></li></ul></li><li><a href=#env-设置环境变量>ENV 设置环境变量</a></li><li><a href=#arg-构建参数>ARG 构建参数</a></li><li><a href=#volume-定义匿名卷>VOLUME 定义匿名卷</a></li><li><a href=#expose-暴露端口>EXPOSE 暴露端口</a></li><li><a href=#workdir-指定工作目录>WORKDIR 指定工作目录</a></li><li><a href=#user-指定当前用户>USER 指定当前用户</a></li><li><a href=#healthcheck-健康检查>HEALTHCHECK 健康检查</a></li><li><a href=#onbuild-为他人作嫁衣裳>ONBUILD 为他人作嫁衣裳</a></li><li><a href=#label-为镜像添加元数据>LABEL 为镜像添加元数据</a></li><li><a href=#shell-指令>SHELL 指令</a></li></ul></li><li><a href=#dockerfile-多阶段构建>Dockerfile 多阶段构建</a><ul><li><a href=#之前的做法>之前的做法</a><ul><li><a href=#全部放入一个-dockerfile>全部放入一个 Dockerfile</a></li><li><a href=#分散到多个-dockerfile>分散到多个 Dockerfile</a></li></ul></li><li><a href=#使用多阶段构建>使用多阶段构建</a><ul><li><a href=#只构建某一阶段的镜像>只构建某一阶段的镜像</a></li><li><a href=#构建时从其他镜像复制文件>构建时从其他镜像复制文件</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=docker>Docker</h1><p>摘自：https://yeasy.gitbook.io/docker_practice/</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png title=img></p><h2 id=什么是-docker>什么是 Docker</h2><p>摘自：https://zhuanlan.zhihu.com/p/187505981</p><h3 id=容器技术-vs-虚拟机>容器技术 vs 虚拟机</h3><blockquote><p>从空间和时间两个维度考虑</p></blockquote><p>和一个单纯的应用程序相比，<strong>操作系统是一个很重而且很笨的程序</strong></p><p>操作系统运行起来是需要占用很多资源的，刚装好的系统还什么都没有部署，单纯的操作系统其磁盘占用至少几十 G 起步，内存要几个 G 起步。</p><p>假设我有一台机器，16G 内存，需要部署三个应用，那么使用虚拟机技术可以这样划分：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg title=img></p><p>在这台机器上开启三个虚拟机，每个虚拟机上部署一个应用，其中 VM1 占用 2G 内存，VM2 占用 1G 内存，VM3 占用了 4G 内存。</p><p>我们可以看到虚拟本身就占据了总共 7G 内存，因此<strong>我们没有办法划分出更多虚拟机从而部署更多的应用程序</strong>，可是我们部署的是应用程序，要用的也是应用程序而<strong>不是操作系统</strong>。</p><p>如果有一种技术可以让我们避免把<strong>内存浪费</strong>在 “无用” 的操作系统上岂不是太香？这是问题一，主要原因在于操作系统太重了。</p><p>还有另一个问题，那就是<strong>启动时间</strong>问题，我们知道操作系统重启是非常慢的，因为操作系统要从头到尾把该检测的都检测了该加载的都加载上，这个过程非常缓慢，动辄数分钟，因此操作系统还是太笨了。</p><p>那么有没有一种技术可以让我们获得虚拟机的好处又能克服这些缺点从而一举实现鱼和熊掌的兼得呢？</p><p>答案是肯定的，这就是容器技术。</p><h3 id=什么是容器>什么是容器</h3><p>容器一词的英文是 container，其实 container 还有集装箱的意思，而容器和集装箱在概念上是很相似的。</p><p>现代软件开发的一大目的就是<strong>隔离</strong>，应用程序在运行时相互独立互不干扰，这种隔离实现起来是很不容易的，其中一种解决方案就是上面提到的虚拟机技术，通过将应用程序部署在不同的虚拟机中从而实现隔离：</p><img src=https://pic1.zhimg.com/v2-0f6ede7f0b920b5d0d5571c937a04838_b.jpg alt=img style=zoom:67%><p>但是虚拟机技术有上述提到的各种缺点，那么容器技术又怎么样呢？</p><p>与虚拟机通过操作系统实现隔离不同，容器技术</p><ul><li><strong>只隔离应用程序的运行时环境</strong></li><li><strong>容器之间可以共享同一个操作系统</strong></li></ul><blockquote><p>这里的运行时环境指的是程序运行依赖的<strong>各种库以及配置</strong>。</p></blockquote><img src=https://pic2.zhimg.com/v2-907214eadd65987e84a0751c08143f91_b.jpg alt=img style=zoom:67%><p>从图中我们可以看到容器更加的<strong>轻量级且占用的资源更少</strong>，与操作系统动辄几 G 的内存占用相比，容器技术只需数 M 空间，因此我们可以在同样规格的硬件上<strong>大量部署容器</strong>，这是虚拟机所不能比拟的，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动，容器技术为<strong>打包服务栈</strong>提供了一种更加高效的方式，So cool。</p><p>那么我们该怎么使用容器呢？这就要讲到 docker 了。</p><p>注意，<strong>容器是一种通用技术，docker 只是其中的一种实现。</strong></p><h3 id=什么是-docker-1>什么是 docker</h3><p>docker 是一个用 Go 语言实现的开源项目，可以让我们方便的创建和使用容器，docker 将程序以及程序所有的依赖都打包到 docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器。</p><p>就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系（容器），和集装箱放在哪个货船或者哪个港口 (操作系统) 没有关系</strong>。</p><p>因此我们可以看到 docker 可以<strong>屏蔽环境差异</strong>，也就是说，只要你的程序打包到了 docker 中，那么无论运行在什么环境下程序的行为都是一致的，程序员再也无法施展表演才华了，不会再有 “在我的环境上可以运行”，真正实现 “<strong>build once, run everywhere</strong>”。</p><p>此外 docker 的另一个好处就是<strong>快速部署</strong>，这是当前互联网公司最常见的一个应用场景，一个原因在于容器启动速度非常快，另一个原因在于只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。</p><h3 id=如何使用-docker>如何使用 docker</h3><p>docker 中有这样几个概念：</p><ul><li><strong>dockerfile</strong></li><li><strong>image</strong></li><li><strong>container</strong></li></ul><p>实际上你可以简单的把</p><ul><li>dockerfile 理解为源代码</li><li>image 理解为可执行程序</li><li>container 就是运行起来的进程</li><li>docker 就是 &ldquo;编译器&rdquo;。</li></ul><p>官方文档的术语解释：</p><blockquote><ul><li><p>A <strong>Dockerfile</strong> is simply a text-based script of instructions that is used to create a container image.</p></li><li><p>A <strong>container</strong> is a sandboxed process on your machine that is isolated from all other processes on the host machine.</p></li></ul></blockquote><p>因此我们只需要在 dockerfile 中指定需要哪些程序、依赖什么样的配置，之后把 dockerfile 交给“编译器” docker 进行“编译”，也就是 <code>docker build</code> 命令，生成的可执行程序就是 image，之后就可以运行这个 image 了，这就是 <code>docker run</code> 命令，image 运行起来后就是 docker container。</p><h3 id=docker-是如何工作的>docker 是如何工作的</h3><p>实际上 docker 使用了常见的 CS 架构，也就是 client-server 模式，docker client 负责处理用户输入的各种命令，比如 docker build、docker run，真正工作的其实是 server，也就是 docker daemon</p><blockquote><p>值得注意的是，docker client 和 docker demon 可以运行在同一台机器上。</p></blockquote><p>接下来我们用几个命令来讲解一下 docker 的工作流程：</p><h4 id=docker-build><code>docker build</code></h4><p>当我们写完 dockerfile 交给 docker “编译” 时使用这个命令，那么 client 在接收到请求后转发给 docker daemon，接着 docker daemon 根据 dockerfile 创建出 “可执行程序” image。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg title=img></p><h4 id=docker-run><code>docker run</code></h4><p>有了 “可执行程序” image 后就可以运行程序了，接下来使用命令 <code>docker run</code>，docker daemon 接收到该命令后找到具体的 image，然后加载到内存开始执行，image 执行起来就是所谓的 container。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg title=img></p><h4 id=docker-pull><code>docker pull</code></h4><p>其实 <code>docker build</code> 和 <code>docker run</code> 是两个最核心的命令，会用这两个命令基本上 docker 就可以用起来了，剩下的就是一些补充。</p><p>那么 <code>docker pull</code> 是什么意思呢？</p><p>我们之前说过，docker 中 image 的概念就类似于“可执行程序”，我们可以从哪里下载到别人写好的应用程序呢？很简单，就是 <strong>Docker Hub</strong>，docker 官方的“应用商店”，你可以在这里下载到别人编写好的 image，这样你就不用自己编写 dockerfile 了。</p><p><strong>docker registry 可以用来存放各种 image</strong>，公共的可以供任何人下载 image 的仓库就是 docker Hub。那么该怎么从 Docker Hub 中下载 image 呢，就是这里的 docker pull 命令了。</p><p>因此，这个命令的实现也很简单，那就是用户通过 docker client 发送命令，docker daemon 接收到命令后向 docker registry 发送 image 下载请求，下载后存放在本地，这样我们就可以使用 image 了。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg title=img></p><p>最后，让我们来看一下 docker 的底层实现。</p><h3 id=docker-的底层实现>docker 的底层实现</h3><p>docker 基于 Linux 内核提供这样几项功能实现的：</p><ul><li><strong>NameSpace</strong>
我们知道 Linux 中的 PID、IPC、网络等资源是全局的，而 NameSpace 机制是一种<strong>资源隔离方案</strong>，在该机制下这些资源就不再是全局的了，而是属于某个特定的 NameSpace，各个 NameSpace 下的资源互不干扰，这就使得每个 NameSpace 看上去就像一个独立的操作系统一样，但是只有 NameSpace 是不够。</li><li><strong>Control groups</strong>
虽然有了 NameSpace 技术可以实现资源隔离，但进程还是可以不受控的<strong>访问系统资源</strong>，比如 CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker 采用 control groups 技术（也就是 cgroup），有了 cgroup 就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些 CPU 上运行等等。</li></ul><p>有了这两项技术，容器看起来就真的像是独立的操作系统了。</p><h2 id=安装>安装</h2><h3 id=ubuntu>Ubuntu</h3><h4 id=使用-apt-安装>使用 APT 安装</h4><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo apt-get install <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    apt-transport-https <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    ca-certificates <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    curl <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    gnupg <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    lsb-release
</span></span></code></pre></td></tr></table></div></div><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class=p>|</span> sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 官方源</span>
</span></span><span class=line><span class=cl><span class=c1># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=s2>&#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \
</span></span></span><span class=line><span class=cl><span class=s2>  </span><span class=k>$(</span>lsb_release -cs<span class=k>)</span><span class=s2> stable&#34;</span> <span class=p>|</span> sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 官方源</span>
</span></span><span class=line><span class=cl><span class=c1># $ echo \</span>
</span></span><span class=line><span class=cl><span class=c1>#   &#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span>
</span></span><span class=line><span class=cl><span class=c1>#   $(lsb_release -cs) stable&#34; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo apt-get install docker-ce docker-ce-cli containerd.io
</span></span></code></pre></td></tr></table></div></div><h4 id=启动-docker>启动 Docker</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo systemctl <span class=nb>enable</span> docker
</span></span><span class=line><span class=cl>$ sudo systemctl start docker
</span></span></code></pre></td></tr></table></div></div><h4 id=测试>测试</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run --rm hello-world
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Unable to find image <span class=s1>&#39;hello-world:latest&#39;</span> locally
</span></span><span class=line><span class=cl>latest: Pulling from library/hello-world
</span></span><span class=line><span class=cl>b8dfde127a29: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> hello-world:latest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hello from Docker!
</span></span><span class=line><span class=cl>This message shows that your installation appears to be working correctly.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To generate this message, Docker took the following steps:
</span></span><span class=line><span class=cl> 1. The Docker client contacted the Docker daemon.
</span></span><span class=line><span class=cl> 2. The Docker daemon pulled the <span class=s2>&#34;hello-world&#34;</span> image from the Docker Hub.
</span></span><span class=line><span class=cl>    <span class=o>(</span>amd64<span class=o>)</span>
</span></span><span class=line><span class=cl> 3. The Docker daemon created a new container from that image which runs the
</span></span><span class=line><span class=cl>    executable that produces the output you are currently reading.
</span></span><span class=line><span class=cl> 4. The Docker daemon streamed that output to the Docker client, which sent it
</span></span><span class=line><span class=cl>    to your terminal.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To try something more ambitious, you can run an Ubuntu container with:
</span></span><span class=line><span class=cl> $ docker run -it ubuntu bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Share images, automate workflows, and more with a free Docker ID:
</span></span><span class=line><span class=cl> https://hub.docker.com/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>For more examples and ideas, visit:
</span></span><span class=line><span class=cl> https://docs.docker.com/get-started/
</span></span></code></pre></td></tr></table></div></div><p>若能正常输出以上信息，则说明安装成功。</p><h4 id=建立-docker-用户组>建立 docker 用户组</h4><p>默认情况下，<code>docker</code> 命令会使用 <a href=https://en.wikipedia.org/wiki/Unix_domain_socket target=_blank rel="external nofollow noopener noreferrer">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo groupadd docker
</span></span></code></pre></td></tr></table></div></div><p>将当前用户加入 <code>docker</code> 组：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo usermod -aG docker <span class=nv>$USER</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=使用镜像>使用镜像</h2><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id=获取镜像-docker-pull>获取镜像 <code>docker pull</code></h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull <span class=o>[</span>选项<span class=o>]</span> 仓库名<span class=o>[</span>:标签<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 更具体地</span>
</span></span><span class=line><span class=cl>$ docker pull <span class=o>[</span>选项<span class=o>]</span> <span class=o>[</span>Docker Registry 地址<span class=o>[</span>:端口号<span class=o>]]</span>仓库名<span class=o>[</span>:标签<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP>[:端口号]</code>。<ul><li>默认地址是 Docker Hub (<code>docker.io</code>)</li></ul></li><li>仓库名：两段式名称，即 &lt;用户名>/&lt;软件名>。<ul><li>对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul></li></ul><h4 id=例>例</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull ubuntu:18.04
</span></span><span class=line><span class=cl><span class=c1># 更具体地</span>
</span></span><span class=line><span class=cl>$ docker pull docker.io/library/ubuntu:18.04
</span></span></code></pre></td></tr></table></div></div><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><p>下载过程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>18.04: Pulling from library/ubuntu
</span></span><span class=line><span class=cl>92dc2a97ff99: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>be13a9d27eb8: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>c8299583700a: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> ubuntu:18.04
</span></span><span class=line><span class=cl>docker.io/library/ubuntu:18.04
</span></span></code></pre></td></tr></table></div></div><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><p>下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><h4 id=试运行>试运行</h4><p>以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --rm ubuntu:18.04 bash
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>-it</code>：这是两个参数</p><ul><li><code>-i</code>：交互式操作</li><li><code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li></ul></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。</p><ul><li>默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</li><li>我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li></ul></li><li><p><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</p></li></ul><h3 id=列出镜像-docker-image-ls>列出镜像 <code>docker image ls</code></h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>redis                latest              5f515359c7f8        <span class=m>5</span> days ago          <span class=m>183</span> MB
</span></span><span class=line><span class=cl>nginx                latest              05a60462f8ba        <span class=m>5</span> days ago          <span class=m>181</span> MB
</span></span><span class=line><span class=cl>mongo                3.2                 fe9198c04d62        <span class=m>5</span> days ago          <span class=m>342</span> MB
</span></span><span class=line><span class=cl>&lt;none&gt;               &lt;none&gt;              00285df0df87        <span class=m>5</span> days ago          <span class=m>342</span> MB
</span></span><span class=line><span class=cl>ubuntu               18.04               329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span><span class=line><span class=cl>ubuntu               bionic              329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span></code></pre></td></tr></table></div></div><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p><strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id=镜像体积>镜像体积</h4><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>63.3MB</code>，但是在 <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42?context=explore" target=_blank rel="external nofollow noopener noreferrer">Docker Hub</a> 显示的却是 <code>25.47 MB</code>。</p><p>这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，<strong>因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。</strong></p><p>而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，<strong>因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</strong></p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是<strong>多层存储结构</strong>，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此<strong>实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</strong></p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker system df
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>TYPE                TOTAL           ACTIVE           SIZE              RECLAIMABLE
</span></span><span class=line><span class=cl>Images              <span class=m>24</span>              <span class=m>0</span>                1.992GB           1.992GB <span class=o>(</span>100%<span class=o>)</span>
</span></span><span class=line><span class=cl>Containers          <span class=m>1</span>               <span class=m>0</span>                62.82MB           62.82MB <span class=o>(</span>100%<span class=o>)</span>
</span></span><span class=line><span class=cl>Local Volumes       <span class=m>9</span>               <span class=m>0</span>                652.2MB           652.2MB <span class=o>(</span>100%<span class=o>)</span>
</span></span><span class=line><span class=cl>Build Cache                                          0B                0B
</span></span></code></pre></td></tr></table></div></div><h4 id=虚悬镜像>虚悬镜像</h4><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none></code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&lt;none&gt;          &lt;none&gt;         00285df0df87      <span class=m>5</span> days ago        <span class=m>342</span> MB
</span></span></code></pre></td></tr></table></div></div><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none></code>。</p><p>除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。<strong>由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none></code> 的镜像</strong>。这类无标签镜像也被称为<strong>虚悬镜像（dangling image）</strong> ，可以用下面的命令专门显示这类镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -f <span class=nv>dangling</span><span class=o>=</span><span class=nb>true</span>
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>&lt;none&gt;              &lt;none&gt;              00285df0df87        <span class=m>5</span> days ago          <span class=m>342</span> MB
</span></span></code></pre></td></tr></table></div></div><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image prune
</span></span></code></pre></td></tr></table></div></div><h4 id=中间层镜像>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -a
</span></span></code></pre></td></tr></table></div></div><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。</p><p>这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。</p><p>实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h4 id=列出部分镜像>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p><strong>根据仓库名列出镜像</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls ubuntu
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>ubuntu              18.04               329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span><span class=line><span class=cl>ubuntu              bionic              329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span></code></pre></td></tr></table></div></div><p>列出特定的某个镜像，也就是说<strong>指定仓库名和标签</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls ubuntu:18.04
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>ubuntu              18.04               329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span></code></pre></td></tr></table></div></div><p>除此以外，<code>docker image ls</code> 还支持强大的<strong>过滤器参数</strong> <code>--filter</code>，或者简写 <code>-f</code>。</p><p>之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -f <span class=nv>since</span><span class=o>=</span>mongo:3.2
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>redis               latest              5f515359c7f8        <span class=m>5</span> days ago          <span class=m>183</span> MB
</span></span><span class=line><span class=cl>nginx               latest              05a60462f8ba        <span class=m>5</span> days ago          <span class=m>181</span> MB
</span></span></code></pre></td></tr></table></div></div><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -f <span class=nv>label</span><span class=o>=</span>com.example.version<span class=o>=</span>0.1
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><h3 id=删除本地镜像-docker-image-rm>删除本地镜像 <code>docker image rm</code></h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=o>[</span>选项<span class=o>]</span> &lt;镜像1&gt; <span class=o>[</span>&lt;镜像2&gt; ...<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=用-id镜像名摘要删除镜像>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像></code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY             TAG              IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>centos                 latest           0584b3d2cf6d        <span class=m>3</span> weeks ago         196.5 MB
</span></span><span class=line><span class=cl>redis                  alpine           501ad78535f0        <span class=m>3</span> weeks ago         21.03 MB
</span></span><span class=line><span class=cl>docker                 latest           cf693ec9b5c7        <span class=m>3</span> weeks ago         105.1 MB
</span></span><span class=line><span class=cl>nginx                  latest           e43d811ce2f4        <span class=m>5</span> weeks ago         181.5 MB
</span></span></code></pre></td></tr></table></div></div><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。</p><p><code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前 3 个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=m>501</span>
</span></span></code></pre></td></tr></table></div></div><p>我们也可以用 <code>镜像名</code>，也就是 <code>&lt;仓库名>:&lt;标签></code>，来删除镜像。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm centos
</span></span></code></pre></td></tr></table></div></div><blockquote><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p></blockquote><h4 id=untagged-和-deleted>Untagged 和 Deleted</h4><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在<strong>要求删除某个标签的镜像</strong>。这就是我们看到的 <code>Untagged</code> 的信息。</p><p>因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p><strong>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。</strong></p><p>镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。**直到没有任何层依赖当前层时，才会真实的删除当前层。**这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h4 id=用-docker-image-ls-命令来配合>用 docker image ls 命令来配合</h4><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=k>$(</span>docker image ls -q redis<span class=k>)</span>
</span></span></code></pre></td></tr></table></div></div><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=k>$(</span>docker image ls -q -f <span class=nv>before</span><span class=o>=</span>mongo:3.2<span class=k>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=操作容器>操作容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p><strong>容器的实质是进程</strong>，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href=https://en.wikipedia.org/wiki/Linux_namespaces target=_blank rel="external nofollow noopener noreferrer">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</p><p><strong>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样</strong></p><p>这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机</p><p>按照 Docker 最佳实践的要求，<strong>容器不应该向其存储层内写入任何数据</strong>，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href>数据卷（Volume）</a>、或者 <a href>绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p><strong>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡</strong>。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h3 id=启动>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h4 id=新建并启动-docker-run>新建并启动 <code>docker run</code></h4><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run ubuntu:18.04 /bin/echo <span class=s1>&#39;Hello world&#39;</span>
</span></span><span class=line><span class=cl>Hello world
</span></span></code></pre></td></tr></table></div></div><p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -t -i ubuntu:18.04 /bin/bash
</span></span><span class=line><span class=cl>root@af8bae53bdd3:/#
</span></span></code></pre></td></tr></table></div></div><p>其中，<code>-t</code> 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href>registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@ba267838cc1b:/# ps
</span></span><span class=line><span class=cl>  PID TTY          TIME CMD
</span></span><span class=line><span class=cl>    <span class=m>1</span> ?        00:00:00 bash
</span></span><span class=line><span class=cl>   <span class=m>11</span> ?        00:00:00 ps
</span></span></code></pre></td></tr></table></div></div><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h4 id=守护态运行--d>守护态运行 <code>-d</code></h4><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run ubuntu:18.04 /bin/sh -c <span class=s2>&#34;while true; do echo hello world; sleep 1; done&#34;</span>
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span></code></pre></td></tr></table></div></div><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d ubuntu:18.04 /bin/sh -c <span class=s2>&#34;while true; do echo hello world; sleep 1; done&#34;</span>
</span></span><span class=line><span class=cl>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</span></span></code></pre></td></tr></table></div></div><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面 (输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
</span></span><span class=line><span class=cl>77b2dc01fe0f  ubuntu:18.04  /bin/sh -c <span class=err>&#39;</span><span class=k>while</span> tr  <span class=m>2</span> minutes ago  Up <span class=m>1</span> minute        agitated_wright
</span></span></code></pre></td></tr></table></div></div><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container logs <span class=o>[</span>container ID or NAMES<span class=o>]</span>
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>. . .
</span></span></code></pre></td></tr></table></div></div><h3 id=终止-docker-container-stop>终止 <code>docker container stop</code></h3><p>可以使用 <code>docker container stop &lt;id></code>（或 <code>docker stop &lt;id></code>） 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls -a
</span></span><span class=line><span class=cl>CONTAINER ID     IMAGE        COMMAND       CREATED          STATUS        PORTS     NAMES
</span></span><span class=line><span class=cl>ba267838cc1b     ubuntu:18.04 <span class=s2>&#34;/bin/bash&#34;</span>   <span class=m>30</span> minutes ago   Exited <span class=o>(</span>0<span class=o>)</span> About a minute ago       trusting_newton
</span></span></code></pre></td></tr></table></div></div><p><strong>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</strong></p><p><strong>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</strong></p><h3 id=进入容器>进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h4 id=docker-attach><code>docker attach</code></h4><p>下面示例如何使用 <code>docker attach</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -dit ubuntu
</span></span><span class=line><span class=cl>243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span></span><span class=line><span class=cl>243c32535da7        ubuntu:latest       <span class=s2>&#34;/bin/bash&#34;</span>         <span class=m>18</span> seconds ago      Up <span class=m>17</span> seconds                           nostalgic_hypatia
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker attach 243c
</span></span><span class=line><span class=cl>root@243c32535da7:/#
</span></span></code></pre></td></tr></table></div></div><blockquote><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p></blockquote><h4 id=docker-exec><code>docker exec</code></h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -dit ubuntu
</span></span><span class=line><span class=cl>69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span></span><span class=line><span class=cl>69d137adef7a        ubuntu:latest       <span class=s2>&#34;/bin/bash&#34;</span>         <span class=m>18</span> seconds ago      Up <span class=m>17</span> seconds                           zealous_swirles
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>exec</span> -i 69d1 bash
</span></span><span class=line><span class=cl>ls
</span></span><span class=line><span class=cl>bin
</span></span><span class=line><span class=cl>boot
</span></span><span class=line><span class=cl>dev
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>exec</span> -it 69d1 bash
</span></span><span class=line><span class=cl>root@69d137adef7a:/#
</span></span></code></pre></td></tr></table></div></div><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><h3 id=导出和导入>导出和导入</h3><h4 id=导出容器-docker-export>导出容器 <code>docker export</code></h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls -a
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
</span></span><span class=line><span class=cl>7691a814370e        ubuntu:18.04        <span class=s2>&#34;/bin/bash&#34;</span>         <span class=m>36</span> hours ago        Exited <span class=o>(</span>0<span class=o>)</span> <span class=m>21</span> hours ago                       <span class=nb>test</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>export</span> 7691a814370e &gt; ubuntu.tar
</span></span></code></pre></td></tr></table></div></div><p>这样将导出容器快照到本地文件。</p><h4 id=导入容器快照-docker-import>导入容器快照 <code>docker import</code></h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat ubuntu.tar <span class=p>|</span> docker import - test/ubuntu:v1.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
</span></span><span class=line><span class=cl>test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB
</span></span></code></pre></td></tr></table></div></div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker import http://example.com/exampleimage.tgz example/imagerepo
</span></span></code></pre></td></tr></table></div></div><blockquote><p><em>用户既可以使用</em> <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。</p><p>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。</p><p>此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p></blockquote><h3 id=删除>删除</h3><h4 id=删除容器-docker-container-rm>删除容器 <code>docker container rm</code></h4><p>可以使用 <code>docker container rm</code>（或 <code>docker rm</code>）来删除一个<strong>处于终止状态</strong>的容器。例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container rm trusting_newton
</span></span><span class=line><span class=cl>trusting_newton
</span></span></code></pre></td></tr></table></div></div><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h4 id=清理所有处于终止状态的容器>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container prune
</span></span></code></pre></td></tr></table></div></div><h2 id=访问仓库>访问仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href>Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名>:&lt;标签></code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><p>大部分时候，并不需要严格区分这两者的概念。</p><h3 id=docker-hub>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href=https://hub.docker.com/ target=_blank rel="external nofollow noopener noreferrer">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target=_blank rel="external nofollow noopener noreferrer">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h4 id=登录-docker-login>登录 <code>docker login</code></h4><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录。</p><h4 id=拉取镜像-docker-pull>拉取镜像 <code>docker pull</code></h4><p>你可以通过 <strong><code>docker search</code></strong> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker search centos
</span></span><span class=line><span class=cl>NAME                     DESCRIPTION                        STARS     OFFICIAL  AUTOMATED
</span></span><span class=line><span class=cl>centos                   The official build of CentOS.      <span class=m>6449</span>        <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>ansible/centos7-ansible  Ansible on Centos7                 <span class=m>132</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>consol/centos-xfce-vnc   Centos container with …            <span class=m>126</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>jdeathe/centos-ssh       OpenSSH / Supervisor …             <span class=m>117</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>centos/systemd           systemd enabled base container.     <span class=m>96</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><ul><li><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p></li><li><p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p></li></ul><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull centos
</span></span><span class=line><span class=cl>Using default tag: latest
</span></span><span class=line><span class=cl>latest: Pulling from library/centos
</span></span><span class=line><span class=cl>7a0437f04f83: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> centos:latest
</span></span><span class=line><span class=cl>docker.io/library/centos:latest
</span></span></code></pre></td></tr></table></div></div><h4 id=推送镜像-docker-push>推送镜像 <code>docker push</code></h4><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker tag ubuntu:18.04 username/ubuntu:18.04
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY            TAG              IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>ubuntu                18.04            275d79972a86        <span class=m>6</span> days ago          94.6MB
</span></span><span class=line><span class=cl>username/ubuntu       18.04            275d79972a86        <span class=m>6</span> days ago          94.6MB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker push username/ubuntu:18.04
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker search username
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>NAME             DESCRIPTION         STARS           OFFICIAL        AUTOMATED
</span></span><span class=line><span class=cl>username/ubuntu
</span></span></code></pre></td></tr></table></div></div><h2 id=数据管理>数据管理</h2><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media" data-srcset="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media, https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media 1.5x, https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media 2x" data-sizes=auto alt="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media" title=img></p><p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><p>实际上，Docker 提供了三种不同的方式用于将宿主的数据挂载到容器中：volumes，bind mounts，tmpfs volumes。当你不知道该选择哪种方式时，记住，volumes 总是正确的选择。</p><h3 id=数据卷-volumn>数据卷 volumn</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间<strong>共享和重用</strong></li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会<strong>一直存在</strong>，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h4 id=创建一个数据卷>创建一个数据卷</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume create my-vol
</span></span></code></pre></td></tr></table></div></div><p>查看所有的 <code>数据卷</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>DRIVER              VOLUME NAME
</span></span><span class=line><span class=cl><span class=nb>local</span>               my-vol
</span></span></code></pre></td></tr></table></div></div><p>在主机里使用以下命令可以<strong>查看指定 <code>数据卷</code> 的信息</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume inspect my-vol
</span></span><span class=line><span class=cl><span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Driver&#34;</span>: <span class=s2>&#34;local&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Labels&#34;</span>: <span class=o>{}</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Mountpoint&#34;</span>: <span class=s2>&#34;/var/lib/docker/volumes/my-vol/_data&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Name&#34;</span>: <span class=s2>&#34;my-vol&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Options&#34;</span>: <span class=o>{}</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Scope&#34;</span>: <span class=s2>&#34;local&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=启动一个挂载数据卷的容器>启动一个挂载数据卷的容器</h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --name web <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=c1># -v my-vol:/usr/share/nginx/html \</span>
</span></span><span class=line><span class=cl>    --mount <span class=nv>source</span><span class=o>=</span>my-vol,target<span class=o>=</span>/usr/share/nginx/html <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h4 id=查看数据卷的具体信息>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker inspect web
</span></span></code></pre></td></tr></table></div></div><p><code>数据卷</code> 信息在 &ldquo;Mounts&rdquo; Key 下面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=s2>&#34;Mounts&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Type&#34;</span>: <span class=s2>&#34;volume&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Name&#34;</span>: <span class=s2>&#34;my-vol&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Source&#34;</span>: <span class=s2>&#34;/var/lib/docker/volumes/my-vol/_data&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Destination&#34;</span>: <span class=s2>&#34;/usr/share/nginx/html&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Driver&#34;</span>: <span class=s2>&#34;local&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Mode&#34;</span>: <span class=s2>&#34;&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;RW&#34;</span>: true,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Propagation&#34;</span>: <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>]</span>,
</span></span></code></pre></td></tr></table></div></div><h4 id=删除数据卷>删除数据卷</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume rm my-vol
</span></span></code></pre></td></tr></table></div></div><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。</p><p>如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume prune
</span></span></code></pre></td></tr></table></div></div><h3 id=挂载主机目录-bind-mount>挂载主机目录 bind mount</h3><h4 id=挂载一个主机目录作为数据卷>挂载一个主机目录作为数据卷</h4><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --name web <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=c1># -v /src/webapp:/usr/share/nginx/html \</span>
</span></span><span class=line><span class=cl>    --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span>/src/webapp,target<span class=o>=</span>/usr/share/nginx/html <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。</p><p>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是<strong>绝对路径</strong>，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --name web <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=c1># -v /src/webapp:/usr/share/nginx/html:ro \</span>
</span></span><span class=line><span class=cl>    --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span>/src/webapp,target<span class=o>=</span>/usr/share/nginx/html,readonly <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/usr/share/nginx/html <span class=c1># touch new.txt</span>
</span></span><span class=line><span class=cl>touch: new.txt: Read-only file system
</span></span></code></pre></td></tr></table></div></div><h4 id=查看数据卷的具体信息-1>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker inspect web
</span></span></code></pre></td></tr></table></div></div><p><code>挂载主机目录</code> 的配置信息在 &ldquo;Mounts&rdquo; Key 下面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=s2>&#34;Mounts&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Type&#34;</span>: <span class=s2>&#34;bind&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Source&#34;</span>: <span class=s2>&#34;/src/webapp&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Destination&#34;</span>: <span class=s2>&#34;/usr/share/nginx/html&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Mode&#34;</span>: <span class=s2>&#34;&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;RW&#34;</span>: true,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Propagation&#34;</span>: <span class=s2>&#34;rprivate&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>]</span>,
</span></span></code></pre></td></tr></table></div></div><h4 id=挂载一个本地主机文件作为数据卷>挂载一个本地主机文件作为数据卷</h4><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run --rm -it <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   <span class=c1># -v $HOME/.bash_history:/root/.bash_history \</span>
</span></span><span class=line><span class=cl>   --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span><span class=nv>$HOME</span>/.bash_history,target<span class=o>=</span>/root/.bash_history <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   ubuntu:18.04 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@2affd44b4667:/# <span class=nb>history</span>
</span></span><span class=line><span class=cl><span class=m>1</span>  ls
</span></span><span class=line><span class=cl><span class=m>2</span>  diskutil list
</span></span></code></pre></td></tr></table></div></div><p>这样就可以记录在容器输入过的命令了。</p><h3 id=volume-和-bind-的区别>volume 和 bind 的区别</h3><ul><li><p>volume：如果 volume 是空的而 container 中的目录有内容，那么 docker 会将 container 目录中的内容拷贝到 volume 中，但是如果 volume 中已经有内容，则会将 container 中的目录覆盖。</p></li><li><p>bind mount :不管 host 目录是否有值，都会覆盖 container 映射的目录</p></li></ul><h2 id=使用网络>使用网络</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h3 id=外部访问容器>外部访问容器</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会<strong>随机</strong>映射一个端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P nginx:alpine
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker container ls -l
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
</span></span><span class=line><span class=cl>fae320d08268        nginx:alpine        <span class=s2>&#34;/docker-entrypoint.…&#34;</span>   <span class=m>24</span> seconds ago      Up <span class=m>20</span> seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty
</span></span></code></pre></td></tr></table></div></div><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker logs fa
</span></span><span class=line><span class=cl>172.17.0.1 - - <span class=o>[</span>25/Aug/2020:08:34:04 +0000<span class=o>]</span> <span class=s2>&#34;GET / HTTP/1.1&#34;</span> <span class=m>200</span> <span class=m>612</span> <span class=s2>&#34;-&#34;</span> <span class=s2>&#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&#34;</span> <span class=s2>&#34;-&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</p><p>支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h4 id=映射所有接口地址>映射所有接口地址</h4><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 80:80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>此时默认会<strong>绑定本地所有接口上的所有地址</strong>。</p><h4 id=映射到指定地址的指定端口>映射到指定地址的指定端口</h4><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h4 id=映射到指定地址的任意端口>映射到指定地址的任意端口</h4><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 127.0.0.1::80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h4 id=查看映射端口配置-docker-port>查看映射端口配置 <code>docker port</code></h4><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker port fa <span class=m>80</span>
</span></span><span class=line><span class=cl>0.0.0.0:32768
</span></span></code></pre></td></tr></table></div></div><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -p 80:80 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -p 443:443 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h3 id=容器互联>容器互联</h3><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><h4 id=新建网络-docker-network-create>新建网络 <code>docker network create</code></h4><p>下面先创建一个新的 Docker 网络。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker network create -d bridge my-net
</span></span></code></pre></td></tr></table></div></div><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 和 <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href>Swarm mode</a>，在本小节中你可以忽略它。</p><h4 id=连接容器>连接容器</h4><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --rm --name busybox1 --network my-net busybox sh
</span></span></code></pre></td></tr></table></div></div><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --rm --name busybox2 --network my-net busybox sh
</span></span></code></pre></td></tr></table></div></div><p>再打开一个新的终端查看容器信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>CONTAINER ID    IMAGE         COMMAND   CREATED     STATUS  PORTS           NAMES
</span></span><span class=line><span class=cl>b47060aca56b    busybox       <span class=s2>&#34;sh&#34;</span>      <span class=m>11</span> minutes  ago     Up <span class=m>11</span> minutes   busybox2
</span></span><span class=line><span class=cl>8720575823ec    busybox       <span class=s2>&#34;sh&#34;</span>      <span class=m>16</span> minutes  ago     Up <span class=m>16</span> minutes   busybox1
</span></span></code></pre></td></tr></table></div></div><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ <span class=c1># ping busybox2</span>
</span></span><span class=line><span class=cl>PING busybox2 <span class=o>(</span>172.19.0.3<span class=o>)</span>: <span class=m>56</span> data bytes
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.3: <span class=nv>seq</span><span class=o>=</span><span class=m>0</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.072 ms
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.3: <span class=nv>seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.118 ms
</span></span></code></pre></td></tr></table></div></div><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ <span class=c1># ping busybox1</span>
</span></span><span class=line><span class=cl>PING busybox1 <span class=o>(</span>172.19.0.2<span class=o>)</span>: <span class=m>56</span> data bytes
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.2: <span class=nv>seq</span><span class=o>=</span><span class=m>0</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.064 ms
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.2: <span class=nv>seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.143 ms
</span></span></code></pre></td></tr></table></div></div><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h4 id=docker-compose>Docker Compose</h4><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。</p><h2 id=常用命令>常用命令</h2><p><a href="https://zhuanlan.zhihu.com/p/150951927#:~:text=Docker%20%28%E4%B8%80%29-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%201%201.%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A%20docker%20images%202%202.%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A,5.%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%9A%20docker%20restart%20mysql01%2010%206.%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20" target=_blank rel="external nofollow noopener noreferrer">https://zhuanlan.zhihu.com/p/150951927#:~:text=Docker%20%28%E4%B8%80%29-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%201%201.%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A%20docker%20images%202%202.%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A,5.%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%9A%20docker%20restart%20mysql01%2010%206.%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20</a></p><h2 id=使用-dockerfile-定制镜像->使用 Dockerfile 定制镜像 ⭐</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个<strong>脚本</strong>，用这个脚本来构建、定制镜像，那么一些无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir mynginx
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> mynginx
</span></span><span class=line><span class=cl>$ touch Dockerfile
</span></span></code></pre></td></tr></table></div></div><p>其内容为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>FROM nginx
</span></span><span class=line><span class=cl>RUN <span class=nb>echo</span> <span class=s1>&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></td></tr></table></div></div><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p><h3 id=from-指定基础镜像>FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 <code>nginx</code> 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 <code>FROM</code> 就是指定 <strong>基础镜像</strong>，因此一个 <code>Dockerfile</code> 中 <code>FROM</code> 是必备的指令，并且必须是第一条指令。</p><p>在 <a href="https://hub.docker.com/search?q=&type=image&image_filter=official" target=_blank rel="external nofollow noopener noreferrer">Docker Hub</a> 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 <a href=https://hub.docker.com/_/nginx/ target=_blank rel="external nofollow noopener noreferrer"><code>nginx</code></a>、<a href=https://hub.docker.com/_/redis/ target=_blank rel="external nofollow noopener noreferrer"><code>redis</code></a>、<a href=https://hub.docker.com/_/mongo/ target=_blank rel="external nofollow noopener noreferrer"><code>mongo</code></a>、<a href=https://hub.docker.com/_/mysql/ target=_blank rel="external nofollow noopener noreferrer"><code>mysql</code></a>、<a href=https://hub.docker.com/_/httpd/ target=_blank rel="external nofollow noopener noreferrer"><code>httpd</code></a>、<a href=https://hub.docker.com/_/php/ target=_blank rel="external nofollow noopener noreferrer"><code>php</code></a>、<a href=https://hub.docker.com/_/tomcat/ target=_blank rel="external nofollow noopener noreferrer"><code>tomcat</code></a> 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 <a href=https://hub.docker.com/_/node target=_blank rel="external nofollow noopener noreferrer"><code>node</code></a>、<a href=https://hub.docker.com/_/openjdk/ target=_blank rel="external nofollow noopener noreferrer"><code>openjdk</code></a>、<a href=https://hub.docker.com/_/python/ target=_blank rel="external nofollow noopener noreferrer"><code>python</code></a>、<a href=https://hub.docker.com/_/ruby/ target=_blank rel="external nofollow noopener noreferrer"><code>ruby</code></a>、<a href=https://hub.docker.com/_/golang/ target=_blank rel="external nofollow noopener noreferrer"><code>golang</code></a> 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p><p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 <a href=https://hub.docker.com/_/ubuntu/ target=_blank rel="external nofollow noopener noreferrer"><code>ubuntu</code></a>、<a href=https://hub.docker.com/_/debian/ target=_blank rel="external nofollow noopener noreferrer"><code>debian</code></a>、<a href=https://hub.docker.com/_/centos/ target=_blank rel="external nofollow noopener noreferrer"><code>centos</code></a>、<a href=https://hub.docker.com/_/fedora/ target=_blank rel="external nofollow noopener noreferrer"><code>fedora</code></a>、<a href=https://hub.docker.com/_/alpine/ target=_blank rel="external nofollow noopener noreferrer"><code>alpine</code></a> 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p><p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 <code>scratch</code>。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> scratch</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span>...<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>如果你以 <code>scratch</code> 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p><p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 <code>FROM scratch</code> 会让镜像体积更加小巧。使用 <a href=https://golang.google.cn target=_blank rel="external nofollow noopener noreferrer">Go 语言</a> 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p><h3 id=run-执行命令>RUN 执行命令</h3><p><code>RUN</code> 指令是用来执行命令行命令的。由于命令行的强大能力，<code>RUN</code> 指令在定制镜像时是最常用的指令之一。其格式有两种：</p><ul><li><em>shell</em> 格式：<code>RUN &lt;命令></code>，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 <code>RUN</code> 指令就是这种格式。</li><li><em>exec</em> 格式：<code>RUN ["可执行文件", "参数1", "参数2"]</code>，这更像是函数调用中的格式。</li></ul><p>既然 <code>RUN</code> 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:stretch</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get install -y gcc libc6-dev make wget<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> wget -O redis.tar.gz <span class=s2>&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir -p /usr/src/redis<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class=o>=</span><span class=m>1</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> make -C /usr/src/redis<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> make -C /usr/src/redis install<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>之前说过，Dockerfile 中<strong>每一个指令都会建立一层</strong>，<code>RUN</code> 也不例外。每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p><blockquote><p><em>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</em></p></blockquote><p>上面的 <code>Dockerfile</code> 正确的写法应该是这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> debian:stretch</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>set</span> -x<span class=p>;</span> <span class=nv>buildDeps</span><span class=o>=</span><span class=s1>&#39;gcc libc6-dev make wget&#39;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> apt-get update <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> apt-get install -y <span class=nv>$buildDeps</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> wget -O redis.tar.gz <span class=s2>&#34;http://download.redis.io/releases/redis-5.0.3.tar.gz&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> mkdir -p /usr/src/redis <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> tar -xzf redis.tar.gz -C /usr/src/redis --strip-components<span class=o>=</span><span class=m>1</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> make -C /usr/src/redis <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> make -C /usr/src/redis install <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> rm -rf /var/lib/apt/lists/* <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> rm redis.tar.gz <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> rm -r /usr/src/redis <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> apt-get purge -y --auto-remove <span class=nv>$buildDeps</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此<strong>没有必要建立很多层</strong>，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&&</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p><p>并且，这里为了<strong>格式化</strong>还进行了换行。Dockerfile 支持 Shell 类的行尾添加 <code>\</code> 的命令换行方式，以及行首 <code>#</code> 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p><p>此外，还可以看到这一组命令的最后添加了<strong>清理工作</strong>的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p><h3 id=构建镜像-docker->构建镜像 <code>docker</code></h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p><p>在 <code>Dockerfile</code> 文件所在目录执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build -t nginx:v3 .
</span></span><span class=line><span class=cl>Sending build context to Docker daemon 2.048 kB
</span></span><span class=line><span class=cl>Step <span class=m>1</span> : FROM nginx
</span></span><span class=line><span class=cl> ---&gt; e43d811ce2f4
</span></span><span class=line><span class=cl>Step <span class=m>2</span> : RUN <span class=nb>echo</span> <span class=s1>&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span><span class=line><span class=cl> ---&gt; Running in 9cdc27646c7b
</span></span><span class=line><span class=cl> ---&gt; 44aa4490ce2c
</span></span><span class=line><span class=cl>Removing intermediate container 9cdc27646c7b
</span></span><span class=line><span class=cl>Successfully built 44aa4490ce2c
</span></span></code></pre></td></tr></table></div></div><p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 <code>Step 2</code> 中，如同我们之前所说的那样，<code>RUN</code> 指令启动了一个容器 <code>9cdc27646c7b</code>，执行了所要求的命令，并最后提交了这一层 <code>44aa4490ce2c</code>，随后删除了所用到的这个容器 <code>9cdc27646c7b</code>。</p><p>这里我们使用了 <code>docker build</code> 命令进行镜像构建。其格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>docker build <span class=o>[</span>选项<span class=o>]</span> &lt;上下文路径/URL/-&gt;
</span></span></code></pre></td></tr></table></div></div><p>在这里我们指定了最终镜像的名称 <code>-t nginx:v3</code>，构建成功后，我们可以像之前运行 <code>nginx:v2</code> 那样来运行这个镜像，其结果会和 <code>nginx:v2</code> 一样。</p><h3 id=镜像构建上下文context>镜像构建上下文（Context）</h3><p>如果注意，会看到 <code>docker build</code> 命令最后有一个 <code>.</code>。</p><p><code>.</code> 表示当前目录，而 <code>Dockerfile</code> 就在当前目录，因此不少初学者以为这个路径是在指定 <code>Dockerfile</code> 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定 <strong>上下文路径</strong>。那么什么是上下文呢？</p><p>首先我们要理解 <code>docker build</code> 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 <a href=https://docs.docker.com/develop/sdk/ target=_blank rel="external nofollow noopener noreferrer">Docker Remote API</a>，而如 <code>docker</code> 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 <code>docker</code> 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 <code>docker build</code> 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，<code>docker build</code> 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>如果在 <code>Dockerfile</code> 中这么写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>COPY</span> ./package.json /app/<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这并不是要复制执行 <code>docker build</code> 命令所在的目录下的 <code>package.json</code>，也不是复制 <code>Dockerfile</code> 所在目录下的 <code>package.json</code>，而是复制 <strong>上下文（context）</strong> 目录下的 <code>package.json</code>。</p><p>因此，<code>COPY</code> 这类指令中的源文件的路径都是<em>相对路径</em>。这也是初学者经常会问的为什么 <code>COPY ../package.json /app</code> 或者 <code>COPY /opt/xxxx /app</code> 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p><p>现在就可以理解刚才的命令 <code>docker build -t nginx:v3 .</code> 中的这个 <code>.</code>，实际上是在指定上下文的目录，<code>docker build</code> 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p><p>如果观察 <code>docker build</code> 输出，我们其实已经看到了这个发送上下文的过程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build -t nginx:v3 .
</span></span><span class=line><span class=cl>Sending build context to Docker daemon 2.048 kB
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 <code>COPY /opt/xxxx /app</code> 不工作后，于是干脆将 <code>Dockerfile</code> 放到了硬盘根目录去构建，结果发现 <code>docker build</code> 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 <code>docker build</code> 打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将 <code>Dockerfile</code> 置于一个空目录下，或者<strong>项目根目录下</strong>。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，<strong>那么可以用 <code>.gitignore</code> 一样的语法写一个 <code>.dockerignore</code></strong>，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><p>那么为什么会有人误以为 <code>.</code> 是指定 <code>Dockerfile</code> 所在目录呢？这是因为在默认情况下，如果不额外指定 <code>Dockerfile</code> 的话，会将上下文目录下的名为 <code>Dockerfile</code> 的文件作为 Dockerfile。</p><p>这只是默认行为，实际上 <code>Dockerfile</code> 的文件名并不要求必须为 <code>Dockerfile</code>，而且并不要求必须位于上下文目录中，比如可以用 <code>-f ../Dockerfile.php</code> 参数指定某个文件作为 <code>Dockerfile</code>。</p><p>当然，一般大家习惯性的会使用默认的文件名 <code>Dockerfile</code>，以及会将其置于镜像构建上下文目录中。</p><h3 id=其它-docker-build-的用法>其它 <code>docker build</code> 的用法</h3><h4 id=直接用-git-repo-进行构建>直接用 Git repo 进行构建</h4><p>或许你已经注意到了，<code>docker build</code> 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=c1># $env:DOCKER_BUILDKIT=0</span>
</span></span><span class=line><span class=cl><span class=c1># export DOCKER_BUILDKIT=0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker build -t hello-world https://github.com/docker-library/hello-world.git#master:amd64/hello-world
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Step 1/3 : FROM scratch
</span></span><span class=line><span class=cl> ---&gt;
</span></span><span class=line><span class=cl>Step 2/3 : COPY hello /
</span></span><span class=line><span class=cl> ---&gt; ac779757d46e
</span></span><span class=line><span class=cl>Step 3/3 : CMD <span class=o>[</span><span class=s2>&#34;/hello&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl> ---&gt; Running in d2a513a760ed
</span></span><span class=line><span class=cl>Removing intermediate container d2a513a760ed
</span></span><span class=line><span class=cl> ---&gt; 038ad4142d2b
</span></span><span class=line><span class=cl>Successfully built 038ad4142d2b
</span></span></code></pre></td></tr></table></div></div><p>这行命令指定了构建所需的 Git repo，并且指定分支为 <code>master</code>，构建目录为 <code>/amd64/hello-world/</code>，然后 Docker 就会自己去 <code>git clone</code> 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p><h4 id=用给定的-tar-压缩包构建>用给定的 tar 压缩包构建</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build http://server/context.tar.gz
</span></span></code></pre></td></tr></table></div></div><p>如果所给出的 URL 不是个 Git repo，而是个 <code>tar</code> 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p><h4 id=从标准输入中读取-dockerfile-进行构建>从标准输入中读取 Dockerfile 进行构建</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build - &lt; Dockerfile
</span></span></code></pre></td></tr></table></div></div><p>或</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat Dockerfile <span class=p>|</span> docker build -
</span></span></code></pre></td></tr></table></div></div><p>如果标准输入传入的是文本文件，则将其视为 <code>Dockerfile</code>，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 <code>COPY</code> 进镜像之类的事情。</p><h4 id=从标准输入中读取上下文压缩包进行构建>从标准输入中读取上下文压缩包进行构建</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build - &lt; context.tar.gz
</span></span></code></pre></td></tr></table></div></div><p>如果发现标准输入的文件格式是 <code>gzip</code>、<code>bzip2</code> 以及 <code>xz</code> 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h2 id=dockerfile-指令详解>Dockerfile 指令详解</h2><h3 id=copy-复制文件>COPY 复制文件</h3><p>格式：</p><ul><li><code>COPY [--chown=&lt;user>:&lt;group>] &lt;源路径>... &lt;目标路径></code></li><li><code>COPY [--chown=&lt;user>:&lt;group>] ["&lt;源路径1>",... "&lt;目标路径>"]</code></li></ul><p>和 <code>RUN</code> 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p><p><code>COPY</code> 指令将从构建上下文目录中 <code>&lt;源路径></code> 的文件/目录复制到新的一层的镜像内的 <code>&lt;目标路径></code> 位置。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>COPY</span> package.json /usr/src/app/<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><code>&lt;源路径></code> 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 <a href=https://golang.org/pkg/path/filepath/#Match target=_blank rel="external nofollow noopener noreferrer"><code>filepath.Match</code></a> 规则，如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>COPY</span> hom* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> hom?.txt /mydir/<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><code>&lt;目标路径></code> 可以是<strong>容器内的绝对路径</strong>，也可以是<strong>相对于工作目录的相对路径</strong>（工作目录可以用 <code>WORKDIR</code> 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 <code>COPY</code> 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user>:&lt;group></code> 选项来改变文件的所属用户及所属组。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>COPY</span> --chown<span class=o>=</span>55:mygroup files* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --chown<span class=o>=</span>bin files* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --chown<span class=o>=</span><span class=m>1</span> files* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --chown<span class=o>=</span>10:11 files* /mydir/<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>⭐ 如果源路径为文件夹，复制的时候不是直接复制该文件夹，而是将<strong>文件夹中的内容</strong>复制到目标路径。</p><h3 id=add-更高级的复制文件>ADD 更高级的复制文件</h3><p><code>ADD</code> 指令和 <code>COPY</code> 的格式和性质基本一致。但是在 <code>COPY</code> 基础上增加了一些功能。</p><p>比如 <code>&lt;源路径></code> 可以是一个 <code>URL</code>，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 <code>&lt;目标路径></code> 去。下载后的文件权限自动设置为 <code>600</code>，如果这并不是想要的权限，那么还需要增加额外的一层 <code>RUN</code> 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 <code>RUN</code> 指令进行解压缩。所以不如直接使用 <code>RUN</code> 指令，然后使用 <code>wget</code> 或者 <code>curl</code> 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实<strong>并不实用，而且不推荐使用</strong>。</p><p>如果 <code>&lt;源路径></code> 为一个 <code>tar</code> 压缩文件的话，压缩格式为 <code>gzip</code>, <code>bzip2</code> 以及 <code>xz</code> 的情况下，<code>ADD</code> 指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径></code> 去。</p><p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 <code>ubuntu</code> 中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>FROM scratch
</span></span><span class=line><span class=cl>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 <code>ADD</code> 命令了。</p><p>在 Docker 官方的 <a href>Dockerfile 最佳实践文档</a> 中要求，尽可能的使用 <code>COPY</code>，因为 <code>COPY</code> 的语义很明确，就是复制文件而已，而 <code>ADD</code> 则包含了更复杂的功能，其行为也不一定很清晰。最<strong>适合使用 <code>ADD</code> 的场合，就是所提及的需要自动解压缩的场合。</strong></p><p>另外需要注意的是，<code>ADD</code> 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p><p>因此在 <code>COPY</code> 和 <code>ADD</code> 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 <code>COPY</code> 指令，仅在需要自动解压缩的场合使用 <code>ADD</code>。</p><p>在使用该指令的时候还可以加上 <code>--chown=&lt;user>:&lt;group></code> 选项来改变文件的所属用户及所属组。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ADD</span> --chown<span class=o>=</span>55:mygroup files* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> --chown<span class=o>=</span>bin files* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> --chown<span class=o>=</span><span class=m>1</span> files* /mydir/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ADD</span> --chown<span class=o>=</span>10:11 files* /mydir/<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=cmd-容器启动命令>CMD 容器启动命令</h3><p>指定容器启动程序及参数</p><p><code>CMD</code> 指令的格式和 <code>RUN</code> 相似，也是两种格式：</p><ul><li><code>shell</code> 格式：<code>CMD &lt;命令></code></li><li><code>exec</code> 格式：<code>CMD ["可执行文件", "参数1", "参数2"...]</code></li><li>参数列表格式：<code>CMD ["参数1", "参数2"...]</code>。在指定了 <code>ENTRYPOINT</code> 指令后，用 <code>CMD</code> 指定具体的参数。</li></ul><p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。<code>CMD</code> 指令就是用于指定默认的容器主进程的启动命令的。</p><p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，<code>ubuntu</code> 镜像默认的 <code>CMD</code> 是 <code>/bin/bash</code>，如果我们直接 <code>docker run -it ubuntu</code> 的话，会直接进入 <code>bash</code>。我们也可以在运行时指定运行别的命令，如 <code>docker run -it ubuntu cat /etc/os-release</code>。这就是用 <code>cat /etc/os-release</code> 命令替换了默认的 <code>/bin/bash</code> 命令了，输出了系统版本信息。</p><p>在指令格式上，一般推荐使用 <code>exec</code> 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 <code>"</code>，而不要使用单引号。</p><p>如果使用 <code>shell</code> 格式的话，实际的命令会被包装为 <code>sh -c</code> 的参数的形式进行执行。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>CMD</span> <span class=nb>echo</span> <span class=nv>$HOME</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>在实际执行中，会将其变更为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>CMD</span> <span class=p>[</span> <span class=s2>&#34;sh&#34;</span><span class=p>,</span> <span class=s2>&#34;-c&#34;</span><span class=p>,</span> <span class=s2>&#34;echo $HOME&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p><p>提到 <code>CMD</code> 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p><p>Docker 不是虚拟机，<strong>容器中的应用都应该以前台执行</strong>，而不是像虚拟机、物理机里面那样，用 <code>systemd</code> 去启动后台服务，<strong>容器内没有后台服务的概念</strong>。</p><p>一些初学者将 <code>CMD</code> 写为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>CMD</span> service nginx start<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>然后发现容器执行后就立即退出了。甚至在容器内去使用 <code>systemctl</code> 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p><p>而使用 <code>service nginx start</code> 命令，则是希望 upstart 来以后台守护进程形式启动 <code>nginx</code> 服务。而刚才说了 <code>CMD service nginx start</code> 会被理解为 <code>CMD [ "sh", "-c", "service nginx start"]</code>，因此主进程实际上是 <code>sh</code>。那么当 <code>service nginx start</code> 命令结束后，<code>sh</code> 也就结束了，<code>sh</code> 作为主进程退出了，自然就会令容器退出。</p><p>正确的做法是直接执行 <code>nginx</code> 可执行文件，并且要求以前台形式运行。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;nginx&#34;</span><span class=p>,</span> <span class=s2>&#34;-g&#34;</span><span class=p>,</span> <span class=s2>&#34;daemon off;&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=entrypoint-入口点>ENTRYPOINT 入口点</h3><p><code>ENTRYPOINT</code> 的格式和 <code>RUN</code> 指令格式一样，分为 <code>exec</code> 格式和 <code>shell</code> 格式。</p><p><code>ENTRYPOINT</code> 的目的和 <code>CMD</code> 一样，都是在指定容器启动程序及参数。<code>ENTRYPOINT</code> 在运行时也可以替代，不过比 <code>CMD</code> 要略显繁琐，需要通过 <code>docker run</code> 的参数 <code>--entrypoint</code> 来指定。</p><p>当指定了 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的含义就发生了改变，不再是直接的运行其命令，而是<strong>将 <code>CMD</code> 的内容作为参数传给 <code>ENTRYPOINT</code> 指令</strong>，换句话说实际执行时，将变为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&lt;ENTRYPOINT&gt; <span class=s2>&#34;&lt;CMD&gt;&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>那么有了 <code>CMD</code> 后，为什么还要有 <code>ENTRYPOINT</code> 呢？这种 <code>&lt;ENTRYPOINT> "&lt;CMD>"</code> 有什么好处么？让我们来看几个场景。</p><h4 id=场景一让镜像变成像命令一样使用>场景一：让镜像变成像命令一样使用</h4><p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 <code>CMD</code> 来实现：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> ubuntu:18.04</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> apt-get install -y curl <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span> <span class=s2>&#34;curl&#34;</span><span class=p>,</span> <span class=s2>&#34;-s&#34;</span><span class=p>,</span> <span class=s2>&#34;http://myip.ipip.net&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>假如我们使用 <code>docker build -t myip .</code> 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run myip
</span></span><span class=line><span class=cl>当前 IP：61.148.226.66 来自：北京市 联通
</span></span></code></pre></td></tr></table></div></div><p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 <code>CMD</code> 中可以看到实质的命令是 <code>curl</code>，那么如果我们希望显示 HTTP 头信息，就需要加上 <code>-i</code> 参数。那么我们可以直接加 <code>-i</code> 参数给 <code>docker run myip</code> 么？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run myip -i
</span></span><span class=line><span class=cl>docker: Error response from daemon: invalid header field value <span class=s2>&#34;oci runtime error: container_linux.go:247: starting container process caused \&#34;exec: \\\&#34;-i\\\&#34;: executable file not found in </span><span class=nv>$PATH</span><span class=s2>\&#34;\n&#34;</span>.
</span></span></code></pre></td></tr></table></div></div><p>我们可以看到可执行文件找不到的报错，<code>executable file not found</code>。之前我们说过，跟在镜像名后面的是 <code>command</code>，运行时会替换 <code>CMD</code> 的默认值。因此这里的 <code>-i</code> 替换了原来的 <code>CMD</code>，而不是添加在原来的 <code>curl -s http://myip.ipip.net</code> 后面。而 <code>-i</code> 根本不是命令，所以自然找不到。</p><p>那么如果我们希望加入 <code>-i</code> 这参数，我们就必须重新完整的输入这个命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run myip curl -s http://myip.ipip.net -i
</span></span></code></pre></td></tr></table></div></div><p>这显然不是很好的解决方案，而使用 <code>ENTRYPOINT</code> 就可以解决这个问题。现在我们重新用 <code>ENTRYPOINT</code> 来实现这个镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>FROM ubuntu:18.04
</span></span><span class=line><span class=cl>RUN apt-get update <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> apt-get install -y curl <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> rm -rf /var/lib/apt/lists/*
</span></span><span class=line><span class=cl>ENTRYPOINT <span class=o>[</span> <span class=s2>&#34;curl&#34;</span>, <span class=s2>&#34;-s&#34;</span>, <span class=s2>&#34;http://myip.ipip.net&#34;</span> <span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>这次我们再来尝试直接使用 <code>docker run myip -i</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run myip
</span></span><span class=line><span class=cl>当前 IP：61.148.226.66 来自：北京市 联通
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker run myip -i
</span></span><span class=line><span class=cl>HTTP/1.1 <span class=m>200</span> OK
</span></span><span class=line><span class=cl>Server: nginx/1.8.0
</span></span><span class=line><span class=cl>Date: Tue, <span class=m>22</span> Nov <span class=m>2016</span> 05:12:40 GMT
</span></span><span class=line><span class=cl>Content-Type: text/html<span class=p>;</span> <span class=nv>charset</span><span class=o>=</span>UTF-8
</span></span><span class=line><span class=cl>Vary: Accept-Encoding
</span></span><span class=line><span class=cl>X-Powered-By: PHP/5.6.24-1~dotdeb+7.1
</span></span><span class=line><span class=cl>X-Cache: MISS from cache-2
</span></span><span class=line><span class=cl>X-Cache-Lookup: MISS from cache-2:80
</span></span><span class=line><span class=cl>X-Cache: MISS from proxy-2_6
</span></span><span class=line><span class=cl>Transfer-Encoding: chunked
</span></span><span class=line><span class=cl>Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006
</span></span><span class=line><span class=cl>Connection: keep-alive
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>当前 IP：61.148.226.66 来自：北京市 联通
</span></span></code></pre></td></tr></table></div></div><p>可以看到，这次成功了。这是因为当存在 <code>ENTRYPOINT</code> 后，<code>CMD</code> 的内容将会作为参数传给 <code>ENTRYPOINT</code>，而这里 <code>-i</code> 就是新的 <code>CMD</code>，因此会作为参数传给 <code>curl</code>，从而达到了我们预期的效果。</p><h4 id=场景二应用运行前的准备工作>场景二：应用运行前的准备工作</h4><p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p><p>比如 <code>mysql</code> 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p><p>此外，可能希望避免使用 <code>root</code> 用户去启动服务，从而提高安全性，而在启动服务前还需要以 <code>root</code> 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 <code>root</code> 身份执行，方便调试等。</p><p>这些准备工作是和容器 <code>CMD</code> 无关的，无论 <code>CMD</code> 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 <code>ENTRYPOINT</code> 中去执行，而这个脚本会将接到的参数（也就是 <code>&lt;CMD></code>）作为命令，在脚本最后执行。比如官方镜像 <code>redis</code> 中就是这么做的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>FROM alpine:3.4
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>RUN addgroup -S redis <span class=o>&amp;&amp;</span> adduser -S -G redis redis
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>ENTRYPOINT <span class=o>[</span><span class=s2>&#34;docker-entrypoint.sh&#34;</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>EXPOSE <span class=m>6379</span>
</span></span><span class=line><span class=cl>CMD <span class=o>[</span> <span class=s2>&#34;redis-server&#34;</span> <span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 <code>ENTRYPOINT</code> 为 <code>docker-entrypoint.sh</code> 脚本。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span>...
</span></span><span class=line><span class=cl><span class=c1># allow the container to be started with `--user`</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[</span> <span class=s2>&#34;</span><span class=nv>$1</span><span class=s2>&#34;</span> <span class=o>=</span> <span class=s1>&#39;redis-server&#39;</span> -a <span class=s2>&#34;</span><span class=k>$(</span>id -u<span class=k>)</span><span class=s2>&#34;</span> <span class=o>=</span> <span class=s1>&#39;0&#39;</span> <span class=o>]</span><span class=p>;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>	find . <span class=se>\!</span> -user redis -exec chown redis <span class=s1>&#39;{}&#39;</span> +
</span></span><span class=line><span class=cl>	<span class=nb>exec</span> gosu redis <span class=s2>&#34;</span><span class=nv>$0</span><span class=s2>&#34;</span> <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>exec</span> <span class=s2>&#34;</span><span class=nv>$@</span><span class=s2>&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>该脚本的内容就是根据 <code>CMD</code> 的内容来判断，如果是 <code>redis-server</code> 的话，则切换到 <code>redis</code> 用户身份启动服务器，否则依旧使用 <code>root</code> 身份执行。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it redis id
</span></span><span class=line><span class=cl><span class=nv>uid</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span> <span class=nv>gid</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span> <span class=nv>groups</span><span class=o>=</span>0<span class=o>(</span>root<span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=env-设置环境变量>ENV 设置环境变量</h3><p>格式有两种：</p><ul><li><code>ENV &lt;key> &lt;value></code></li><li><code>ENV &lt;key1>=&lt;value1> &lt;key2>=&lt;value2>...</code></li></ul><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 <code>RUN</code>，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> <span class=nv>VERSION</span><span class=o>=</span><span class=m>1</span>.0 <span class=nv>DEBUG</span><span class=o>=</span>on <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=nv>NAME</span><span class=o>=</span><span class=s2>&#34;Happy Feet&#34;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 <code>node</code> 镜像 <code>Dockerfile</code> 中，就有类似这样的代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ENV</span> NODE_VERSION 7.2.0<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> curl -SLO <span class=s2>&#34;https://nodejs.org/dist/v</span><span class=nv>$NODE_VERSION</span><span class=s2>/node-v</span><span class=nv>$NODE_VERSION</span><span class=s2>-linux-x64.tar.xz&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> curl -SLO <span class=s2>&#34;https://nodejs.org/dist/v</span><span class=nv>$NODE_VERSION</span><span class=s2>/SHASUMS256.txt.asc&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> grep <span class=s2>&#34; node-v</span><span class=nv>$NODE_VERSION</span><span class=s2>-linux-x64.tar.xz\$&#34;</span> SHASUMS256.txt <span class=p>|</span> sha256sum -c - <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> tar -xJf <span class=s2>&#34;node-v</span><span class=nv>$NODE_VERSION</span><span class=s2>-linux-x64.tar.xz&#34;</span> -C /usr/local --strip-components<span class=o>=</span><span class=m>1</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> rm <span class=s2>&#34;node-v</span><span class=nv>$NODE_VERSION</span><span class=s2>-linux-x64.tar.xz&#34;</span> SHASUMS256.txt.asc SHASUMS256.txt <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> ln -s /usr/local/bin/node /usr/local/bin/nodejs<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>在这里先定义了环境变量 <code>NODE_VERSION</code>，其后的 <code>RUN</code> 这层里，多次使用 <code>$NODE_VERSION</code> 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 <code>7.2.0</code> 即可，<code>Dockerfile</code> 构建维护变得更轻松了。</p><p>下列指令可以支持环境变量展开： <code>ADD</code>、<code>COPY</code>、<code>ENV</code>、<code>EXPOSE</code>、<code>FROM</code>、<code>LABEL</code>、<code>USER</code>、<code>WORKDIR</code>、<code>VOLUME</code>、<code>STOPSIGNAL</code>、<code>ONBUILD</code>、<code>RUN</code>。</p><p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 <code>Dockerfile</code> 制作更多的镜像，只需使用不同的环境变量即可。</p><h3 id=arg-构建参数>ARG 构建参数</h3><p>格式：<code>ARG &lt;参数名>[=&lt;默认值>]</code></p><p>构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</p><p><code>Dockerfile</code> 中的 <code>ARG</code> 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 <code>docker build</code> 中用 <code>--build-arg &lt;参数名>=&lt;值></code> 来覆盖。</p><p>灵活的使用 <code>ARG</code> 指令，能够在不修改 Dockerfile 的情况下，构建出不同的镜像。</p><p>ARG 指令有生效范围，<strong>如果在 <code>FROM</code> 指令之前指定，那么只能用于 <code>FROM</code> 指令中。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>FROM</span><span class=s> ${DOCKER_USERNAME}/alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>set</span> -x <span class=p>;</span> <span class=nb>echo</span> <span class=si>${</span><span class=nv>DOCKER_USERNAME</span><span class=si>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>使用上述 Dockerfile 会发现无法输出 <code>${DOCKER_USERNAME}</code> 变量的值，要想正常输出，你必须在 <code>FROM</code> 之后再次指定 <code>ARG</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 只在 FROM 中生效</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>FROM</span><span class=s> ${DOCKER_USERNAME}/alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 要想在 FROM 之后使用，必须再次指定</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>RUN</span> <span class=nb>set</span> -x <span class=p>;</span> <span class=nb>echo</span> <span class=si>${</span><span class=nv>DOCKER_USERNAME</span><span class=si>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>对于多阶段构建，尤其要注意这个问题</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 这个变量在每个 FROM 中都生效</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>FROM</span><span class=s> ${DOCKER_USERNAME}/alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>set</span> -x <span class=p>;</span> <span class=nb>echo</span> <span class=m>1</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> ${DOCKER_USERNAME}/alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>set</span> -x <span class=p>;</span> <span class=nb>echo</span> <span class=m>2</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>对于上述 Dockerfile 两个 <code>FROM</code> 指令都可以使用 <code>${DOCKER_USERNAME}</code>，对于在各个阶段中使用的变量都必须在每个阶段分别指定</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>FROM</span><span class=s> ${DOCKER_USERNAME}/alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 在FROM 之后使用变量，必须在每个阶段分别指定</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>RUN</span> <span class=nb>set</span> -x <span class=p>;</span> <span class=nb>echo</span> <span class=si>${</span><span class=nv>DOCKER_USERNAME</span><span class=si>}</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> ${DOCKER_USERNAME}/alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 在FROM 之后使用变量，必须在每个阶段分别指定</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ARG</span> <span class=nv>DOCKER_USERNAME</span><span class=o>=</span>library
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>RUN</span> <span class=nb>set</span> -x <span class=p>;</span> <span class=nb>echo</span> <span class=si>${</span><span class=nv>DOCKER_USERNAME</span><span class=si>}</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=volume-定义匿名卷>VOLUME 定义匿名卷</h3><p>格式为：</p><ul><li><code>VOLUME ["&lt;路径1>", "&lt;路径2>"...]</code></li><li><code>VOLUME &lt;路径></code></li></ul><p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷 (volume) 中；为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 <code>Dockerfile</code> 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>VOLUME</span><span class=s> /data</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这里的 <code>/data</code> 目录就会在容器运行时自动挂载为匿名卷，任何向 <code>/data</code> 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行容器时可以覆盖这个挂载设置。比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl>$ docker run -d ·mydata:/data xxxx<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>在这行命令中，就使用了 <code>mydata</code> 这个命名卷挂载到了 <code>/data</code> 这个位置，替代了 <code>Dockerfile</code> 中定义的匿名卷的挂载配置。</p><h3 id=expose-暴露端口>EXPOSE 暴露端口</h3><p>格式为 <code>EXPOSE &lt;端口1> [&lt;端口2>...]</code>。</p><p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，<strong>这只是一个声明</strong>，在容器运行时并不会因为这个声明应用就会开启这个端口的服务。</p><p>在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</p><p>应该将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口>:&lt;容器端口></code> 区分开来。</p><ul><li><code>-p</code>，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问</li><li>而 <code>EXPOSE</code> 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</li></ul><h3 id=workdir-指定工作目录>WORKDIR 指定工作目录</h3><p>格式为 <code>WORKDIR &lt;工作目录路径></code>。</p><p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p><p>之前提到一些初学者常犯的错误是把 <code>Dockerfile</code> 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>RUN</span> <span class=nb>cd</span> /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span> &gt; world.txt<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>如果将这个 <code>Dockerfile</code> 进行构建镜像运行后，会发现找不到 <code>/app/world.txt</code> 文件，或者其内容不是 <code>hello</code>。</p><p>原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 <code>Dockerfile</code> 中，<strong>这两行 <code>RUN</code> 命令的执行环境根本不同，是两个完全不同的容器</strong>。这就是对 <code>Dockerfile</code> 构建<strong>分层存储</strong>的概念不了解所导致的错误。</p><p>之前说过每一个 <code>RUN</code> 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 <code>RUN cd /app</code> 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p><p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 <code>WORKDIR</code> 指令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nb>echo</span> <span class=s2>&#34;hello&#34;</span> &gt; world.txt<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>如果你的 <code>WORKDIR</code> 指令使用的相对路径，那么所切换的路径与之前的 <code>WORKDIR</code> 有关</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>WORKDIR</span><span class=s> /a</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> b</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> c</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> pwd<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p><code>RUN pwd</code> 的工作目录为 <code>/a/b/c</code>。</p><h3 id=user-指定当前用户>USER 指定当前用户</h3><p>格式：<code>USER &lt;用户名>[:&lt;用户组>]</code></p><p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p><p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>RUN</span> groupadd -r redis <span class=o>&amp;&amp;</span> useradd -r -g redis redis<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>USER</span><span class=s> redis</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=o>[</span> <span class=s2>&#34;redis-server&#34;</span> <span class=o>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a href=https://github.com/tianon/gosu target=_blank rel="external nofollow noopener noreferrer"><code>gosu</code></a>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=c># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> groupadd -r redis <span class=o>&amp;&amp;</span> useradd -r -g redis redis<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 下载 gosu</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> wget -O /usr/local/bin/gosu <span class=s2>&#34;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> chmod +x /usr/local/bin/gosu <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=o>&amp;&amp;</span> gosu nobody true<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># 设置 CMD，并以另外的用户执行</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span> <span class=s2>&#34;exec&#34;</span><span class=p>,</span> <span class=s2>&#34;gosu&#34;</span><span class=p>,</span> <span class=s2>&#34;redis&#34;</span><span class=p>,</span> <span class=s2>&#34;redis-server&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=healthcheck-健康检查>HEALTHCHECK 健康检查</h3><p>格式：</p><ul><li><code>HEALTHCHECK [选项] CMD &lt;命令></code>：设置检查容器健康状况的命令</li><li><code>HEALTHCHECK NONE</code>：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</li></ul><p><code>HEALTHCHECK</code> 指令是告诉 Docker <strong>应该如何进行判断容器的状态是否正常</strong>，这是 Docker 1.12 引入的新指令。</p><p>在没有 <code>HEALTHCHECK</code> 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p><p>而自 1.12 之后，Docker 提供了 <code>HEALTHCHECK</code> 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了 <code>HEALTHCHECK</code> 指令后，用其启动容器，初始状态会为 <code>starting</code>，在 <code>HEALTHCHECK</code> 指令检查成功后变为 <code>healthy</code>，如果连续一定次数失败，则会变为 <code>unhealthy</code>。</p><p><code>HEALTHCHECK</code> 支持下列选项：</p><ul><li><code>--interval=&lt;间隔></code>：两次健康检查的间隔，默认为 30 秒；</li><li><code>--timeout=&lt;时长></code>：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</li><li><code>--retries=&lt;次数></code>：当连续失败指定次数后，则将容器状态视为 <code>unhealthy</code>，默认 3 次。</li></ul><p>和 <code>CMD</code>, <code>ENTRYPOINT</code> 一样，<code>HEALTHCHECK</code> 只可以出现一次，如果写了多个，<strong>只有最后一个生效</strong>。</p><p>在 <code>HEALTHCHECK [选项] CMD</code> 后面的命令，格式和 <code>ENTRYPOINT</code> 一样，分为 <code>shell</code> 格式，和 <code>exec</code> 格式。命令的返回值决定了该次健康检查的成功与否：<code>0</code>：成功；<code>1</code>：失败；<code>2</code>：保留，不要使用这个值。</p><p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 <code>curl</code> 来帮助判断，其 <code>Dockerfile</code> 的 <code>HEALTHCHECK</code> 可以这么写：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> nginx</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apt-get update <span class=o>&amp;&amp;</span> apt-get install -y curl <span class=o>&amp;&amp;</span> rm -rf /var/lib/apt/lists/*<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>HEALTHCHECK --interval=5s --timeout=3s \
</span></span></span><span class=line><span class=cl><span class=err>  </span><span class=k>CMD</span> curl -fs http://localhost/ <span class=o>||</span> <span class=nb>exit</span> <span class=m>1</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 <code>curl -fs http://localhost/ || exit 1</code> 作为健康检查命令。</p><p>使用 <code>docker build</code> 来构建这个镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build -t myweb:v1 .
</span></span></code></pre></td></tr></table></div></div><p>构建好了后，我们启动一个容器：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d --name web -p 80:80 myweb:v1
</span></span></code></pre></td></tr></table></div></div><p>当运行该镜像后，可以通过 <code>docker container ls</code> 看到最初的状态为 <code>(health: starting)</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES
</span></span><span class=line><span class=cl>03e28eb00bd0        myweb:v1            <span class=s2>&#34;nginx -g &#39;daemon off&#34;</span>   <span class=m>3</span> seconds ago       Up <span class=m>2</span> seconds <span class=o>(</span>health: starting<span class=o>)</span>   80/tcp, 443/tcp     web
</span></span></code></pre></td></tr></table></div></div><p>在等待几秒钟后，再次 <code>docker container ls</code>，就会看到健康状态变化为了 <code>(healthy)</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                    PORTS               NAMES
</span></span><span class=line><span class=cl>03e28eb00bd0        myweb:v1            <span class=s2>&#34;nginx -g &#39;daemon off&#34;</span>   <span class=m>18</span> seconds ago      Up <span class=m>16</span> seconds <span class=o>(</span>healthy<span class=o>)</span>   80/tcp, 443/tcp     web
</span></span></code></pre></td></tr></table></div></div><p>如果健康检查连续失败超过了重试次数，状态就会变为 <code>(unhealthy)</code>。</p><p>为了帮助排障，健康检查命令的输出（包括 <code>stdout</code> 以及 <code>stderr</code>）都会被存储于健康状态里，可以用 <code>docker inspect</code> 来查看。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker inspect --format <span class=s1>&#39;{{json .State.Health}}&#39;</span> web <span class=p>|</span> python -m json.tool
</span></span><span class=line><span class=cl><span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;FailingStreak&#34;</span>: 0,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;Log&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>        <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=s2>&#34;End&#34;</span>: <span class=s2>&#34;2016-11-25T14:35:37.940957051Z&#34;</span>,
</span></span><span class=line><span class=cl>            <span class=s2>&#34;ExitCode&#34;</span>: 0,
</span></span><span class=line><span class=cl>            <span class=s2>&#34;Output&#34;</span>: <span class=s2>&#34;&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body {\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    }\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\&#34;http://nginx.org/\&#34;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\&#34;http://nginx.com/\&#34;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&#34;</span>,
</span></span><span class=line><span class=cl>            <span class=s2>&#34;Start&#34;</span>: <span class=s2>&#34;2016-11-25T14:35:37.780192565Z&#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>]</span>,
</span></span><span class=line><span class=cl>    <span class=s2>&#34;Status&#34;</span>: <span class=s2>&#34;healthy&#34;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=onbuild-为他人作嫁衣裳>ONBUILD 为他人作嫁衣裳</h3><p>格式：<code>ONBUILD &lt;其它指令></code>。</p><p><code>ONBUILD</code> 是一个特殊的指令，它后面跟的是其它指令，比如 <code>RUN</code>, <code>COPY</code> 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p><p><code>Dockerfile</code> 中的其它指令都是为了定制当前镜像而准备的，唯有 <code>ONBUILD</code> 是为了帮助别人定制自己而准备的。</p><p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 <code>npm</code> 进行包管理，所有依赖、配置、启动信息等会放到 <code>package.json</code> 文件里。在拿到程序代码后，需要先进行 <code>npm install</code> 才可以获得所有需要的依赖。然后就可以通过 <code>npm start</code> 来启动应用。因此，一般来说会这样写 <code>Dockerfile</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> node:slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> ./package.json /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=o>[</span> <span class=s2>&#34;npm&#34;</span>, <span class=s2>&#34;install&#34;</span> <span class=o>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /app/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span> <span class=s2>&#34;npm&#34;</span><span class=p>,</span> <span class=s2>&#34;start&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>把这个 <code>Dockerfile</code> 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 <code>Dockerfile</code> 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p><p>如果第一个 Node.js 项目在开发过程中，发现这个 <code>Dockerfile</code> 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 <code>Dockerfile</code>，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 <code>Dockerfile</code> 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 <code>Dockerfile</code>，而第二个项目的 <code>Dockerfile</code> 就会被自动修复。</p><p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 <code>Dockerfile</code> 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 <code>Dockerfile</code> 就会变为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> node:slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span> <span class=s2>&#34;npm&#34;</span><span class=p>,</span> <span class=s2>&#34;start&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 <code>my-node</code> 的话，各个项目内的自己的 <code>Dockerfile</code> 就变为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> my-node</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> ./package.json /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=o>[</span> <span class=s2>&#34;npm&#34;</span>, <span class=s2>&#34;install&#34;</span> <span class=o>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> . /app/<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>基础镜像变化后，各个项目都用这个 <code>Dockerfile</code> 重新构建镜像，会继承基础镜像的更新。</p><p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 <code>Dockerfile</code> 里面有些东西需要调整呢？比如 <code>npm install</code> 都需要加一些参数，那怎么办？这一行 <code>RUN</code> 是不可能放入基础镜像的，因为涉及到了当前项目的 <code>./package.json</code>，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 <code>Dockerfile</code> 的前 4 条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p><p><code>ONBUILD</code> 可以解决这个问题。让我们用 <code>ONBUILD</code> 重新写一下基础镜像的 <code>Dockerfile</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> node:slim</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> mkdir /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /app</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ONBUILD</span> <span class=k>COPY</span> ./package.json /app<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ONBUILD</span> <span class=k>RUN</span> <span class=o>[</span> <span class=s2>&#34;npm&#34;</span>, <span class=s2>&#34;install&#34;</span> <span class=o>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ONBUILD</span> <span class=k>COPY</span> . /app/<span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span> <span class=s2>&#34;npm&#34;</span><span class=p>,</span> <span class=s2>&#34;start&#34;</span> <span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>这次我们回到原始的 <code>Dockerfile</code>，但是这次将项目相关的指令加上 <code>ONBUILD</code>，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 <code>Dockerfile</code> 就变成了简单地：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> my-node</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 <code>Dockerfile</code> 构建镜像时，之前基础镜像的那三行 <code>ONBUILD</code> 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 <code>npm install</code>，生成应用镜像。</p><h3 id=label-为镜像添加元数据>LABEL 为镜像添加元数据</h3><p><code>LABEL</code> 指令用来给镜像以键值对的形式添加一些元数据（metadata）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>LABEL</span> &lt;key&gt;<span class=o>=</span>&lt;value&gt; &lt;key&gt;<span class=o>=</span>&lt;value&gt; &lt;key&gt;<span class=o>=</span>&lt;value&gt; ...<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>我们还可以用一些标签来申明镜像的作者、文档地址等：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>LABEL</span> org.opencontainers.image.authors<span class=o>=</span><span class=s2>&#34;yeasy&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>LABEL</span> org.opencontainers.image.documentation<span class=o>=</span><span class=s2>&#34;https://yeasy.gitbooks.io&#34;</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>具体可以参考 <a href=https://github.com/opencontainers/image-spec/blob/master/annotations.md target=_blank rel="external nofollow noopener noreferrer">https://github.com/opencontainers/image-spec/blob/master/annotations.md</a></p><h3 id=shell-指令>SHELL 指令</h3><p>格式：<code>SHELL ["executable", "parameters"]</code></p><p><code>SHELL</code> 指令可以指定 <code>RUN</code> <code>ENTRYPOINT</code> <code>CMD</code> 指令的 shell，Linux 中默认为 <code>["/bin/sh", "-c"]</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>SHELL</span> <span class=p>[</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=s2>&#34;-c&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> lll <span class=p>;</span> ls<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>SHELL</span> <span class=p>[</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=s2>&#34;-cex&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> lll <span class=p>;</span> ls<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>两个 <code>RUN</code> 运行同一命令，第二个 <code>RUN</code> 运行的命令会打印出每条命令并当遇到错误时退出。</p><p>当 <code>ENTRYPOINT</code> <code>CMD</code> 以 shell 格式指定时，<code>SHELL</code> 指令所指定的 shell 也会成为这两个指令的 shell</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>SHELL</span> <span class=p>[</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=s2>&#34;-cex&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># /bin/sh -cex &#34;nginx&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>ENTRYPOINT</span> nginx<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>SHELL</span> <span class=p>[</span><span class=s2>&#34;/bin/sh&#34;</span><span class=p>,</span> <span class=s2>&#34;-cex&#34;</span><span class=p>]</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=c># /bin/sh -cex &#34;nginx&#34;</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> nginx<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=dockerfile-多阶段构建>Dockerfile 多阶段构建</h2><h3 id=之前的做法>之前的做法</h3><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p><h4 id=全部放入一个-dockerfile>全部放入一个 Dockerfile</h4><p>一种方式是将所有的构建过程编包含在一个 <code>Dockerfile</code> 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p><ul><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄露的风险</li></ul><p>例如，编写 <code>app.go</code> 文件，该程序输出 <code>Hello World!</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>(){</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Hello World!&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>编写 <code>Dockerfile.one</code> 文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk --no-cache add git ca-certificates<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /go/src/github.com/go/helloworld/</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app.go .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go get -d -v github.com/go-sql-driver/mysql <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> <span class=nv>CGO_ENABLED</span><span class=o>=</span><span class=m>0</span> <span class=nv>GOOS</span><span class=o>=</span>linux go build -a -installsuffix cgo -o app . <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> cp /go/src/github.com/go/helloworld/app /root<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /root/</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./app&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>构建镜像</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build -t go/helloworld:1 -f Dockerfile.one .
</span></span></code></pre></td></tr></table></div></div><h4 id=分散到多个-dockerfile>分散到多个 Dockerfile</h4><p>另一种方式，就是我们事先在一个 <code>Dockerfile</code> 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 <code>Dockerfile</code> 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p><p>例如，编写 <code>Dockerfile.build</code> 文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:alpine</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk --no-cache add git<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /go/src/github.com/go/helloworld</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app.go .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go get -d -v github.com/go-sql-driver/mysql <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=o>&amp;&amp;</span> <span class=nv>CGO_ENABLED</span><span class=o>=</span><span class=m>0</span> <span class=nv>GOOS</span><span class=o>=</span>linux go build -a -installsuffix cgo -o app .<span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>编写 <code>Dockerfile.copy</code> 文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> alpine:latest</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk --no-cache add ca-certificates<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /root/</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./app&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>新建 <code>build.sh</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nb>echo</span> Building go/helloworld:build
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>docker build -t go/helloworld:build . -f Dockerfile.build
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>docker create --name extract go/helloworld:build
</span></span><span class=line><span class=cl>docker cp extract:/go/src/github.com/go/helloworld/app ./app
</span></span><span class=line><span class=cl>docker rm -f extract
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>echo</span> Building go/helloworld:2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copy
</span></span><span class=line><span class=cl>rm ./app
</span></span></code></pre></td></tr></table></div></div><p>现在运行脚本即可构建镜像</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ chmod +x build.sh
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ ./build.sh
</span></span></code></pre></td></tr></table></div></div><p>对比两种方式生成的镜像大小</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>REPOSITORY      TAG    IMAGE ID        CREATED         SIZE
</span></span><span class=line><span class=cl>go/helloworld   <span class=m>2</span>      f7cf3465432c    <span class=m>22</span> seconds ago  6.47MB
</span></span><span class=line><span class=cl>go/helloworld   <span class=m>1</span>      f55d3e16affc    <span class=m>2</span> minutes ago   295MB
</span></span></code></pre></td></tr></table></div></div><h3 id=使用多阶段构建>使用多阶段构建</h3><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (<code>multistage builds</code>)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 <code>Dockerfile</code>：</p><p>例如，编写 <code>Dockerfile</code> 文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:alpine as builder</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk --no-cache add git<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /go/src/github.com/go/helloworld/</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> go get -d -v github.com/go-sql-driver/mysql<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> app.go .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> <span class=nv>CGO_ENABLED</span><span class=o>=</span><span class=m>0</span> <span class=nv>GOOS</span><span class=o>=</span>linux go build -a -installsuffix cgo -o app .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>FROM</span><span class=s> alpine:latest as prod</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>RUN</span> apk --no-cache add ca-certificates<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>WORKDIR</span><span class=s> /root/</span><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>COPY</span> --from<span class=o>=</span><span class=m>0</span> /go/src/github.com/go/helloworld/app .<span class=err>
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=k>CMD</span> <span class=p>[</span><span class=s2>&#34;./app&#34;</span><span class=p>]</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>构建镜像</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build -t go/helloworld:3 .
</span></span></code></pre></td></tr></table></div></div><p>对比三个镜像大小</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>REPOSITORY        TAG   IMAGE ID         CREATED            SIZE
</span></span><span class=line><span class=cl>go/helloworld     <span class=m>3</span>     d6911ed9c846     <span class=m>7</span> seconds ago      6.47MB
</span></span><span class=line><span class=cl>go/helloworld     <span class=m>2</span>     f7cf3465432c     <span class=m>22</span> seconds ago     6.47MB
</span></span><span class=line><span class=cl>go/helloworld     <span class=m>1</span>     f55d3e16affc     <span class=m>2</span> minutes ago      295MB
</span></span></code></pre></td></tr></table></div></div><p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p><h4 id=只构建某一阶段的镜像>只构建某一阶段的镜像</h4><p>我们可以使用 <code>as</code> 来为某一阶段命名，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl><span class=k>FROM</span><span class=s> golang:alpine as builder</span><span class=err>
</span></span></span></code></pre></td></tr></table></div></div><p>例如当我们只想构建 <code>builder</code> 阶段的镜像时，增加 <code>--target=builder</code> 参数即可</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker build --target builder -t username/imagename:tag .
</span></span></code></pre></td></tr></table></div></div><h4 id=构建时从其他镜像复制文件>构建时从其他镜像复制文件</h4><p>上面例子中我们使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code> 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=line><span class=cl>$ COPY --from<span class=o>=</span>nginx:latest /etc/nginx/nginx.conf /nginx.conf<span class=err>
</span></span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-01-06 16:23:36">更新于 2023-01-06</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/docker/ data-title=Docker data-hashtags=快速入门,Golang><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/docker/ data-hashtag=快速入门><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/%E5%B7%A5%E5%85%B7/docker/ data-title=Docker data-image=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/>快速入门</a>,&nbsp;<a href=/Notes/tags/golang/>Golang</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/golang/%E8%BF%9B%E9%98%B6/%E9%9D%9E%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%E6%8C%87%E9%92%88/ class=prev rel=prev title="Go 非类型安全指针"><i class="fa-solid fa-angle-left fa-fw"></i>Go 非类型安全指针</a>
<a href=/Notes/posts/%E5%88%B7%E9%A2%98/others/9.-%E5%9B%9E%E6%96%87%E6%95%B0/ class=next rel=next title="9. 回文数">9. 回文数<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>