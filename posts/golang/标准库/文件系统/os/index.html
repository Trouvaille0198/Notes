<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Go os 标准库 - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="os os 包提供了平台无关的操作系统功能接口。 尽管错误处理是 go 风格的，但设计是 Unix 风格的"><meta name=keywords content="Go 库"><meta itemprop=name content="Go os 标准库"><meta itemprop=description content="os os 包提供了平台无关的操作系统功能接口。 尽管错误处理是 go 风格的，但设计是 Unix 风格的"><meta itemprop=datePublished content="2021-12-25T00:00:00+00:00"><meta itemprop=dateModified content="2023-03-22T14:57:16+00:00"><meta itemprop=wordCount content="7984"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="Go 库,"><meta property="og:title" content="Go os 标准库"><meta property="og:description" content="os os 包提供了平台无关的操作系统功能接口。 尽管错误处理是 go 风格的，但设计是 Unix 风格的"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-12-25T00:00:00+00:00"><meta property="article:modified_time" content="2023-03-22T14:57:16+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="Go os 标准库"><meta name=twitter:description content="os os 包提供了平台无关的操作系统功能接口。 尽管错误处理是 go 风格的，但设计是 Unix 风格的"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go os 标准库","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/%E6%A0%87%E5%87%86%E5%BA%93\/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\/os\/"},"genre":"posts","keywords":"Go 库","wordcount":7984,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/%E6%A0%87%E5%87%86%E5%BA%93\/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F\/os\/","datePublished":"2021-12-25T00:00:00+00:00","dateModified":"2023-03-22T14:57:16+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Go os 标准库</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/golang/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Golang</a></span></div><div class=post-meta-line><span title="2021-12-25 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-12-25>2021-12-25</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 7984 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#快览>快览</a></li><li><a href=#文件-io>文件 I/O</a><ul><li><a href=#打开文件>打开文件</a><ul><li><a href=#openfile>OpenFile</a><ul><li><a href=#name>name</a></li><li><a href=#flag>flag</a></li><li><a href=#perm>perm</a></li></ul></li><li><a href=#open-和-create>Open 和 Create</a></li></ul></li><li><a href=#读取文件>读取文件</a><ul><li><a href=#read>Read</a></li><li><a href=#readat>ReadAt</a></li></ul></li><li><a href=#写入文件>写入文件</a><ul><li><a href=#write>Write</a></li><li><a href=#writeat-writestring>WriteAt, WriteString</a></li></ul></li><li><a href=#关闭文件-close>关闭文件 Close</a></li><li><a href=#改变文件偏移量-seek>改变文件偏移量 Seek</a></li></ul></li><li><a href=#截断文件>截断文件</a></li><li><a href=#文件属性-stat>文件属性 Stat</a><ul><li><a href=#改变文件时间戳-chitimes>改变文件时间戳 Chitimes</a></li><li><a href=#文件属主-chown>文件属主 Chown</a></li><li><a href=#文件权限>文件权限</a><ul><li><a href=#关于目录权限>关于目录权限</a></li><li><a href=#ispermission>IsPermission</a></li><li><a href=#chmod>Chmod</a></li></ul></li></ul></li><li><a href=#目录与链接>目录与链接</a><ul><li><a href=#创建和移除硬链接-link-remove>创建和移除（硬）链接 Link Remove</a></li><li><a href=#更改文件名>更改文件名</a></li><li><a href=#使用符号链接>使用符号链接</a><ul><li><a href=#readlink>ReadLink</a></li></ul></li><li><a href=#创建和移除目录>创建和移除目录</a><ul><li><a href=#mkdir-mkdirall>Mkdir, MkdirAll</a></li><li><a href=#remove-removeall>Remove, RemoveAll</a></li></ul></li><li><a href=#读目录-readdirnames-readdir>读目录 Readdirnames, Readdir</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=os>os</h1><p><strong><code>os</code> 包提供了平台无关的操作系统功能接口。</strong></p><p>尽管错误处理是 go 风格的，但设计是 Unix 风格的；所以，失败的调用会返回 <code>error</code> 而非错误码。通常 <code>error</code> 里会包含更多信息。</p><p>例如，如果使用一个文件名的调用（如 Open、Stat）失败了，打印错误时会包含该文件名，错误类型将为 <code>*PathError</code>，其内部可以解包获得更多信息。</p><p>os 包规定为所有操作系统实现的接口都是一致的。有一些某个系统特定的功能，需要使用 <code>syscall</code> 获取。实际上，<strong><code>os</code> 依赖于 <code>syscall</code></strong>。</p><p>在实际编程中，我们应该总是优先使用 <code>os</code> 中提供的功能，而不是 <code>syscall</code>。</p><p>下面是一个简单的例子，打开一个文件并从中读取一些数据：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=s>&#34;file.go&#34;</span><span class=p>)</span> <span class=c1>// For read access.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如果打开失败，错误字符串是自解释的，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>open file.go: no such file or directory
</span></span></code></pre></td></tr></table></div></div><p>而不像 C 语言，需要额外的函数（或宏）来解释错误码。</p><h2 id=快览>快览</h2><ul><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>Create</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>根据提供的文件名创建新的文件，返回一个文件对象，默认权限是 0666</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>NewFile</span><span class=p>(</span><span class=nx>fd</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=o>*</span><span class=nx>File</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>根据文件描述符创建相应的文件，返回一个文件对象</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>Open</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>只读方式打开一个名称为 name 的文件</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>OpenFile</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>flag</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>perm</span> <span class=kt>uint32</span><span class=p>)</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>打开名称为 name 的文件，flag 是打开的方式，只读、读写等，perm 是权限</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>写入 byte 类型的信息到文件</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>WriteAt</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>off</span> <span class=kt>int64</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>在指定位置开始写入 byte 类型的信息</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>WriteString</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>写入 string 信息到文件</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>读取数据到 b 中</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>ReadAt</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>off</span> <span class=kt>int64</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=nx>Error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>从 off 开始读取数据到 b 中</li></ul></li><li><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl>  <span class=kd>func</span> <span class=nf>Remove</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=nx>Error</span>
</span></span></code></pre></td></tr></table></div></div><ul><li>删除文件名为 name 的文件</li></ul></li></ul><h2 id=文件-io>文件 I/O</h2><p>在 Unix 系统调用中，所有 I/O 操作以文件描述符 ( 一个非负整数 , 通常是小整数 ) 来指代打开的文件。文件描述符用以表示所有类型的已打开文件，包括管道（pipe）、FIFO、socket、终端、设备和普通文件。这里，我们主要介绍普通文件的 I/O。</p><p>在 Go 中，文件描述符封装在 <code>os.File</code> 结构中，通过 <code>File.Fd()</code> 可以获得底层的文件描述符：fd。</p><p>按照惯例，大多数程序都期望能够使用 3 种标准的文件描述符：0- 标准输入；1- 标准输出；2- 标准错误。<code>os</code> 包提供了 3 个 <code>File</code> 对象，分别代表这 3 种标准描述符：<code>Stdin</code>、<code>Stdout</code> 和 <code>Stderr</code>，它们对应的文件名分别是：/dev/stdin、/dev/stdout 和 /dev/stderr。</p><blockquote><p>这里说的文件名，并不一定存在，比如 Windows 下就没有。</p></blockquote><h3 id=打开文件>打开文件</h3><h4 id=openfile>OpenFile</h4><p><code>OpenFile()</code> 既能打开一个已经存在的文件，也能创建并打开一个新文件。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>OpenFile</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>flag</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>perm</span> <span class=nx>FileMode</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>OpenFile</code> 是一个更一般性的文件打开函数，<strong>大多数调用者都应用 <code>Open</code> 或 <code>Create</code> 代替本函数。</strong></p><p>它会使用指定的选项（如 O_RDONLY 等）、指定的模式（如 0666 等）打开指定名称的文件。</p><p>如果操作成功，返回的文件对象可用于 I/O。如果出错，错误底层类型是 <code>*PathError</code>。它会记录具体操作、文件路径和错误原因。</p><p>另外，在 <code>OpenFile</code> 内部会调用 <code>NewFile</code>，来得到 <code>File</code> 对象。</p><h5 id=name>name</h5><p>要打开的文件由参数 <code>name</code> 指定。</p><p>它可以是绝对路径或相对路径（相对于进程当前工作目录），也可以是一个符号链接（会对其进行解引用）。</p><h5 id=flag>flag</h5><p>位掩码参数 <code>flag</code> 用于指定文件的访问模式，可用的值在 <code>os</code> 中定义为常量（以下值并非所有操作系统都可用）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=nx>O_RDONLY</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_RDONLY</span> <span class=c1>// 只读模式打开文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_WRONLY</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_WRONLY</span> <span class=c1>// 只写模式打开文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_RDWR</span>   <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_RDWR</span>   <span class=c1>// 读写模式打开文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_APPEND</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_APPEND</span> <span class=c1>// 写操作时将数据附加到文件尾部
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_CREATE</span> <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_CREAT</span>  <span class=c1>// 如果不存在将创建一个新文件
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_EXCL</span>   <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_EXCL</span>   <span class=c1>// 和 O_CREATE 配合使用，文件必须不存在
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_SYNC</span>   <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_SYNC</span>   <span class=c1>// 打开文件用于同步 I/O
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>O_TRUNC</span>  <span class=kt>int</span> <span class=p>=</span> <span class=nx>syscall</span><span class=p>.</span><span class=nx>O_TRUNC</span>  <span class=c1>// 如果可能，打开时清空文件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>其中，<code>O_RDONLY</code>、<code>O_WRONLY</code>、<code>O_RDWR</code> 应该只指定一个，剩下的通过 <code>|</code> 操作符来指定。</p><p>该函数内部会给 <code>flags</code> 加上 <code>syscall.O_CLOEXEC</code>，在 fork 子进程时会关闭通过 <code>OpenFile</code> 打开的文件，即子进程不会重用该文件描述符。</p><blockquote><p>由于历史原因，<code>O_RDONLY | O_WRONLY</code> 并非等于 <code>O_RDWR</code>，它们的值一般是 0、1、2</p></blockquote><h5 id=perm>perm</h5><p>位掩码参数 <code>perm</code> 指定了文件的模式和权限位，类型是 <code>os.FileMode</code>，文件模式位常量定义在 <code>os</code> 中：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>const</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 单字符是被 String 方法用于格式化的属性缩写。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeDir</span>        <span class=nx>FileMode</span> <span class=p>=</span> <span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=mi>32</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=kc>iota</span><span class=p>)</span> <span class=c1>// d: 目录
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeAppend</span>                                     <span class=c1>// a: 只能写入，且只能写入到末尾
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeExclusive</span>                                  <span class=c1>// l: 用于执行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeTemporary</span>                                  <span class=c1>// T: 临时文件（非备份文件）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeSymlink</span>                                    <span class=c1>// L: 符号链接（不是快捷方式文件）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeDevice</span>                                     <span class=c1>// D: 设备
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeNamedPipe</span>                                  <span class=c1>// p: 命名管道（FIFO）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeSocket</span>                                     <span class=c1>// S: Unix 域 socket
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeSetuid</span>                                     <span class=c1>// u: 表示文件具有其创建者用户 id 权限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeSetgid</span>                                     <span class=c1>// g: 表示文件具有其创建者组 id 的权限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeCharDevice</span>                                 <span class=c1>// c: 字符设备，需已设置 ModeDevice
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeSticky</span>                                     <span class=c1>// t: 只有 root/ 创建者能删除 / 移动文件
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=c1>// 覆盖所有类型位（用于通过 &amp; 获取类型位），对普通文件，所有这些位都不应被设置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ModeType</span> <span class=p>=</span> <span class=nx>ModeDir</span> <span class=p>|</span> <span class=nx>ModeSymlink</span> <span class=p>|</span> <span class=nx>ModeNamedPipe</span> <span class=p>|</span> <span class=nx>ModeSocket</span> <span class=p>|</span> <span class=nx>ModeDevice</span>
</span></span><span class=line><span class=cl>    <span class=nx>ModePerm</span> <span class=nx>FileMode</span> <span class=p>=</span> <span class=mo>0777</span> <span class=c1>// 覆盖所有 Unix 权限位（用于通过 &amp; 获取类型位）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>以上常量在所有操作系统都有相同的含义（可用时），因此文件的信息可以在不同的操作系统之间安全的移植。</p><p>不是所有的位都能用于所有的系统，唯一共有的是用于表示目录的 <code>ModeDir</code> 位。</p><p>以上这些被定义的位是 <code>FileMode</code> 最重要的位。另外 9 个位（权限位）为标准 Unix rwxrwxrwx 权限（所有人都可读、写、运行）。</p><p><code>FileMode</code> 还定义了几个方法，用于判断文件类型的 <code>IsDir()</code> 和 <code>IsRegular()</code>，用于获取权限的 <code>Perm()</code>。</p><h4 id=open-和-create>Open 和 Create</h4><p>打开一个文件，一般通过 <code>Open</code> 或 <code>Create</code>，我们看这两个函数的实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Open</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>OpenFile</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>O_RDONLY</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Create</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=o>*</span><span class=nx>File</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>OpenFile</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>O_RDWR</span><span class=p>|</span><span class=nx>O_CREATE</span><span class=p>|</span><span class=nx>O_TRUNC</span><span class=p>,</span> <span class=mo>0666</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=读取文件>读取文件</h3><h4 id=read>Read</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Read</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Read</code> 方法从 <code>f</code> 中读取最多 <code>len(b)</code> 字节数据并写入 <code>b</code>。</p><p>它返回读取的字节数和可能遇到的任何错误。</p><p>文件终止标志是读取 0 个字节且返回值 err 为 <code>io.EOF</code>。</p><p>从方法声明可以知道，<code>File</code> 实现了 <code>io.Reader</code> 接口。</p><p><code>Read</code> 对应的系统调用是 <code>read</code>。</p><h4 id=readat>ReadAt</h4><p>对比下 <code>ReadAt</code> 方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>ReadAt</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>off</span> <span class=kt>int64</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>ReadAt</code> 从指定的位置（<strong>相对于文件开始位置</strong>）读取长度为 <code>len(b)</code> 个字节数据并写入 <code>b</code>。</p><p>它返回读取的字节数和可能遇到的任何错误。</p><p>当 n&lt;len(b) 时，本方法总是会返回错误；如果是因为到达文件结尾，返回值 err 会是 <code>io.EOF</code>。它对应的系统调用是 <code>pread</code>。</p><p><strong><code>Read</code> 和 <code>ReadAt</code> 的区别</strong>：前者从文件当前偏移量处读，且会改变文件当前的偏移量；而后者从 <code>off</code> 指定的位置开始读，且<strong>不会改变</strong>文件当前偏移量。</p><h3 id=写入文件>写入文件</h3><h4 id=write>Write</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Write</span><span class=p>(</span><span class=nx>b</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Write</code> 向文件中写入 <code>len(b)</code> 字节数据。</p><p>它返回写入的字节数和可能遇到的任何错误。</p><p>如果返回值 <code>n!=len(b)</code>，本方法会返回一个非 nil 的错误。</p><p>从方法声明可以知道，<code>File</code> 实现了 <code>io.Writer</code> 接口。</p><p><code>Write</code> 对应的系统调用是 <code>write</code>。</p><h4 id=writeat-writestring>WriteAt, WriteString</h4><p><code>Write</code> 与 <code>WriteAt</code> 的区别同 <code>Read</code> 与 <code>ReadAt</code> 的区别一样。</p><p>为了方便，还提供了 <code>WriteString</code> 方法，它实际是对 <code>Write</code> 的封装。</p><p>注意：<code>Write</code> 调用成功并不能保证数据已经写入磁盘，因为内核会缓存磁盘的 I/O 操作。如果希望立刻将数据写入磁盘（一般场景不建议这么做，因为会影响性能），有两种办法：</p><ol><li>打开文件时指定 <code>os.O_SYNC</code>；</li><li>调用 <code>File.Sync()</code> 方法。</li></ol><p>说明：<code>File.Sync()</code> 底层调用的是 <code>fsync</code> 系统调用，这会将数据和元数据都刷到磁盘；如果只想刷数据到磁盘（比如，文件大小没变，只是变了文件数据），需要自己封装，调用 <code>fdatasync</code> 系统调用。（<code>syscall.Fdatasync</code>）</p><h3 id=关闭文件-close>关闭文件 Close</h3><p><code>close()</code> 系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。</p><p>当进程终止时，将<strong>自动关闭</strong>其已打开的所有文件描述符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Close</span><span class=p>()</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p><code>os.File.Close()</code> 是对 <code>close()</code> 的封装。</p><p>我们应该养成关闭不需要的文件的良好编程习惯。</p><blockquote><p>文件描述符是资源，Go 的 gc 是针对内存的，并不会自动回收资源，如果不关闭文件描述符，长期运行的服务可能会把文件描述符耗尽。</p></blockquote><p>通常的写法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=s>&#34;/tmp/studygolang.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 错误处理，一般会阻止程序往下执行
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span> <span class=c1>// 在return之前执行
</span></span></span></code></pre></td></tr></table></div></div><p><strong>关于返回值 <code>error</code></strong></p><p>以下两种情况会导致 <code>Close</code> 返回错误：</p><ol><li>关闭一个未打开的文件；</li><li>两次关闭同一个文件；</li></ol><p>通常，我们不会去检查 <code>Close</code> 的错误。</p><h3 id=改变文件偏移量-seek>改变文件偏移量 Seek</h3><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。</p><p>文件偏移量是指执行下一个 <code>Read</code> 或 <code>Write</code> 操作的文件其实位置，会以相对于文件头部起始点的文件当前位置来表示。</p><p>文件第一个字节的偏移量为 0。</p><p>文件打开时，会将文件偏移量设置为指向文件开始，以后每次 <code>Read</code> 或 <code>Write</code> 调用将自动对其进行调整，以指向已读或已写数据后的下一个字节。</p><p>因此，连续的 <code>Read</code> 和 <code>Write</code> 调用将按顺序递进，对文件进行操作。</p><p>而 <code>Seek</code> 可以调整文件偏移量。方法定义如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Seek</span><span class=p>(</span><span class=nx>offset</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>whence</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>ret</span> <span class=kt>int64</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Seek</code> 设置下一次读 / 写的位置。</p><ul><li>offset 为相对偏移量</li><li>whence 决定相对位置<ul><li>0 为相对文件开头</li><li>1 为相对当前位置</li><li>2 为相对文件结尾。</li></ul></li></ul><p>它返回新的偏移量（相对开头）和可能的错误。</p><p>使用中，whence 应该使用 <code>os</code> 包中的常量：<code>SEEK_SET</code>、<code>SEEK_CUR</code> 和 <code>SEEK_END</code>。</p><p>注意：<code>Seek</code> 只是调整内核中与文件描述符相关的文件偏移量记录，并没有引起对任何物理设备的访问。</p><p>一些 <code>Seek</code> 的使用例子（file 为打开的文件对象），注释说明了将文件偏移量移动到的具体位置：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>file</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>os</span><span class=p>.</span><span class=nx>SEEK_SET</span><span class=p>)</span>    <span class=c1>// 文件开始处
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>file</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=nx>SEEK_END</span><span class=p>)</span>        <span class=c1>// 文件结尾处的下一个字节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>file</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=nx>SEEK_END</span><span class=p>)</span>        <span class=c1>// 文件最后一个字节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>file</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=o>-</span><span class=mi>10</span><span class=p>,</span> <span class=nx>SEEK_CUR</span><span class=p>)</span>     <span class=c1>// 当前位置前 10 个字节
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>file</span><span class=p>.</span><span class=nf>Seek</span><span class=p>(</span><span class=mi>1000</span><span class=p>,</span> <span class=nx>SEEK_END</span><span class=p>)</span>    <span class=c1>// 文件结尾处的下 1001 个字节
</span></span></span></code></pre></td></tr></table></div></div><p>最后一个例子在文件中会产生“空洞”。</p><p><code>Seek</code> 对应系统调用 <code>lseek</code>。该系统调用并不适用于所有类型，不允许将 <code>lseek</code> 应用于管道、FIFO、socket 或 终端。</p><h2 id=截断文件>截断文件</h2><p><code>truncate</code> 和 <code>ftruncate</code> 系统调用将文件大小设置为 <code>size</code> 参数指定的值；Go 语言中相应的包装函数是 <code>os.Truncate</code> 和 <code>os.File.Truncate</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Truncate</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>size</span> <span class=kt>int64</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Truncate</span><span class=p>(</span><span class=nx>size</span> <span class=kt>int64</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p>如果文件当前长度大于参数 <code>size</code>，调用将丢弃超出部分，若小于参数 <code>size</code>，调用将在文件尾部添加一系列空字节或是一个文件空洞。</p><p>它们之间的区别在于如何指定操作文件：</p><ol><li><code>Truncate</code> 以路径名称字符串来指定文件，并要求可访问该文件（即对组成路径名的各目录拥有可执行 (x) 权限），且对文件拥有写权限。若文件名为符号链接，那么调用将对其进行解引用。</li><li>很明显，调用 <code>File.Truncate</code> 前，需要先以可写方式打开操作文件，该方法不会修改文件偏移量。</li></ol><h2 id=文件属性-stat>文件属性 Stat</h2><p>文件属性，也即文件<strong>元数据</strong>。</p><p>在 Go 中，文件属性具体信息通过 <code>os.FileInfo</code> 接口获取。</p><p><strong>函数 <code>Stat</code>、<code>Lstat</code> 和 <code>File.Stat</code> 可以得到该接口的实例</strong>。这三个函数对应三个系统调用：<code>stat</code>、<code>lstat</code> 和 <code>fstat</code>。</p><p>这三个函数的区别：</p><ol><li><code>stat</code> 会返回所命名文件的相关信息。</li><li><code>lstat</code> 与 <code>stat</code> 类似，区别在于如果文件是符号链接，那么所返回的信息针对的是符号链接自身（而非符号链接所指向的文件）。</li><li><code>fstat</code> 则会返回由某个打开文件描述符（Go 中则是当前打开文件 File）所指代文件的相关信息。</li></ol><p><code>Stat</code> 和 <code>Lstat</code> 无需对其所操作的文件本身拥有任何权限，但针对指定 name 的父目录要有执行（搜索）权限。而只要 <code>File</code> 对象 ok，<code>File.Stat</code> 总是成功。</p><p><code>FileInfo</code> 接口如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>FileInfo</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nf>Name</span><span class=p>()</span> <span class=kt>string</span>       <span class=c1>// 文件的名字（不含扩展名）
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Size</span><span class=p>()</span> <span class=kt>int64</span>        <span class=c1>// 普通文件返回值表示其大小；其他文件的返回值含义各系统不同
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Mode</span><span class=p>()</span> <span class=nx>FileMode</span>     <span class=c1>// 文件的模式位
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>ModTime</span><span class=p>()</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span> <span class=c1>// 文件的修改时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>IsDir</span><span class=p>()</span> <span class=kt>bool</span>        <span class=c1>// 等价于 Mode().IsDir()
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nf>Sys</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span>   <span class=c1>// 底层数据来源（可以返回 nil）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Sys()</code> 底层数据的 C 语言 结构 <code>statbuf</code> 格式如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>struct</span> <span class=nx>stat</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>dev_t</span>    <span class=nx>st_dev</span><span class=p>;</span>    <span class=c1>// 设备 ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>ino_t</span>    <span class=nx>st_ino</span><span class=p>;</span>    <span class=c1>// 文件 i 节点号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>mode_t</span>    <span class=nx>st_mode</span><span class=p>;</span>    <span class=c1>// 位掩码，文件类型和文件权限
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>nlink_t</span>    <span class=nx>st_nlink</span><span class=p>;</span>    <span class=c1>// 硬链接数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>uid_t</span>    <span class=nx>st_uid</span><span class=p>;</span>    <span class=c1>// 文件属主，用户 ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>gid_t</span>    <span class=nx>st_gid</span><span class=p>;</span>    <span class=c1>// 文件属组，组 ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>dev_t</span>    <span class=nx>st_rdev</span><span class=p>;</span>    <span class=c1>// 如果针对设备 i 节点，则此字段包含主、辅 ID
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>off_t</span>    <span class=nx>st_size</span><span class=p>;</span>    <span class=c1>// 常规文件，则是文件字节数；符号链接，则是链接所指路径名的长度，字节为单位；对于共享内存对象，则是对象大小
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>blksize_t</span>    <span class=nx>st_blsize</span><span class=p>;</span>    <span class=c1>// 分配给文件的总块数，块大小为 512 字节
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>blkcnt_t</span>    <span class=nx>st_blocks</span><span class=p>;</span>    <span class=c1>// 实际分配给文件的磁盘块数量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time_t</span>    <span class=nx>st_atime</span><span class=p>;</span>        <span class=c1>// 对文件上次访问时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time_t</span>    <span class=nx>st_mtime</span><span class=p>;</span>        <span class=c1>// 对文件上次修改时间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>time_t</span>    <span class=nx>st_ctime</span><span class=p>;</span>        <span class=c1>// 文件状态发生改变的上次时间
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Go 中 <code>syscal.Stat_t</code> 与该结构对应。</p><p>如果我们要获取 <code>FileInfo</code> 接口没法直接返回的信息，比如想获取文件的上次访问时间，示例如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>fileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Stat</span><span class=p>(</span><span class=s>&#34;test.log&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>sys</span> <span class=o>:=</span> <span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Sys</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=nx>stat</span> <span class=o>:=</span> <span class=nx>sys</span><span class=p>.(</span><span class=o>*</span><span class=nx>syscall</span><span class=p>.</span><span class=nx>Stat_t</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Unix</span><span class=p>(</span><span class=nx>stat</span><span class=p>.</span><span class=nx>Atimespec</span><span class=p>.</span><span class=nf>Unix</span><span class=p>()))</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=改变文件时间戳-chitimes>改变文件时间戳 Chitimes</h3><p>可以显式改变文件的访问时间和修改时间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Chtimes</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>atime</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>,</span> <span class=nx>mtime</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Time</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Chtimes</code> 修改 name 指定的文件对象的访问时间和修改时间，类似 Unix 的 utime() 或 utimes() 函数。</p><p>底层的文件系统可能会截断 / 舍入时间单位到更低的精确度。</p><p>如果出错，会返回 <code>*PathError</code> 类型的错误。</p><p>在 Unix 中，函数的底层实现会调用 <code>utimenstat()</code>，它提供纳秒级别的精度</p><h3 id=文件属主-chown>文件属主 Chown</h3><p>每个文件都有一个与之关联的用户 ID（UID）和组 ID（GID），籍此可以判定文件的属主和属组。</p><p>系统调用 <code>chown</code>、<code>lchown</code> 和 <code>fchown</code> 可用来改变文件的属主和属组，Go 中对应的函数或方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Chown</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>uid</span><span class=p>,</span> <span class=nx>gid</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Lchown</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>uid</span><span class=p>,</span> <span class=nx>gid</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Chown</span><span class=p>(</span><span class=nx>uid</span><span class=p>,</span> <span class=nx>gid</span> <span class=kt>int</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p>它们的区别和上文提到的 <code>Stat</code> 相关函数类似。</p><h3 id=文件权限>文件权限</h3><p>这里介绍是应用于文件和目录的权限方案，尽管此处讨论的权限主要是针对普通文件和目录，但其规则可适用于所有文件类型，包括设备文件、FIFO 以及 Unix 域套接字等。</p><h4 id=关于目录权限>关于目录权限</h4><p>目录与文件拥有相同的权限方案，只是对 3 种权限的含义<strong>另有所指</strong>。</p><ul><li>读权限：可列出（比如，通过 ls 命令）目录之下的内容（即目录下的文件名）。</li><li>写权限：可在目录内创建、删除文件。注意，要删除文件，对文件本身无需有任何权限。</li><li>可执行权限：可访问目录中的文件。因此，有时也将对目录的执行权限称为 search（搜索）权限。</li></ul><p>访问文件时，需要拥有对路径名所列所有目录的执行权限。例如，想读取文件 <code>/home/studygolang/abc</code>，则需拥有对目录 <code>/</code>、<code>/home</code> 以及 <code>/home/studygolang</code> 的执行权限（还要有对文件 <code>abc</code> 自身的读权限）。</p><h4 id=ispermission>IsPermission</h4><p>在文件相关操作报错时，可以通过 <code>os.IsPermission</code> 检查是否是权限的问题。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>IsPermission</span><span class=p>(</span><span class=nx>err</span> <span class=kt>error</span><span class=p>)</span> <span class=kt>bool</span>
</span></span></code></pre></td></tr></table></div></div><p>返回一个布尔值说明该错误是否表示因权限不足要求被拒绝。ErrPermission 和一些系统调用错误会使它返回真。</p><p>另外，<code>syscall.Access</code> 可以获取文件的权限。这对应系统调用 <code>access</code>。</p><h4 id=chmod>Chmod</h4><p>除了 9 位用来表明属主、属组和其他用户的权限外，文件权限掩码还另设有 3 个附加位，分别是 set-user-ID(bit 04000)、set-group-ID(bit 02000) 和 sticky(bit 01000) 位。set-user-ID 和 set-group-ID 权限位将在进程章节介绍。这里介绍 <strong>sticky 位</strong>。</p><p>Sticky 位一般用于目录，起限制删除位的作用，表明仅当非特权进程具有对目录的写权限，且为文件或目录的属主时，才能对目录下的文件进行删除和重命名操作。</p><p>根据这个机制<strong>来创建为多个用户共享的一个目录</strong>，各个用户可在其下创建或删除属于自己的文件，但不能删除隶属于其他用户的文件。<code>/tmp</code> 目录就设置了 sticky 位，正是出于这个原因。</p><p><code>chmod</code> 命令或系统调用可以设置文件的 sticky 位。若对某文件设置了 sticky 位，则 <code>ls -l</code> 显示文件时，会在其他用户执行权限字段上看到字母 t（有执行权限时） 或 T（无执行权限时）。</p><p><code>os.Chmod</code> 和 <code>os.File.Chmod</code> 可以修改文件权限（包括 sticky 位），分别对应系统调用 <code>chmod</code> 和 <code>fchmod</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;studygolang.txt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fileMode</span> <span class=o>:=</span> <span class=nf>getFileMode</span><span class=p>(</span><span class=nx>file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;file mode:&#34;</span><span class=p>,</span> <span class=nx>fileMode</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nx>file</span><span class=p>.</span><span class=nf>Chmod</span><span class=p>(</span><span class=nx>fileMode</span> <span class=p>|</span> <span class=nx>os</span><span class=p>.</span><span class=nx>ModeSticky</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>log</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;change after, file mode:&#34;</span><span class=p>,</span> <span class=nf>getFileMode</span><span class=p>(</span><span class=nx>file</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getFileMode</span><span class=p>(</span><span class=nx>file</span> <span class=o>*</span><span class=nx>os</span><span class=p>.</span><span class=nx>File</span><span class=p>)</span> <span class=nx>os</span><span class=p>.</span><span class=nx>FileMode</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Stat</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>log</span><span class=p>.</span><span class=nf>Fatal</span><span class=p>(</span><span class=s>&#34;file stat error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Mode</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1>// 2016/06/18 15:59:06 file mode: -rw-rw-r--
</span></span></span><span class=line><span class=cl><span class=c1>// 2016/06/18 15:59:06 change after, file mode: trw-rw-r--
</span></span></span><span class=line><span class=cl><span class=c1>// ls -l 看到的 studygolang.tx 是：-rw-rw-r-T
</span></span></span><span class=line><span class=cl><span class=c1>// 当然这里是给文件设置了 sticky 位，对权限不起作用。系统会忽略它。
</span></span></span></code></pre></td></tr></table></div></div><h2 id=目录与链接>目录与链接</h2><p>在 Unix 文件系统中，目录的存储方式类似于普通文件。目录和普通文件的区别有二：</p><ul><li>在其 i-node 条目中，会将目录标记为一种不同的文件类型。</li><li>目录是经特殊组织而成的文件。本质上说就是一个表格，包含文件名和 i-node 标号。</li></ul><h3 id=创建和移除硬链接-link-remove>创建和移除（硬）链接 Link Remove</h3><p><strong>硬链接是针对文件而言的，目录不允许创建硬链接。</strong></p><p><code>link</code> 和 <code>unlink</code> 系统调用用于创建和移除（硬）链接。</p><p>Go 中 <code>os.Link</code> 对应 <code>link</code> 系统调用；但 <code>os.Remove</code> 的实现会先执行 <code>unlink</code> 系统调用，如果要移除的是目录，则 <code>unlink</code> 会失败，这时 <code>Remove</code> 会再调用 <code>rmdir</code> 系统调用。</p><p><code>Link</code> 创建一个名为 newname 指向 oldname 的硬链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Link</span><span class=p>(</span><span class=nx>oldname</span><span class=p>,</span> <span class=nx>newname</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Remove</code> 删除 name 指定的文件或目录。如果出错，会返回 <code>*PathError</code> 类型的错误。如果目录不为空，<code>Remove</code> 会返回失败。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Remove</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=更改文件名>更改文件名</h3><p>系统调用 <code>rename</code> 既可以重命名文件，又可以将文件移至同一个文件系统中的另一个目录。</p><p>该系统调用既可以用于文件，也可以用于目录。</p><p>Go 中的 <code>os.Rename</code> 是对应的封装函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Rename</span><span class=p>(</span><span class=nx>oldpath</span><span class=p>,</span> <span class=nx>newpath</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Rename</code> 修改一个文件的名字或移动一个文件。如果 <code>newpath</code> 已经存在，则<strong>替换</strong>它。注意，可能会有一些个操作系统特定的限制。</p><h3 id=使用符号链接>使用符号链接</h3><p>符号链接即软链接</p><blockquote><p>软链接类似于快捷方式，它可以指向任意文件系统中的一个文件或目录。</p><p>硬链接也可以看作是文件或目录的快捷方式，但是无法在两个不同文件系统之间创建硬链接。</p></blockquote><p><code>symlink</code> 系统调用用于<strong>为指定路径名创建一个新的符号链接</strong>（想要移除符号链接，使用 <code>unlink</code>）。</p><p>Go 中的 <code>os.Symlink</code> 是对应的封装函数。</p><p><code>Symlink</code> 创建一个名为 <code>newname</code> 指向 <code>oldname</code> 的符号链接。如果出错，会返回 <code>*LinkError</code> 类型的错误。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Symlink</span><span class=p>(</span><span class=nx>oldname</span><span class=p>,</span> <span class=nx>newname</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p>由 <code>oldname</code> 所命名的文件或目录在调用时无需存在。因为即便当时存在，也无法阻止后来将其删除。这时，<code>newname</code> 成为“悬空链接”，其他系统调用试图对其进行解引用操作都将错误（通常错误号是 ENOENT）。</p><h4 id=readlink>ReadLink</h4><p>有时候，我们希望<strong>通过符号链接，能获取其所指向的路径名</strong>。系统调用 <code>readlink</code> 能做到，Go 的封装函数是 <code>os.Readlink</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Readlink</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Readlink</code> 获取 <code>name</code> 指定的符号链接指向的文件的路径。</p><p>如果出错，会返回 <code>*PathError</code> 类型的错误。</p><p>我们看看 <code>Readlink</code> 的实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Readlink</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>)</span> <span class=p>(</span><span class=kt>string</span><span class=p>,</span> <span class=kt>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=nx>len</span> <span class=o>:=</span> <span class=mi>128</span><span class=p>;</span> <span class=p>;</span> <span class=nx>len</span> <span class=o>*=</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nx>b</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=nx>len</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=nx>n</span><span class=p>,</span> <span class=nx>e</span> <span class=o>:=</span> <span class=nf>fixCount</span><span class=p>(</span><span class=nx>syscall</span><span class=p>.</span><span class=nf>Readlink</span><span class=p>(</span><span class=nx>name</span><span class=p>,</span> <span class=nx>b</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>e</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=s>&#34;&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=nx>PathError</span><span class=p>{</span><span class=s>&#34;readlink&#34;</span><span class=p>,</span> <span class=nx>name</span><span class=p>,</span> <span class=nx>e</span><span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nx>n</span> <span class=p>&lt;</span> <span class=nx>len</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>string</span><span class=p>(</span><span class=nx>b</span><span class=p>[</span><span class=mi>0</span><span class=p>:</span><span class=nx>n</span><span class=p>]),</span> <span class=kc>nil</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这里之所以用循环，是因为我们没法知道文件的路径到底多长，如果 <code>b</code> 长度不够，文件名会被截断，而 <code>readlink</code> 系统调用无非分辨所返回的字符串到底是经过截断处理，还是恰巧将 <code>b</code> 填满。这里采用的验证方法是分配一个更大的（两倍）<code>b</code> 并再次调用 <code>readlink</code>。</p><h3 id=创建和移除目录>创建和移除目录</h3><h4 id=mkdir-mkdirall>Mkdir, MkdirAll</h4><p><code>mkdir</code> 系统调用创建一个新目录，Go 中的 <code>os.Mkdir</code> 是对应的封装函数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Mkdir</span><span class=p>(</span><span class=nx>name</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>perm</span> <span class=nx>FileMode</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Mkdir</code> 使用指定的权限和名称创建一个目录。如果出错，会返回 <code>*PathError</code> 类型的错误。</p><ul><li><p><code>name</code> 参数指定了新目录的路径名，可以是相对路径，也可以是绝对路径。如果已经存在，则调用失败并返回 <code>os.ErrExist</code> 错误。</p></li><li><p><code>perm</code> 参数指定了新目录的权限。对该位掩码值的指定方式和 <code>os.OpenFile</code> 相同，也可以直接赋予八进制数值。注意，<code>perm</code> 值还将于进程掩码相与（&）。如果 <code>perm</code> 中设置了 sticky 位，那么将对新目录设置该权限。</p></li></ul><p>因为 <code>Mkdir</code> 所创建的只是路径名中的最后一部分，如果父目录不存在，创建会失败。<code>os.MkdirAll</code> 用于递归创建所有不存在的目录。</p><h4 id=remove-removeall>Remove, RemoveAll</h4><p><code>rmdir</code> 系统调用<strong>移除一个指定的目录</strong>，目录可以是绝对路径或相对路径。</p><p>在讲解 <code>unlink</code> 时，已经介绍了 Go 中的 <code>os.Remove</code>。</p><p>注意，这里要求目录必须为空。为了方便使用，Go 中封装了一个 <code>os.RemoveAll</code> 函数：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>RemoveAll</span><span class=p>(</span><span class=nx>path</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><p><code>RemoveAll</code> 删除 <code>path</code> 指定的文件，或目录及它包含的任何下级对象。</p><p>它会尝试删除所有东西，除非遇到错误并返回。</p><p>如果 <code>path</code> 指定的对象不存在，<code>RemoveAll</code> 会返回 nil 而不返回错误。</p><p><code>RemoveAll</code> 的内部实现逻辑如下：</p><ol><li>调用 <code>Remove</code> 尝试进行删除，如果成功或返回 <code>path</code> 不存在，则直接返回 nil；</li><li>调用 <code>Lstat</code> 获取 <code>path</code> 信息，以便判断是否是目录。注意，这里使用 <code>Lstat</code>，表示不对符号链接解引用；</li><li>调用 <code>Open</code> 打开目录，递归读取目录中内容，执行删除操作。</li></ol><h3 id=读目录-readdirnames-readdir>读目录 Readdirnames, Readdir</h3><p><code>POSIX</code> 与 <code>SUS</code> 定义了读取目录相关的 C 语言标准，各个操作系统提供的系统调用却不尽相同。Go 没有基于 C 语言，而是自己通过系统调用实现了读目录功能。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Readdirnames</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>names</span> <span class=p>[]</span><span class=kt>string</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Readdirnames</code> 读取目录 <code>f</code> 的内容，返回一个最多有 <code>n</code> 个成员的 []string，切片成员为目录中文件对象的名字，采用目录顺序。</p><p>对本函数的下一次调用会返回上一次调用未读取的内容的信息。</p><p>如果 n>0，<code>Readdirnames</code> 函数会返回一个最多 n 个成员的切片。这时，如果 <code>Readdirnames</code> 返回一个空切片，它会返回一个非 nil 的错误说明原因。如果到达了目录 <code>f</code> 的结尾，返回值 err 会是 <code>io.EOF</code>。</p><p>如果 n&lt;=0，<code>Readdirnames</code> 函数返回目录中剩余所有文件对象的名字构成的切片。此时，如果 <code>Readdirnames</code> 调用成功（读取所有内容直到结尾），它会返回该切片和 nil 的错误值。如果在到达结尾前遇到错误，会返回之前成功读取的名字构成的切片和该错误。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>f</span> <span class=o>*</span><span class=nx>File</span><span class=p>)</span> <span class=nf>Readdir</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>fi</span> <span class=p>[]</span><span class=nx>FileInfo</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>Readdir</code> 内部会调用 <code>Readdirnames</code>，将得到的 <code>names</code> 构造路径，通过 <code>Lstat</code> 构造出 <code>[]FileInfo</code>。</p><p>例：列出某个目录的文件列表</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;io&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;os&#34;</span>
</span></span><span class=line><span class=cl>   <span class=s>&#34;path/filepath&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nf>ReadAndOutputDir</span><span class=p>(</span><span class=s>&#34;../../..&#34;</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>ReadAndOutputDir</span><span class=p>(</span><span class=nx>rootPath</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>deep</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=nx>file</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Open</span><span class=p>(</span><span class=nx>rootPath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=k>defer</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>fileInfos</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>file</span><span class=p>.</span><span class=nf>Readdir</span><span class=p>(</span><span class=mi>100</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=nx>err</span> <span class=o>==</span> <span class=nx>io</span><span class=p>.</span><span class=nx>EOF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>         <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;readdir error:&#34;</span><span class=p>,</span> <span class=nx>err</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=k>return</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>fileInfos</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>break</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>fileInfo</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>fileInfos</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>         <span class=k>if</span> <span class=nx>fileInfo</span><span class=p>.</span><span class=nf>IsDir</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=nx>deep</span> <span class=p>&gt;</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>               <span class=nf>ReadAndOutputDir</span><span class=p>(</span><span class=nx>filepath</span><span class=p>.</span><span class=nf>Join</span><span class=p>(</span><span class=nx>rootPath</span><span class=p>,</span> <span class=nb>string</span><span class=p>(</span><span class=nx>os</span><span class=p>.</span><span class=nx>PathSeparator</span><span class=p>),</span> <span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Name</span><span class=p>()),</span> <span class=nx>deep</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;file:&#34;</span><span class=p>,</span> <span class=nx>fileInfo</span><span class=p>.</span><span class=nf>Name</span><span class=p>(),</span> <span class=s>&#34;in directory:&#34;</span><span class=p>,</span> <span class=nx>rootPath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>         <span class=p>}</span>
</span></span><span class=line><span class=cl>      <span class=p>}</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-03-22 14:57:16">更新于 2023-03-22</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/ data-title="Go os 标准库" data-hashtags="Go 库"><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/ data-hashtag="Go 库"><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/os/ data-title="Go os 标准库"><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/go-%E5%BA%93/>Go 库</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/io/io/ class=prev rel=prev title="Go io 标准库"><i class="fa-solid fa-angle-left fa-fw"></i>Go io 标准库</a>
<a href=/Notes/posts/courses/%E5%AE%9E%E7%94%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%8B%B1%E8%AF%AD/ class=next rel=next title=实用计算机英语>实用计算机英语<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>