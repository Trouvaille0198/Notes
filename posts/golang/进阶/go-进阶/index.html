<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title>Go 进阶 - 伤心肠粉的酱油碟子</title><meta name=Description content><meta property="og:title" content="Go 进阶">
<meta property="og:description" content="Go 进阶 内存对齐 引入 1 2 3 4 5 6 7 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？ 1 2 3 4 5 6 7 8 func main() { fmt.Printf(&#34;bool size: %d\n&#34;,">
<meta property="og:type" content="article">
<meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-03-03T00:00:00+00:00">
<meta property="article:modified_time" content="2022-03-06T08:20:50+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Go 进阶">
<meta name=twitter:description content="Go 进阶 内存对齐 引入 1 2 3 4 5 6 7 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？ 1 2 3 4 5 6 7 8 func main() { fmt.Printf(&#34;bool size: %d\n&#34;,">
<meta name=application-name content="伤心肠粉的酱油碟子">
<meta name=apple-mobile-web-app-title content="伤心肠粉的酱油碟子"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go 进阶","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/%E8%BF%9B%E9%98%B6\/go-%E8%BF%9B%E9%98%B6\/"},"genre":"posts","keywords":"进阶","wordcount":7512,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/%E8%BF%9B%E9%98%B6\/go-%E8%BF%9B%E9%98%B6\/","datePublished":"2022-03-03T00:00:00+00:00","dateModified":"2022-03-06T08:20:50+00:00","publisher":{"@type":"Organization","name":"MelonCholi"},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a>
</div><div class=menu>
<div class=menu-inner><a class=menu-item href=/Notes/posts/> 文章 </a><a class=menu-item href=/Notes/tags/> 标签 </a><a class=menu-item href=/Notes/categories/> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div></div></div></header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a>
</div><div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div></div><div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
取消
</a>
</div><a class=menu-item href=/Notes/posts/ title>文章</a><a class=menu-item href=/Notes/tags/ title>标签</a><a class=menu-item href=/Notes/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a></div></div></header><div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div></div><main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Go 进阶</h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/Notes/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>MelonCholi</a></span>&nbsp;<span class=post-category>收录于 <a href=/Notes/categories/golang/><i class="far fa-folder fa-fw"></i>Golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-03>2022-03-03</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7512 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#内存对齐>内存对齐</a>
<ul>
<li><a href=#引入>引入</a></li><li><a href=#定义>定义</a>
<ul>
<li><a href=#例>例</a></li><li><a href=#为什么要关心对齐>为什么要关心对齐</a></li><li><a href=#为什么要做对齐>为什么要做对齐</a></li></ul></li><li><a href=#默认系数>默认系数</a>
<ul>
<li><a href=#类型的对称系数>类型的对称系数</a></li></ul></li><li><a href=#结构体的整体对齐>结构体的整体对齐</a>
<ul>
<li><a href=#对齐规则>对齐规则</a></li><li><a href=#分析流程>分析流程</a>
<ul>
<li><a href=#变量对齐>变量对齐</a></li><li><a href=#整体对齐>整体对齐</a></li></ul></li></ul></li><li><a href=#调整字段顺序来优化内存>调整字段顺序来优化内存</a></li></ul></li><li><a href=#边界检查消除>边界检查消除</a>
<ul>
<li><a href=#例子-1>例子 1</a></li><li><a href=#例子-2>例子 2</a></li><li><a href=#例子-3>例子 3</a></li><li><a href=#例子-4>例子 4</a></li><li><a href=#例子-5>例子 5</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#延迟函数调用>延迟函数调用</a>
<ul>
<li><a href=#一个延迟调用可以修改包含此延迟调用的最内层函数的返回值>一个延迟调用可以修改包含此延迟调用的最内层函数的返回值</a></li><li><a href=#延迟函数调用的必要性和好处>延迟函数调用的必要性和好处</a></li><li><a href=#star-协程和延迟调用的实参的估值时刻>:star: 协程和延迟调用的实参的估值时刻</a>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href=#顺便说一句使用-timesleep-调用来做并发同步不是一个好的方法-如果上面这个程序运行在一个满负荷运行的电脑上此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了>顺便说一句，使用 <code>time.Sleep</code> 调用来做并发同步不是一个好的方法。 如果上面这个程序运行在一个满负荷运行的电脑上，此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了。</a></li></ul></li></ul></li></ul></li></ul></li><li><a href=#恐慌panic和恢复recover>恐慌（panic）和恢复（recover）</a>
<ul>
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href=#对于官方标准编译器来说很多致命性错误比如堆栈溢出和内存不足不能被恢复它们一旦产生程序将崩溃>对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。</a></li></ul></li></ul></li></ul></li><li><a href=#一些恐慌恢复用例>一些恐慌/恢复用例</a></li><li><a href=#详解恐慌和恢复原理>详解恐慌和恢复原理</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=go-进阶>Go 进阶</h1><h2 id=内存对齐>内存对齐</h2><h3 id=引入>引入</h3><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Part1</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=kt>int8</span>
</span></span><span class=line><span class=cl>    <span class=nx>d</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>e</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在开始之前，希望你计算一下 <code>Part1</code> 共占用的大小是多少呢？</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;bool size: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nb>bool</span><span class=p>(</span><span class=kc>true</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int32 size: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int8 size: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nb>int8</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int64 size: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;byte size: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nb>byte</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;string size: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=s>&#34;EDDYCJY&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出结果：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kt>bool</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>int32</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=kt>int8</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>int64</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=kt>byte</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>16</span>
</span></span></code></pre></td></tr></table></div></div><p>这么一算，<code>Part1</code> 这一个结构体的占用内存大小为 1+4+1+8+1 = 15 个字节。相信有的小伙伴是这么算的，看上去也没什么毛病</p><p>真实情况是怎么样的呢？我们实际调用看看，如下：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Part1</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=kt>int8</span>
</span></span><span class=line><span class=cl>    <span class=nx>d</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>e</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>part1</span> <span class=o>:=</span> <span class=nx>Part1</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;part1 size: %d, align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>part1</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nx>part1</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出结果：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>part1</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>32</span><span class=p>,</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>8</span>
</span></span></code></pre></td></tr></table></div></div><p>最终输出为占用 32 个字节。这与前面所预期的结果完全不一样。</p><p>在这里要提到 “内存对齐” 这一概念，才能够用正确的姿势去计算。</p><h3 id=定义>定义</h3><p>有的小伙伴可能会认为内存读取，就是一个简单的字节数组摆放</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/SZHQJK7.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/SZHQJK7.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/SZHQJK7.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/SZHQJK7.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/SZHQJK7.png title=img></p><p>上图表示一个坑一个萝卜的内存读取方式。但实际上 CPU 并不会以一个一个字节去读取和写入内存。</p><p>相反 CPU 读取内存是<strong>一块一块读取</strong>的，块的大小可以为 2、4、6、8、16 字节等大小。</p><p>块大小我们称其为<strong>内存访问粒度</strong>。如下图：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/mCFZWe8.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/mCFZWe8.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/mCFZWe8.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/mCFZWe8.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/mCFZWe8.png title=img></p><p>在样例中，假设访问粒度为 4。 CPU 是以每 4 个字节大小的访问粒度去读取和写入内存的。这才是正确的姿势</p><h4 id=例>例</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/g1RxUTz.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/g1RxUTz.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/g1RxUTz.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/g1RxUTz.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/g1RxUTz.png title=img></p><p>在上图中，假设从 Index1 开始读取，将会出现很崩溃的问题。因为它的内存访问边界是不对齐的。因此 CPU 会做一些额外的处理工作。如下：</p><ol>
<li>CPU <strong>首次</strong>读取未对齐地址的第一个内存块，读取 0-3 字节。并移除不需要的字节 0</li><li>CPU <strong>再次</strong>读取未对齐地址的第二个内存块，读取 4-7 字节。并移除不需要的字节 5、6、7 字节</li><li>合并 1-4 字节的数据</li><li>合并后放入寄存器</li></ol><p>从上述流程可得出，不做 “内存对齐” 是一件有点 &ldquo;麻烦&rdquo; 的事。因为它会增加许多耗费时间的动作。</p><p>而假设做了内存对齐，从 Index0 开始读取 4 个字节，只需要读取一次，也不需要额外的运算。这显然高效很多，是标准的<strong>空间换时间</strong>做法。</p><h4 id=为什么要关心对齐>为什么要关心对齐</h4><ul>
<li>你正在编写的代码在性能（CPU、Memory）方面有一定的要求</li><li>你正在处理向量方面的指令</li><li>某些硬件平台（ARM）体系不支持未对齐的内存访问</li></ul><p>另外作为一个工程师，你也很有必要学习这块知识点哦 :)</p><h4 id=为什么要做对齐>为什么要做对齐</h4><ul>
<li>平台（移植性）原因：不是所有的硬件平台都能够访问任意地址上的任意数据。例如：特定的硬件平台只允许在特定地址获取特定类型的数据，否则会导致异常情况</li><li>性能原因：若访问未对齐的内存，将会导致 CPU 进行两次内存访问，并且要花费额外的时钟周期来处理对齐及运算。而本身就对齐的内存仅需要一次访问就可以完成读取动作</li></ul><h3 id=默认系数>默认系数</h3><p>在不同平台上的编译器都有自己默认的 “对齐系数”，可通过预编译命令 <code>#pragma pack(n)</code> 进行变更，n 就是代指 “对齐系数”。一般来讲，我们常用的平台的系数如下：</p><ul>
<li>32 位：4</li><li>64 位：8</li></ul><p>另外要注意，不同硬件平台占用的大小和对齐值都可能是不一样的。因此本文的值不是唯一的，调试的时候需按本机的实际情况考虑</p><h4 id=类型的对称系数>类型的对称系数</h4><p>在 Go 中可以调用 <code>unsafe.Alignof</code> 来返回相应<strong>类型的对齐系数</strong>。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;bool align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>bool</span><span class=p>(</span><span class=kc>true</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int32 align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int32</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int8 align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int8</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;int64 align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;byte align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nb>byte</span><span class=p>(</span><span class=mi>0</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;string align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=s>&#34;EDDYCJY&#34;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;map align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>string</span><span class=p>{}))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kt>bool</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>int32</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl><span class=kt>int8</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>int64</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=kt>byte</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl><span class=kt>string</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=kd>map</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>8</span>
</span></span></code></pre></td></tr></table></div></div><p>通过观察输出结果，可得知基本都是 <code>2^n</code>，最大也不会超过 8。这是因为当前测试（64 位）编译器默认对齐系数是 8，因此最大值不会超过这个数</p><h3 id=结构体的整体对齐>结构体的整体对齐</h3><p>在上小节中，提到了结构体中的成员变量要做字节对齐。那么想当然身为最终结果的结构体，也是需要做字节对齐的</p><h4 id=对齐规则>对齐规则</h4><ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>当前成员变量类型的长度</strong>（<code>unsafe.Sizeof</code>），取<strong>最小值作为当前类型的对齐值</strong>，其偏移量必须为对齐值的整数倍</li><li>结构体本身，对齐值必须为<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）或<strong>结构体的所有成员变量类型中的最大长度</strong>，取<strong>最大数的最小整数倍</strong>作为对齐值</li><li>结合以上两点，可得知若<strong>编译器默认对齐长度</strong>（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li></ul><h4 id=分析流程>分析流程</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220303194913655.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220303194913655.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220303194913655.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220303194913655.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220303194913655.png title=image-20220303194913655></p><h5 id=变量对齐>变量对齐</h5><ul>
<li>
<p>第一个成员 a</p><ul>
<li>
<p>类型为 bool</p></li><li>
<p>大小/对齐值为 1 字节</p></li><li>
<p>初始地址，偏移量为 0。占用了第 1 位</p></li></ul></li><li>
<p>第二个成员 b</p><ul>
<li>
<p>类型为 int32</p></li><li>
<p>大小/对齐值为 4 字节</p></li><li>
<p>根据规则 1，其偏移量必须为 4 的整数倍。确定偏移量为 4，因此 2-4 位为 Padding。而当前数值从第 5 位开始填充，到第 8 位。如下：axxx|bbbb</p></li></ul></li><li>
<p>第三个成员 c</p><ul>
<li>
<p>类型为 int8</p></li><li>
<p>大小/对齐值为 1 字节</p></li><li>
<p>根据规则1，其偏移量必须为 1 的整数倍。当前偏移量为 8。不需要额外对齐，填充 1 个字节到第 9 位。如下：axxx|bbbb|c&mldr;</p></li></ul></li><li>
<p>第四个成员 d</p><ul>
<li>
<p>类型为 int64</p></li><li>
<p>大小/对齐值为 8 字节</p></li><li>
<p>根据规则 1，其偏移量必须为 8 的整数倍。确定偏移量为 16，因此</p><p>9-16 位为 Padding。而当前数值从第 17 位开始写入，到第 24 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd</p></li></ul></li><li>
<p>第五个成员 e</p><ul>
<li>
<p>类型为 byte</p></li><li>
<p>大小/对齐值为 1 字节</p></li><li>
<p>根据规则 1，其偏移量必须为 1 的整数倍。当前偏移量为 24。不需要额外对齐，填充 1 个字节到第 25 位。如下：axxx|bbbb|cxxx|xxxx|dddd|dddd|e&mldr;</p></li></ul></li></ul><h5 id=整体对齐>整体对齐</h5><p>在每个成员变量进行对齐后，根据规则 2，整个结构体本身也要进行字节对齐，因为可发现它可能并不是 <code>2^n</code>，不是偶数倍。显然不符合对齐的规则</p><p>根据规则 2，可得出对齐值为 8。现在的偏移量为 25，不是 8 的整倍数。因此确定偏移量为 32。对结构体进行对齐</p><p>axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p><h3 id=调整字段顺序来优化内存>调整字段顺序来优化内存</h3><p>在上一小节，可得知根据成员变量的类型不同，其结构体的内存会产生对齐等动作。那假设字段顺序不同，会不会有什么变化呢？我们一起来试试吧 :-)</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Part1</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=kt>int8</span>
</span></span><span class=line><span class=cl>    <span class=nx>d</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=nx>e</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Part2</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>e</span> <span class=kt>byte</span>
</span></span><span class=line><span class=cl>    <span class=nx>c</span> <span class=kt>int8</span>
</span></span><span class=line><span class=cl>    <span class=nx>a</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>    <span class=nx>b</span> <span class=kt>int32</span>
</span></span><span class=line><span class=cl>    <span class=nx>d</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>part1</span> <span class=o>:=</span> <span class=nx>Part1</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>part2</span> <span class=o>:=</span> <span class=nx>Part2</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;part1 size: %d, align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>part1</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nx>part1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;part2 size: %d, align: %d\n&#34;</span><span class=p>,</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Sizeof</span><span class=p>(</span><span class=nx>part2</span><span class=p>),</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nf>Alignof</span><span class=p>(</span><span class=nx>part2</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>part1</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>32</span><span class=p>,</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl><span class=nx>part2</span> <span class=nx>size</span><span class=p>:</span> <span class=mi>16</span><span class=p>,</span> <span class=nx>align</span><span class=p>:</span> <span class=mi>8</span>
</span></span></code></pre></td></tr></table></div></div><p>通过结果可以惊喜的发现，只是 “简单” 对成员变量的字段顺序进行改变，就改变了结构体占用大小</p><p>Part1 内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|exxx|xxxx</p><p>Part2 内存布局：ecax|bbbb|dddd|dddd</p><p>通过<strong>调整结构体内成员变量的字段顺序</strong>可以达到缩小结构体占用大小的的效果，因为它巧妙地减少了 Padding 的存在，让它们更 “紧凑” 了。这一点对于加深 Go 的内存布局印象和大对象的优化非常有帮助。</p><h2 id=边界检查消除>边界检查消除</h2><p>Go 是一个内存安全的语言。在数组和切片的索引和子切片操作中，Go 运行时将检查操作中使用的下标是否越界。 如果下标越界，一个恐慌将产生，以防止这样的操作破坏内存安全。这样的检查称为<strong>边界检查</strong>。</p><p>边界检查使得我们的代码能够安全地运行；但是另一方面，也使得我们的代码运行效率略微降低。</p><p>从 Go 官方工具链 1.7 开始，官方标准编译器使用了一个新的基于 SSA（single-assignment form，静态单赋值形式）的后端。 SSA 使得 Go 编译器可以有效利用诸如 <a href=https://en.wikipedia.org/wiki/Bounds-checking_elimination target=_blank rel="noopener noreffer">BCE</a>（bounds check elimination，边界检查消除）和 <a href=https://en.wikipedia.org/wiki/Common_subexpression_elimination target=_blank rel="noopener noreffer">CSE</a>（common subexpression elimination，公共子表达式消除）等优化：</p><ul>
<li>BCE 可以避免很多不必要的边界检查</li><li>CSE 可以避免很多重复表达式的计算，从而使得编译器编译出的程序执行效率更高。</li></ul><p>有时候这些优化的效果非常明显。</p><p>本文将展示一些例子来解释边界检查消除在官方标准编译器 1.7+ 中的表现。</p><p>对于 Go 官方工具链 1.7+，我们可以使用编译器选项 <code>-gcflags="-d=ssa/check_bce/debug=1"</code> 来列出哪些代码行仍然需要边界检查。</p><h3 id=例子-1>例子 1</h3><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// example1.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f1</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=c1>// 第5行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=c1>// 第6行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=c1>// 第7行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f2</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span> <span class=c1>// 第11行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=c1>// 第12行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=c1>// 第13行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f3</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第17行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第18行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f4</span><span class=p>(</span><span class=nx>a</span> <span class=p>[</span><span class=mi>5</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=mi>4</span><span class=p>]</span> <span class=c1>// 第22行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go run -gcflags<span class=o>=</span><span class=s2>&#34;-d=ssa/check_bce/debug=1&#34;</span> example1.go
</span></span><span class=line><span class=cl>./example1.go:5: Found IsInBounds
</span></span><span class=line><span class=cl>./example1.go:6: Found IsInBounds
</span></span><span class=line><span class=cl>./example1.go:7: Found IsInBounds
</span></span><span class=line><span class=cl>./example1.go:11: Found IsInBounds
</span></span><span class=line><span class=cl>./example1.go:17: Found IsInBounds
</span></span></code></pre></td></tr></table></div></div><p>我们可以看到函数 <code>f2</code> 中的第 <em>12</em> 行和第 <em>13</em> 行不再需要边界检查了，因为第 <em>11</em> 行的检查确保了第 <em>12</em> 行和第 <em>13</em> 行中使用的下标肯定不会越界。</p><p>但是，函数 <code>f1</code> 中的三行仍然都需要边界检查，因为第 <em>5</em> 行中的边界检查不能保证第 <em>6</em> 行和第 <em>7</em> 行中的下标没有越界，第 <em>6</em> 行中的边界检查也不能保证第第 <em>7</em> 行中的下标没有越界。</p><p>在函数 <code>f3</code> 中，编译器知道如果第一个 <code>s[index]</code> 是安全的，则第二个 <code>s[index]</code> 是无需边界检查的。</p><p>编译器也正确地认为函数 <code>f4</code> 中的唯一一行（第 <em>22</em> 行）是无需边界检查的。</p><h3 id=例子-2>例子 2</h3><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// example2.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f5</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>s</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f6</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>);</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>i</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f7</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span><span class=o>--</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=c1>// line22
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>i</span><span class=p>:</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f8</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>index</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>index</span> <span class=p>&lt;</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>		<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>:</span><span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>f9</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mi>2</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	    <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>],</span> <span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=err>$</span> <span class=k>go</span> <span class=nx>run</span> <span class=o>-</span><span class=nx>gcflags</span><span class=p>=</span><span class=s>&#34;-d=ssa/check_bce/debug=1&#34;</span> <span class=nx>example2</span><span class=p>.</span><span class=k>go</span>
</span></span></code></pre></td></tr></table></div></div><p>官方标准编译器消除了上例程序中的所有边界检查。</p><blockquote>
<p>注意：在 Go 官方工具链 1.11 之前，官方标准编译器没有足够聪明到认为第 <em>22</em> 行是不需要边界检查的。</p></blockquote><h3 id=例子-3>例子 3</h3><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// example3.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fa</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第9行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>:]</span> <span class=c1>// 第10行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fb</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第14行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>:]</span> <span class=c1>// 第15行： 需要边界检查（不够智能？）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fc</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第22行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>:]</span> <span class=c1>// 第23行： 需要边界检查（不够智能？）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ go run -gcflags<span class=o>=</span><span class=s2>&#34;-d=ssa/check_bce/debug=1&#34;</span> example3.go
</span></span><span class=line><span class=cl>./example3.go:9: Found IsSliceInBounds
</span></span><span class=line><span class=cl>./example3.go:14: Found IsSliceInBounds
</span></span><span class=line><span class=cl>./example3.go:15: Found IsSliceInBounds
</span></span><span class=line><span class=cl>./example3.go:22: Found IsSliceInBounds
</span></span><span class=line><span class=cl>./example3.go:23: Found IsSliceInBounds
</span></span></code></pre></td></tr></table></div></div><p>噢，仍然有这么多的边界检查！</p><p>但是等等，为什么官方标准编译器认为第 <em>10</em> 行不需要边界检查，却认为第 <em>15</em> 和第 <em>23</em> 行仍旧需要边界检查呢？ 是标准编译器不够智能吗？</p><p>事实上，这里标准编译器做得对。原因是<strong>一个子切片表达式中的起始下标可能会大于基础切片的长度</strong>。</p><p>让我们先看一个简单的使用了子切片的例子：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s0</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// len(s0) == 5, cap(s0) == 10
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=o>:=</span> <span class=mi>8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 在Go中，对于一个子切片表达式s[a:b]，a和b须满足
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 0 &lt;= a &lt;= b &lt;= cap(s);否则，将产生一个恐慌。
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s0</span><span class=p>[:</span><span class=nx>index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 上一行是安全的不能保证下一行是无需边界检查的。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 事实上，下一行将产生一个恐慌，因为起始下标
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// index大于终止下标（即切片s0的长度）。
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s0</span><span class=p>[</span><span class=nx>index</span><span class=p>:]</span> <span class=c1>// panic
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>所以 <strong>如果<code>s[:index]</code>是安全的，则<code>s[index:]</code>是无需边界检查的</strong> 这条论述只有在 <code>len(s)</code> 和 <code>cap(s)</code> 相等的情况下才正确。这就是函数 <code>fb</code> 和 <code>fc</code> 中的代码仍旧需要边界检查的原因。</p><p>而在例子 3 中，标准编译器成功地检测到在函数 <code>fa</code> 中 <code>len(s)</code> 和 <code>cap(s)</code> 是相等的。</p><h3 id=例子-4>例子 4</h3><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// example4.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;math/rand&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fb2</span><span class=p>(</span><span class=nx>s</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>index</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>:]</span> <span class=c1>// 第7行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第8行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fc2</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span><span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=mi>4</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=nx>index</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=mi>7</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[</span><span class=nx>index</span><span class=p>:]</span> <span class=c1>// 第15行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>s</span><span class=p>[:</span><span class=nx>index</span><span class=p>]</span> <span class=c1>// 第16行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=err>$</span> <span class=k>go</span> <span class=nx>run</span> <span class=o>-</span><span class=nx>gcflags</span><span class=p>=</span><span class=s>&#34;-d=ssa/check_bce/debug=1&#34;</span> <span class=nx>example4</span><span class=p>.</span><span class=k>go</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>example4</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>7</span><span class=p>:</span><span class=mi>7</span><span class=p>:</span> <span class=nx>Found</span> <span class=nx>IsSliceInBounds</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>example4</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>15</span><span class=p>:</span><span class=mi>7</span><span class=p>:</span> <span class=nx>Found</span> <span class=nx>IsSliceInBounds</span>
</span></span></code></pre></td></tr></table></div></div><p>在此例子中，标准编译器成功推断出：</p><ul>
<li>在函数 <code>fb2</code> 中，如果第 <em>7</em> 行是安全的，则第 <em>8</em> 行是无需边界检查的；</li><li>在函数 <code>fc2</code> 中，如果第 <em>15</em> 行是安全的，则第 <em>16</em> 行是无需边界检查的。</li></ul><p>注意：Go 官方工具链 1.9 之前中的标准编译器没有出推断出第 <em>8</em> 行不需要边界检查。</p><h3 id=例子-5>例子 5</h3><p>当前版本的标准编译器并非足够智能到可以消除到一切应该消除的边界检查。 有时候，我们需要给标准编译器一些暗示来帮助标准编译器将这些不必要的边界检查消除掉。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// example5.go
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fd</span><span class=p>(</span><span class=nx>is</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>bs</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>is</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>256</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>_</span> <span class=p>=</span> <span class=nx>is</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=c1>// 第7行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fd2</span><span class=p>(</span><span class=nx>is</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>bs</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>is</span><span class=p>)</span> <span class=o>&gt;=</span> <span class=mi>256</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>is</span> <span class=p>=</span> <span class=nx>is</span><span class=p>[:</span><span class=mi>256</span><span class=p>]</span> <span class=c1>// 第14行： 一个暗示
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>bs</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>_</span> <span class=p>=</span> <span class=nx>is</span><span class=p>[</span><span class=nx>n</span><span class=p>]</span> <span class=c1>// 第16行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fe</span><span class=p>(</span><span class=nx>isa</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>isb</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>isa</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mh>0xFFF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>isb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>_</span> <span class=p>=</span> <span class=nx>isa</span><span class=p>[</span><span class=nx>n</span> <span class=o>&amp;</span> <span class=mh>0xFFF</span><span class=p>]</span> <span class=c1>// 第24行： 需要边界检查
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>fe2</span><span class=p>(</span><span class=nx>isa</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>isb</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=nx>isa</span><span class=p>)</span> <span class=p>&gt;</span> <span class=mh>0xFFF</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>isa</span> <span class=p>=</span> <span class=nx>isa</span><span class=p>[:</span><span class=mh>0xFFF</span><span class=o>+</span><span class=mi>1</span><span class=p>]</span> <span class=c1>// 第31行： 一个暗示
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=nx>_</span><span class=p>,</span> <span class=nx>n</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>isb</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>_</span> <span class=p>=</span> <span class=nx>isa</span><span class=p>[</span><span class=nx>n</span> <span class=o>&amp;</span> <span class=mh>0xFFF</span><span class=p>]</span> <span class=c1>// 第33行： 边界检查消除了！
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=err>$</span> <span class=k>go</span> <span class=nx>run</span> <span class=o>-</span><span class=nx>gcflags</span><span class=p>=</span><span class=s>&#34;-d=ssa/check_bce/debug=1&#34;</span> <span class=nx>example5</span><span class=p>.</span><span class=k>go</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>example5</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>7</span><span class=p>:</span> <span class=nx>Found</span> <span class=nx>IsInBounds</span>
</span></span><span class=line><span class=cl><span class=p>.</span><span class=o>/</span><span class=nx>example5</span><span class=p>.</span><span class=k>go</span><span class=p>:</span><span class=mi>24</span><span class=p>:</span> <span class=nx>Found</span> <span class=nx>IsInBounds</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=总结>总结</h3><p>本文上面列出的例子并没有涵盖标准编译器支持的所有边界检查消除的情形。本文列出的仅仅是一些常见的情形。</p><p>尽管标准编译器中的边界检查消除特性依然不是 100% 完美，但是对很多常见的情形，它确实很有效。 自从标准编译器支持此特性以来，在每个版本更新中，此特性都在不断地改进增强。 无需质疑，在以后的版本中，标准编译器会更加得智能，以至于上面第 5 个例子中提供给编译器的暗示有可能将变得不再必要。</p><h2 id=延迟函数调用>延迟函数调用</h2><blockquote>
<p>deferred function call</p></blockquote><p>在Go中，一个函数调用可以跟在一个 <code>defer</code> 关键字后面，形成一个延迟函数调用。 和协程调用类似，<strong>被延迟的函数调用的所有返回值必须全部被舍弃。</strong></p><p>当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个延迟调用堆栈。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的<a href=https://gfw.go101.org/article/function-declarations-and-calls.html#exiting-phase target=_blank rel="noopener noreffer">退出阶段</a>后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。</p><p>下面这个例子展示了如何使用延迟调用函数。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;The third line.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;The second line.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;The first line.&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>输出结果：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>The first line.
</span></span><span class=line><span class=cl>The second line.
</span></span><span class=line><span class=cl>The third line.
</span></span></code></pre></td></tr></table></div></div><p>事实上，每个协程维护着两个调用堆栈。</p><ul>
<li>一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈中最早被推入的调用是对应协程的启动调用。</li><li>另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。</li></ul><p>下面是另一个略微复杂一点的使用了延迟调用的例子程序。此程序将按照自然数的顺序打印出 0 到 9 十个数字。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;9&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;0&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;8&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;1&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=kc>false</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;not reachable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;7&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;3&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;5&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;6&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}()</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;4&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;2&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;not reachable&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=一个延迟调用可以修改包含此延迟调用的最内层函数的返回值>一个延迟调用可以修改包含此延迟调用的最内层函数的返回值</h3><p>一个例子：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>Triple</span><span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>(</span><span class=nx>r</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>r</span> <span class=o>+=</span> <span class=nx>n</span> <span class=c1>// 修改返回值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=nx>n</span> <span class=o>+</span> <span class=nx>n</span> <span class=c1>// &lt;=&gt; r = n + n; return
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nf>Triple</span><span class=p>(</span><span class=mi>5</span><span class=p>))</span> <span class=c1>// 15
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=延迟函数调用的必要性和好处>延迟函数调用的必要性和好处</h3><p>事实上，上面的几个使用了延迟函数调用的例子中的延迟函数调用并非绝对必要。 但是延迟调用对于下面将要介绍的恐慌 / 恢复特性是必要的。</p><p>另外延迟函数调用可以帮助我们写出更整洁和更鲁棒的代码。</p><h3 id=star-协程和延迟调用的实参的估值时刻>:star: 协程和延迟调用的实参的估值时刻</h3><p>一个协程调用或者延迟调用的实参是在此调用发生时被估值的。更具体地说，</p><ul>
<li>
<p>对于一个<strong>延迟函数调用</strong>，它的实参是在此调用<strong>被推入延迟调用堆栈</strong>的时候被估值的。</p></li><li>
<p>对于一个<strong>协程调用</strong>，它的实参是在此协程<strong>被创建</strong>的时候估值的。</p></li><li>
<p>一个<strong>匿名函数</strong>体内的表达式是在此函数被<strong>执行</strong>的时候才会被逐个估值的，不管此函数是被普通调用还是延迟 / 协程调用。</p></li></ul><p>一个例子：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span> <span class=c1>// 推入堆栈时被估值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>				<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span> <span class=c1>// 执行时被估值
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=p>}()</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>运行之，将得到如下结果：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a: 2
</span></span><span class=line><span class=cl>a: 1
</span></span><span class=line><span class=cl>a: 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>b: 3
</span></span><span class=line><span class=cl>b: 3
</span></span><span class=line><span class=cl>b: 3
</span></span></code></pre></td></tr></table></div></div><p>第一个匿名函数中的循环打印出 <code>2</code>、<code>1</code> 和 <code>0</code> 这个序列，但是第二个匿名函数中的循环打印出三个 <code>3</code>。 因为第一个循环中的 <code>i</code> 是在 <code>fmt.Println</code> 函数调用被推入延迟调用堆栈的时候估的值，而第二个循环中的 <code>i</code> 是在第二个匿名函数调用的退出阶段估的值（此时循环变量 <code>i</code> 的值已经变为 <code>3</code>）。</p><p>我们可以对第二个循环略加修改（使用两种方法），使得它和第一个循环打印出相同的结果。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>defer</span> <span class=kd>func</span><span class=p>(</span><span class=nx>i</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 此i为形参i，非实参循环变量i。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}(</span><span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>或者</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>3</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>i</span> <span class=o>:=</span> <span class=nx>i</span> <span class=c1>// 在下面的调用中，左i遮挡了右i。
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// &lt;=&gt; var i = i
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 此i为上面的左i，非循环变量i。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;b:&#34;</span><span class=p>,</span> <span class=nx>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>同样的估值时刻规则也<strong>适用于协程调用</strong>。下面这个例子程序将打印出 <code>123 789</code>。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>a</span> <span class=p>=</span> <span class=mi>123</span>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>(</span><span class=nx>x</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// x在创建时被估值
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>a</span><span class=p>)</span> <span class=c1>// 123 789
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}(</span><span class=nx>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>a</span> <span class=p>=</span> <span class=mi>789</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=mi>2</span> <span class=o>*</span> <span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote>
<h6 id=顺便说一句使用-timesleep-调用来做并发同步不是一个好的方法-如果上面这个程序运行在一个满负荷运行的电脑上此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了>顺便说一句，使用 <code>time.Sleep</code> 调用来做并发同步不是一个好的方法。 如果上面这个程序运行在一个满负荷运行的电脑上，此程序可能在新启动的协程可能还未得到执行机会的时候就已经退出了。</h6></blockquote><h2 id=恐慌panic和恢复recover>恐慌（panic）和恢复（recover）</h2><p>Go 不支持异常抛出和捕获，而是<strong>推荐使用返回值显式返回错误</strong>。 不过，Go 支持一套和异常抛出 / 捕获类似的机制。此机制称为恐慌 / 恢复（panic/recover）机制。</p><p>我们可以调用内置函数 <code>panic</code> 来产生一个恐慌以使当前协程进入恐慌状况。</p><p>进入恐慌状况是另一种使当前函数调用开始返回的途径。 <strong>一旦一个函数调用产生一个恐慌，此函数调用将立即进入它的退出阶段，在此函数调用中被推入堆栈的延迟调用将按照它们被推入的顺序逆序执行。</strong></p><p>通过在一个延迟函数调用之中调用内置函数 <code>recover</code>，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况。</p><p><strong>在一个处于恐慌状况的协程退出之前，其中的恐慌不会蔓延到其它协程；如果一个协程在恐慌状况下退出，它将使整个程序崩溃。</strong></p><p>内置函数 <code>panic</code> 和 <code>recover</code> 的声明原型如下：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nb>panic</span><span class=p>(</span><span class=nx>v</span> <span class=kd>interface</span><span class=p>{})</span>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nb>recover</span><span class=p>()</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><p>在一个 <code>panic</code> 函数调用中，我们可以传任何实参值。</p><p>一个 <code>recover</code> 函数的返回值为其所恢复的恐慌在产生时被一个 <code>panic</code> 函数调用所消费的参数。</p><p>下面这个例子展示了如何产生一个恐慌和如何消除一个恐慌。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;正常退出&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;嗨！&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>v</span> <span class=o>:=</span> <span class=nb>recover</span><span class=p>()</span>
</span></span><span class=line><span class=cl>		<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;恐慌被恢复了：&#34;</span><span class=p>,</span> <span class=nx>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>	<span class=nb>panic</span><span class=p>(</span><span class=s>&#34;拜拜！&#34;</span><span class=p>)</span> <span class=c1>// 产生一个恐慌
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;执行不到这里&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>它的输出结果：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>嗨！
</span></span><span class=line><span class=cl>恐慌被恢复了： 拜拜！
</span></span><span class=line><span class=cl>正常退出
</span></span></code></pre></td></tr></table></div></div><p>下面的例子在一个新协程里面产生了一个恐慌，并且此协程在恐慌状况下退出，所以整个程序崩溃了。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;time&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;hi!&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nb>panic</span><span class=p>(</span><span class=mi>123</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>运行之，输出如下：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>hi!
</span></span><span class=line><span class=cl>panic: 123
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>goroutine 5 [running]:
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>Go运行时（runtime）会在若干情形下产生恐慌，比如一个整数被 0 除的时候。下面这个程序将崩溃退出。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>a</span><span class=p>,</span> <span class=nx>b</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>	<span class=nx>_</span> <span class=p>=</span> <span class=nx>a</span><span class=o>/</span><span class=nx>b</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>它的输出：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>panic: runtime error: integer divide by zero
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>goroutine 1 [running]:
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>一般说来，<strong>恐慌用来表示正常情况下不应该发生的逻辑错误</strong>。 如果这样的一个错误在运行时刻发生了，则它肯定是由于某个 bug 引起的。 另一方面，非逻辑错误是现实中难以避免的错误，它们不应该导致恐慌。 我们必须正确地对待和处理非逻辑错误。</p><blockquote>
<h6 id=对于官方标准编译器来说很多致命性错误比如堆栈溢出和内存不足不能被恢复它们一旦产生程序将崩溃>对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。</h6></blockquote><h3 id=一些恐慌恢复用例>一些恐慌/恢复用例</h3><h3 id=详解恐慌和恢复原理>详解恐慌和恢复原理</h3></div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2022-03-06</span>
</div><div class=post-info-license></div></div><div class=post-info-line>
<div class=post-info-md></div><div class=post-info-share>
<span></span>
</div></div></div><div class=post-info-more>
<section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E8%BF%9B%E9%98%B6/>进阶</a></section><section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span>
</section></div><div class=post-nav><a href=/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/ class=prev rel=prev title="Go 高性能编程"><i class="fas fa-angle-left fa-fw"></i>Go 高性能编程</a>
<a href=/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/ class=next rel=next title="Go runtime/pprof库">Go runtime/pprof库<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer>
<div class=footer-container><div class=footer-line>酒困路长惟欲睡，日高人渴漫思茶</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><script type=text/javascript src=/Notes/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/Notes/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:40},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50}}</script><script type=text/javascript src=/Notes/js/theme.min.js></script></body></html>