<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Go nil 详解 - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="Go nil 详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 a0 := make(map[string][]int, 0) var a1 []int a2 :="><meta name=keywords content="进阶"><meta itemprop=name content="Go nil 详解"><meta itemprop=description content="Go nil 详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 a0 := make(map[string][]int, 0) var a1 []int a2 :="><meta itemprop=datePublished content="2022-03-29T00:00:00+00:00"><meta itemprop=dateModified content="2023-06-14T09:53:17+00:00"><meta itemprop=wordCount content="4671"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="进阶,"><meta property="og:title" content="Go nil 详解"><meta property="og:description" content="Go nil 详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 a0 := make(map[string][]int, 0) var a1 []int a2 :="><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/nil-%E8%AF%A6%E8%A7%A3/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-29T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-14T09:53:17+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="Go nil 详解"><meta name=twitter:description content="Go nil 详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 a0 := make(map[string][]int, 0) var a1 []int a2 :="><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/nil-%E8%AF%A6%E8%A7%A3/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/136.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Go nil 详解","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/%E8%BF%9B%E9%98%B6\/nil-%E8%AF%A6%E8%A7%A3\/"},"genre":"posts","keywords":"进阶","wordcount":4671,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/%E8%BF%9B%E9%98%B6\/nil-%E8%AF%A6%E8%A7%A3\/","datePublished":"2022-03-29T00:00:00+00:00","dateModified":"2023-06-14T09:53:17+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Go nil 详解</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/golang/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Golang</a></span></div><div class=post-meta-line><span title="2022-03-29 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-29>2022-03-29</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 4671 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 10 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#nil-到底是什么>nil 到底是什么</a><ul><li><a href=#go-和-c-的变量定义异同>Go 和 C 的变量定义异同</a></li></ul></li><li><a href=#怎么理解-nil>怎么理解 <code>nil</code></a></li><li><a href=#和-nil-打交道的-6-大类型>和 <code>nil</code> 打交道的 6 大类型</a><ul><li><a href=#slice>slice</a><ul><li><a href=#变量定义>变量定义</a></li><li><a href=#变量本身>变量本身</a></li><li><a href=#nil-赋值><code>nil</code> 赋值</a></li><li><a href=#nil-值判断><code>nil</code> 值判断</a></li></ul></li><li><a href=#map>map</a><ul><li><a href=#变量定义-1>变量定义</a></li><li><a href=#变量本身-1>变量本身</a></li><li><a href=#nil-赋值-1><code>nil</code> 赋值</a></li><li><a href=#nil-值判断-1><code>nil</code> 值判断</a></li></ul></li><li><a href=#interface>interface</a><ul><li><a href=#变量定义-2>变量定义</a></li><li><a href=#变量本身-2>变量本身</a></li><li><a href=#nil-赋值-2><code>nil</code> 赋值</a></li><li><a href=#nil-值判断-2><code>nil</code> 值判断</a></li></ul></li><li><a href=#channel>channel</a><ul><li><a href=#变量定义-3>变量定义</a></li><li><a href=#变量本身-3>变量本身</a></li><li><a href=#nil-赋值-3><code>nil</code> 赋值</a></li><li><a href=#nil-值判断-3><code>nil</code> 值判断</a></li></ul></li><li><a href=#指针>指针</a><ul><li><a href=#变量定义-4>变量定义</a></li><li><a href=#变量本身-4>变量本身</a></li><li><a href=#nil-赋值-4><code>nil</code> 赋值</a></li><li><a href=#nil-值判断-4><code>nil</code> 值判断</a></li></ul></li><li><a href=#函数>函数</a><ul><li><a href=#变量定义-5>变量定义</a></li><li><a href=#变量本身-5>变量本身</a></li><li><a href=#nil-赋值-5><code>nil</code> 赋值</a></li><li><a href=#nil-值判断-5><code>nil</code> 值判断</a></li></ul></li></ul></li><li><a href=#总结>总结</a></li><li><a href=#后记>后记</a></li></ul></nav></div></div><div class=content id=content><h1 id=go-nil-详解>Go nil 详解</h1><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>a0</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a1</span> <span class=p>[]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=nx>a2</span> <span class=o>:=</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=nx>a3</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>a0</span><span class=p>[</span><span class=s>&#34;zero&#34;</span><span class=p>]</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// yes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a0 is nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>a1</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// yes
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a1 is nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>a2</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// no
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a2 is nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>a3</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// no
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;a3 is nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// won&#39;t panic
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>a0</span><span class=p>[</span><span class=s>&#34;zero&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a0</span><span class=p>[</span><span class=s>&#34;zero&#34;</span><span class=p>],</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>a1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a1</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>a2</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a2</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>a3</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>a3</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=nil-到底是什么>nil 到底是什么</h2><p>答案是<strong>变量</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// nil is a predeclared identifier representing the zero value for a
</span></span></span><span class=line><span class=cl><span class=c1>// pointer, channel, func, interface, map, or slice type.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=kc>nil</span> <span class=nx>Type</span> <span class=c1>// Type must be a pointer, channel, func, interface, map, or slice type
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Type is here for the purposes of documentation only. It is a stand-in
</span></span></span><span class=line><span class=cl><span class=c1>// for any Go type, but represents the same type for any given function
</span></span></span><span class=line><span class=cl><span class=c1>// invocation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Type</span> <span class=kt>int</span>
</span></span></code></pre></td></tr></table></div></div><p>从类型定义得到<strong>两个关键点</strong>：</p><ol><li><code>nil</code> 本质上是一个 <code>Type</code> 类型的变量而已；</li><li><code>Type</code> 类型仅仅是基于 <code>int</code> 定义出来的一个新类型；</li></ol><p>而从 <code>nil</code> 官方的注释中，我们可以得到一个重要信息：</p><p><strong>划重点</strong>：<code>nil</code> 适用于 <strong>指针</strong>，<strong>函数</strong>，<code>interface</code>，<code>map</code>，<code>slice</code>，<code>channel</code> 这 6 种类型</p><h3 id=go-和-c-的变量定义异同>Go 和 C 的变量定义异同</h3><p><strong>相同点</strong>：</p><p>Go 和 C 的变量定义回归最本质原理：分配变量指定大小的内存，确定一个变量名称。</p><p><strong>不同点</strong>：</p><ul><li>Go 分配内存是置 0 分配的。置 0 分配的意思是：Go 确保分配出来的内存块里面是全 0 数据；</li><li>C 默认分配的内存则仅仅是分配内存，里面的数据不能做任何假设，里面是未定义的数据，可能是全 0 ，可能是全 1，可能是 <code>0101</code> 等；</li></ul><p><strong>Go 置 0 分配的原理</strong>：</p><ul><li>栈上变量的内存编译阶段由编译器就保证了置 0 分配，这种反汇编看下就知道了；</li><li>堆上变量的内存由 <code>runtime</code> 保证，可以仔细观察下 <code>mallocgc</code> 这个函数参数有一个 <code>needzero</code> 的参数，用户变量定义触发的入口（比如 <code>newobject</code> 等等 ）这个参数为 <code>true</code>，而该参数就是显式指定置 0 分配的。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>mallocgc</span><span class=p>(</span><span class=nx>size</span> <span class=kt>uintptr</span><span class=p>,</span> <span class=nx>typ</span> <span class=o>*</span><span class=nx>_type</span><span class=p>,</span> <span class=nx>needzero</span> <span class=kt>bool</span><span class=p>)</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>思考一个小问题：Go 既然所用的类型定义都是置 0 分配的，那为什么 <code>mallocgc</code> 需要 <code>needzero</code> 这么一个参数来控制呢？</p><ul><li>首先，Go 的类型定义一定确保是置 0 分配的，这个是 Go 语言给到 Go 程序员的语义。Go <code>runtime</code> 众多的内部的流程（对 Go 程序员不感知的层面）是没有这个规定的。</li><li>其次，置 0 分配是有性能代价的，如果在确保语义的情况下，能不做自然是最好的。</li></ul><p>总结下：Go 的变量定义由语言层面确保置 0 分配，<strong>确保内存块全 0 数据</strong>。请记住这个最本质的约定。所以这个本质上跟 <code>nil</code> 没有关系，也不存在说初始值赋 <code>nil</code> 的说法（虽然 nil 值本质上也仅仅是一个 0 int 大小的内存块）。</p><p>至于怎么跟 <code>nil</code> 搭上交道的，后面交代。</p><h2 id=怎么理解-nil>怎么理解 <code>nil</code></h2><p>通过上面，我们理解了几个东西：</p><ol><li>Go 的类型定义仅比 C 多做了一件事，把分配的内存块置 0，而已；</li><li>能够和 nil 值做判断的，仅仅有 6 个类型。如果你用来其他类型来和 nil 比较，那么在编译期间 <code>typecheck</code> 会报错检查到会报错；</li></ol><p>就笔者理解，<code>nil</code> 这个概念是更高一层的概念，在语言级别，而这个概念是由编译器带给你的。</p><p>不是所有的类型都可以和 <code>nil</code> 进行比较或者赋值，只有这 6 种类型的变量才能和 nil 值比较，因为这是编译器决定的。</p><p>同样的，你不能赋值一个 <code>nil</code> 变量给一个整型，原理也很简单，仅仅是编译器不让，就这么简单。</p><p>所以，<code>nil</code> 其实更准确的理解是一个触发条件，编译器看到和 <code>nil</code> 值比较的写法，那么就要确认类型在这 6 种类型以内，如果是赋值 <code>nil</code>，那么也要确认在这 6 种类型以内，并且对应的结构内存为全 0 数据。</p><p>所以，记住这句话，<code>nil</code> 是编译器识别行为的一个触发点而已，看到这个 <code>nil</code> 会触发编译器的一些特殊判断和操作。</p><h2 id=和-nil-打交道的-6-大类型>和 <code>nil</code> 打交道的 6 大类型</h2><h3 id=slice>slice</h3><h4 id=变量定义>变量定义</h4><p>创建 <code>slice</code> 有两种方法</p><ol><li><code>var</code> 关键字定义；</li><li><code>make</code> 关键字创建；</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 方式一
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>slice1</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>slice2</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=mh>0x1</span><span class=p>,</span> <span class=mh>0x2</span><span class=p>,</span> <span class=mh>0x3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 方式二
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>slice3</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=kd>var</span> <span class=nx>slice4</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>byte</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>首先，slice 变量本身占多少个字节？</p><p>答案是：24 个字节。1 个指针字段，2 个 8 字节的整形字段。</p><p><strong>思考：<code>var</code> 和 <code>make</code> 这两种方式有什么区别？</strong></p><ul><li>第一种 <code>var</code> 的方式定义变量纯粹真的是变量定义，如果逃逸分析之后，确认可以分配在栈上，那就在栈上分配这 24 个字节，如果逃逸到堆上去，那么调用 <code>newobject</code> 函数进行类型分配。</li><li>第二种 <code>make</code> 方式则略有不同，如果逃逸分析之后，确认分配在栈上，那么也是直接在栈上分配 24 字节，如果逃逸到堆上则会导致调用 <code>makeslice</code> 函数来分配变量。</li></ul><h4 id=变量本身>变量本身</h4><p>定义的变量本身分配了多少内存？</p><p>上面已经说过了，无论多大的 slice ，变量本身占用 24 字节。这 24 个字节其实是动态数组的管理结构，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>slice</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>array</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>    <span class=c1>// 管理的内存块首地址
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>len</span>   <span class=kt>int</span>                    <span class=c1>// 动态数组实际使用大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>cap</span>   <span class=kt>int</span>                    <span class=c1>// 动态数组内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>该结构体定义在 <code>src/runtime/slice.go</code> 里。</p><p>划重点：我们看到无论是 <code>var</code> 声明定义的 <code>slice</code> 变量，还是 <code>make(xxx，num)</code> 创建的 <code>slice</code> 变量，<code>slice</code> 管理结构是已经分配出来了的（也就是 <code>struct slice</code> 结构 ）。</p><p>所以， 对于 <code>slice</code> 来说，其实并不需要 <code>make</code> 创建的才能使用，直接用 <code>var</code> 定义出来的 <code>slice</code> 也能直接使用。如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 定义一个 slice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>slice1</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl><span class=c1>// 使用这个 slice
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>slice1</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>slice1</span><span class=p>,</span> <span class=mh>0x1</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>定义的时候，<code>slice</code> 结构本身就已经置 0 分配了，这个 24 字节的 <code>slice</code> 结构就是管理动态数组的核心。有这个在 <code>append</code> 函数就能正常处理 <code>slice</code> 变量。</p><p><strong>思考：<code>append</code> 又是怎么处理的呢？</strong></p><p>本质是调用 <code>runtime.growslice</code> 函数来处理。</p><h4 id=nil-赋值><code>nil</code> 赋值</h4><p>如果把一个已经存在的 <code>slice</code> 结构赋值 <code>nil</code> ，会发生什么事情？</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>slice2</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=mh>0x1</span><span class=p>,</span> <span class=mh>0x2</span><span class=p>,</span> <span class=mh>0x3</span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// slice 赋值 nil
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>slice2</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span></code></pre></td></tr></table></div></div><p>发生什么事？</p><p>事情在编译期间就确定了，就是把 slice2 变量<strong>本身</strong>内存块置 0 ，也就是说 slice2 本身的 24 字节的内存块被置 0。</p><h4 id=nil-值判断><code>nil</code> 值判断</h4><p>编译器认为 <code>slice</code> 做可以做 <code>nil</code> 判断，那么什么样的 <code>slice</code> 认为是 <code>nil</code> 的？</p><p><strong>指针值为 0 的，也就是说这个动态数组没有实际数据的时候。</strong></p><p>思考：仅判断指针？对 len 和 cap 两个字段不做判断吗？</p><ul><li>只对首字段 <code>array</code> 做非 0 判断，len，cap 字段不做判断。</li></ul><p>如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>a</span> <span class=p>[]</span><span class=kt>byte</span> <span class=p>=</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>{</span><span class=mh>0x1</span><span class=p>,</span> <span class=mh>0x2</span><span class=p>,</span> <span class=mh>0x3</span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=nx>a</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对应的部分汇编代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 赋值 array 的值
</span></span><span class=line><span class=cl>0x00000000004587cd &lt;+93&gt;:	mov    %rax,0x20(%rsp)
</span></span><span class=line><span class=cl>// 赋值 len 的值
</span></span><span class=line><span class=cl>0x00000000004587d2 &lt;+98&gt;:	movq   $0x3,0x28(%rsp)
</span></span><span class=line><span class=cl>// 赋值 cap 的值
</span></span><span class=line><span class=cl>0x00000000004587db &lt;+107&gt;:	movq   $0x3,0x30(%rsp)
</span></span><span class=line><span class=cl>// 判断 slice 是否是 nil
</span></span><span class=line><span class=cl>=&gt; 0x00000000004587e4 &lt;+116&gt;:	test   %rax,%rax
</span></span></code></pre></td></tr></table></div></div><p>不信 Go 只判断首字段？为了验证，自己思考下一下的程序的输出：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;unsafe&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>sliceType</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>pdata</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl>	<span class=nx>len</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=nx>cap</span>   <span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>a</span> <span class=p>[]</span><span class=kt>byte</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=o>*</span><span class=nx>sliceType</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>a</span><span class=p>))).</span><span class=nx>len</span> <span class=p>=</span> <span class=mh>0x3</span>
</span></span><span class=line><span class=cl>	<span class=p>((</span><span class=o>*</span><span class=nx>sliceType</span><span class=p>)(</span><span class=nx>unsafe</span><span class=p>.</span><span class=nf>Pointer</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>a</span><span class=p>))).</span><span class=nx>cap</span> <span class=p>=</span> <span class=mh>0x4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>a</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>println</span><span class=p>(</span><span class=s>&#34;not nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>println</span><span class=p>(</span><span class=s>&#34;nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>答案是：输出 <code>nil</code>。</p><h3 id=map>map</h3><h4 id=变量定义-1>变量定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 变量定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>m1</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl><span class=c1>// 定义 &amp; 初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>m2</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>和 slice 类似，上面也是两种差别的方式：</p><ul><li>第一种方式仅仅定义了 m1 变量本身；</li><li>第二种方式则是分配 m2 的内存，还会调用 <code>makehmap</code> 函数（不一定是这个函数，要看逃逸分析的结果，如果是可以栈上分配的，会有一些优化）来创建某个结构，并且把这个函数的返回值赋给 m2；</li></ul><h4 id=变量本身-1>变量本身</h4><p><code>map</code> 的变量本身究竟是什么？比如上面的 <code>m1</code>，<code>m2</code> ?</p><p><strong>m1, m2 变量本身是一个指针，内存占用 8 字节</strong>。这个指针指向的结构才大有来头，指向一个 <code>struct hmap</code> 结构。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>hmap</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>count</span>     <span class=kt>int</span> <span class=c1>// # live cells == size of map.  Must be first (used by len() builtin)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>flags</span>     <span class=kt>uint8</span>
</span></span><span class=line><span class=cl>	<span class=nx>B</span>         <span class=kt>uint8</span>  <span class=c1>// log_2 of # of buckets (can hold up to loadFactor * 2^B items)
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>noverflow</span> <span class=kt>uint16</span> <span class=c1>// approximate number of overflow buckets; see incrnoverflow for details
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>hash0</span>     <span class=kt>uint32</span> <span class=c1>// hash seed
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>buckets</span>    <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// array of 2^B Buckets. may be nil if count==0.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>oldbuckets</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span> <span class=c1>// previous bucket array of half the size, non-nil only when growing
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>nevacuate</span>  <span class=kt>uintptr</span>        <span class=c1>// progress counter for evacuation (buckets less than this have been evacuated)
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>extra</span> <span class=o>*</span><span class=nx>mapextra</span> <span class=c1>// optional fields
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>所以，回到思考问题：为什么 <code>map</code> 结构却光定义还不行，一定要 <code>make(XXMap)</code> 才能使用？</p><p>因为，<code>map</code> 结构的核心在于 <code>struct hmap</code> 结构体，这个结构体是很大的一个结构体。<code>map</code> 的操作核心都是基于这个结构体之上的。而 <code>var</code> 定义一个 <code>map</code> 结构的时候，只是分配了一个 8 字节的指针，<strong>只有调用 <code>make</code> 的时候，才触发调用 <code>makemap</code> ，在这个函数里面分配出一个庞大的 <code>struct hmap</code> 结构体。</strong></p><h4 id=nil-赋值-1><code>nil</code> 赋值</h4><p>如果把一个 <code>map</code> 变量赋值 <code>nil</code> 那就很容易理解了，仅仅是把这个变量本身置 0 而已，也就是这个指针变量置 0 ，<code>hmap</code> 结构体本身是不会动的。</p><p>当然考虑垃圾回收的话，如果这个 <code>m1</code> 是唯一的指向这个 <code>hmap</code> 结构，那么 <code>m1</code> 赋值 <code>nil</code> 之后，那么这个 <code>hmap</code> 结构体之后就可能被回收。</p><h4 id=nil-值判断-1><code>nil</code> 值判断</h4><p>搞懂了变量本身和管理结构的区别就很简单了，这里的 <code>nil</code> 值判断也仅仅是针对变量本身的判断，<strong>只要是非 0 指针，那么就是非 <code>nil</code></strong> 。也就是说 <code>m1</code> 只要是一个非 0 的指针，就不会是非 <code>nil</code> 的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>m1</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>m2</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>m1</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>println</span><span class=p>(</span><span class=s>&#34;m1 not nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>println</span><span class=p>(</span><span class=s>&#34;m1 nil&#34;</span><span class=p>)</span> <span class=c1>// bingo
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=nx>m2</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>println</span><span class=p>(</span><span class=s>&#34;m2 not nil&#34;</span><span class=p>)</span> <span class=c1>// bingo
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nb>println</span><span class=p>(</span><span class=s>&#34;m2 nil&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>如上示例程序，m1 是一个 0 指针，m2 被赋值了的。</p><h3 id=interface>interface</h3><h4 id=变量定义-2>变量定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 定义一个接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Reader</span> <span class=kd>interface</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>Read</span><span class=p>(</span><span class=nx>p</span> <span class=p>[]</span><span class=kt>byte</span><span class=p>)</span> <span class=p>(</span><span class=nx>n</span> <span class=kt>int</span><span class=p>,</span> <span class=nx>err</span> <span class=kt>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 定义一个接口变量
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>reader</span> <span class=nx>Reader</span>
</span></span><span class=line><span class=cl><span class=c1>// 或者一个空接口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>empty</span> <span class=kd>interface</span><span class=p>{}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=变量本身-2>变量本身</h4><p>interface 稍微有点特殊，有两种对应的结构体，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>iface</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>tab</span>  <span class=o>*</span><span class=nx>itab</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span> <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>type</span> <span class=nx>eface</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>_type</span> <span class=o>*</span><span class=nx>_type</span>
</span></span><span class=line><span class=cl>    <span class=nx>data</span>  <span class=nx>unsafe</span><span class=p>.</span><span class=nx>Pointer</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>其中，<code>iface</code> 就是通常定义的 interface 类型，<code>eface</code> 则是通常人们常说的 <code>空接口</code> 对应的数据结构。</p><p>不管内部怎么样，这两个结构体占用内存是一样的，都是<strong>一个正常的指针类型和一个无类型的指针类型</strong>（ <code>Pointer</code> ），总共占用 16 个字节。</p><p>也就是说，如果你声明定义一个 <code>interface</code> 类型，无论是空接口，还是具体的接口类型，都只是分配了一个 16 字节的内存块给你，注意是置 0 分配哦。</p><h4 id=nil-赋值-2><code>nil</code> 赋值</h4><p>和上面类似，如果对一个 <code>interface</code> 变量赋值 <code>nil</code> 的话，发生的事情也仅仅是把变量本身这 16 个字节的内存块置 0 而已。</p><h4 id=nil-值判断-2><code>nil</code> 值判断</h4><p>判断 <code>interface</code> 是否是 <code>nil</code> ？这个跟 <code>slice</code> 类似，也仅仅是判断首字段（指针类型）是否为 0 即可。因为如果是初始化过的，首字段一定是非 0 的。</p><p>⭐ 关于 interface 判断 nil 的坑：https://www.cnblogs.com/cnxkey/articles/10096934.html</p><h3 id=channel>channel</h3><h4 id=变量定义-3>变量定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 变量本身定义
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>c1</span> <span class=kd>chan</span> <span class=kd>struct</span><span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=c1>// 变量定义和初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>c2</span> <span class=p>=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kd>struct</span><span class=p>{})</span>
</span></span></code></pre></td></tr></table></div></div><p>区别：</p><ul><li>第一种方式仅仅定义了 c1 变量本身；</li><li>第二种方式则是分配 c2 的内存，还会调用 <code>makechan</code> 函数来创建某个结构，并且把这个函数的返回值赋给 c2；</li></ul><h4 id=变量本身-3>变量本身</h4><p>定义的 <code>channel</code> 变量本身是什么一个表现？</p><p>答案是：一个 8 字节的指针而已，意图指向一个 <code>channel</code> 管理结构，也就是 <code>struct hchan</code> 的指针。</p><p>程序员定义的 <code>channel</code> 变量本身内存仅仅是一个指针，<code>channel</code> 所有的逻辑都在 <code>hchan</code> 这个管理结构体上，所以，<code>channel</code> 也是必须 <code>make(chan Xtype)</code> 之后才能使用，就是这个道理。</p><h4 id=nil-赋值-3><code>nil</code> 赋值</h4><p>赋值 nil 之后，仅仅是把这 8 字节的指针置 0 。</p><h4 id=nil-值判断-3><code>nil</code> 值判断</h4><p>简单，仅仅是判断这 channel 指针是否非 0 而已。</p><h3 id=指针>指针</h3><p>指针和函数类型比较好理解，因为之前的 4 种类型 <code>slice</code>，<code>map</code>，<code>channel</code>，<code>interface</code> 是复合结构。</p><p>指针本身来说也只是一个 8 字节的整型，函数变量类型则本身就是个指针。</p><h4 id=变量定义-4>变量定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>ptr</span> <span class=o>*</span><span class=kt>int</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=变量本身-4>变量本身</h4><p>变量本身就是一个 8 字节的内存块，这个没啥好讲的，因为指针都不是复合类型。</p><h4 id=nil-赋值-4><code>nil</code> 赋值</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>ptr</span> <span class=p>=</span> <span class=kc>nil</span>
</span></span></code></pre></td></tr></table></div></div><p>这 8 字节的指针置 0。</p><h4 id=nil-值判断-4><code>nil</code> 值判断</h4><p>判断这 8 字节的指针是否为 0 。</p><h3 id=函数>函数</h3><h4 id=变量定义-5>变量定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>var</span> <span class=nx>f</span> <span class=kd>func</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span> <span class=kt>error</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=变量本身-5>变量本身</h4><p>变量本身是一个 8 字节的指针。</p><h4 id=nil-赋值-5><code>nil</code> 赋值</h4><p>本身就是指针，只不过指向的是函数而已。所以赋值也仅仅是这 8 字节置 0 。</p><h4 id=nil-值判断-5><code>nil</code> 值判断</h4><p>判断这 8 字节是否为 0 。</p><h2 id=总结>总结</h2><p>下面总结一些上述分享：</p><ol><li>请撇开死记硬背的语法和玄学，变量仅仅是绑定到一个指定内存块的名字；</li><li>Go 从语言层面对程序员做了承诺，变量定义分配的内存一定是置 0 分配的；</li><li>并不是所有的类型能够赋值 <code>nil</code>，并且和 <code>nil</code> 进行对比判断。只有 <code>slice</code>、<code>map</code>、<code>channel</code>、<code>interface</code>、指针、函数 这 6 种类型；</li><li>不要把 <code>nil</code> 理解成一个特殊的值，而要理解成一个触发条件，编译器识别到代码里有 <code>nil</code> 之后，会对应做出处理和判断；</li><li><code>channel</code>，<code>map</code> 类型的变量必须要 <code>make </code>才能使用的原因（否则会出现空指针的 panic ）在于 var 定义的变量仅仅是分配了一个指向 <code>hchan</code> 和 <code>hmap</code> 的指针变量而已，并且还是置 0 分配的。真正的管理结构只有 make 调用才能分配出来，对应的函数分别是 <code>makechan</code> 和 <code>makemap</code> 等；</li><li><code>slice</code> 变量为什么 <code>var</code> 就能用是因为 <code>struct slice</code> 核心结构是定义的时候就分配出来了；</li><li>以上 6 种变量赋值 <code>nil</code> 的行为都是把变量本身置 0 ，仅此而已。<code>slice</code> 的 24 字节管理结构，<code>map</code> 的 8 字节指针，<code>channel</code> 的 8 字节指针，<code>interface</code> 的 16 字节，8 字节指针和函数指针也是如此；</li><li>以上 6 种类型和 <code>nil</code> 进行比较判断本质上都是和变量本身做判断，<code>slice</code> 是判断管理结构的第一个指针字段，<code>map</code>，<code>channel</code> 本身就是指针，<code>interface</code> 也是判断管理结构的第一个指针字段，指针和函数变量本身就是指针；</li></ol><h2 id=后记>后记</h2><p>推荐使用 gdb 进行对上面的 demo 程序进行调试，加深自己理解。重点关注内存分配和内部代码的生成（反汇编），比如类似 makechan 这样的函数，如果你不调试，你根本不会知道竟然还有这个，我明明没有写过这函数呀？这个是编译器帮你生成的。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-06-14 09:53:17">更新于 2023-06-14</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/nil-%E8%AF%A6%E8%A7%A3/ data-title="Go nil 详解" data-hashtags=进阶><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/nil-%E8%AF%A6%E8%A7%A3/ data-hashtag=进阶><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/nil-%E8%AF%A6%E8%A7%A3/ data-title="Go nil 详解"><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E8%BF%9B%E9%98%B6/>进阶</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/%E5%88%B7%E9%A2%98/greedy/55.-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/ class=prev rel=prev title="10. 正则表达式匹配"><i class="fa-solid fa-angle-left fa-fw"></i>10. 正则表达式匹配</a>
<a href=/Notes/posts/%E5%88%B7%E9%A2%98/array/136.-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/ class=next rel=next title="136. 只出现一次的数字">136. 只出现一次的数字<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>