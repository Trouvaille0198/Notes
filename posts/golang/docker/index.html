<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Docker - 伤心肠粉的酱油碟子</title><meta name=Description content><meta property="og:title" content="Docker"><meta property="og:description" content="Docker 摘自：https://yeasy.gitbook.io/docker_prac"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/golang/docker/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-07T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-12T15:26:47+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker"><meta name=twitter:description content="Docker 摘自：https://yeasy.gitbook.io/docker_prac"><meta name=application-name content="伤心肠粉的酱油碟子"><meta name=apple-mobile-web-app-title content="伤心肠粉的酱油碟子"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/golang/docker/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/golang/basicgrammar/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Docker","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/docker\/"},"genre":"posts","wordcount":13234,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/golang\/docker\/","datePublished":"2022-03-07T00:00:00+00:00","dateModified":"2022-03-12T15:26:47+00:00","publisher":{"@type":"Organization","name":"MelonCholi"},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/Notes/categories/>分类 </a><a class=menu-item href=/Notes/tags/>标签 </a><a class=menu-item href=/Notes/posts/>文章 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/Notes/categories/ title>分类</a><a class=menu-item href=/Notes/tags/ title>标签</a><a class=menu-item href=/Notes/posts/ title>文章</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Docker</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/Notes/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>MelonCholi</a></span>&nbsp;<span class=post-category>收录于 <a href=/Notes/categories/golang/><i class="far fa-folder fa-fw"></i>Golang</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-03-07>2022-03-07</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 13234 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 27 分钟&nbsp;</div></div><div class=featured-image><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png title=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#什么是-docker>什么是 Docker</a><ul><li><a href=#容器技术-vs-虚拟机>容器技术 vs 虚拟机</a></li><li><a href=#什么是容器>什么是容器</a></li><li><a href=#什么是-docker-1>什么是 docker</a></li><li><a href=#如何使用-docker>如何使用 docker</a></li><li><a href=#docker-是如何工作的>docker 是如何工作的</a><ul><li><a href=#docker-build><code>docker build</code></a></li><li><a href=#docker-run><code>docker run</code></a></li><li><a href=#docker-pull><code>docker pull</code></a></li></ul></li><li><a href=#docker-的底层实现>docker 的底层实现</a></li></ul></li><li><a href=#安装>安装</a><ul><li><a href=#ubuntu>Ubuntu</a><ul><li><a href=#使用-apt-安装>使用 APT 安装</a></li><li><a href=#启动-docker>启动 Docker</a></li><li><a href=#测试>测试</a></li><li><a href=#建立-docker-用户组>建立 docker 用户组</a></li></ul></li></ul></li><li><a href=#使用镜像>使用镜像</a><ul><li><a href=#获取镜像-docker-pull>获取镜像 <code>docker pull</code></a><ul><li><a href=#例>例</a></li><li><a href=#试运行>试运行</a></li></ul></li><li><a href=#列出镜像-docker-image-ls>列出镜像 <code>docker image ls</code></a><ul><li><a href=#镜像体积>镜像体积</a></li><li><a href=#虚悬镜像>虚悬镜像</a></li><li><a href=#中间层镜像>中间层镜像</a></li><li><a href=#列出部分镜像>列出部分镜像</a></li></ul></li><li><a href=#删除本地镜像-docker-image-rm>删除本地镜像 <code>docker image rm</code></a><ul><li><a href=#用-id镜像名摘要删除镜像>用 ID、镜像名、摘要删除镜像</a></li><li><a href=#untagged-和-deleted>Untagged 和 Deleted</a></li><li><a href=#用-docker-image-ls-命令来配合>用 docker image ls 命令来配合</a></li></ul></li></ul></li><li><a href=#操作容器>操作容器</a><ul><li><a href=#启动>启动</a><ul><li><a href=#新建并启动-docker-run>新建并启动 <code>docker run</code></a></li><li><a href=#守护态运行--d>守护态运行 <code>-d</code></a></li></ul></li><li><a href=#终止-docker-container-stop>终止 <code>docker container stop</code></a></li><li><a href=#进入容器>进入容器</a><ul><li><a href=#docker-attach><code>docker attach</code></a></li><li><a href=#docker-exec><code>docker exec</code></a></li></ul></li><li><a href=#导出和导入>导出和导入</a><ul><li><a href=#导出容器-docker-export>导出容器 <code>docker export</code></a></li><li><a href=#导入容器快照-docker-import>导入容器快照 <code>docker import</code></a></li></ul></li><li><a href=#删除>删除</a><ul><li><a href=#删除容器-docker-container-rm>删除容器 <code>docker container rm</code></a></li><li><a href=#清理所有处于终止状态的容器>清理所有处于终止状态的容器</a></li></ul></li></ul></li><li><a href=#访问仓库>访问仓库</a><ul><li><a href=#docker-hub>Docker Hub</a><ul><li><a href=#登录-docker-login>登录 <code>docker login</code></a></li><li><a href=#拉取镜像-docker-pull>拉取镜像 <code>docker pull</code></a></li><li><a href=#推送镜像-docker-push>推送镜像 <code>docker push</code></a></li></ul></li></ul></li><li><a href=#数据管理>数据管理</a><ul><li><a href=#数据卷-volumn>数据卷 volumn</a><ul><li><a href=#创建一个数据卷>创建一个数据卷</a></li><li><a href=#启动一个挂载数据卷的容器>启动一个挂载数据卷的容器</a></li><li><a href=#查看数据卷的具体信息>查看数据卷的具体信息</a></li><li><a href=#删除数据卷>删除数据卷</a></li></ul></li><li><a href=#挂载主机目录-bind-mount>挂载主机目录 bind mount</a><ul><li><a href=#挂载一个主机目录作为数据卷>挂载一个主机目录作为数据卷</a></li><li><a href=#查看数据卷的具体信息-1>查看数据卷的具体信息</a></li><li><a href=#挂载一个本地主机文件作为数据卷>挂载一个本地主机文件作为数据卷</a></li></ul></li><li><a href=#volume-和-bind-的区别>volume 和 bind 的区别</a></li></ul></li><li><a href=#使用网络>使用网络</a><ul><li><a href=#外部访问容器>外部访问容器</a><ul><li><a href=#映射所有接口地址>映射所有接口地址</a></li><li><a href=#映射到指定地址的指定端口>映射到指定地址的指定端口</a></li><li><a href=#映射到指定地址的任意端口>映射到指定地址的任意端口</a></li><li><a href=#查看映射端口配置-docker-port>查看映射端口配置 <code>docker port</code></a></li></ul></li><li><a href=#容器互联>容器互联</a><ul><li><a href=#新建网络-docker-network-create>新建网络 <code>docker network create</code></a></li><li><a href=#连接容器>连接容器</a></li><li><a href=#docker-compose>Docker Compose</a></li></ul></li></ul></li><li><a href=#常用命令>常用命令</a></li><li><a href=#使用-dockerfile-定制镜像>使用 Dockerfile 定制镜像</a></li></ul></nav></div></div><div class=content id=content><h1 id=docker>Docker</h1><p>摘自：https://yeasy.gitbook.io/docker_practice/</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Moby-share.png title=img></p><h2 id=什么是-docker>什么是 Docker</h2><p>摘自：https://zhuanlan.zhihu.com/p/187505981</p><h3 id=容器技术-vs-虚拟机>容器技术 vs 虚拟机</h3><p>和一个单纯的应用程序相比，<strong>操作系统是一个很重而且很笨的程序</strong></p><p>操作系统运行起来是需要占用很多资源的，刚装好的系统还什么都没有部署，单纯的操作系统其磁盘占用至少几十 G 起步，内存要几个 G 起步。</p><p>假设我有一台机器，16G 内存，需要部署三个应用，那么使用虚拟机技术可以这样划分：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://pic4.zhimg.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg data-srcset="https://pic4.zhimg.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg, https://pic4.zhimg.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg 1.5x, https://pic4.zhimg.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg 2x" data-sizes=auto alt=https://pic4.zhimg.com/v2-c20cb49c88034e73e09059668b8cecfb_b.jpg title=img></p><p>在这台机器上开启三个虚拟机，每个虚拟机上部署一个应用，其中 VM1 占用 2G 内存，VM2 占用 1G 内存，VM3 占用了 4G 内存。</p><p>我们可以看到虚拟本身就占据了总共 7G 内存，因此<strong>我们没有办法划分出更多虚拟机从而部署更多的应用程序</strong>，可是我们部署的是应用程序，要用的也是应用程序而<strong>不是操作系统</strong>。</p><p>如果有一种技术可以让我们避免把<strong>内存浪费</strong>在“无用”的操作系统上岂不是太香？这是问题一，主要原因在于操作系统太重了。</p><p>还有另一个问题，那就是<strong>启动时间</strong>问题，我们知道操作系统重启是非常慢的，因为操作系统要从头到尾把该检测的都检测了该加载的都加载上，这个过程非常缓慢，动辄数分钟，因此操作系统还是太笨了。</p><p>那么有没有一种技术可以让我们获得虚拟机的好处又能克服这些缺点从而一举实现鱼和熊掌的兼得呢？</p><p>答案是肯定的，这就是容器技术。</p><h3 id=什么是容器>什么是容器</h3><p>容器一词的英文是 container，其实 container 还有集装箱的意思，而容器和集装箱在概念上是很相似的。</p><p>现代软件开发的一大目的就是<strong>隔离</strong>，应用程序在运行时相互独立互不干扰，这种隔离实现起来是很不容易的，其中一种解决方案就是上面提到的虚拟机技术，通过将应用程序部署在不同的虚拟机中从而实现隔离。</p><img src=https://pic1.zhimg.com/v2-0f6ede7f0b920b5d0d5571c937a04838_b.jpg alt=img style=zoom:67%><p>但是虚拟机技术有上述提到的各种缺点，那么容器技术又怎么样呢？</p><p>与虚拟机通过操作系统实现隔离不同，容器技术</p><ul><li><strong>只隔离应用程序的运行时环境</strong></li><li><strong>容器之间可以共享同一个操作系统</strong></li></ul><blockquote><p>这里的运行时环境指的是程序运行依赖的<strong>各种库以及配置</strong>。</p></blockquote><img src=https://pic2.zhimg.com/v2-907214eadd65987e84a0751c08143f91_b.jpg alt=img style=zoom:67%><p>从图中我们可以看到容器更加的<strong>轻量级且占用的资源更少</strong>，与操作系统动辄几 G 的内存占用相比，容器技术只需数 M 空间，因此我们可以在同样规格的硬件上<strong>大量部署容器</strong>，这是虚拟机所不能比拟的，而且不同于操作系统数分钟的启动时间容器几乎瞬时启动，容器技术为<strong>打包服务栈</strong>提供了一种更加高效的方式，So cool。</p><p>那么我们该怎么使用容器呢？这就要讲到 docker 了。</p><p>注意，<strong>容器是一种通用技术，docker 只是其中的一种实现。</strong></p><h3 id=什么是-docker-1>什么是 docker</h3><p>docker 是一个用 Go 语言实现的开源项目，可以让我们方便的创建和使用容器，docker 将程序以及程序所有的依赖都打包到 docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器。</p><p>就好比集装箱，容器所处的操作系统环境就好比货船或港口，<strong>程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系</strong>。</p><p>因此我们可以看到 docker 可以<strong>屏蔽环境差异</strong>，也就是说，只要你的程序打包到了 docker 中，那么无论运行在什么环境下程序的行为都是一致的，程序员再也无法施展表演才华了，不会再有 “在我的环境上可以运行”，真正实现 “build once, run everywhere”。</p><p>此外 docker 的另一个好处就是<strong>快速部署</strong>，这是当前互联网公司最常见的一个应用场景，一个原因在于容器启动速度非常快，另一个原因在于只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。</p><h3 id=如何使用-docker>如何使用 docker</h3><p>docker 中有这样几个概念：</p><ul><li><strong>dockerfile</strong></li><li><strong>image</strong></li><li><strong>container</strong></li></ul><p>实际上你可以简单的把</p><ul><li>dockerfile 理解为源代码</li><li>image 理解为可执行程序</li><li>container 就是运行起来的进程</li><li>docker 就是 &ldquo;编译器&rdquo;。</li></ul><p>官方文档的术语解释：</p><blockquote><ul><li><p>A <strong>Dockerfile</strong> is simply a text-based script of instructions that is used to create a container image.</p></li><li><p>A <strong>container</strong> is a sandboxed process on your machine that is isolated from all other processes on the host machine.</p></li></ul></blockquote><p>因此我们只需要在 dockerfile 中指定需要哪些程序、依赖什么样的配置，之后把 dockerfile 交给“编译器” docker 进行“编译”，也就是 <code>docker build</code> 命令，生成的可执行程序就是 image，之后就可以运行这个 image 了，这就是 <code>docker run</code> 命令，image运行起来后就是 docker container。</p><h3 id=docker-是如何工作的>docker 是如何工作的</h3><p>实际上 docker 使用了常见的 CS 架构，也就是 client-server 模式，docker client 负责处理用户输入的各种命令，比如 docker build、docker run，真正工作的其实是 server，也就是 docker demon</p><blockquote><p>值得注意的是，docker client 和 docker demon 可以运行在同一台机器上。</p></blockquote><p>接下来我们用几个命令来讲解一下 docker 的工作流程：</p><h4 id=docker-build><code>docker build</code></h4><p>当我们写完 dockerfile 交给 docker “编译” 时使用这个命令，那么 client 在接收到请求后转发给 docker daemon，接着 docker daemon 根据 dockerfile 创建出“可执行程序” image。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://pic3.zhimg.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg data-srcset="https://pic3.zhimg.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg, https://pic3.zhimg.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg 1.5x, https://pic3.zhimg.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg 2x" data-sizes=auto alt=https://pic3.zhimg.com/v2-f16577a98471b4c4b5b1af1036882caa_b.jpg title=img></p><h4 id=docker-run><code>docker run</code></h4><p>有了“可执行程序” image 后就可以运行程序了，接下来使用命令 <code>docker run</code>，docker daemon 接收到该命令后找到具体的 image，然后加载到内存开始执行，image 执行起来就是所谓的 container。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://pic4.zhimg.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg data-srcset="https://pic4.zhimg.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg, https://pic4.zhimg.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg 1.5x, https://pic4.zhimg.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg 2x" data-sizes=auto alt=https://pic4.zhimg.com/v2-672b29e2d53d2ab044269b026c6bc473_b.jpg title=img></p><h4 id=docker-pull><code>docker pull</code></h4><p>其实 <code>docker build</code> 和 <code>docker run</code> 是两个最核心的命令，会用这两个命令基本上 docker 就可以用起来了，剩下的就是一些补充。</p><p>那么 <code>docker pull</code> 是什么意思呢？</p><p>我们之前说过，docker 中 image 的概念就类似于“可执行程序”，我们可以从哪里下载到别人写好的应用程序呢？很简单，就是 <strong>Docker Hub</strong>，docker 官方的“应用商店”，你可以在这里下载到别人编写好的 image，这样你就不用自己编写 dockerfile 了。</p><p><strong>docker registry 可以用来存放各种 image</strong>，公共的可以供任何人下载 image 的仓库就是 docker Hub。那么该怎么从 Docker Hub 中下载 image 呢，就是这里的 docker pull 命令了。</p><p>因此，这个命令的实现也很简单，那就是用户通过 docker client 发送命令，docker daemon 接收到命令后向 docker registry 发送 image 下载请求，下载后存放在本地，这样我们就可以使用 image 了。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://pic3.zhimg.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg data-srcset="https://pic3.zhimg.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg, https://pic3.zhimg.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg 1.5x, https://pic3.zhimg.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg 2x" data-sizes=auto alt=https://pic3.zhimg.com/v2-dac570abcf7e1776cc266a60c4b19e5e_b.jpg title=img></p><p>最后，让我们来看一下 docker 的底层实现。</p><h3 id=docker-的底层实现>docker 的底层实现</h3><p>docker 基于 Linux 内核提供这样几项功能实现的：</p><ul><li><strong>NameSpace</strong>
我们知道 Linux 中的 PID、IPC、网络等资源是全局的，而 NameSpace 机制是一种资源隔离方案，在该机制下这些资源就不再是全局的了，而是属于某个特定的 NameSpace，各个 NameSpace 下的资源互不干扰，这就使得每个 NameSpace 看上去就像一个独立的操作系统一样，但是只有 NameSpace 是不够。</li><li><strong>Control groups</strong>
虽然有了 NameSpace 技术可以实现资源隔离，但进程还是可以不受控的访问<strong>系统资源</strong>，比如 CPU、内存、磁盘、网络等，为了控制容器中进程对资源的访问，Docker 采用 control groups 技术（也就是 cgroup），有了 cgroup 就可以控制容器中进程对系统资源的消耗了，比如你可以限制某个容器使用内存的上限、可以在哪些 CPU 上运行等等。</li></ul><p>有了这两项技术，容器看起来就真的像是独立的操作系统了。</p><h2 id=安装>安装</h2><h3 id=ubuntu>Ubuntu</h3><h4 id=使用-apt-安装>使用 APT 安装</h4><p>由于 <code>apt</code> 源使用 HTTPS 以确保软件下载过程中不被篡改。因此，我们首先需要添加使用 HTTPS 传输的软件包以及 CA 证书。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo apt-get install <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    apt-transport-https <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    ca-certificates <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    curl <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    gnupg <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    lsb-release
</span></span></code></pre></td></tr></table></div></div><p>为了确认所下载软件包的合法性，需要添加软件源的 <code>GPG</code> 密钥。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg <span class=p>|</span> sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 官方源</span>
</span></span><span class=line><span class=cl><span class=c1># $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span>
</span></span></code></pre></td></tr></table></div></div><p>然后，我们需要向 <code>sources.list</code> 中添加 Docker 软件源</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ <span class=nb>echo</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>  <span class=s2>&#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \
</span></span></span><span class=line><span class=cl><span class=s2>  </span><span class=k>$(</span>lsb_release -cs<span class=k>)</span><span class=s2> stable&#34;</span> <span class=p>|</span> sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># 官方源</span>
</span></span><span class=line><span class=cl><span class=c1># $ echo \</span>
</span></span><span class=line><span class=cl><span class=c1>#   &#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span>
</span></span><span class=line><span class=cl><span class=c1>#   $(lsb_release -cs) stable&#34; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>以上命令会添加稳定版本的 Docker APT 镜像源，如果需要测试版本的 Docker 请将 stable 改为 test。</p></blockquote><p>更新 apt 软件包缓存，并安装 <code>docker-ce</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo apt-get update
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ sudo apt-get install docker-ce docker-ce-cli containerd.io
</span></span></code></pre></td></tr></table></div></div><h4 id=启动-docker>启动 Docker</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo systemctl <span class=nb>enable</span> docker
</span></span><span class=line><span class=cl>$ sudo systemctl start docker
</span></span></code></pre></td></tr></table></div></div><h4 id=测试>测试</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run --rm hello-world
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Unable to find image <span class=s1>&#39;hello-world:latest&#39;</span> locally
</span></span><span class=line><span class=cl>latest: Pulling from library/hello-world
</span></span><span class=line><span class=cl>b8dfde127a29: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>Digest: sha256:308866a43596e83578c7dfa15e27a73011bdd402185a84c5cd7f32a88b501a24
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> hello-world:latest
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Hello from Docker!
</span></span><span class=line><span class=cl>This message shows that your installation appears to be working correctly.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To generate this message, Docker took the following steps:
</span></span><span class=line><span class=cl> 1. The Docker client contacted the Docker daemon.
</span></span><span class=line><span class=cl> 2. The Docker daemon pulled the <span class=s2>&#34;hello-world&#34;</span> image from the Docker Hub.
</span></span><span class=line><span class=cl>    <span class=o>(</span>amd64<span class=o>)</span>
</span></span><span class=line><span class=cl> 3. The Docker daemon created a new container from that image which runs the
</span></span><span class=line><span class=cl>    executable that produces the output you are currently reading.
</span></span><span class=line><span class=cl> 4. The Docker daemon streamed that output to the Docker client, which sent it
</span></span><span class=line><span class=cl>    to your terminal.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>To try something more ambitious, you can run an Ubuntu container with:
</span></span><span class=line><span class=cl> $ docker run -it ubuntu bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Share images, automate workflows, and more with a free Docker ID:
</span></span><span class=line><span class=cl> https://hub.docker.com/
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>For more examples and ideas, visit:
</span></span><span class=line><span class=cl> https://docs.docker.com/get-started/
</span></span></code></pre></td></tr></table></div></div><p>若能正常输出以上信息，则说明安装成功。</p><h4 id=建立-docker-用户组>建立 docker 用户组</h4><p>默认情况下，<code>docker</code> 命令会使用 <a href=https://en.wikipedia.org/wiki/Unix_domain_socket target=_blank rel="noopener noreffer">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。</p><p>建立 <code>docker</code> 组：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo groupadd docker
</span></span></code></pre></td></tr></table></div></div><p>将当前用户加入 <code>docker</code> 组：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ sudo usermod -aG docker <span class=nv>$USER</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=使用镜像>使用镜像</h2><p><strong>Docker 镜像</strong> 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像 <strong>不包含</strong> 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id=获取镜像-docker-pull>获取镜像 <code>docker pull</code></h3><p>从 Docker 镜像仓库获取镜像的命令是 <code>docker pull</code>。其命令格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull <span class=o>[</span>选项<span class=o>]</span> 仓库名<span class=o>[</span>:标签<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 更具体地</span>
</span></span><span class=line><span class=cl>$ docker pull <span class=o>[</span>选项<span class=o>]</span> <span class=o>[</span>Docker Registry 地址<span class=o>[</span>:端口号<span class=o>]]</span>仓库名<span class=o>[</span>:标签<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>具体的选项可以通过 <code>docker pull --help</code> 命令看到，这里我们说一下镜像名称的格式。</p><ul><li>Docker 镜像仓库地址：地址的格式一般是 <code>&lt;域名/IP>[:端口号]</code>。<ul><li>默认地址是 Docker Hub (<code>docker.io</code>)</li></ul></li><li>仓库名：两段式名称，即 &lt;用户名>/&lt;软件名>。<ul><li>对于 Docker Hub，如果不给出用户名，则默认为 <code>library</code>，也就是官方镜像。</li></ul></li></ul><h4 id=例>例</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull ubuntu:18.04
</span></span><span class=line><span class=cl><span class=c1># 更具体地</span>
</span></span><span class=line><span class=cl>$ docker pull docker.io/library/ubuntu:18.04
</span></span></code></pre></td></tr></table></div></div><p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （<code>docker.io</code>）获取镜像。镜像名称是 <code>ubuntu:18.04</code>，因此将会获取官方镜像 <code>library/ubuntu</code> 仓库中标签为 <code>18.04</code> 的镜像。</p><p>下载过程：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>18.04: Pulling from library/ubuntu
</span></span><span class=line><span class=cl>92dc2a97ff99: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>be13a9d27eb8: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>c8299583700a: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>Digest: sha256:4bc3ae6596938cb0d9e5ac51a1152ec9dcac2a1c50829c74abd9c4361e321b26
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> ubuntu:18.04
</span></span><span class=line><span class=cl>docker.io/library/ubuntu:18.04
</span></span></code></pre></td></tr></table></div></div><p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。</p><p>下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 <code>sha256</code> 的摘要，以确保下载一致性。</p><h4 id=试运行>试运行</h4><p>以上面的 <code>ubuntu:18.04</code> 为例，如果我们打算启动里面的 <code>bash</code> 并且进行交互式操作的话，可以执行下面的命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --rm ubuntu:18.04 bash
</span></span></code></pre></td></tr></table></div></div><ul><li><p><code>-it</code>：这是两个参数</p><ul><li><code>-i</code>：交互式操作</li><li><code>-t</code> 终端。我们这里打算进入 <code>bash</code> 执行一些命令并查看返回结果，因此我们需要交互式终端。</li></ul></li><li><p><code>--rm</code>：这个参数是说容器退出后随之将其删除。</p><ul><li>默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 <code>docker rm</code>。</li><li>我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 <code>--rm</code> 可以避免浪费空间。</li></ul></li><li><p><code>ubuntu:18.04</code>：这是指用 <code>ubuntu:18.04</code> 镜像为基础来启动容器。</p></li><li><p><code>bash</code>：放在镜像名后的是 <strong>命令</strong>，这里我们希望有个交互式 Shell，因此用的是 <code>bash</code>。</p></li></ul><h3 id=列出镜像-docker-image-ls>列出镜像 <code>docker image ls</code></h3><p>要想列出已经下载下来的镜像，可以使用 <code>docker image ls</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>redis                latest              5f515359c7f8        <span class=m>5</span> days ago          <span class=m>183</span> MB
</span></span><span class=line><span class=cl>nginx                latest              05a60462f8ba        <span class=m>5</span> days ago          <span class=m>181</span> MB
</span></span><span class=line><span class=cl>mongo                3.2                 fe9198c04d62        <span class=m>5</span> days ago          <span class=m>342</span> MB
</span></span><span class=line><span class=cl>&lt;none&gt;               &lt;none&gt;              00285df0df87        <span class=m>5</span> days ago          <span class=m>342</span> MB
</span></span><span class=line><span class=cl>ubuntu               18.04               329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span><span class=line><span class=cl>ubuntu               bionic              329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span></code></pre></td></tr></table></div></div><p>列表包含了 <code>仓库名</code>、<code>标签</code>、<code>镜像 ID</code>、<code>创建时间</code> 以及 <code>所占用的空间</code>。</p><p><strong>镜像 ID</strong> 则是镜像的唯一标识，一个镜像可以对应多个 <strong>标签</strong>。因此，在上面的例子中，我们可以看到 <code>ubuntu:18.04</code> 和 <code>ubuntu:bionic</code> 拥有相同的 ID，因为它们对应的是同一个镜像。</p><h4 id=镜像体积>镜像体积</h4><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，<code>ubuntu:18.04</code> 镜像大小，在这里是 <code>63.3MB</code>，但是在 <a href="https://hub.docker.com/layers/ubuntu/library/ubuntu/bionic/images/sha256-32776cc92b5810ce72e77aca1d949de1f348e1d281d3f00ebcc22a3adcdc9f42?context=explore" target=_blank rel="noopener noreffer">Docker Hub</a> 显示的却是 <code>25.47 MB</code>。</p><p>这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，<strong>因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。</strong></p><p>而 <code>docker image ls</code> 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，<strong>因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</strong></p><p>另外一个需要注意的问题是，<code>docker image ls</code> 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此<strong>实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</strong></p><p>你可以通过 <code>docker system df</code> 命令来便捷的查看镜像、容器、数据卷所占用的空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker system df
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>TYPE                TOTAL           ACTIVE           SIZE              RECLAIMABLE
</span></span><span class=line><span class=cl>Images              <span class=m>24</span>              <span class=m>0</span>                1.992GB           1.992GB <span class=o>(</span>100%<span class=o>)</span>
</span></span><span class=line><span class=cl>Containers          <span class=m>1</span>               <span class=m>0</span>                62.82MB           62.82MB <span class=o>(</span>100%<span class=o>)</span>
</span></span><span class=line><span class=cl>Local Volumes       <span class=m>9</span>               <span class=m>0</span>                652.2MB           652.2MB <span class=o>(</span>100%<span class=o>)</span>
</span></span><span class=line><span class=cl>Build Cache                                          0B                0B
</span></span></code></pre></td></tr></table></div></div><h4 id=虚悬镜像>虚悬镜像</h4><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <code>&lt;none></code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>&lt;none&gt;          &lt;none&gt;         00285df0df87      <span class=m>5</span> days ago        <span class=m>342</span> MB
</span></span></code></pre></td></tr></table></div></div><p>这个镜像原本是有镜像名和标签的，原来为 <code>mongo:3.2</code>，随着官方镜像维护，发布了新版本后，重新 <code>docker pull mongo:3.2</code> 时，<code>mongo:3.2</code> 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <code>&lt;none></code>。</p><p>除了 <code>docker pull</code> 可能导致这种情况，<code>docker build</code> 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <code>&lt;none></code> 的镜像。这类无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -f <span class=nv>dangling</span><span class=o>=</span><span class=nb>true</span>
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>&lt;none&gt;              &lt;none&gt;              00285df0df87        <span class=m>5</span> days ago          <span class=m>342</span> MB
</span></span></code></pre></td></tr></table></div></div><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image prune
</span></span></code></pre></td></tr></table></div></div><h4 id=中间层镜像>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker 会利用 <strong>中间层镜像</strong>。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 <code>docker image ls</code> 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 <code>-a</code> 参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -a
</span></span></code></pre></td></tr></table></div></div><p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。</p><p>这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。</p><p>实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p><h4 id=列出部分镜像>列出部分镜像</h4><p>不加任何参数的情况下，<code>docker image ls</code> 会列出所有顶层镜像，但是有时候我们只希望列出部分镜像。<code>docker image ls</code> 有好几个参数可以帮助做到这个事情。</p><p><strong>根据仓库名列出镜像</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls ubuntu
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>ubuntu              18.04               329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span><span class=line><span class=cl>ubuntu              bionic              329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span></code></pre></td></tr></table></div></div><p>列出特定的某个镜像，也就是说<strong>指定仓库名和标签</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls ubuntu:18.04
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>ubuntu              18.04               329ed837d508        <span class=m>3</span> days ago          63.3MB
</span></span></code></pre></td></tr></table></div></div><p>除此以外，<code>docker image ls</code> 还支持强大的过滤器参数 <code>--filter</code>，或者简写 <code>-f</code>。</p><p>之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 <code>mongo:3.2</code> 之后建立的镜像，可以用下面的命令：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -f <span class=nv>since</span><span class=o>=</span>mongo:3.2
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>redis               latest              5f515359c7f8        <span class=m>5</span> days ago          <span class=m>183</span> MB
</span></span><span class=line><span class=cl>nginx               latest              05a60462f8ba        <span class=m>5</span> days ago          <span class=m>181</span> MB
</span></span></code></pre></td></tr></table></div></div><p>想查看某个位置之前的镜像也可以，只需要把 <code>since</code> 换成 <code>before</code> 即可。</p><p>此外，如果镜像构建时，定义了 <code>LABEL</code>，还可以通过 <code>LABEL</code> 来过滤。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls -f <span class=nv>label</span><span class=o>=</span>com.example.version<span class=o>=</span>0.1
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><h3 id=删除本地镜像-docker-image-rm>删除本地镜像 <code>docker image rm</code></h3><p>如果要删除本地的镜像，可以使用 <code>docker image rm</code> 命令，其格式为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=o>[</span>选项<span class=o>]</span> &lt;镜像1&gt; <span class=o>[</span>&lt;镜像2&gt; ...<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=用-id镜像名摘要删除镜像>用 ID、镜像名、摘要删除镜像</h4><p>其中，<code>&lt;镜像></code> 可以是 <code>镜像短 ID</code>、<code>镜像长 ID</code>、<code>镜像名</code> 或者 <code>镜像摘要</code>。</p><p>比如我们有这么一些镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY             TAG              IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>centos                 latest           0584b3d2cf6d        <span class=m>3</span> weeks ago         196.5 MB
</span></span><span class=line><span class=cl>redis                  alpine           501ad78535f0        <span class=m>3</span> weeks ago         21.03 MB
</span></span><span class=line><span class=cl>docker                 latest           cf693ec9b5c7        <span class=m>3</span> weeks ago         105.1 MB
</span></span><span class=line><span class=cl>nginx                  latest           e43d811ce2f4        <span class=m>5</span> weeks ago         181.5 MB
</span></span></code></pre></td></tr></table></div></div><p>我们可以用镜像的完整 ID，也称为 <code>长 ID</code>，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 <code>短 ID</code> 来删除镜像。</p><p><code>docker image ls</code> 默认列出的就已经是短 ID 了，一般取前 3 个字符以上，只要足够区分于别的镜像就可以了。</p><p>比如这里，如果我们要删除 <code>redis:alpine</code> 镜像，可以执行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=m>501</span>
</span></span></code></pre></td></tr></table></div></div><p>我们也可以用<code>镜像名</code>，也就是 <code>&lt;仓库名>:&lt;标签></code>，来删除镜像。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm centos
</span></span></code></pre></td></tr></table></div></div><blockquote><p>当然，更精确的是使用 <code>镜像摘要</code> 删除镜像。</p></blockquote><h4 id=untagged-和-deleted>Untagged 和 Deleted</h4><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 <code>Untagged</code>，另一类是 <code>Deleted</code>。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p><p>因此当我们使用上面命令删除镜像的时候，实际上是在<strong>要求删除某个标签的镜像</strong>。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 <code>Untagged</code> 的信息。</p><p>因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 <code>Delete</code> 行为就不会发生。所以并非所有的 <code>docker image rm</code> 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p><p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。</p><p>镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变得非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。**直到没有任何层依赖当前层时，才会真实的删除当前层。**这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 <code>docker pull</code> 看到的层数不一样的原因。</p><p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p><h4 id=用-docker-image-ls-命令来配合>用 docker image ls 命令来配合</h4><p>像其它可以承接多个实体的命令一样，可以使用 <code>docker image ls -q</code> 来配合使用 <code>docker image rm</code>，这样可以成批的删除希望删除的镜像。</p><p>比如，我们需要删除所有仓库名为 <code>redis</code> 的镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=k>$(</span>docker image ls -q redis<span class=k>)</span>
</span></span></code></pre></td></tr></table></div></div><p>或者删除所有在 <code>mongo:3.2</code> 之前的镜像：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker image rm <span class=k>$(</span>docker image ls -q -f <span class=nv>before</span><span class=o>=</span>mongo:3.2<span class=k>)</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=操作容器>操作容器</h2><p>镜像（<code>Image</code>）和容器（<code>Container</code>）的关系，就像是面向对象程序设计中的 <code>类</code> 和 <code>实例</code> 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 <a href=https://en.wikipedia.org/wiki/Linux_namespaces target=_blank rel="noopener noreffer">命名空间</a>。因此容器可以拥有自己的 <code>root</code> 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。</p><p>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p><p>这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p><p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 <a href rel>数据卷（Volume）</a>、或者 <a href rel>绑定宿主目录</a>，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p><h3 id=启动>启动</h3><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（<code>exited</code>）的容器重新启动。</p><p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p><h4 id=新建并启动-docker-run>新建并启动 <code>docker run</code></h4><p>所需要的命令主要为 <code>docker run</code>。</p><p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run ubuntu:18.04 /bin/echo <span class=s1>&#39;Hello world&#39;</span>
</span></span><span class=line><span class=cl>Hello world
</span></span></code></pre></td></tr></table></div></div><p>这跟在本地直接执行 <code>/bin/echo 'hello world'</code> 几乎感觉不出任何区别。</p><p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -t -i ubuntu:18.04 /bin/bash
</span></span><span class=line><span class=cl>root@af8bae53bdd3:/#
</span></span></code></pre></td></tr></table></div></div><p>其中，<code>-t</code> 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， <code>-i</code> 则让容器的标准输入保持打开。</p><p>当利用 <code>docker run</code> 来创建容器时，Docker 在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从 <a href rel>registry</a> 下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个 ip 地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 <code>ps</code> 或 <code>top</code> 来查看进程信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>root@ba267838cc1b:/# ps
</span></span><span class=line><span class=cl>  PID TTY          TIME CMD
</span></span><span class=line><span class=cl>    <span class=m>1</span> ?        00:00:00 bash
</span></span><span class=line><span class=cl>   <span class=m>11</span> ?        00:00:00 ps
</span></span></code></pre></td></tr></table></div></div><p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p><h4 id=守护态运行--d>守护态运行 <code>-d</code></h4><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 <code>-d</code> 参数来实现。</p><p>下面举两个例子来说明一下。</p><p>如果不使用 <code>-d</code> 参数运行容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run ubuntu:18.04 /bin/sh -c <span class=s2>&#34;while true; do echo hello world; sleep 1; done&#34;</span>
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span></code></pre></td></tr></table></div></div><p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p><p>如果使用了 <code>-d</code> 参数运行容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d ubuntu:18.04 /bin/sh -c <span class=s2>&#34;while true; do echo hello world; sleep 1; done&#34;</span>
</span></span><span class=line><span class=cl>77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a
</span></span></code></pre></td></tr></table></div></div><p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面 (输出结果可以用 <code>docker logs</code> 查看)。</p><p><strong>注：</strong> 容器是否会长久运行，是和 <code>docker run</code> 指定的命令有关，和 <code>-d</code> 参数无关。</p><p>使用 <code>-d</code> 参数启动后会返回一个唯一的 id，也可以通过 <code>docker container ls</code> 命令来查看容器信息。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES
</span></span><span class=line><span class=cl>77b2dc01fe0f  ubuntu:18.04  /bin/sh -c <span class=err>&#39;</span><span class=k>while</span> tr  <span class=m>2</span> minutes ago  Up <span class=m>1</span> minute        agitated_wright
</span></span></code></pre></td></tr></table></div></div><p>要获取容器的输出信息，可以通过 <code>docker container logs</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container logs <span class=o>[</span>container ID or NAMES<span class=o>]</span>
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>hello world
</span></span><span class=line><span class=cl>. . .
</span></span></code></pre></td></tr></table></div></div><h3 id=终止-docker-container-stop>终止 <code>docker container stop</code></h3><p>可以使用 <code>docker container stop</code> 来终止一个运行中的容器。</p><p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p><p>例如对于上一章节中只启动了一个终端的容器，用户通过 <code>exit</code> 命令或 <code>Ctrl+d</code> 来退出终端时，所创建的容器立刻终止。</p><p>终止状态的容器可以用 <code>docker container ls -a</code> 命令看到。例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls -a
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES
</span></span><span class=line><span class=cl>ba267838cc1b        ubuntu:18.04             <span class=s2>&#34;/bin/bash&#34;</span>            <span class=m>30</span> minutes ago      Exited <span class=o>(</span>0<span class=o>)</span> About a minute ago                       trusting_newton
</span></span></code></pre></td></tr></table></div></div><p><strong>处于终止状态的容器，可以通过 <code>docker container start</code> 命令来重新启动。</strong></p><p><strong>此外，<code>docker container restart</code> 命令会将一个运行态的容器终止，然后再重新启动它。</strong></p><h3 id=进入容器>进入容器</h3><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。</p><p>某些时候需要进入容器进行操作，包括使用 <code>docker attach</code> 命令或 <code>docker exec</code> 命令，推荐大家使用 <code>docker exec</code> 命令，原因会在下面说明。</p><h4 id=docker-attach><code>docker attach</code></h4><p>下面示例如何使用 <code>docker attach</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -dit ubuntu
</span></span><span class=line><span class=cl>243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span></span><span class=line><span class=cl>243c32535da7        ubuntu:latest       <span class=s2>&#34;/bin/bash&#34;</span>         <span class=m>18</span> seconds ago      Up <span class=m>17</span> seconds                           nostalgic_hypatia
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker attach 243c
</span></span><span class=line><span class=cl>root@243c32535da7:/#
</span></span></code></pre></td></tr></table></div></div><blockquote><p><em>注意：</em> 如果从这个 stdin 中 exit，会导致容器的停止。</p></blockquote><h4 id=docker-exec><code>docker exec</code></h4><p><code>docker exec</code> 后边可以跟多个参数，这里主要说明 <code>-i</code> <code>-t</code> 参数。</p><p>只用 <code>-i</code> 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p><p>当 <code>-i</code> <code>-t</code> 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -dit ubuntu
</span></span><span class=line><span class=cl>69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
</span></span><span class=line><span class=cl>69d137adef7a        ubuntu:latest       <span class=s2>&#34;/bin/bash&#34;</span>         <span class=m>18</span> seconds ago      Up <span class=m>17</span> seconds                           zealous_swirles
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>exec</span> -i 69d1 bash
</span></span><span class=line><span class=cl>ls
</span></span><span class=line><span class=cl>bin
</span></span><span class=line><span class=cl>boot
</span></span><span class=line><span class=cl>dev
</span></span><span class=line><span class=cl>...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>exec</span> -it 69d1 bash
</span></span><span class=line><span class=cl>root@69d137adef7a:/#
</span></span></code></pre></td></tr></table></div></div><p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 <code>docker exec</code> 的原因。</p><h3 id=导出和导入>导出和导入</h3><h4 id=导出容器-docker-export>导出容器 <code>docker export</code></h4><p>如果要导出本地某个容器，可以使用 <code>docker export</code> 命令。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls -a
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES
</span></span><span class=line><span class=cl>7691a814370e        ubuntu:18.04        <span class=s2>&#34;/bin/bash&#34;</span>         <span class=m>36</span> hours ago        Exited <span class=o>(</span>0<span class=o>)</span> <span class=m>21</span> hours ago                       <span class=nb>test</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker <span class=nb>export</span> 7691a814370e &gt; ubuntu.tar
</span></span></code></pre></td></tr></table></div></div><p>这样将导出容器快照到本地文件。</p><h4 id=导入容器快照-docker-import>导入容器快照 <code>docker import</code></h4><p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ cat ubuntu.tar <span class=p>|</span> docker import - test/ubuntu:v1.0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
</span></span><span class=line><span class=cl>test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB
</span></span></code></pre></td></tr></table></div></div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker import http://example.com/exampleimage.tgz example/imagerepo
</span></span></code></pre></td></tr></table></div></div><blockquote><p><em>用户既可以使用</em> <code>docker load</code> 来导入镜像存储文件到本地镜像库，也可以使用 <code>docker import</code> 来导入一个容器快照到本地镜像库。</p><p>这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。</p><p>此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p></blockquote><h3 id=删除>删除</h3><h4 id=删除容器-docker-container-rm>删除容器 <code>docker container rm</code></h4><p>可以使用 <code>docker container rm</code> 来删除一个<strong>处于终止状态</strong>的容器。例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container rm trusting_newton
</span></span><span class=line><span class=cl>trusting_newton
</span></span></code></pre></td></tr></table></div></div><p>如果要删除一个运行中的容器，可以添加 <code>-f</code> 参数。Docker 会发送 <code>SIGKILL</code> 信号给容器。</p><h4 id=清理所有处于终止状态的容器>清理所有处于终止状态的容器</h4><p>用 <code>docker container ls -a</code> 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container prune
</span></span></code></pre></td></tr></table></div></div><h2 id=访问仓库>访问仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，<a href rel>Docker Registry</a> 就是这样的服务。</p><p>一个 <strong>Docker Registry</strong> 中可以包含多个 <strong>仓库</strong>（<code>Repository</code>）；每个仓库可以包含多个 <strong>标签</strong>（<code>Tag</code>）；每个标签对应一个镜像。</p><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名>:&lt;标签></code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>仓库（<code>Repository</code>）是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（<code>Registry</code>）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 <code>docker.io/ubuntu</code> 来说，<code>docker.io</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><p>大部分时候，并不需要严格区分这两者的概念。</p><h3 id=docker-hub>Docker Hub</h3><p>目前 Docker 官方维护了一个公共仓库 <a href=https://hub.docker.com/ target=_blank rel="noopener noreffer">Docker Hub</a>，其中已经包括了数量超过 <a href="https://hub.docker.com/search/?type=image" target=_blank rel="noopener noreffer">2,650,000</a> 的镜像。大部分需求都可以通过在 Docker Hub 中直接下载镜像来实现。</p><h4 id=登录-docker-login>登录 <code>docker login</code></h4><p>可以通过执行 <code>docker login</code> 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p><p>你可以通过 <code>docker logout</code> 退出登录。</p><h4 id=拉取镜像-docker-pull>拉取镜像 <code>docker pull</code></h4><p>你可以通过 <strong><code>docker search</code></strong> 命令来查找官方仓库中的镜像，并利用 <code>docker pull</code> 命令来将它下载到本地。</p><p>例如以 <code>centos</code> 为关键词进行搜索：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker search centos
</span></span><span class=line><span class=cl>NAME                     DESCRIPTION                        STARS     OFFICIAL  AUTOMATED
</span></span><span class=line><span class=cl>centos                   The official build of CentOS.      <span class=m>6449</span>        <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>ansible/centos7-ansible  Ansible on Centos7                 <span class=m>132</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>consol/centos-xfce-vnc   Centos container with …            <span class=m>126</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>jdeathe/centos-ssh       OpenSSH / Supervisor …             <span class=m>117</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span><span class=line><span class=cl>centos/systemd           systemd enabled base container.     <span class=m>96</span>                   <span class=o>[</span>OK<span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建（<code>OFFICIAL</code>）、是否自动构建 （<code>AUTOMATED</code>）。</p><p>根据是否是官方提供，可将镜像分为两类。</p><ul><li><p>一种是类似 <code>centos</code> 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p></li><li><p>还有一种类型，比如 <code>ansible/centos7-ansible</code> 镜像，它是由 Docker Hub 的注册用户创建并维护的，往往带有用户名称前缀。可以通过前缀 <code>username/</code> 来指定使用某个用户提供的镜像，比如 ansible 用户。</p></li></ul><p>另外，在查找的时候通过 <code>--filter=stars=N</code> 参数可以指定仅显示收藏数量为 <code>N</code> 以上的镜像。</p><p>下载官方 <code>centos</code> 镜像到本地。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker pull centos
</span></span><span class=line><span class=cl>Using default tag: latest
</span></span><span class=line><span class=cl>latest: Pulling from library/centos
</span></span><span class=line><span class=cl>7a0437f04f83: Pull <span class=nb>complete</span>
</span></span><span class=line><span class=cl>Digest: sha256:5528e8b1b1719d34604c87e11dcd1c0a20bedf46e83b5632cdeac91b8c04efc1
</span></span><span class=line><span class=cl>Status: Downloaded newer image <span class=k>for</span> centos:latest
</span></span><span class=line><span class=cl>docker.io/library/centos:latest
</span></span></code></pre></td></tr></table></div></div><h4 id=推送镜像-docker-push>推送镜像 <code>docker push</code></h4><p>用户也可以在登录后通过 <code>docker push</code> 命令来将自己的镜像推送到 Docker Hub。</p><p>以下命令中的 <code>username</code> 请替换为你的 Docker 账号用户名。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker tag ubuntu:18.04 username/ubuntu:18.04
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker image ls
</span></span><span class=line><span class=cl>REPOSITORY            TAG              IMAGE ID            CREATED             SIZE
</span></span><span class=line><span class=cl>ubuntu                18.04            275d79972a86        <span class=m>6</span> days ago          94.6MB
</span></span><span class=line><span class=cl>username/ubuntu       18.04            275d79972a86        <span class=m>6</span> days ago          94.6MB
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker push username/ubuntu:18.04
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker search username
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>NAME             DESCRIPTION         STARS           OFFICIAL        AUTOMATED
</span></span><span class=line><span class=cl>username/ubuntu
</span></span></code></pre></td></tr></table></div></div><h2 id=数据管理>数据管理</h2><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media" data-srcset="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media, https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media 1.5x, https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media 2x" data-sizes=auto alt="https://3503645665-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-M5xTVjmK7ax94c8ZQcm%2Fuploads%2Fgit-blob-5950036bba1c30c0b1ab52a73a94b59bbdd5f57c%2Ftypes-of-mounts.png?alt=media" title=img></p><p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p><ul><li>数据卷（Volumes）</li><li>挂载主机目录 (Bind mounts)</li></ul><p>实际上，Docker 提供了三种不同的方式用于将宿主的数据挂载到容器中：volumes，bind mounts，tmpfs volumes。当你不知道该选择哪种方式时，记住，volumes 总是正确的选择。</p><h3 id=数据卷-volumn>数据卷 volumn</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p><ul><li><code>数据卷</code> 可以在容器之间<strong>共享和重用</strong></li><li>对 <code>数据卷</code> 的修改会立马生效</li><li>对 <code>数据卷</code> 的更新，不会影响镜像</li><li><code>数据卷</code> 默认会<strong>一直存在</strong>，即使容器被删除</li></ul><blockquote><p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p></blockquote><h4 id=创建一个数据卷>创建一个数据卷</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume create my-vol
</span></span></code></pre></td></tr></table></div></div><p>查看所有的 <code>数据卷</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>DRIVER              VOLUME NAME
</span></span><span class=line><span class=cl><span class=nb>local</span>               my-vol
</span></span></code></pre></td></tr></table></div></div><p>在主机里使用以下命令可以<strong>查看指定 <code>数据卷</code> 的信息</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume inspect my-vol
</span></span><span class=line><span class=cl><span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Driver&#34;</span>: <span class=s2>&#34;local&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Labels&#34;</span>: <span class=o>{}</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Mountpoint&#34;</span>: <span class=s2>&#34;/var/lib/docker/volumes/my-vol/_data&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Name&#34;</span>: <span class=s2>&#34;my-vol&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Options&#34;</span>: <span class=o>{}</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Scope&#34;</span>: <span class=s2>&#34;local&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>]</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=启动一个挂载数据卷的容器>启动一个挂载数据卷的容器</h4><p>在用 <code>docker run</code> 命令的时候，使用 <code>--mount</code> 标记来将 <code>数据卷</code> 挂载到容器里。在一次 <code>docker run</code> 中可以挂载多个 <code>数据卷</code>。</p><p>下面创建一个名为 <code>web</code> 的容器，并加载一个 <code>数据卷</code> 到容器的 <code>/usr/share/nginx/html</code> 目录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --name web <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=c1># -v my-vol:/usr/share/nginx/html \</span>
</span></span><span class=line><span class=cl>    --mount <span class=nv>source</span><span class=o>=</span>my-vol,target<span class=o>=</span>/usr/share/nginx/html <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h4 id=查看数据卷的具体信息>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker inspect web
</span></span></code></pre></td></tr></table></div></div><p><code>数据卷</code> 信息在 &ldquo;Mounts&rdquo; Key 下面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=s2>&#34;Mounts&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Type&#34;</span>: <span class=s2>&#34;volume&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Name&#34;</span>: <span class=s2>&#34;my-vol&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Source&#34;</span>: <span class=s2>&#34;/var/lib/docker/volumes/my-vol/_data&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Destination&#34;</span>: <span class=s2>&#34;/usr/share/nginx/html&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Driver&#34;</span>: <span class=s2>&#34;local&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Mode&#34;</span>: <span class=s2>&#34;&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;RW&#34;</span>: true,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Propagation&#34;</span>: <span class=s2>&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>]</span>,
</span></span></code></pre></td></tr></table></div></div><h4 id=删除数据卷>删除数据卷</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume rm my-vol
</span></span></code></pre></td></tr></table></div></div><p><code>数据卷</code> 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 <code>数据卷</code>，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 <code>数据卷</code>。</p><p>如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 <code>docker rm -v</code> 这个命令。</p><p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker volume prune
</span></span></code></pre></td></tr></table></div></div><h3 id=挂载主机目录-bind-mount>挂载主机目录 bind mount</h3><h4 id=挂载一个主机目录作为数据卷>挂载一个主机目录作为数据卷</h4><p>使用 <code>--mount</code> 标记可以指定挂载一个本地主机的目录到容器中去。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --name web <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=c1># -v /src/webapp:/usr/share/nginx/html \</span>
</span></span><span class=line><span class=cl>    --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span>/src/webapp,target<span class=o>=</span>/usr/share/nginx/html <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>上面的命令加载主机的 <code>/src/webapp</code> 目录到容器的 <code>/usr/share/nginx/html</code>目录。</p><p>这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是<strong>绝对路径</strong>，以前使用 <code>-v</code> 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 <code>--mount</code> 参数时如果本地目录不存在，Docker 会报错。</p><p>Docker 挂载主机目录的默认权限是 <code>读写</code>，用户也可以通过增加 <code>readonly</code> 指定为 <code>只读</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    --name web <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    <span class=c1># -v /src/webapp:/usr/share/nginx/html:ro \</span>
</span></span><span class=line><span class=cl>    --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span>/src/webapp,target<span class=o>=</span>/usr/share/nginx/html,readonly <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>加了 <code>readonly</code> 之后，就挂载为 <code>只读</code> 了。如果你在容器内 <code>/usr/share/nginx/html</code> 目录新建文件，会显示如下错误</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/usr/share/nginx/html <span class=c1># touch new.txt</span>
</span></span><span class=line><span class=cl>touch: new.txt: Read-only file system
</span></span></code></pre></td></tr></table></div></div><h4 id=查看数据卷的具体信息-1>查看数据卷的具体信息</h4><p>在主机里使用以下命令可以查看 <code>web</code> 容器的信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker inspect web
</span></span></code></pre></td></tr></table></div></div><p><code>挂载主机目录</code> 的配置信息在 &ldquo;Mounts&rdquo; Key 下面</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=s2>&#34;Mounts&#34;</span>: <span class=o>[</span>
</span></span><span class=line><span class=cl>    <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Type&#34;</span>: <span class=s2>&#34;bind&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Source&#34;</span>: <span class=s2>&#34;/src/webapp&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Destination&#34;</span>: <span class=s2>&#34;/usr/share/nginx/html&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Mode&#34;</span>: <span class=s2>&#34;&#34;</span>,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;RW&#34;</span>: true,
</span></span><span class=line><span class=cl>        <span class=s2>&#34;Propagation&#34;</span>: <span class=s2>&#34;rprivate&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>]</span>,
</span></span></code></pre></td></tr></table></div></div><h4 id=挂载一个本地主机文件作为数据卷>挂载一个本地主机文件作为数据卷</h4><p><code>--mount</code> 标记也可以从主机挂载单个文件到容器中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run --rm -it <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   <span class=c1># -v $HOME/.bash_history:/root/.bash_history \</span>
</span></span><span class=line><span class=cl>   --mount <span class=nv>type</span><span class=o>=</span>bind,source<span class=o>=</span><span class=nv>$HOME</span>/.bash_history,target<span class=o>=</span>/root/.bash_history <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   ubuntu:18.04 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>   bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>root@2affd44b4667:/# <span class=nb>history</span>
</span></span><span class=line><span class=cl><span class=m>1</span>  ls
</span></span><span class=line><span class=cl><span class=m>2</span>  diskutil list
</span></span></code></pre></td></tr></table></div></div><p>这样就可以记录在容器输入过的命令了。</p><h3 id=volume-和-bind-的区别>volume 和 bind 的区别</h3><ul><li><p>volume：如果 volume 是空的而 container 中的目录有内容，那么 docker 会将 container 目录中的内容拷贝到 volume 中，但是如果 volume 中已经有内容，则会将 container 中的目录覆盖。</p></li><li><p>bind mount :不管 host 目录是否有值，都会覆盖 container 映射的目录</p></li></ul><h2 id=使用网络>使用网络</h2><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p><h3 id=外部访问容器>外部访问容器</h3><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p><p>当使用 <code>-P</code> 标记时，Docker 会<strong>随机</strong>映射一个端口到内部容器开放的网络端口。</p><p>使用 <code>docker container ls</code> 可以看到，本地主机的 32768 被映射到了容器的 80 端口。此时访问本机的 32768 端口即可访问容器内 NGINX 默认页面。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -P nginx:alpine
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>$ docker container ls -l
</span></span><span class=line><span class=cl>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES
</span></span><span class=line><span class=cl>fae320d08268        nginx:alpine        <span class=s2>&#34;/docker-entrypoint.…&#34;</span>   <span class=m>24</span> seconds ago      Up <span class=m>20</span> seconds       0.0.0.0:32768-&gt;80/tcp   bold_mcnulty
</span></span></code></pre></td></tr></table></div></div><p>同样的，可以通过 <code>docker logs</code> 命令来查看访问记录。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker logs fa
</span></span><span class=line><span class=cl>172.17.0.1 - - <span class=o>[</span>25/Aug/2020:08:34:04 +0000<span class=o>]</span> <span class=s2>&#34;GET / HTTP/1.1&#34;</span> <span class=m>200</span> <span class=m>612</span> <span class=s2>&#34;-&#34;</span> <span class=s2>&#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0&#34;</span> <span class=s2>&#34;-&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p><code>-p</code> 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。</p><p>支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p><h4 id=映射所有接口地址>映射所有接口地址</h4><p>使用 <code>hostPort:containerPort</code> 格式本地的 80 端口映射到容器的 80 端口，可以执行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 80:80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>此时默认会<strong>绑定本地所有接口上的所有地址</strong>。</p><h4 id=映射到指定地址的指定端口>映射到指定地址的指定端口</h4><p>可以使用 <code>ip:hostPort:containerPort</code> 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 127.0.0.1:80:80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h4 id=映射到指定地址的任意端口>映射到指定地址的任意端口</h4><p>使用 <code>ip::containerPort</code> 绑定 localhost 的任意端口到容器的 80 端口，本地主机会自动分配一个端口。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 127.0.0.1::80 nginx:alpine
</span></span></code></pre></td></tr></table></div></div><p>还可以使用 <code>udp</code> 标记来指定 <code>udp</code> 端口</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d -p 127.0.0.1:80:80/udp nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h4 id=查看映射端口配置-docker-port>查看映射端口配置 <code>docker port</code></h4><p>使用 <code>docker port</code> 来查看当前映射的端口配置，也可以查看到绑定的地址</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker port fa <span class=m>80</span>
</span></span><span class=line><span class=cl>0.0.0.0:32768
</span></span></code></pre></td></tr></table></div></div><p>注意：</p><ul><li>容器有自己的内部网络和 ip 地址（使用 <code>docker inspect</code> 查看，Docker 还可以有一个可变的网络配置。）</li><li><code>-p</code> 标记可以多次使用来绑定多个端口</li></ul><p>例如</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -d <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -p 80:80 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -p 443:443 <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    nginx:alpine
</span></span></code></pre></td></tr></table></div></div><h3 id=容器互联>容器互联</h3><p>如果你之前有 <code>Docker</code> 使用经验，你可能已经习惯了使用 <code>--link</code> 参数来使容器互联。</p><p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 <code>--link</code> 参数。</p><h4 id=新建网络-docker-network-create>新建网络 <code>docker network create</code></h4><p>下面先创建一个新的 Docker 网络。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker network create -d bridge my-net
</span></span></code></pre></td></tr></table></div></div><p><code>-d</code> 参数指定 Docker 网络类型，有 <code>bridge</code> 和 <code>overlay</code>。其中 <code>overlay</code> 网络类型用于 <a href rel>Swarm mode</a>，在本小节中你可以忽略它。</p><h4 id=连接容器>连接容器</h4><p>运行一个容器并连接到新建的 <code>my-net</code> 网络</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --rm --name busybox1 --network my-net busybox sh
</span></span></code></pre></td></tr></table></div></div><p>打开新的终端，再运行一个容器并加入到 <code>my-net</code> 网络</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker run -it --rm --name busybox2 --network my-net busybox sh
</span></span></code></pre></td></tr></table></div></div><p>再打开一个新的终端查看容器信息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ docker container ls
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>CONTAINER ID    IMAGE         COMMAND   CREATED     STATUS  PORTS           NAMES
</span></span><span class=line><span class=cl>b47060aca56b    busybox       <span class=s2>&#34;sh&#34;</span>      <span class=m>11</span> minutes  ago     Up <span class=m>11</span> minutes   busybox2
</span></span><span class=line><span class=cl>8720575823ec    busybox       <span class=s2>&#34;sh&#34;</span>      <span class=m>16</span> minutes  ago     Up <span class=m>16</span> minutes   busybox1
</span></span></code></pre></td></tr></table></div></div><p>下面通过 <code>ping</code> 来证明 <code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><p>在 <code>busybox1</code> 容器输入以下命令</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ <span class=c1># ping busybox2</span>
</span></span><span class=line><span class=cl>PING busybox2 <span class=o>(</span>172.19.0.3<span class=o>)</span>: <span class=m>56</span> data bytes
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.3: <span class=nv>seq</span><span class=o>=</span><span class=m>0</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.072 ms
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.3: <span class=nv>seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.118 ms
</span></span></code></pre></td></tr></table></div></div><p>用 ping 来测试连接 <code>busybox2</code> 容器，它会解析成 <code>172.19.0.3</code>。</p><p>同理在 <code>busybox2</code> 容器执行 <code>ping busybox1</code>，也会成功连接到。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>/ <span class=c1># ping busybox1</span>
</span></span><span class=line><span class=cl>PING busybox1 <span class=o>(</span>172.19.0.2<span class=o>)</span>: <span class=m>56</span> data bytes
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.2: <span class=nv>seq</span><span class=o>=</span><span class=m>0</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.064 ms
</span></span><span class=line><span class=cl><span class=m>64</span> bytes from 172.19.0.2: <span class=nv>seq</span><span class=o>=</span><span class=m>1</span> <span class=nv>ttl</span><span class=o>=</span><span class=m>64</span> <span class=nv>time</span><span class=o>=</span>0.143 ms
</span></span></code></pre></td></tr></table></div></div><p>这样，<code>busybox1</code> 容器和 <code>busybox2</code> 容器建立了互联关系。</p><h4 id=docker-compose>Docker Compose</h4><p>如果你有多个容器之间需要互相连接，推荐使用 <a href rel>Docker Compose</a>。</p><h2 id=常用命令>常用命令</h2><p><a href="https://zhuanlan.zhihu.com/p/150951927#:~:text=Docker%20%28%E4%B8%80%29-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%201%201.%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A%20docker%20images%202%202.%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A,5.%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%9A%20docker%20restart%20mysql01%2010%206.%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20" target=_blank rel="noopener noreffer">https://zhuanlan.zhihu.com/p/150951927#:~:text=Docker%20%28%E4%B8%80%29-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%201%201.%E6%9C%AC%E5%9C%B0%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A%20docker%20images%202%202.%E4%BB%93%E5%BA%93%E9%95%9C%E5%83%8F%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%EF%BC%9A,5.%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%EF%BC%9A%20docker%20restart%20mysql01%2010%206.%E5%81%9C%E6%AD%A2%E5%AE%B9%E5%99%A8%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20</a></p><h2 id=使用-dockerfile-定制镜像>使用 Dockerfile 定制镜像</h2><p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个<strong>脚本</strong>，用这个脚本来构建、定制镜像，那么一些无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的<strong>指令(Instruction)</strong>，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><p>还以之前定制 <code>nginx</code> 镜像为例，这次我们使用 Dockerfile 来定制。</p><p>在一个空白目录中，建立一个文本文件，并命名为 <code>Dockerfile</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ mkdir mynginx
</span></span><span class=line><span class=cl>$ <span class=nb>cd</span> mynginx
</span></span><span class=line><span class=cl>$ touch Dockerfile
</span></span></code></pre></td></tr></table></div></div><p>其内容为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>FROM nginx
</span></span><span class=line><span class=cl>RUN <span class=nb>echo</span> <span class=s1>&#39;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#39;</span> &gt; /usr/share/nginx/html/index.html
</span></span></code></pre></td></tr></table></div></div><p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，<code>FROM</code> 和 <code>RUN</code>。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-12</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/golang/basicgrammar/ class=prev rel=prev title="Go 基础语法"><i class="fas fa-angle-left fa-fw"></i>Go 基础语法</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>酒困路长惟欲睡，日高人渴漫思茶</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><script type=text/javascript src=/Notes/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/Notes/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:45},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js></script></body></html>