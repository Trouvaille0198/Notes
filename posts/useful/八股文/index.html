<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>面试八股文 - 伤心肠粉的酱油碟子</title><meta name=Description content><meta property="og:title" content="面试八股文"><meta property="og:description" content="八股文 计算机网络 说说 OSI 七层、TCP/IP 四层的关系和区别？ OSI 七层从下往上依次是："><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-11T14:08:15+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="面试八股文"><meta name=twitter:description content="八股文 计算机网络 说说 OSI 七层、TCP/IP 四层的关系和区别？ OSI 七层从下往上依次是："><meta name=application-name content="伤心肠粉的酱油碟子"><meta name=apple-mobile-web-app-title content="伤心肠粉的酱油碟子"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/useful/%E5%85%AB%E8%82%A1%E6%96%87/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"面试八股文","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/useful\/%E5%85%AB%E8%82%A1%E6%96%87\/"},"genre":"posts","keywords":"刷题","wordcount":10028,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/useful\/%E5%85%AB%E8%82%A1%E6%96%87\/","datePublished":"2022-02-25T00:00:00+00:00","dateModified":"2022-03-11T14:08:15+00:00","publisher":{"@type":"Organization","name":"MelonCholi"},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/Notes/categories/>分类 </a><a class=menu-item href=/Notes/tags/>标签 </a><a class=menu-item href=/Notes/posts/>文章 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/Notes/categories/ title>分类</a><a class=menu-item href=/Notes/tags/ title>标签</a><a class=menu-item href=/Notes/posts/ title>文章</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">面试八股文</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/Notes/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>MelonCholi</a></span>&nbsp;<span class=post-category>收录于 <a href=/Notes/categories/%E6%9C%89%E7%94%A8%E7%9A%84%E4%B8%9C%E4%B8%9C/><i class="far fa-folder fa-fw"></i>有用的东东</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-02-25>2022-02-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 10028 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 21 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#计算机网络>计算机网络</a><ul><li><a href=#说说-osi-七层tcpip-四层的关系和区别>说说 OSI 七层、TCP/IP 四层的关系和区别？</a></li><li><a href=#说说-tcp-与-udp-的区别>说说 TCP 与 UDP 的区别？</a></li><li><a href=#tcp-是如何实现数据的可靠性>TCP 是如何实现数据的可靠性？</a></li><li><a href=#说说-tcp-协议如何提高传输效率>说说 TCP 协议如何提高传输效率？</a></li><li><a href=#你知道-tcp-如何处理拥塞吗>你知道 TCP 如何处理拥塞吗？</a></li><li><a href=#讲一下三次握手和四次挥手全过程>讲一下三次握手和四次挥手全过程</a></li><li><a href=#为什么-tcp-链接需要三次握手两次不可以么为什么>为什么 TCP 链接需要三次握手，两次不可以么，为什么？</a></li><li><a href=#ip-地址是怎样分类的你知道吗>IP 地址是怎样分类的，你知道吗？</a></li><li><a href=#讲一下-http11-和-http2-有什么区别>讲一下 http1.1 和 http2 有什么区别？</a></li><li><a href=#说说-http-和-https-的区别>说说 HTTP 和 HTTPS 的区别？</a></li><li><a href=#你知道对称加密和非对称加密的区别和原理吗>你知道对称加密和非对称加密的区别和原理吗？</a></li><li><a href=#常见的状态码有哪些>常见的状态码有哪些?</a></li><li><a href=#http-中常见的-header-字段有哪些>http 中常见的 header 字段有哪些？</a></li><li><a href=#get-与-post-的区别>GET 与 POST 的区别</a></li><li><a href=#dns-的寻址过程你知道吗>DNS 的寻址过程你知道吗？</a></li><li><a href=#在浏览器中输入一个-httpwwwbaiducomhttpslinkzhihucomtargethttp3awwwbaiducom-后执行的全部过程>在浏览器中输入一个 <a href="https://link.zhihu.com/?target=http%3A//www.baidu.com">http://www.baidu.com</a> 后执行的全部过程？</a></li><li><a href=#sessioncookie-的区别>Session、Cookie 的区别</a></li><li><a href=#有哪些-web-性能优化技术>有哪些 web 性能优化技术?</a></li><li><a href=#什么是-xss-攻击>什么是 XSS 攻击？</a></li><li><a href=#什么是跨站攻击-csrf>什么是跨站攻击 CSRF？</a></li><li><a href=#简述-tcp-粘包现象><strong>简述 TCP 粘包现象</strong></a></li><li><a href=#tcp-粘包现象处理方法><strong>TCP 粘包现象处理方法</strong></a></li><li><a href=#简述半连接队列><strong>简述半连接队列</strong></a></li><li><a href=#简述-syn-攻击><strong>简述 SYN 攻击</strong></a></li><li><a href=#https-的连接过程><strong>https 的连接过程</strong></a></li><li><a href=#了解-rest-api-吗><strong>了解 REST API 吗</strong></a></li></ul></li><li><a href=#操作系统>操作系统</a><ul><li><a href=#操作系统有哪些分类><strong>操作系统有哪些分类？</strong></a></li><li><a href=#什么是内核态和用户态><strong>什么是内核态和用户态？</strong></a></li><li><a href=#如何实现内核态和用户态的切换><strong>如何实现内核态和用户态的切换？</strong></a></li><li><a href=#并发和并行的区别>并发和并行的区别</a></li><li><a href=#进程和线程的区别>进程和线程的区别</a></li><li><a href=#进程间通信方法><strong>进程间通信方法</strong></a></li><li><a href=#线程间通信方式>线程间通信方式</a></li><li><a href=#进程调度的时机><strong>进程调度的时机</strong></a></li><li><a href=#不能进行进程调度的情况><strong>不能进行进程调度的情况</strong></a></li><li><a href=#进程的调度策略><strong>进程的调度策略</strong></a></li><li><a href=#什么是信号><strong>什么是信号</strong></a></li><li><a href=#进程调度策略的基本设计指标><strong>进程调度策略的基本设计指标</strong></a></li><li><a href=#进程的状态与状态转换><strong>进程的状态与状态转换</strong></a></li><li><a href=#什么是孤儿进程僵尸进程><strong>什么是孤儿进程？僵尸进程?</strong></a></li><li><a href=#多线程模型><strong>多线程模型</strong></a></li><li><a href=#死锁是怎样产生的><strong>死锁是怎样产生的？</strong></a></li><li><a href=#如何解决死锁问题><strong>如何解决死锁问题？</strong></a></li><li><a href=#优先级反转是什么如何解决><strong>优先级反转是什么？如何解决</strong></a></li></ul></li><li><a href=#测试开发>测试开发</a><ul><li><a href=#定位测试方法>定位测试方法</a></li></ul></li><li><a href=#其他>其他</a><ul><li><a href=#爬虫-url-去重方法>爬虫 url 去重方法</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=八股文>八股文</h1><h2 id=计算机网络>计算机网络</h2><h3 id=说说-osi-七层tcpip-四层的关系和区别>说说 OSI 七层、TCP/IP 四层的关系和区别？</h3><p>OSI 七层从下往上依次是：<code>物理层</code>、<code>数据链路层</code>、<code>网络层</code>、<code>传输层</code>、<code>会话层</code>、<code>表示层</code>、<code>应用层</code>。</p><p>TCP/IP 四层从下往上依次是：<code>网络接口层</code>、<code>网络层</code>、<code>传输层</code>、<code>应用层</code></p><p><strong>特点：</strong></p><ul><li>层与层之间相互独立又相互依靠</li><li>上层依赖于下层，下层为上层提供服务</li></ul><p>TCP/IP 四层是 OSI 七层的简化版，已经成为实事国际标准</p><h3 id=说说-tcp-与-udp-的区别>说说 TCP 与 UDP 的区别？</h3><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-4e57dcabfc7814f50199ffbd444c5eed_b.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-4e57dcabfc7814f50199ffbd444c5eed_b.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-4e57dcabfc7814f50199ffbd444c5eed_b.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-4e57dcabfc7814f50199ffbd444c5eed_b.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-4e57dcabfc7814f50199ffbd444c5eed_b.jpg title=img></p><h3 id=tcp-是如何实现数据的可靠性>TCP 是如何实现数据的可靠性？</h3><p>一句话：通过<code>校验和</code>、<code>序列号</code>、<code>确认应答</code>、<code>超时重传</code>、<code>连接管理</code>、<code>流量控制</code>、<code>拥塞控制</code>等机制来保证可靠性。</p><p><strong>校验和</strong></p><p>在数据传输过程中，将发送的数据段都当做一个 16 位的整数，将这些整数加起来，并且前面的进位不能丢弃，补在最后，然后取反，得到校验和。</p><p>发送方：在发送数据之前计算校验和，并进行校验和的填充。接收方：收到数据后，对数据以同样的方式进行计算，求出校验和，与发送方进行比较。</p><p><strong>序列号</strong></p><p>TCP 传输时将每个字节的数据都进行了编号，这就是序列号。序列号的作用不仅仅是应答作用，有了序列号能够将接收到的数据根据序列号进行排序，并且去掉重复的数据。</p><p><strong>确认应答</strong></p><p>TCP 传输过程中，每次接收方接收到数据后，都会对传输方进行确认应答，也就是发送 ACK 报文，这个 ACK 报文中带有对应的确认序列号，告诉发送方，接收了哪些数据，下一次数据从哪里传。</p><p><strong>超时重传</strong></p><p>在进行 TCP 传输时，由于存在确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟都没有接收到接收方传来的 ACK 报文，那么就对刚刚发送的数据进行重发。</p><p><strong>连接管理</strong></p><p>就是指三次握手、四次挥手的过程。</p><p><strong>流量控制</strong></p><p>如果发送方的发送速度太快，会导致接收方的接收缓冲区填充满了，这时候继续传输数据，就会造成大量丢包，进而引起丢包重传等等一系列问题。TCP 支持根据接收端的处理能力来决定发送端的发送速度，这就是流量控制机制。</p><p>具体实现方式：接收端将自己的接收缓冲区大小放入 TCP 首部的『窗口大小』字段中，通过 ACK 通知发送端。</p><p><strong>拥塞控制</strong></p><p>TCP 传输过程中一开始就发送大量数据，如果当时网络非常拥堵，可能会造成拥堵加剧。所以 TCP 引入了<code>慢启动机制</code>，在开始发送数据的时候，先发少量的数据探探路。</p><h3 id=说说-tcp-协议如何提高传输效率>说说 TCP 协议如何提高传输效率？</h3><p>一句话：TCP 协议提高效率的方式有<code>滑动窗口</code>、<code>快重传</code>、<code>延迟应答</code>、<code>捎带应答</code>等。</p><p><strong>滑动窗口</strong></p><p>如果每一个发送的数据段，都要收到 ACK 应答之后再发送下一个数据段，这样的话我们效率很低，大部分时间都用在了等待 ACK 应答上了。</p><p>为了提高效率我们可以一次发送多条数据，这样就能使等待时间大大减少，从而提高性能。 窗口大小指的是无需等待确认应答而可以继续发送数据的最大值。</p><p><strong>快重传</strong></p><p><code>快重传</code>也叫<code>高速重发控制</code>。</p><p>那么如果出现了丢包，需要进行重传。一般分为两种情况：</p><p>情况一：数据包已经抵达，ACK 被丢了。这种情况下，部分 ACK 丢了并不影响，因为可以通过后续的 ACK 进行确认；</p><p>情况二：数据包直接丢了。发送端会连续收到多个相同的 ACK 确认，发送端立即将对应丢失的数据重传。</p><p><strong>延迟应答</strong></p><p>如果接收数据的主机立刻返回 ACK 应答，这时候返回的窗口大小可能比较小。</p><ul><li>假设接收端缓冲区为 1M，一次收到了 512K 的数据；如果立刻应答，返回的窗口就是 512K；</li><li>但实际上可能处理端处理速度很快，10ms 之内就把 512K 的数据从缓存区消费掉了；</li><li>在这种情况下，接收端处理还远没有达到自己的极限，即使窗口再放大一些，也能处理过来；</li><li>如果接收端稍微等一会在应答，比如等待 200ms 再应答，那么这个时候返回的窗口大小就是 1M；</li></ul><p>窗口越大，网络吞吐量就越大，传输效率就越高；我们的目标是在保证网络不拥塞的情况下尽量提高传输效率。</p><p><strong>捎带应答</strong></p><p>在延迟应答的基础上，很多情况下，客户端服务器在应用层也是一发一收的。这时候常常采用捎带应答的方式来提高效率，而 ACK 响应常常伴随着数据报文共同传输。如：三次握手。</p><h3 id=你知道-tcp-如何处理拥塞吗>你知道 TCP 如何处理拥塞吗？</h3><ul><li>慢开始</li><li>拥塞避免机制</li><li>设置门限变量</li><li>区分不同的丢包事件</li></ul><h3 id=讲一下三次握手和四次挥手全过程>讲一下三次握手和四次挥手全过程</h3><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210528101829778.png alt=image-20210528101829778 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210528102538934.png alt=image-20210528102538934 style=zoom:50%><h3 id=为什么-tcp-链接需要三次握手两次不可以么为什么>为什么 TCP 链接需要三次握手，两次不可以么，为什么？</h3><p><strong>两次握手只能保证单向连接是畅通的</strong></p><p>第一步，客户端给服务端发送一条消息：你好，服务端。 第二步，服务端收到消息，同时给客户端回复一条消息：收到！你好客户端。</p><p>这样的两次握手过程， 客户端给服务端打招呼，服务端收到了，说明客户端可以正常给服务端发送数据。但是服务端给客户端打招呼，服务端没有收到反馈，也就不能确保服务端是否能正常给客户端发送消息。</p><p><strong>只有经过第三次握手，才能确保双向都可以接收到对方的发送的数据</strong></p><p>第三步，客户端收到服务端发送的消息，回复：收到！这样就证明了客户端能正常收到服务端的消息。</p><h3 id=ip-地址是怎样分类的你知道吗>IP 地址是怎样分类的，你知道吗？</h3><p>先说一下 IP 的基本特点：</p><ul><li>IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255。</li><li>IP 地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。</li></ul><p>IP 地址主要分为 A、B、C 三类及特殊地址 D、E 这五类，甩一张图：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c9ee6f1b6a90d30aa94aad7d62019444_b.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c9ee6f1b6a90d30aa94aad7d62019444_b.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c9ee6f1b6a90d30aa94aad7d62019444_b.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c9ee6f1b6a90d30aa94aad7d62019444_b.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-c9ee6f1b6a90d30aa94aad7d62019444_b.jpg title=img></p><p>A 类：(1.0.0.0-126.0.0.0) 一般用于大型网络。</p><p>B 类：(128.0.0.0-191.255.0.0) 一般用于中等规模网络。</p><p>C 类：(192.0.0.0-223.255.255.0) 一般用于小型网络。</p><p>D 类：是多播地址，地址的网络号取值于 224~239 之间，一般用于多路广播用户。</p><p>E 类：是保留地址。地址的网络号取值于 240~255 之间。</p><h3 id=讲一下-http11-和-http2-有什么区别>讲一下 http1.1 和 http2 有什么区别？</h3><p><strong>HTTP1.1</strong></p><ul><li><p>持久连接</p><ul><li>在一个 TCP 连接上可以传送多个 HTTP 请求和响应。使用 TCP 长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。</li></ul></li><li><p>请求管道化</p></li><li><p>增加缓存处理（新的字段如 cache-control）</p></li><li><p>增加 Host 字段、支持断点传输等</p></li></ul><p><strong>HTTP2.0</strong></p><ul><li><p>二进制分帧</p><ul><li>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列 id，服务器就可以进行并行传输数据。</li><li>头部压缩</li></ul></li><li><p>多路复用（或连接共享）</p><ul><li>多路复用前，文件时串行传输的，请求 a 文件，b 文件只能等待，并且连接数过多。引入多路复用，a 文件 b 文件可以同时传输。</li></ul></li><li><p>服务器推送</p></li></ul><h3 id=说说-http-和-https-的区别>说说 HTTP 和 HTTPS 的区别？</h3><ul><li><p>HTTPS 协议需要到 CA 申请证书，一般免费证书较少，因而需要一定费用。</p></li><li><p>HTTP 是超文本传输协议，信息是<strong>明文传输</strong>，HTTPS 则是具有安全性的 SSL <strong>加密传输</strong>协议</p></li><li><p>HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443</p></li><li><p>HTTP 的连接很简单，是<strong>无状态</strong>的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</p></li></ul><h3 id=你知道对称加密和非对称加密的区别和原理吗>你知道对称加密和非对称加密的区别和原理吗？</h3><p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即<code>如何安全地将密钥发给对方</code>;</p><p>而非对称加密是指使用一对非对称密钥，即<code>公钥</code>和<code>私钥</code>，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以<code>保证安全性</code>；但是和对称加密比起来，它比较<code>慢</code>，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p><h3 id=常见的状态码有哪些>常见的状态码有哪些?</h3><p>1×× : 请求处理中，请求已被接受，正在处理</p><p>2×× : 请求成功，请求被成功处理 200 OK</p><p>3×× : 重定向，要完成请求必须进行进一步处理</p><ul><li>301 : 永久性转移</li><li>302 ：暂时性转移</li><li>304 ：已缓存（资源没修改，用之前缓存就行）</li></ul><p>4×× : 客户端错误，请求不合法</p><ul><li>400：Bad Request 请求有语法问题</li><li>403：拒绝请求</li><li>404：客户端所访问的页面不存在</li></ul><p>5×× : 服务器端错误，服务器不能处理合法请求</p><ul><li>500 ：服务器内部错误</li><li>503 ： 服务不可用，稍等</li></ul><h3 id=http-中常见的-header-字段有哪些>http 中常见的 header 字段有哪些？</h3><table><thead><tr><th style=text-align:left>字段名</th><th style=text-align:left>说明</th><th style=text-align:left>示例</th></tr></thead><tbody><tr><td style=text-align:left>Accept</td><td style=text-align:left>能够接受的回应内容类型（Content-Types）</td><td style=text-align:left>Accept: text/plain</td></tr><tr><td style=text-align:left>Accept-Charset</td><td style=text-align:left>能够接受的字符集</td><td style=text-align:left>Accept-Charset: utf-8</td></tr><tr><td style=text-align:left>Accept-Encoding</td><td style=text-align:left>能够接受的编码方式列表</td><td style=text-align:left>Accept-Encoding: gzip, deflate</td></tr><tr><td style=text-align:left>Accept-Language</td><td style=text-align:left>能够接受的回应内容的自然语言列表</td><td style=text-align:left>Accept-Language: en-US</td></tr><tr><td style=text-align:left>Authorization</td><td style=text-align:left>用于超文本传输协议的认证的认证信息</td><td style=text-align:left>Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style=text-align:left>Cache-Control</td><td style=text-align:left>用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令</td><td style=text-align:left>Cache-Control: no-cache</td></tr><tr><td style=text-align:left>Connection</td><td style=text-align:left>该浏览器想要优先使用的连接类型</td><td style=text-align:left>Connection: keep-alive Connection: Upgrade</td></tr><tr><td style=text-align:left>Cookie</td><td style=text-align:left>服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie</td><td style=text-align:left>Cookie: $Version=1; Skin=new;</td></tr><tr><td style=text-align:left>Content-Length</td><td style=text-align:left>以 八位字节数组 （8位的字节）表示的请求体的长度</td><td style=text-align:left>Content-Length: 348</td></tr><tr><td style=text-align:left>Content-Type</td><td style=text-align:left>请求体的 多媒体类型</td><td style=text-align:left>Content-Type: application/x-www-form-urlencoded</td></tr><tr><td style=text-align:left>Date</td><td style=text-align:left>发送该消息的日期和时间</td><td style=text-align:left>Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td style=text-align:left>Expect</td><td style=text-align:left>表明客户端要求服务器做出特定的行为</td><td style=text-align:left>Expect: 100-continue</td></tr><tr><td style=text-align:left>Host</td><td style=text-align:left>服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号</td><td style=text-align:left>Host: en.wikipedia.org:80 Host: en.wikipedia.org</td></tr><tr><td style=text-align:left>If-Match</td><td style=text-align:left>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源</td><td style=text-align:left>If-Match: &ldquo;737060cd8c284d8af7ad3082f209582d&rdquo;</td></tr><tr><td style=text-align:left>If-Modified-Since</td><td style=text-align:left>允许在对应的内容未被修改的情况下返回304未修改</td><td style=text-align:left>If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td style=text-align:left>If-None-Match</td><td style=text-align:left>允许在对应的内容未被修改的情况下返回304未修改</td><td style=text-align:left>If-None-Match: &ldquo;737060cd8c284d8af7ad3082f209582d&rdquo;</td></tr><tr><td style=text-align:left>If-Range</td><td style=text-align:left>如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td><td style=text-align:left>If-Range: &ldquo;737060cd8c284d8af7ad3082f209582d&rdquo;</td></tr><tr><td style=text-align:left>Range</td><td style=text-align:left>仅请求某个实体的一部分</td><td style=text-align:left>Range: bytes=500-999</td></tr><tr><td style=text-align:left>User-Agent</td><td style=text-align:left>浏览器的浏览器身份标识字符串</td><td style=text-align:left>User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td></tr><tr><td style=text-align:left>Origin</td><td style=text-align:left>发起一个针对 跨来源资源共享 的请求</td><td style=text-align:left>Origin: <a href=http://www.example-social-network.com target=_blank rel="noopener noreffer">http://www.example-social-network.com</a></td></tr></tbody></table><h3 id=get-与-post-的区别>GET 与 POST 的区别</h3><p>GET 一般用来从服务器上获取资源，POST 一般用来创建资源；</p><ul><li><p>GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的。</p></li><li><p>从请求参数形式上看，GET 请求的数据会附在<code>URL之后</code>；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的<code>请求体</code>中。</p></li><li><p>POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而 POST 请求参数则被包装到请求体中，相对更安全。</p></li><li><p>GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</p></li></ul><h3 id=dns-的寻址过程你知道吗>DNS 的寻址过程你知道吗？</h3><p>1、客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器</p><p>2、本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找</p><p>3、本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器</p><p>4、根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址</p><p>5、客户机的dns服务器根据返回的信息接着访问下一级的dns服务器</p><p>6、这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息</p><p>7、客户机的本地的dns服务器会将查询结果返回给我们的客户机</p><p>8、客户机根据得到的ip信息访问目标主机，完成解析过程</p><h3 id=在浏览器中输入一个-httpwwwbaiducomhttpslinkzhihucomtargethttp3awwwbaiducom-后执行的全部过程>在浏览器中输入一个 <a href="https://link.zhihu.com/?target=http%3A//www.baidu.com" target=_blank rel="noopener noreffer">http://www.baidu.com</a> 后执行的全部过程？</h3><p>域名解析 -> 建立 TCP 连接（三次握手）-> 发起 http 请求 -> 服务器响应 http 请求，浏览器得到 html 代码 -> 浏览器解析 html 代码，并请求 html 代码中的资源（如 js、css、图片等）-> 浏览器对页面进行渲染呈献给用户。</p><h3 id=sessioncookie-的区别>Session、Cookie 的区别</h3><ul><li>session 存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号 sessionId，通常存放于 cookie 中。服务器收到 cookie 后解析出 sessionId，再去 session 列表中查找，才能找到相应 session。</li><li>cookie 类似一个令牌，装有 sessionId，存储在客户端，浏览器通常会自动添加。</li><li>token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。</li><li>jwt 只是一个跨域认证的方案</li></ul><p><strong>补充 JWT</strong></p><p>JWT 就是 token 的一种实现方式，并且基本是 java web 领域的事实标准。</p><p>JWT 全称是 JSON Web Token。基本可以看出是使用 JSON 格式传输 token</p><p>JWT 由 3 部分构成:</p><ul><li>Header：描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。</li><li>Payload（负载）：用来存放实际需要传递的数据</li><li>Signature（签名）：服务器通过 Payload、Header 和一个密钥 (secret) 使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。</li></ul><p>流程：</p><ul><li>在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过 Payload、Header 和一个密钥(secret) 创建令牌（Token）并将 Token 发送给客户端，</li><li>然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization 字段中</li></ul><h3 id=有哪些-web-性能优化技术>有哪些 web 性能优化技术?</h3><ul><li>DNS 查询优化</li><li>客户端缓存</li><li>优化 TCP 连接</li><li>避免重定向</li><li>网络边缘的缓存</li><li>条件缓存</li><li>压缩和代码极简化</li><li>图片优化</li></ul><h3 id=什么是-xss-攻击>什么是 XSS 攻击？</h3><p>XSS 即（Cross Site Scripting）中文名称为：跨站脚本攻击。</p><p>XSS 的重点不在于跨站点，而在于脚本的执行。</p><p>XSS的原理是：恶意攻击者在 web 页面中会插入一些恶意的 script 代码。当用户浏览该页面的时候，那么嵌入到web 页面中 script 代码会执行，因此会达到恶意攻击用户的目的。</p><p>XSS 攻击最主要有如下分类：<code>反射型</code>、<code>存储型</code>、及 <code>DOM-based 型</code>。 反射性和 DOM-baseed 型可以归类为<code>非持久性 XSS 攻击</code>。存储型可以归类为<code>持久性 XSS 攻击</code>。</p><h3 id=什么是跨站攻击-csrf>什么是跨站攻击 CSRF？</h3><p>CSRF（Cross Site Request Forgery，跨站域请求伪造）是一种网络的攻击方式，它在 2007 年曾被列为互联网 20 大安全隐患之一，也被称为『One Click Attack』或者 『Session Riding』，通常缩写为<code>CSRF</code>或者<code>XSRF</code>，是一种对网站的恶意利用。</p><p>听起来像跨站脚本（XSS），但它与 XSS 非常不同，并且攻击方式几乎相左。</p><p>XSS 利用站点内的信任用户，而 CSRF 则通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>与 XSS 攻击相比，CSRF 攻击往往不大流行（因此对其进行防范的资源也相当稀少）和难以防范，所以被认为比XSS更具危险性。</p><h3 id=简述-tcp-粘包现象><strong>简述 TCP 粘包现象</strong></h3><p>TCP 是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个 tcp 报文中发出去的可能性。 可以简单的理解成客户端调用了两次 send，服务器端一个 recv 就把信息都读出来了。</p><h3 id=tcp-粘包现象处理方法><strong>TCP 粘包现象处理方法</strong></h3><p>固定发送信息长度，或在两个信息之间加入分隔符。</p><h3 id=简述半连接队列><strong>简述半连接队列</strong></h3><p>TCP 握手中，当服务器处于 SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</p><h3 id=简述-syn-攻击><strong>简述 SYN 攻击</strong></h3><p>泛洪攻击</p><p>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费 CPU 和内存资源。</p><p>优化方式：</p><ol><li>缩短 SYN Timeout 时间</li><li>记录 IP，若连续受到某个IP的重复 SYN 报文，从这个 IP 地址来的包会被一概丢弃。</li></ol><h3 id=https-的连接过程><strong>https 的连接过程</strong></h3><ol><li>浏览器将支持的加密算法信息发给服务器</li><li>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器</li><li>客户端(SSL/TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为 client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。</li><li>客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端对称密钥发送给服务器</li><li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。</li><li>服务器将加密后的密文发送给客户端</li><li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成</li></ol><h3 id=了解-rest-api-吗><strong>了解 REST API 吗</strong></h3><p>REST API 全称为表述性状态转移（Representational State Transfer，REST）即利用 HTTP 中 get、post、put、delete 以及其他的 HTTP 方法构成 REST 中数据资源的增删改查操作：</p><ul><li>Create ： POST</li><li>Read ： GET</li><li>Update ： PUT/PATCH</li><li>Delete： DELETE</li></ul><h2 id=操作系统>操作系统</h2><h3 id=操作系统有哪些分类><strong>操作系统有哪些分类？</strong></h3><p>批处理操作系统、分时操作系统、实时操作系统。</p><p>若一个操作系统兼顾批操作和分时的功能，则称该系统为通用操作系统。</p><h3 id=什么是内核态和用户态><strong>什么是内核态和用户态？</strong></h3><p>都是处理机的执行状态</p><p>用户程序运行在用户态，操作系统内核运行在内核态。</p><p><strong>用户态</strong></p><p>非特权状态、目态</p><p>在此状态下，执行的代码被硬件限定，不能执行特权指令</p><p><strong>内核态</strong></p><p>特权状态、管态</p><p>核心态是操作系统内核所运行的模式，运行在该模式的代码，可以无限制地对系统存储、外部设备进行访问。</p><h3 id=如何实现内核态和用户态的切换><strong>如何实现内核态和用户态的切换？</strong></h3><p>处理器从用户态切换到内核态的方法有三种：<strong>系统调用</strong>、<strong>异常</strong>和<strong>外部中断</strong>。</p><ol><li>系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。</li><li>异常，也叫做<strong>内中断</strong>，是由错误引起的，如文件损坏、缺页故障等。</li><li>外部中断，是通过两根信号线来通知处理器外设的状态变化，是硬中断。</li></ol><h3 id=并发和并行的区别>并发和并行的区别</h3><ol><li>并发（concurrency）：指<strong>宏观上</strong>看起来两个程序在<strong>同时运行</strong>，比如说在单核 cpu 上的多任务。但是从<strong>微观上</strong>看两个程序的指令是<strong>交织着运行</strong>的，指令之间交错执行，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率（如降低某个进程的相应时间）。</li><li>并行（parallelism）：指<strong>严格物理意义上的同时运行</strong>，比如多核 cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。</li></ol><h3 id=进程和线程的区别>进程和线程的区别</h3><p>进程</p><ul><li>进程是<strong>进程实体</strong>的运行过程，是系统进行<strong>资源分配和独立调度的基本单位</strong></li><li>进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。</li></ul><p>进程是资源分配的最小单位，线程是程序执行的最小单位。</p><p>进程有自己的<strong>独立地址空间</strong>，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</p><p>而线程是<strong>共享进程中的数据</strong>的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很位。</p><p>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据。而进程之间的通信需要以通信的方式 (IPC) 进行。不过如何处理好同步与互斥是编写多线程程序的难点。</p><p>但是多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p><h3 id=进程间通信方法><strong>进程间通信方法</strong></h3><p>进程之间可以看到一份公共资源；而提供这份资源的形式或者提供者不同，造成了通信方式不同。</p><p>管道、系统 IPC（包括消息队列、信号量、信号、共享内存等）、以及套接字 socket。</p><h3 id=线程间通信方式>线程间通信方式</h3><p>锁机制：包括互斥锁、条件变量、读写锁。</p><ul><li>互斥锁：提供了以排他方式防止数据结构被并发修改的方法。</li><li>读写锁：允许多个线程同时读共享数据，而对写操作是互斥的。</li></ul><p>条件变量：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。</p><ul><li>条件变量始终与互斥锁一起使用。</li></ul><p>信号量机制 (Semaphore)：包括无名线程信号量和命名线程信号量。</p><p>信号机制 (Signal)：类似进程间的信号处理。</p><p>线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。</p><h3 id=进程调度的时机><strong>进程调度的时机</strong></h3><ol><li>当前运行的进程运行结束。</li><li>当前运行的进程由于某种原因阻塞。</li><li>执行完系统调用等系统程序后返回用户进程。</li><li>在使用抢占调度的系统中，具有更高优先级的进程就绪时。</li><li>分时系统中，分给当前进程的时间片用完。</li></ol><h3 id=不能进行进程调度的情况><strong>不能进行进程调度的情况</strong></h3><ol><li>在中断处理程序执行时。</li><li>在操作系统的内核程序临界区内。</li><li>其它需要完全屏蔽中断的原子操作过程中。、</li></ol><h3 id=进程的调度策略><strong>进程的调度策略</strong></h3><ol><li>先到先服务调度算法</li><li>短作业优先调度算法</li><li>优先级调度算法</li><li>时间片轮转调度算法</li><li>高响应比优先调度算法</li><li>多级队列调度算法</li><li>多级反馈队列调度算法</li></ol><h3 id=什么是信号><strong>什么是信号</strong></h3><p>一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。 Linux 系统上支持的30 种不同类型的信号。 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。</p><ul><li><p>发送信号：内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：</p><ul><li><p>内核检测到一个系统事件，比如除零错误或者子进程终止。</p></li><li><p>—个进程调用了 kill 函数， 显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</p></li></ul></li><li><p>接收信号：当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序 (signal handler) 的用户层函数捕获这个信号。</p></li></ul><h3 id=进程调度策略的基本设计指标><strong>进程调度策略的基本设计指标</strong></h3><ol><li>CPU 利用率</li><li>系统吞吐率，即单位时间内CPU完成的作业的数量。</li><li>响应时间。</li><li>周转时间。是指作业从提交到完成的时间间隔。从每个作业的角度看，完成每个作业的时间也是很关键</li></ol><ul><li>平均周转时间</li><li>带权周转时间</li><li>平均带权周转时间</li></ul><h3 id=进程的状态与状态转换><strong>进程的状态与状态转换</strong></h3><p>进程在运行时有三种基本状态：就绪态、运行态和阻塞态。</p><ol><li><p>运行（running）态：进程占有处理器正在运行的状态。进程已获得 CPU，其程序正在执行。在单处理机系统中，只有一个进程处于执行状态； 在多处理机系统中，则有多个进程处于执行状态。</p></li><li><p>就绪（ready）态：进程具备运行条件，等待系统分配处理器以便运行的状态。 当进程已分配到除 CPU 以外的所有必要资源后，只要再获得 CPU，便可立即执行，进程这时的状态称为就绪状态。在一个系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</p></li><li><p>阻塞（wait）态：又称等待态或睡眠态，指进程不具备运行条件，正在等待某个时间完成的状态。</p></li></ol><p>各状态之间的转换：</p><ol><li>就绪 → 执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，该进程便由就绪状态转变成执行状态。</li><li>执行 → 就绪：处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而不得不让出处理机，于是进程从执行状态转变成就绪状态。</li><li>执行 → 阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态。</li><li>阻塞 → 就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态。</li></ol><h3 id=什么是孤儿进程僵尸进程><strong>什么是孤儿进程？僵尸进程?</strong></h3><ol><li><p>孤儿进程： 父进程退出，子进程还在运行的这些子进程都是孤儿进程，孤儿进程将被 init 进程（1 号进程）所收养，并由 init 进程对他们完成状态收集工作。</p></li><li><p>僵尸进程： 进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 获 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这些进程是僵尸进程。</p></li></ol><h3 id=多线程模型><strong>多线程模型</strong></h3><ol><li>多对一模型。将多个用户级线程映射到一个内核级线程上。该模型下，线程在用户空间进行管理，效率较高。缺点就是一个线程阻塞，整个进程内的所有线程都会阻塞。几乎没有系统继续使用这个模型。</li><li>一对一模型。将内核线程与用户线程一一对应。优点是一个线程阻塞时，不会影响到其它线程的执行。该模型具有更好的并发性。缺点是内核线程数量一般有上限，会限制用户线程的数量。更多的内核线程数目也给线程切换带来额外的负担。linux和Windows操作系统家族都是使用一对一模型。</li><li>多对多模型。将多个用户级线程映射到多个内核级线程上。结合了多对一模型和一对一模型的特点。</li></ol><h3 id=死锁是怎样产生的><strong>死锁是怎样产生的？</strong></h3><p>死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。 产生死锁需要满足下面四个条件：</p><ol><li>互斥条件（Mutual Exclusion）<ul><li>资源要求互斥访问</li></ul></li><li>请求和保持条件（Hold and wait）<ul><li>提出的请求得不到满足，手头的资源释放不出来</li></ul></li><li>不可抢占条件（No preemption）<ul><li>资源只能由占有者资源释放</li></ul></li><li>循环等待条件（Circular wait）<ul><li>必有一个进程-资源的环形链，环路中的进程形成等待链</li></ul></li></ol><h3 id=如何解决死锁问题><strong>如何解决死锁问题？</strong></h3><p>解决死锁的方法即破坏产生死锁的四个必要条件之一，主要方法如下:</p><ol><li>不让死锁发生<ul><li>预防死锁：静态策略，破坏死锁产生的必要条件</li><li>避免死锁：动态策略，不限制必要条件，而去防止系统进入不安全状态（银行家算法）</li></ul></li><li>让死锁发生<ul><li>检测死锁：通过检测机构及时发现死锁，再采取措施（资源分配图）</li><li>解除死锁：当死锁发生，撤销一些进程，回收资源再分配</li></ul></li></ol><h3 id=优先级反转是什么如何解决><strong>优先级反转是什么？如何解决</strong></h3><p>由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务(C)而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。</p><p>目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承 (priority inheritance)；另一种被称作优先级极限 (priority ceilings)。</p><ol><li>优先级继承 (priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。</li><li>优先级天花板 (priority ceilings) 优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级. (这个优先级称为该资源的优先级天花板)。</li></ol><h2 id=测试开发>测试开发</h2><h3 id=定位测试方法>定位测试方法</h3><p>确认网络环境是否正常</p><p>抓包看接口返回</p><p>查看服务端日志</p><h2 id=其他>其他</h2><h3 id=爬虫-url-去重方法>爬虫 url 去重方法</h3><p><a href=https://blog.csdn.net/weixin_42425970/article/details/102532185 target=_blank rel="noopener noreffer">https://blog.csdn.net/weixin_42425970/article/details/102532185</a></p><ul><li>放到列表中（烂中之烂）</li><li>放到数据库中（利用唯一性索引）</li><li>放到 HashSet 中</li><li>md5 编码后放到 HashSet 中</li><li>位图 Bitmap</li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-11</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E5%88%B7%E9%A2%98/>刷题</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/%E5%88%B7%E9%A2%98/array/560.-%E5%92%8C%E4%B8%BA-k-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/ class=prev rel=prev title="560. 和为 K 的子数组"><i class="fas fa-angle-left fa-fw"></i>560. 和为 K 的子数组</a>
<a href=/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/ class=next rel=next title=算法技巧>算法技巧<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>酒困路长惟欲睡，日高人渴漫思茶</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><script type=text/javascript src=/Notes/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/Notes/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:45},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js></script></body></html>