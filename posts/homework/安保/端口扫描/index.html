<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=robots content="noodp">
<meta http-equiv=x-ua-compatible content="IE=edge, chrome=1">
<title> - 伤心肠粉的酱油碟子</title><meta name=Description content><meta property="og:title" content>
<meta property="og:description" content="scanit 开发目的 端口扫描是指发送特特定的数据包到指定主机的端口，以获取端口状态的一种技术，它能用来了解与目标端口绑定的计算机网络服务类型。 端口扫描">
<meta property="og:type" content="article">
<meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"><meta property="article:section" content="posts">
<meta property="article:modified_time" content="2022-03-07T06:27:40+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content>
<meta name=twitter:description content="scanit 开发目的 端口扫描是指发送特特定的数据包到指定主机的端口，以获取端口状态的一种技术，它能用来了解与目标端口绑定的计算机网络服务类型。 端口扫描">
<meta name=application-name content="伤心肠粉的酱油碟子">
<meta name=apple-mobile-web-app-title content="伤心肠粉的酱油碟子"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico>
<link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png>
<link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/homework/%E5%AE%89%E4%BF%9D/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/homework/%E5%AE%89%E4%BF%9D/ex4/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/homework\/%E5%AE%89%E4%BF%9D\/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F\/"},"genre":"posts","wordcount":4010,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/homework\/%E5%AE%89%E4%BF%9D\/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F\/","dateModified":"2022-03-07T06:27:40+00:00","publisher":{"@type":"Organization","name":"作者"},"author":{"@type":"Person","name":"作者"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script>
<div id=mask></div><div class=wrapper><header class=desktop id=header-desktop>
<div class=header-wrapper>
<div class=header-title>
<a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a>
</div><div class=menu>
<div class=menu-inner><a class=menu-item href=/Notes/posts/> 文章 </a><a class=menu-item href=/Notes/tags/> 标签 </a><a class=menu-item href=/Notes/categories/> 分类 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-desktop>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a>
</div></div></div></header><header class=mobile id=header-mobile>
<div class=header-container>
<div class=header-wrapper>
<div class=header-title>
<a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a>
</div><div class=menu-toggle id=menu-toggle-mobile>
<span></span><span></span><span></span>
</div></div><div class=menu id=menu-mobile><div class=search-wrapper>
<div class="search mobile" id=search-mobile>
<input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索>
<i class="fas fa-search fa-fw"></i>
</a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空>
<i class="fas fa-times-circle fa-fw"></i>
</a>
<span class="search-button search-loading" id=search-loading-mobile>
<i class="fas fa-spinner fa-fw fa-spin"></i>
</span>
</div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>
取消
</a>
</div><a class=menu-item href=/Notes/posts/ title>文章</a><a class=menu-item href=/Notes/tags/ title>标签</a><a class=menu-item href=/Notes/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a></div></div></header><div class="search-dropdown desktop">
<div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile">
<div id=search-dropdown-mobile></div></div><main class=main>
<div class=container><div class=toc id=toc-auto>
<h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX"></h1><div class=post-meta>
<div class=post-meta-line><span class=post-author><a href=/Notes/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>作者</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=0001-01-01>0001-01-01</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4010 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 9 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept>
<div class="details-summary toc-title">
<span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span>
</div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents>
<ul>
<li><a href=#开发目的>开发目的</a></li><li><a href=#系统功能>系统功能</a></li><li><a href=#系统设计>系统设计</a>
<ul>
<li><a href=#网络接口工具函数>网络接口工具函数</a></li><li><a href=#端口扫描器scanner>端口扫描器Scanner</a>
<ul>
<li><a href=#发送syn包>发送SYN包</a></li><li><a href=#监听响应>监听响应</a>
<ul>
<li><a href=#并发优化>并发优化</a></li><li><a href=#监听过程>监听过程</a></li><li><a href=#过滤数据包>过滤数据包</a></li></ul></li></ul></li><li><a href=#命令行语法>命令行语法</a>
<ul>
<li><a href=#指定ip地址>指定ip地址</a></li><li><a href=#指定域名>指定域名</a></li><li><a href=#指定端口范围>指定端口范围</a></li></ul></li></ul></li><li><a href=#系统实现>系统实现</a></li><li><a href=#项目开发总结>项目开发总结</a></li><li><a href=#心得体会>心得体会</a></li><li><a href=#参考文献>参考文献</a></li></ul></nav></div></div><div class=content id=content><h1 id=scanit>scanit</h1><h2 id=开发目的>开发目的</h2><p>端口扫描是指发送特特定的数据包到指定主机的端口，以获取端口状态的一种技术，它能用来了解与目标端口绑定的计算机网络服务类型。</p><p>端口扫描在计算机安全领域发挥着重要的作用，通常，一个开放的端口就是一个潜在的入侵点，通过端口扫描，我们能全盘了解网站可能暴露的漏洞，对网络安全方面有着不可或缺的贡献。所以，了解如何使用端口扫描技术是一门重要的课题</p><p>半开放端口扫描（又名SYN scan）技术，是利用TCP建立连接三次握手中的半开放状态进行端口扫描的一种方式：开放的目标端口在接到主机发来的SYN包后，会返回一个SYN+ACK回应，若此时主机受到这样的响应包，就没有必要进行接下来的握手步骤，在半开放的状态下即终止连接。半开放端口扫描技术发出的探测包，不会被目标主机记录，安全性更高，扫描速度也比传统的全连接扫描更快。</p><p>本项目使用Golang编写完成了一个TCP半开放扫描工具，Go拥有接近C语言的速度和便捷的并发编程语法，还提供了基于libpcap的gopacket库，所以它成为了项目的不二之选。</p><h2 id=系统功能>系统功能</h2><p>系统实现了对指定ip地址或域名地址的所有端口（1-65535）进行TCP半开放端口扫描的功能。</p><p>系统提供了编译后可在命令行界面运行的指令语法，可以使用不同的命令参数（flag）来选择解析ip地址或域名的端口状态，也可以指定扫描的端口序列范围。</p><p>命令执行后会打印目标主机开放的端口列表。</p><h2 id=系统设计>系统设计</h2><p>系统主要由三部分组成</p><ul>
<li>
<p>一些与网络接口处理相关的工具函数</p></li><li>
<p>端口扫描器Scanner的结构及其方法定义</p></li><li>
<p>命令行语法构建程序</p></li></ul><h3 id=网络接口工具函数>网络接口工具函数</h3><p>在进行端口扫描事前，系统需要寻找一个合适的网络接口设备来承担收发数据包的工作，core/utils中的函数功能实现了这一过程的全自动化操作，即：</p><p>获取出站ip地址 -> 在一众网络接口中选取与出站ip匹配的接口设备 -> 获取其mac地址</p><p><code>getOutboundIP()</code>调用<code>net</code>标准库中的通讯模块，向特定ip地址发送udp包的方法来<strong>自动化地</strong>获取本地主机的出站ip</p><p><code>chooseDevice()</code>负责遍历本地主机的所有网络接口设备，并且找出匹配出站ip的设备接口名</p><p><code>getLocalMAC()</code>则找出该设备的mac地址</p><blockquote>
<p>为什么要获取mac地址和出站ip地址？</p><p>tcp包的构建不仅需要tcp协议的支持，也依赖于底层的ip协议层和以太网（Ethernet）协议层，而ip地址和mac地址在这两层中分别都起到了定位作用，必不可少。</p><p>同理，我们也需要知晓目标主机的ip地址和mac地址，才能构建对应的协议包头</p></blockquote><p><code>GetDstMAC()</code>发送了一个<strong>ARP请求包</strong>，期望获取目标主机的mac地址以构建以太网协议层的数据包头。函数循环发送5次ARP请求包，并且创建一个goroutine（go协程）专门等待响应；一旦监听到返回的数据包即返回其中的mac地址。</p><h3 id=端口扫描器scanner>端口扫描器Scanner</h3><p>Scanner的结构体定义如下：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// Scanner 端口扫描器 维护一个ip地址的端口扫描工作
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>type</span> <span class=nx>Scanner</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>mac</span>        <span class=nx>net</span><span class=p>.</span><span class=nx>HardwareAddr</span> <span class=c1>// 本地主机mac地址
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>deviceName</span> <span class=kt>string</span>           <span class=c1>// 本地发送设备名
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>handle</span>     <span class=o>*</span><span class=nx>pcap</span><span class=p>.</span><span class=nx>Handle</span>     <span class=c1>// 本地设备句柄
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>srcIP</span><span class=p>,</span> <span class=nx>dstIP</span><span class=p>,</span> <span class=nx>gatewayIP</span> <span class=nx>net</span><span class=p>.</span><span class=nx>IP</span> <span class=c1>// 出站ip 目标ip 网关ip
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// opts 和 buf 被用于 send 方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>opts</span> <span class=nx>gopacket</span><span class=p>.</span><span class=nx>SerializeOptions</span> <span class=c1>// 配置项
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>buf</span>  <span class=nx>gopacket</span><span class=p>.</span><span class=nx>SerializeBuffer</span>  <span class=c1>// 待发送的序列缓冲
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=nx>openPort</span> <span class=p>[]</span><span class=kt>string</span> <span class=c1>// 开放的端口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>在<strong>初始化</strong>Scanner时，一个对应网络接口设备的句柄（handle）将会生成，数据包的收发工作都由它完成；</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 创建句柄 实现tcp包的发送和接收
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>handle</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>pcap</span><span class=p>.</span><span class=nf>OpenLive</span><span class=p>(</span><span class=nx>deviceName</span><span class=p>,</span> <span class=mi>65536</span><span class=p>,</span> <span class=kc>true</span><span class=p>,</span> <span class=nx>pcap</span><span class=p>.</span><span class=nx>BlockForever</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>接下来介绍Scanner核心逻辑的实现</p><h4 id=发送syn包>发送SYN包</h4><p><code>send()</code>封装了gopacket库中的方法，将字节数组写进序列化缓冲中发送</p><p><code>sendSYNPackets()</code> 以goroutine的方式被扫描程序调用；它对目标地址从1到25565循环使用<code>send()</code>方法发送SYN数据包，试图对相应的端口建立TCP连接；在循环结束后，向一个channel（管道）内冲进一个标记以提示主程序发送完毕</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 循环发送SYN包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=nx>portNum</span> <span class=o>:=</span> <span class=mi>1</span><span class=p>;</span> <span class=nx>portNum</span> <span class=o>&lt;=</span> <span class=mi>65535</span><span class=p>;</span> <span class=nx>portNum</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>s</span><span class=p>.</span><span class=nf>send</span><span class=p>(</span><span class=nx>ethLayer</span><span class=p>,</span> <span class=nx>ip4Layer</span><span class=p>,</span> <span class=nx>tcpLayer</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>对发向不同的端口的TCP数据包来说，它们之间的唯一不同就是TCP包头中的<code>DstPort</code>。所以我们使用一个统一的<code>getLayers()</code>函数来构建包头信息的相同部分（包括IP协议层与以太网协议层）。</p><p>值得注意的是，在手动构建TCP数据包的过程中，TCP包头中的校验和被包裹住（wrap）它的IP协议层所决定。gopacket为我们提供了一个简便的解决方案<code>SetNetworkLayerForChecksum()</code>来实现自动计算校验和的目的：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// 使用ipv4协议包裹tcp层 以方便计算校验和
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>err</span> <span class=o>:=</span> <span class=nx>tcpLayer</span><span class=p>.</span><span class=nf>SetNetworkLayerForChecksum</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>ip4Layer</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=监听响应>监听响应</h4><h5 id=并发优化>并发优化</h5><p>发送与监听如果设计成线性运行，将会相当耗时。得益于Golang中的goroutine语法，我们可以方便地做到发送和监听功能并发执行：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nx>quit</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 发送syn包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>go</span> <span class=nx>s</span><span class=p>.</span><span class=nf>sendSYNPackets</span><span class=p>(</span><span class=nx>quit</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 阻塞以读取响应包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>s</span><span class=p>.</span><span class=nf>handleResponse</span><span class=p>(</span><span class=nx>quit</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>go</code>关键字开启了一个goroutine，保证发送逻辑在一个全新的协程中运行，与主进程互不干扰；所以在<code>sendSYNPackets()</code>仍未完成时，<code>handleResponse()</code>即可以开始监听收到的响应包</p><p><code>handleResponse()</code>接受一个channal信号<code>quit</code>，<code>quit</code>管道将在<code>sendSYNPackets()</code>结束后被写入标志，提醒监听结束，程序退出。也就是说，监听会在发送完65536个SYN包外加一段人为添加的时间间隔之后结束：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// ...此逻辑在sendSYNPackets()中
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>log</span><span class=p>.</span><span class=nf>Print</span><span class=p>(</span><span class=s>&#34;all ports are sent&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nx>time</span><span class=p>.</span><span class=nf>Sleep</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nx>Second</span><span class=p>)</span> <span class=c1>// 等一秒钟 保证接收端不遗漏有效响应
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>quit</span> <span class=o>&lt;-</span> <span class=mi>1</span> 
</span></span></code></pre></td></tr></table></div></div><h5 id=监听过程>监听过程</h5><p>gopacket提供了监听响应包的相关函数，该函数返回一个channel，一旦有新的数据包被此网络接口接收，它会作为<code>Packet</code>类型被送入channel中，并被<code>handleResponse()</code>方法捕捉到进行分析处理。</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// handleResponse 处理响应包
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Scanner</span><span class=p>)</span> <span class=nf>handleResponse</span><span class=p>(</span><span class=nx>quit</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>packetSource</span> <span class=o>:=</span> <span class=nx>gopacket</span><span class=p>.</span><span class=nf>NewPacketSource</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>handle</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>handle</span><span class=p>.</span><span class=nf>LinkType</span><span class=p>())</span>
</span></span><span class=line><span class=cl>	<span class=nx>packetChan</span> <span class=o>:=</span> <span class=nx>packetSource</span><span class=p>.</span><span class=nf>Packets</span><span class=p>()</span> <span class=c1>// 监听
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>for</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>select</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=o>&lt;-</span><span class=nx>quit</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;seems like we find all open port of %v&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>dstIP</span><span class=p>)</span>
</span></span><span class=line><span class=cl>			<span class=k>return</span>
</span></span><span class=line><span class=cl>		<span class=k>case</span> <span class=nx>packet</span> <span class=o>:=</span> <span class=o>&lt;-</span><span class=nx>packetChan</span><span class=p>:</span>
</span></span><span class=line><span class=cl>			<span class=nx>s</span><span class=p>.</span><span class=nf>judgePortStatus</span><span class=p>(</span><span class=nx>packet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><blockquote>
<p><code>select case</code>为Golang的语法糖，它阻塞程序，直到任意一个case上的channel有新数据读出</p></blockquote><h5 id=过滤数据包>过滤数据包</h5><p>监听时，任何流经此接口设备的数据包（甚至是发送至目标端口上的SYN包）都会被捕捉到，所以，过滤数据包、从中筛选出对象端口的响应数据是必要的过程。</p><p>过滤算法要求尽可能更早地将无用数据淘汰，因此，判断条件应该按淘汰命中率降序排列：</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// judgePortStatus  拆解响应包 分析端口状态 并在s中添加活跃端口
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=p>(</span><span class=nx>s</span> <span class=o>*</span><span class=nx>Scanner</span><span class=p>)</span> <span class=nf>judgePortStatus</span><span class=p>(</span><span class=nx>packet</span> <span class=nx>gopacket</span><span class=p>.</span><span class=nx>Packet</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=nx>networkLayer</span> <span class=o>:=</span> <span class=nx>packet</span><span class=p>.</span><span class=nf>NetworkLayer</span><span class=p>();</span> <span class=nx>networkLayer</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 检查是否有网络层
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// log.Printf(&#34;packet has no network layer&#34;)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>ipl</span> <span class=o>:=</span> <span class=nx>packet</span><span class=p>.</span><span class=nf>Layer</span><span class=p>(</span><span class=nx>layers</span><span class=p>.</span><span class=nx>LayerTypeIPv4</span><span class=p>);</span> <span class=nx>ipl</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 检查是否有ip层
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// log.Printf(&#34;packet has no IPv4 layer&#34;)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>tcpl</span> <span class=o>:=</span> <span class=nx>packet</span><span class=p>.</span><span class=nf>Layer</span><span class=p>(</span><span class=nx>layers</span><span class=p>.</span><span class=nx>LayerTypeTCP</span><span class=p>);</span> <span class=nx>tcpl</span> <span class=o>==</span> <span class=kc>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 检查是否有TCP层
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// log.Printf(&#34;packet has no TCP layer&#34;)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>recvIPLayer</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>ipl</span><span class=p>.(</span><span class=o>*</span><span class=nx>layers</span><span class=p>.</span><span class=nx>IPv4</span><span class=p>);</span> <span class=p>!</span><span class=nx>net</span><span class=p>.</span><span class=nx>IP</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>recvIPLayer</span><span class=p>.</span><span class=nx>SrcIP</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>dstIP</span><span class=p>)</span> <span class=o>||</span> <span class=p>!</span><span class=nx>net</span><span class=p>.</span><span class=nx>IP</span><span class=p>.</span><span class=nf>Equal</span><span class=p>(</span><span class=nx>recvIPLayer</span><span class=p>.</span><span class=nx>DstIP</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>srcIP</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 检查目标ip和源ip是否匹配
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// log.Printf(&#34;packet does not match our src IP / dst IP&#34;)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>recvTCPLayer</span><span class=p>,</span> <span class=nx>ok</span> <span class=o>:=</span> <span class=nx>tcpl</span><span class=p>.(</span><span class=o>*</span><span class=nx>layers</span><span class=p>.</span><span class=nx>TCP</span><span class=p>);</span> <span class=p>!</span><span class=nx>ok</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// 基本不会发生
</span></span></span><span class=line><span class=cl><span class=c1></span>      <span class=c1>// log.Printf(&#34;tcp layer is not tcp layer&#34;)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>recvTCPLayer</span><span class=p>.</span><span class=nx>DstPort</span> <span class=o>!=</span> <span class=nx>SRC_PORT</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// log.Printf(&#34;dst port %v does not match&#34;, recvTCPLayer.DstPort)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>recvTCPLayer</span><span class=p>.</span><span class=nx>RST</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=c1>// log.Printf(&#34;port %v closed&#34;, recvTCPLayer.SrcPort)
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=nx>recvTCPLayer</span><span class=p>.</span><span class=nx>SYN</span> <span class=o>&amp;&amp;</span> <span class=nx>recvTCPLayer</span><span class=p>.</span><span class=nx>ACK</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;port %v open&#34;</span><span class=p>,</span> <span class=nx>recvTCPLayer</span><span class=p>.</span><span class=nx>SrcPort</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=nx>s</span><span class=p>.</span><span class=nx>openPort</span> <span class=p>=</span> <span class=nb>append</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>openPort</span><span class=p>,</span> <span class=nx>recvTCPLayer</span><span class=p>.</span><span class=nx>SrcPort</span><span class=p>.</span><span class=nf>String</span><span class=p>())</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=nx>log</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;ignoring useless packet&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>“检查目标ip和源ip是否匹配”的判断可以过滤掉绝大多数的无用信息。</p><p>对于目标端口的响应，主要有三种类型：</p><ul>
<li>若目标端口返回SYN+ACK的数据包，则代表此端口处于开放状态</li><li>若目标端口返回RST数据包，则代表此端口处于关闭状态</li><li>若目标端口没有回应，则发出去的SYN包可能被包过滤机制过滤，也可以认为此端口处于关闭状态</li></ul><p>在目标返回一个SYN+ACK类型的数据包之后，我们已经达到了探测的目的，可以省略发送RST复位信息以断开连接这一步。</p><h3 id=命令行语法>命令行语法</h3><p>系统采用cobra构建命令行程序，提供丰富的自定义选项</p><h4 id=指定ip地址>指定ip地址</h4><p><code>-i [ip address]</code>或<code>--ipaddr [ip address]</code></p><p>扫描指定ip地址中的所有端口</p><p><code>ip address</code>允许以ipv4和ipv6格式输入</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>./scanit -i 192.168.0.1
</span></span></code></pre></td></tr></table></div></div><h4 id=指定域名>指定域名</h4><p><code>-d [domain name]</code>或<code>--domain [domain name]</code></p><p>扫描指定域名下的所有端口</p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>./scanit -d baidu.com
</span></span></code></pre></td></tr></table></div></div><blockquote>
<p>若同时输入<code>-i</code>和<code>-d</code>选项，程序将默认优先识别<code>-d</code>，如果域名不合法才会尝试<code>-i</code></p></blockquote><h4 id=指定端口范围>指定端口范围</h4><p><code>-p [port range]</code>或<code>--port [port range]</code></p><p>扫描指定范围内的端口，默认为1-65535</p><p><code>[port range]</code>的语法格式为<code>int-int</code>，如<code>114-514</code></p><div class=highlight><div class=chroma>
<table class=lntable><tr><td class=lntd>
<pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd>
<pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>./scanit -d github.com -p 123-6547
</span></span></code></pre></td></tr></table></div></div><h2 id=系统实现>系统实现</h2><ul>
<li>
<p>开发环境：Windows10-21H2</p></li><li>
<p>IDE：GoLand 2021.3.1</p></li><li>
<p>开发语言：Go 1.17.4</p></li><li>
<p>测试环境：</p><ul>
<li>
<p>Windows10-21H2</p></li><li>
<p>Ubuntu 20.04.2</p></li></ul></li></ul><p>扫描ip地址</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220211140917422.png alt=image-20220211140917422 style=zoom:67%>
<p>扫描域名</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220211140938324.png alt=image-20220211140938324 style=zoom:67%>
<blockquote>
<p>值得注意的是，在Linux上程序的运行耗时（3-5s）大大少于在Windows上运行（半分钟左右）</p></blockquote><p>指定端口范围进行扫描</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220211152017898.png alt=image-20220211152017898 style=zoom:67%>
<h2 id=项目开发总结>项目开发总结</h2><p>本项目基于libpcap、使用Go语言开发了一个半开放端口扫描工具，并提供了ip地址和域名的查询选择，允许用户以命令行指令的形式运行程序，具有比较完备的命令行语法检查，而且速度较快，可以接近nmap等传统端口扫描工具；同时准确率较高；但是项目需要完善的地方也有很多。</p><p>如何在有限的监听时间段内全面地接收到所有端口的响应，项目采用了一个较为简单的策略：在发送完所有SYN包后，系统将等待一段固定的时间间隔，超时则停止监听。但这样的策略对于一些后发迟发端口，可能会有遗漏的情况发生。</p><p>对于每一个单独的端口，指令只会发送一个SYN包；探测包如果在途中丢失，对于此端口的扫描实际上是失败的，系统没有检测机制来防止这样的情况发生。若对一个端口重复发包，效率上又失去了优势。因此，速度与准确率，向来是个两难的抉择。</p><p>另外，命令行界面尽管效率高，但是稍显简单；日后可以计划构建对用户更加友好的图形界面。</p><h2 id=心得体会>心得体会</h2><p>十周的《计算机安全与保密技术》课程，我获益良多。不论是在课堂上，在实验课中，还是在课外学习期间，我都能收获到其他课程所无法给予的网络安全知识与实战经验。</p><p>老师对于整个课程的规划非常合理完备：课上主讲专业知识，提供理论保障；实验课引入了一套齐全、循序渐进的教学方案，非常考验我们的英语能力、阅读文档和自学的能力；又以开发一个实战项目为期末考核内容，而不是简单机械地用卷面考试来评判成绩。得幸于这样的教学安排，我可以在短短十周接触到网络安全技术的诸多内容。</p><h2 id=参考文献>参考文献</h2><p><a href="https://pkg.go.dev/github.com/google/gopacket?utm_source=godoc" target=_blank rel="noopener noreffer">https://pkg.go.dev/github.com/google/gopacket?utm_source=godoc</a></p><p><a href=https://tutorialedge.net/projects/building-security-tools-in-go/building-port-scanner-go/#what-is-port-scanning target=_blank rel="noopener noreffer">https://tutorialedge.net/projects/building-security-tools-in-go/building-port-scanner-go/#what-is-port-scanning</a></p></div><div class=post-footer id=post-footer>
<div class=post-info>
<div class=post-info-line>
<div class=post-info-mod>
<span>更新于 2022-03-07</span>
</div><div class=post-info-license></div></div><div class=post-info-line>
<div class=post-info-md></div><div class=post-info-share>
<span></span>
</div></div></div><div class=post-info-more>
<section class=post-tags></section><section>
<span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span>
</section></div><div class=post-nav><a href=/Notes/posts/homework/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/ex/ex1/ class=prev rel=prev title><i class="fas fa-angle-left fa-fw"></i></a>
<a href=/Notes/posts/homework/%E5%AE%89%E4%BF%9D/ex4/ class=next rel=next title><i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer>
<div class=footer-container><div class=footer-line>酒困路长惟欲睡，日高人渴漫思茶</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部>
<i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论>
<i class="fas fa-comment fa-fw"></i>
</a>
</div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><script type=text/javascript src=/Notes/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/Notes/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:40},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50}}</script><script type=text/javascript src=/Notes/js/theme.min.js></script></body></html>