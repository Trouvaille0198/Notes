<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=X-UA-Compatible content="IE=edge, chrome=1"><title>对 Python 异步思想的理解 - 伤心肠粉的酱油碟子</title><meta name=author content>
<meta name=author-link content><meta name=description content="对 Python 异步思想的理解 摘自 https://lulaoshi.info/python/asyncio/basics.html 记住 asyncio 是一个事件循环 记住在你不想阻塞其他任务的地方，aw"><meta name=keywords content='Python'><meta itemprop=name content="对 Python 异步思想的理解"><meta itemprop=description content="对 Python 异步思想的理解 摘自 https://lulaoshi.info/python/asyncio/basics.html 记住 asyncio 是一个事件循环 记住在你不想阻塞其他任务的地方，aw"><meta itemprop=dateModified content="2024-04-27T05:32:21+00:00"><meta itemprop=wordCount content="6251"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="Python"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/%E4%B8%93%E4%B8%9A/python/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/"><meta property="og:site_name" content="伤心肠粉的酱油碟子"><meta property="og:title" content="对 Python 异步思想的理解"><meta property="og:description" content="对 Python 异步思想的理解 摘自 https://lulaoshi.info/python/asyncio/basics.html 记住 asyncio 是一个事件循环 记住在你不想阻塞其他任务的地方，aw"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:modified_time" content="2024-04-27T05:32:21+00:00"><meta property="article:tag" content="Python"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="对 Python 异步思想的理解"><meta name=twitter:description content="对 Python 异步思想的理解 摘自 https://lulaoshi.info/python/asyncio/basics.html 记住 asyncio 是一个事件循环 记住在你不想阻塞其他任务的地方，aw"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/%E4%B8%93%E4%B8%9A/python/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/%E9%9F%B3%E4%B9%90/%E4%B8%80%E4%BA%9B%E5%A5%BD%E4%B9%90%E5%8F%A5/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/%E4%B8%93%E4%B8%9A/courses/operating-system/operatingsystem1/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"对 Python 异步思想的理解","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E4%B8%93%E4%B8%9A\/python\/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1\/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3\/"},"genre":"posts","keywords":"Python","wordcount":6251,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/%E4%B8%93%E4%B8%9A\/python\/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1\/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3\/","dateModified":"2024-04-27T05:32:21+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>对 Python 异步思想的理解</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/python/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;Python</a></span></div><div class=post-meta-line><span title="0001-01-01 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=0001-01-01>0001-01-01</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 6251 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 13 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#函数调用-vs-协程调用>函数调用 v.s. 协程调用</a><ul><li><a href=#并行计算>并行计算</a></li><li><a href=#函数-vs-协程>函数 v.s. 协程</a></li><li><a href=#函数调用栈>函数调用栈</a></li><li><a href=#event-loopstaskscoroutines>Event Loops/Tasks/Coroutines</a></li><li><a href=#总结>总结</a></li></ul></li><li><a href=#编写-asyncio-代码>编写 asyncio 代码</a><ul><li><a href=#async-def-关键字>async def 关键字</a><ul><li><a href=#def>def</a></li><li><a href=#async-def>async def</a></li></ul></li><li><a href=#await-与-awaitable>await 与 awaitable</a></li><li><a href=#运行一个协程>运行一个协程</a></li><li><a href=#asynciosleep>asyncio.sleep()</a><ul><li><a href=#timesleep>time.sleep()</a></li><li><a href=#asynciosleep-1>asyncio.sleep()</a></li></ul></li><li><a href=#task>Task</a><ul><li><a href=#没有使用-event-loop>没有使用 Event Loop</a></li><li><a href=#task-与-event-loop>Task 与 Event Loop</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=对-python-异步思想的理解>对 Python 异步思想的理解</h1><blockquote><p>摘自 <a href=https://lulaoshi.info/python/asyncio/basics.html target=_blank rel="external nofollow noopener noreferrer">https://lulaoshi.info/python/asyncio/basics.html</a></p></blockquote><ol><li><p>记住 asyncio 是一个事件循环</p></li><li><p>记住在你不想阻塞其他任务的地方，await</p></li></ol><p>每一次 await，函数会停止执行，但不会返回。他会把执行权交还给事件循环，让其他 async 函数执行。等待下次被重启。</p><h2 id=函数调用-vs-协程调用>函数调用 v.s. 协程调用</h2><h3 id=并行计算>并行计算</h3><p>计算机的 CPU 一次只做一件事。现代计算机配备了多个 CPU 核心，通过多线程（multi-threading）或者多进程（multi-processing）等方式来并行化，以充分利用多核。不同编程语言的实现也稍有不同，其中 Python 使用最多的是 <code>multiprocessing</code> 库。这些库的核心思想是让 Python 代码并行地在多个 CPU 核心上同时执行。</p><p><strong>但 asyncio 并不是传统意义上的多线程或多进程</strong></p><blockquote><p>asyncio 更像是操作系统中<strong>并发</strong>的概念：让多个函数交替占用单个 CPU 运行；</p><p>其他多线 / 进程库则是<strong>并行</strong>的概念：使用多核来同时运行多个函数</p></blockquote><p>使用 asyncio 并不是将代码转换成多线程，它不会导致多条 Python 指令同时执行，也不会以任何方式让你避开所谓的全局解释器锁（Global Interpreter Lock，GIL）</p><blockquote><p>CPU bound v.s. IO bound</p><p>CPU bound：有些应用受 CPU 速度的限制，并不需要频繁IO。很多传统高性能计算应用就是CPU bound的，例如，分子动力学模拟。</p><p>IO bound：有些应用受 IO 速度的限制，即使 CPU 速度再快，也无法充分发挥 CPU 的性能。这些应用花费大量时间从存储或网络设备读写数据，往往需要等待数据到达后才能进行计算，在等待期间，CPU 什么都做不了。大数据和AI就是典型的 IO bound 应用。****</p></blockquote><p>如果应用是 IO bound ，CPU 大量时间什么都做不了，单纯等待其他地方把数据准备好并搬运过来。其实，在 CPU 等待期间其实可以给它安排一些其他工作。 asyncio 的目的就是为了给 CPU 安排更多的工作：当前单线程代码正在等待某个事情发生时，另一段代码可以接管并使用 CPU，以充分利用 CPU 的计算性能。</p><p><strong>asyncio 更多是关于更有效地使用单核，而不是如何使用多核</strong></p><h3 id=函数-vs-协程>函数 v.s. 协程</h3><blockquote><p>许多编程语言使用术语“函数”（Function）或“方法”（Method）或“过程”(Procedure)或“子程序”(Subroutine)来表示可以被其他代码调用的一段代码。一些比较古老的编程语言，比如 Fortran，会使用 Subroutine 这个词，在 Python 中，主要使用“函数”（Function）或“方法”（Method）这两个概念。</p></blockquote><p>大多数编程语言都有所谓的 <strong>“子程序” (Subroutine) 调用模型</strong>。父函数遇到一个子程序，开始调用该函数，进入到该函数的开头，然后一直执行，直到函数的结尾（或遇到 <code>return</code> 语句），返回到调用该函数的地方。所有对该函数的调用都遵循上面的这个流程：进入函数，从头开始，直到 <code>return</code> 结尾，返回父函数调用处。这种调用模型我们再熟悉不过了。</p><p>此外，还有另一种代码执行模型，称为 <strong>“协程”（Coroutine）调用模型</strong>。在这个调用模型中，被调用者可以 “<strong>让出</strong>” 控制权而不是运行完之后把整个函数都返回。当这个被调用的协程 “让出” 控制权时，调用他的父函数会立即返回到当初调用协程的的位置。但未来再次调用协程时，不会从头开始，而是从上一次该协程执行停止的地方继续执行。控制权在父函数和协程之间来回跳转，如下图所示：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-subroutines-coroutines.png data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-subroutines-coroutines.png, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-subroutines-coroutines.png 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-subroutines-coroutines.png 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-subroutines-coroutines.png title="Subroutines v.s. Coroutines"></p><p>在 Python 中就是 yield 语法了</p><h3 id=函数调用栈>函数调用栈</h3><p>继续深入探究函数调用，大多数操作系统和编程语言都使用一种称为“调用栈”的抽象。调用栈是一个堆栈数据结构。</p><p>为了说明这一点，下面使用一段简单的 Python 代码来演示：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>a_func</span><span class=p>(</span><span class=n>x</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span><span class=o>-</span><span class=mi>2</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>some_value</span> <span class=o>=</span> <span class=mi>12</span>
</span></span><span class=line><span class=cl>    <span class=n>some_other_value</span> <span class=o>=</span> <span class=n>a_func</span><span class=p>(</span><span class=n>some_value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>main</span><span class=p>()</span>
</span></span></code></pre></td></tr></table></div></div><p>当我们开始执行这段代码时，堆栈被初始化为内存中一个后进先出 (Last In First Out) 存储区，整个函数从最后一行 <code>main()</code> 开始执行。</p><p>假设我们对这段 Python 代码进行了编译，得到下面这个编译后的代码段。每行有一个行号，用来记录程序运行到哪一行。同时有一个名为指令指针（Instruction Pointer，IP）的指针，指向下一步将要运行哪一行代码。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack0.svg data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack0.svg, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack0.svg 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack0.svg 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack0.svg title="程序刚开始：执行 main() 函数"></p><p>由于 <code>main()</code> 函数本身就是一个函数调用，Python 解释器会调用 <code>main()</code> 函数：</p><ul><li>Python 解释器将一个新的“<strong>栈帧</strong>”添加到堆栈的顶部。栈帧是一个数据结构，是为这个函数调用单独分配的栈空间。</li><li>Python 解释器在栈帧的栈顶添加了一个“返回指针”（Return Point）。这是一个地址，它告诉解释器，当函数返回时，回到哪一行。</li><li>Python 解释器根据 Instruction Pointer 中存的地址确定下一行将要执行什么。</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack1.svg data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack1.svg, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack1.svg 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack1.svg 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack1.svg title="程序进入 main() 函数，开始执行 main() 函数中的内容"></p><p>下一条指令：<code>some_value = 12</code> 创建了一个局部变量，这个局部变量仅存在于这个 <code>main()</code> 函数的上下文，一旦离开 <code>main()</code> 函数，<code>some_value</code> 就不存在了。因此，局部变量 <code>some_value</code> 存储在 <code>main()</code> 栈帧中。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack2.svg data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack2.svg, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack2.svg 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack2.svg 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack2.svg title="执行 some_value = 12，在栈帧内创建局部变量"></p><p>下一条指令： <code>some_other_value = a_func(some_value)</code>。这又是一个函数调用，Python 解释器继续进行函数调用：</p><ul><li>它将一个新栈帧添加到堆栈的顶部。</li><li>它添加了一个 Return Point，该指针指向 04。</li><li>这个函数调用传递了参数，参数被放置在栈帧的顶部（x = 12）。</li><li>Instruction Pointer 设置为 01，<code>a_func</code> 是下一条要执行的指令。</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack3.svg data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack3.svg, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack3.svg 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack3.svg 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack3.svg title="执行 some_other_value = a_func(some_value)，进行函数调用"></p><p>下一条要执行的指令是 <code>return x-2</code> ，这里面有 <code>return</code> ，Python 解释器执行从函数返回的过程。</p><ul><li>它从堆栈中删除顶部栈帧，包括其中的所有内容。</li><li>它将函数的返回值放在栈顶。</li><li>Instruction Pointer 设置为 04，即刚刚记录的 Return Point。</li></ul><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack4.svg data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack4.svg, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack4.svg 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack4.svg 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-stack4.svg title="执行 return x-2，从 a_func() 返回到 main()"></p><p>几乎所有编程语言的函数调用都遵循这种模式。多线程跟这种方式也很像，只不过每个线程都有一个单独的堆栈，除此之外几乎完全相同。</p><p>然而，说了这么多，都是关于传统的函数调用的。asyncio 的原理跟这种函数调用有很大不同。</p><h3 id=event-loopstaskscoroutines>Event Loops/Tasks/Coroutines</h3><p>在 asyncio 中，每个线程不再只有一个堆栈。相反，每个线程都有一个被称为事件循环（Event Loop）的对象。Event Loop 中包含一个任务（Task）对象列表。每个 Task 维护一个堆栈，以及它自己的 Instruction Pointer。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-eventloop.svg data-srcset="http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-eventloop.svg, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-eventloop.svg 1.5x, http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-eventloop.svg 2x" data-sizes=auto alt=http://aixingqiu-1258949597.cos.ap-beijing.myqcloud.com/2023-05-03-eventloop.svg title="Event Loop 有多个 Task，每个 Task 维护一个堆栈"></p><p>在任意时刻，Event Loop 只能有一个 Task 实际执行，毕竟 CPU 在某一时刻只能做一件事，Event Loop 中的其他任务都暂停了。当前正在执行的 Task 跟我们经常使用的函数调用的 Python 程序一模一样。唯一区别在于，遇到需要等待的事情时接下来的处理方式，即当 Task 遇到需要等待的事情，比如 IO bound 应用需要等待数据到达。</p><p>此时，Task 中的代码不再等待，而是让出控制权。Event Loop 暂停正在运行的 Task。未来的某个时刻，当这个 Task 所等待的事情已经成熟，Event Loop 将再次唤醒这个 Task。</p><p>Task 让出控制权后，Event Loop 唤醒某个休眠的 Task，并将这个新唤醒的 Task 设置为当前执行的 Task。有一种可能，所有 Task 都无法被唤醒，因为所有 Task 都在等待自己所依赖的事情发生，那么 Event Loop 和所有 Task 一起等待。</p><p>通过这种方式，CPU 可以被不同的 Task 共享。Task 或者在执行自己的代码，或者在休眠，休眠期间等待自己所依赖的事情。</p><blockquote><p>Event Loop 不能中断正在执行的协程。</p><p>Event Loop 不能强制中断当前正在执行的协程。当前正在执行的协程将继续执行，直到它让出控制权（比如 yield）。Event Loop 选择下一个被调度的协程，并跟踪这些协程的状态，例如哪些协程被阻塞且无法执行，直到某些 IO 完成。Event Loop 仅在当前没有协程正在执行时才执行去做这些跟踪状态的工作。</p></blockquote><p>控制权在不同 Task 之间来回切换，下次唤醒 Task 时正好在上次停止的地方继续执行。这种方式被称为“协程调用”（Coroutine Calling）。这就是 Python asyncio 所提供的功能，它使得 CPU 闲置的时间更少。</p><p>这种调用方法适用于 IO bound 应用，在这类应用中，长时间的暂停是为了等待其他事情，比如某个应用请求一个 HTTP 网页，需要等待网页内容返回后才能进行下面的操作。有关 HTTP 或其他互联网流量的处理任务几乎都是 IO bound 的。</p><h3 id=总结>总结</h3><ul><li>异步（Asynchronous）编程：与传统的同步（Synchronous）编程相对应<ul><li>同步编程就是传统的函数调用的方式</li><li>异步编程不需要等待事情完成，而是把控制权让出。</li></ul></li><li>协程（Coroutine）：异步编程中的某个函数体。</li><li>Event Loop：管理和控制协程。</li><li>Task：某个可运行的任务。</li></ul><h2 id=编写-asyncio-代码>编写 asyncio 代码</h2><h3 id=async-def-关键字>async def 关键字</h3><p><code>async def</code> 是 asyncio 异步编程中最关键的关键字，它用来<strong>声明一个异步协程函数</strong>，就像用 <code>def</code> 定义一个普通的同步函数一样。</p><blockquote><p>可以认为 async def 共同组成一个关键字</p><p>可以认为 <code>async def</code> 共同组成一个关键字。实际上， <code>async</code> 本身是一个关键字，但我们并不能单独使用 <code>async</code> 。所以，可以简单认为 <code>async def</code> 组合在一起，共同组成一个关键字。同样， <code>async for</code> 和 <code>async with</code> 也是两个单词共同组成的关键字。</p></blockquote><p>下面的例子中我们定义了一个协程函数 <code>example_coroutine_function</code> 和一个普通函数 <code>example_function</code>。 <code>example_function</code> 的代码块是普通的同步 Python 代码，而<code>example_coroutine_function</code> 的代码块是异步 Python 代码，又被称为协程。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>example_coroutine_function</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 异步代码</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>example_function</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># 同步代码</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><blockquote><p>提示</p><ul><li>我们<strong>只</strong>能在 <code>async def</code> 定义的协程函数体内编写异步 Python 代码。</li><li>异步 Python 代码可以使用普通 Python 中允许的任何 Python 关键字、结构等。</li><li>有几个只能在异步代码中使用的新关键字：<code>await</code>、<code>async with</code> 和 <code>async for</code>。</li></ul></blockquote><p>使用 <code>async def</code> 定义一个协程函数，这看起来与使用 <code>def</code> 的普通函数声明非常相似。大多数时候确实非常相似，但是有一些关键的区别，这对于异步编程非常重要：</p><h4 id=def>def</h4><p><code>def</code> 定义一个同步函数，函数本身是一个 <code>Callable</code> 对象，调用这个函数的时候，函数体内的代码被执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>example_function</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p><code>example_function</code> 是一个 <code>Callable</code> 对象实例，这个函数接收 3 个参数，像这样调用它：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>example_function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>调用之后，<code>example_function</code> 会被立即执行，返回值会被赋值给 <code>r</code> 。</p><h4 id=async-def>async def</h4><p><code>async def</code> 关键字也定义了一个 <code>Callable</code> 对象实例，但当我们调用这个函数时，函数体内代码<strong>不是</strong>立即执行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>example_coroutine_function</span><span class=p>(</span><span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>c</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=o>...</span>
</span></span></code></pre></td></tr></table></div></div><p>跟 <code>example_function</code> 类似，<code>example_coroutine_function</code> 也是一个 <code>Callable</code> 对象实例，它接受 3 个参数，通过下面的方式调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>example_coroutine_function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>但执行这行之后<strong>不会</strong>直接运行函数体内的代码块。相反，Python 创建了一个 <code>Coroutine</code> 对象实例，并将其分配给 <code>r</code>。要使代码块实际运行，需要使用 asyncio 提供的其他工具。最常见的是 <code>await</code> 关键字。接下来我们开始讨论 <code>await</code>。</p><h3 id=await-与-awaitable>await 与 awaitable</h3><p><code>await</code> 是 asyncio 的最为核心的关键字之一。</p><ul><li>它只能在异步代码块中使用，即在 <code>async def</code> 语句定义的协程代码块中。</li><li>它有一个参数，并且有一个返回值。</li></ul><p>例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>r</span> <span class=o>=</span> <span class=n>example_coroutine_function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=k>await</span> <span class=n>r</span>
</span></span></code></pre></td></tr></table></div></div><p>上面这行代码中，<code>r</code> 是一个 awaitable 对象。它用 <code>r = example_coroutine_function(1, 2, 3)</code> 定义。 执行 <code>s = await r</code> 这行代码，就将对 <code>r</code> 执行 <code>await</code> 操作并将返回值赋值给 <code>s</code>。</p><p>awaitable 对象，从名字中可以看出，这种对象是<strong>可以被等待</strong>的。</p><p>将刚才例子的两行整合成一行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>s</span> <span class=o>=</span> <span class=k>await</span> <span class=n>example_coroutine_function</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>一个 <code>async def</code> + <code>await</code> 的完整的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>add</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>x</span> <span class=o>+</span> <span class=n>y</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>get_results</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=c1># 直接 print(add(3, 4)) 得到的是一个 coroutine object</span>
</span></span><span class=line><span class=cl>    <span class=c1># 这个 coroutine object 是 awaitable 的</span>
</span></span><span class=line><span class=cl>    <span class=c1># 而且还会提示：RuntimeWarning: coroutine &#39;add&#39; was never awaited</span>
</span></span><span class=line><span class=cl>    <span class=c1># 因为这个 awaitable 从来没被 await</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1># 打印出结果为 7</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=k>await</span> <span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>res1</span> <span class=o>=</span> <span class=k>await</span> <span class=n>add</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>res2</span> <span class=o>=</span> <span class=k>await</span> <span class=n>add</span><span class=p>(</span><span class=mi>8</span><span class=p>,</span> <span class=mi>5</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># 打印出结果为 7 13</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>res1</span><span class=p>,</span> <span class=n>res2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>get_results</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><p>可以看到 <code>await</code> 在 <code>async def</code> 定义的协程 <code>get_results()</code> 里。直接 <code>print(add(3, 4))</code> 得到的是一个 Coroutine 对象，这个 coroutine 对象是 awaitable 可等待的。而且还会提示：RuntimeWarning: coroutine &lsquo;add&rsquo; was never awaited，因为这个 awaitable 对象从来没被 await。 <code>print(await add(3, 4))</code> 可以打印出结果，先 <code>await</code> ，才能得到结果。</p><p>换个角度思考，**<code>await</code> 一个 coroutine object，有点像主动去调用一个传统意义上的同步函数。**这个 coroutine 对象里的代码段包含了异步的代码。</p><p>我们有说过，异步代码是以 Task 的形式去运行、被 Event Loop 管理和调度的，Task 可以被暂停和恢复，每个 Task 有自己调用栈。所以，虽然调用一个同步函数和 <code>await</code> 一个 coroutine 对象有点像，但是 coroutine 对象中的异步代码是可以被暂停和恢复的。这也是同步函数和异步函数的重要区别。</p><p>一共有三种可以被 <code>await</code> 的对象：</p><ul><li><p>coroutine 对象</p><ul><li>前面多个例子中的 <code>await r</code>， <code>r</code> 是一个 coroutine 对象。</li></ul></li><li><p><code>asyncio.Future</code> 类对象</p><ul><li>如果 <code>await</code> 一个 <code>asyncio.Future</code> 对象，则当前 Task 被暂停。下文提到的 <code>asyncio.Task</code> 是一种继承了 <code>asyncio.Future</code> 的类。或者说，<code>asyncio.Future</code> 是提供了底层的 awaitable 接口。下文用 <code>Task</code> 指代 <code>asyncio.Task</code>，用 <code>Future</code> 指代 <code>asyncio.Future</code>。</li></ul></li><li><p>实现了 <code>__await__</code> 方法的类和对象</p><ul><li>这种方法给一些包开发者提供了接口，开发者可以自己定义一些 awaitable 的类。</li></ul></li></ul><h3 id=运行一个协程>运行一个协程</h3><p>刚才提到，<code>async def</code> 定义一个协程，协程跟普通函数区别是不会直接运行，如果想运行这个协程，可以使用 <code>asyncio.run</code></p><p>用 <code>asyncio.run</code> 作为整个异步函数的入口。比如:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>await</code> coroutine 对象。</li></ul><p>之前提到的类似的例子：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>hello</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>coro</span> <span class=o>=</span> <span class=n>hello</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span> <span class=o>=</span> <span class=k>await</span> <span class=n>coro</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>h</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><ul><li><code>asyncio.create_task()</code>，创建一个 <code>Task</code> 对象实例，<code>Task</code> 对象实例立即被运行。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>hello</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;async function called&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;hello&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span><span class=n>hello</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>h</span> <span class=o>=</span> <span class=k>await</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>h</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这里的三个场景，第二种 <code>await</code> 的方式和第三种 <code>asyncio.create_task()</code> 看不出明显区别。我们需要加一个 <code>asyncio.sleep()</code> 可能才能看出一些区别。</p><h3 id=asynciosleep>asyncio.sleep()</h3><p><code>asyncio.sleep()</code> 和 <code>time.sleep()</code> 很像。<code>asyncio.sleep()</code> 是 <code>asyncio</code> 库专用的，它跟其他协程函数一样，是<strong>异步</strong>的，或者说是<strong>非阻塞</strong>的。与之对应，<code>time.sleep()</code> 是<strong>同步</strong>的，或者说是<strong>阻塞</strong>的。</p><p>当 <code>time.sleep()</code> 被调用，整个程序都会暂停，什么都做不了。</p><p>当 <code>await asyncio.sleep()</code> 被调用，如果使用了 Event Loop，Event Loop 会将当前的 <code>asyncio.sleep()</code> 的协程暂停，Event Loop 去找其他可以被唤醒的 <code>Task</code>，先执行其他 <code>Task</code> 。当刚刚这个 <code>asyncio.sleep()</code> 满足了睡眠时间，Event Loop 把这个协程唤醒。</p><p>但在协程的场景，确实不容易理解这两种不同的 <code>sleep</code> 到底发生有什么区别。</p><p>下面用几个例子来演示 <code>asyncio.sleep()</code> 。</p><h4 id=timesleep>time.sleep()</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>call_api</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Hello&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>time</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;World&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=n>call_api</span><span class=p>(),</span> <span class=n>call_api</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;It took </span><span class=si>{</span><span class=n>end</span><span class=o>-</span><span class=n>start</span><span class=si>}</span><span class=s1> second(s) to complete.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><p>得到的结果是：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>It took 6.006464317906648 second(s) to complete.
</span></span></code></pre></td></tr></table></div></div><p>如果使用 <code>time.sleep()</code> ：先打印 Hello，等待 3 秒，再打印 World。一共执行了两次 <code>call_api()</code> ，两次 <code>call_api()</code> 都是相互阻塞，执行一共需要 6 秒多。</p><p><code>call_api()</code> 内部经历了下面的过程：</p><ul><li><code>print()</code></li><li>休眠几秒</li><li>继续执行 <code>return result</code></li></ul><h4 id=asynciosleep-1>asyncio.sleep()</h4><p>如果使用 <code>asyncio.sleep()</code>：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>call_api</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;Hello&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;World&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>gather</span><span class=p>(</span><span class=n>call_api</span><span class=p>(),</span> <span class=n>call_api</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;It took </span><span class=si>{</span><span class=n>end</span><span class=o>-</span><span class=n>start</span><span class=si>}</span><span class=s1> second(s) to complete.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><p>输出结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>It took 3.003517189063132 second(s) to complete.
</span></span></code></pre></td></tr></table></div></div><p>改成 <code>asyncio.sleep()</code> 后：两次的 Hello 被马上打印出来，说明 <code>asyncio.sleep()</code> 没有阻塞程序执行，而是让多个协程并发执行，整个程序的总时间也仅用了 3 秒多。</p><p>两次 <code>call_api()</code> 和 <code>main</code> 内部经历了下面的过程：</p><ul><li>第一个 <code>call_api()</code> 调用 <code>print()</code></li><li>第一个进入休眠状态，Event Loop 唤醒第二个 <code>call_api()</code></li></ul><p>在这里用了 <code>asyncio.gather()</code> 的 API，它可以并发地运行协程，或者说<strong>它可以将协程调度为 Task</strong>。下面重点说说如何让协程调度为 Task。</p><h3 id=task>Task</h3><h4 id=没有使用-event-loop>没有使用 Event Loop</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>call_api</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>call_api</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>call_api</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;It took </span><span class=si>{</span><span class=n>end</span><span class=o>-</span><span class=n>start</span><span class=si>}</span><span class=s1> second(s) to complete.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div><p>输出结果：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>It took 6.005615991074592 second(s) to complete.
</span></span></code></pre></td></tr></table></div></div><p>在这个例子中，直接创建了协程并通过 <code>await</code> 来等待协程执行结果，结果显示这个程序和普通的同步函数没有任何区别。主要原因是：这里其实没有将协程放到 Event Loop 中。或者说，虽然这里使用了 <code>async def</code> 和 <code>await</code> 关键字编写了异步的代码，但是依然像同步函数那样执行。</p><h4 id=task-与-event-loop>Task 与 Event Loop</h4><p>异步程序与同步程序的区别在于：程序以 <code>Task</code> 的形式放到 Event Loop 中，Event Loop 管理多个 <code>Task</code>，唤醒某个 <code>Task</code> 或者暂停某个 <code>Task</code> 。</p><p>如何创建一个 <code>Task</code>，并将这个 <code>Task</code> 放到 Event Loop ？答案是用 <code>asyncio.create_task()</code> 。<code>asyncio.create_task()</code> 是一个比较直观的 API，其他的还有 <code>asyncio.gather()</code> 等。</p><p>把刚才的程序做一个简单的修改，<code>call_api()</code> 不变，只不过调用 <code>call_api()</code> 的方式变为使用 <code>asyncio.create_task()</code>。</p><p>输出结果为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>Hello
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>World
</span></span><span class=line><span class=cl>It took 3.0035055382177234 second(s) to complete.
</span></span></code></pre></td></tr></table></div></div><p>两次 Hello 几乎同时被打印出来，说明 <code>call_api()</code> 非阻塞执行。</p><p>在这个程序中，两个关键点：</p><ul><li><p><code>task = asyncio.create_task()</code> 创建协程</p><ul><li><code>asyncio.create_task()</code> 将协程函数创建为 <code>Task</code>，函数的返回值是一个 <code>Task</code> 对象，所创建的 <code>Task</code> 被放到了 Event Loop 中。</li></ul></li><li><p><code>await task</code> 等待 <code>Task</code> 执行结束</p><ul><li>如果不 <code>await task</code>，我们只看到了开头的 Hello，看不到结尾的 World。程序还没执行完，就退出了。</li></ul></li></ul><p>这里本质上是等待 <code>Task</code> 的 <code>done()</code> 方法返回 <code>True</code>。返回 <code>True</code> 说明 <code>Task</code> 执行结束。使用 <code>done()</code> 来判断 <code>Task</code> 是否结束的程序：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>asyncio</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>call_api</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>await</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>sleep</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=s2>&#34;World&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>async</span> <span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>start</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>task_1</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>call_api</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>task_2</span> <span class=o>=</span> <span class=n>asyncio</span><span class=o>.</span><span class=n>create_task</span><span class=p>(</span>
</span></span><span class=line><span class=cl>        <span class=n>call_api</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tasks</span> <span class=o>=</span> <span class=p>[</span><span class=n>task_1</span><span class=p>,</span> <span class=n>task_2</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=kc>True</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1># 检查所有 tasks 中哪些还没结束</span>
</span></span><span class=line><span class=cl>        <span class=n>tasks</span> <span class=o>=</span> <span class=p>[</span><span class=n>t</span> <span class=k>for</span> <span class=n>t</span> <span class=ow>in</span> <span class=n>tasks</span> <span class=k>if</span> <span class=ow>not</span> <span class=n>t</span><span class=o>.</span><span class=n>done</span><span class=p>()]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=nb>len</span><span class=p>(</span><span class=n>tasks</span><span class=p>)</span> <span class=o>==</span> <span class=mi>0</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=c1># 所有 tasks 都结束，tasks 数组为空，程序可以结束</span>
</span></span><span class=line><span class=cl>            <span class=n>end</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>perf_counter</span><span class=p>()</span>
</span></span><span class=line><span class=cl>            <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;It took </span><span class=si>{</span><span class=n>end</span><span class=o>-</span><span class=n>start</span><span class=si>}</span><span class=s1> second(s) to complete.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=c1># tasks 中有还没结束的 Task，使用 await 等待</span>
</span></span><span class=line><span class=cl>        <span class=k>await</span> <span class=n>tasks</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>asyncio</span><span class=o>.</span><span class=n>run</span><span class=p>(</span><span class=n>main</span><span class=p>())</span>
</span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2024-04-27 05:32:21">更新于 2024-04-27</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/%E4%B8%93%E4%B8%9A/python/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/ data-title="对 Python 异步思想的理解" data-hashtags=Python><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/%E4%B8%93%E4%B8%9A/python/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/ data-hashtag=Python><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/%E4%B8%93%E4%B8%9A/python/%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/%E5%AF%B9-python-%E5%BC%82%E6%AD%A5%E6%80%9D%E6%83%B3%E7%9A%84%E7%90%86%E8%A7%A3/ data-title="对 Python 异步思想的理解"><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/python/>Python</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/%E9%9F%B3%E4%B9%90/%E4%B8%80%E4%BA%9B%E5%A5%BD%E4%B9%90%E5%8F%A5/ class=prev rel=prev title=一些好乐句><i class="fa-solid fa-angle-left fa-fw"></i>一些好乐句</a>
<a href=/Notes/posts/%E4%B8%93%E4%B8%9A/courses/operating-system/operatingsystem1/ class=next rel=next title=操作系统（1）>操作系统（1）<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2024</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"7I9AMOLA4S",algoliaIndex:"Notes",algoliaSearchKey:"3c1638dfe9f4d49a59d81ff6943416b8",highlightTag:"em",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>