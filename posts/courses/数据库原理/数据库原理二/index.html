<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>数据库原理（2） - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="数据库原理二 第五章 规范化设计 关系模式的设计问题 关系模式的外延和内涵 一个关系模型包"><meta name=keywords content="数据库"><meta itemprop=name content="数据库原理（2）"><meta itemprop=description content="数据库原理二 第五章 规范化设计 关系模式的设计问题 关系模式的外延和内涵 一个关系模型包"><meta itemprop=datePublished content="2022-02-25T00:00:00+00:00"><meta itemprop=dateModified content="2023-04-24T13:06:13+00:00"><meta itemprop=wordCount content="14611"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="数据库,"><meta property="og:title" content="数据库原理（2）"><meta property="og:description" content="数据库原理二 第五章 规范化设计 关系模式的设计问题 关系模式的外延和内涵 一个关系模型包"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-25T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-24T13:06:13+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="数据库原理（2）"><meta name=twitter:description content="数据库原理二 第五章 规范化设计 关系模式的设计问题 关系模式的外延和内涵 一个关系模型包"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/useful/%E9%85%8D%E7%BD%AE-typora/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据库原理（2）","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/courses\/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86\/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C\/"},"genre":"posts","keywords":"数据库","wordcount":14611,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/courses\/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86\/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C\/","datePublished":"2022-02-25T00:00:00+00:00","dateModified":"2023-04-24T13:06:13+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>数据库原理（2）</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;专业课</a></span></div><div class=post-meta-line><span title="2022-02-25 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-02-25>2022-02-25</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 14611 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 30 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#第五章-规范化设计>第五章 规范化设计</a><ul><li><a href=#关系模式的设计问题>关系模式的设计问题</a><ul><li><a href=#关系模式的外延和内涵>关系模式的外延和内涵</a></li><li><a href=#泛关系模式与数据库模式>泛关系模式与数据库模式</a></li><li><a href=#关系模式的冗余和异常问题>关系模式的冗余和异常问题</a></li></ul></li><li><a href=#函数依赖>函数依赖</a><ul><li><a href=#函数依赖-fd-的定义>函数依赖 FD 的定义</a><ul><li><a href=#例>例</a></li></ul></li><li><a href=#fd-的逻辑蕴涵函数依赖集-f-的闭包>FD 的逻辑蕴涵、函数依赖集 F 的闭包</a></li><li><a href=#函数依赖的推理规则>函数依赖的推理规则</a><ul><li><a href=#armstrong-公理系统>Armstrong 公理系统</a></li><li><a href=#另外三个推理规则>另外三个推理规则</a></li></ul></li><li><a href=#fd-与关键码的联系>FD 与关键码的联系</a><ul><li><a href=#找候选键的方法>找候选键的方法</a></li></ul></li><li><a href=#属性集的闭包>属性集的闭包</a><ul><li><a href=#求属性集的闭包>求属性集的闭包</a></li></ul></li><li><a href=#fd-的最小依赖集>FD 的最小依赖集</a><ul><li><a href=#函数依赖集的等价>函数依赖集的等价</a></li><li><a href=#最小函数依赖集>最小函数依赖集</a></li><li><a href=#例-1>例</a></li></ul></li></ul></li><li><a href=#关系模式的分解特性>关系模式的分解特性</a><ul><li><a href=#模式分解问题>模式分解问题</a><ul><li><a href=#投影>投影</a></li><li><a href=#无损连接性与函数依赖保持性>无损连接性与函数依赖保持性</a></li></ul></li><li><a href=#无损分解>无损分解</a></li><li><a href=#无损分解的测试方法>无损分解的测试方法</a><ul><li><a href=#第二种方法>第二种方法</a></li></ul></li><li><a href=#保持函数依赖的分解>保持函数依赖的分解</a></li></ul></li><li><a href=#关系模式的范式>关系模式的范式</a><ul><li><a href=#第一范式-1nf>第一范式 1NF</a><ul><li><a href=#反例>反例</a></li><li><a href=#定义>定义</a></li><li><a href=#修改后的例子>修改后的例子</a></li></ul></li><li><a href=#第二范式-2nf>第二范式 2NF</a><ul><li><a href=#定义-1>定义</a></li></ul></li><li><a href=#第三-范式-3nf>第三-范式 3NF</a><ul><li><a href=#例-2>例</a></li></ul></li><li><a href=#巴克斯范式-bcnf>巴克斯范式 BCNF</a></li><li><a href=#分解成-bcnf-模式集的方法>分解成 BCNF 模式集的方法</a></li><li><a href=#分解成-3nf-模式集的方法>分解成 3NF 模式集的方法</a><ul><li><a href=#算法一>算法一</a></li><li><a href=#算法二>算法二</a></li></ul></li></ul></li></ul></li><li><a href=#第七章-数据库设计>第七章 数据库设计</a><ul><li><a href=#数据库设计概述>数据库设计概述</a><ul><li><a href=#软件生存期>软件生存期</a></li><li><a href=#数据库系统生存期>数据库系统生存期</a><ul><li><a href=#七个阶段>七个阶段</a></li></ul></li></ul></li><li><a href=#规划>规划</a><ul><li><a href=#规划阶段完成的任务>规划阶段完成的任务</a></li><li><a href=#可行性分析报告>可行性分析报告</a></li></ul></li><li><a href=#需求分析>需求分析</a><ul><li><a href=#需求描述与分析>需求描述与分析</a></li><li><a href=#需求分析阶段的输入和输出>需求分析阶段的输入和输出</a></li><li><a href=#需求分析的步骤>需求分析的步骤</a></li></ul></li><li><a href=#概念设计>概念设计</a><ul><li><a href=#概念设计的必要性>概念设计的必要性</a></li><li><a href=#概念模型>概念模型</a></li><li><a href=#概念设计的主要步骤>概念设计的主要步骤</a></li><li><a href=#数据抽象>数据抽象</a></li><li><a href=#er-模型的操作>ER 模型的操作</a><ul><li><a href=#实体类型的分裂>实体类型的分裂</a></li><li><a href=#实体类型的合并>实体类型的合并</a></li><li><a href=#联系类型的分裂>联系类型的分裂</a></li><li><a href=#联系类型的合并>联系类型的合并</a></li></ul></li><li><a href=#采用-er-方法的数据概念设计>采用 ER 方法的数据概念设计</a></li></ul></li><li><a href=#逻辑设计>逻辑设计</a><ul><li><a href=#逻辑设计环境>逻辑设计环境</a></li><li><a href=#逻辑设计的步骤>逻辑设计的步骤</a></li><li><a href=#er-模型象关系模型的转换>ER 模型象关系模型的转换</a></li><li><a href=#关系数据库的逻辑设计>关系数据库的逻辑设计</a></li></ul></li><li><a href=#物理设计>物理设计</a></li><li><a href=#数据库的实现>数据库的实现</a></li><li><a href=#数据库的运行和维护>数据库的运行和维护</a></li></ul></li><li><a href=#第八章-数据库管理>第八章 数据库管理</a><ul><li><a href=#事务的概念>事务的概念</a><ul><li><a href=#事务的定义>事务的定义</a></li><li><a href=#事务的性质acid>事务的性质（ACID）</a></li><li><a href=#事物的状态变迁>事物的状态变迁</a></li></ul></li><li><a href=#数据库的恢复>数据库的恢复</a><ul><li><a href=#数据库恢复的定义>数据库恢复的定义</a></li><li><a href=#数据库恢复的基本原则和实现方法>数据库恢复的基本原则和实现方法</a></li><li><a href=#故障类型>故障类型</a></li><li><a href=#恢复方法>恢复方法</a><ul><li><a href=#事务故障的恢复>事务故障的恢复</a></li><li><a href=#系统故障的恢复>系统故障的恢复</a></li><li><a href=#介质故障的恢复>介质故障的恢复</a></li></ul></li><li><a href=#检查点机制>检查点机制</a><ul><li><a href=#检查点方法>检查点方法</a></li><li><a href=#检查点恢复步骤->检查点恢复步骤 ✔️</a></li></ul></li><li><a href=#运行记录优先原则>运行记录优先原则</a></li></ul></li><li><a href=#数据库的并发控制>数据库的并发控制</a><ul><li><a href=#并发操作带来三个问题>并发操作带来三个问题</a><ul><li><a href=#丢失更新>丢失更新</a></li><li><a href=#不一致分析>不一致分析</a></li><li><a href=#读脏数据>读“脏”数据</a></li></ul></li><li><a href=#封锁机制>封锁机制</a><ul><li><a href=#排它型封锁>排它型封锁</a></li><li><a href=#共享型封锁>共享型封锁</a></li></ul></li><li><a href=#活锁和死锁>活锁和死锁</a><ul><li><a href=#活锁>活锁</a></li><li><a href=#饿死>饿死</a></li><li><a href=#死锁>死锁</a></li></ul></li><li><a href=#并发事务的可串行化调度>并发事务的可串行化调度</a><ul><li><a href=#事务的调度串行调度和并发调度>事务的调度、串行调度和并发调度</a></li><li><a href=#可串行化与两端封锁协议>可串行化与两端封锁协议</a></li></ul></li><li><a href=#sql-中事务的存取模式和隔离级别>SQL 中事务的存取模式和隔离级别</a></li></ul></li><li><a href=#数据库的完整性>数据库的完整性</a><ul><li><a href=#完整性子系统和完整性规则>完整性子系统和完整性规则</a><ul><li><a href=#定义-2>定义</a></li><li><a href=#完整性规则的组成>完整性规则的组成</a></li></ul></li><li><a href=#sql-中的完整性约束>SQL 中的完整性约束</a><ul><li><a href=#域约束>域约束</a></li><li><a href=#基本表约束>基本表约束</a></li><li><a href=#断言>断言</a></li></ul></li><li><a href=#sql3-的触发器>SQL3 的触发器</a><ul><li><a href=#实例>实例</a><ul><li><a href=#一>一</a></li><li><a href=#二>二</a></li></ul></li></ul></li><li><a href=#sql-server-的数据库完整性及实现方法>SQL Server 的数据库完整性及实现方法</a></li></ul></li><li><a href=#数据库的安全性>数据库的安全性</a><ul><li><a href=#安全性级别>安全性级别</a></li><li><a href=#权限>权限</a></li><li><a href=#安全性和授权>安全性和授权</a></li><li><a href=#数据加密>数据加密</a></li><li><a href=#自然环境的安全性>自然环境的安全性</a></li></ul></li></ul></li><li><a href=#对象关系数据库>对象关系数据库</a><ul><li><a href=#db-技术发展过程>DB 技术发展过程</a><ul><li><a href=#数据模型的演变过程>数据模型的演变过程</a></li><li><a href=#查询语言的演变>查询语言的演变</a></li><li><a href=#概念建模的演变>概念建模的演变</a></li></ul></li><li><a href=#对象联系图>对象联系图</a><ul><li><a href=#三种模型的表示>三种模型的表示</a></li><li><a href=#嵌套的关系结构描述>嵌套的关系结构描述</a></li><li><a href=#引用类型>引用类型</a></li><li><a href=#对象联系图的成分>对象联系图的成分</a></li><li><a href=#数据的泛化--细化>数据的泛化 / 细化</a></li></ul></li><li><a href=#面向对象的数据类型>面向对象的数据类型</a><ul><li><a href=#基本类型>基本类型</a></li><li><a href=#复合类型>复合类型</a></li><li><a href=#引用类型-1>引用类型</a></li></ul></li><li><a href=#ordb-的定义语言>ORDB 的定义语言</a><ul><li><a href=#ordb>ORDB</a></li><li><a href=#数据类型>数据类型</a></li><li><a href=#继承性>继承性</a><ul><li><a href=#类型级的继承性>类型级的继承性</a></li><li><a href=#表级的继承性>表级的继承性</a></li></ul></li><li><a href=#引用类型-2>引用类型</a></li></ul></li><li><a href=#ordb-的查询语言>ORDB 的查询语言</a><ul><li><a href=#select-语句>SELECT 语句</a></li><li><a href=#嵌套与解除嵌套>嵌套与解除嵌套</a></li><li><a href=#函数的定义和使用>函数的定义和使用</a></li><li><a href=#复合值的创建和查询>复合值的创建和查询</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=数据库原理二>数据库原理二</h1><h2 id=第五章-规范化设计>第五章 规范化设计</h2><h3 id=关系模式的设计问题>关系模式的设计问题</h3><h4 id=关系模式的外延和内涵>关系模式的外延和内涵</h4><p>一个关系模型包括外延和内涵两个方面的内容。</p><ul><li><p>外延：关系、表或当前值。</p></li><li><p>内涵：对数据的定义以及对数据完整性约束的定义。</p></li></ul><h4 id=泛关系模式与数据库模式>泛关系模式与数据库模式</h4><p>(泛) 关系模式 R(U)</p><ul><li>R：关系名字</li><li>U：所有属性的全集</li><li>泛关系模式：所有属性组成的关系模式 R(U)</li><li>泛关系：当前值 r</li><li>数据库：$R_i$ 的实例</li></ul><p>实际使用时，用一个关系模式的集合 $\rho = { R_1,\dots,R_k}$ 来代替 R(U)，其中 $R_1 ∪ R_2 ∪··· ∪R_n = R(U)$，$\rho$ 称为<strong>数据库模式</strong>。</p><h4 id=关系模式的冗余和异常问题>关系模式的冗余和异常问题</h4><p><strong>数据冗余</strong>：同一个数据重复存储多次。</p><p><strong>操作异常</strong>：修改异常，插入异常，删除异常</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151401739.png alt=image-20220308151401739 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151410230.png alt=image-20220308151410230 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151420363.png alt=image-20220308151420363 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151430051.png alt=image-20220308151430051 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151446399.png alt=image-20220308151446399 style=zoom:50%><h3 id=函数依赖>函数依赖</h3><h4 id=函数依赖-fd-的定义>函数依赖 FD 的定义</h4><p>通俗定义：（X 和 Y 为属性或属性组）<strong>当 X 有一个确定值时，Y 一定有一个唯一的值与其对应</strong></p><p>严格定义：</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308151831420.png alt=image-20220308151831420 style=zoom:67%><p>或者说，<strong>属性 X 函数决定属性 Y，记作 X→Y</strong>。 其中 X 叫决定因素，Y 叫被决定因素。</p><p>此定义可简单表述为：如果属性 X 的值决定属性 Y 的值，那么属性 Y 函数依赖于属性 X。</p><p>换一种说法是，如果知道 X 的值，就可以获得 Y 的值。</p><ul><li><p>不依赖：$X \nrightarrow Y$</p></li><li><p>互相依赖：$X \leftrightarrow Y$</p></li></ul><h5 id=例>例</h5><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153147662.png alt=image-20220308153147662 style=zoom:67%><h4 id=fd-的逻辑蕴涵函数依赖集-f-的闭包>FD 的逻辑蕴涵、函数依赖集 F 的闭包</h4><p>逻辑蕴涵：由函数依赖集 F 能够推出的某依赖逻辑蕴涵于 F</p><p>函数依赖集 F 的闭包：F 能推出的所有依赖组成的集合</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153351885.png alt=image-20220308153351885 style=zoom:60%><p>逻辑蕴涵：{A→B，B→C} 逻辑蕴涵 A→C</p><h4 id=函数依赖的推理规则>函数依赖的推理规则</h4><h5 id=armstrong-公理系统>Armstrong 公理系统</h5><ol><li>自反性（以大推小）：$若 Y\sube X \sube U, 则 X \rightarrow Y 在 R 上成立。$</li><li>增广性（两边加）：$若 X \rightarrow Y 在 R 上成立，且 Z \sube U, 则 XZ \rightarrow YZ 在 R 上成立。$</li><li>传递性：$若 X \rightarrow Y 和 Y \rightarrow Z 在 R 上成立，则 X \rightarrow Z 在 R 上成立。$</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308153406619.png alt=image-20220308153406619 style=zoom:60%><h5 id=另外三个推理规则>另外三个推理规则</h5><p>平凡的 FD：以大推小</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220602100443663.png alt=image-20220602100443663 style=zoom:80%><h4 id=fd-与关键码的联系>FD 与关键码的联系</h4><p>包含在<strong>任何</strong>一个候选键中的属性成为主属性</p><p>不包含在<strong>任何</strong>一个候选键中的属性成为非主属性</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308160717162.png alt=image-20220308160717162 style=zoom:67%><h5 id=找候选键的方法>找候选键的方法</h5><p>小定理：</p><ul><li>不在函数依赖右部出现的属性，一定是</li><li>只在函数依赖右部出现的属性，一定不是</li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161331535.png alt=image-20220308161331535 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161440201.png alt=image-20220308161440201 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161447918.png alt=image-20220308161447918 style=zoom:67%><h4 id=属性集的闭包>属性集的闭包</h4><p>人话：属性 X（作为左值）可以推出的所有<strong>属性的集合</strong></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161457792.png alt=image-20220308161457792 style=zoom:67%><h5 id=求属性集的闭包>求属性集的闭包</h5><p>其实不用这么麻烦，暴力找也是可以的。。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161928927.png alt=image-20220308161928927 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308161942842.png alt=image-20220308161942842 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162000436.png alt=image-20220308162000436 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162008294.png alt=image-20220308162008294 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162421014.png alt=image-20220308162421014 style=zoom:67%><h4 id=fd-的最小依赖集>FD 的最小依赖集</h4><h5 id=函数依赖集的等价>函数依赖集的等价</h5><p>等价：两者闭包相等</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220308162436812.png alt=image-20220308162436812 style=zoom:67%><h5 id=最小函数依赖集>最小函数依赖集</h5><blockquote><p>最大函数依赖集就是闭包</p></blockquote><ul><li><p>保证右边都是单属性</p></li><li><p>消除左边的多余属性</p></li><li><p>消除多余的函数依赖</p></li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151127771.png alt=image-20220315151127771 style=zoom:67%><h5 id=例-1>例</h5><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151412567.png alt=image-20220315151412567 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315151417206.png alt=image-20220315151417206 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315153009173.png alt=image-20220315153009173 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315153021337.png alt=image-20220315153021337 style=zoom:67%><h3 id=关系模式的分解特性>关系模式的分解特性</h3><h4 id=模式分解问题>模式分解问题</h4><p>分解：把一张表拆成多张表</p><h5 id=投影>投影</h5><p>人话：有函数依赖集 F~i~，其中的所有元素都属于子集 U~i~，则称 F~i~ 为 F 在 U~i~ 上的投影</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154036857.png alt=image-20220315154036857 style=zoom:67%><h5 id=无损连接性与函数依赖保持性>无损连接性与函数依赖保持性</h5><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154427612.png alt=image-20220315154427612 style=zoom:67%><h4 id=无损分解>无损分解</h4><p>无损连接：分解后的表进行自然连接之后的表与原表的内容不多不少</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315154616981.png alt=image-20220315154616981 style=zoom:67%><h4 id=无损分解的测试方法>无损分解的测试方法</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160031794.png alt=image-20220315160031794 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160151601.png alt=image-20220315160151601 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160202135.png alt=image-20220315160202135 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160209405.png alt=image-20220315160209405 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160217009.png alt=image-20220315160217009 style=zoom:67%><p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160236362.png alt=image-20220315160236362 style=zoom:67%><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315160241704.png alt=image-20220315160241704 style=zoom:67%></p><h5 id=第二种方法>第二种方法</h5><p>只分解成两个子模式时适用</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161148857.png alt=image-20220315161148857 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161820582.png alt=image-20220315161820582 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161848712.png alt=image-20220315161848712 style=zoom:67%><h4 id=保持函数依赖的分解>保持函数依赖的分解</h4><p><strong>函数依赖保持性</strong>：F 在 Z 这个属性集合上的投影得到的小函数依赖集们的并集是否与 F 等价</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161858815.png alt=image-20220315161858815 style=zoom:67%><p>判断函数依赖保持性的方法</p><ol><li>求每个分解模式在 F 上的投影</li><li>若投影的并 = F，则保持</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161907624.png alt=image-20220315161907624 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161915181.png alt=image-20220315161915181 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220315161923688.png alt=image-20220315161923688 style=zoom:67%><h3 id=关系模式的范式>关系模式的范式</h3><blockquote><p>码 = 候选键，本质上是一个或一堆属性</p></blockquote><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/853012-20181109110730391-1699550272.png title=img></p><h4 id=第一范式-1nf>第一范式 1NF</h4><h5 id=反例>反例</h5><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150648406.png alt=image-20220322150648406 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150805914.png alt=image-20220322150805914 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150818141.png alt=image-20220322150818141 style=zoom:50%><h5 id=定义>定义</h5><p>原子性：每一个属性都不可分解</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150848377.png alt=image-20220322150848377 style=zoom:67%><h5 id=修改后的例子>修改后的例子</h5><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322150953681.png alt=image-20220322150953681 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151003707.png alt=image-20220322151003707 style=zoom:67%><h4 id=第二范式-2nf>第二范式 2NF</h4><h5 id=定义-1>定义</h5><p>第一范式有部分依赖的问题，而第二范式<strong>消除了部分依赖</strong></p><p>在满足第一范式的条件下，其他属性都必须<strong>完全依赖</strong>于某个候选键</p><ul><li>部分依赖：$X\rightarrow Y，且存在 X 的真子集 x&rsquo;,满足 x&rsquo;\rightarrow Y$</li><li>完全依赖/ 左部不可约依赖：$X\rightarrow Y，且不存在 X 的真子集 x&rsquo;,满足 x&rsquo;\rightarrow Y$</li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151718007.png alt=image-20220322151718007 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322151741366.png alt=image-20220322151741366 style=zoom:67%><h4 id=第三-范式-3nf>第三-范式 3NF</h4><p>第二范式会有传递依赖的问题，而第三范式<strong>消除了传递依赖</strong></p><p>✔️ 在满足第一范式的前提下，<strong>每一个非主属性都不传递依赖于候选键（主属性）</strong></p><p>个人理解：不满足第三范式的情况——存在非主属性 C 依赖于非主属性 B</p><p>跟 BCNF 相近的定义：对于 F 中每个非平凡 FD X->Y，都有 X 是 R 的超键，<strong>或 Y 的每个属性都是主属性</strong>（表明主属性间可能有传递依赖）。即每一个决定因素（左部）都包含码</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322152917085.png alt=image-20220322152917085 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322152926667.png alt=image-20220322152926667 style=zoom:67%><h5 id=例-2>例</h5><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154419167.png style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154517415.png alt=image-20220322154517415 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322154654654.png alt=image-20220322154654654 style=zoom:67%><h4 id=巴克斯范式-bcnf>巴克斯范式 BCNF</h4><p>消除主属性之间的（部分函数依赖和）传递函数依赖</p><p>✔️ 人话：对于 F 中每个非平凡 FD X->Y, 都有 X 是 R 的超键。即每一个决定因素（左部）都包含码</p><p>跟 3NF 相近的定义：满足第一范式的前提下，每一个<strong>属性</strong>都不传递依赖于候选键（主属性）</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160029125.png alt=image-20220322160029125 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160222855.png alt=image-20220322160222855 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322160458916.png alt=image-20220322160458916 style=zoom:67%><h4 id=分解成-bcnf-模式集的方法>分解成 BCNF 模式集的方法</h4><p>只能保持无损分解，不一定保持函数依赖。</p><ol><li><p>置初值：ρ = {R}。</p></li><li><p>ρ 已经满足 BC 范式，则结束。</p></li><li><p>找到左边没有码的依赖 X->A</p><ol><li>把 XA 单独放在一个模式 S~1~（这个模式必满足 BCNF）</li><li>把 A 从 U 里面删除，剩余属性组成一个新模式 S~2~，</li></ol></li><li><p>继续步骤 3，分解 S~2~，直到都满足 BCNF。</p></li><li><p>结束，输出 ρ。</p></li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161210743.png alt=image-20220322161210743 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161220977.png alt=image-20220322161220977 style=zoom:67%><p>另一种方法：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220327171535911.png title=image-20220327171535911></p><h4 id=分解成-3nf-模式集的方法>分解成 3NF 模式集的方法</h4><p>保持函依赖分解题，先求最小依赖集。</p><p>依赖两侧未出现，分成子集放一边，剩余依赖变子集。</p><p>若要连接成无损，再添候选做子集。</p><h5 id=算法一>算法一</h5><p><strong>保持函数依赖 ρ 的 3NF 模式集</strong></p><p>输入：R(U) + F~min~</p><ol><li>若 F~min~ 中只有一个函数依赖 X -> A , 且 {X, A} = U ，则停止</li><li>所有 F~min~ 中没有出现的属性，放在一个单独的模式。</li><li>F~min~ 中的每一个 X -> A，放在同一分组 R~i~ = XA</li><li>分解结束，输出 ρ</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161229166.png alt=image-20220322161229166 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161233794.png alt=image-20220322161233794 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161242727.png alt=image-20220322161242727 style=zoom:67%><h5 id=算法二>算法二</h5><p><strong>既保持函数依赖又无损链接 ρ 的 3NF 模式集</strong></p><p>输入：U + F~min~</p><ol><li>算法 1 得到一个模式集</li><li>若现有的模式中不存在包含候选键的模式，则将候选键作为一个模式加入模式集。</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220531115002045.png alt=image-20220531115002045 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161936938.png alt=image-20220322161936938 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220322161941646.png alt=image-20220322161941646 style=zoom:67%><h2 id=第七章-数据库设计>第七章 数据库设计</h2><h3 id=数据库设计概述>数据库设计概述</h3><h4 id=软件生存期>软件生存期</h4><p>定义：指从软件的规划、研制、实现、投入运行后的维护，直到它被新的软件所取代而停止使用的整个期间。</p><p><strong>六个阶段</strong>：规划阶段、需求分析阶段、设计阶段、程序编制阶段、调试阶段、运行维护阶段</p><h4 id=数据库系统生存期>数据库系统生存期</h4><ul><li><p>数据库应用系统：以<strong>数据库为基础的信息系统</strong>。具有对信息的<strong>采集、组织、加工、抽取和传播</strong>等功能。</p></li><li><p>数据库工程：数据库应用系统的开发。</p></li><li><p>数据库系统生存期：数据库应用系统从<strong>开始规划、设计、实现、维护到最后被新的系统取代而停止使用</strong>的整个期间。</p></li></ul><h5 id=七个阶段>七个阶段</h5><ol><li><strong>规划阶段</strong><ul><li>必要性和可行性分析。确定数据库系统的地位，以及数据库间联系。</li></ul></li><li><strong>需求分析阶段</strong><ul><li>分析用户需求</li><li>信息要求（数据库中存储哪些数据）</li><li>处理要求（需要的处理功能，响应时间要求，批/联机处理）</li><li>安全性和完整性要求</li></ul></li><li><strong>概念设计阶段</strong><ul><li>表达用户整体要求，且独立于 DBMS 和硬件结构。</li></ul></li><li><strong>逻辑设计阶段</strong>（设计 ER 图）<ul><li><strong>数据库逻辑结构设计</strong>：ER 图 => DBMS 的 DDL 转换为逻辑数据库结构</li><li><strong>应用程序设计</strong>：DBMS 的 DML 进行结构式的程序设计。</li></ul></li><li><strong>物理设计阶段</strong>（设计表）<ul><li><strong>物理数据库结构的选择</strong></li><li><strong>逻辑设计中程序模块说明的精确化</strong>（开发）。</li><li>成果：一个完整的，能实现的数据库结构。</li></ul></li><li><strong>实现</strong></li><li><strong>运行维护</strong><ul><li>收集和记录系统实际运行的数据。</li></ul></li></ol><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145819593.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145819593.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145819593.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145819593.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145819593.png title=image-20220529145819593></p><h3 id=规划>规划</h3><h4 id=规划阶段完成的任务>规划阶段完成的任务</h4><ul><li>确定系统的范围</li><li>确定开发工作所需要的资源</li><li>估计软件开发的成本</li><li>确定项目的进度</li></ul><h4 id=可行性分析报告>可行性分析报告</h4><p>规划工作完成后，写出详尽的可行性分析报告和数据库系统规划纲要</p><p>内容包括：信息范围、信息来源、人力资源、设备资源、软件及支持工具资源、开发成本估算、开发进度计划、现行系统向新系统过渡计划等。</p><p>规划送决策部门评审。</p><h3 id=需求分析>需求分析</h3><h4 id=需求描述与分析>需求描述与分析</h4><ol><li>对系统的整个应用情况做<strong>全面的详细的调查</strong>，<strong>确定企业组织的目标</strong></li><li>收集<strong>支持系统总的设计目标的基础数据和对这些数据的要求</strong>，<strong>确定用户的需求</strong></li><li>并把这些要求写成用户和数据库设计者都能接受的文档。</li></ol><h4 id=需求分析阶段的输入和输出>需求分析阶段的输入和输出</h4><ol><li>输入：总体信息要求（数据本质和概念上联系），处理要求（数据处理），系统要求</li><li>输出：需求说明书（数据流图 + 数据字典）</li></ol><h4 id=需求分析的步骤>需求分析的步骤</h4><ol><li>分析用户活动，产生用户活动图（即<strong>用户的业务流程图</strong>）</li><li>确定系统范围，产生系统范围图（即确定<strong>人机界面</strong>）;</li><li>分析用户活动所涉及的数据,产生数据流图（<strong>数据的流向及加工</strong>）;</li><li>分析系统数据，产生数据字典。</li></ol><p>数据流图：→ 数据流；$\bigcirc$ 加工 / 处理；= 文件；$\square$ 外部实体</p><p>数据字典：</p><ul><li>定义：对系统中数据的详尽描述，提供了对数据库数据描述的集中管理。</li><li>内容：数据项，数据结构，数据流，数据存储，加工过程</li><li>功能：存储和检索各种数据描述，为 DBA 提供有关的报告。</li><li>在需求分析阶段建立，并在数据库设计过程中不断改进、充实和完善。</li></ul><h3 id=概念设计>概念设计</h3><p>目标：<strong>产生</strong>反映企业组织信息需求的数据库概念结构（<strong>概念模式</strong>）。</p><p>概念模式独立于数据库逻辑结构，也独立于支持数据库的 DBMS。</p><h4 id=概念设计的必要性>概念设计的必要性</h4><ol><li>各阶段的任务相对单一化，设计复杂程度大大降低，便于组织管理。</li><li>不受特定的 DBMS 的限制，也独立于存储安排和效率方面的考虑，比逻辑模式更稳定。</li><li>不含具体 DBMS 附加技术细节，用户理解容易，可以更准确反应用户的信息需求。</li></ol><h4 id=概念模型>概念模型</h4><ol><li>是对现实世界的抽象和概括。</li><li>应简洁，明晰，独立于机器，容易理解。</li><li>应易于变动。</li><li>应很容易向关系，层次，网状等各种数据模型转换。</li></ol><h4 id=概念设计的主要步骤>概念设计的主要步骤</h4><ol><li>进行数据抽象，设计局部概念模式（“聚集” + “概括”）</li><li>将局部概念模式综合成全局概念模式（解决冲突：消除冗余，统一命名）</li><li>评审（用户评审 + DBA 和应用开发人员评审）</li></ol><h4 id=数据抽象>数据抽象</h4><ol><li>抽象：对实际的人、物、事或概念的人为处理，抽取人们关心的共同特性，忽略非本质的细节，将这些特性用各种概念精确地加以描述，这些概念组成了某种模型。</li><li>两种形式：<ul><li>抽象对象：系统状态的抽象</li><li>抽象运算：系统转换的抽象</li></ul></li><li>聚集：笛卡尔积，形成对象之间的一个联系对象。<ul><li>聚集层次表示：“是……的一部分” (is part of) 的关系。</li></ul></li><li>概括：从一类对象形成一个对象。<ul><li>概括层次表示：“是……一种” (is a) 的关系。</li></ul></li><li>数据抽象层次<ul><li>每个对象既可以是聚集对象，也可以是概括对象。</li><li>反复进行数据抽象，形成层次关系。</li></ul></li></ol><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145838801.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145838801.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145838801.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145838801.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145838801.png title=image-20220529145838801></p><h4 id=er-模型的操作>ER 模型的操作</h4><p>ER 模型的操作：在利用 ER 模型进行数据库概念设计的过程中，常常对 ER 图进行的种种变换。<strong>（实体类型、联系类型和属性的分裂、合并和增删······）</strong></p><h5 id=实体类型的分裂>实体类型的分裂</h5><ol><li>垂直分割：把一个实体类型的属性分成若干组，然后按组形成若干实体类型。 <strong>键必须在所有实体中体现。</strong></li></ol><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145847409.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145847409.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145847409.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145847409.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145847409.png title=image-20220529145847409></p><ol start=2><li>水平分割：分裂成互补相交的子类。 e.g. 教师 => 男教师 + 女教师</li></ol><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145852716.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145852716.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145852716.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145852716.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145852716.png title=image-20220529145852716></p><h5 id=实体类型的合并>实体类型的合并</h5><ol><li>水平合并，垂直合并。</li><li>是否会产生新联系视情况而定。</li></ol><h5 id=联系类型的分裂>联系类型的分裂</h5><p>一个联系类型可分裂成几个新联系类型。新联系类型可能和原联系类型不同。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145900817.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145900817.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145900817.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145900817.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145900817.png title=image-20220529145900817></p><h5 id=联系类型的合并>联系类型的合并</h5><p>合并的联系类型必须是定义在相同的实体类型组合中，否则，不合法。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145906488.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145906488.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145906488.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145906488.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145906488.png title=image-20220529145906488></p><h4 id=采用-er-方法的数据概念设计>采用 ER 方法的数据概念设计</h4><p>第一步：设计局部 ER 模式：</p><ol><li>确定局部结构范围划分；</li><li>实体定义；</li><li>联系定义。</li></ol><p>第二步：设计全局 ER 模式：</p><ol><li>确定公共实体类型；（同名实体类型；相同主键的实体）</li><li>局部 ER 模式的合并；</li><li>消除冲突 （属性冲突，结构冲突，命名冲突）</li></ol><p>第三步：全局 ER 模式的优化原则：</p><ol><li>相关实体类型的合并：1:1 的实体合并，部分相同键的实体</li><li>冗余属性的消除；</li><li>冗余联系的消除。</li></ol><h3 id=逻辑设计>逻辑设计</h3><p>数据库的逻辑设计就是把概念设计得到的数据库模型，转化为具体的 DBMS 所能接受的数据库逻辑结构，包括数据库模式和外模式</p><h4 id=逻辑设计环境>逻辑设计环境</h4><ol><li>输入<ol><li>独立于 DBMS 的概念模式：局部，全局概念模式（概念设计阶段）</li><li>处理需求：业务活动分析结果（需求分析阶段）</li><li>约束条件</li><li>DBMS 特性</li></ol></li><li>输出<ol><li>DBMS 可处理的模式：说明</li><li>子模式</li><li>应用程序设计指南</li><li>物理设计指南：完全文档化的模式和子模式。</li></ol></li></ol><h4 id=逻辑设计的步骤>逻辑设计的步骤</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529152543667.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529152543667.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529152543667.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529152543667.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529152543667.png title=image-20220529152543667></p><h4 id=er-模型象关系模型的转换>ER 模型象关系模型的转换</h4><p><strong>ER 模型转换为关系模型的一般规则</strong></p><ol><li><p>实体类型的转换：1 个实体 1 张表。</p></li><li><p>联系类型的转换</p><ul><li>1:1：任意一端加入另一端的主键，作为外键。</li><li>1:N：N 端加入 1 端主键，作为外键。</li><li>弱实体 1:N：N 端为弱实体 N 端中加入 1 端主键，作为外键。且 N 端主键 = 1 端主键 + N 端外键</li><li>M:N：新增一张表，主键为两端的外键构成。</li></ul></li><li><p>超类和子类的转换规则：子类 = 父类主键 + 新增属性</p></li></ol><h4 id=关系数据库的逻辑设计>关系数据库的逻辑设计</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145935339.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145935339.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145935339.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145935339.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529145935339.png title=image-20220529145935339></p><ol><li>导出初始关系模式</li><li>运用模式设计理论，对初始关系模式进行规范化处理<ol><li>确定规范级别，3NF / BCNF</li><li>实施规范化处理</li></ol></li><li>模式评价：功能 + 性能</li><li>模式修正</li></ol><h3 id=物理设计>物理设计</h3><ol><li>物理设计：对于给定的基本数据模型选取一个最适合应用环境的物理结构。</li><li>数据库的物理结构：数据库的存储记录格式，存储记录安排，存取方法。</li><li>物理设计分五步完成<ol><li><strong>存储记录结构设计</strong>：记录的组成、数据项的类型、长度，以及逻辑记录到存储记录的映射。</li><li><strong>确定数据存放位置</strong>：把经常同时被访问的数据组合在一起。</li><li><strong>存取方法的设计</strong>：主存取路径，辅存取路径。</li><li><strong>完整性和安全性考虑</strong></li><li><strong>程序设计</strong></li></ol></li></ol><h3 id=数据库的实现>数据库的实现</h3><ol><li>数据库的实现阶段： 根据逻辑设计和物理设计的结果，在计算机系统上建立起实际数据库结构、装入数据、测试和试运行的过程。</li><li>实现阶段主要有三项工作<ol><li>建立实际数据库结构</li><li>装入试验数据对应用程序进行调试</li><li>装入实际数据，进入试运行状态</li></ol></li></ol><h3 id=数据库的运行和维护>数据库的运行和维护</h3><p>运行维护阶段主要有四项工作</p><ol><li>维护数据库的安全性与完整性</li><li>监测并改善数据库运行性能</li><li>根据用户要求对数据库现有功能进行扩充</li><li>及时改正运行中发现的系统错误</li></ol><h2 id=第八章-数据库管理>第八章 数据库管理</h2><h3 id=事务的概念>事务的概念</h3><h4 id=事务的定义>事务的定义</h4><p>事务是构成<strong>单一逻辑工作单元的操作集合</strong>。DBS 必须保证事务<strong>正确，完整的执行</strong></p><blockquote><p>事务是由若干数据库操作组成的一个逻辑工作单位，是一个<strong>不可分割</strong>的工作单位。</p></blockquote><ul><li>一个应用程序可以包括多个事务。</li><li>事务以 <code>BEGIN TRANSACTION</code> 语句的成功执行开始，以 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句的成功执行结束。<ul><li><code>COMMIT</code>（提交）语句表示一事务的全部操作都已成功，它对 DB 的所有更新可真正写到 DB 中。</li><li><code>ROLLBACK</code>（回退）语句表示事务没有成功地完成全部操作，系统将撤消该事务对 DB 已作的更新。</li></ul></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=err>银行转账事务</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>T</span><span class=p>:</span><span class=k>BEGIN</span><span class=w> </span><span class=k>TRANSACTION</span><span class=p>;</span><span class=w>			</span><span class=cm>/* 事务开始语句 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>read</span><span class=p>(</span><span class=n>A</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>A</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=n>A</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=mi>50</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>write</span><span class=p>(</span><span class=n>A</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>A</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>0</span><span class=p>):</span><span class=w> </span><span class=k>ROLLBACK</span><span class=p>;</span><span class=w>			</span><span class=cm>/* 事务回退语句 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>else</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  		</span><span class=k>read</span><span class=p>(</span><span class=n>B</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  		</span><span class=n>B</span><span class=w> </span><span class=p>:</span><span class=o>=</span><span class=w> </span><span class=n>B</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=mi>50</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  		</span><span class=k>write</span><span class=p>(</span><span class=n>B</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  		</span><span class=k>COMMIT</span><span class=p>;</span><span class=err>}</span><span class=w>				</span><span class=cm>/* 事务提交语句 */</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=事务的性质acid>事务的性质（ACID）</h4><p>事务有四个重要性质：原子性、一致性、隔离性和持久性。通常称为 “<strong>ACID 性质</strong>”。</p><ul><li><strong>原子性</strong>（atomicity）<ul><li>事务对数据库的更新要么全部起作用，要么完全不起作用。（不可分割）</li><li>DBMS 的事务管理子系统</li></ul></li><li><strong>一致性</strong>（consistency）<ul><li>一个事务独立执行的结果，应保持数据库的一致性。即数据不会因事物的执行而遭受破坏</li><li>程序员（正确地编写事务）DBMS 的完整性子系统</li></ul></li><li><strong>隔离性</strong>（isolation ）<ul><li>事务相互隔离，在多个事务并发执行时，任一事务的更新操作在该事务成功提交前对其他事务都是不可见的。</li><li>DBMS 的并发控制子系统</li></ul></li><li><strong>持久性</strong>（durability）<ul><li>事务一旦成功提交，其对数据库的更新就永久有效，不会因系统崩溃等而丢失。</li><li>DBMS 的恢复管理子系统</li></ul></li></ul><h4 id=事物的状态变迁>事物的状态变迁</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503151741223.png title=image-20220503151741223></p><h3 id=数据库的恢复>数据库的恢复</h3><h4 id=数据库恢复的定义>数据库恢复的定义</h4><p><strong>恢复的定义</strong>：恢复管理子系统采取一些列的措施保证在任何情况下保持事务的<strong>原子性和持久性</strong>，确保数据不丢失、不破坏。</p><p><strong>数据库的可恢复性</strong>：系统能把数据库从被破坏、不正确的状态、恢复到最近一个正确的状态。</p><h4 id=数据库恢复的基本原则和实现方法>数据库恢复的基本原则和实现方法</h4><p><strong>基本原则</strong>：<strong>冗余</strong>（数据重复存储）</p><p><strong>实现方法</strong>：</p><ul><li><strong>备份</strong>：定期对数据库复制或转储（静态转储和动态转储，海量转储和增量转储）。</li><li><strong>日志</strong>：执行事务时，记录其开始、结束和对 DB 的每次更新操作。</li></ul><p>发送故障时，分情况处理</p><ul><li>数据库破坏：复制最近一次数据到数据库，利用日志 “重做” 以同步。</li><li>数据库完好，数据损坏：利用日志 “撤销” 处理。</li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503152715965.png alt=image-20220503152715965 style=zoom:67%><h4 id=故障类型>故障类型</h4><ul><li><p><strong>事务故障</strong></p><ul><li>非预期事务故障：运算错误、数据错误、死锁等，故障事务夭折</li><li>可预期事务故障：在事务中可预期出错的地方所加的 ROLLBACK 语句</li></ul></li><li><p><strong>系统故障</strong>（软故障）</p><ul><li>引起系统停止运转随之要求重新启动的事件。</li><li>影响正在运行的事务，主存内容丢失，但不破坏数据库。</li><li>硬件、系统软件出错，停电等，事务执行被打断，内存中数据被破坏</li></ul></li><li><p><strong>介质故障</strong>（硬故障）</p><ul><li>物理损坏，磁盘数据丢失。</li><li>磁头、磁盘控制器或磁盘损坏，盘上数据丢失，病毒破坏等，DB 遭破坏</li></ul></li></ul><h4 id=恢复方法>恢复方法</h4><p>当系统运行过程中发生故障，利用数据库后备副本和日志文件将数据库恢复到故障前的某个一致性状态。不同故障其恢复技术不一样</p><h5 id=事务故障的恢复>事务故障的恢复</h5><blockquote><p>事务故障的恢复是由系统自动完成的，不需要用户干预。</p></blockquote><p>事务故障是指事务在运行至正常终止点前被终止，此时恢复子系统应<strong>撤销</strong>（UNDO）此事务已对数据库进行的修改</p><p><strong>恢复步骤</strong>（其实就是 undo 的具体操作）</p><ol><li><strong>反向扫描</strong>日志文件（即从最后向前扫描日志文件）<ul><li>查找该事务的更新操作。</li></ul></li><li>对该事务的更新操作执行逆操作。<ul><li>即将日志记录中“更新前的值”写入数据库<ul><li>若记录中是插入操作，则相当于做删除操作</li><li>若记录中是删除操作，则做插入操作</li><li>若是修改操作，则用修改前值代替修改后值。</li></ul></li></ul></li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了</li></ol><h5 id=系统故障的恢复>系统故障的恢复</h5><blockquote><p>系统故障的恢复也由系统自动完成的，不需要用户干预。</p></blockquote><p>系统故障造成数据库不一致状态的<strong>原因</strong>有两个</p><ul><li>未完成事务对数据库的更新已写数据库</li><li>已提交事务对数据库的更新还留在缓冲区没来得及真正写入数据库。</li></ul><p><strong>恢复办法</strong></p><ul><li>撤销 undo 故障发生时未完成的事务</li><li>重做 redo 已完成的事务（使其写入数据库）</li></ul><blockquote><p><strong>恢复步骤</strong></p><ol><li><strong>正向扫描</strong>日志文件 (即从头开始扫描日志文件)，找出在故障发生前<ul><li>已提交事务 (既有 <code>&lt;Ti, START></code> 记录，也有 <code>&lt;Ti, COMMIT></code> 记录)，将其事务标识记入<strong>重做队列</strong></li><li>尚未完成的事务 (有 <code>&lt;Ti, START></code> 记录，无 <code>&lt;Ti,COMMIT></code> 记录), 将其事务标识记入<strong>撤销队列</strong></li></ul></li><li>对撤销队列中的各个事务进行<strong>撤销</strong>（UNDO）处理<ul><li><strong>反向扫描</strong>日志文件，对每个 UNDO 事务的更新操作执行<strong>逆操作</strong>，即将日志记录中“更新前的值”写入数据库</li></ul></li><li>对重做队列中的各个事务进行<strong>重做</strong>（REDO）处理<ul><li><strong>正向扫描</strong>日志文件，对每个 REDO 事务重新执行登记操作，即将日志记录中“更新后的值”写入数据库</li></ul></li></ol></blockquote><h5 id=介质故障的恢复>介质故障的恢复</h5><p>在发生介质故障和遭受病毒破坏时，磁盘上的物理数据库遭到毁灭性破坏。此时恢复的过程如下</p><ol><li>重装转储的副本，恢复数据库到最近一次转储的正确（一致）状态。</li><li>在日志中找出转储以后所有已提交的事务。</li><li>对已提交事务 REDO 处理。</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220503161657955.png alt=image-20220503161657955 style=zoom:67%><h4 id=检查点机制>检查点机制</h4><blockquote><p>感觉就是系统故障的恢复的优化</p></blockquote><p>检查点（Checkpoint）方法 ：DBMS 定时设置检查点，在检查点时刻才真正做到把对 DB 的修改写到磁盘，并在日志文件写入一条检查点记录。</p><p><strong>恢复方法</strong></p><ol><li>根据日志文件建立重做队列和事务撤消队列。</li><li>对重做队列中的事务进行 REDO 处理，对撤消队列中的事务进行 UNDO 处理</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220531221346786.png alt=image-20220531221346786 style=zoom:67%><h5 id=检查点方法>检查点方法</h5><p>DBMS 定时设置检查点，在检查点时，做下列事情</p><ol><li>将日志缓冲区中的日志记录写入磁盘</li><li>将数据库缓冲区中修改过的缓冲块内容写入磁盘</li><li>写一个检查点记录到磁盘，内容包括<ul><li>检查点时刻，所有活动事务</li><li>每个事务最近日志记录地址</li></ul></li><li>把磁盘中日志检测点记录的地址写入“重新启动文件中”</li></ol><h5 id=检查点恢复步骤->检查点恢复步骤 ✔️</h5><ol><li><strong>正向</strong>扫描日志文件，建立事务<strong>重做队列</strong>和事务<strong>撤消队列</strong><ul><li>将已完成的事务加入重做队列</li><li>未完成的事务加入撤销队列</li><li><strong>做完的重做，没做完的别做了</strong></li></ul></li><li>对撤销队列做 UNDO 处理的方法是<ul><li><strong>反向</strong>扫描日志文件，根据撤销队列的记录对每一个撤销事务的更新操作执行逆操作，使其恢复到原状态</li></ul></li><li>对重做队列做 REDO 处理的方法是<ul><li><strong>正向</strong>扫描日志文件，根据重做队列的记录对每一个重做事务实施对数据库的更新操作</li></ul></li></ol><h4 id=运行记录优先原则>运行记录优先原则</h4><p>运行记录优先原则包括两点</p><ul><li>（先写日志，后写 DB）将一个更新结果写到 DB 中前，必须确保<strong>先在日志中成功登记</strong>了这个更新。</li><li>（写全日志，才 COMMIT）直至对一事务的日志登记全部完成，方能够允许该事务完成 COMMIT 处理。</li></ul><p>这个原则确保了发生故障后能够根据日志对事务进行 REDO 或 UNDO。</p><h3 id=数据库的并发控制>数据库的并发控制</h3><h4 id=并发操作带来三个问题>并发操作带来三个问题</h4><p>为了充分利用数据库这个共享资源，DBMS 允许多个事务并发地存取数据库。</p><p>如果不对并发操作进行恰当的控制，可能导致如下的数据不一致性问题：</p><ul><li>丢失更新问题：（更新被覆盖，同时写时会发生）一事务所作的更新操作因另一事务的操作而丢失。</li><li>不一致分析问题：（前后读取不一致，读时写会发生）指事务从数据库中读取了处于不一致状态的数据，并因此进行了不一致的分析。</li><li>读 “脏数据” 问题（读取的数据被撤销，读时写会发生）：又称为未提交依赖，指一事务取用了别的事务未提交随后又被<strong>撤消</strong>的数据。</li></ul><h5 id=丢失更新>丢失更新</h5><blockquote><p>Lost Update</p></blockquote><p>指事务 Ti 与事务 Tj 从数据库中读入同一数据并修改，事务 Tj 的提交结果破坏了事务 Ti 提交的结果，导致事务 Ti 的修改被丢失。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516210506608.png alt=image-20220516210506608 style=zoom:67%><h5 id=不一致分析>不一致分析</h5><blockquote><p>不可重复读 nonrepeatable read</p></blockquote><p>指事务 Ti 读取数据后，事务 Tj 执行更新操作，使事务 Ti 无法再读取前一次结果</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516211547543.png alt=image-20220516211547543 style=zoom:67%><h5 id=读脏数据>读“脏”数据</h5><blockquote><p>diriy read</p></blockquote><p>事务 Ti 修改某一数据，并将其写回磁盘，事务 Tj 读取同一数据后，事务 Ti 由于某种原因被撤销，这时事务 Ti 已修改过的数据恢复原值，事务 Tj 读到的数据就与数据库中的数据不一致，是不正确的数据，称为“脏”数据。</p><p>如果事务 T~j~ 读取脏数据后又进行了更新操作，实际上是无效的，此时破坏了数据库的完整性。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516212059994.png alt=image-20220516212059994 style=zoom:67%><h4 id=封锁机制>封锁机制</h4><p>封锁是实现并发控制的重要技术。</p><p>所谓封锁，是指事务向系统发出对某数据对象<strong>加锁</strong>的请求，以取得对该对象一定的控制权。</p><p>基本的封锁有两类：</p><ul><li><strong>排它型封锁</strong>（写锁，X 封锁）：一个事务对数据对象加了 X 锁后，在它释放 X 锁之前不允许其他事务再对该数据对象加任何锁。</li><li><strong>共享型锁</strong>（读锁，S 封锁） ：一个事务对数据对象加了 S 锁后，允许其他事务再对该数据对象加 S 锁，但在它释放 S 锁之前不允许其他事务加 X 锁。</li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516213308761.png alt=image-20220516213308761 style=zoom:50%><h5 id=排它型封锁>排它型封锁</h5><p><strong>PX 协议</strong>主要内容是：</p><ul><li>事务若要更新数据 R，则必须先提出对此 R 的 X 封锁请求；（<code>XFIND R</code>）</li><li>事务如果未获准 X 封锁，那么进入等待状态，直至获准在此数据对象上的 X 封锁，才能继续执行。</li></ul><p>PX 协议可以解决因多事务同时更新同一数据对象而引起的更新丢失问题。</p><p><strong>PXC 协议</strong> 是在 PX 协议上再加一规定：解除 X 锁的操作合并到事务的结束（COMMIT 或 ROLLBACK）操作中。</p><p>PXC 协议可以解决更新丢失问题。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516212541732.png alt=image-20220516212541732 style=zoom:67%><h5 id=共享型封锁>共享型封锁</h5><p><strong>PS 协议</strong>，其主要内容是：</p><ul><li>事务若要存取数据 R，则必须先提出对 R 的 S 封锁请求；（<code>SFIND R</code>）</li><li>事务如果未获准 S 封锁，那么进入等待状态，直至获准在此数据对象上 S 封锁，才能继续执行；</li><li>事务在更新数据前必须先将它在该数据对象上的 S 封锁升级为 X 封锁。 （<code>UPDX R</code>）</li></ul><p>**PSC 协议 **是在 PS 协议上再加一规定：解锁操作合并到事务的结束（COMMIT 或 ROLLBACK）操作中。</p><p>PSC 协议可以解决丢失更新、读 “脏数据” 和不一致分析问题。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516212728567.png alt=image-20220516212728567 style=zoom:67%><h4 id=活锁和死锁>活锁和死锁</h4><p>恰当地运用封锁技术，可以保证并发调度的正确性、有效地避免数据不一致，但有可能引起活锁和死锁问题。</p><h5 id=活锁>活锁</h5><p>出现某个事务永远处于等待状态得不到执行的现象。</p><p>例子：写者一直被不断到来的读者堵着</p><p>避免活锁的一个简便方法是采用 “<strong>先来先服务</strong>” 排队的策略。封锁子系统按请求在时间上的先后次序对事务排序，数据对象上原有的锁一释放，即执行队列中第一个事务的封锁请求。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516213848559.png alt=image-20220516213848559 style=zoom:67%><h5 id=饿死>饿死</h5><p>对某数据，S 锁永远存在，没有机会上 X 锁。</p><p>解决：授权加锁：T2 对 Q 加锁</p><ul><li>不存在在数据项 Q 上持有 X 锁的其他事务。</li><li>不存在等待对数据项 Q 加锁且先于 T2 申请加锁的事务。</li></ul><blockquote><p>这个定义跟活锁太像了，很怪</p></blockquote><h5 id=死锁>死锁</h5><p>出现若干事务因循环等待而无法继续执行的现象。</p><p>例： 两个事务 T1 和 T2 已分别封锁了数据 D1 和 D2。 T1 和 T2 由于需要各自分别申请封锁 D2 和 D1，但是由于 D2 和 D1 已被对方封锁，因而 T1 和 T2 只能等待。 而 T1 和 T2 由于等待封锁而不能结束，从而使对方的封锁申请也永远不能被选中，这就形成了死锁。</p><p>死锁的诊断：DBMS 周期地测试系统中是否出现了死锁。用事务依赖图的形式可以测试系统中是否存在死锁。如果在事务依赖图中，沿着箭头方向存在一个循环，那么表示已出现死锁现象。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214047843.png alt=image-20220516214047843 style=zoom:67%><h4 id=并发事务的可串行化调度>并发事务的可串行化调度</h4><h5 id=事务的调度串行调度和并发调度>事务的调度、串行调度和并发调度</h5><ul><li><p>调度：事务的<strong>执行次序</strong></p></li><li><p>串行调度：多个事务<strong>依次</strong>执行</p></li><li><p>并发调度：设法（例如利用分时的方法）使多个事务<strong>同时</strong>被处理（即交错执行）</p></li></ul><p>在应用环境中，事务的任一串行调度都是有效的（正确的），但是事务的并发调度不一定是正确的，有可能产生前面提到的不一致性问题。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214740738.png alt=image-20220516214740738 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214754739.png alt=image-20220516214754739 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214801766.png alt=image-20220516214801766 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214807748.png alt=image-20220516214807748 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516214840390.png alt=image-20220516214840390 style=zoom:50%><p>了保证并行操作的正确性，DBMS 的并行控制机制必须提供一定的手段来保证调度是可串行化的。</p><p>从理论上讲，在某一事务执行时禁止其他事务执行的调度策略一定是可串行化的调度，这也是最简单的调度策略，但这种方法实际上是不可行的，因为它使用户不能充分共享数据库资源。</p><h5 id=可串行化与两端封锁协议>可串行化与两端封锁协议</h5><p><strong>可串行化</strong>：如果<strong>一个并发调度与某一串行调度具有相同的执行结果</strong>，那么称这个并发调度是可串行化的调度（即正确的并发调度），否则是不可串行化的调度。</p><p><strong>两段封锁协议</strong></p><ul><li>事务在对数据对象存取之前必须先获得对此数据对象的封锁</li><li>事务在解除了一个锁之后不能再获得任何其他封锁</li></ul><p>要点</p><ul><li><p>PXC 和 PSC 协议可以看作两端封锁协议的加强形式</p></li><li><p>⭐ 若所有事务都遵守两段封锁协议，则对这些事务的任何并发调度策略都是可串行化的；</p></li><li><p>但若并发事务的一个调度是可串行化的，并不一定所有事务都符合两段封锁协议。</p></li><li><p>两段封锁协议与防止死锁的一次封锁法是不同的。一次封锁法符合两段封锁协议，但两段封锁协议并不要求一</p><p>次封锁法。因此，遵守两段封锁协议的事务也有可能发生死锁。</p></li></ul><p><strong>封锁粒度</strong>：封锁对象的规模称为封锁粒度（Granularity）。</p><h4 id=sql-中事务的存取模式和隔离级别>SQL 中事务的存取模式和隔离级别</h4><p>事务的存取模式</p><ul><li>READ ONLY（只读型）</li><li>READ WRITE（读写型）</li></ul><p>事务的隔离级别</p><ul><li>SERIALIZABLE（可串行化）</li><li>REPEATABLE READ （可重复读）</li><li>READ COMMITED（读提交数据）</li><li>READ UNCOMMITED（读未提交数据）</li></ul><h3 id=数据库的完整性>数据库的完整性</h3><h4 id=完整性子系统和完整性规则>完整性子系统和完整性规则</h4><h5 id=定义-2>定义</h5><p><strong>完整性</strong>：是指数据的正确性、有效性和相容性。</p><ul><li>正确性：数据的合法性，e.g. 数值类型中只含数字，不含字母。</li><li>有效性：数据是否属于定义的有效范围。</li><li>相容性：同一事实的两个数据应相同。</li></ul><p><strong>完整性约束条件</strong>（完整性规则）：为保证数据的完整性而规定的条件。</p><p><strong>完整性检查</strong>：检查 DB 中数据是否满足完整性约束条件。</p><p><strong>完整性子系统</strong>：DBMS 中执行完整性检查的子系统。其功能有：</p><ul><li>监督事务的执行，测试其是否违反完整性约束条件；</li><li>若有违反，则按进行预定的处理。</li></ul><h5 id=完整性规则的组成>完整性规则的组成</h5><p>每个规则包括三部分：</p><ul><li><strong>触发条件</strong>：规定<strong>何时</strong>执行本规则进行检查；</li><li><strong>约束条件</strong>：又称谓词，定义应满足的条件；</li><li><strong>否则子句</strong>：规定不满足条件时该作的处理。</li></ul><p>在关系 DB 中，完整性规则可分为三类：</p><ul><li><strong>域完整性规则</strong>：定义属性取值范围。</li><li><strong>域联系的规则</strong>：定义属性间的联系、影响和约束。</li><li><strong>关系完整性规则</strong>：定义更新操作对值的影响和限制。</li></ul><p>完整性规则用 DDL 描述，由系统执行检查。</p><h4 id=sql-中的完整性约束>SQL 中的完整性约束</h4><p>完整性约束分为三大类：</p><ul><li>域约束</li><li>基本表约束</li><li>断言</li></ul><h5 id=域约束>域约束</h5><p>定义属性的取值范围——属性值约束。</p><p>包括：<strong>域约束子句</strong>、<strong>非空值约束</strong>、<strong>基于属性的检查子句</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>DOMAIN</span><span class=w> </span><span class=n>COLOR</span><span class=w> </span><span class=nb>CHAR</span><span class=p>(</span><span class=mi>6</span><span class=p>)</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=s1>&#39;???&#39;</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>若插入</span><span class=n>COLOR</span><span class=err>不再范围内，则置为</span><span class=o>???</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>	</span><span class=k>CONSTRAINT</span><span class=w> </span><span class=n>VALID_COLORS</span><span class=w>	                </span><span class=o>#</span><span class=w> </span><span class=err>域约束名</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>		</span><span class=k>CHECK</span><span class=p>(</span><span class=n>VALUE</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;RED&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;YELLOW&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;BLUE&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;GREENN&#39;</span><span class=p>,</span><span class=w> </span><span class=s1>&#39;???&#39;</span><span class=p>))</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>允许域约束上的 CHECK 子句可以有任意复杂的条件表达式</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516223852029.png alt=image-20220516223852029 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516223859244.png alt=image-20220516223859244 style=zoom:50%><h5 id=基本表约束>基本表约束</h5><blockquote><p>都可以加 <code>CONSTRAINT 约束名 # 指定域约束名</code></p></blockquote><p><strong>候选键约束（主键约束）</strong></p><p>可用候选键约束约束来描述实体完整性规则。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>UNIQUE</span><span class=p>(</span><span class=o>&lt;</span><span class=err>列名序列</span><span class=o>&gt;</span><span class=p>)</span><span class=w>      </span><span class=o>#</span><span class=w> </span><span class=err>候选键定义，仅表示唯一，非空需要加</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=err>。</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=o>&lt;</span><span class=err>列名序列</span><span class=o>&gt;</span><span class=p>)</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>主键定义，仅有一个，默认非空。</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>其实有两种定义主键的方法，一种是在属性后增加关键字，另一种是在属性表中加入额外的定义主键的子句（主键子句和主键短语）</p></blockquote><p><strong>外键约束</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>FOREIGN</span><span class=w>  </span><span class=k>KEY</span><span class=p>(</span><span class=o>&lt;</span><span class=err>列名序列</span><span class=mi>1</span><span class=o>&gt;</span><span class=p>).</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=k>REFERENCES</span><span class=w>  </span><span class=o>&lt;</span><span class=err>参照表</span><span class=o>&gt;</span><span class=w>  </span><span class=p>[(</span><span class=o>&lt;</span><span class=err>列名序列</span><span class=mi>2</span><span class=o>&gt;</span><span class=p>)]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>[</span><span class=w> </span><span class=k>ON</span><span class=w>  </span><span class=k>DELETE</span><span class=w> </span><span class=o>&lt;</span><span class=err>参照动作</span><span class=o>&gt;</span><span class=w> </span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=p>[</span><span class=w> </span><span class=k>ON</span><span class=w>  </span><span class=k>UPDATE</span><span class=w> </span><span class=o>&lt;</span><span class=err>参照动作</span><span class=o>&gt;</span><span class=w> </span><span class=p>]</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>作为主键的关系叫参照表，作为外键的关系叫依赖表</p><p>外部码的取值只有两种情况：</p><ol><li>取空值；</li><li>取参照关系中的主码值。</li></ol><p>当用户的删除或修改操作违反了上述规则时，如何保持此种约束呢？SQL 中提供了五种可选方案供数据库实现者使用：</p><ul><li>NO ACTION（无影响）</li><li>CASCADE（级联方式）</li><li>RESTRICT（受限方式）</li><li>SET NULL（置空值）</li><li>SET DEFAULT（置缺省值）</li></ul><p><strong>检查约束</strong></p><p>对单个关系的<strong>元组</strong>值加以约束。</p><p>对表内元组说明约束时，在 CREATE TABLE 语句中的属性表、主码、外部码的说明之后加上 <strong>CHECK</strong> 子句。</p><p>每当对元组进行插入或修改操作时，都要对 CHECK 子句的条件表达式求值，如果条件为假，违背了约束，系统将拒绝该插入或修改操作。</p><p>CHECK 子句的一般格式为： <code>CHECK &lt;条件></code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CHECK</span><span class=w> </span><span class=p>(</span><span class=n>weight</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=mi>80</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=p>(</span><span class=n>color</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;red&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>200</span><span class=p>)</span><span class=w> </span><span class=k>or</span><span class=w> </span><span class=p>(</span><span class=n>color</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=s1>&#39;red&#39;</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>weight</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=mi>400</span><span class=p>))</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h5 id=断言>断言</h5><blockquote><p>复杂情况下用</p></blockquote><p>如果完整性约束与多个关系有关，或者与聚合操作有关，SQL 提供 “断言”（Assertions）机制让用户书写完整性约束。</p><p>定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>ASSERTION</span><span class=w> </span><span class=err>断言名</span><span class=w> </span><span class=k>CHECK</span><span class=err>（条件）</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>撤消：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>DROP</span><span class=w> </span><span class=k>ASSERTION</span><span class=w> </span><span class=err>断言名</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224400263.png alt=image-20220516224400263 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224612538.png alt=image-20220516224612538 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224414554.png alt=image-20220516224414554 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220516224425631.png alt=image-20220516224425631 style=zoom:39%><p>断言也可以在关系定义中用检查子句形式定义，但是检查子句不一定能保证完整性约束彻底实现，而断言能保证不出差错。</p><h4 id=sql3-的触发器>SQL3 的触发器</h4><p><strong>定义</strong></p><ul><li>触发器（Trigger）不仅能实现完整性规则，而且能保证一些较复杂业务规则的实施。</li><li>所谓触发器就是一类由事件驱动的特殊过程，一旦由某个用户定义，任何用户对该触发器指定的数据进行增、删或改操作时，系统将<strong>自动</strong>激活相应的触发器，在核心层进行集中的完整性控制。</li></ul><p><strong>触发器结构分三部分</strong></p><ul><li><strong>事件</strong>：对数据库的插入、删除和修改等操作。</li><li><strong>条件</strong>：触发器将测试条件是否成立。</li><li><strong>动作</strong>：如果测试满足预定的条件，就由 DBM S 执行这些动作。</li></ul><p><strong>触发器结构组成</strong></p><p>触发事件包括表中行的插入、删除和修改，即执行 INSERT、DELETE、UPDATE 语句</p><p>在修改操作（UPDATE）中，还可以指定，特定的属性或属性组的修改为触发条件。</p><p>事件的触发还有两个相关的时间：Before 和 After。Before 触发器是在事件发生之前触发，After 触发器是在事件发生之后触发。</p><p>触发动作实际上是一系列 SQL 语句，可以有两种方式：</p><ol><li>对被事件影响的每一行（FOR EACH ROW）——每一元组执行触发过程，称为行级触发器。</li><li>对整个事件只执行一次触发过程（FOR EACH STATEMENT）称为语句级触发器。该方式是触发器的默认方式。所以综合触发时间和触发方式，触发器的基本类型如下表所示。</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153502055.png alt=image-20220517153502055 style=zoom:50%><h5 id=实例>实例</h5><h6 id=一>一</h6><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153550774.png alt=image-20220517153550774 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153613756.png alt=image-20220517153613756 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153620490.png alt=image-20220517153620490 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153626559.png alt=image-20220517153626559 style=zoom:67%><h6 id=二>二</h6><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517160117909.png alt=image-20220517160117909 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517153714566.png alt=image-20220517153714566 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220517160156102.png alt=image-20220517160156102 style=zoom:67%><h4 id=sql-server-的数据库完整性及实现方法>SQL Server 的数据库完整性及实现方法</h4><p>SQL Server 具有较健全的数据库完整性控制机制。</p><p>SQL Server 使用约束、缺省，规则和触发器 4 种方法</p><p>定义和实施数据库完整性功能。</p><h3 id=数据库的安全性>数据库的安全性</h3><blockquote><p>安全性 vs 完整性：前者，<strong>非法，蓄意</strong>；后者，<strong>合法，无意</strong></p></blockquote><p>定义：是指保护 DB，防止不合法的使用，以免数据的泄漏、非法更改和破坏。</p><h4 id=安全性级别>安全性级别</h4><p>环境级、职员级、OS 级、网络级、DBS 级</p><blockquote><p>这里只讨论 DBS 级的安全性问题。</p></blockquote><h4 id=权限>权限</h4><p>定义：用户使用数据库的方式。</p><p>内容</p><ul><li><p>访问 DB 的权限：读 ，插入，修改，删除 权限</p></li><li><p>修改 DB 的权限：索引，资源（创建新关系），修改，撤销 权限</p></li></ul><p>方式</p><ul><li>授权：可根据需要把在某对象上的某些权限授予特定的用户。</li><li>转授：若拥有转授权，则允许把已获得的权限再转授给其他用户。</li><li>回收：也可以撤消已授给某用户的某些权限</li></ul><h4 id=安全性和授权>安全性和授权</h4><p>安全性由两个机制提供：<strong>视图</strong>和<strong>授权子系统</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>GRANT</span><span class=w> </span><span class=o>&lt;</span><span class=err>权限表</span><span class=o>&gt;</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=o>&lt;</span><span class=err>数据库元素</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=k>TO</span><span class=o>&lt;</span><span class=err>用户名表</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=p>[</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=k>GRANT</span><span class=w> </span><span class=k>OPTION</span><span class=err>］</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>所有权限：</span><span class=k>ALL</span><span class=w> </span><span class=k>PRIVILEGES</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=err>数据库元素：关系，视图，域（域名前加</span><span class=w> </span><span class=k>DOMAIN</span><span class=err>）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>#</span><span class=w> </span><span class=k>WITH</span><span class=w> </span><span class=k>GRANT</span><span class=w> </span><span class=k>OPTION</span><span class=p>:</span><span class=w> </span><span class=err>可以传递权限</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>REVOKE</span><span class=w> </span><span class=o>&lt;</span><span class=err>权限表</span><span class=o>&gt;</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=o>&lt;</span><span class=err>数据库元素</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>FROM</span><span class=o>&lt;</span><span class=err>用户名表</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=p>[</span><span class=w> </span><span class=k>RESTRICT</span><span class=o>|</span><span class=k>CASCADE</span><span class=w> </span><span class=p>]</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=err>回收权限</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>REVOKE</span><span class=w> </span><span class=k>GRANT</span><span class=w> </span><span class=k>OPTION</span><span class=w> </span><span class=k>FOR</span><span class=w> </span><span class=p>...</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=err>回收转授出去的转让权限</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=数据加密>数据加密</h4><p>定义：数据存储和传输时采用加密技术</p><p>数据加、 解密的代价也不小。 因此，DBMS 往往把加密特性作为一种可选功能,由用户决定是否选用。 如果选用了加密功能，用户必须要保管好自己的加密密钥和解密密钥，不能失去或泄露。</p><blockquote><p>数据的安全性和完整性是两个不同的概念。</p><p>数据的安全性是防止数据库被恶意破坏和非法存取，而数据完整性是为了防止错误信息的输入，保证数据库中的数据符合应用环境的语义要求。</p><p>安全性措施的防范对象是非法用户和非法操作，而完整性措施的防范对象是不合语义的数据。</p></blockquote><h4 id=自然环境的安全性>自然环境的安全性</h4><p>DBS 的设备、硬件和环境的安全性</p><h2 id=对象关系数据库>对象关系数据库</h2><h3 id=db-技术发展过程>DB 技术发展过程</h3><h4 id=数据模型的演变过程>数据模型的演变过程</h4><ul><li><strong>平面关系模型</strong>：属性不可分，都是基本数据类型</li><li><strong>嵌套关系模型</strong>：属性可以是基本数据类型，也可以是关系类型（表），且数据结构可以多次嵌套。</li><li><strong>复合对象模型</strong>：属性可以是基本数据类型，也可以是关系类型，还可以是元组类型，且数据结构可以多次嵌套。</li><li><strong>面向对象模型</strong>：在复合对象模型的基础上，数据结构的嵌套采用引用（指针）方式，并且引入面向对象技术的继承性等概念。</li></ul><h4 id=查询语言的演变>查询语言的演变</h4><p>主要指 SELECT 语句的演变过程</p><ul><li><p>RDB (关系型数据库) 中的 SELECT 语句：由六个子句构成</p></li><li><p>ORDB (面向关系型数据库) 中的 SELECT 语句 (SQL3 标准)：引入了路径表达式、嵌套与解除嵌套等概念。</p></li><li><p>OODB (面向对象型数据库) 中的 SELECT 语句 (ODMG 标准 OQL)：有了更多的扩充，并与宿主语言语句混合起来，可以表达更为复杂的查询操作。</p></li></ul><h4 id=概念建模的演变>概念建模的演变</h4><ul><li><p>ER 图：主要用于关系数据库的设计</p></li><li><p>对象联系图：它是 ER 图的扩充，使之能表达对象之间的引用</p></li><li><p>UML 的类图：是一种纯 OO 技术的结构，体现了现实世界数据之间面向对象的各种联系方式。</p></li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529134938840.png alt=image-20220529134938840 style=zoom:50%><h3 id=对象联系图>对象联系图</h3><h4 id=三种模型的表示>三种模型的表示</h4><blockquote><p>集合是类，元组是对象</p></blockquote><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529135236469.png alt=image-20220529135236469 style=zoom:67%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529135401326.png alt=image-20220529135401326 style=zoom:67%><h4 id=嵌套的关系结构描述>嵌套的关系结构描述</h4><p>定义 <code>Dept(dno,dname,staff(empno,ename,age))</code> 的嵌套关系</p><p>方法 1：类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>type</span><span class=w> </span><span class=n>DeptRel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>relation</span><span class=p>(</span><span class=n>dno</span><span class=p>:</span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>dname</span><span class=p>:</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>staff</span><span class=p>:</span><span class=n>EmpRel</span><span class=p>);</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>定义车间类型</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span><span class=w> </span><span class=n>EmpRel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>relation</span><span class=p>(</span><span class=n>empno</span><span class=p>:</span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>ename</span><span class=p>:</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=p>:</span><span class=nb>integer</span><span class=p>);</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>定义职员类型</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>persistent</span><span class=w> </span><span class=n>var</span><span class=w> </span><span class=n>Dept</span><span class=p>:</span><span class=n>DeptRel</span><span class=w> </span><span class=o>#</span><span class=w> </span><span class=err>持久变量形式说明</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>方法 2：先元组，再类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>type</span><span class=w> </span><span class=n>DeptTup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tuple</span><span class=p>(</span><span class=n>dno</span><span class=p>:</span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>dname</span><span class=p>:</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>staff</span><span class=p>:</span><span class=n>EmpRel</span><span class=p>);</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>定义车间元组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span><span class=w> </span><span class=n>EmpTup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tuple</span><span class=p>(</span><span class=n>empno</span><span class=p>:</span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>ename</span><span class=p>:</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=p>:</span><span class=nb>integer</span><span class=p>);</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>定义职员元组</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span><span class=w> </span><span class=n>DeptRel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>set</span><span class=p>(</span><span class=n>DeptTup</span><span class=p>);</span><span class=w>	</span><span class=o>#</span><span class=w> </span><span class=err>定义车间类型（元组的集合）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span><span class=w> </span><span class=n>EmpRel</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>set</span><span class=p>(</span><span class=n>EmpTup</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>persistent</span><span class=w> </span><span class=n>var</span><span class=w> </span><span class=n>Dept</span><span class=p>:</span><span class=n>DeptRel</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>方法 3：元组 + 集合 set</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>type</span><span class=w> </span><span class=n>DeptTup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tuple</span><span class=p>(</span><span class=n>dno</span><span class=p>:</span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>dname</span><span class=p>:</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>staff</span><span class=p>:</span><span class=k>set</span><span class=p>(</span><span class=n>EmpTup</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>type</span><span class=w> </span><span class=n>EmpTup</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>tuple</span><span class=p>(</span><span class=n>empno</span><span class=p>:</span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>ename</span><span class=p>:</span><span class=n>string</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=p>:</span><span class=nb>integer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>persistent</span><span class=w> </span><span class=n>var</span><span class=w> </span><span class=n>Dept</span><span class=p>:</span><span class=k>set</span><span class=p>(</span><span class=n>DeptTup</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=引用类型>引用类型</h4><p>嵌套关系和符合对象<strong>无法表达递归结构</strong>；</p><p>以下的类型构造不合法：</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529140813875.png alt=image-20220529140813875 style=zoom:50%><p>可以采用<strong>引用</strong>技术解决类型定义中的递归问题。利用<strong>指针</strong>（对象标识），指向关系。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529140850536.png alt=image-20220529140850536 style=zoom:50%><h4 id=对象联系图的成分>对象联系图的成分</h4><table><thead><tr><th>名称</th><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>椭圆</td><td></td><td>对象 / 实体</td></tr><tr><td>小圆圈</td><td>$\bigcirc$</td><td>基本数据类型（整型、实型、字符串型）属性</td></tr><tr><td>椭圆间的边</td><td></td><td>“引用”</td></tr><tr><td>单箭头</td><td>$\rightarrow$</td><td>单值属性</td></tr><tr><td>双箭头</td><td>$\rightarrow\rightarrow$</td><td>多值属性</td></tr><tr><td>双线箭头</td><td>$\Rightarrow$</td><td>子类 $\Rightarrow$ 超类</td></tr><tr><td>双向箭头</td><td>$\longleftrightarrow$</td><td>两属性间的逆联系</td></tr></tbody></table><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Snipaste_2022-06-01_21-20-55.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Snipaste_2022-06-01_21-20-55.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Snipaste_2022-06-01_21-20-55.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Snipaste_2022-06-01_21-20-55.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/Snipaste_2022-06-01_21-20-55.png title=Snipaste_2022-06-01_21-20-55></p><h4 id=数据的泛化--细化>数据的泛化 / 细化</h4><p>数据的泛化 / 细化：对概念之间联系进行抽象的一种方法</p><ol><li>超类是子类的泛化，子类是超类的细化。</li><li>超类型：较高层的对象；子类型：较低层的对象。具有继承性。</li><li>泛化 / 细化联系：泛化边 (双线箭头)；泛化边：子类 $\Rightarrow$超类。</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529141729308.png alt=image-20220529141729308 style=zoom:50%><h3 id=面向对象的数据类型>面向对象的数据类型</h3><h4 id=基本类型>基本类型</h4><p>整型，浮点型，字符，字符串，布尔型，枚举型。</p><h4 id=复合类型>复合类型</h4><table><thead><tr><th>类型</th><th>类型</th><th>顺序</th><th>重复性</th><th>元素个数</th><th>例子</th></tr></thead><tbody><tr><td>行 / 元组 / 结构 / 对象类型</td><td><strong>不同</strong></td><td>有序</td><td></td><td></td><td>日期 (1,October,2007)</td></tr><tr><td>数组类型</td><td>相同</td><td>有序</td><td>可重复</td><td><strong>预置</strong></td><td>[1,2,1] $\ne$ [2,1,1]</td></tr><tr><td>列表类型</td><td>相同</td><td>有序</td><td>可重复</td><td>未预置</td><td>{1,2,1} $\ne$ {2,1,1}</td></tr><tr><td>包 / 多集类型</td><td>相同</td><td><strong>无序</strong></td><td>可重复</td><td>未预置</td><td>{1,2,1} = {2,1,1}</td></tr><tr><td>集合 / 关系类型</td><td>相同</td><td><strong>无序</strong></td><td><strong>不可重复</strong></td><td>未预置</td><td>{1,2} = {2,1}</td></tr></tbody></table><p>后四行统称 “<strong>聚集类型</strong>”；数据类型可以嵌套。</p><h4 id=引用类型-1>引用类型</h4><p>数据类型的定义只能嵌套，若要允许递归，就要前面提到的引用类型 。</p><h3 id=ordb-的定义语言>ORDB 的定义语言</h3><h4 id=ordb>ORDB</h4><ul><li><p><strong>对象关系数据模型</strong> (ORDB)：在传统的关系数据模型基础上，提供元组、数组、集合一类丰富的数据类型以及处理新的数据类型操作的能力，并且有继承性和对象标识等面向对象特点。</p></li><li><p>对象关系数据库系统：基于对象关系数据模型的 DBS。</p></li></ul><h4 id=数据类型>数据类型</h4><p>复合类型有下列四种：</p><ol><li>结构类型：不同类型元素的有序集合称为结构。</li><li>数组类型：同类元素的有序集合，称为数组（array）。</li><li>多集类型：同类元素的无序集合（有的成员可多次出现），称为多集（multiset）。</li><li>集合类型：同类元素的无序集合（每个成员只能出现一次），称为集合（set）。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>MyString</span><span class=w> </span><span class=nb>char</span><span class=w> </span><span class=nb>varying</span><span class=p>;</span><span class=w>			    </span><span class=cm>/*定义变长字符串类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=nb>DATE</span><span class=p>(</span><span class=k>day</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=k>month</span><span class=w> </span><span class=nb>char</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span><span class=w> </span><span class=k>year</span><span class=w> </span><span class=nb>integer</span><span class=p>);</span><span class=w>	</span><span class=cm>/*定义结构类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>NameArray</span><span class=w> </span><span class=n>MyString</span><span class=p>[</span><span class=mi>10</span><span class=p>];</span><span class=w>			    </span><span class=cm>/*定义数组类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w>	</span><span class=n>StudentGrade</span><span class=w> </span><span class=n>multiset</span><span class=p>(</span><span class=nb>integer</span><span class=p>);</span><span class=w>		</span><span class=cm>/*定义包/多集类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>CourseList</span><span class=w> </span><span class=k>setof</span><span class=p>(</span><span class=n>MyString</span><span class=p>);</span><span class=w>			</span><span class=cm>/*定义集合类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*使用中间变量，建立表类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>CourseGrade</span><span class=w> </span><span class=p>(</span><span class=n>course</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>grade</span><span class=w> </span><span class=nb>integer</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>StudentCourse</span><span class=w> </span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>cg</span><span class=w> </span><span class=k>setof</span><span class=p>(</span><span class=n>CourseGrade</span><span class=p>));</span><span class=w> </span><span class=cm>/*定义嵌套类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>sc</span><span class=w> </span><span class=k>of</span><span class=w> </span><span class=k>Type</span><span class=w> </span><span class=n>StudentCourse</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*不使用中间变量，建立表类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>sc</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>cg</span><span class=w> </span><span class=k>setof</span><span class=p>(</span><span class=n>course</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>grade</span><span class=w> </span><span class=nb>integer</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=继承性>继承性</h4><p>继承性可以发生在类型一级或表一级。</p><h5 id=类型级的继承性>类型级的继承性</h5><p>数据类型之间的子类型与超类型的联系</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=cm>/*超类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>Person</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>social_number</span><span class=w> </span><span class=nb>integer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*子类型*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>Student</span><span class=p>(</span><span class=n>degree</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>MyString</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 					</span><span class=k>under</span><span class=w> </span><span class=n>Person</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>Teacher</span><span class=p>(</span><span class=n>salary</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=n>department</span><span class=w> </span><span class=n>MyString</span><span class=err>）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>under</span><span class=w> </span><span class=n>Person</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529143216215.png alt=image-20220529143216215 style=zoom:67%><h5 id=表级的继承性>表级的继承性</h5><p>在表级实现继承性（子表与超表的联系）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=cm>/*超表*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>People</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>social_number</span><span class=w> </span><span class=nb>integer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*子表*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>Students</span><span class=p>(</span><span class=n>degree</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>department</span><span class=w> </span><span class=n>MyString</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> 					</span><span class=k>under</span><span class=w> </span><span class=n>People</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>Teachers</span><span class=p>(</span><span class=n>salary</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=n>department</span><span class=w> </span><span class=n>MyString</span><span class=err>）</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>under</span><span class=w> </span><span class=n>People</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529143306666.png alt=image-20220529143306666 style=zoom:67%><p>子表和超表应满足下列两个一致性要求</p><ol><li><strong>超表</strong>中每个元组最多可以与<strong>每个子表</strong>中的一个元组对应。</li><li><strong>子表</strong>中每个元组在超表中恰有一个元组对应，并在继承的属性上有相同的值。</li></ol><h4 id=引用类型-2>引用类型</h4><p>在嵌套引用时，不是引用对象本身的值，是引用对象标识符（即 “指针” 的概念）</p><p>利用 ref (表名) 表示引用类型，即地址。以此实现递归。若集合类型，需加 <code>setof()</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>MyString</span><span class=w> </span><span class=nb>char</span><span class=w> </span><span class=nb>varying</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>dpept</span><span class=p>(</span><span class=n>dno</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>dname</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>staff</span><span class=w> </span><span class=k>setof</span><span class=p>(</span><span class=k>ref</span><span class=p>(</span><span class=n>emp</span><span class=p>)));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>emp</span><span class=p>(</span><span class=n>empno</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>ename</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>age</span><span class=w> </span><span class=nb>integer</span><span class=p>,</span><span class=w> </span><span class=n>works_for</span><span class=w> </span><span class=k>setof</span><span class=p>(</span><span class=k>ref</span><span class=p>(</span><span class=n>dept</span><span class=p>)));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=ordb-的查询语言>ORDB 的查询语言</h3><h4 id=select-语句>SELECT 语句</h4><p>扩充 SQL 对 SELECT 语句的使用规定</p><ol><li><p>允许用于计算关系的表达式出现在任何关系名可以出现的地方。</p></li><li><p>每个基本表设置一个元组变量，然后才可引用</p><ul><li><strong>在 FROM 子句中要为每个关系定义一个元组变量。</strong></li><li>如：<code>e.g. FROM university as U</code></li></ul></li><li><p>当属性值为单值或结构值时，属性的引用方式仍和传统的关系模型一样，在层次之间加点 <code>.</code></p><ul><li><strong>university 的 president 属性，只有一个 faculty 元组与之对应。</strong></li><li>**<code>U.president.fname √</code> **</li></ul></li><li><p>当路径中某个属性值为集合时，就不能连着写下去, 必须定义元组变量。</p><ul><li><strong>university 的 staff 属性，有多个 faculty 元组与之对应，不能直接获取属性值。</strong></li><li><strong><code>U.staff.frame ×</code></strong></li></ul></li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20220529144911788.png alt=image-20220529144911788 style=zoom:50%><blockquote><p>sap PPT 就到这里了</p></blockquote><h4 id=嵌套与解除嵌套>嵌套与解除嵌套</h4><blockquote><p>例：检索使用本校教材开课的教师工号、姓名及所在学校：</p></blockquote><p>“接触嵌套”：将一个嵌套关系转换成 1NF 的过程。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w>  </span><span class=n>A</span><span class=p>.</span><span class=n>uname</span><span class=err>，</span><span class=n>B</span><span class=p>.</span><span class=n>fno</span><span class=err>，</span><span class=n>B</span><span class=p>.</span><span class=n>fname</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w>  </span><span class=n>university</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>A</span><span class=err>，</span><span class=n>A</span><span class=p>.</span><span class=n>staff</span><span class=w> </span><span class=k>as</span><span class=w>  </span><span class=n>B</span><span class=err>，</span><span class=n>B</span><span class=p>.</span><span class=n>teach</span><span class=w>  </span><span class=k>as</span><span class=w>  </span><span class=k>C</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w>  </span><span class=k>C</span><span class=p>.</span><span class=n>editor</span><span class=p>.</span><span class=n>uname</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>uname</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>“嵌套”：将一个 1NF 关系转化为嵌套关系。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=cm>/* 利用set 和 group by 实现嵌套*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w>  </span><span class=n>A</span><span class=p>.</span><span class=n>uname</span><span class=err>，</span><span class=k>set</span><span class=p>(</span><span class=n>B</span><span class=p>.</span><span class=n>fno</span><span class=err>，</span><span class=n>B</span><span class=p>.</span><span class=n>fname</span><span class=p>)</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>teachers</span><span class=w>	
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>university</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>A</span><span class=p>,</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>staff</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>B</span><span class=p>,</span><span class=w> </span><span class=n>B</span><span class=p>.</span><span class=n>teach</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=k>C</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=k>C</span><span class=p>.</span><span class=n>editor</span><span class=p>.</span><span class=n>uname</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>uname</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>uname</span><span class=err>；</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=函数的定义和使用>函数的定义和使用</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=cm>/*定义类型 和 表*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>StudentCourseGrade</span><span class=p>(</span><span class=n>name</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>cg</span><span class=w> </span><span class=k>setof</span><span class=p>(</span><span class=n>course</span><span class=w> </span><span class=n>MyString</span><span class=p>,</span><span class=w> </span><span class=n>grade</span><span class=w> </span><span class=nb>integer</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>sc</span><span class=w> </span><span class=k>of</span><span class=w> </span><span class=k>TYPE</span><span class=w> </span><span class=n>StudentCourseGrade</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=cm>/*定义函数*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>course_count</span><span class=p>(</span><span class=n>one_student</span><span class=w> </span><span class=n>StudentCourseGrade</span><span class=p>)</span><span class=w> </span><span class=cm>/*参数类型:Student CourseGrade*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>RETURNS</span><span class=w> </span><span class=nb>integer</span><span class=w> </span><span class=k>AS</span><span class=w>	</span><span class=cm>/*返回值*/</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=n>B</span><span class=p>.</span><span class=n>cg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>one_student</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>B</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=复合值的创建和查询>复合值的创建和查询</h4><p>INSERT 复合值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>sc</span><span class=w> </span><span class=k>VALUES</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;ZHANG&#39;</span><span class=p>,</span><span class=w> </span><span class=k>set</span><span class=p>((</span><span class=s1>&#39;DB&#39;</span><span class=p>,</span><span class=mi>80</span><span class=p>),(</span><span class=s1>&#39;OS&#39;</span><span class=p>,</span><span class=mi>85</span><span class=p>)));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>SELECT 复合值</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=cm>/*检索 WANG LIU ZHANG三位学生选修的课程门数 */</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=k>count</span><span class=p>(</span><span class=n>A</span><span class=p>.</span><span class=n>cg</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=n>sc</span><span class=w> </span><span class=k>as</span><span class=w> </span><span class=n>A</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>WHERE</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>name</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=k>set</span><span class=p>(</span><span class=s1>&#39;WANG&#39;</span><span class=p>,</span><span class=s1>&#39;LIU&#39;</span><span class=p>,</span><span class=s1>&#39;ZHANG&#39;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>A</span><span class=p>.</span><span class=n>name</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-04-24 13:06:13">更新于 2023-04-24</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C/ data-title=数据库原理（2） data-hashtags=数据库><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C/ data-hashtag=数据库><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/courses/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E4%BA%8C/ data-title=数据库原理（2）><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/%E5%88%B7%E9%A2%98/%E6%8A%80%E5%B7%A7/ class=prev rel=prev title=算法技巧><i class="fa-solid fa-angle-left fa-fw"></i>算法技巧</a>
<a href=/Notes/posts/useful/%E9%85%8D%E7%BD%AE-typora/ class=next rel=next title="配置 typora">配置 typora<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>