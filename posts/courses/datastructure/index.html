<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>数据结构 - 伤心肠粉的酱油碟子</title><meta name=Description content><meta property="og:title" content="数据结构"><meta property="og:description" content="数据结构 定义 数据元素（Data Element）：数据的基本单位 数据项（Data I"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/courses/datastructure/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-03-22T15:31:57+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据结构"><meta name=twitter:description content="数据结构 定义 数据元素（Data Element）：数据的基本单位 数据项（Data I"><meta name=application-name content="伤心肠粉的酱油碟子"><meta name=apple-mobile-web-app-title content="伤心肠粉的酱油碟子"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/courses/datastructure/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/homework/database/ex2/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/courses/digitalimageprocessing/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"数据结构","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/courses\/datastructure\/"},"genre":"posts","keywords":"数据结构, 算法","wordcount":22166,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/courses\/datastructure\/","datePublished":"2021-11-25T00:00:00+00:00","dateModified":"2022-03-22T15:31:57+00:00","publisher":{"@type":"Organization","name":"MelonCholi"},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":''==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:''==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/Notes/categories/>分类 </a><a class=menu-item href=/Notes/tags/>标签 </a><a class=menu-item href=/Notes/posts/>文章 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子>伤心肠粉</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/Notes/categories/ title>分类</a><a class=menu-item href=/Notes/tags/ title>标签</a><a class=menu-item href=/Notes/posts/ title>文章</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">数据结构</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/Notes/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>MelonCholi</a></span>&nbsp;<span class=post-category>收录于 <a href=/Notes/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/><i class="far fa-folder fa-fw"></i>专业课</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-11-25>2021-11-25</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 22166 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 45 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#定义>定义</a></li><li><a href=#构成>构成</a></li></ul><ul><li><a href=#特质>特质</a></li><li><a href=#描述>描述</a></li><li><a href=#评估>评估</a></li><li><a href=#复杂度>复杂度</a><ul><li><a href=#时间复杂度>时间复杂度</a></li><li><a href=#空间复杂度>空间复杂度</a></li></ul></li></ul><ul><li><a href=#定义-1>定义</a></li><li><a href=#基本操作>基本操作</a></li><li><a href=#顺序表sequential-list>顺序表（Sequential List）</a><ul><li><a href=#类模板定义>类模板定义</a></li><li><a href=#具体实现>具体实现</a><ul><li><a href=#构造函数>构造函数</a></li><li><a href=#插入元素>插入元素</a></li><li><a href=#删除元素>删除元素</a></li></ul></li><li><a href=#复杂度分析>复杂度分析</a></li></ul></li><li><a href=#链表>链表</a><ul><li><a href=#单链表>单链表</a><ul><li><a href=#结点类模板定义>结点类模板定义</a></li><li><a href=#结点实现>结点实现</a></li><li><a href=#链表类模板定义>链表类模板定义</a></li></ul></li><li><a href=#双向循环链表>双向循环链表</a></li><li><a href=#静态链表>静态链表</a></li></ul></li></ul><ul><li><a href=#栈>栈</a><ul><li><a href=#顺序栈>顺序栈</a><ul><li><a href=#类模板定义-1>类模板定义</a></li><li><a href=#具体定义>具体定义</a></li><li><a href=#共享存储空间的双顺序栈>共享存储空间的双顺序栈</a></li></ul></li><li><a href=#链式栈>链式栈</a><ul><li><a href=#类模板定义-2>类模板定义</a></li><li><a href=#具体实现-1>具体实现</a></li></ul></li></ul></li><li><a href=#队列>队列</a><ul><li><a href=#循环队列>循环队列</a><ul><li><a href=#顺序队列类模板定义>顺序队列类模板定义</a></li><li><a href=#具体定义-1>具体定义</a></li></ul></li><li><a href=#链式队列>链式队列</a><ul><li><a href=#类模板定义-3>类模板定义</a></li><li><a href=#具体定义-2>具体定义</a></li></ul></li></ul></li><li><a href=#递归>递归</a><ul><li><a href=#递归转换为非递归>递归转换为非递归</a><ul><li><a href=#尾递归和单项递归的消除>尾递归和单项递归的消除</a></li><li><a href=#用栈模拟系统运行时的栈>用栈模拟系统运行时的栈</a></li></ul></li></ul></li></ul><ul><li><a href=#字符串>字符串</a><ul><li><a href=#定义-2>定义</a></li><li><a href=#模式匹配>模式匹配</a><ul><li><a href=#brute-force-算法>Brute-Force 算法</a></li><li><a href=#kmp-算法>KMP 算法</a></li></ul></li></ul></li><li><a href=#数组>数组</a></li><li><a href=#稀疏矩阵>稀疏矩阵</a><ul><li><a href=#矩阵的压缩存储>矩阵的压缩存储</a></li><li><a href=#三元组>三元组</a></li><li><a href=#三元组顺序表>三元组顺序表</a><ul><li><a href=#类模板定义-4>类模板定义</a></li><li><a href=#具体定义-3>具体定义</a></li></ul></li><li><a href=#三元组的十字链表>三元组的十字链表</a><ul><li><a href=#非零元素结点类模板>非零元素结点类模板</a></li></ul></li></ul></li><li><a href=#广义表>广义表</a><ul><li><a href=#广义链表>广义链表</a><ul><li><a href=#结点类模板定义-1>结点类模板定义</a></li><li><a href=#链表类模板定义-1>链表类模板定义</a></li></ul></li></ul></li></ul><ul><li><a href=#树>树</a><ul><li><a href=#定义-3>定义</a></li><li><a href=#术语>术语</a></li><li><a href=#存储结构>存储结构</a><ul><li><a href=#双亲数组表示法>双亲(数组)表示法</a></li><li><a href=#孩子表示法>孩子表示法</a></li><li><a href=#双亲---孩子表示法>双亲 - 孩子表示法</a></li><li><a href=#孩子---兄弟表示法>孩子 - 兄弟表示法</a></li></ul></li><li><a href=#树森林和二叉树的转换>树、森林和二叉树的转换</a><ul><li><a href=#树转化为二叉树>树转化为二叉树</a></li><li><a href=#森林转化为二叉树>森林转化为二叉树</a></li><li><a href=#二叉树转化为森林>二叉树转化为森林</a></li></ul></li><li><a href=#树的遍历>树的遍历</a><ul><li><a href=#树的先根遍历>树的先根遍历</a></li><li><a href=#树的后根遍历>树的后根遍历</a></li><li><a href=#树的层次遍历>树的层次遍历</a></li></ul></li><li><a href=#森林的遍历>森林的遍历</a><ul><li><a href=#森林的先根遍历>森林的先根遍历</a></li><li><a href=#森林的中根遍历>森林的中根遍历</a></li><li><a href=#森林的后根遍历>森林的后根遍历</a></li></ul></li></ul></li><li><a href=#二叉树>二叉树</a><ul><li><a href=#定义-4>定义</a></li><li><a href=#性质>性质</a></li><li><a href=#遍历>遍历</a><ul><li><a href=#先序遍历>先序遍历</a></li><li><a href=#中序遍历>中序遍历</a></li><li><a href=#后序遍历>后序遍历</a></li><li><a href=#层序遍历>层序遍历</a></li><li><a href=#遍历的用途>遍历的用途</a></li><li><a href=#遍历的-c-写法>遍历的 C++ 写法</a></li></ul></li><li><a href=#定义-5>定义</a><ul><li><a href=#类模板定义-5>类模板定义</a></li><li><a href=#具体定义-4>具体定义</a></li></ul></li></ul></li><li><a href=#线索二叉树>线索二叉树</a><ul><li><a href=#查找结点的前驱和后继算法>查找结点的前驱和后继算法</a></li></ul></li><li><a href=#堆>堆</a><ul><li><a href=#定义-6>定义</a><ul><li><a href=#向下调整-filterdown>向下调整 FilterDown</a></li></ul></li></ul></li><li><a href=#哈夫曼树>哈夫曼树</a><ul><li><a href=#术语-1>术语</a></li><li><a href=#定义-7>定义</a></li><li><a href=#哈夫曼编码>哈夫曼编码</a></li></ul></li><li><a href=#等价类及其表示并查集>等价类及其表示(并查集)</a><ul><li><a href=#合并算法的改进>合并算法的改进</a></li><li><a href=#类模板定义-6>类模板定义</a></li><li><a href=#具体定义-5>具体定义</a></li></ul></li></ul><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#存储结构-1>存储结构</a><ul><li><a href=#邻接矩阵>邻接矩阵</a><ul><li><a href=#概念>概念</a></li><li><a href=#无向图的邻接矩阵>无向图的邻接矩阵</a><ul><li><a href=#类模板定义-7>类模板定义</a></li></ul></li></ul></li><li><a href=#邻接表>邻接表</a></li><li><a href=#邻接多重表>邻接多重表</a></li><li><a href=#十字链表>十字链表</a></li></ul></li><li><a href=#遍历-1>遍历</a><ul><li><a href=#深度优先遍历-dfs>深度优先遍历 DFS</a><ul><li><a href=#步骤>步骤</a></li><li><a href=#时间复杂度-1>时间复杂度</a></li><li><a href=#实现>实现</a></li></ul></li><li><a href=#广度优先遍历-bfs>广度优先遍历 BFS</a><ul><li><a href=#步骤-1>步骤</a></li><li><a href=#时间复杂度-2>时间复杂度</a></li></ul></li><li><a href=#连通分量>连通分量</a></li></ul></li><li><a href=#最小生成树>最小生成树</a><ul><li><a href=#概念-1>概念</a><ul><li><a href=#生成树>生成树</a></li><li><a href=#最小生成树-1>最小生成树</a></li></ul></li><li><a href=#克鲁斯卡尔算法>克鲁斯卡尔算法</a><ul><li><a href=#步骤-2>步骤</a></li><li><a href=#实现-1>实现</a></li></ul></li><li><a href=#普利姆算法>普利姆算法</a><ul><li><a href=#步骤-3>步骤</a></li></ul></li></ul></li><li><a href=#最短路径>最短路径</a><ul><li><a href=#类别>类别</a></li><li><a href=#弧上权值非负的单源点最短路径>弧上权值非负的单源点最短路径</a><ul><li><a href=#迪杰斯特拉算法dijkstra>迪杰斯特拉算法（Dijkstra）</a></li><li><a href=#实现-2>实现</a></li></ul></li><li><a href=#弧上权值任意值的单源点最短路径>弧上权值任意值的单源点最短路径</a><ul><li><a href=#贝尔曼---福特算法>贝尔曼 - 福特算法</a></li></ul></li><li><a href=#所有点之间的最短路径>所有点之间的最短路径</a><ul><li><a href=#重复迪杰斯特拉>重复迪杰斯特拉</a></li><li><a href=#弗洛伊德floyd算法>弗洛伊德（Floyd）算法</a></li></ul></li></ul></li><li><a href=#活动网络>活动网络</a><ul><li><a href=#用顶点表示活动的网络>用顶点表示活动的网络</a><ul><li><a href=#概念-2>概念</a></li></ul></li><li><a href=#用边表示活动的网络>用边表示活动的网络</a><ul><li><a href=#概念-3>概念</a></li></ul></li></ul></li></ul><ul><li><a href=#基本概念-1>基本概念</a></li><li><a href=#顺序表>顺序表</a><ul><li><a href=#顺序查找>顺序查找</a><ul><li><a href=#一般实现>一般实现</a></li><li><a href=#监视哨实现>监视哨实现</a></li><li><a href=#性能分析>性能分析</a></li></ul></li><li><a href=#二分查找>二分查找</a><ul><li><a href=#迭代实现>迭代实现</a></li><li><a href=#递归实现>递归实现</a></li><li><a href=#性能分析-1>性能分析</a></li></ul></li><li><a href=#分块查找>分块查找</a><ul><li><a href=#索引顺序表>索引顺序表</a></li><li><a href=#分块查找-1>分块查找</a></li></ul></li><li><a href=#倒排表>倒排表</a><ul><li><a href=#链式倒排表>链式倒排表</a></li><li><a href=#单元素倒排表>单元素倒排表</a></li></ul></li><li><a href=#比较>比较</a></li></ul></li><li><a href=#二叉排序树>二叉排序树</a><ul><li><a href=#定义-8>定义</a></li><li><a href=#模板定义>模板定义</a></li><li><a href=#查找-1>查找</a></li><li><a href=#性能分析-2>性能分析</a></li><li><a href=#操作>操作</a><ul><li><a href=#插入>插入</a></li><li><a href=#删除>删除</a></li></ul></li></ul></li><li><a href=#平衡二叉树>平衡二叉树</a><ul><li><a href=#定义-9>定义</a></li><li><a href=#平衡旋转>平衡旋转</a><ul><li><a href=#ll-平衡旋转右单旋转>LL 平衡旋转——右单旋转</a></li><li><a href=#rr-平衡旋转左单旋转>RR 平衡旋转——左单旋转</a></li><li><a href=#lr-平衡旋转先左后右双旋转>LR 平衡旋转——先左后右双旋转</a></li><li><a href=#rl-平衡旋转先右后左双旋转>RL 平衡旋转——先右后左双旋转</a></li></ul></li><li><a href=#插入-1>插入</a><ul><li><a href=#思想>思想</a></li><li><a href=#示例>示例</a></li></ul></li><li><a href=#删除-1>删除</a><ul><li><a href=#思想-1>思想</a></li><li><a href=#示例-1>示例</a></li></ul></li></ul></li><li><a href=#b--树>B- 树</a><ul><li><a href=#动态的-m-路查找树>动态的 m 路查找树</a></li><li><a href=#定义-10>定义</a></li><li><a href=#插入-2>插入</a><ul><li><a href=#思路>思路</a></li><li><a href=#示例-2>示例</a></li></ul></li><li><a href=#删除-2>删除</a></li><li><a href=#b树>B+树</a><ul><li><a href=#定义-11>定义</a></li></ul></li></ul></li><li><a href=#散列表>散列表</a><ul><li><a href=#定义-12>定义</a></li><li><a href=#哈希函数>哈希函数</a><ul><li><a href=#构造方法>构造方法</a></li></ul></li><li><a href=#处理冲突>处理冲突</a><ul><li><a href=#开放地址法>开放地址法</a></li><li><a href=#拉链法>拉链法</a></li></ul></li><li><a href=#哈希查找>哈希查找</a><ul><li><a href=#过程>过程</a></li><li><a href=#分析>分析</a></li></ul></li></ul></li></ul><ul><li><a href=#基础知识>基础知识</a><ul><li><a href=#分组>分组</a></li><li><a href=#排序的存储方式>排序的存储方式</a></li><li><a href=#各种排序方法的选用>各种排序方法的选用</a></li></ul></li><li><a href=#交换排序>交换排序</a><ul><li><a href=#冒泡排序>冒泡排序</a><ul><li><a href=#实现-3>实现</a></li><li><a href=#分析-1>分析</a></li></ul></li><li><a href=#快速排序>快速排序</a><ul><li><a href=#实现-4>实现</a></li><li><a href=#分析-2>分析</a></li></ul></li></ul></li><li><a href=#插入排序>插入排序</a><ul><li><a href=#直接插入排序>直接插入排序</a><ul><li><a href=#实现-5>实现</a></li><li><a href=#分析-3>分析</a></li></ul></li><li><a href=#折半插入排序>折半插入排序</a><ul><li><a href=#实现-6>实现</a></li><li><a href=#分析-4>分析</a></li></ul></li><li><a href=#希尔排序>希尔排序</a><ul><li><a href=#分析-5>分析</a></li></ul></li></ul></li><li><a href=#选择排序>选择排序</a><ul><li><a href=#简单选择排序>简单选择排序</a><ul><li><a href=#实现-7>实现</a></li><li><a href=#分析-6>分析</a></li></ul></li><li><a href=#锦标赛排序>锦标赛排序</a><ul><li><a href=#分析-7>分析</a></li></ul></li><li><a href=#堆排序>堆排序</a></li></ul></li><li><a href=#归并排序>归并排序</a><ul><li><a href=#二路归并排序>二路归并排序</a><ul><li><a href=#实现-8>实现</a></li><li><a href=#分析-8>分析</a></li></ul></li><li><a href=#递归归并>递归归并</a><ul><li><a href=#实现-9>实现</a></li><li><a href=#分析-9>分析</a></li></ul></li></ul></li><li><a href=#基数排序>基数排序</a><ul><li><a href=#链式基数排序>链式基数排序</a><ul><li><a href=#分析-10>分析</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=数据结构>数据结构</h1><h2 id=定义>定义</h2><ul><li>数据元素（Data Element）：数据的基本单位</li><li>数据项（Data Item）：用来描述数据元素，是数据的最小单位</li><li>数据对象：具有相同性质的数据元素集合</li><li>数据结构（Data Structure） = 数据对象 + 结构</li></ul><h2 id=构成>构成</h2><ul><li>逻辑结构<ul><li>集合</li><li>线性结构</li><li>树形结构</li><li>图形结构（网状结构）</li></ul></li></ul><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201130131301667.png alt=image-20201130131301667 style=zoom:67%><ul><li><p>物理结构（存储结构）</p><ul><li>顺序存储：将逻辑上相邻的元素存储在物理位置上也相邻的存储单元中</li><li>链式存储</li><li>索引存储</li><li>散列存储（哈希存储）</li></ul></li><li><p>数据运算</p><p>运算描述针对逻辑结构，运算实现针对存储结构</p></li></ul><h1 id=算法>算法</h1><h2 id=特质>特质</h2><ul><li>有穷性：必须执行有限次运算来实现</li><li>确定性：对于同意输入只能得到相同输出</li><li>有效性：含义明确，规定严格</li><li>输入性：可以有零个或多个输入</li><li>输出性：可以由一个或多个输出</li></ul><h2 id=描述>描述</h2><ul><li><p>自然语言（Natural Language）</p></li><li><p>流程图（FlowChart）</p></li><li><p>类程序设计语言（Similar-programming Language）</p></li></ul><h2 id=评估>评估</h2><ul><li>正确性（Correctness）</li><li>可用性（Usability）</li><li>可读性（Readability）</li><li>健壮性（Robustness）</li><li>效率（Efficiency）：时间代价+空间代价，需要用算法分析（Analytic Method）进行评估</li><li>可移植性（Mobility）</li><li>可测试性（Testability）</li></ul><h2 id=复杂度>复杂度</h2><h3 id=时间复杂度>时间复杂度</h3><p>（Time Complexity）</p><p>时间开销 $$T(n)$$ 与问题规模 $$n$$ 之间的关系</p><ol><li><p>方法</p><ol><li>频度统计法：确定 $$O(f(n))$$</li><li>渐进时间复杂度：知晓级数即可</li></ol></li><li><p>依赖于数据的算法：采用平均复杂度</p></li><li><p>常见的时间复杂度</p><p>常对幂指阶</p><p>$$O(1)&lt;O(\log_2n)&lt;O(n)&lt;O(n\log_2n)&lt;O(n^2)&lt;O(n^3)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$$</p></li></ol><h3 id=空间复杂度>空间复杂度</h3><p>（Space Complexity）</p><p>空间开销（内存开销）$$S(n)$$与问题规模$$n$$之间的关系</p><p>原地工作：算法所需内存空间为常量，即$$S(n)=O(1)$$</p><p>递归调用的空间复杂度=递归调用的深度</p><h1 id=线性表>线性表</h1><h2 id=定义-1>定义</h2><p>n 个<strong>相同类型</strong>数据元素的<strong>有限</strong>序列，记为 $$L=(a_1,a_2,\ldots,a_n)$$</p><p>L 称为表名，n 称为表长，$$a_i$$：第 i 个称为位序，$$a_1$$ 称为首元素，$$a_n$$ 称为末元素</p><p>除首元素，其他元素拥有一个直接前驱；除末元素，其他元素拥有一个直接后继</p><h2 id=基本操作>基本操作</h2><ol><li><p>初始化 InitList(&L)</p></li><li><p>求长度 Length(L)</p></li><li><p>取指定元素的值 GetElem(i, &e)</p></li><li><p>元素定位 Locate(&e)</p></li><li><p>修改指定元素的值 SetElem(i, &e)</p></li><li><p>插入 ListInsert(&L,i,e)</p></li><li><p>删除 ListDelete(&L,i,&e)</p></li><li><p>判断是否是空表 Empty(L)</p></li><li><p>表清空 Clear()</p></li></ol><h2 id=顺序表sequential-list>顺序表（Sequential List）</h2><p>顺序表是用顺序存储的方式来实现的线性表</p><p>若用静态数组，表长一旦确定便不可更改，建议使用动态数组</p><ul><li>特点<ol><li><strong>随机访问</strong>，在 $$O(1)$$ 时间内找到第i个元素</li><li>存储密度高（=1），每个结点只存储数据元素，不记录相对关系，节省空间</li><li>因为设置了最大容量，空间会有富余，较为浪费</li><li>扩展容量不方便</li><li>插入、删除操作不方便，需要移动大量元素</li></ol></li></ul><h3 id=类模板定义>类模板定义</h3><p>第$$i$$个元素的数组索引为 $$i-1$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SeqList</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>DEFAULT_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_length</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_maxlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>*</span><span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SeqList</span><span class=p>(</span><span class=kt>int</span> <span class=n>maxlen</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>);</span>                   <span class=c1>//建立空表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SeqList</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxlen</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>);</span> <span class=c1>//根据数组创建新表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SeqList</span><span class=p>(</span><span class=k>const</span> <span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>);</span>                        <span class=c1>//拷贝构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=o>~</span><span class=n>SeqList</span><span class=p>();</span>                                   <span class=c1>//析构函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>);</span>          <span class=c1>//赋值运算符重载
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ClearList</span><span class=p>();</span>                 <span class=c1>//清空顺序表，暂时不知道有啥用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>            <span class=c1>//返回长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>             <span class=c1>//判空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsFull</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>              <span class=c1>//判满
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DisplayList</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>         <span class=c1>//遍历显示顺序表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>LocateElem</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span> <span class=c1>//元素定位，返回指定元素位置
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>GetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>             <span class=c1>//查找元素，返回查找的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>SetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>    <span class=c1>//修改i位置的元素值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>InsertElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span> <span class=c1>//在i位置插入新元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>InsertElem</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>        <span class=c1>//在末尾插入新元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DeleteElemByIndex</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>);</span>      <span class=c1>//删除i位置的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DeleteElemByValue</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span> <span class=c1>//删除指定元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=具体实现>具体实现</h3><h4 id=构造函数>构造函数</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>::</span><span class=n>SeqList</span><span class=p>(</span><span class=nb>int</span> <span class=n>maxlen</span><span class=p>)</span> <span class=p>:</span> <span class=n>_length</span><span class=p>(</span><span class=mi>0</span><span class=p>),</span> <span class=n>_maxlen</span><span class=p>(</span><span class=n>maxlen</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_data</span> <span class=o>=</span> <span class=n>new</span> <span class=n>T</span><span class=p>[</span><span class=n>_maxlen</span><span class=p>];</span> <span class=o>//</span><span class=n>申请存储空间</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>::</span><span class=n>SeqList</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=nb>int</span> <span class=n>length</span><span class=p>,</span> <span class=nb>int</span> <span class=n>maxlen</span><span class=p>)</span> <span class=p>:</span> <span class=n>_length</span><span class=p>(</span><span class=n>length</span><span class=p>),</span> <span class=n>_maxlen</span><span class=p>(</span><span class=n>maxlen</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_data</span> <span class=o>=</span> <span class=n>new</span> <span class=n>T</span><span class=p>[</span><span class=n>maxlen</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=nb>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=插入元素>插入元素</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>InsertElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsFull</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;线性表已满,不可添加新元素!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;位置不合理！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>_length</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span> <span class=c1>//i后的元素向后移动一格
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>_data</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_length</span><span class=o>++</span><span class=p>;</span> <span class=c1>//总长+1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=删除元素>删除元素</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>DeleteElemByIndex</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;线性表已空,不可删除元素!&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=mi>1</span> <span class=o>||</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>_length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;位置不合理！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>_length</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>_length</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=复杂度分析>复杂度分析</h3><ul><li>在任意位置插入、删除一个数据元素：$$O(n)$$</li><li>定位、遍历、构造函数、重载赋值：$$O(n)$$</li><li>其他函数：$$O(1)$$</li></ul><h2 id=链表>链表</h2><p>（Linked List）</p><p>采用链接存储方式存储的线性表称为线性链表（Linked List），信息域 + 指针域</p><ul><li>特点<ol><li>不要求连续空间，逻辑上相邻的元素，物理上不用相邻</li><li><strong>顺序访问</strong>，下标无助于访存</li><li>插入、删除元素无需大量移动</li><li>易于动态扩展</li><li>存储密度 >1</li></ol></li></ul><h3 id=单链表>单链表</h3><p>一个结点由两个域组成，data域存放数据元素，next域存放指向下一结点的指针</p><p>一般多用带有头结点的单链表（第一个结点为空）</p><p>欲得知已知结点的前结点，需要顺序访问；欲得知已知结点的后结点，仅需使用next指针</p><h4 id=结点类模板定义>结点类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Node</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 数据成员:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>ElemType</span> <span class=n>data</span><span class=p>;</span>		  <span class=c1>// 数据域
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Node</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span> <span class=c1>// 指针域
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>	<span class=c1>// 构造函数:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Node</span><span class=p>();</span>										   <span class=c1>// 无参数的构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Node</span><span class=p>(</span><span class=n>ElemType</span> <span class=n>e</span><span class=p>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>link</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 已知数数据元素值和指针建立结构
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=结点实现>结点实现</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 结点类的实现部分
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Node</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>Node</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>// 操作结果：构造指针域为空的结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>next</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>Node</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;::</span><span class=n>Node</span><span class=p>(</span><span class=n>ElemType</span> <span class=n>e</span><span class=p>,</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>link</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 操作结果：构造一个数据域为e和指针域为link的结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>data</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=n>next</span> <span class=o>=</span> <span class=n>link</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=链表类模板定义>链表类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LinkList</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//  单链表的数据成员
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Node</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>head</span><span class=p>;</span> <span class=c1>// 头结点指针
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=n>length</span><span class=p>;</span>			  <span class=c1>// 单链表长度
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>	<span class=c1>//  单链表的函数成员
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>LinkList</span><span class=p>();</span>													 <span class=c1>// 无参数的构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>LinkList</span><span class=p>(</span><span class=n>ElemType</span> <span class=n>v</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>);</span>								 <span class=c1>// 有参数的构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>virtual</span> <span class=o>~</span><span class=n>LinkList</span><span class=p>();</span>										 <span class=c1>// 析构函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>										 <span class=c1>// 求单链表长度
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>										 <span class=c1>// 判断单链表是否为空
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=nf>Clear</span><span class=p>();</span>												 <span class=c1>// 将单链表清空
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>void</span> <span class=nf>Traverse</span><span class=p>(</span><span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>Visit</span><span class=p>)(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=p>))</span> <span class=k>const</span><span class=p>;</span>		 <span class=c1>// 遍历单链表
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>int</span> <span class=nf>LocateElem</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>					 <span class=c1>// 元素定位
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Status</span> <span class=nf>GetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>,</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>			 <span class=c1>// 求指定位置的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Status</span> <span class=nf>SetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>,</span> <span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>			 <span class=c1>// 设置指定位置的元素值
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Status</span> <span class=nf>DeleteElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>,</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>				 <span class=c1>// 删除元素
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Status</span> <span class=nf>InsertElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>position</span><span class=p>,</span> <span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>			 <span class=c1>// 在制定位置插入元素
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>Status</span> <span class=nf>InsertElem</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>						 <span class=c1>// 在表尾插入元素
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>LinkList</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkList</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>la</span><span class=p>);</span>						 <span class=c1>// 复制构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=n>LinkList</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkList</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>la</span><span class=p>);</span> <span class=c1>// 重载赋值运算
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=双向循环链表>双向循环链表</h3><p>（Double Circular List）</p><h3 id=静态链表>静态链表</h3><p>（Static List）</p><p>用数组方式存储数据，但数据间关系模拟链式存储，适用于不支持指针的语言。</p><h1 id=栈队列和递归>栈、队列和递归</h1><p>栈和队列都是受限的线性表</p><h2 id=栈>栈</h2><p>（Stack）</p><p>限制存取位置的顺序表，只可在表尾位置插入和删除，所谓后进先出（Last In First Out, LIFO）允许插入删除的一端称为栈顶（top），不允许的一端称为栈底（bottom）。</p><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201214080922294.png alt=image-20201214080922294 style=zoom:67%><ul><li>基本操作<ul><li>初始化</li><li>求长度</li><li>取栈顶元素</li><li>进栈（push，也叫压入）</li><li>出栈（pop，也叫弹出）</li><li>判断是否为空栈清空栈</li></ul></li></ul><h3 id=顺序栈>顺序栈</h3><h4 id=类模板定义-1>类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SeqStack</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>DEFAULT_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_top</span><span class=p>;</span> <span class=c1>//_top从0开始
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>_maxlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=o>*</span><span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SeqStack</span><span class=p>(</span><span class=kt>int</span> <span class=n>maxlen</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>);</span>           <span class=c1>//建立空栈
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SeqStack</span><span class=p>(</span><span class=k>const</span> <span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>);</span>               <span class=c1>//拷贝构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=o>~</span><span class=n>SeqStack</span><span class=p>();</span>                           <span class=c1>//析构函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>sa</span><span class=p>);</span> <span class=c1>//赋值运算符重载
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ClearStack</span><span class=p>();</span>         <span class=c1>//清空顺序表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>     <span class=c1>//返回长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsFull</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>       <span class=c1>//判满
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>      <span class=c1>//判空
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DisplayStack</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span> <span class=c1>//遍历显示顺序表
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PushElem</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span> <span class=c1>//入栈
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>T</span> <span class=nf>TopElem</span><span class=p>();</span>               <span class=c1>//取栈顶元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>PopElem</span><span class=p>();</span>            <span class=c1>//出栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=具体定义>具体定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PushElem</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//入栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsFull</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;顺序栈已满！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>_data</span><span class=p>[</span><span class=o>++</span><span class=n>_top</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>TopElem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//取栈顶元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;顺序栈已空，无法取出栈顶元素！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>//return NULL;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>_data</span><span class=p>[</span><span class=n>_top</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PopElem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//出栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;顺序栈已空，无法继续出栈！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_top</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=共享存储空间的双顺序栈>共享存储空间的双顺序栈</h4><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201214083413534.png alt=image-20201214083413534 style=zoom:67%><h3 id=链式栈>链式栈</h3><p>与顺序栈相比，链式栈对于同时使用多个栈的情况下可以共享存储</p><p>用不带头结点的的单链表示链式栈，且头指针表示 top，指向栈顶</p><h4 id=类模板定义-2>类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LinkStack</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=c1>//不设头结点，_top为第一个节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>_top</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>LinkStack</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>la</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>la</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ClearStack</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DisplayStack</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PushElem</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>TopElem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PopElem</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=具体实现-1>具体实现</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PushElem</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//入栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>e</span><span class=p>,</span> <span class=n>_top</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;动态内存耗尽！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>_top</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>TopElem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//取栈顶元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;链式栈已空&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>_top</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PopElem</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//出栈
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;链式栈已空，无法出栈！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>_top</span><span class=p>;</span> <span class=c1>//取旧栈顶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>_top</span> <span class=o>=</span> <span class=n>_top</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span> <span class=c1>//_top指向新栈顶
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>          <span class=c1>//释放旧栈顶空间
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=队列>队列</h2><p>（Queue）</p><p>队列允许在表的一端插入元素，在另一端删除元素，所谓先进先出（First In First Out, FIFO）。允许插入的一端称为队尾（rear），允许删除的一端称为队头（front）。</p><ul><li>操作<ul><li>初始化</li><li>求长度</li><li>取队头元素</li><li>进队</li><li>出队</li><li>判空</li><li>清空队列</li></ul></li></ul><p>约定：front 指向队头元素，rear 指向队尾元素后一个位置</p><h3 id=循环队列>循环队列</h3><p>为了避免假溢出问题，把顺序队列所使用的存储空间构造成一个逻辑上首尾相连的循环队列，称为循环队列。</p><ul><li>假溢出问题的解决方法（主要是判空判满的问题）<ul><li>少用一个存储空间，队满即 <code>(rear + 1) % maxlen == front</code></li><li>不设rear，改设length，队空 <code>length == 0</code>；队满 <code>length == maxlen</code></li><li>新增数据成员flag，队空 <code>flag == 0</code>；队满 <code>flag == maxlen</code></li></ul></li></ul><h4 id=顺序队列类模板定义>顺序队列类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>SeqQueue</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>DEFAULT_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_rear</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_maxlen</span><span class=p>;</span> <span class=c1>//包含被闲置的那一个存储空间，真实供存储的最大值为_maxlen-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>T</span> <span class=o>*</span><span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>SeqQueue</span><span class=p>(</span><span class=kt>int</span> <span class=n>maxlen</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>SeqQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>SeqQueue</span><span class=p>(</span><span class=k>const</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsFull</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ClearQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DisplayQueue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>EnterQueue</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span> <span class=c1>//入队
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>T</span> <span class=nf>GetFront</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>          <span class=c1>//取队头
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DeleteQueue</span><span class=p>();</span>          <span class=c1>//出队
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=具体定义-1>具体定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetLength</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=c1>//当 rear &gt; front 时，长度为 rear-front;当 rear &lt; front 时，长度为(QueueSize-front)+rear
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>_rear</span> <span class=o>-</span> <span class=n>_front</span> <span class=o>+</span> <span class=n>_maxlen</span><span class=p>)</span> <span class=o>%</span> <span class=n>_maxlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>IsEmpty</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_rear</span> <span class=o>==</span> <span class=n>_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>IsFull</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=p>(</span><span class=n>_rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>_maxlen</span> <span class=o>==</span> <span class=n>_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>ClearQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//清空队列，不需要清空存储的元素
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>_rear</span> <span class=o>=</span> <span class=n>_front</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>DisplayQueue</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;队列中无元素！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;从对头到队尾，队列元素依次为：&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>_front</span><span class=p>;</span> <span class=n>i</span> <span class=o>!=</span> <span class=n>_rear</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>_maxlen</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>_data</span><span class=p>[</span><span class=n>_rear</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>EnterQueue</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//入队
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsFull</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;队列已满，无法继续添加元素！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_data</span><span class=p>[</span><span class=n>_rear</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_rear</span> <span class=o>=</span> <span class=p>(</span><span class=n>_rear</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>_maxlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>SeqQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>DeleteQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=c1>//出队
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;队列为空，无法出队！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_front</span> <span class=o>=</span> <span class=p>(</span><span class=n>_front</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)</span> <span class=o>%</span> <span class=n>_maxlen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=链式队列>链式队列</h3><p>链式队列完全避免了假溢出的问题。</p><h4 id=类模板定义-3>类模板定义</h4><p><code>_front</code> 是空的头指针，其下一个元素是队头元素；<code>_rear</code> 指向队尾元素</p><p>初始化时，<code>_rear</code> 等于 <code>_front</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>LinkQueue</span>
</span></span><span class=line><span class=cl><span class=c1>//带头结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>_front</span><span class=p>,</span> <span class=o>*</span><span class=n>_rear</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=o>~</span><span class=n>LinkQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkQueue</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>ClearQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetLength</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DisplayQueue</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>EnterQueue</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>GetFront</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DeleteQueue</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=具体定义-2>具体定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>EnterQueue</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=p>)</span> <span class=c1>//判断系统空间是否足够
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_rear</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_rear</span> <span class=o>=</span> <span class=n>_rear</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;系统空间不足，无法入队！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>T</span> <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetFront</span><span class=p>()</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_front</span><span class=o>-&gt;</span><span class=n>next</span><span class=o>-&gt;</span><span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>DeleteQueue</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;链队列已空，无法出队！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Node</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>_front</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>_front</span><span class=o>-&gt;</span><span class=n>next</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>_rear</span> <span class=o>==</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>_rear</span> <span class=o>=</span> <span class=n>_front</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=递归>递归</h2><p>（Recursion）</p><p>若一个对象部分地包含自己，或用它自己给自己定义，则此对象是递归的。</p><p>若一个过程直接或间接地调用自己，则此过程是递归的过程</p><p>对任意一个递归，需要有<strong>出口</strong>和<strong>同一形式</strong></p><p>步骤</p><ul><li>保留调用信息（返回地址和实参信息）</li><li>分配调用过程所需的数据空间</li><li>将控制转到被调用的子过程</li></ul><p>特点</p><ul><li>不节省时间，也不节省空间</li><li>容易根据定义进行编程</li><li>结构清晰，便于阅读</li></ul><h3 id=递归转换为非递归>递归转换为非递归</h3><p>原因</p><ul><li>递归的时间效率通常比较差</li><li>有些计算机语言不支持递归</li></ul><p>方法</p><ul><li>对于尾递归和单项递归，可用循环结构的算法替代。</li><li>自己用栈来模拟系统运行时的栈（工作记录），保存有关信息。</li></ul><h4 id=尾递归和单项递归的消除>尾递归和单项递归的消除</h4><p>尾递归：递归调用语句只有一个，且在函数最后。（如阶乘）</p><p>单项递归：所有递归调用彼此间参数无关（不套娃），且均在函数最后。（如斐波那契数列）</p><h4 id=用栈模拟系统运行时的栈>用栈模拟系统运行时的栈</h4><h1 id=串数组和广义表>串、数组和广义表</h1><h2 id=字符串>字符串</h2><h3 id=定义-2>定义</h3><p>$$
s=“a_0a_1\ldots a_{n-1}”
$$</p><ul><li><p>空格符也是字符，空格串不是空串</p></li><li><p>当串采用顺序存储时，存储串的数组名指出了串在内存中的首地址</p></li><li><p>C++中存储串的末尾会添加一个结束标识符NULL（编码值为0）</p></li></ul><h3 id=模式匹配>模式匹配</h3><p>（Pattern Matching）</p><p>设 ob 为主串，pat 为模式串，查找 pat 在 ob 的匹配位置的操作称为模式匹配</p><h4 id=brute-force-算法>Brute-Force 算法</h4><p>从主串首字符开始依次匹配，若匹配失败，从第二个字符位开始匹配，以此类推。它是一种带回溯的算法。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>BF_find</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>ob</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>pat</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//查找pat在ob中从位置p开始子串
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>p</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>ob</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>-</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>ob</span><span class=p>.</span><span class=n>length</span><span class=p>()</span> <span class=o>-</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ob</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>])</span><span class=c1>//匹配成功，继续匹配下个字符
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=c1>//匹配失败
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>//i退回到上趟匹配的下个字符位置
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>         <span class=c1>//j从头开始
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>&gt;=</span> <span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>())</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间复杂度（最坏）：$$O(m\sdot n)$$</p><h4 id=kmp-算法>KMP 算法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=nf>KMP</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>ob</span><span class=p>,</span> <span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>pat</span><span class=p>,</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>next</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>pat</span><span class=p>.</span><span class=n>length</span><span class=p>()];</span>
</span></span><span class=line><span class=cl>    <span class=n>GetNext</span><span class=p>(</span><span class=n>pat</span><span class=p>,</span> <span class=n>next</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>start</span><span class=p>,</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>((</span><span class=n>j</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span> <span class=o>||</span> <span class=p>(</span><span class=n>ob</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span> <span class=o>&amp;&amp;</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>j</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>ob</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>++</span><span class=p>;</span> <span class=c1>//继续对下一个字符比较
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>j</span><span class=o>++</span><span class=p>;</span> <span class=c1>//模式串向右滑动
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>next</span><span class=p>[</span><span class=n>j</span><span class=p>];</span> <span class=c1>//寻找新的匹配字符位置，模式串尽可能向右滑动
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>);</span> <span class=c1>//匹配成功返回下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>//匹配失败返回-1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>GetNext</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span> <span class=o>&amp;</span><span class=n>pat</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>next</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//p[k]表示前缀，p[j]表示后缀
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>k</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>next</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>//设next[0]的初始值为-1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>!=</span> <span class=sc>&#39;\0&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>k</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span> <span class=o>||</span> <span class=n>pat</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=n>pat</span><span class=p>[</span><span class=n>k</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span><span class=o>++</span><span class=p>;</span>         <span class=c1>//j,k向后走
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>next</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>k</span><span class=p>;</span> <span class=c1>//记录到此索引前字符串真子串的长度
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span> <span class=o>=</span> <span class=n>next</span><span class=p>[</span><span class=n>k</span><span class=p>];</span> <span class=c1>//寻求新的匹配字符
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=数组>数组</h2><p>数组将线性关系进行扩展（一维变多维）</p><p>数据类型受限</p><h2 id=稀疏矩阵>稀疏矩阵</h2><h3 id=矩阵的压缩存储>矩阵的压缩存储</h3><ul><li>对称矩阵 （$$a_{ij} == a_{ji}$$）：记录三角及对角线</li><li>三对角矩阵（除主对角线及其相邻两条斜线，其余元素均为0）：行列号插值不为1的为0</li><li>稀疏矩阵 （大部分元素为0的矩阵）</li></ul><h3 id=三元组>三元组</h3><p>用（行、列、值）来记录稀疏矩阵中的非零元素</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>Triple</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_row</span><span class=p>,</span> <span class=n>_col</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Triple</span><span class=p>(){};</span>
</span></span><span class=line><span class=cl>    <span class=n>Triple</span><span class=p>(</span><span class=kt>int</span> <span class=n>row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>col</span><span class=p>,</span> <span class=n>T</span> <span class=n>value</span><span class=p>)</span> <span class=o>:</span> <span class=n>_row</span><span class=p>(</span><span class=n>row</span><span class=p>),</span> <span class=n>_col</span><span class=p>(</span><span class=n>col</span><span class=p>),</span> <span class=n>_value</span><span class=p>(</span><span class=n>value</span><span class=p>){};</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=三元组顺序表>三元组顺序表</h3><h4 id=类模板定义-4>类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>TriSparseMatrix</span>
</span></span><span class=line><span class=cl><span class=c1>//三元组顺序表实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>DEFAULT_SIZE</span> <span class=o>=</span> <span class=mi>100</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Triple</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>_data</span><span class=p>;</span>       <span class=c1>//存储三元组的数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>_maxLen</span><span class=p>;</span>            <span class=c1>//非零元素最大个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>_rows</span><span class=p>,</span> <span class=n>_cols</span><span class=p>,</span> <span class=n>_num</span><span class=p>;</span> <span class=c1>//行数、列数、非零元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TriSparseMatrix</span><span class=p>(</span><span class=kt>int</span> <span class=n>rows</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>,</span> <span class=kt>int</span> <span class=n>cols</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxLen</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>TriSparseMatrix</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>TriSparseMatrix</span><span class=p>(</span><span class=k>const</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>copy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>copy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>copy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetRows</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_rows</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetCols</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_cols</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetNum</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_num</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>col</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>GetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>col</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Display</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SimpleTranspose</span><span class=p>(</span><span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span> <span class=c1>//简单转置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>FastTranspose</span><span class=p>(</span><span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>);</span>   <span class=c1>//快速转置
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=具体定义-3>具体定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>SetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>row</span><span class=p>,</span> <span class=kt>int</span> <span class=n>col</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//三种情况：非零变零，零变非零，非零变非零
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>v</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>//若设置非零值为零
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>//找到要设零的非零值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span> <span class=o>==</span> <span class=n>row</span> <span class=o>&amp;&amp;</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span> <span class=o>==</span> <span class=n>col</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>//_data[i] = 0;
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>_num</span><span class=p>)</span> <span class=c1>//说明确实设置了非零数为零
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>_num</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>_num</span><span class=o>--</span><span class=p>;</span> <span class=c1>//非零值个数-1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Triple</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>e</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>,</span> <span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span> <span class=o>==</span> <span class=n>row</span> <span class=o>&amp;&amp;</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span> <span class=o>==</span> <span class=n>col</span><span class=p>)</span> <span class=c1>//修改非零值
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>_num</span><span class=p>)</span> <span class=c1>//设置零值为非零值
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>_data</span><span class=p>[</span><span class=n>_num</span><span class=o>++</span><span class=p>]</span> <span class=o>=</span> <span class=n>e</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=k>operator</span><span class=o>+</span><span class=p>(</span><span class=k>const</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>result</span><span class=p>(</span><span class=n>_rows</span><span class=p>,</span> <span class=n>_cols</span><span class=p>,</span> <span class=n>DEFAULT_SIZE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//result._num = 0;
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>_rows</span> <span class=o>!=</span> <span class=n>e</span><span class=p>.</span><span class=n>_rows</span> <span class=o>||</span> <span class=n>_cols</span> <span class=o>!=</span> <span class=n>e</span><span class=p>.</span><span class=n>_cols</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;两矩阵行列数不等，无法进行加法运算！&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>                     <span class=c1>//控制左值，即this
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>                     <span class=c1>//控制右值，即e
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>T</span> <span class=n>value</span><span class=p>;</span>                       <span class=c1>//存放临时的非零值值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>_num</span><span class=p>)</span> <span class=c1>//直到一个矩阵的非零元素被遍历完
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span> <span class=o>==</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_row</span><span class=p>)</span> <span class=c1>//行号相等时
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span> <span class=o>==</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_col</span><span class=p>)</span> <span class=c1>//行列号都相等时
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>value</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_value</span> <span class=o>+</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>value</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span> <span class=o>&gt;</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_col</span><span class=p>)</span> <span class=c1>//行号相等，左值列号&gt;右值列号
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span> <span class=c1>//将右值（即列较小值）添加到新矩阵中
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=c1>//行号相等，左值列号&lt;右值列号
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span> <span class=c1>//将左值（即列较小值）添加到新矩阵中
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span> <span class=o>&gt;</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_row</span><span class=p>)</span> <span class=c1>//左值行号&gt;右值行号时
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span> <span class=c1>//将右值（即行较小值）添加到新矩阵中
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=c1>//左值行号&lt;右值行号时
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span> <span class=c1>//将左值（即行较小值）添加到新矩阵中
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span><span class=p>)</span> <span class=c1>//若左值中有剩余元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>e</span><span class=p>.</span><span class=n>_num</span><span class=p>)</span> <span class=c1>//若右值中有剩余元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>SimpleTranspose</span><span class=p>(</span><span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//简单转置，时间复杂度O(_rows*_cols)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_rows</span> <span class=o>=</span> <span class=n>_rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_cols</span> <span class=o>=</span> <span class=n>_cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_num</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_maxLen</span> <span class=o>=</span> <span class=n>_maxLen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_data</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Triple</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>[</span><span class=n>_maxLen</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>col</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>col</span> <span class=o>&lt;</span> <span class=n>_cols</span><span class=p>;</span> <span class=n>col</span><span class=o>++</span><span class=p>)</span> <span class=c1>//对整个矩阵的列进行遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>//对_data进行遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>col</span> <span class=o>==</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>)</span> <span class=c1>//若_data[i]中出现相应列，添加到e中
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>e</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span><span class=p>,</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>//*this = e;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>FastTranspose</span><span class=p>(</span><span class=n>TriSparseMatrix</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>e</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//快速转置，时间复杂度O(_num)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_rows</span> <span class=o>=</span> <span class=n>_rows</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_cols</span> <span class=o>=</span> <span class=n>_cols</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_num</span> <span class=o>=</span> <span class=n>_num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_maxLen</span> <span class=o>=</span> <span class=n>_maxLen</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>e</span><span class=p>.</span><span class=n>_data</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Triple</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>[</span><span class=n>_maxLen</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>DataNumInCol</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>_cols</span><span class=p>];</span> <span class=c1>//存放原矩阵每一列非零个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=o>*</span><span class=n>FirstDataIne</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>_cols</span><span class=p>];</span> <span class=c1>//存放每一列第一个非零元素在e中的索引位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_cols</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>     <span class=c1>//赋初值为0
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DataNumInCol</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>//记录每列的非零元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>DataNumInCol</span><span class=p>[</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>]</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>FirstDataIne</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>            <span class=c1>//零行第一个非零元素必在0位置
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_cols</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>//当前列第一个元素的索引位置=上一列的索引位置+上一列的元素个数
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>FirstDataIne</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>FirstDataIne</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=n>DataNumInCol</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_num</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>FirstDataIne</span><span class=p>[</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>];</span> <span class=c1>//j记录当前列的索引
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_row</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_col</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_row</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>e</span><span class=p>.</span><span class=n>_data</span><span class=p>[</span><span class=n>j</span><span class=p>].</span><span class=n>_value</span> <span class=o>=</span> <span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>FirstDataIne</span><span class=p>[</span><span class=n>_data</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>_col</span><span class=p>]</span><span class=o>++</span><span class=p>;</span> <span class=c1>//当前列的索引值+1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>DataNumInCol</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span><span class=p>[]</span> <span class=n>FirstDataIne</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//*this = e;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=三元组的十字链表>三元组的十字链表</h3><p>当非零元素经常变动时，不适合用顺序表。</p><p>十字链表由行链表和列链表组成（不带头结点的循环表），每个非零元素既处于行链表又处于列链表中</p><h4 id=非零元素结点类模板>非零元素结点类模板</h4><h2 id=广义表>广义表</h2><p>即列表（List），元素可以是一个数据也可以是一个表
$$
LS=(a_1,a_2,\ldots,a_n)
$$</p><ul><li><p>表头：$$a_1$$</p></li><li><p>表尾：$$(a_2,a_3,\ldots,a_n)$$</p></li><li><p>深度：广义表中括号的深度；空表的深度为1</p></li></ul><h3 id=广义链表>广义链表</h3><p><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20201228093515706.png alt=image-20201228093515706 style=zoom:67%><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210104080520301.png alt=image-20210104080520301 style=zoom:67%></p><p>要点：</p><ol><li><p>带头结点</p></li><li><p>单元素深度为0，空表深度为一</p></li><li><p>几乎所有操作都是递归，因为广义表本身的定义即是递归的</p></li><li><p>求深度公式</p></li></ol><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210104083030427.png alt=image-20210104083030427 style=zoom:67%><h4 id=结点类模板定义-1>结点类模板定义</h4><h4 id=链表类模板定义-1>链表类模板定义</h4><h1 id=数和森林>数和森林</h1><p>一个数据可能有多个直接前驱（或后继），需要用非线性数据结构去表示，本章讲解树形结构的定义与实现</p><h2 id=树>树</h2><p>(tree)</p><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210104090947185.png alt=image-20210104090947185 style=zoom:67%>
<img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210104092654359.png alt=image-20210104092654359 style=zoom:67%><h3 id=定义-3>定义</h3><p>树$$T$$是一个包含$$n$$个数据元素的有限集合，每个数据元素用一个结点表示，且有</p><ol><li>$$n=0$$时，$$T$$为空树</li><li>$$n>0$$时，$$T$$有且只有一个根（root），根结点只有后继，没有前驱</li><li>$$n>1$$时，根以外的其余结点又是$$m$$个互不受限的非空有限集，它们是根结点的子树（subtree）</li></ol><h3 id=术语>术语</h3><ul><li>结点（node）：每个数据元素及指向其子树根的分支</li><li>结点的度（degree of node）：一个结点的分支个数（子树数目）</li><li>终端结点（terminal tree）：度为 0 的结点，也叫叶子（leaf）</li><li>非终端结点（nonterminal tree）：度不为 0 的结点，也叫分支结点</li><li>树的度（degree of tree）：树的结点中最大的度</li><li>孩子（child）和双亲（parent）：结点 p 的子树称为p的孩子，p 是其子树的双亲</li><li>兄弟（sibling）：双亲相同的结点</li><li>祖先（ancestor）：从根结点到结点x所经分支上的所有结点是 x 的祖先</li><li>子孙（descendant）：以结点 p 为根的所有子树中的所有结点都是 p 的子孙</li><li>结点的层次（level）：根为第一层，根的孩子第二层，以此类推；树中任意结点的 level 是其双亲结点level+1</li><li>树的深度（depth）：树中结点的最大层次（根的层次），也叫高度（height）</li><li>堂兄弟：双亲在同一层的结点</li><li>有序树：树中结点 p 的子树都是有顺序的</li><li>无序树：树中结点 p 的子树没有顺序</li><li>森林（forest）：m 颗互不相交的的树的集合；对树中每个结点而言，其子树的集合即为森林（子树森林）</li></ul><h3 id=存储结构>存储结构</h3><p>采用链式存储为佳，记录前驱和后继其中一个即可完成全部功能</p><h4 id=双亲数组表示法>双亲(数组)表示法</h4><ol><li><p>采用数组来存储，本质上是静态链表，所以不属于顺序存储</p></li><li><p>Data 域存储结点的数据信息
Parent 存储结点的双亲在数组中的序号。</p></li><li><p>实现求双亲操作很方便，但对于求某节点的孩子节点的操作需要查询整个数组，实现求兄弟的操作也比较困难。</p></li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329082007138.png alt=image-20210329082007138 style=zoom:50%><h4 id=孩子表示法>孩子表示法</h4><ol><li><p>多重链表
链表中的每个结点包括一个数据域和多个指针域。数据域存储树中结点的自身信息，每个指针指向该结点的一个孩子结点。</p><p>定长，浪费；不定长，难写</p></li><li><p>数组 + 单链表
一维数组顺序存储树中各节点的信息，并将各结点的孩子信息组成一个单链表。</p></li></ol><h4 id=双亲---孩子表示法>双亲 - 孩子表示法</h4><p>将各结点的孩子结点组成一个单链表，同时用一维数组顺序存储树中的各节点，数组元素包括结点的自身信息、双亲结点在数组中的序号以及该结点的孩子结点链表的头指针。</p><p>有些麻烦</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329082616400.png alt=image-20210329082616400 style=zoom:67%><h4 id=孩子---兄弟表示法>孩子 - 兄弟表示法</h4><ol><li>二重链表表示法</li><li>查找某结点的孩子结点比较方便，如果在每一个结点中增加一个指向双亲的指针，就可以方便地找到各结点的祖先。</li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329082944536.png alt=image-20210329082944536 style=zoom:50%><h3 id=树森林和二叉树的转换>树、森林和二叉树的转换</h3><h4 id=树转化为二叉树>树转化为二叉树</h4><p>把树当作有序树看待：约定树中每一个结点的孩子结点按从左到右的次序顺序编号。</p><ul><li><p>操作</p><ol><li><strong>连线</strong>：树中所有相邻兄弟结点之间加一条线</li><li><strong>删线</strong>：对树中的每一个结点，只保留它与第一个孩子结点之间的连线，删去它与其他孩子结点之间的连线。</li><li><strong>美化</strong>：以树的根结点为轴心，将这棵树顺时针转动 45 度使其层次分明。</li></ol></li><li><p>性质</p><ol><li>左孩子表示自己的第一个孩子；右孩子表示自己的下一个兄弟</li><li>树作这样的转化所构成的二叉树是唯一的。</li><li>树转化成的二叉树，其根结点无右子树。</li></ol></li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329084439741.png alt=image-20210329084439741 style=zoom:50%><h4 id=森林转化为二叉树>森林转化为二叉树</h4><p>森林转化成的二叉树，其根结点有右子树。</p><ol><li>依次将森林中每棵树转化成相应的二叉树。</li><li>从第二棵二叉树开始，依次把当前的二叉树作为前一棵二叉树根结点的右子树，此时所得到的二叉树就是由森林转化得到的二叉树。</li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329084517512.png style=zoom:50%><h4 id=二叉树转化为森林>二叉树转化为森林</h4><ol><li><strong>连线</strong>：若结点 p 是其双亲结点F的左孩子，则把从结点 p 延沿右分支所找到的所有结点和结点 F 用线连起来。</li><li><strong>删线</strong>：删除二叉树中所有结点和其右孩子结点之间的连线。</li><li><strong>美化</strong>：整理，使结构层次分明。</li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329084543768.png alt=image-20210329084543768 style=zoom:50%><h3 id=树的遍历>树的遍历</h3><p>指按照某种顺序访问树中的每个结点，并使每个结点被访问一次且只被访问一次。</p><h4 id=树的先根遍历>树的先根遍历</h4><p>若树为空，遍历结束。否则，</p><ol><li>访问根结点；</li><li>按照从左到右的顺序先根遍历根结点的每一棵子树。</li></ol><p><strong>与二叉树先序遍历结果序列相同。</strong></p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135015723.png style=zoom:67%><p>ABEFKLCGDHIMNJ</p><h4 id=树的后根遍历>树的后根遍历</h4><p>若树为空，遍历结束。否则，</p><ol><li>按照从左到右的顺序后根遍历根结点的每一棵子树；</li><li>访问根结点。</li></ol><p><strong>与二叉树中序遍历结果序列相同。</strong></p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135015723.png style=zoom:67%><p>EKLFBGCHMNIJDA</p><h4 id=树的层次遍历>树的层次遍历</h4><p>又称为树的广度遍历。从树的第一层（根结点）开始，自上至下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。
借助队列，结构按下述步骤层序遍历树：</p><ol><li>初始化队列，并将根结点入队。</li><li>当队列非空时，取出队头结点p，转步骤3）；如果队列为空，则结束遍历。</li><li>访问取出的结点p；如果结点p有孩子，则依次将它们入队列。</li><li>重复步骤2）、3），直到队列为空。</li></ol><h3 id=森林的遍历>森林的遍历</h3><h4 id=森林的先根遍历>森林的先根遍历</h4><p>若森林为空，返回；否则，</p><ol><li><p>访问森林中第一棵树的根结点；</p></li><li><p>先根遍历第一棵树的根结点的子树森林；</p></li><li><p>先根遍历除第一棵外其他树组成的森林。</p></li></ol><p><strong>与二叉树先序遍历结果序列相同。</strong></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png title=image-20210611135715150></p><p>ABCDEFGHI</p><h4 id=森林的中根遍历>森林的中根遍历</h4><p>若森林为空，返回；否则，</p><ol><li>中根遍历第一棵树的根结点的子树森林；</li><li>访问森林中第一棵树的根结点；</li><li>中根遍历除第一棵外其他树组成的森林。</li></ol><p><strong>与二叉树中序遍历结果序列相同。</strong></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png title=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png></p><p>BCDAFEHIG</p><h4 id=森林的后根遍历>森林的后根遍历</h4><p>若森林为空，返回；否则，</p><ol><li>后根遍历第一棵树的根结点的子树森林；</li><li>后根遍历除第一棵外其他树组成的森林；</li><li>访问森林中第一棵树的根结点。</li></ol><p><strong>与二叉树后序遍历结果序列相同。</strong></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png title=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611135715150.png></p><p>DCBFIHGEA</p><h2 id=二叉树>二叉树</h2><p>（Binary Tree）</p><h3 id=定义-4>定义</h3><p>二叉树是特殊的有序树，每个结点的度最多为2</p><p>非空时，有根结点BT，余下的结点最多被组成两颗互不相交的、分别被称为BT的左子树（left subtree）和右子树（right subtree）的二叉树</p><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210104093053829.png alt=image-20210104093053829 style=zoom:67%><h3 id=性质>性质</h3><ol><li>n 个结点，分支数为 n-1</li><li>n 个叶子节点，有 n-1 个度为 2 的节点</li><li>n 个结点，其高度范围为 $$[\lceil log_2(n+1\rceil,n]$$</li><li>高度为 h ，其节点数范围为 $$[h,2^h-1]$$</li><li>完全二叉树时，找 i 的子节点：$$2i+1 \ 与 \ 2i+2$$</li></ol><h3 id=遍历>遍历</h3><p>（Traversing Binary Tree, TBT）</p><p>定义：按某种顺序访问每个结点，并使每个结点只被访问一次</p><p>方法：规定$$L,D,R$$为访问左子树，根，右子树，有：（规定先左再右）</p><ol><li>$$DLR$$：先序遍历</li><li>$$LDR$$：中序遍历</li><li>$$LRD$$：后序遍历</li></ol><p>先序+中序（or 后序+中序）的遍历结果可以反向推导出二叉树</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210316141122137.png alt=image-20210316141122137 style=zoom:67%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210316141042079.png alt=image-20210316141042079 style=zoom:67%><h4 id=先序遍历>先序遍历</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>PreOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>PreOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PreOrder_NoRecurve</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//DLR 节点不为空时即打印
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>Stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>()</span> <span class=o>||</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span> <span class=c1>//先打印父节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>Stack</span><span class=p>.</span><span class=n>PushElem</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>       <span class=c1>//父节点入栈
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>;</span>       <span class=c1>//转到左节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>.</span><span class=n>TopElem</span><span class=p>();</span> <span class=c1>//回溯到父节点
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>Stack</span><span class=p>.</span><span class=n>PopElem</span><span class=p>();</span>     <span class=c1>//父节点出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>;</span>  <span class=c1>//转到右节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=中序遍历>中序遍历</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>InOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>InOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>InOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>InOrder_NoRecurve</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// LDR 左节点为空时访问（或 即将转到右节点时访问）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>Stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>()</span> <span class=o>||</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Stack</span><span class=p>.</span><span class=n>PushElem</span><span class=p>(</span><span class=n>p</span><span class=p>);</span> <span class=c1>//入栈
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>;</span> <span class=c1>//转到左节点
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>.</span><span class=n>TopElem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                <span class=n>Stack</span><span class=p>.</span><span class=n>PopElem</span><span class=p>();</span>         <span class=c1>//栈顶出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span> <span class=c1>//即将转到右节点时，打印栈顶
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>;</span>      <span class=c1>//转到右节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=后序遍历>后序遍历</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PostOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>PostOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>PostOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>PostOrder_NoRecurve</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//LRD 出栈时，需要判定左右节点遍历的完成情况
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>_root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=o>&lt;</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>Stack</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkStack</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>Tag</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>//Stack.PushElem(p);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//Tag.PushElem(0);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>()</span> <span class=o>||</span> <span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Stack</span><span class=p>.</span><span class=n>PushElem</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>Tag</span><span class=p>.</span><span class=n>PushElem</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>Tag</span><span class=p>.</span><span class=n>TopElem</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=c1>//此时左节点已经遍历完
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>.</span><span class=n>TopElem</span><span class=p>();</span> <span class=c1>//预出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>Tag</span><span class=p>.</span><span class=n>PopElem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>Tag</span><span class=p>.</span><span class=n>PushElem</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span> <span class=c1>//将Tag栈顶改为1，表示已经遍历完左节点
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span> <span class=c1>//此时右节点已经遍历完
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>p</span> <span class=o>=</span> <span class=n>Stack</span><span class=p>.</span><span class=n>TopElem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>Stack</span><span class=p>.</span><span class=n>PopElem</span><span class=p>();</span> <span class=c1>//真正出栈
</span></span></span><span class=line><span class=cl><span class=c1></span>                    <span class=n>Tag</span><span class=p>.</span><span class=n>PopElem</span><span class=p>();</span>
</span></span><span class=line><span class=cl>                    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>Stack</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=层序遍历>层序遍历</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>LevelOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//层序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>Queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Queue</span><span class=p>.</span><span class=n>EnterQueue</span><span class=p>(</span><span class=n>root</span><span class=p>);</span> <span class=c1>//若根非空，则入队
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>Queue</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>.</span><span class=n>GetFront</span><span class=p>();</span>    <span class=c1>//取队头
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>Queue</span><span class=p>.</span><span class=n>DeleteQueue</span><span class=p>();</span>     <span class=c1>//出队
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span><span class=p>;</span> <span class=c1>//打印打印！
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=c1>//若左节点非空，入队
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Queue</span><span class=p>.</span><span class=n>EnterQueue</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=c1>//若右节点非空，入队
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Queue</span><span class=p>.</span><span class=n>EnterQueue</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=遍历的用途>遍历的用途</h4><ol><li>打印内容</li><li>知晓层数</li><li>统计结点</li><li>使非线性结构线性化</li></ol><h4 id=遍历的-c-写法>遍历的 C++ 写法</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=定义-5>定义</h3><h4 id=类模板定义-5>类模板定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BinaryTree</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>_root</span><span class=p>;</span> <span class=c1>//二叉树根节点的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>T</span> <span class=n>_refValue</span><span class=p>;</span>           <span class=c1>//创建二叉树时的结束标志
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>//辅助函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 创建二叉树 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>CreateBinTree_PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span> <span class=c1>//利用已知的二叉树的前序遍历创建二叉树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 遍历二叉树 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>            <span class=c1>//前序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>InOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>             <span class=c1>//中序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>PostOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>           <span class=c1>//后序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>PreOrder_NoRecurve</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>  <span class=c1>//前序遍历非递归
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>InOrder_NoRecurve</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>   <span class=c1>//中序遍历非递归
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>PostOrder_NoRecurve</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span> <span class=c1>//后序遍历非递归
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>LevelOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>          <span class=c1>//层次遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 获取信息 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetHeight</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                                <span class=c1>//求高度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetNodeNum</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                               <span class=c1>//求节点个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetParent</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>,</span> <span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span> <span class=c1>//求父节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetmaxWidth</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                                    <span class=c1>//求最大宽度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetLeafNum</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                               <span class=c1>//求叶子节点数目
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 其他 */</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>CopyTree</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>originNode</span><span class=p>);</span> <span class=c1>//复制二叉树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DestroyTree</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>);</span>                    <span class=c1>//删除二叉树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsEqual</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>b</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 构造与析构 */</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryTree</span><span class=p>()</span> <span class=o>:</span> <span class=n>_root</span><span class=p>(</span><span class=nb>NULL</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryTree</span><span class=p>(</span><span class=n>T</span> <span class=n>refValue</span><span class=p>)</span> <span class=o>:</span> <span class=n>_refValue</span><span class=p>(</span><span class=n>refValue</span><span class=p>)</span> <span class=p>{</span> <span class=n>_root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span> <span class=p>}</span> <span class=c1>//构造函数，指定结束标志refValue
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>virtual</span> <span class=o>~</span><span class=n>BinaryTree</span><span class=p>()</span> <span class=p>{</span> <span class=n>DestroyTree</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryTree</span><span class=p>(</span><span class=k>const</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>copy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=cm>/*运算符重载*/</span>
</span></span><span class=line><span class=cl>    <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=k>operator</span><span class=o>=</span><span class=p>(</span><span class=k>const</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>copy</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=k>operator</span><span class=o>==</span><span class=p>(</span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>s</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>IsEqual</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>s</span><span class=o>-&gt;</span><span class=n>_root</span><span class=p>));</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 创建二叉树 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>CreateBinTree_PreOrder</span><span class=p>()</span> <span class=p>{</span> <span class=n>CreateBinTree_PreOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span> <span class=c1>//用先序遍历结果创建二叉树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/* 遍历二叉树 */</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PreOrder</span><span class=p>()</span> <span class=p>{</span> <span class=n>PreOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InOrder</span><span class=p>()</span> <span class=p>{</span> <span class=n>InOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PostOrder</span><span class=p>()</span> <span class=p>{</span> <span class=n>PostOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PreOrder_NoRecurve</span><span class=p>()</span> <span class=p>{</span> <span class=n>PreOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InOrder_NoRecurve</span><span class=p>()</span> <span class=p>{</span> <span class=n>InOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>PostOrder_NoRecurve</span><span class=p>()</span> <span class=p>{</span> <span class=n>PostOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>LevelOrder</span><span class=p>()</span> <span class=p>{</span> <span class=n>LevelOrder</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 获取信息 */</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetRoot</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>_root</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetHeight</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetNodeNum</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>GetNodeNum</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetmaxWidth</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>GetmaxWidth</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetLeafNum</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>GetLeafNum</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetParent</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>_root</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>||</span> <span class=n>_root</span> <span class=o>==</span> <span class=n>p</span><span class=p>)</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=n>GetParent</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetLeftChild</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetRightChild</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>?</span> <span class=nb>NULL</span> <span class=o>:</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetLeftSibling</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>GetRightSibling</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=cm>/* 其他 */</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>CopyTree</span><span class=p>()</span> <span class=p>{</span> <span class=n>CopyTree</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DestroyTree</span><span class=p>()</span> <span class=p>{</span> <span class=n>DestroyTree</span><span class=p>(</span><span class=n>_root</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>()</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=p>(</span><span class=n>_root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=o>?</span> <span class=nb>true</span> <span class=o>:</span> <span class=nb>false</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InsertLeftChild</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>p</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>InsertRightChild</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>p</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>GetElem</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span> <span class=p>{</span> <span class=k>return</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>SetElem</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=n>T</span> <span class=n>data</span><span class=p>)</span> <span class=p>{</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=具体定义-4>具体定义</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span><span class=lnt>176
</span><span class=lnt>177
</span><span class=lnt>178
</span><span class=lnt>179
</span><span class=lnt>180
</span><span class=lnt>181
</span><span class=lnt>182
</span><span class=lnt>183
</span><span class=lnt>184
</span><span class=lnt>185
</span><span class=lnt>186
</span><span class=lnt>187
</span><span class=lnt>188
</span><span class=lnt>189
</span><span class=lnt>190
</span><span class=lnt>191
</span><span class=lnt>192
</span><span class=lnt>193
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>DestroyTree</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//销毁二叉树，递归进行。先删左子树再删右子树，最后删自己
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DestroyTree</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>DestroyTree</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>delete</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>CopyTree</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>originNode</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//复制二叉树，返回一个指针，给出一个以originNode为根复制的二叉树的副本
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>originNode</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>=</span> <span class=n>originNode</span><span class=o>-&gt;</span><span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>=</span> <span class=n>CopyTree</span><span class=p>(</span><span class=n>originNode</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span> <span class=o>=</span> <span class=n>CopyTree</span><span class=p>(</span><span class=n>originNode</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>bool</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>IsEqual</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>a</span><span class=p>,</span> <span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>b</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>b</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>a</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>b</span> <span class=o>!=</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>a</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>==</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>&amp;&amp;</span> <span class=n>IsEqual</span><span class=p>(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=n>IsEqual</span><span class=p>(</span><span class=n>a</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>,</span> <span class=n>b</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetNodeNum</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>1</span> <span class=o>+</span> <span class=n>GetNodeNum</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>)</span> <span class=o>+</span> <span class=n>GetNodeNum</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetHeight</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>GetHeight</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span> <span class=o>&gt;</span> <span class=n>j</span> <span class=o>?</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>:</span> <span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetParent</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>,</span> <span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=c1>//从root开始搜索p的父节点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>==</span> <span class=n>p</span> <span class=o>||</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span> <span class=o>==</span> <span class=n>p</span><span class=p>)</span> <span class=c1>//如果找到，返回父节点root
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>GetParent</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>,</span> <span class=n>p</span><span class=p>)</span> <span class=o>==</span> <span class=n>p</span><span class=p>)</span> <span class=c1>//递归在左子树中搜索
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>GetParent</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=c1>//递归右子树中搜索
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>GetParent</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetLeftSibling</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>r</span> <span class=o>=</span> <span class=n>GetParent</span><span class=p>(</span><span class=n>_root</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>_rightChild</span> <span class=o>==</span> <span class=n>p</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>InsertLeftChild</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>p</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=o>-&gt;</span><span class=n>_data</span> <span class=o>=</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>r</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>=</span> <span class=n>r</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>CreateBinTree_PreOrder</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//创建二叉树(利用已知的二叉树的前序遍历创建)用#表示空结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;input data: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>data</span> <span class=o>!=</span> <span class=n>_refValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>CreateBinTree_PreOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>  <span class=c1>//递归创建左子树
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>CreateBinTree_PreOrder</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span> <span class=c1>//递归创建右子树
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>root</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetmaxWidth</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=c1>//获取二叉树最大宽度，采用层序遍历
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>LinkQueue</span><span class=o>&lt;</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&gt;</span> <span class=n>Queue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maxWidth</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>curWidth</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>nextWidth</span><span class=p>;</span> <span class=c1>//最大节点数，当前层节点数，下一层节点数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>                          <span class=c1>//根节点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>maxWidth</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>curWidth</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>Queue</span><span class=p>.</span><span class=n>EnterQueue</span><span class=p>(</span><span class=n>root</span><span class=p>);</span> <span class=c1>//若根非空，则入队
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=o>!</span><span class=n>Queue</span><span class=p>.</span><span class=n>IsEmpty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>nextWidth</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>//nextWidth归零
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>curWidth</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>p</span> <span class=o>=</span> <span class=n>Queue</span><span class=p>.</span><span class=n>GetFront</span><span class=p>();</span> <span class=c1>//取队头
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>Queue</span><span class=p>.</span><span class=n>DeleteQueue</span><span class=p>();</span>  <span class=c1>//出队
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=c1>//若当前节点有左孩子，nextWidth++
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Queue</span><span class=p>.</span><span class=n>EnterQueue</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>nextWidth</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span> <span class=c1>//若当前节点有右孩子，nextWidth++
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Queue</span><span class=p>.</span><span class=n>EnterQueue</span><span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>nextWidth</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>curWidth</span> <span class=o>=</span> <span class=n>nextWidth</span><span class=p>;</span> <span class=c1>//此时进入下一层的遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>curWidth</span> <span class=o>&gt;</span> <span class=n>maxWidth</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>maxWidth</span> <span class=o>=</span> <span class=n>curWidth</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>maxWidth</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>GetLeafNum</span><span class=p>(</span><span class=k>const</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>root</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span> <span class=o>==</span> <span class=nb>NULL</span> <span class=o>&amp;&amp;</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>GetLeafNum</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_leftChild</span><span class=p>)</span> <span class=o>+</span> <span class=n>GetLeafNum</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>_rightChild</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=线索二叉树>线索二叉树</h2><p>(Threaded Binary Tree)</p><p>利用结点的空链，记录遍历的前驱和后继</p><p>规定</p><ul><li>结点左指针为空，记前驱；结点右指针为空，记后继</li><li>为了区分指针指的式孩子还是线索关系，加标记，为0记录孩子，为1记录线索</li><li>添加一个数据域为空的头结点，左指针指向根结点，标记0；右指针记录遍历时第一个访问的结点，标记1</li></ul><table><thead><tr><th>leftChild</th><th>leftTag</th><th>data</th><th>rightTag</th><th>rightChild</th></tr></thead><tbody><tr><td>左孩子或前驱</td><td>0或1</td><td>数据域</td><td>0或1</td><td>右孩子或后继</td></tr></tbody></table><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210111093250495.png alt=image-20210111093250495 style=zoom:67%><h3 id=查找结点的前驱和后继算法>查找结点的前驱和后继算法</h3><ol><li>中序线索二叉树</li></ol><p>查找p的前驱：查左线索；若无左线索，结点的前驱是遍历左子树时访问的最后一个结点。</p><p>查找p的后继：查右线索；若无右线索，结点的后继是遍历右子树时访问的第一个结点。</p><ol start=2><li>先序线索二叉树</li></ol><p>查找p的前驱：查左线索；若无左线索，结点的前驱是结点的双亲结点，或是先序遍历其双亲结点左子树时最后访问的结点。</p><p>查找p的后继：查右线索；若无右线索，结点的后继必为结点的左子树（若存在）或右子树根结点。</p><ol start=3><li>后序线索二叉树</li></ol><p>查找p的前驱：查左线索；若无左线索，且无右线索时，结点的前驱是右子树根结点；若无左线索，但是有右线索时，结点的前驱是左子树根结点。</p><p>查找p的后继，这种查找比较复杂，分4类情况讨论：</p><p>​ 若p为二叉树的根结点，后继为空；
​ 若p为右子树根结点，后继为双亲结点；
​ 若p为左子树根结点，且无右兄弟，后继为双亲结点；
​ 若p为左子树根结点，且有右兄弟，后继为后序遍历双亲结点右子树时访问的第一个结点。</p><h2 id=堆>堆</h2><p>（Heap）</p><h3 id=定义-6>定义</h3><p>在完全二叉树中任何非终端节点的关键字均不大于（或不小于）其左、右孩子结点的关键字</p><p>堆的本质是线性关系，但写成完全二叉树形式更为直观</p><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210115092512720.png alt=image-20210115092512720 style=zoom:67%><p>称根节点为堆顶，称堆顶最小为小顶堆（最小堆）；堆顶最大为大顶堆（最大堆）</p><p>使用顺序存储来构建堆</p><h4 id=向下调整-filterdown>向下调整 FilterDown</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210425170330961.png alt=image-20210425170330961 style=zoom:50%><h2 id=哈夫曼树>哈夫曼树</h2><h3 id=术语-1>术语</h3><ul><li>路径（Path）：从根结点到某个结点经过的分支序列</li><li>（根到结点的）路径长度：路径中的分支数</li><li>树的路径长度（Path Length，PL）：从根结点到所有叶子结点的路径长度和</li><li>带权路径长度（WPL）：设一颗有n个带权值叶结点的二叉树，$$W_k$$为第k个叶结点的权值，$$L_k$$为第k个叶结点的路径长度</li></ul><p>$$
WPL=\sum\limits_{k=1}^nW_k*L_k
$$</p><h3 id=定义-7>定义</h3><p>对于一组确定权值的结点，所构造出不同形态二叉树的带权路径长度并不相同。将其中具有最小带权路径长度的二叉树称为<strong>哈夫曼树</strong>（最优二叉树）</p><p>构造方法：取最小的两个结点构树（左小右大），重复</p><h3 id=哈夫曼编码>哈夫曼编码</h3><p>哈夫曼编码是一种前缀码，解码时没有歧义，相比于等长编码可以节省空间</p><ul><li>计算字母频率作为权值，构造哈夫曼树，</li><li>叶子结点具有哈夫曼编码</li><li>规定左子树为 0，右子树为 1，写出字母编码</li></ul><img src=https://trou.oss-cn-shanghai.aliyuncs.com/img/image-20210118092851997.png alt=image-20210118092851997 style=zoom:67%><h2 id=等价类及其表示并查集>等价类及其表示(并查集)</h2><ul><li><p>定义</p><p>指能够完成查找、合并功能的集合。</p></li><li><p>操作</p><ol><li><code>Ufsets(n)</code>：构造函数，将并查集中 n 个元素初始化为 n 个只有一个单元素的子集合。</li><li><code>Union(S1,S2)</code>：把集合 S2 并入集合 S1 中。要求 S1 与 S2 互不相交，否则没有结果。</li><li><code>Find(d)</code>：查找单元素 d 所在的集合，并返回该集合的名字。</li></ol></li><li><p>效率问题</p><ol><li>查找效率取决于树的高度</li></ol></li></ul><ol start=2><li>树的高度取决于合并操作</li></ol><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611144154134.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611144154134.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611144154134.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611144154134.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210611144154134.png title=image-20210611144154134></p><h3 id=合并算法的改进>合并算法的改进</h3><ol><li><p>按照高度</p><p>高度高的作为根节点</p><p>绝对合理，但是高度难以求出</p></li><li><p>按照树中结点个数</p><p>节点个数多的作为根节点</p></li><li><p><strong>压缩路径 / 折叠规则</strong></p><p>也就是直接改进查找算法</p><p>设 j 是以 i 为根的树中的一个结点，则对于从 j 到根 i 的路径上的每一个结点 k，如果 k 的双亲不等于 i，则把 i 设置为 k 的双亲。</p></li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210329101540959.png alt=image-20210329101540959 style=zoom:50%><p>​ 使用折叠规则完成一次查找，所需时间比 <code>Find()</code> 多，但是能改善树的性能，减少以后查找操作所需的时间。</p><h3 id=类模板定义-6>类模板定义</h3><p>结点模板</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UFSetsNode</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=n>_data</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><p>并查集模板</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>UnionFindSets</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>UFSetsNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>_sets</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_size</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>SimpleFind</span><span class=p>(</span><span class=n>T</span> <span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>CollapsingFind</span><span class=p>(</span><span class=n>T</span> <span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>UnionFindSets</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>elems</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=o>~</span><span class=n>UnionFindSets</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>T</span> <span class=nf>GetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>   <span class=c1>//求索引指向的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetIndex</span><span class=p>(</span><span class=n>T</span> <span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>      <span class=c1>//求指定元素的索引
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>Find</span><span class=p>(</span><span class=n>T</span> <span class=n>e</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>          <span class=c1>//求指定元素所在等价根元素的索引
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Union</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>);</span>         <span class=c1>//合并两个等价类
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>WeightedUnion</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>);</span> <span class=c1>//合并两个等价类，结点多者作为结点少者的双亲
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DepthUnion</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>);</span>    <span class=c1>//合并两个等价类，深度大者作为深度小者的双亲
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Show</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=具体定义-5>具体定义</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span><span class=lnt>66
</span><span class=lnt>67
</span><span class=lnt>68
</span><span class=lnt>69
</span><span class=lnt>70
</span><span class=lnt>71
</span><span class=lnt>72
</span><span class=lnt>73
</span><span class=lnt>74
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>UnionFindSets</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Find</span><span class=p>(</span><span class=n>T</span> <span class=n>e</span><span class=p>)</span> <span class=k>const</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>index</span> <span class=o>=</span> <span class=n>GetIndex</span><span class=p>(</span><span class=n>e</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>index</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>_sets</span><span class=p>[</span><span class=n>index</span><span class=p>].</span><span class=n>_parent</span> <span class=o>&gt;</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>//不断寻找e的双亲，直到找到根结点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>index</span> <span class=o>=</span> <span class=n>_sets</span><span class=p>[</span><span class=n>index</span><span class=p>].</span><span class=n>_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>index</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>UnionFindSets</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>Union</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//此时，根结点的_parent记录的是树的结点数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rb</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ra</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>rb</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>ra</span> <span class=o>!=</span> <span class=n>rb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>+=</span> <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span><span class=p>;</span> <span class=c1>//个数相加
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>ra</span><span class=p>;</span>                 <span class=c1>//合并等价类，a作为b的双亲
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>UnionFindSets</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>WeightedUnion</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rb</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//此时，根结点的_parent记录的是树的结点数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ra</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>rb</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>ra</span> <span class=o>!=</span> <span class=n>rb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>&lt;=</span> <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>+=</span> <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>ra</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span> <span class=o>+=</span> <span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>rb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>UnionFindSets</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;::</span><span class=n>DepthUnion</span><span class=p>(</span><span class=n>T</span> <span class=n>a</span><span class=p>,</span> <span class=n>T</span> <span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ra</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rb</span> <span class=o>=</span> <span class=n>Find</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=c1>//此时，根结点的_parent记录的是树的深度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>ra</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>rb</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=n>ra</span> <span class=o>!=</span> <span class=n>rb</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>==</span> <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>//若两棵树的深度相同，合并后的最小深度为原深度+1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>ra</span><span class=p>;</span> <span class=c1>//合并等价类，a作为b的双亲
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=c1>//若两棵树的深度不同，合并后的最小深度为较大者
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>&lt;</span> <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>_sets</span><span class=p>[</span><span class=n>rb</span><span class=p>].</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>ra</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>_sets</span><span class=p>[</span><span class=n>ra</span><span class=p>].</span><span class=n>_parent</span> <span class=o>=</span> <span class=n>rb</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h1 id=图>图</h1><h2 id=基本概念>基本概念</h2><p>数据结构中的图：不带自身环，关联边不能多于一条
$$
graph=(V,E)
$$
顶点 vertex</p><p>有向边又称为弧，有弧尾（始点）和弧头（终点）</p><h2 id=存储结构-1>存储结构</h2><p>思考：如何找到环？</p><h3 id=邻接矩阵>邻接矩阵</h3><h4 id=概念>概念</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412081500935.png alt=image-20210412081500935 style=zoom:55%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412081530638.png alt=image-20210412081530638 style=zoom:55%><p>用一维数组 <code>vertexes[]</code> 存储顶点信息，二维数组 <code>arcs[]</code> 存储边信息</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412081633859.png alt=image-20210412081633859 style=zoom:55%><h4 id=无向图的邻接矩阵>无向图的邻接矩阵</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412082225634.png alt=image-20210412082225634 style=zoom:55%><h5 id=类模板定义-7>类模板定义</h5><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>//图的邻接矩阵类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>WeightType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>AdjMatrixGraph</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>protected</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_vexMaxNum</span><span class=p>,</span> <span class=n>_arcNum</span><span class=p>;</span>     <span class=c1>// 最大顶点数, 边数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=o>*</span><span class=n>_tag</span><span class=p>;</span>                   <span class=c1>// 标志数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SeqList</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=o>&gt;</span> <span class=n>_vertexes</span><span class=p>;</span> <span class=c1>// 顶点数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=o>**</span><span class=n>_arcs</span><span class=p>;</span>                 <span class=c1>// 邻接矩阵, 二维数组
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>_dirType</span><span class=p>;</span>                <span class=c1>// 有向图或无向图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>_weightType</span><span class=p>;</span>             <span class=c1>// 带权值或不带权值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=n>_infinity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>AdjMatrixGraph</span><span class=p>(</span><span class=kt>int</span> <span class=n>dirType</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>weightType</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=kt>int</span> <span class=n>vexMaxNum</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>,</span> <span class=n>WeightType</span> <span class=n>infinity</span> <span class=o>=</span> <span class=n>DEFAULT_INFINITY</span><span class=p>);</span> <span class=c1>//默认构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>AdjMatrixGraph</span><span class=p>(</span><span class=n>ElemType</span> <span class=o>*</span><span class=n>es</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vexNum</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=kt>int</span> <span class=n>dirType</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=kt>int</span> <span class=n>weightType</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=kt>int</span> <span class=n>vexMaxNum</span> <span class=o>=</span> <span class=n>DEFAULT_SIZE</span><span class=p>,</span> <span class=n>WeightType</span> <span class=n>infinity</span> <span class=o>=</span> <span class=n>DEFAULT_INFINITY</span><span class=p>);</span> <span class=c1>//构造函数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>AdjMatrixGraph</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsEmpty</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>GetVexNum</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>                          <span class=c1>// 求顶点个数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetArcNum</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>                          <span class=c1>// 求边数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetOrder</span><span class=p>(</span><span class=n>ElemType</span> <span class=n>vex</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>               <span class=c1>// 求顶点序号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>ElemType</span> <span class=nf>GetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>              <span class=c1>// 求指定下标的顶点值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>SetElem</span><span class=p>(</span><span class=kt>int</span> <span class=n>index</span><span class=p>,</span> <span class=n>ElemType</span> <span class=n>vex</span><span class=p>);</span>          <span class=c1>// 更新指定下标的顶点值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetFirstAdjVex</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                <span class=c1>// 求v的第一个邻接点的下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetNextAdjVex</span><span class=p>(</span><span class=kt>int</span> <span class=n>v1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v2</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>        <span class=c1>// 求v1相对于v2的下一个邻接点的下标
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>InsertVex</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>vex</span><span class=p>);</span>            <span class=c1>// 插入顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>InsertArc</span><span class=p>(</span><span class=kt>int</span> <span class=n>v1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v2</span><span class=p>,</span> <span class=kt>int</span> <span class=n>weight</span> <span class=o>=</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>// 插入边
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DeleteVex</span><span class=p>(</span><span class=k>const</span> <span class=n>ElemType</span> <span class=o>&amp;</span><span class=n>vex</span><span class=p>);</span>            <span class=c1>// 删除顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DeleteArc</span><span class=p>(</span><span class=kt>int</span> <span class=n>v1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v2</span><span class=p>);</span>                 <span class=c1>// 删除边
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>WeightType</span> <span class=nf>GetWeight</span><span class=p>(</span><span class=kt>int</span> <span class=n>v1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v2</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>     <span class=c1>// 求从顶点为v1到v2的边的权值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>SetWeight</span><span class=p>(</span><span class=kt>int</span> <span class=n>v1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>v2</span><span class=p>,</span> <span class=n>WeightType</span> <span class=n>w</span><span class=p>);</span>   <span class=c1>// 设置从顶点为v1到v2的边的权值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetTag</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                        <span class=c1>// 求顶点v的标志值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>SetTag</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>,</span> <span class=kt>int</span> <span class=n>value</span><span class=p>);</span>                  <span class=c1>// 设置顶点v的标志值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Display</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>                           <span class=c1>// 打印图
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>SetArcs</span><span class=p>(</span><span class=kt>int</span> <span class=o>**</span><span class=n>arcs</span><span class=p>,</span> <span class=kt>int</span> <span class=n>vexNum</span><span class=p>);</span>           <span class=c1>// 设置新的邻接矩阵
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Dijkstra</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>);</span>                           <span class=c1>// 迪杰斯特拉算法
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>GetInDegree</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span> <span class=k>const</span><span class=p>;</span>                   <span class=c1>// 求v的入度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>TopSort</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>                           <span class=c1>// 有向无权图的拓扑排序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>CriticalPath</span><span class=p>()</span> <span class=k>const</span><span class=p>;</span>                      <span class=c1>// AOE网络的开始时间、关键路径
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsConnected</span><span class=p>();</span>                             <span class=c1>// 判断图是否连通
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DFS</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>);</span>                                <span class=c1>// 深度优先搜索
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DFSHelp</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>);</span>                            <span class=c1>// 深度优先遍历, 无输出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DFSTraverse</span><span class=p>();</span>                             <span class=c1>// 深度优先遍历
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>TearCycle</span><span class=p>();</span>                               <span class=c1>// 破圈法, 求带权连通无向图的最小生成树
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=邻接表>邻接表</h3><p>把邻接矩阵的每一行记为一个单链表，把竖着排列的边连接成为一个边链表</p><p>记录有向图的出度，使用<strong>逆邻接表</strong></p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412083406393.png alt=image-20210412083406393 style=zoom:55%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412083416383.png alt=image-20210412083416383 style=zoom:55%><h3 id=邻接多重表>邻接多重表</h3><p>(Adjacency Multilist)</p><p>用来存储无向图</p><p>邻接多重表中，每条边用一个结点表示，每个顶点也用一个结点表示</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412084350845.png alt=image-20210412084350845 style=zoom:50%><ul><li>data：存储此顶点的数据；</li><li>firstedge：指针域，用于指向同该顶点有直接关联的存储其他顶点的节点</li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412084359057.png alt=image-20210412084359057 style=zoom:50%><ul><li>mark：标志域，用于标记此节点是否被操作过，例如在对图中顶点做遍历操作时，为了防止多次操作同一节点，mark 域为 0 表示还未被遍历；mark 为 1 表示该节点已被遍历；</li><li>ivex 和 jvex：数据域，分别存储图中各边两端的顶点所在数组中的位置下标；</li><li>ilink：指针域，指向下一个存储与 ivex 有直接关联顶点的节点；</li><li>jlink：指针域，指向下一个存储与 jvex 有直接关联顶点的节点；</li><li>info：指针域，用于存储与该顶点有关的其他信息，比如无向网中各边的权</li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412084959127.png alt=image-20210412084959127 style=zoom:67%><h3 id=十字链表>十字链表</h3><p>（Orthogonal List）</p><p>用来存储有向图</p><p>十字链表（即有向图的邻接多重表）可以看作是邻接表和逆邻接表的合体</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412085322307.png alt=image-20210412085322307 style=zoom:60%><h2 id=遍历-1>遍历</h2><p>思考：深度、广度分别有什么应用？</p><h3 id=深度优先遍历-dfs>深度优先遍历 DFS</h3><p>（Depth First Search, DFS）</p><p>理论上，结果不唯一</p><h4 id=步骤>步骤</h4><ol><li>访问节点 v，并标记其已访问</li><li>取 v 的第一个邻接顶点 w</li><li>判断<ol><li>w 是存在<ol><li>若是，继续</li><li>若否，返回</li></ol></li><li>w 是否被访问<ol><li>若是，取 v 的下下个邻接顶点，转到步骤 3</li><li>若否，访问 w，标记，转到步骤1</li></ol></li></ol></li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412090916957.png alt=image-20210412090916957 style=zoom:67%><h4 id=时间复杂度-1>时间复杂度</h4><ul><li>邻接表：O(n+e)</li><li>邻接矩阵：O(n^2^)</li></ul><h4 id=实现>实现</h4><h3 id=广度优先遍历-bfs>广度优先遍历 BFS</h3><p>（Breadth First Search, BFS）</p><h4 id=步骤-1>步骤</h4><ol><li>访问节点 v，并标记其已访问，使 v 入队</li><li>队空时，返回；若队非空，继续</li><li>出队 v</li><li>取 v 的第一个邻接顶点 w</li><li>判断 w 是否存在<ol><li>若存在，继续</li><li>若不存在，转步骤 3</li></ol></li><li>判断 w 是否被访问<ol><li>若被访问，继续</li><li>若未被访问，访问 w 并标记，使 w 入队，继续</li></ol></li><li>取 v 的下下个邻接顶点覆盖 w，转步骤 5</li></ol><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210424141055004.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210424141055004.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210424141055004.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210424141055004.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210424141055004.png title=image-20210424141055004></p><h4 id=时间复杂度-2>时间复杂度</h4><ul><li>邻接表：O(n+e)</li><li>邻接矩阵：O(n^2^)</li></ul><h3 id=连通分量>连通分量</h3><p>遍历算法的应用</p><p>定义：非连通图中的极大连通子图</p><h2 id=最小生成树>最小生成树</h2><h3 id=概念-1>概念</h3><h4 id=生成树>生成树</h4><ul><li><p>定义：连通图的极小连通子图</p></li><li><p>特点</p><ul><li>任意两顶点有且只有一条路径</li><li>n 个顶点的生成树具有 n-1 条边</li><li>生成树不唯一，n 个顶点的完全图有 $$n^{n-2}$$ 种生成树</li><li>不同遍历方法 / 不同顶点出发 / 不同存储结构，生成树不同</li><li>n 个顶点 n-1 条边也不一定是生成树</li></ul></li></ul><h4 id=最小生成树-1>最小生成树</h4><p>（minimum cost spanning tree, MST）</p><ul><li>定义：连通网中，权值总和最小的生成树，全称最小代价生成树</li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412100310369.png alt=image-20210412100310369 style=zoom:67%><ul><li>性质：假设 N = (V, E) 是一个连通网，U 是顶点集 V的一个非空子集。若 (u, v) 是一条具有最小权值的边，其中u∈U， v∈V - U，则必存在一棵包含边（u，v）的最小生成树</li></ul><h3 id=克鲁斯卡尔算法>克鲁斯卡尔算法</h3><p>(Kruskal)</p><h4 id=步骤-2>步骤</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412101458244.png alt=image-20210412101458244 style=zoom:50%><p>设 G = (V, E) 是具有 n 个顶点的连通网，T = (U，TE) 是其最小生成树。</p><ol><li><p>选取权值最小的边（V~i~，V~j~），若边（V~i~，V~j~）加入到 TE 后形成回路 (环)，则舍弃该边，否则将该边加入到 TE 中。</p></li><li><p>重复 1，知道 TE 中含有 n-1 条边为止</p></li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412101256880.png alt=image-20210412101256880 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412101237144.png style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412102147705.png alt=image-20210412102147705 style=zoom:50%><h4 id=实现-1>实现</h4><p>用最小堆来找最小边</p><p>用并查集来判断有无环</p><h3 id=普利姆算法>普利姆算法</h3><p>(Prim)</p><p>基于 MST 性质、</p><h4 id=步骤-3>步骤</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412103207051.png alt=image-20210412103207051 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412101256880.png alt=image-20210412101256880 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412102751502.png alt=image-20210412102751502 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210412103347778.png alt=image-20210412103347778 style=zoom:67%><h2 id=最短路径>最短路径</h2><p>（Shortest Path）</p><h3 id=类别>类别</h3><ul><li><p>单源点最短路径</p><p>给定网 G 和 V，求 V 到其他顶点的最短路径</p></li><li><p>多源点最短路径</p><p>给定网 G，求其中顶点到其他各顶点的最短路径</p></li></ul><h3 id=弧上权值非负的单源点最短路径>弧上权值非负的单源点最短路径</h3><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419081428998.png alt=image-20210419081428998 style=zoom:50%><h4 id=迪杰斯特拉算法dijkstra>迪杰斯特拉算法（Dijkstra）</h4><p>按路径长度递增的次序来产生最短路径；先求路径最短的一条，然后参照它进行刷新，求出长度次短的一条，以此类推，被求出长度的顶点放入集合 S 中，当 S 满，代表算法结束</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419081437115.png alt=image-20210419081437115 style=zoom:50%><p>引入 dist[]，存储 v 到 v~i~ <strong>当前</strong>找到的最短路径长度；引入 path[]，存储 v~i~ 的直接前驱节点</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419083104462.png alt=image-20210419083104462 style=zoom:50%><p>只看初边</p><h4 id=实现-2>实现</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span><span class=lnt>64
</span><span class=lnt>65
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>ElemType</span><span class=p>,</span> <span class=k>class</span> <span class=nc>WeightType</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>AdjMatrixGraph</span><span class=o>&lt;</span><span class=n>ElemType</span><span class=p>,</span> <span class=n>WeightType</span><span class=o>&gt;::</span><span class=n>Dijkstra</span><span class=p>(</span><span class=kt>int</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>// 求索引为v的顶点的各个最短路径长度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>_vexNum</span> <span class=o>=</span> <span class=n>_vertexes</span><span class=p>.</span><span class=n>GetLength</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>WeightType</span> <span class=n>min</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>WeightType</span> <span class=n>dist</span><span class=p>[</span><span class=n>_vexNum</span><span class=p>];</span> <span class=c1>// 存储当前找到的最短路径长度
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>path</span><span class=p>[</span><span class=n>_vexNum</span><span class=p>];</span>        <span class=c1>// 存储目标顶点的直接前驱节点
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_vexNum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>_arcs</span><span class=p>[</span><span class=n>v</span><span class=p>][</span><span class=n>i</span><span class=p>];</span> <span class=c1>// 存入一条边的路径
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>SetTag</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>          <span class=c1>// 用_tag表示已经找到最短路径的集合
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>!=</span> <span class=n>v</span> <span class=o>&amp;&amp;</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>_infinity</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 若dist[i]存在, 添加前驱节点
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>SetTag</span><span class=p>(</span><span class=n>v</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span> <span class=c1>//自身已经在集合中
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;所选源点: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>GetElem</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>finalVex</span><span class=p>;</span> <span class=c1>// 已求出最短路径的顶点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_vexNum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 按递增序列求最短路径
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>min</span> <span class=o>=</span> <span class=n>_infinity</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>finalVex</span> <span class=o>=</span> <span class=n>v</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>_vexNum</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 查询最小的最短路径, 找出finalVex
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_tag</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>dist</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>min</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>finalVex</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>min</span> <span class=o>=</span> <span class=n>dist</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>SetTag</span><span class=p>(</span><span class=n>finalVex</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>GetFirstAdjVex</span><span class=p>(</span><span class=n>finalVex</span><span class=p>);</span> <span class=n>j</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>=</span> <span class=n>GetNextAdjVex</span><span class=p>(</span><span class=n>finalVex</span><span class=p>,</span> <span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 从上一次找到的最短路径的顶点出发, 依次判断各顶点的最短路径能否更新
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>_tag</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>min</span> <span class=o>+</span> <span class=n>GetWeight</span><span class=p>(</span><span class=n>finalVex</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>dist</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>min</span> <span class=o>+</span> <span class=n>GetWeight</span><span class=p>(</span><span class=n>finalVex</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>path</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>finalVex</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 打印输出
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>_vexNum</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>v</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>string</span> <span class=nf>pathStr</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>GetElem</span><span class=p>(</span><span class=n>i</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>path</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>j</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>=</span> <span class=n>path</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pathStr</span> <span class=o>=</span> <span class=n>string</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>GetElem</span><span class=p>(</span><span class=n>j</span><span class=p>))</span> <span class=o>+</span> <span class=s>&#34; -&gt; &#34;</span> <span class=o>+</span> <span class=n>pathStr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;从顶点 &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>GetElem</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; 到顶点 &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>GetElem</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; 的最短路径为: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>pathStr</span>
</span></span><span class=line><span class=cl>             <span class=o>&lt;&lt;</span> <span class=s>&#34;, 长度为: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>dist</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=弧上权值任意值的单源点最短路径>弧上权值任意值的单源点最短路径</h3><h4 id=贝尔曼---福特算法>贝尔曼 - 福特算法</h4><p>从原点依次经过其他顶点，来缩短到达顶点的最短路径长度。要求：途中不能有路径长度为负数的<strong>回路</strong></p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419085915738.png alt=image-20210419085915738 style=zoom:40%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419090104101.png alt=image-20210419090104101 style=zoom:45%><p>递推公式</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419090451877.png alt=image-20210419090451877 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419090559757.png alt=image-20210419090559757 style=zoom:50%><h3 id=所有点之间的最短路径>所有点之间的最短路径</h3><h4 id=重复迪杰斯特拉>重复迪杰斯特拉</h4><p>以每一个点为原点，重复执行迪杰斯特拉算法；O(n^3^)</p><h4 id=弗洛伊德floyd算法>弗洛伊德（Floyd）算法</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419091217637.png alt=image-20210419091217637 style=zoom:45%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419091738628.png alt=image-20210419091738628 style=zoom:50%><h2 id=活动网络>活动网络</h2><p>（Activity Network）</p><h3 id=用顶点表示活动的网络>用顶点表示活动的网络</h3><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419093621497.png alt=image-20210419093621497 style=zoom:45%><h4 id=概念-2>概念</h4><ul><li><p>有向无环图（Directed acycline graph）：一个无环的有向图，简称 DAG 图</p></li><li><p>顶点表示活动的网络（Activity on vertices）：AOV 网络</p></li><li><p>拓扑排序：把 AOV 网络中各顶点按照他们相互之间的优先关系排列成一个线性序列的过程</p><ul><li>在有向图中选一个没有前驱的顶点且输出之</li><li>从图中删除该顶点和所有以它为尾的弧</li><li>重复前两步，直到所有顶点均已输出</li></ul></li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419100943832.png alt=image-20210419100943832 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419101244005.png alt=image-20210419101244005 style=zoom:45%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419101738002.png alt=image-20210419101738002 style=zoom:40%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419101626892.png alt=image-20210419101626892 style=zoom:50%><h3 id=用边表示活动的网络>用边表示活动的网络</h3><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419101854295.png alt=image-20210419101854295 style=zoom:50%><h4 id=概念-3>概念</h4><ul><li>边表示活动的网络（activity on edges）：简称 <strong>AOE 网络</strong><ul><li>边的值：此活动持续的时间</li></ul></li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210425112512555.png alt=image-20210425112512555 style=zoom:50%><ul><li>顶点表示事件（event），保证一个源点，一个汇点<ul><li>关键路径：从源点到汇点，具有最大路径长度的路径</li><li>关键活动：关键路径上的所有活动</li></ul></li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210419102732678.png alt=image-20210419102732678 style=zoom:45%><ul><li><p>求事件（顶点）的最早开始时间 ve：从源点起，入边的值加上其弧尾的最早开始时间，取最大值（看入边，求最大）</p></li><li><p>求事件（顶点）的最晚开始时间 vl：从汇点起，弧头的最早开始时间减去出边的值，取最小值（看出边，求最小）</p></li><li><p>求活动（边）的最早开始时间 ee：弧尾的最早开始时间</p></li><li><p>求活动（边）的最晚开始时间 el：其弧头的最晚开始时间减去活动时间</p></li></ul><h1 id=查找>查找</h1><h2 id=基本概念-1>基本概念</h2><ul><li>数据表：数据的有限集合</li><li>关键字：字段、属性域；互不相同的关键字也成为主关键字</li><li>查找表：支持查找功能的数据表<ul><li>静态查找表：表中元素固定不变</li><li>动态查找表：表中元素在插入和删除时会得到调整，当查找失败时，将给定值的数据元素插入数据表中</li></ul></li><li>装载因子 / 装填因子：数据表的长度 m 与数据元素个数 n 的比值，$$\alpha=n/m$$</li><li>平均查找长度 ASL (Average Search Length)：n 个关键字，第 i 个元素被查找的概率 P~i~，查找第 i 个元素所需进行关键字的比较次数为 C~i~</li></ul><p>$$
ASL=\sum_{i=1}^nP_i\times C_i
$$</p><h2 id=顺序表>顺序表</h2><h3 id=顺序查找>顺序查找</h3><p>一个一个去找</p><h4 id=一般实现>一般实现</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-C++ data-lang=C++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>SqSearch</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>T</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>key</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=监视哨实现>监视哨实现</h4><p>0 号元素不存内容时，while 中的索引 0 可以起到<strong>监视哨</strong>的作用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>SqSearch</span><span class=p>(</span><span class=n>T</span> <span class=n>elem</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>T</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>elem</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=n>key</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>elem</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>!=</span> <span class=n>key</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=性能分析>性能分析</h4><p>$$
ASL=\sum_{i=1}^n\frac{1}{n}\times i=\frac{n-1}{2}
$$</p><p>优点：算法简单，适应面广，对表的结构或关键字是否有序没有要求</p><p>缺点：查找效率低</p><h3 id=二分查找>二分查找</h3><p>（Binary Search）</p><p>按顺序方式存储 + 关键字排序</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426083900676.png alt=image-20210426083900676 style=zoom:50%><h4 id=迭代实现>迭代实现</h4><h4 id=递归实现>递归实现</h4><h4 id=性能分析-1>性能分析</h4><p>用二叉查找树来分析</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426084515121.png alt=image-20210426084515121 style=zoom:50%>
$$
ASL=\log_2(n+1)-1
$$
优点：特别当 n 大时，效率高<p>缺点：只限于顺序存储结构，只适合做静态查找</p><h3 id=分块查找>分块查找</h3><h4 id=索引顺序表>索引顺序表</h4><p>主表 + 索引表</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426090835254.png alt=image-20210426090835254 style=zoom:50%><p>当完全索引表中的关键字分块有序存放，可以建立二级索引表</p><p>块与块之间有序，块内无序</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426090931149.png alt=image-20210426090931149 style=zoom:50%><h4 id=分块查找-1>分块查找</h4><p>分两次查找</p><h3 id=倒排表>倒排表</h3><p>（Inverted Index List）</p><p>经常搜索的关键字设次索引</p><h4 id=链式倒排表>链式倒排表</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426092552894.png alt=image-20210426092552894 style=zoom:50%><p>寻找时，求交集即可</p><p>表长不定，管理麻烦</p><h4 id=单元素倒排表>单元素倒排表</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426092730832.png alt=image-20210426092730832 style=zoom:50%><h3 id=比较>比较</h3><table><thead><tr><th>要求</th><th>顺序查找</th><th>折半查找</th><th>分块查找</th></tr></thead><tbody><tr><td>ASL</td><td>最大</td><td>最小</td><td>两者之间</td></tr><tr><td>表结构</td><td>有序表、无序表</td><td>有序表</td><td>分块有序表</td></tr><tr><td>存储结构</td><td>顺序存储、线性表</td><td>顺序存储</td><td>顺序存储、线性链表</td></tr></tbody></table><h2 id=二叉排序树>二叉排序树</h2><p>BST（Binary Sort / Search Tree）</p><p>对于链式存储，使用二叉排序树（二叉搜索树），以适应动态查找的要求</p><h3 id=定义-8>定义</h3><ul><li>要不是空树，要不符合以下性质<ul><li>左子树节点关键字都小于根节点</li><li>右子树节点关键字都大于根节点</li><li>左右子树也是二叉排序树</li></ul></li></ul><p>特点：中序遍历结果有序</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426100408810.png alt=image-20210426100408810 style=zoom:50%><h3 id=模板定义>模板定义</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>BinSortTree</span> <span class=o>:</span> <span class=k>public</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 继承二叉树的根节点数据成员
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>BinSortTree</span><span class=p>(</span><span class=n>T</span> <span class=n>refvalue</span><span class=p>)</span> <span class=o>:</span> <span class=n>BinaryTree</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>(</span><span class=n>refvalue</span><span class=p>){};</span>
</span></span><span class=line><span class=cl>    <span class=n>BinSortTree</span><span class=p>(</span><span class=n>T</span> <span class=o>*</span><span class=n>a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>);</span> <span class=c1>// 插入数组元素构建二叉排序树, 不用判断
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>~</span><span class=n>BinSortTree</span><span class=p>()</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Insert</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>,</span> <span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>p</span><span class=p>);</span> <span class=c1>// 以p为根节点, 按大小插入元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=cm>/*判定是否为二叉排序树*/</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>IsBST_Recursive</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>r</span><span class=p>,</span> <span class=n>T</span> <span class=o>*</span><span class=n>pre</span><span class=p>,</span> <span class=kt>bool</span> <span class=o>*</span><span class=n>result</span><span class=p>);</span> <span class=c1>// 递归方式判断是否为二叉排序树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>IsBST_Recursive</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>DisplayLarger</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>);</span> <span class=c1>// 从大到小输出不小于x的元素
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>DisplayLarger</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>DisplayLarger</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>_root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>Find_NoRecursive</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>);</span> <span class=c1>// 在以root为根的子树中查找x
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=nf>Find_NoRecursive</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=k>return</span> <span class=n>Find_NoRecursive</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>_root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>Insert_NoRecursive</span><span class=p>(</span><span class=n>BinTreeNode</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>*&amp;</span><span class=n>root</span><span class=p>,</span> <span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>);</span> <span class=c1>// 在以root为根的子树中插入x
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=nf>Insert_NoRecursive</span><span class=p>(</span><span class=k>const</span> <span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>)</span> <span class=p>{</span> <span class=n>Insert_NoRecursive</span><span class=p>(</span><span class=k>this</span><span class=o>-&gt;</span><span class=n>_root</span><span class=p>,</span> <span class=n>x</span><span class=p>);</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=nf>SearchOrInsert</span><span class=p>(</span><span class=n>T</span> <span class=o>&amp;</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=查找-1>查找</h3><ul><li>步骤<ol><li>从根开始将 x 与节点值进行比较</li><li>若 x 小，沿着左子树搜索</li><li>若 x 大，沿着右子树搜索</li><li>若与 x 相等，查找成功；若为空则查找失败</li></ol></li></ul><p>比较次数不大于 <code>h + 1</code></p><h3 id=性能分析-2>性能分析</h3><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210426101235491.png alt=image-20210426101235491 style=zoom:40%><h3 id=操作>操作</h3><h4 id=插入>插入</h4><p>先搜索 BST 中有无该节点，无才插入</p><p>查找失败时插入</p><h4 id=删除>删除</h4><p>被删节点为叶子，将双亲结点的相应指针置空</p><p>被删节点无右子树，拿左孩子顶替它的位置</p><p>被删节点无左子树，拿右孩子顶替它的位置</p><p>被删节点左右子树都有</p><ol><li>左子树找最大</li><li>或者右子树找最小</li></ol><h2 id=平衡二叉树>平衡二叉树</h2><p>AVL</p><h3 id=定义-9>定义</h3><ul><li><p>或是空树，或是符合以下条件的二叉排序树</p></li><li><p>左右子树都是平衡二叉树。</p></li><li><p>左右子树的高度差值不超过 1</p></li><li><p>平衡因子（Balance factor，BF）：左右子树高度差，其绝对值不超过 1</p></li><li><p>其 ASL 可保持在 $$O(log_2n)$$</p></li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510080329179.png alt=image-20210510080329179 style=zoom:60%><h3 id=平衡旋转>平衡旋转</h3><h4 id=ll-平衡旋转右单旋转>LL 平衡旋转——右单旋转</h4><p>左孩子的左子树失衡</p><p>顺时针旋转</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510081108724.png alt=image-20210510081108724 style=zoom:70%><h4 id=rr-平衡旋转左单旋转>RR 平衡旋转——左单旋转</h4><p>右孩子的右子树失衡</p><p>逆时针旋转</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510081227246.png alt=image-20210510081227246 style=zoom:70%><h4 id=lr-平衡旋转先左后右双旋转>LR 平衡旋转——先左后右双旋转</h4><p>先逆时针再顺时针</p><p>左孩子的右子树失衡</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510081304603.png alt=image-20210510081304603 style=zoom:70%><h4 id=rl-平衡旋转先右后左双旋转>RL 平衡旋转——先右后左双旋转</h4><p>右孩子的左子树失衡</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510081355449.png alt=image-20210510081355449 style=zoom:70%><h3 id=插入-1>插入</h3><h4 id=思想>思想</h4><ol><li>按二叉树的排序性质插入节点</li><li>若插入后产生失衡，继续步骤 3，否则结束</li><li>找到失衡的最小子树</li><li>判断平衡旋转类型，进行相应的平衡化处理</li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510083139739.png alt=image-20210510083139739 style=zoom:55%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510083150370.png alt=image-20210510083150370 style=zoom:55%><h4 id=示例>示例</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510083216777.png alt=image-20210510083216777 style=zoom:60%><h3 id=删除-1>删除</h3><h4 id=思想-1>思想</h4><p>定义布尔变量 <code>isShorter</code> 判断被删除结点的子树高度有没有被缩短</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510083857938.png alt=image-20210510083857938 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510083915922.png alt=image-20210510083915922 style=zoom:50%><h4 id=示例-1>示例</h4><p>删除结点 50</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510084127101.png alt=image-20210510084127101 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210613131053818.png alt=image-20210613131053818 style=zoom:80%><h2 id=b--树>B- 树</h2><p>二叉排序树适合在内存中组织较小的索引；若对于存放在外存中的较大的文件系统，使用 B- 树或 B+ 树做文件索引</p><h3 id=动态的-m-路查找树>动态的 m 路查找树</h3><p><strong>定义</strong></p><ul><li>或是空树，或满足以下条件</li><li>根节点最多有 m 棵树并具有结构 $$(n,p_0,k_1,p_1,k_2,p_2,\cdots,k_n,p_n)$$。其中，$$p_i$$ 是指向子树的指针，$$k_i$$ 是数据元素的关键字；$$1\le i\le n&lt;m$$</li><li>$$k_i&lt;k_{i+1},i\le i&lt;n$$</li><li>在 $$p_i$$ 所指的子树中所有数据元素的关键字都大于 $$k_i$$，且小于 $$k_{i+1}$$，$$0\le i\le n$$</li><li>在 $$p_n$$ 所指的子树中所有数据元素的关键字都大于 $$k_n$$，而子树 $$p_0$$ 中的所有数据元素的关键字均小于 $$k_1$$</li><li>$$p_i$$ 所指的子树也是 m 路查找树，$$0\le i\le n$$</li></ul><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510090656452.png alt=image-20210510090656452 style=zoom:50%><h3 id=定义-10>定义</h3><p>一颗 m 阶的 B- 树是一种平衡的 m 路查找树，通常用于文件系统（外查找）</p><p>失败节点即叶子节点</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510090920715.png alt=image-20210510090920715 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510091034784.png alt=image-20210510091034784 style=zoom:50%><h3 id=插入-2>插入</h3><h4 id=思路>思路</h4><p>插入指在结点中插入关键字</p><p>关键字数在 $$[\lceil m/2 \rceil-1,m-1]$$ 之间</p><p>若关键字超出 m-1，结点要分裂</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510092154652.png alt=image-20210510092154652 style=zoom:50%><p>插入是个递归的过程</p><h4 id=示例-2>示例</h4><p>按照关键字 {35，26，74，60，49，17，41，53，29} 构建 3 阶 B-树</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510092510793.png alt=image-20210510092510793 style=zoom:60%><h3 id=删除-2>删除</h3><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510093239533.png alt=image-20210510093239533 style=zoom:60%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510093539490.png alt=image-20210510093539490 style=zoom:60%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510093553411.png alt=image-20210510093553411 style=zoom:60%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510093634951.png alt=image-20210510093634951 style=zoom:60%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510095925874.png alt=image-20210510095925874 style=zoom:67%><h3 id=b树>B+树</h3><h4 id=定义-11>定义</h4><p>叶子结点包含了全部关键字及对应指针</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510100347513.png alt=image-20210510100347513 style=zoom:50%><h2 id=散列表>散列表</h2><p>基本思想：在存储地址和关键字之间构建一个确定的对应关系。不经过比较就能在一次存取中得到所查元素</p><h3 id=定义-12>定义</h3><ul><li><p>哈希函数：在存储地址和关键字之间构建一个确定的对应关系/函数 $$Addr(ai)=H(ki)$$</p></li><li><p>哈希表/散列表</p></li><li><p>哈希存储/散列存储</p></li><li><p>哈希查找/散列查找</p></li><li><p>冲突 (collision)：$$key1\neq key2,H(key1)=H(key2)$$</p></li></ul><h3 id=哈希函数>哈希函数</h3><p>定义域：全部关键字</p><p>值域：0 到 m-1 之间</p><h4 id=构造方法>构造方法</h4><p>不是重点</p><ul><li><p>直接定址法</p><p>$$H(key)=a*key+b$$，无冲突，但是要求散列地址空间大小与关键字集合大小相同</p></li><li><p>数字分析法</p></li><li><p>除留余数法</p></li><li><p>随机数法</p></li></ul><h3 id=处理冲突>处理冲突</h3><h4 id=开放地址法>开放地址法</h4><p>当冲突发生时，形成一个探查序列，逐个探查，直到找出一个空位置</p><p><strong>探查序列</strong></p><ol><li>线性探测再散列<ul><li>d~i~=1,2,3,&mldr;,m-1</li></ul></li><li>二次探测再散列<ul><li>d~i~=1^2^,-1^2^,2^2^,-2^2^,&mldr;,k^2^,-k^2^</li></ul></li><li>伪随机探测再散列<ul><li>d~i~=伪随机序列</li></ul></li><li>双散列函数探查法<ul><li>d~i~=iH~2~(key)[计算时间增加]</li></ul></li></ol><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510102542131.png alt=image-20210510102542131 style=zoom:40%><h4 id=拉链法>拉链法</h4><p>将所有关键字为同义词的记录存储在一个单链表中，并用一维数组存放头指针</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510102941399.png alt=image-20210510102941399 style=zoom:50%><h3 id=哈希查找>哈希查找</h3><h4 id=过程>过程</h4><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510103146013.png alt=image-20210510103146013 style=zoom:50%><h4 id=分析>分析</h4><p>用 ASL 分析效率</p><p>装填因子：$$\alpha=\frac{表中填入的记录数}{哈希表长度}$$</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510103516617.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510103516617.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510103516617.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510103516617.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210510103516617.png title=image-20210510103516617></p><h1 id=排序>排序</h1><p>原理和算法实现不一定对应</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524094014136.png alt=image-20210524094014136 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20180402133438219-1946132192.png style=zoom:40%><h2 id=基础知识>基础知识</h2><ul><li><p>排序（sorting）</p></li><li><p>关键字（key）：分主次关键字</p></li><li><p>排序表</p></li><li><p>排序的稳定性：两个相同值的关键字的相对位置在排序后是否发生变化</p></li><li><p>内部排序：待排的数据在内存上</p></li><li><p>排序的基本操作：比较次数、移动次数</p></li><li><p>趟：对所有数据进行一次操作</p></li></ul><h3 id=分组>分组</h3><ul><li>按排序依据原则分组<ul><li>插入排序</li><li>交换排序</li><li>选择排序</li><li>归并排序</li><li>基数排序（分配排序）</li></ul></li><li>按排序所需工作量分组<ul><li>简单的排序方法：$$T(n)=O(n^2)$$</li><li>先进的排序方法：$$T(n)=O(log_n)$$</li><li>基数排序：$$T(n)=O(d.n)$$</li></ul></li></ul><h3 id=排序的存储方式>排序的存储方式</h3><p>顺序表、链表、类静态链表</p><h3 id=各种排序方法的选用>各种排序方法的选用</h3><ul><li>时间复杂度</li><li>空间复杂度</li><li>稳定性</li><li>算法结构鲁棒性</li><li>参加排序数据的规模<ul><li>较少，采用简单的排序方法<ul><li>直接插入排序，选择排序</li></ul></li><li>较大，选用执行时间与 $$nlog_2n$$ 成正比的排序方法<ul><li>快速排序，希尔排序，堆排序，归并排序</li></ul></li><li>较大，且关键字位数少<ul><li>基数排序</li></ul></li></ul></li><li>关键字的分布情况<ul><li>分布平均、随机<ul><li>快速排序（时间短）、堆排序（空间少），希尔排序（也可）</li></ul></li><li>分组基本有序<ul><li>冒泡排序、直接插入排序</li></ul></li></ul></li></ul><h2 id=交换排序>交换排序</h2><p>（Exchange Sort）</p><p>对两个数据比较，如果逆序，则两者交换位置</p><h3 id=冒泡排序>冒泡排序</h3><p>两两相比，重复，每次循环只确定一个最大/小值</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015223238449-2146169197.gif data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015223238449-2146169197.gif, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015223238449-2146169197.gif 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015223238449-2146169197.gif 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015223238449-2146169197.gif title=img></p><h4 id=实现-3>实现</h4><p>顺序表实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>BubbleSort</span><span class=p>(</span><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>list</span><span class=p>.</span><span class=n>GetLength</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>list</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>list</span><span class=p>.</span><span class=n>ExchangeElem</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=分析-1>分析</h4><ul><li><p>比较次数：$$\sum\limits_{i=1}^{n-1}(n-i)= n(n-1)/2$$</p></li><li><p>移动次数：$$3\sum\limits_{i=1}^{n-1}(n-i)= 3n(n-1)/2$$</p></li><li><p>平均时间复杂度：$$O(n^2)$$</p><ul><li>最好情况 $$O(n)$$，最坏情况 $$O(n^2)$$</li></ul></li><li><p>空间复杂度：$$S(n)=O(1)$$</p></li><li><p>稳定</p></li></ul><h3 id=快速排序>快速排序</h3><p>（quick sort）</p><p>任取某个元素作为基准，划分左右子表，再在左右子表中递归快排</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210517094051933.png alt=image-20210517094051933 style=zoom:50%><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif data-srcset="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif, https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif 1.5x, https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif 2x" data-sizes=auto alt=https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif title=1></p><h4 id=实现-4>实现</h4><p>一般实现思路</p><ul><li>选第一个作为基准 i，从最后一个开始比较，记为 j</li><li>发生逆序，i，j 上的元素互换</li><li>若一次比较后<ul><li>基准在前，j &ndash;，与后面比；</li><li>基准在后，i ++，与前面比</li></ul></li><li>对左右子表进行递归</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph LR
</span></span><span class=line><span class=cl>	start[开始]--&gt;con1{&#34;i &lt; j?&#34;}
</span></span><span class=line><span class=cl>	con1 -- NO --&gt; recurve[&#34;结束一次快排&#34;]
</span></span><span class=line><span class=cl>    con1 -- YES --&gt; con2{&#34;Elem[i] &gt; Elem[j]?&#34;}
</span></span><span class=line><span class=cl>    con2 -- YES --&gt; exchange[&#34;i,j 值互换&#34;]
</span></span><span class=line><span class=cl>	exchange ---&gt; pivot{&#34;基准位置?&#34;}
</span></span><span class=line><span class=cl>	con2 -- NO --&gt;pivot
</span></span><span class=line><span class=cl>	pivot -- &#34;前&#34; --&gt; j[&#34;j--&#34;]
</span></span><span class=line><span class=cl>	pivot -- &#34;后&#34; --&gt; i[&#34;i++&#34;]
</span></span><span class=line><span class=cl>	i --&gt; finish[&#34;下次循环&#34;]
</span></span><span class=line><span class=cl>	j --&gt; finish
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	finish --&gt; con1
</span></span></code></pre></td></tr></table></div></div><p>顺序表实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>QuickSortHelp</span><span class=p>(</span><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>start</span><span class=p>;</span>             <span class=c1>// 基准
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>end</span><span class=p>;</span>               <span class=c1>// 从最后开始比较
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>bool</span> <span class=n>pivotLocation</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span> <span class=c1>// true表示基准位置在前
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>j</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>i</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>j</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span><span class=p>.</span><span class=n>ExchangeElem</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>pivotLocation</span> <span class=o>=</span> <span class=o>!</span><span class=n>pivotLocation</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pivotLocation</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 基准位置在前
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>j</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 基准位置在后
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>start</span> <span class=o>&lt;</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>QuickSortHelp</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>start</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&lt;</span> <span class=n>end</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>QuickSortHelp</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>end</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>QuickSort</span><span class=p>(</span><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>QuickSortHelp</span><span class=p>(</span><span class=n>list</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>list</span><span class=p>.</span><span class=n>GetLength</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=分析-2>分析</h4><ul><li>比较次数：$$\sum\limits_{i=1}^{n-1}(n-i)= n(n-1)/2$$</li><li>移动次数：$$3\sum\limits_{i=1}^{n-1}(n-i)= 3n(n-1)/2$$</li><li>平均时间复杂度：$$O(nlog_2n)$$<ul><li>最好情况 $$O(nlog_2n)$$，最坏情况 $$O(n^2)$$</li></ul></li><li>空间复杂度<ul><li>最坏情况 $$S(n)=O(n)$$</li><li>一般情况 $$S(n)=O(nlog_2n)$$</li></ul></li><li>不稳定</li></ul><h2 id=插入排序>插入排序</h2><p>（Insertion Sort）</p><p>每次把一个数据插入到已经排序的序列中</p><h3 id=直接插入排序>直接插入排序</h3><p>（Straight Insertion Sort）</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1258817-20190325144034879-1237555952.gif data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1258817-20190325144034879-1237555952.gif, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1258817-20190325144034879-1237555952.gif 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1258817-20190325144034879-1237555952.gif 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1258817-20190325144034879-1237555952.gif title=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/1258817-20190325144034879-1237555952.gif></p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210517082910800.png alt=image-20210517082910800 style=zoom:60%><h4 id=实现-5>实现</h4><p>线性表实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>T</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>StraightInsertionSort</span><span class=p>(</span><span class=n>SeqList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>list</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>list</span><span class=p>.</span><span class=n>GetLength</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>// 遍历无序区
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>T</span> <span class=n>e</span> <span class=o>=</span> <span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>i</span><span class=p>);</span> <span class=c1>// 取出无序区第一个元素
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>j</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>e</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>list</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>list</span><span class=p>.</span><span class=n>GetElem</span><span class=p>(</span><span class=n>j</span><span class=p>));</span> <span class=c1>// 将比e大的元素后移一位
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>list</span><span class=p>.</span><span class=n>SetElem</span><span class=p>(</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>e</span><span class=p>);</span>                   <span class=c1>//在j+1处插入e
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=分析-3>分析</h4><ul><li><p>比较次数：$$\sum\limits_{i=1}^{n-1}i=n(n-1)/2\approx n^2/2$$</p></li><li><p>移动次数：$$\sum\limits_{i=1}^{n-1}i+2=(n+4)(n-1)/2\approx n^2/2$$</p></li><li><p>平均时间复杂度：$$O(n^2)$$</p><ul><li>最好情况 $$O(n)$$，最坏情况 $$O(n^2)$$</li><li>初始数据表越接近有序，效率越高</li></ul></li><li><p>空间复杂度：$$S(n)=O(1)$$</p></li><li><p>稳定</p></li></ul><h3 id=折半插入排序>折半插入排序</h3><p>（Binary Insertion Sort）</p><p>相对于直接插入排序，在插入时，折半插入排序不是一个个比，而是利用<strong>折半查找</strong>来寻找位置</p><p>只能用于顺序存储</p><h4 id=实现-6>实现</h4><h4 id=分析-4>分析</h4><ul><li><p>比较次数减少了</p></li><li><p>时间复杂度、空间复杂度与直接插入排序相同</p></li><li><p>单纯的折半不能保证稳定性</p></li></ul><h3 id=希尔排序>希尔排序</h3><p>（Shell Sort）又称缩小增量排序</p><p>先将待排关键字分为若干子列分别用直接插入法排序，再对全体关键字用直接插入排序</p><p>n 个元素，取长度 d &lt; n 作为间隔，分出 d 个子表，所有相距 d 的数据元素放在同一子表中，子表中进行直接插入排序；然后再缩小 d（如取 $$d=\lceil d/2 \rceil$$），重复迭代直到 d = 1 后，将所有数据一起来依一次直接插入排序</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210517090706915.png alt=image-20210517090706915 style=zoom:50%><h4 id=分析-5>分析</h4><ul><li>不稳定</li></ul><h2 id=选择排序>选择排序</h2><p>（Selection Sort）</p><h3 id=简单选择排序>简单选择排序</h3><p>（Simple selection sort）</p><p>在序列中首先找到最小元素放在首位，再在未排序序列（无序区）中寻找最小元素放在已排序序列（有序区）末尾，以此类推</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210517102931312.png alt=image-20210517102931312 style=zoom:50%><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015224719590-1433219824.gif data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015224719590-1433219824.gif, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015224719590-1433219824.gif 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015224719590-1433219824.gif 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015224719590-1433219824.gif title=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015224719590-1433219824.gif></p><h4 id=实现-7>实现</h4><h4 id=分析-6>分析</h4><ul><li><p>相较于冒泡排序，移动次数减少</p></li><li><p>平均时间复杂度：$$O(n^2)$$</p><ul><li>最好情况 $$O(n^2)$$，最坏情况 $$O(n^2)$$</li></ul></li><li><p>空间复杂度：$$S(n)=O(1)$$</p></li><li><p>不稳定</p></li></ul><h3 id=锦标赛排序>锦标赛排序</h3><p>（Tournament sort）又称树形选择排序</p><p>将 n 个元素两两分组，分别比较，得到 n/2 个优胜者，保留结果；对优胜者继续比较，以此类推。</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210517103442290.png alt=image-20210517103442290 style=zoom:60%><h4 id=分析-7>分析</h4><ul><li><p>以空间换时间</p></li><li><p>比较次数：$$O(nlog_2n)$$</p></li><li><p>时间复杂度：$$O(nlog_2n)$$</p></li><li><p>空间复杂度：</p></li><li><p>不稳定</p></li></ul><h3 id=堆排序>堆排序</h3><p>（Heap sort）</p><p>建堆，输出堆顶，调整堆，以此类推</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210517104227355.png alt=image-20210517104227355 style=zoom:60%><h2 id=归并排序>归并排序</h2><p>（Merge sort）</p><p>归并：将两个（二路归并）或两个以上的有序表合并成一个新的有序表</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524080251828.png alt=image-20210524080251828 style=zoom:50%><h3 id=二路归并排序>二路归并排序</h3><p>一直两两归并，顺序存储时，另外开辟空间</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524081059143.png alt=image-20210524081059143 style=zoom:50%>
<img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524080641843.png alt=image-20210524080641843 style=zoom:67%><h4 id=实现-8>实现</h4><h4 id=分析-8>分析</h4><ul><li><p>以空间换时间</p></li><li><p>时间复杂度：$$O(nlog_2n)$$</p></li><li><p>空间复杂度：$$O(n)$$</p></li><li><p>稳定</p></li></ul><h3 id=递归归并>递归归并</h3><p>一分为二，左右递归</p><h4 id=实现-9>实现</h4><h4 id=分析-9>分析</h4><h2 id=基数排序>基数排序</h2><p>（Radix sort）也叫桶排序</p><p>本质：多关键字排序</p><ul><li>最高位优先法（Most significant digit first）MSD</li><li>最低位优先法（Least significant digit first）LSD</li></ul><p>基数：关键字取值的种数</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015232453668-1397662527.gif data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015232453668-1397662527.gif, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015232453668-1397662527.gif 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015232453668-1397662527.gif 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015232453668-1397662527.gif title=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/849589-20171015232453668-1397662527.gif></p><h3 id=链式基数排序>链式基数排序</h3><p>用链表模拟队列</p><img src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524092533926.png alt=image-20210524092533926 style=zoom:50%><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524093145089.png data-srcset="http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524093145089.png, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524093145089.png 1.5x, http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524093145089.png 2x" data-sizes=auto alt=http://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210524093145089.png title=image-20210524093145089></p><h4 id=分析-10>分析</h4><ul><li>时间复杂度 n 记录数，d 关键字位数，radix 关键字取值范围<ul><li>$$O(d(n+radix))$$，即—— n 趟 * （n 次分配 + radix 次收集）</li></ul></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2022-03-22</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/>数据结构</a>,&nbsp;<a href=/Notes/tags/%E7%AE%97%E6%B3%95/>算法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/homework/database/ex2/ class=prev rel=prev title><i class="fas fa-angle-left fa-fw"></i></a>
<a href=/Notes/posts/courses/digitalimageprocessing/ class=next rel=next title=数字图像整理>数字图像整理<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>酒困路长惟欲睡，日高人渴漫思茶</div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2022</span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><script type=text/javascript src=/Notes/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/Notes/lib/clipboard/clipboard.min.js></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:45},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js></script></body></html>