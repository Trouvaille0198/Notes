<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>算法设计与分析 - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="题型 填空 10-12 分，概念 单选 20 分 综合大题 4 道，其中 2-3 小题 算法设计，写出复杂度的递推公式"><meta name=keywords content="算法"><meta itemprop=name content="算法设计与分析"><meta itemprop=description content="题型 填空 10-12 分，概念 单选 20 分 综合大题 4 道，其中 2-3 小题 算法设计，写出复杂度的递推公式"><meta itemprop=datePublished content="2021-11-25T00:00:00+00:00"><meta itemprop=dateModified content="2022-08-21T12:08:57+00:00"><meta itemprop=wordCount content="12422"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="算法,"><meta property="og:title" content="算法设计与分析"><meta property="og:description" content="题型 填空 10-12 分，概念 单选 20 分 综合大题 4 道，其中 2-3 小题 算法设计，写出复杂度的递推公式"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-11-25T00:00:00+00:00"><meta property="article:modified_time" content="2022-08-21T12:08:57+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="算法设计与分析"><meta name=twitter:description content="题型 填空 10-12 分，概念 单选 20 分 综合大题 4 道，其中 2-3 小题 算法设计，写出复杂度的递推公式"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/linux/%E5%9F%BA%E7%A1%80/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"算法设计与分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/courses\/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90\/"},"genre":"posts","keywords":"算法","wordcount":12422,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/courses\/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90\/","datePublished":"2021-11-25T00:00:00+00:00","dateModified":"2022-08-21T12:08:57+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>算法设计与分析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/%E4%B8%93%E4%B8%9A%E8%AF%BE/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;专业课</a></span></div><div class=post-meta-line><span title="2021-11-25 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-11-25>2021-11-25</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 12422 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 25 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#认识>认识</a><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#p-问题与-np-问题>P 问题与 NP 问题</a></li><li><a href=#算法渐进复杂性>算法渐进复杂性</a></li><li><a href=#增长的阶>增长的阶</a><ul><li><a href=#符号意义>符号意义</a></li><li><a href=#复杂性阶的理解举例>复杂性阶的理解举例</a></li><li><a href=#理解>理解</a></li><li><a href=#各记号在等式和不等式中的意义>各记号在等式和不等式中的意义</a></li><li><a href=#性质>性质</a></li></ul></li></ul></li><li><a href=#递归>递归</a><ul><li><a href=#定义>定义</a></li><li><a href=#例>例</a><ul><li><a href=#例-1>例 1</a></li><li><a href=#ackerman>Ackerman</a></li><li><a href=#排列问题-perm>排列问题 Perm()</a></li><li><a href=#整数划分问题>整数划分问题</a></li><li><a href=#hanoi-汉诺塔问题>hanoi 汉诺塔问题</a></li></ul></li><li><a href=#原理>原理</a></li><li><a href=#递归程序代价>递归程序代价</a></li></ul></li><li><a href=#分治>分治</a><ul><li><a href=#定义-1>定义</a></li><li><a href=#代价分析>代价分析</a></li><li><a href=#二分搜索技术>二分搜索技术</a><ul><li><a href=#基本思想>基本思想</a></li><li><a href=#算法实现>算法实现</a></li><li><a href=#复杂性>复杂性</a></li></ul></li><li><a href=#大整数的乘法>大整数的乘法</a><ul><li><a href=#小学生算法>小学生算法</a></li><li><a href=#一种毫无进步的分治>一种毫无进步的分治</a></li><li><a href=#另一种分治>另一种分治</a></li></ul></li><li><a href=#strassen-矩阵乘法>strassen 矩阵乘法</a><ul><li><a href=#传统方法>传统方法</a></li><li><a href=#垃圾的分治方法>垃圾的分治方法</a></li><li><a href=#好分治>好分治</a></li></ul></li><li><a href=#棋盘覆盖>棋盘覆盖</a><ul><li><a href=#基本思想-1>基本思想</a></li><li><a href=#算法实现-1>算法实现</a></li><li><a href=#复杂性-1>复杂性</a></li></ul></li><li><a href=#合并排序>合并排序</a><ul><li><a href=#基本思想-2>基本思想</a></li><li><a href=#递归算法>递归算法</a><ul><li><a href=#实现>实现</a></li><li><a href=#复杂性-2>复杂性</a></li></ul></li><li><a href=#非递归的分治算法>非递归的分治算法</a><ul><li><a href=#实现-1>实现</a></li><li><a href=#复杂性-3>复杂性</a></li></ul></li><li><a href=#复杂性-4>复杂性</a></li></ul></li><li><a href=#快速排序>快速排序</a><ul><li><a href=#算法实现-2>算法实现</a></li><li><a href=#复杂度>复杂度</a></li></ul></li><li><a href=#线性时间选择>线性时间选择</a><ul><li><a href=#模仿快排的很拉的分治算法>模仿快排的、很拉的分治算法</a></li><li><a href=#改进的分治>改进的分治</a></li></ul></li><li><a href=#最接近点对问题>最接近点对问题</a><ul><li><a href=#一维>一维</a></li><li><a href=#二维>二维</a></li><li><a href=#算法>算法</a></li><li><a href=#复杂度-1>复杂度</a></li></ul></li><li><a href=#循环赛程表问题>循环赛程表问题</a></li></ul></li><li><a href=#动态规划>动态规划</a><ul><li><a href=#定义-2>定义</a></li><li><a href=#基本要素>基本要素</a><ul><li><a href=#动态规划的基本要素><strong>动态规划的基本要素</strong></a></li></ul></li><li><a href=#矩阵连乘>矩阵连乘</a><ul><li><a href=#问题叙述><strong>问题叙述</strong></a></li><li><a href=#算法分析>算法分析</a></li><li><a href=#计算最优值>计算最优值</a></li><li><a href=#构造最优解>构造最优解</a></li></ul></li><li><a href=#最长公共子序列>最长公共子序列</a><ul><li><a href=#概念><strong>概念</strong></a></li><li><a href=#递归-1>递归</a></li><li><a href=#代码>代码</a></li></ul></li><li><a href=#最大子段和>最大子段和</a><ul><li><a href=#问题描述><strong>问题描述</strong></a></li><li><a href=#分治策略><strong>分治策略</strong></a></li><li><a href=#动态规划-1><strong>动态规划</strong></a></li><li><a href=#推广最大子矩阵和问题><strong>推广</strong>：<strong>最大子矩阵和问题</strong></a></li></ul></li><li><a href=#凸多边形最优三角剖分>凸多边形最优三角剖分</a></li><li><a href=#流水作业调度>流水作业调度</a><ul><li><a href=#问题描述-1><strong>问题描述</strong></a></li><li><a href=#算法分析-1><strong>算法分析</strong></a></li><li><a href=#最优子结构性质><strong>最优子结构性质</strong></a></li><li><a href=#递归关系>递归关系</a></li><li><a href=#johnson-不等式><strong>Johnson 不等式</strong></a></li></ul></li><li><a href=#0-1-背包问题>0-1 背包问题</a><ul><li><a href=#问题描述-2><strong>问题描述</strong></a></li><li><a href=#证明最优子结构性质>证明最优子结构性质</a></li><li><a href=#递归关系-1>递归关系</a></li></ul></li></ul></li><li><a href=#贪心算法>贪心算法</a><ul><li><a href=#活动安排问题>活动安排问题</a><ul><li><a href=#问题描述-3><strong>问题描述</strong></a></li><li><a href=#求解策略><strong>求解策略</strong></a></li></ul></li><li><a href=#贪心算法的基本要素>贪心算法的基本要素</a><ul><li><a href=#问题具有贪心选择性质的证明方法><strong>问题具有贪心选择性质的证明方法</strong></a></li><li><a href=#贪心算法与动态规划算法的差异><strong>贪心算法与动态规划算法的差异</strong></a></li><li><a href=#一般背包问题的贪心选择性质证明>一般背包问题的贪心选择性质证明</a></li></ul></li><li><a href=#最优装载>最优装载</a><ul><li><a href=#问题描述-4><strong>问题描述</strong></a></li><li><a href=#算法描述><strong>算法描述</strong></a></li><li><a href=#性质证明>性质证明</a></li></ul></li><li><a href=#哈夫曼编码>哈夫曼编码</a><ul><li><a href=#问题描述-5><strong>问题描述</strong></a></li><li><a href=#编码方法><strong>编码方法</strong></a></li><li><a href=#构造哈夫曼编码><strong>构造哈夫曼编码</strong></a></li><li><a href=#哈夫曼树><strong>哈夫曼树</strong></a></li><li><a href=#哈夫曼树的实现方式与复杂性><strong>哈夫曼树的实现方式与复杂性</strong></a></li></ul></li><li><a href=#单源最短路径>单源最短路径</a><ul><li><a href=#问题描述-6><strong>问题描述</strong></a></li><li><a href=#dijkstra-算法基本思想><strong>Dijkstra 算法基本思想</strong></a></li></ul></li></ul></li><li><a href=#回溯法>回溯法</a><ul><li><a href=#回溯法的算法框架>回溯法的算法框架</a><ul><li><a href=#问题的解空间><strong>问题的解空间</strong></a></li><li><a href=#回溯法-1><strong>回溯法</strong></a></li><li><a href=#子集树与排列树><strong>子集树与排列树</strong></a></li></ul></li><li><a href=#装载问题>装载问题</a><ul><li><a href=#问题描述-7><strong>问题描述</strong></a></li><li><a href=#最优装载方案><strong>最优装载方案</strong></a></li><li><a href=#装载问题的回溯法><strong>装载问题的回溯法</strong></a></li></ul></li><li><a href=#批处理作业调度>批处理作业调度</a><ul><li><a href=#问题描述-8><strong>问题描述</strong></a></li><li><a href=#算法设计>算法设计</a></li></ul></li><li><a href=#n-后问题>n 后问题</a><ul><li><a href=#问题描述-9><strong>问题描述</strong></a></li><li><a href=#算法分析-2><strong>算法分析</strong></a></li></ul></li><li><a href=#0-1-背包问题-1>0-1 背包问题</a></li><li><a href=#最大团问题>最大团问题</a><ul><li><a href=#概念-1>概念</a></li><li><a href=#算法分析-3><strong>算法分析</strong></a></li><li><a href=#启发式信息>启发式信息</a></li></ul></li></ul></li><li><a href=#分支限界法>分支限界法</a><ul><li><a href=#概念-2>概念</a><ul><li><a href=#与回溯法的不同>与回溯法的不同</a></li><li><a href=#基本思想-3>基本思想</a></li><li><a href=#方法>方法</a></li><li><a href=#术语>术语</a></li><li><a href=#子集树与排列数的算法框架>子集树与排列数的算法框架</a></li></ul></li><li><a href=#装载问题-1>装载问题</a><ul><li><a href=#描述>描述</a></li><li><a href=#队列式分支限界法>队列式分支限界法</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><p>题型</p><p>填空 10-12 分，概念</p><p>单选 20 分</p><p>综合大题 4 道，其中 2-3 小题</p><ul><li>算法设计，写出复杂度的递推公式（分治法），并推导；动态方程/递归方程</li><li>程序填空（回溯法）</li><li>手工操作题（分支限界法：解空间树、队列变化次序……）</li></ul><h1 id=算法设计与分析>算法设计与分析</h1><h2 id=认识>认识</h2><h3 id=基本概念>基本概念</h3><p><strong>算法</strong></p><ul><li>有穷规则的集合，其中的规则规定了解决某一特殊问题的<strong>一系列运算</strong>；计算序列</li><li>特点<ul><li>输入（零个或多个）</li><li>输出（至少一个）</li><li>确定性</li><li>有限性（执行次数、执行时间）</li><li>可行性</li></ul></li></ul><p><strong>程序</strong>：数据结构 + 算法</p><h3 id=p-问题与-np-问题>P 问题与 NP 问题</h3><p>（<strong>会考概念</strong>）</p><p><strong>P 问题</strong>：Polynomial Problem，多项式时间复杂度内能解的问题</p><p><strong>NP 问题</strong>：Non-deterministic Polynomial Problem，<strong>非确定性</strong>多项式时间能解的问题，可以在多项式时间复杂度内对猜测进行验证</p><p><strong>NPC 问题</strong>：NP-Complete，多项式时间内可转化为任意 NP 问题，可视为代表性 NP 问题</p><p>P 问题是确定计算模式下的易解问题，NP 问题是非确定性计算模式下的易验证问题，$P \subseteq NP$</p><h3 id=算法渐进复杂性>算法渐进复杂性</h3><p>粗略理解：取 T(n) 的<strong>高阶</strong>，即为渐进表达式</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132329296.png alt=image-20210909132329296 style=zoom:50%><h3 id=增长的阶>增长的阶</h3><p>用增长的阶来衡量算法复杂度</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132341701.png alt=image-20210909132341701 style=zoom:50%><p>g(n) 比 f(n) 结构要简单，可以近似代表 f(n)</p><h4 id=符号意义>符号意义</h4><p>（<strong>看</strong>）</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132441135.png alt=image-20210909132441135 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909132514428.png alt=image-20210909132514428 style=zoom:50%><h4 id=复杂性阶的理解举例>复杂性阶的理解举例</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909134231473.png alt=image-20210909134231473 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909134300379.png alt=image-20210909134300379 style=zoom:50%><h4 id=理解>理解</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141813886.png alt=image-20210909141813886 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141415681.png alt=image-20210909141415681 style=zoom:33%><h4 id=各记号在等式和不等式中的意义>各记号在等式和不等式中的意义</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141735965.png alt=image-20210909141735965 style=zoom:33%><h4 id=性质>性质</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141843286.png alt=image-20210909141843286 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141856607.png alt=image-20210909141856607 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210909141928128.png alt=image-20210909141928128 style=zoom:33%><h2 id=递归>递归</h2><h3 id=定义>定义</h3><ul><li>递归算法：一个直接或间接地调用自身的算法</li><li>递归函数：使用函数自身给出定义的函数</li><li>递归方程：对于递归算法，一般可把时间代价表示为一个递归方程</li><li>解递归方程最常用的方法是进行递归扩展<ul><li>边界条件</li><li>递归关系</li></ul></li></ul><h3 id=例>例</h3><p><strong>初始条件</strong>与<strong>递归方程</strong>是递归函数的两个要素</p><h4 id=例-1>例 1</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130246852.png alt=image-20210914130246852 style=zoom:33%><h4 id=ackerman>Ackerman</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130327267.png alt=image-20210914130327267 style=zoom:33%><h4 id=排列问题-perm>排列问题 Perm()</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130645860.png alt=image-20210914130645860 style=zoom:33%><p>为便于理解，以 {1,2,3,4,5,6} 为例：</p><p>1 2 3 4 5 6 –> <strong>1</strong> 2 3 4 5 6 –> <strong>1</strong> <strong>2</strong> 3 4 5 6 –> <strong>1 2 3</strong> 4 5 6 –> <strong>1 2 3 4</strong> 5 6 –> <strong>1 2 3 4 5</strong> 6 –> <strong>1 2 3 4</strong> 6 5 –> <strong>1 2 3 4 6</strong> 5</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>template</span><span class=o>&lt;</span><span class=n>class</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Perm</span><span class=p>(</span><span class=n>Type</span> <span class=n>list</span><span class=p>[],</span><span class=kt>int</span> <span class=n>k</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>){</span>			<span class=c1>//产生list[k:m]的所有排列
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=k>if</span><span class=p>(</span><span class=n>k</span><span class=o>==</span><span class=n>m</span><span class=p>){</span>									<span class=c1>//只剩下一个元素，到达递归的最底层
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>m</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span><span class=p>{</span>										<span class=c1>//还有多个元素待排列，递归产生排列
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>k</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>m</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Swap</span><span class=p>(</span><span class=n>list</span><span class=p>[</span><span class=n>k</span><span class=p>],</span><span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>Perm</span><span class=p>(</span><span class=n>list</span><span class=p>,</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>m</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>Swap</span><span class=p>(</span><span class=n>list</span><span class=p>[</span><span class=n>k</span><span class=p>],</span><span class=n>list</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>				<span class=c1>//复位，保证所有元素都能依次做前缀
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>template</span><span class=o>&lt;</span><span class=n>class</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kr>inline</span> <span class=kt>void</span> <span class=n>Swap</span><span class=p>(</span><span class=n>Type</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=n>Type</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Type</span> <span class=n>temp</span><span class=o>=</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>a</span> <span class=o>=</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>b</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=整数划分问题>整数划分问题</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130826534.png alt=image-20210914130826534 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130854067.png alt=image-20210914130854067 style=zoom:33%><ol><li>q(n,1)=1，n≥1。当最大加数 n~1~ 不大于 1 时，任何正整数 n 只有一种划分形式，即 n=1+1+…+1</li><li>q(n,m)=q(n,n)，m≥n。最大加数 n~1~ 不能大于 n。</li><li>q(n,n)=1+q(n,n-1)。正整数 n 的划分由 n~1~=n 的划分和 n~1~≤n-1 的划分组成；n~1~=n 时，划分仅有一种。</li><li>q(n,m-1)+q(n-m,m)，n>m>1。正整数 n 的最大加数 n~1~ 不大于 m 的划分由 n~1~=m 的划分和 n~1~≤m-1 的划分组成。</li></ol><h4 id=hanoi-汉诺塔问题>hanoi 汉诺塔问题</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130932836.png alt=image-20210914130932836 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130947107.png alt=image-20210914130947107 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914130956383.png alt=image-20210914130956383 style=zoom:33%><h3 id=原理>原理</h3><p>也就是<strong>递归调用工作栈</strong></p><p>递归程序逐层调用需要分配存储空间，一旦某一层被启用，就要为之开辟新的空间。而当一层执行完毕，释放相应空间掉，退到上一层。</p><ul><li>递归程序逐层调用需要记录调用/返回地址（函数指针）及相关输入，返回参数。</li><li>递归程序逐层调用及返回时需要建立控制转移机制。</li></ul><p><strong>递归优点</strong>：结构清晰，可读性强</p><p><strong>递归缺点</strong>：递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多</p><p><strong>解决方法</strong>：在递归算法中消除递归调用，使其转化为非递归算法。可采用一个用户定义的栈来模拟系统的递归调用工作栈。</p><h3 id=递归程序代价>递归程序代价</h3><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914131136872.png alt=image-20210914131136872 style=zoom:33%><h2 id=分治>分治</h2><h3 id=定义-1>定义</h3><ul><li><p><strong>基本思想</strong></p><ul><li>将问题分解成若干子问题，然后求解子问题。</li><li>子问题较原问题更容易些，由此得出原问题的解，就是所谓的“<strong>分而治之</strong>”的意思。</li><li>分治策略可以递归进行，即子问题仍然可以用分治策略来处理，但最后的问题要非常基本而简单。</li></ul></li><li><p><strong>步骤</strong></p><ul><li>把问题分解为 k 个<strong>性质相同</strong>、但规模较小的子问题，并求解这些子问题。</li><li>逐步合并子问题的解，直到获得原问题的解</li></ul></li><li><p><strong>算法构架</strong></p><ul><li><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914132047694.png alt=image-20210914132047694 style=zoom:50%></li><li><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914132325235.png alt=image-20210914132325235 style=zoom:50%></li></ul></li></ul><h3 id=代价分析>代价分析</h3><p>（<strong>复杂度的推导必考</strong>）</p><p>==递归式==</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914140519132.png alt=image-20210914140519132 style=zoom:50%><ul><li>参数<ul><li>m：子问题总数量</li><li>k：一次分解的子问题数量（一般小于等于 m）<ul><li>n/m：单个子问题的规模</li></ul></li><li>f(n)：merge 的时间复杂度</li></ul></li></ul><p>推导式</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133027722.png alt=image-20210914133027722 style=zoom:50%><p>==又可写成==
$$
T(N)=
\begin{cases}
\ O(N^{log_ba}),\ a>b^k \
\ O(N^klog_bN),\ a=b^k \
\ O(N^k),\ a&lt;b^k \
\end{cases}\ \
之于 \ T(N)=aT(N/b)+N^k
$$</p><p>==推导==</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918124716010.png alt=image-20210918124716010 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918124727349.png alt=image-20210918124727349 style=zoom:50%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918132243595.png alt=image-20210918132243595 style=zoom:50%><h3 id=二分搜索技术>二分搜索技术</h3><p>给定已按升序<strong>排好序</strong>的 n 个元素 a[0:n-1]，现要在这 n 个元素中找出一特定元素 x</p><h4 id=基本思想>基本思想</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133242984.png alt=image-20210914133242984 style=zoom:33%><h4 id=算法实现>算法实现</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133312170.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133312170.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133312170.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133312170.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133312170.png title=image-20210914133312170></p><h4 id=复杂性>复杂性</h4><p>做时间复杂度的推导必考
$$
T(n)=T(n/2)+1
$$</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914133555521.png alt=image-20210914133555521 style=zoom:33%><h3 id=大整数的乘法>大整数的乘法</h3><p>设计一个有效的算法，可以进行两个 n 位大整数的乘法运算</p><h4 id=小学生算法>小学生算法</h4><p>一位位乘</p><p>复杂度为 O(n^2^)</p><h4 id=一种毫无进步的分治>一种毫无进步的分治</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914135309496.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914135309496.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914135309496.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914135309496.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914135309496.png title=image-20210914135309496></p><h4 id=另一种分治>另一种分治</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142652819.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142652819.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142652819.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142652819.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142652819.png title=image-20210914142652819></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210914142743233.png alt=image-20210914142743233 style=zoom:40%><h3 id=strassen-矩阵乘法>strassen 矩阵乘法</h3><p>暂且考虑方阵相乘</p><h4 id=传统方法>传统方法</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131627947.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131627947.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131627947.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131627947.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131627947.png title=image-20210918131627947></p><h4 id=垃圾的分治方法>垃圾的分治方法</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131736390.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131736390.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131736390.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131736390.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131736390.png title=image-20210918131736390></p><h4 id=好分治>好分治</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131812017.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131812017.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131812017.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131812017.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131812017.png title=image-20210918131812017></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131824600.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131824600.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131824600.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131824600.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918131824600.png title=image-20210918131824600></p><h3 id=棋盘覆盖>棋盘覆盖</h3><p>不考</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918134456210.png alt=image-20210918134456210 style=zoom:33%><h4 id=基本思想-1>基本思想</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918135558538.png alt=image-20210918135558538 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918135708174.png alt=image-20210918135708174 style=zoom:33%><h4 id=算法实现-1>算法实现</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>chess_board</span><span class=p>(</span><span class=n>tr</span><span class=p>:</span><span class=nb>int</span><span class=p>,</span> <span class=n>tc</span><span class=p>:</span><span class=nb>int</span><span class=p>,</span> <span class=n>dr</span><span class=p>:</span><span class=nb>int</span><span class=p>,</span> <span class=n>dc</span><span class=p>:</span><span class=nb>int</span><span class=p>,</span> <span class=n>size</span><span class=p>:</span><span class=nb>int</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    棋盘覆盖问题
</span></span></span><span class=line><span class=cl><span class=s2>    param tr: 棋盘起始行坐标
</span></span></span><span class=line><span class=cl><span class=s2>    param tc: 棋盘起始列坐标
</span></span></span><span class=line><span class=cl><span class=s2>    param dr: 特殊方格的行号
</span></span></span><span class=line><span class=cl><span class=s2>    param dc: 特殊方格的列号
</span></span></span><span class=line><span class=cl><span class=s2>    param size:
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>size</span><span class=o>==</span><span class=mi>1</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=n>t</span><span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=o>=</span><span class=n>size</span><span class=o>/</span><span class=mi>2</span> <span class=c1># 分割棋盘</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>dr</span><span class=o>&lt;</span><span class=n>tr</span><span class=o>+</span><span class=n>s</span> <span class=ow>and</span> <span class=n>dc</span><span class=o>&lt;</span><span class=n>tc</span><span class=o>+</span><span class=n>s</span>
</span></span></code></pre></td></tr></table></div></div><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918135756445.png alt=image-20210918135756445 style=zoom:40%><h4 id=复杂性-1>复杂性</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918140021496.png alt=image-20210918140021496 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918140032888.png alt=image-20210918140032888 style=zoom:33%><h3 id=合并排序>合并排序</h3><p>就是归并排序</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918141728529.png alt=image-20210918141728529 style=zoom:33%><h4 id=基本思想-2>基本思想</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918141813181.png alt=image-20210918141813181 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918141823072.png alt=image-20210918141823072 style=zoom:33%><h4 id=递归算法>递归算法</h4><h5 id=实现>实现</h5><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142034783.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142034783.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142034783.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142034783.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142034783.png title=image-20210918142034783></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142939870.png alt=image-20210918142939870 style=zoom:33%><h5 id=复杂性-2>复杂性</h5><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png title=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142146773.png></p><h4 id=非递归的分治算法>非递归的分治算法</h4><p>非递归：自底向上</p><p>递归：自顶向下</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143041362.png alt=image-20210918143041362 style=zoom:33%><h5 id=实现-1>实现</h5><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142549068.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142549068.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142549068.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142549068.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918142549068.png title=image-20210918142549068></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143559704.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143559704.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143559704.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143559704.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143559704.png title=image-20210918143559704></p><h5 id=复杂性-3>复杂性</h5><p>（长为 n/2）</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143708276.png alt=image-20210918143708276 style=zoom:33%><h4 id=复杂性-4>复杂性</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210918143749827.png alt=image-20210918143749827 style=zoom:33%><h3 id=快速排序>快速排序</h3><p>设基准 -> 划分子列 -> 递归</p><h4 id=算法实现-2>算法实现</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>graph LR
</span></span><span class=line><span class=cl>	start[开始]--&gt;con1{&#34;i &lt; j?&#34;}
</span></span><span class=line><span class=cl>	con1 -- NO --&gt; recurve[&#34;结束一次快排&#34;]
</span></span><span class=line><span class=cl>    con1 -- YES --&gt; con2{&#34;Elem[i] &gt; Elem[j]?&#34;}
</span></span><span class=line><span class=cl>    con2 -- YES --&gt; exchange[&#34;i,j 值互换&#34;]
</span></span><span class=line><span class=cl>	exchange ---&gt; pivot{&#34;基准位置?&#34;}
</span></span><span class=line><span class=cl>	con2 -- NO --&gt;pivot
</span></span><span class=line><span class=cl>	pivot -- &#34;前&#34; --&gt; j[&#34;j--&#34;]
</span></span><span class=line><span class=cl>	pivot -- &#34;后&#34; --&gt; i[&#34;i++&#34;]
</span></span><span class=line><span class=cl>	i --&gt; finish[&#34;下次循环&#34;]
</span></span><span class=line><span class=cl>	j --&gt; finish
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	finish --&gt; con1
</span></span></code></pre></td></tr></table></div></div><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923133023063.png alt=image-20210923133023063 style=zoom:40%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923133043429.png alt=image-20210923133043429 style=zoom:35%><h4 id=复杂度>复杂度</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923135538263.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923135538263.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923135538263.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923135538263.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923135538263.png title=image-20210923135538263></p><h3 id=线性时间选择>线性时间选择</h3><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141552761.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141552761.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141552761.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141552761.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141552761.png title=image-20210923141552761></p><p>一个结论：一般的选择问题可以在 O(n) 时间内得到解决</p><h4 id=模仿快排的很拉的分治算法>模仿快排的、很拉的分治算法</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923141859889.png alt=image-20210923141859889 style=zoom:33%><p>使用到类似于快排的算法</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923142034552.png alt=image-20210923142034552 style=zoom:50%><h4 id=改进的分治>改进的分治</h4><p>思想：选择一个有用的基准值，让每一次递归都有效，能大概剔除 n/4 的规模</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143236828.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143236828.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143236828.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143236828.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143236828.png title=image-20210923143236828></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143302958.png alt=image-20210923143302958 style=zoom:33%><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143328281.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143328281.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143328281.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143328281.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143328281.png title=image-20210923143328281></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210923143617933.png alt=image-20210923143617933 style=zoom:40%><h3 id=最接近点对问题>最接近点对问题</h3><p>不会出大题</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132532247.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132532247.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132532247.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132532247.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132532247.png title=image-20210927132532247></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132702653.png alt=image-20210927132702653 style=zoom:40%><h4 id=一维>一维</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132910859.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132910859.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132910859.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132910859.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927132910859.png title=image-20210927132910859></p><h4 id=二维>二维</h4><p>分治</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140302631.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140302631.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140302631.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140302631.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140302631.png title=image-20211112140302631></p><p>推广到二维</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140603318.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140603318.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140603318.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140603318.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112140603318.png title=image-20211112140603318></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141019693.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141019693.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141019693.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141019693.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141019693.png title=image-20210927141019693></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927140304921.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927140304921.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927140304921.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927140304921.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927140304921.png title=image-20210927140304921></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141206939.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141206939.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141206939.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141206939.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141206939.png title=image-20210927141206939></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141241174.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141241174.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141241174.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141241174.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141241174.png title=image-20210927141241174></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141752486.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141752486.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141752486.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141752486.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141752486.png title=image-20211112141752486></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141801333.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141801333.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141801333.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141801333.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211112141801333.png title=image-20211112141801333></p><h4 id=算法>算法</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927141353325.png alt=image-20210927141353325 style=zoom:50%><p>第四部中的 X 与 Y 只要排一次序就行</p><h4 id=复杂度-1>复杂度</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142019431.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142019431.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142019431.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142019431.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142019431.png title=image-20210927142019431></p><h3 id=循环赛程表问题>循环赛程表问题</h3><p>不考</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142731078.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142731078.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142731078.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142731078.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927142731078.png title=image-20210927142731078></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143104868.png alt=image-20210927143104868 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143125161.png alt=image-20210927143125161 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143143263.png alt=image-20210927143143263 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20210927143154432.png alt=image-20210927143154432 style=zoom:33%><h2 id=动态规划>动态规划</h2><h3 id=定义-2>定义</h3><p>最优子结构性质</p><p>重叠子问题性质</p><p><strong>基本思想</strong></p><ul><li>将问题分解成若干子问题，然后求解子问题。</li><li>子问题<strong>不是互相独立的</strong></li></ul><p><strong>方法</strong></p><ul><li><p>自底向上求解</p></li><li><p>备忘录：递归，自顶向下</p></li></ul><h3 id=基本要素>基本要素</h3><p><strong>算法目标</strong></p><p>求解有某种最优性质的问题（离散型）。它可能有许多可行解，希望找到具有最优值的解。</p><p><strong>算法思想</strong></p><ol><li>动态规划算法将待求解问题分解成若干子问题，先求解<strong>子问题</strong></li><li>从这些子问题的解得到原问题的解。这些子问题往往<strong>不互相独立</strong></li><li>分解时得到的子问题数目可能很多，有些子问题被<strong>重复计算</strong>了很多次</li></ol><p><strong>求解方法</strong></p><ul><li>自底向上方式、自上而下方式</li><li>采用<strong>备忘录方法</strong>：求解过程中需保持已经解决的子问题的解，而在需要时再找出已求得的解，就可以避免大量的重复计算，节省时间。动态规划法用表记录所有已解的子问题的答案。不管该子问题以后是否会被用到，只要它被计算过，就将其结果填入表中。</li></ul><p><strong>动态规划中的概念、名词术语</strong></p><table><thead><tr><th>概念、名词术语</th><th>解释</th></tr></thead><tbody><tr><td>阶段</td><td>把问题分成几个相互联系的有顺序的几个环节</td></tr><tr><td>状态</td><td>某一阶段的触发位置称为状态。通常一个阶段包含若干状态。</td></tr><tr><td>决策</td><td>从某阶段的一个状态演变到下一阶段某状态的选择。特点：前一阶段的终点是后一阶段的起点，前一阶段的决策影响后一阶段的状态。</td></tr><tr><td>策略</td><td>由考生到终点的全过程中，由每段决策组成的决策序列。</td></tr><tr><td>状态转移方程</td><td>描述由 k 阶段到 k+1 阶段状态的演变规律称为状态转移方程（用数学形式表达）</td></tr><tr><td>目标函数与最优化概念</td><td>目标函数是衡量多阶段决策过程优劣的准则。最优化概念是在一定条件下找到一个途径，按照题目具体性质所确定的运算以后，使全过程的总效益达到最优。</td></tr><tr><td>动态规划</td><td>在多阶段决策问题中，各阶段采取的决策依赖于目前状态，并引起状态的转移以求得最优化过程。</td></tr></tbody></table><p>最佳原理：==<strong>一个最优化策略的子策略总是最优的</strong>==</p><p><strong>动态规划的求解步骤</strong>：</p><ol><li>找出最优解的性质，并刻画其结构特征</li><li>递归地定义最优值（写出动态规划方程）</li><li>以自底向上（或自顶向下）的方式计算出最优值</li><li>根据计算最优值得到的信息，构造一个最优解</li></ol><h4 id=动态规划的基本要素><strong>动态规划的基本要素</strong></h4><p>（填空、简答考）</p><p>动态规划算法的有效性依赖于问题本身所具有的两个重要性质：<strong>最优子结构性质</strong>和<strong>子问题重叠性质</strong>。</p><ol><li><p><strong>最优子结构</strong></p><p>当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。</p><p>证明用反证法：</p><ul><li><strong>先假设由问题的最优解导出的子问题的解不是最优的，然后再设法证明在这个假设下可构造出一个比原问题最优解更好的解，从而导致矛盾。</strong><ol><li>构建一个问题的最优解 $\pi$</li><li>构建其子问题的一个解（一个递归式），接下来开始证明这个解是最优解</li><li>如果这个解不是子问题的最优解，则满足某一个不等式，使得另有一个解 $\pi&rsquo;$ 成为子问题的最优解</li><li>这个解 $\pi&rsquo;$ 加上第一个元素后将会成为整个问题的最优解</li><li>这与 $\pi$ 是问题的最优解矛盾，不等式推翻，证明最优子结构性质</li></ol></li></ul></li><li><p><strong>重叠子问题</strong></p><p>在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，<strong>有些子问题被反复计算多次</strong>。这种性质称为子问题的重叠性质。</p><p>动态规划利用子问题的重叠性质，对每个子问题只解一次，并将解保存在一个表格中，在以后尽可能多利用这些子问题的解。</p><p>特征：<strong>不同的子问题个数随问题的大小呈多项式增长而非指数增长</strong>。</p></li></ol><p><strong>动态规划法与分治策略</strong></p><p>共性：都通过子问题求解原问题</p><p>方法：分治法是把一个规模为 n 的问题分成多个与原问题类型相同的较小的子问题，通过对子问题的求解，并把子问题的解合并起来，构造出整个问题的解；动态规划法先求子问题的解，通过求解子问题，构造原问题的解</p><p>==差异==：</p><ol><li><p><strong>独立性</strong></p><p>分治法各子问题互相独立，动态规划法的各子问题不独立</p></li><li><p><strong>子问题数目</strong></p><p>动态规划法中设计的子问题，不独立的有很多，而独立的应只有<strong>多项式级</strong>；</p><p>分治法设计的子问题数一般达<strong>指数级</strong></p></li><li><p><strong>局部最优</strong></p><p>动态规划法把问题分成许多子问题，每个子问题的解都是局部最优；分治法未必考虑最优性</p></li><li><p><strong>备忘录方法</strong></p><p>动态规划法可采用备忘录方法</p></li></ol><h3 id=矩阵连乘>矩阵连乘</h3><h4 id=问题叙述><strong>问题叙述</strong></h4><p>给定 n 个矩阵 $A_1$，$A_2$，……，$A_n$，其中 A~1~ 与 A~j+1~ 是可乘的，i=1,2,……，n-1，现要计算出这 n 个矩阵的连乘积 $A_1 A_2 … A_n$。</p><p>确定一种运算次序，使总的运算次数达到最少。</p><p>两个矩阵相乘时：</p><ul><li><p>A=(a~ij~)~m×k~，B=(b~ij~)~k×n~，C=(c~ij~)~m×n~</p></li><li><p>C 有 m×n 个元素，需 <strong>m×n×k 次乘法</strong>，m×n×(k-1) 次加法</p></li></ul><p>完全<strong>加括号</strong>的矩阵连乘积可递归地定义为：</p><ol><li>单个矩阵是完全加括号的；</li><li>若矩阵链乘积 A 是完全加括号的，则 A 可表示为 2 个完全加括号的矩阵连乘积 B 和 C 的乘积并加括号，即 A=(BC)</li></ol><h4 id=算法分析>算法分析</h4><ol><li><p>分析<strong>最优解的结构</strong></p><p>记 $A[i:j]$ 为 A~i~A~i+!~…A~j~，记 $m[i][j]$ 是计算 A~i~A~i+!~…A~j~ 时的最少乘法次数，显然 $A[i:i]=A_i$，$m[i][i]=0$</p><p>特征：计算 $A[i:k]$ 和 $A[k+1:j]$ 的次序是最优的。</p></li><li><p>建立递归关系</p><p>假定计算 $A[1:n]$ 的一个最优次序在矩阵 A~k~ 和 A~k+1~ 之间将矩阵链断开，1≤k&lt;n</p><p>$m[1][n]=m[1][k]+m[k+1][n]+p_0p_kp_n$</p><p><em>一般情况</em></p><p>假定计算 $A[i:j]$ 的一个最优次序在矩阵 A~k~ 和 A~k+1~ 之间将矩阵链断开，i≤k&lt;j</p><p>m[1] [n]=m[1] [k]+m[k+1] [n]+p~i-1~p~k~p~j~</p><p>一般递推关系：</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211012133136426.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211012133136426.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211012133136426.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211012133136426.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211012133136426.png title=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211012133136426.png></p></li></ol><h4 id=计算最优值>计算最优值</h4><p>不同子问题个数最多有 ${n}\choose{2}$+$n=\theta(n^2)$ 个。</p><p>依据递归式自底向上进行计算。在计算过程中保存已解决的子问题答案，每个子问题只计算一次。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>r:矩阵序的长度
</span></span></span><span class=line><span class=cl><span class=cm>p[]：存放矩阵序列维度的数组
</span></span></span><span class=line><span class=cl><span class=cm>m[][]：最优值数组
</span></span></span><span class=line><span class=cl><span class=cm>s[][]：记录最优断开位置的数组
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>MatrixChain</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>p</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>m</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=kt>int</span> <span class=n>i</span><span class=p>,</span><span class=n>r</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>k</span><span class=p>,</span><span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>r</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>r</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>r</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 每次循环计算出x个矩阵相乘时的最优运算次数，x=1到n-1
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=o>-</span><span class=n>r</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 斜着
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=n>j</span> <span class=o>=</span> <span class=n>i</span><span class=o>+</span><span class=n>r</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=c1>// x
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>*</span><span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>			<span class=c1>//初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>for</span> <span class=p>(</span><span class=n>k</span><span class=o>=</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=n>k</span><span class=o>&lt;</span><span class=n>j</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>t</span><span class=o>=</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span><span class=o>+</span><span class=n>m</span><span class=p>[</span><span class=n>k</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>*</span><span class=n>p</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>*</span><span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>&lt;</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                    <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>t</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>matrix_chain</span><span class=p>(</span><span class=n>n</span><span class=p>:</span> <span class=nb>int</span><span class=p>,</span> <span class=n>p</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>])</span> <span class=o>-&gt;</span> <span class=nb>tuple</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;
</span></span></span><span class=line><span class=cl><span class=s2>    计算最优值关系矩阵
</span></span></span><span class=line><span class=cl><span class=s2>    :param n: 连乘矩阵的个数
</span></span></span><span class=line><span class=cl><span class=s2>    :param p: 矩阵序列维度的列表
</span></span></span><span class=line><span class=cl><span class=s2>    :return: 最优断开位置的二维列表, 备忘录
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>  <span class=c1># 初始记录矩阵全设为零</span>
</span></span><span class=line><span class=cl>    <span class=n>s</span><span class=p>:</span> <span class=n>List</span><span class=p>[</span><span class=n>List</span><span class=p>[</span><span class=nb>int</span><span class=p>]]</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>        <span class=p>[</span><span class=mi>0</span> <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span> <span class=k>for</span> <span class=n>j</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>)]</span>  <span class=c1># 记录最优断开位置的数组</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>r</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=c1># 对每个对角线</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=n>n</span> <span class=o>-</span> <span class=n>r</span> <span class=o>+</span> <span class=mi>2</span><span class=p>):</span>
</span></span><span class=line><span class=cl>            <span class=c1># 对每行</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=n>r</span> <span class=o>-</span> <span class=mi>1</span>  <span class=c1># 对角线长</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> \
</span></span><span class=line><span class=cl>                <span class=n>p</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>*</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>  <span class=c1># 初始化 m[i][j]</span>
</span></span><span class=line><span class=cl>            <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>i</span>  <span class=c1># 记录断开位置</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=n>k</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=c1># 寻找m[i][j]最小值</span>
</span></span><span class=line><span class=cl>                <span class=n>t</span> <span class=o>=</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>]</span> <span class=o>+</span> <span class=n>m</span><span class=p>[</span><span class=n>k</span> <span class=o>+</span> <span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=n>p</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>p</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>*</span> <span class=n>p</span><span class=p>[</span><span class=n>j</span><span class=p>]</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>t</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]:</span>
</span></span><span class=line><span class=cl>                    <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>t</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                    <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>k</span>  <span class=c1># 记录断开位置</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>s</span><span class=p>,</span> <span class=n>m</span>
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009143427146.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009143427146.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009143427146.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009143427146.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211009143427146.png title=image-20211009143427146></p><p><strong>复杂度</strong></p><p>计算时间上界为 $O(n^3)$，空间为 $O(n^2)$</p><h4 id=构造最优解>构造最优解</h4><p>引入分割点标记 $s[i][j]$，确定加括号方式，构造最优解</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Traceback</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span><span class=o>==</span><span class=n>j</span><span class=p>)</span> <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Traceback</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>],</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Traceback</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>s</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Multiply A &#34;</span><span class=o>&lt;&lt;</span> <span class=n>i</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; and A &#34;</span> <span class=o>&lt;&lt;</span> <span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; ,&#34;</span> <span class=o>&lt;&lt;</span> <span class=n>j</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=最长公共子序列>最长公共子序列</h3><h4 id=概念><strong>概念</strong></h4><ol><li>子序列：若给定序列 $X={x_1,x_2,…,x_m}$，则另一序列 $Z={z_1,z_2,…,z_k}$是 X 的子序列，是指存在一个严格递增下标序列 ${i_1,i_2,…,i_k}$ 使得对于所有 j=1,2,…,k 有：$Z_j=X_{ij}$</li></ol><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211011135948207.png alt=image-20211011135948207 style=zoom:33%><ol><li>公共子序列：给定两个序列 X 和 Y，当另一序列 Z 既是 X 的子序列又是 Y 的子序列时，称 Z 是序列 X 和 Y 的公共子序列</li></ol><p>设序列 $X={x_1,x_2,…,x_m}$ 和 $Y={y_1,y_2,…,y_n}$ 的最长公共子序列为 $Z={z_1,z_2,…,z_k}$，则</p><ol><li>若 $x_m=y_n$，则 $z_k=x_m=y_n$，且 Z~k-1~ 是 X~m-1~ 和 Y~n-1~ 的最长公共子序列</li><li>若 $x_m≠y_n$ 且 $z_k≠x_m$，则 Z 是 X~m-1~ 和 Y 的最长公共子序列</li><li>若 $x_m≠y_n$ 且 $z_k≠y_n$，则 Z 是 X 和 Y~n-1~ 的最长公共子序列</li></ol><p>当 i=0 或 j=0 时，空序列是 $X_i$ 和 $Y_j$ 的最长公共子序列，此时 $c[i][j]=0$。</p><h4 id=递归-1>递归</h4><p>其他情况下的递归关系：
$$
c[i][j]=\begin{cases}0,i=0、j=0\c[i-1][j-1]+1,i、j＞0;x_i=y_j\max(c[i][j-1],c[i-1][j]),i、j>0;x_i≠y_j\end{cases}
$$
子问题空间中，总共有 $\theta(mn)$ 个不同的子问题，用动态规划算法自底向上计算最优值能提高算法的效率。</p><h4 id=代码>代码</h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>c[i][j]：存储Xi和Yj的最长公共子序列的长度
</span></span></span><span class=line><span class=cl><span class=cm>b[i][j]：记录c[i][j]的值是由哪个子问题的解得到的
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//计算最优值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>LCSLength</span><span class=p>(</span><span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>m</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>m</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>==</span><span class=n>y</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>					<span class=c1>//指↖
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>&gt;=</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>				<span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span>					<span class=c1>//指↑
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>c</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=mi>3</span><span class=p>;</span>					<span class=c1>//指←
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=p>}</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//构造最长公共子序列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>LCS</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>b</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>i</span><span class=o>==</span><span class=mi>0</span> <span class=o>||</span> <span class=n>j</span><span class=o>==</span><span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>==</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>LCS</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>x</span><span class=p>,</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span> <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>==</span><span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>LCS</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>j</span><span class=p>,</span><span class=n>x</span><span class=p>,</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>LCS</span><span class=p>(</span><span class=n>i</span><span class=p>,</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>x</span><span class=p>,</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211019134827454.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211019134827454.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211019134827454.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211019134827454.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211019134827454.png title=image-20211019134827454></p><h3 id=最大子段和>最大子段和</h3><h4 id=问题描述><strong>问题描述</strong></h4><p>给定由 n 个整数组成的序列 $a_1,a_2,a_3……,a_n$，求该序列形如 $\sum{a_k}$ 的子段和的最大值。</p><p>枚举：$O(n^3)$</p><p>递推：$O(n^2)$</p><h4 id=分治策略><strong>分治策略</strong></h4><p>将序列 $a[1:n]$ 分为长度相等的两段 $a[1:n/2]$ 和 $a[n/2+1:n]$，分别求出这两段的最大子段和 S~1~，S~2~</p><p>$a[1:n]$ 的最大子段和 S 有三种可能：</p><p>$S=S~1$，$S=S_2$ 或 $S=\sum_{k=i}^{j}{a_k}$，$i≤n/2，n/2+1≤j$</p><p>对于第三种情况只需求得 S~1~ 中 i 到 n/2 最大子段和，S~2~ 中 n/2+1 到 j 最大子段和，二者相加 S=S~1~’+S~2~’（因为比包含 n/2 处的数）</p><p>时间复杂度递推式：
$$
T(n)=\begin{cases}2T(n/2)+O(n),n>C\O(1),n≤C\end{cases}
$$
由上解得 $T(n)=O(nlogn)$</p><h4 id=动态规划-1><strong>动态规划</strong></h4><p>对 $a[1:j]$，记 $b[j]$，$1≤j≤n$</p><p>$b[j]=max$~{1≤i≤j}~{$\sum_{k=i}^{j}{a_k}$} <strong>以 j 为末尾位置的最大子段和</strong></p><p>$a[1:n]$ 的最大子段和 $S=max$~{1≤j≤n}~{$b[j]$}，即 j 从 1 到 n 的最大 b[j]</p><p>有递推：
$$
b[j]=max{b[j-1]+a[j],a[j]}
$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>MaxSum</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=n>b</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>b</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>)</span> <span class=n>b</span><span class=o>+=</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=n>b</span><span class=o>=</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>b</span><span class=o>&gt;</span><span class=n>sum</span><span class=p>)</span> <span class=n>sum</span><span class=o>=</span><span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=c1>// 好妙
</span></span></span></code></pre></td></tr></table></div></div><p>复杂性：$O(n)$</p><h4 id=推广最大子矩阵和问题><strong>推广</strong>：<strong>最大子矩阵和问题</strong></h4><p>给定一个 m 行 n 列的整数矩阵 A，试求矩阵 A 的一个子矩阵，使其各元素之和为最大。</p><p>思想：将多行压成一行</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>MaxSum2</span><span class=p>(</span><span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=o>**</span><span class=n>a</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span><span class=o>=</span><span class=mi>0</span><span class=p>,</span><span class=o>*</span><span class=n>b</span><span class=o>=</span><span class=n>new</span> <span class=kt>int</span> <span class=p>[</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>m</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>k</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=n>b</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>=</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>k</span><span class=p>];</span> <span class=c1>// 将i行数据存进b数组中
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>m</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span> <span class=n>k</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>k</span><span class=o>++</span><span class=p>)</span> <span class=n>b</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>+=</span><span class=n>a</span><span class=p>[</span><span class=n>j</span><span class=p>][</span><span class=n>k</span><span class=p>];</span> <span class=c1>// 将新一行累加到b数组中
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>max</span><span class=o>=</span><span class=n>MaxSum</span><span class=p>(</span><span class=n>n</span><span class=p>,</span><span class=n>b</span><span class=p>);</span> <span class=c1>// 获取加上这行后，所得的最大子段和（降维）
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>max</span><span class=o>&gt;</span><span class=n>sum</span><span class=p>)</span> <span class=n>sum</span><span class=o>=</span><span class=n>max</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>复杂性：$O(m^2n)$</p><h3 id=凸多边形最优三角剖分>凸多边形最优三角剖分</h3><p><strong>凸多边形</strong>：用多边形顶点的逆时针序列表示凸多边形，即 P={v~0~，v~1~，…，v~n-1~} 表示具有 n 条边的凸多边形。</p><p><strong>弦</strong>：若 v~i~ 与 v~j~ 是多边形上不相邻的 2 个顶点，则线段 v~i~v~j~ 称为多边形的一条弦。弦将多边形分割成 2 个多边形 {v~i~，v~i+1~，…，v~j~} 和 {v~j~，v~j+1~，…，v~i~}</p><p>凸多边形最优三角剖分：给定凸多边形 P，以及定义在由多边形的边和弦组成的三角形上的权函数 w。确定该凸多边形的三角剖分，使得该三角剖分中诸三角形上权之和为最小。</p><p>与矩阵连乘思想类似，都是找到一颗最优的语法树</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211018143135168.png alt=image-20211018143135168 style=zoom:50%><p><strong>递归结构</strong></p><p>定义 $t[i][j]$，1 ≤ i＜j ≤ n 为凸子多边形 {v~i-1~，v~i~，…，v~j~} 的最优三角剖分所对应的权函数值，即其最优值。</p><p>$t[i][j]=t[i][k]+t[k+1][j]+$(△v~i-1~v~k~v~j~ 权值)</p><p><strong>递归定义</strong></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211018143451216.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211018143451216.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211018143451216.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211018143451216.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211018143451216.png title=image-20211018143451216></p><p>时间复杂性：$O(n^3)$</p><p>空间复杂性：$O(n^2)$</p><h3 id=流水作业调度>流水作业调度</h3><h4 id=问题描述-1><strong>问题描述</strong></h4><p>n 个作业 {1,2,…,n} 要在由 2 台机器 M1 和 M2 组成的流水线上完成加工。每个作业加工的顺序都是现在 M1 上加工，然后在 M2 上加工 M1 和 M2 加工作业 i 所需的时间分别为 a~i~ 和 b~i~。</p><p>流水作业调度问题：确定这 n 个作业的最优加工顺序，使得从第一个作业在机器 M1 上开始加工，到最后一个作业在机器 M2 上加工完成所需的时间最少。</p><h4 id=算法分析-1><strong>算法分析</strong></h4><p>优化的点：M2 会有空闲时间</p><p>一个最优调度应使机器 M1 没有空闲时间且机器 M2 的空闲时间最少。</p><p>机器 M2 的两种情况：</p><ol><li><p>机器空闲</p></li><li><p>作业积压</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021132216652.png alt=image-20211021132216652 style=zoom:40%></li></ol><p>设机器 M1 开始加工 S 中作业时，机器 M2 还在加工其他作业，要等时间 t 后才可利用，完成 S 中作业所需的<strong>最短</strong>时间记为 $T(S,t)$</p><p>由此，该问题变为求最优值为 $T(J,0)$</p><h4 id=最优子结构性质><strong>最优子结构性质</strong></h4><p>设 π 是所给 n 个流水作业的一个最优调度，即已排好作业调度：π(1)，π(2)，…，π(n)，其中 π(i)∈{1,2,…,n}</p><p>设机器 M1 开始加工 J 中第一个作业 J~π(1)~ 时，机器 M2 可能在等待，它所需的加工时间为 a~π(1)~+T‘，其中 T’ 是在机器 M2 的等待时间为 b~π(1)~ 时，安排作业 J~π(2)~，…，J~π(n)~ 所需的时间，这是最好的时间。</p><p>记 S=J-{J~π(1)~}，则可证明：$T’=T(S,b_{π(1)})$</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211113150642076.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211113150642076.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211113150642076.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211113150642076.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211113150642076.png title=image-20211113150642076></p><h4 id=递归关系>递归关系</h4><p>可得 $T(J,0)=min_{1≤i≤n}{a_i+T(J-{J_i},b_i)}$</p><p>一般情况：$T(S,t)=min_{Ji∈S}{a_i+T(S-{J_i},b_i+max{t-a_i,0})}$</p><h4 id=johnson-不等式><strong>Johnson 不等式</strong></h4><p>设 π 是作业集 S 在机器 M2 的等待时间为 t 时的任一最优调度。若 π(1)=i，π(2)=j，由动态规划递归式可得：</p><p>$T(S,t)=a_i+T(S-{J_i},b_i+max{t-a_i,0})=a_i+a_j+T(S-{J_i,J_j},t_{ij})$</p><p>其中，$t_{ij}=b_j+b_i-a_j-a_i+max{t,a_i+a_j-b_i,a_i}$</p><p>若作业 J~i~ 和 J~j~ <strong>满足 min{a~j~,b~i~}≥min{a~i~,b~j~}</strong>，称做 J~i~ 和 J~j~ 满足 Johnson 不等式。</p><p>当作业 J~i~ 和 J~j~ 不满足 Johnson 不等式时，只要交换他们的加工顺序后，不会增加加工时间。</p><p>所有满足 Johnson 法则的调度均为最优调度。</p><p>最坏情况下算法所需的计算时间为 $O(nlogn)$，所需空间为 $O(n)$</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021142024275.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021142024275.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021142024275.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021142024275.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021142024275.png title=image-20211021142024275></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211021142130035.png alt=image-20211021142130035 style=zoom:40%><p>注意证明！</p><h3 id=0-1-背包问题>0-1 背包问题</h3><h4 id=问题描述-2><strong>问题描述</strong></h4><p>给定 n 个物体和一个背包，物体 i 的重量为 w~i~，价值为 v~i~ (i=1,2,……,n)，背包能容纳的物体重量为 c，要从这 n 个物体中选出若干件放入背包，使得放入物体的总重量小于等于 c，而总价值达到最大。</p><p>如果用 x~i~=1 表示将第 i 件物体放入背包，用 x~i~=0 表示未放入，则问题变为选择一组 x~i~ (i=0,1) 使得 $w_x=\sum_{i=l}^{n}{w_ix_i}≤c$，$v_x=\sum_{i=l}^{n}{v_ix_i}$，并且达到最大</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211025130118370.png alt=image-20211025130118370 style=zoom:50%><h4 id=证明最优子结构性质>证明最优子结构性质</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211025130427862.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211025130427862.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211025130427862.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211025130427862.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211025130427862.png title=image-20211025130427862></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145337223.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145337223.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145337223.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145337223.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145337223.png title=image-20211114145337223></p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145343892.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145343892.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145343892.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145343892.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114145343892.png title=image-20211114145343892></p><h4 id=递归关系-1>递归关系</h4><p>$m(i,j)$ 是背包容量为 j，可选择物品为 $i,i+1,…,n$ 时 0-1 背包问题的最优值。</p><p>由 0-1 背包问题的最优子结构性质，有计算 $m(i,j)$ 的递归式：
$$
m(i,j)=\begin{cases}max{m(i+1,j),m(i+1,j-w_i)+v_i},j \ge w_i \ m(i+1,j),0 \le j＜w_i\end{cases}
$$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* 
</span></span></span><span class=line><span class=cl><span class=cm>w[]: 重量数组
</span></span></span><span class=line><span class=cl><span class=cm>c: 最大容纳重量
</span></span></span><span class=line><span class=cl><span class=cm>n: 从第n个开始
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=n>template</span><span class=o>&lt;</span><span class=n>class</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Knapsack</span><span class=p>(</span><span class=n>Type</span> <span class=n>v</span><span class=p>,</span><span class=kt>int</span> <span class=n>w</span><span class=p>,</span><span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=n>Type</span><span class=o>**</span> <span class=n>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>jMax</span><span class=o>=</span><span class=n>min</span><span class=p>(</span><span class=n>w</span><span class=p>[</span><span class=n>n</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>jMax</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>			<span class=c1>//初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>w</span><span class=p>[</span><span class=n>n</span><span class=p>];</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>c</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>			<span class=c1>//价值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>v</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&gt;</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>jMax</span><span class=o>=</span><span class=n>min</span><span class=p>(</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>jMax</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>		<span class=c1>//放不下
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>c</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>		<span class=c1>//放得下
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>max</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span><span class=o>+</span><span class=n>v</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span><span class=o>=</span><span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>c</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>c</span><span class=o>&gt;=</span><span class=n>w</span><span class=p>[</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>]</span><span class=o>=</span><span class=n>max</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>],</span><span class=n>m</span><span class=p>[</span><span class=mi>2</span><span class=p>][</span><span class=n>c</span><span class=o>-</span><span class=n>w</span><span class=p>[</span><span class=mi>1</span><span class=p>]]</span><span class=o>+</span><span class=n>v</span><span class=p>[</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 构造最优解
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>template</span><span class=o>&lt;</span><span class=n>class</span> <span class=n>Type</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>Traceback</span><span class=p>(</span><span class=n>Type</span> <span class=o>**</span><span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>c</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>c</span><span class=p>]</span><span class=o>==</span><span class=n>m</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>c</span><span class=p>])</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>			<span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>c</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>x</span><span class=p>[</span><span class=n>n</span><span class=p>]</span><span class=o>=</span><span class=p>(</span><span class=n>m</span><span class=p>[</span><span class=n>n</span><span class=p>][</span><span class=n>c</span><span class=p>])</span><span class=o>?</span><span class=mi>1</span><span class=o>:</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间复杂性：$O(min{nc,2^n})$</p><h2 id=贪心算法>贪心算法</h2><p>贪心策略不从整体最优考虑，而总是某种意义上是局部最优的方面做出选择。</p><p>==<strong>贪心策略总是作出在当前看来最好的选择</strong>==</p><h3 id=活动安排问题>活动安排问题</h3><h4 id=问题描述-3><strong>问题描述</strong></h4><p>有 n 个活动的集合 E={1,2,……,n}，其中每个活动都要求使用同一资源，而在同一时间内只有一个活动能使用这一资源。</p><p>每个活动 i 都有一个要求使用该资源的起始时间 s~i~ 和一个结束时间 f~i~，且 s~i~＜f~i~。</p><p>若选择了活动 i，则它在半开时间区间 [s~i~,f~i~) 内占用资源。若区间 [s~i~,f~i~) 与区间 [s~j~,f~j~) 不相交，则称活动 i 与活动 j 是相容的。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211113193157199.png alt=image-20211113193157199 style=zoom:50%><h4 id=求解策略><strong>求解策略</strong></h4><p>策略：从队列中每次<strong>总是选择具有最早完成时间的相容活动</strong>加入活动集合 A 中。</p><p>预备：将活动以完成时间升序排列</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>GreedySelector</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>,</span><span class=kt>int</span> <span class=n>s</span><span class=p>[],</span> <span class=kt>int</span> <span class=n>f</span><span class=p>[],</span> <span class=kt>bool</span> <span class=n>A</span><span class=p>[])</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>A</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>,</span><span class=n>count</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>2</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&gt;=</span><span class=n>f</span><span class=p>[</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>A</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>选择具有最早完成时间的相容活动加入集合 A 中，时间复杂性：$O(nlogn)$</p><h3 id=贪心算法的基本要素>贪心算法的基本要素</h3><ol><li><p><strong>贪心选择性质</strong></p><p>所求问题的<strong>整体最优解</strong>可以通过一系列<strong>局部最优</strong>的选择来达到。</p></li><li><p><strong>最优子结构性质</strong></p><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有<strong>最优子结构性质</strong></p></li></ol><h4 id=问题具有贪心选择性质的证明方法><strong>问题具有贪心选择性质的证明方法</strong></h4><p>（<strong>贪心策略的证明要考</strong>，看清楚要证明什么）</p><ol><li>明确贪心选择策略 S</li><li>按该贪心选择策略，选一个局部最优解，确定第一步选择（假定有一个最优解 A）</li><li>考察问题的最优解 A，<strong>并证明它的第一步必可通过贪心选择策略开始</strong></li></ol><h4 id=贪心算法与动态规划算法的差异><strong>贪心算法与动态规划算法的差异</strong></h4><ul><li>贪心选择<ul><li>问题的整体最优解可以通过<strong>一系列局部最优的选择</strong>求得。</li><li>通常自顶向下的方式进行，以迭代方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。</li></ul></li><li>动态规划<ul><li>问题的整体最优解由<strong>所有相关子问题的最优解</strong>组成</li><li>每步选择依赖于相关子问题，待子问题求解后，才做出选择。</li><li>通常以自底向上的方式解决各子问题。</li></ul></li></ul><p><strong>两者的共同点</strong></p><ul><li>贪心算法和动态规划算法都要求问题具有最优子结构性质；</li><li>都通过求解一系列子问题的解求得原问题的解</li></ul><h4 id=一般背包问题的贪心选择性质证明>一般背包问题的贪心选择性质证明</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211116103552485.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211116103552485.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211116103552485.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211116103552485.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211116103552485.png title=image-20211116103552485></p><h3 id=最优装载>最优装载</h3><h4 id=问题描述-4><strong>问题描述</strong></h4><p>有一批集装箱要装上一艘载重量为 c 的轮船。其中集装箱 i 的重量为 w~i~。确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。</p><h4 id=算法描述><strong>算法描述</strong></h4><p>用 x~i~ 表示将第 i 件集装箱装入船，用 x~i~=0 表示未放入，则问题变为选择一组 x~i~(i=0,1)</p><p>最优装载问题可以用贪心算法求解。</p><ol><li>确定贪心选择策略：采用重量最轻者先装，可产生最优装载问题的最优解。</li><li>步骤：<ul><li>预备：先对货物按重量从轻到重排序</li><li>策略：依次按最轻者装入</li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Loading</span><span class=p>(</span><span class=kt>int</span> <span class=n>x</span><span class=p>[],</span><span class=kt>int</span> <span class=n>w</span><span class=p>[],</span><span class=kt>int</span> <span class=n>c</span><span class=p>,</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=o>*</span><span class=n>t</span><span class=o>=</span><span class=n>new</span> <span class=kt>int</span> <span class=p>[</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>Sort</span><span class=p>(</span><span class=n>w</span><span class=p>,</span><span class=n>t</span><span class=p>,</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=o>&amp;&amp;</span><span class=n>w</span><span class=p>[</span><span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span><span class=o>&lt;=</span><span class=n>c</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>x</span><span class=p>[</span><span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]]</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>c</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>t</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>算法所需的计算时间为 $O(nlogn)$</p><h4 id=性质证明>性质证明</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211101140542806.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211101140542806.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211101140542806.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211101140542806.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211101140542806.png title=image-20211101140542806></p><h3 id=哈夫曼编码>哈夫曼编码</h3><h4 id=问题描述-5><strong>问题描述</strong></h4><p>一个文件含 100,000 个字符，共有 6 个字母 a,b,c,d,e,f 出现，频率为：45,13,12,16,9,5，用 0、1 穿表示字母对文件进行压缩。</p><p>哈夫曼编码特点：给出现频率高的字符较短的 0、1 编码，出现频率较低的字符以较长的编码，可以大大缩短总码长。</p><h4 id=编码方法><strong>编码方法</strong></h4><ol><li><p>前缀码</p><p>对每一个字符规定一个 0、1 串作为其代码，并要求任一字符的代码都不是其他字符代码的前缀。</p></li><li><p>译码方式：取前缀码</p></li><li><p>编码方法：构造二叉树</p></li></ol><p>表示<strong>最优前缀码</strong>的二叉树总是一棵完全二叉树，即树中任一非叶结点都有 2 个儿子结点。</p><p><strong>平均码长</strong>定义为$B(T)=\sum_{c∈C}f(c)d_T(c)$，$C$ 为字符集，$f(c)$ 为字符 $c$ 在文件中出现的频率，$d_T(c)$ 为深度</p><p>使平均码长达到最小的前缀码编码方程称为给定编码字符集 $C$ 的最优前缀码</p><h4 id=构造哈夫曼编码><strong>构造哈夫曼编码</strong></h4><p>哈夫曼算法以自底向上的方式构造表示最优前缀码的二叉树 T。</p><p>算法思想：算法以 $|C|$ 个叶结点开始，执行 $ |C|-1$ 次的“合并”运算后产生最终所要求的树 T。</p><h4 id=哈夫曼树><strong>哈夫曼树</strong></h4><p>算法步骤：</p><ol><li>用 $C$ 中每一字符 $c$ 的频率 $f(c)$ 初始化一个队列 Q</li><li>对优先队列 Q 用贪心选择：取出具有最小频率的 2 棵树 x,y，并将这 2 棵树合并为新树 z，其频率为合并的 2 棵树的频率之和，并将新树插入优先队列 Q。</li><li>作 n-1 次类似的合并。优先队列中只剩下一棵树，即所要求的的树 T。</li></ol><h4 id=哈夫曼树的实现方式与复杂性><strong>哈夫曼树的实现方式与复杂性</strong></h4><ul><li>用最小堆实现优先队列 Q</li><li>初始化优先队列需要 $O(n)$ 计算时间，n-1 次的合并总共需要 $O(nlogn)$ 计算时间</li><li>n 个字符的哈夫曼算法的计算时间为 $O(nlogn)$</li></ul><h3 id=单源最短路径>单源最短路径</h3><h4 id=问题描述-6><strong>问题描述</strong></h4><p>给定带权有向图 G=(V,E)，其中每条边的权是非负实数。给定 V 中的一个顶点 v，称为源。计算从源 v 到所有其他各顶点 u 的最短路长度 d[u]。</p><h4 id=dijkstra-算法基本思想><strong>Dijkstra 算法基本思想</strong></h4><p>设置顶点集合 S 并不断地作贪心选择来扩充这个集合。u∈S，当且仅当从源 v 到该顶点 u 的最短路径长度已知。</p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211114141306838.png alt=image-20211114141306838 style=zoom:50%><h2 id=回溯法>回溯法</h2><ul><li>子集树算法框架</li><li>排列数算法框架</li></ul><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211104133101515.png alt=image-20211104133101515 style=zoom:33%><h3 id=回溯法的算法框架>回溯法的算法框架</h3><h4 id=问题的解空间><strong>问题的解空间</strong></h4><ol><li>解向量：问题的解用向量表示 $(x_1,x_2,…,x_k)$，其中 $k≤n$，$n$ 为问题的规模</li><li>约束条件<ul><li><strong>显式约束</strong>：对分量 $x_i$ 的取值的明显限定</li><li><strong>隐式约束</strong>：为满足问题的解而对分量施加的约束</li></ul></li><li>解空间：对于问题的一个实例，解向量满足显式约束条件的所有多元组，构成了该实例的一个解空间。</li><li>状态空间树：用于形象描述解空间的树</li><li>目标函数与最优解<ul><li>目标函数：衡量问题解的“优劣”标准</li><li>最优解：使目标函数取极（大/小）值的解</li></ul></li></ol><h4 id=回溯法-1><strong>回溯法</strong></h4><ul><li>基本方法：利用限界函数来<strong>避免生成那些实际上不可能产生所需解的活结点</strong>，以减少问题的计算量，避免无效搜索</li><li><strong>限界函数</strong>：用于剪枝（会出代码填空）<ol><li>约束函数：某个满足条件的表达式或关系式</li><li>限界函数（Upper Bound）：某个函数表达式或关系式</li></ol></li><li>回溯法：具有限界函数的深度优先搜索方法</li><li>基本思想<ol><li>以深度优先方式搜索解空间</li><li>开始时，根节点为活结点，也是当前的扩展结点</li><li>对扩展结点，寻找儿子结点：<ul><li>若找到新结点，新结点称为活结点并成为扩展结点，转 3；</li><li>若找不到新结点，当前结点成为死结点，并回退到最近的一个活结点，使它成为扩展结点，转 3</li></ul></li><li>搜索继续进行，直到找到所求的解或解空间中已无活结点时为止</li></ol></li><li>解题步骤<ol><li>针对所给问题，定义问题的解空间</li><li>确定合适的解空间结构</li><li>以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索，直到找到所求的解或解空间中已无活结点时为止</li></ol></li></ul><h4 id=子集树与排列树><strong>子集树与排列树</strong></h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211104134716898.png alt=image-20211104134716898 style=zoom:33%><p>左图为子集树，遍历子集树需计算 $O(2^n)$；右图为排列树，遍历排列树需要 $O(n!)$</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>//legal(t)为Constraint(t)&amp;&amp;Bound(t)
</span></span></span><span class=line><span class=cl><span class=c1>//子集树
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>t</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span> <span class=n>output</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span><span class=p>[</span><span class=n>t</span><span class=p>]</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    		<span class=k>if</span><span class=p>(</span><span class=n>legal</span><span class=p>(</span><span class=n>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>t</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//排列树
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>t</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span> <span class=n>output</span><span class=p>(</span><span class=n>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=n>t</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>swap</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>t</span><span class=p>],</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>legal</span><span class=p>(</span><span class=n>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>t</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>swap</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>t</span><span class=p>],</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=装载问题>装载问题</h3><h4 id=问题描述-7><strong>问题描述</strong></h4><p>有一批共 n 个集装箱要装上 2 艘载重量分别为 $c_1$ 和 $c_2$ 的轮船，其中集装箱 i 的重量为 $w_i$，且 $\sum_{i=1}^{n}{w_i≤c_1+c_2}$</p><p>求一个装载方案可以将这批集装箱装上这两艘轮船</p><h4 id=最优装载方案><strong>最优装载方案</strong></h4><ol><li>首先将第一艘轮船尽可能装满<ul><li>将第一艘轮船尽可能装满等价于选取全体集装箱集合的一个子集，使该子集中集装箱重量之和最接近 $c_1$</li></ul></li><li>将剩余的集装箱装上第二艘轮船</li></ol><p>装载问题等价于特殊的 0-1 背包问题</p><h4 id=装载问题的回溯法><strong>装载问题的回溯法</strong></h4><ul><li>解空间：子集树，完全二叉树</li><li>设定解向量：$(x_1,x_2,…,x_n)$</li><li>约束条件<ol><li>显式约束：$x_i=0,1(i=1,2,…,n)$</li><li>隐式约束：无</li></ol></li><li>约束函数（整体）：$\sum^{n}_{i=1}{w_ix_i}≤c_1$</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>cw:当前船c1的载重量
</span></span></span><span class=line><span class=cl><span class=cm>bestw:当前船c1d最优载重量, 越大越好
</span></span></span><span class=line><span class=cl><span class=cm>r:剩余集装箱的重量，限界函数:cw+r&gt;bestw
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=c1>//求最优值
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>						<span class=c1>//搜索第i层结点
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span>									<span class=c1>//到达叶结点
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>&gt;</span><span class=n>bestw</span><span class=p>)</span> <span class=n>bestw</span><span class=o>=</span><span class=n>cw</span><span class=p>;</span>				<span class=c1>//修正最优值
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>+</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>c</span><span class=p>)</span>							<span class=c1>//搜索左子树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cw</span><span class=o>+=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cw</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>							<span class=c1>//回退
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>+</span><span class=n>r</span><span class=o>&gt;</span><span class=n>bestw</span><span class=p>)</span>							<span class=c1>//搜索右子树
</span></span></span><span class=line><span class=cl><span class=c1></span>    	<span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>	
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>+=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>为了构造最优解，需在算法中记录与当前最优值相对应的当前最优解。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>cw:当前载重量
</span></span></span><span class=line><span class=cl><span class=cm>x:当前解
</span></span></span><span class=line><span class=cl><span class=cm>bestx:当前最优解
</span></span></span><span class=line><span class=cl><span class=cm>bestw:当前最优载重量
</span></span></span><span class=line><span class=cl><span class=cm>r:剩余集装箱的重量，限界函数:cw+r&gt;bestw
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>&gt;</span><span class=n>bestw</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>bestx</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>			<span class=c1>//记录路径
</span></span></span><span class=line><span class=cl><span class=c1></span>        	<span class=n>bestw</span><span class=o>=</span><span class=n>cw</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>+</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>c</span><span class=p>){</span>						<span class=c1>//搜索左子树
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cw</span><span class=o>+=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cw</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>+</span><span class=n>r</span><span class=o>&gt;</span><span class=n>bestw</span><span class=p>){</span>						<span class=c1>//搜索右子树
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>r</span><span class=o>+=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=c1>//复位
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>迭代回溯</strong></p><p><em>注：代码见书P 130</em></p><ul><li>将回溯法表示成非递归的形式</li><li>所需计算时间仍为$O(2^n)$</li><li>优化：修改递归回溯程序，使所需的计算时间仍为$O(2^n)$</li></ul><h3 id=批处理作业调度>批处理作业调度</h3><h4 id=问题描述-8><strong>问题描述</strong></h4><p>给定 n 个作业的集合 $J=${$J_1,J_2,…,J_n$}，每个作业须由机器 M1 处理，再由机器 M2 处理。作业 $J_i$ 需机器 j 的处理时间为 $t_{ji}$，所有作业在机器 M2 上完成处理的时间和称为该作业调度的完成时间和：$f=\sum_{i=1}^{n}{F_{2i}}$</p><h4 id=算法设计>算法设计</h4><p>设 x[1…n] 是 n 个作业，解空间为<strong>排列树</strong></p><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108131414019.png alt=image-20211108131414019 style=zoom:33%><p><code>f1=f1+m[x[j]][1]</code></p><p><code>f2[i]=((f2[i-1]>f1)?f2[i-1]:f1)+m[x[j]][2]</code></p><p>没有约束函数，只有限界函数</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>f1:机器1完成处理时间
</span></span></span><span class=line><span class=cl><span class=cm>f：完成时间和
</span></span></span><span class=line><span class=cl><span class=cm>bestf:当前最优值
</span></span></span><span class=line><span class=cl><span class=cm>m:各作业所需的处理时间
</span></span></span><span class=line><span class=cl><span class=cm>x:当前作业调度
</span></span></span><span class=line><span class=cl><span class=cm>bestx:当前最优调度
</span></span></span><span class=line><span class=cl><span class=cm>f2:机器2完成处理
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&gt;</span><span class=n>n</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>bestx</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>bestf</span><span class=o>=</span><span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=n>i</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>			<span class=n>f1</span><span class=o>+=</span><span class=n>M</span><span class=p>[</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]][</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>f2</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=p>((</span><span class=n>f2</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>&gt;</span><span class=n>f1</span><span class=p>)</span><span class=o>?</span><span class=n>f2</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span><span class=o>:</span><span class=n>f1</span><span class=p>)</span><span class=o>+</span><span class=n>M</span><span class=p>[</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]][</span><span class=mi>2</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>+=</span><span class=n>f2</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>f</span><span class=o>&lt;</span><span class=n>bestf</span><span class=p>)</span> <span class=c1>//限界函数
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>Swap</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=n>Swap</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>],</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span> <span class=c1>//复位
</span></span></span><span class=line><span class=cl><span class=c1></span>			<span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>f1</span><span class=o>-=</span><span class=n>M</span><span class=p>[</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]][</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=n>f</span><span class=o>-=</span><span class=n>f2</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=n-后问题>n 后问题</h3><h4 id=问题描述-9><strong>问题描述</strong></h4><p>在 n×n 格的棋盘上放置彼此不受攻击的 n 个皇后，任何两个皇后不放在同一行或同一列或同一斜线上</p><p>求出可行解的个数</p><h4 id=算法分析-2><strong>算法分析</strong></h4><ol><li><p>设定解向量：$(x_1,x_2,…,x_n)$，采用<strong>排列树</strong></p></li><li><p>约束条件</p><ul><li><p>显式约束：$x_i=1,2,…,n(i=1,2,…,n)$</p></li><li><p>隐式约束</p><ul><li><p>不同列：$x_i≠x_j$</p></li><li><p>不处于同一正、反对角线：$ | i-j | ≠ | x_i-x_j | $</p></li></ul></li></ul></li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>n:皇后个数
</span></span></span><span class=line><span class=cl><span class=cm>x:当前解
</span></span></span><span class=line><span class=cl><span class=cm>sum:当前已找到的可行方案书
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//约束函数
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>bool</span> <span class=nf>place</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span><span class=p>)</span> <span class=c1>//k为当前行号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>k</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>((</span><span class=n>abs</span><span class=p>(</span><span class=n>k</span><span class=o>-</span><span class=n>j</span><span class=p>)</span><span class=o>==</span><span class=n>abs</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>-</span><span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]))</span> <span class=o>||</span> <span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>==</span><span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//递归回溯
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>t</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>t</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span> <span class=n>sum</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=c1>//这里用的是n叉子集树
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>x</span><span class=p>[</span><span class=n>t</span><span class=p>]</span><span class=o>=</span><span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>place</span><span class=p>(</span><span class=n>t</span><span class=p>))</span>
</span></span><span class=line><span class=cl>                <span class=n>backtrack</span><span class=p>(</span><span class=n>t</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><strong>迭代回溯</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>void</span> <span class=n>N</span><span class=o>-</span><span class=n>queen</span><span class=p>(</span><span class=n>n</span><span class=p>){</span>
</span></span><span class=line><span class=cl>	<span class=n>x</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>k</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=n>k</span><span class=o>&gt;</span><span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>		<span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>=</span><span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>((</span><span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>)</span><span class=o>&amp;&amp;!</span><span class=n>place</span><span class=p>(</span><span class=n>k</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 寻找可以放置的x[k]
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>=</span><span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>+</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>k</span><span class=o>==</span><span class=n>n</span><span class=p>)</span> <span class=n>sum</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        	<span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>k</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        		<span class=n>x</span><span class=p>[</span><span class=n>k</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>k</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=0-1-背包问题-1>0-1 背包问题</h3><p>解空间：子集树</p><p>限界函数：<img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108130809892.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108130809892.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108130809892.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108130809892.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108130809892.png title=image-20211108130809892></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>double</span> <span class=nf>bound</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>						<span class=c1>//计算上界
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>double</span> <span class=n>cleft</span><span class=o>=</span><span class=n>c</span><span class=o>-</span><span class=n>cw</span><span class=p>;</span>					<span class=c1>//剩余容量
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>double</span> <span class=n>bnd</span><span class=o>=</span><span class=n>cp</span><span class=p>;</span>						<span class=c1>//cp:当前价值
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>cleft</span><span class=p>)</span>			<span class=c1>//以物品单位重量价值递减序装入物品
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cleft</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>bnd</span><span class=o>+=</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>i</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&lt;=</span><span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&gt;</span><span class=n>cleft</span><span class=p>)</span>				<span class=c1>//背包有空隙时，装满背包
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bnd</span><span class=o>+=</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>*</span><span class=n>cleft</span><span class=o>/</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>bnd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>//回溯程序
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>Backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>bestp</span><span class=o>=</span><span class=n>cp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    	<span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cw</span><span class=o>+</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>&lt;=</span><span class=n>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cw</span><span class=o>+=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>cp</span><span class=o>+=</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>Backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cw</span><span class=o>-=</span><span class=n>w</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>cp</span><span class=o>-=</span><span class=n>p</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>bound</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>&gt;</span><span class=n>bestp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>Backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>时间复杂度：$O(n2^n)$</p><h3 id=最大团问题>最大团问题</h3><h4 id=概念-1>概念</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108133034389.png alt=image-20211108133034389 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108133059950.png alt=image-20211108133059950 style=zoom:33%><p>通俗的讲，就是在一个无向图中找出一个<strong>点数最多的完全图</strong></p><h4 id=算法分析-3><strong>算法分析</strong></h4><p>解空间：子集树</p><p>限界函数：取 cn+(n-i)，即有足够多的可选择顶点使得算法有可能在右子树中找到更大的团</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm>n:图的顶点数
</span></span></span><span class=line><span class=cl><span class=cm>x:当前解
</span></span></span><span class=line><span class=cl><span class=cm>bestx:当前最优解
</span></span></span><span class=line><span class=cl><span class=cm>cn:当前顶点数
</span></span></span><span class=line><span class=cl><span class=cm>bestn:当前最大顶点数
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>backtrack</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>&gt;</span><span class=n>n</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;=</span><span class=n>n</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>bestx</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>=</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=n>bestn</span><span class=o>=</span><span class=n>cn</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>ok</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span><span class=n>j</span><span class=o>&lt;</span><span class=n>i</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>)</span>				<span class=c1>//欲扩展节点i
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>x</span><span class=p>[</span><span class=n>j</span><span class=p>]</span><span class=o>==</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>a</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>			<span class=c1>//考察：i与前面的j是否相连
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// 若x[j]在团中而且j与i不x
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>ok</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>						<span class=c1>//i与前面的j不相连，舍弃i
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>		<span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>ok</span><span class=p>)</span>							<span class=c1>//进入左子树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cn</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cn</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>cn</span><span class=o>+</span><span class=n>n</span><span class=o>-</span><span class=n>i</span><span class=o>&gt;</span><span class=n>bestn</span><span class=p>)</span>				<span class=c1>//进入右子树
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span><span class=p>[</span><span class=n>i</span><span class=p>]</span><span class=o>=</span><span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>backtrack</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=启发式信息>启发式信息</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108134445654.png alt=image-20211108134445654 style=zoom:40%><h2 id=分支限界法>分支限界法</h2><h3 id=概念-2>概念</h3><p>基于广度优先</p><h4 id=与回溯法的不同>与回溯法的不同</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108135918803.png alt=image-20211108135918803 style=zoom:33%><h4 id=基本思想-3>基本思想</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108140036597.png alt=image-20211108140036597 style=zoom:33%><h4 id=方法>方法</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108140352514.png alt=image-20211108140352514 style=zoom:33%><h4 id=术语>术语</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108140605768.png alt=image-20211108140605768 style=zoom:33%>
<img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108140619180.png alt=image-20211108140619180 style=zoom:33%><p>剪枝的表现：不要将这个节点入列</p><h4 id=子集树与排列数的算法框架>子集树与排列数的算法框架</h4><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141510801.png data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141510801.png, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141510801.png 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141510801.png 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141510801.png title=image-20211108141510801></p><h3 id=装载问题-1>装载问题</h3><h4 id=描述>描述</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141658348.png alt=image-20211108141658348 style=zoom:33%><h4 id=队列式分支限界法>队列式分支限界法</h4><img src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/image-20211108141743969.png alt=image-20211108141743969 style=zoom:33%></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2022-08-21 12:08:57">更新于 2022-08-21</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/ data-title=算法设计与分析 data-hashtags=算法><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/ data-hashtag=算法><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/courses/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/ data-title=算法设计与分析><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E7%AE%97%E6%B3%95/>算法</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/linux/shell-%E7%BC%96%E7%A8%8B/ class=prev rel=prev title="Linux shell 编程"><i class="fa-solid fa-angle-left fa-fw"></i>Linux shell 编程</a>
<a href=/Notes/posts/linux/%E5%9F%BA%E7%A1%80/ class=next rel=next title="Linux 基础">Linux 基础<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.stemmer.support.min.js defer></script><script type=text/javascript src=/Notes/lib/lunr/lunr.zh.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{highlightTag:"em",lunrIndexURL:"/Notes/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/Notes/lib/lunr/lunr.segmentit.js",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>