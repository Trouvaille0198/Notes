<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 伤心肠粉的酱油碟子</title><link>https://trouvaille0198.github.io/Notes/posts/</link><description>所有文章 | 伤心肠粉的酱油碟子</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 03 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trouvaille0198.github.io/Notes/posts/" rel="self" type="application/rss+xml"/><item><title>Go runtime/pprof库</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/</guid><description>runtime/pprof benchmark(基准测试) 可以度量某个函数或方法的性能，也就是说，如果我们知道性能的瓶颈点在哪里，benchmark 是一个非常好的方式</description></item><item><title>Go 进阶</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/</guid><description>Go 进阶 内存对齐 引入 1 2 3 4 5 6 7 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？ 1 2 3 4 5 6 7 8 func main() { fmt.Printf(&amp;#34;bool size: %d\n&amp;#34;,</description></item><item><title>Go 高性能编程</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</guid><description>Go 高性能编程 常用数据结构 字符串高效拼接 在 Go 语言中，字符串 (string) 是不可变的，拼接字符串事实上是创建了一个新的字符串对象。 如果代码中存在大量的字符串</description></item><item><title>剑指 Offer 15. 二进制中1的个数</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid><description>剑指 Offer 15. 二进制中1的个数 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &amp;lsquo;1&amp;rsquo; 的个数（也被称为 汉明重量).</description></item><item><title>剑指 Offer 16. 数值的整数次方</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-16.-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</guid><description>剑指 Offer 16. 数值的整数次方 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 示例 1： 1 2 输入：x = 2.00000, n = 10 输出</description></item><item><title>剑指 Offer 33. 二叉搜索树的后序遍历序列</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-33.-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</guid><description>剑指 Offer 33. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设</description></item><item><title>剑指 Offer 65. 不用加减乘除做加法</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-65.-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid><description>剑指 Offer 65. 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 示例: 1 2 输入: a =</description></item><item><title>剑指 Offer 07. 重建二叉树</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-07.-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>剑指 Offer 07. 重建二叉树 mid 输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。 假设输入的前序遍历和中序遍历的结果中都不含重复的数</description></item><item><title>剑指 Offer 26. 树的子结构</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</link><pubDate>Mon, 28 Feb 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-26.-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</guid><description>剑指 Offer 26. 树的子结构 mid 输入两棵二叉树 A 和 B，判断 B 是不是 A 的子结构。(约定空树不是任意一个树的子结构) B 是 A 的子结构， 即 A 中有出现和 B 相同的结</description></item><item><title>剑指 Offer 55 - II. 平衡二叉树</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Sun, 27 Feb 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/tree/%E5%89%91%E6%8C%87-offer-55-ii.-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>剑指 Offer 55 - II. 平衡二叉树 easy 输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵</description></item></channel></rss>