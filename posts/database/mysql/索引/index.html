<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>MySQL 索引 - 伤心肠粉的酱油碟子</title><meta name=author content><meta name=author-link content><meta name=description content="索引 索引是存储引擎用于提高数据库表的访问速度的一种数据结构，它为特定的 mysql 字段进行"><meta name=keywords content="数据库,MySQL"><meta itemprop=name content="MySQL 索引"><meta itemprop=description content="索引 索引是存储引擎用于提高数据库表的访问速度的一种数据结构，它为特定的 mysql 字段进行"><meta itemprop=datePublished content="2022-11-17T00:00:00+00:00"><meta itemprop=dateModified content="2023-06-14T12:27:03+00:00"><meta itemprop=wordCount content="5870"><meta itemprop=image content="https://trouvaille0198.github.io/logo.png"><meta itemprop=keywords content="数据库,MySQL,"><meta property="og:title" content="MySQL 索引"><meta property="og:description" content="索引 索引是存储引擎用于提高数据库表的访问速度的一种数据结构，它为特定的 mysql 字段进行"><meta property="og:type" content="article"><meta property="og:url" content="https://trouvaille0198.github.io/Notes/posts/database/mysql/%E7%B4%A2%E5%BC%95/"><meta property="og:image" content="https://trouvaille0198.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-17T00:00:00+00:00"><meta property="article:modified_time" content="2023-06-14T12:27:03+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://trouvaille0198.github.io/logo.png"><meta name=twitter:title content="MySQL 索引"><meta name=twitter:description content="索引 索引是存储引擎用于提高数据库表的访问速度的一种数据结构，它为特定的 mysql 字段进行"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#252627"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://trouvaille0198.github.io/Notes/posts/database/mysql/%E7%B4%A2%E5%BC%95/><link rel=prev href=https://trouvaille0198.github.io/Notes/posts/database/mysql/%E4%B8%80%E4%BA%9B%E5%85%AB%E8%82%A1/><link rel=next href=https://trouvaille0198.github.io/Notes/posts/database/mysql/%E4%BA%8B%E5%8A%A1/><link rel=stylesheet href=/Notes/lib/normalize/normalize.min.css><link rel=stylesheet href=/Notes/css/style.min.css><link rel=stylesheet href=/Notes/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/Notes/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"MySQL 索引","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/database\/mysql\/%E7%B4%A2%E5%BC%95\/"},"genre":"posts","keywords":"数据库, MySQL","wordcount":5870,"url":"https:\/\/trouvaille0198.github.io\/Notes\/posts\/database\/mysql\/%E7%B4%A2%E5%BC%95\/","datePublished":"2022-11-17T00:00:00+00:00","dateModified":"2023-06-14T12:27:03+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"MelonCholi"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/Notes/ title=伤心肠粉的酱油碟子><span class=header-title-text>伤心肠粉</span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="搜索文章标题或内容 ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/Notes/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/Notes/tags/>标签</a></li><li class=menu-item><a class=menu-link href=/Notes/posts/>文章</a></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw"></i></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container page-style=normal><aside class=toc id=toc-auto><h2 class=toc-title>目录 <i class="toc-icon fa-solid fa-angle-down fa-fw"></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>MySQL 索引</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle"></i>
MelonCholi</span></span>
<span class=post-category>收录于 <a href=/Notes/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/><i class="fa-regular fa-folder fa-fw"></i>&nbsp;数据库</a></span></div><div class=post-meta-line><span title="2022-11-17 00:00:00"><i class="fa-regular fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2022-11-17>2022-11-17</time>
</span>&nbsp;<i class="fa-solid fa-pencil-alt fa-fw"></i>&nbsp;约 5870 字&nbsp;
<i class="fa-regular fa-clock fa-fw"></i>&nbsp;预计阅读 12 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#索引的使用场景>索引的使用场景</a><ul><li><a href=#索引的优缺点>索引的优缺点</a></li><li><a href=#什么情况下需要建索引>什么情况下需要建索引</a></li><li><a href=#什么情况下不建索引>什么情况下不建索引</a></li></ul></li><li><a href=#索引的数据结构>索引的数据结构</a><ul><li><a href=#b-树索引>B+ 树索引</a></li><li><a href=#哈希索引>哈希索引</a></li><li><a href=#hash-索引和-b-树索引的区别>Hash 索引和 B+ 树索引的区别？</a></li><li><a href=#为什么-b-树比-b-树更适合实-现数据库索引>为什么 B+ 树比 B 树更适合实 现数据库索引？</a></li></ul></li><li><a href=#索引的类型>索引的类型</a></li><li><a href=#索引的设计原则>索引的设计原则</a></li><li><a href=#索引何时会失效>索引何时会失效</a></li><li><a href=#索引的相关操作>索引的相关操作</a><ul><li><a href=#索引的创建><strong>索引的创建</strong></a><ul><li><a href=#alter-table><code>ALTER TABLE</code></a></li><li><a href=#create-index><code>CREATE INDEX</code></a></li></ul></li><li><a href=#索引的删除>索引的删除</a></li><li><a href=#索引的查看>索引的查看</a></li><li><a href=#索引的更改>索引的更改</a></li></ul></li><li><a href=#组合索引>组合索引</a><ul><li><a href=#最左匹配原则>最左匹配原则</a><ul><li><a href=#范围查询后停止匹配>范围查询后停止匹配</a></li><li><a href=#例>例</a></li></ul></li></ul></li><li><a href=#聚集索引>聚集索引</a></li><li><a href=#覆盖索引>覆盖索引</a><ul><li><a href=#语法>语法</a></li></ul></li><li><a href=#前缀索引>前缀索引</a></li><li><a href=#强制索引>强制索引</a><ul><li><a href=#强制索引-mysql-force-index>强制索引 MySQL FORCE INDEX</a></li><li><a href=#忽略索引-ignore-index>忽略索引 IGNORE INDEX</a></li><li><a href=#关闭查询缓冲-sql_no_cache>关闭查询缓冲 SQL_NO_CACHE</a></li><li><a href=#强制查询缓冲-sql_cache>强制查询缓冲 SQL_CACHE</a></li><li><a href=#优先操作-high_priority>优先操作 HIGH_PRIORITY</a></li><li><a href=#滞后操作-low_priority>滞后操作 LOW_PRIORITY</a></li><li><a href=#延时插入-insert-delayed>延时插入 INSERT DELAYED</a></li><li><a href=#强制连接顺序-straight_join>强制连接顺序 STRAIGHT_JOIN</a></li><li><a href=#强制使用临时表-sql_buffer_result>强制使用临时表 SQL_BUFFER_RESULT</a></li><li><a href=#分组使用临时表-sql_big_result-和-sql_small_result>分组使用临时表 SQL_BIG_RESULT 和 SQL_SMALL_RESULT</a></li></ul></li></ul></nav></div></div><div class=content id=content><h1 id=索引>索引</h1><p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>，它为特定的 mysql 字段进行一些<strong>特定的算法排序</strong>，比如二叉树的算法和哈希算法</p><ul><li>哈希算法是通过建立特征值，然后根据特征值来快速查找。</li><li>用的最多，并且是 mysql 默认的就是二叉树算法 BTREE（B+ 树），通过 BTREE 算法建立索引的字段，比如扫描 20 行就能得到未使用 BTREE 前扫描了 2^20^ 行的结果。</li></ul><h2 id=索引的使用场景>索引的使用场景</h2><h3 id=索引的优缺点>索引的优缺点</h3><p>优点</p><ul><li><strong>加快数据查找的速度</strong></li><li>为用来排序或分组的字段添加索引，可以<strong>加快分组和排序的速度</strong></li><li>加快表与表之间的<strong>连接</strong></li></ul><p>缺点</p><ul><li>建立索引需要<strong>占用物理空间</strong></li><li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长</li></ul><h3 id=什么情况下需要建索引>什么情况下需要建索引</h3><ol><li>经常用于<strong>查询</strong>的字段</li><li>经常用于<strong>连接</strong>的字段建立索引，可以加快连接的速度</li><li>经常需要<strong>排序</strong>的字段建立索引，因为索引已经排好序，可以加快排序查询速度</li></ol><h3 id=什么情况下不建索引>什么情况下不建索引</h3><ol><li><code>where</code> 条件中用不到的字段不适合建立索引</li><li><strong>表记录较少</strong>。比如只有几百条数据，没必要加索引。</li><li>需要<strong>经常增删改</strong>。需要评估是否适合加索引</li><li><strong>参与列计算</strong>的列不适合建索引</li><li><strong>区分度不高</strong>的字段不适合建立索引，如性别，只有男/女/未知三个值。加了索引，查询效率也不会提高。</li></ol><h2 id=索引的数据结构>索引的数据结构</h2><h3 id=b-树索引>B+ 树索引</h3><p>B+ 树是<strong>基于 B 树和叶子节点顺序访问指针</strong>进行实现，它具有 B 树的平衡性，并且通过顺序访问指针来提高区间查询的性能。</p><p>在 B+ 树中，节点中的 <code>key</code> 从左到右递增排列，如果某个指针的左右相邻 <code>key</code> 分别是 key~i~ 和 key~i+1~，则该指针指向节点的所有 <code>key</code> 大于等于 key~i~ 且小于等于 key~i+1~。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2b6d28e258f4fe43acd500f32331fcd3_1440w.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2b6d28e258f4fe43acd500f32331fcd3_1440w.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2b6d28e258f4fe43acd500f32331fcd3_1440w.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2b6d28e258f4fe43acd500f32331fcd3_1440w.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-2b6d28e258f4fe43acd500f32331fcd3_1440w.jpg title=img></p><p>进行查找操作时，首先在根节点进行<strong>二分查找</strong>，找到 <code>key</code> 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 <code>key</code> 所对应的数据项。</p><p>MySQL 数据库使用最多的索引类型是 <code>BTREE</code> 索引，底层基于 B+ 树数据结构来实现。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=n>mysql</span><span class=o>&gt;</span><span class=w> </span><span class=k>show</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>blog</span><span class=err>\</span><span class=n>G</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=o>***************************</span><span class=w> </span><span class=mi>1</span><span class=p>.</span><span class=w> </span><span class=n>row</span><span class=w> </span><span class=o>***************************</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>Table</span><span class=p>:</span><span class=w> </span><span class=n>blog</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Non_unique</span><span class=p>:</span><span class=w> </span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>Key_name</span><span class=p>:</span><span class=w> </span><span class=k>PRIMARY</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>Seq_in_index</span><span class=p>:</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Column_name</span><span class=p>:</span><span class=w> </span><span class=n>blog_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Collation</span><span class=p>:</span><span class=w> </span><span class=n>A</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>Cardinality</span><span class=p>:</span><span class=w> </span><span class=mi>4</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=n>Sub_part</span><span class=p>:</span><span class=w> </span><span class=no>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>Packed</span><span class=p>:</span><span class=w> </span><span class=no>NULL</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=no>Null</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Index_type</span><span class=p>:</span><span class=w> </span><span class=n>BTREE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Comment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Index_comment</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=n>Visible</span><span class=p>:</span><span class=w> </span><span class=n>YES</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>   </span><span class=n>Expression</span><span class=p>:</span><span class=w> </span><span class=no>NULL</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=哈希索引>哈希索引</h3><p>哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的</p><p>将哈希码的值作为哈希表的 key 值，将指向数据行的指针作为哈希表的 value 值。这样查找一个数据的时间复杂度就是 O(1)，一般多用于精确查找。</p><h3 id=hash-索引和-b-树索引的区别>Hash 索引和 B+ 树索引的区别？</h3><ul><li>哈希索引<strong>不支持排序</strong>，因为哈希表是无序的。</li><li>哈希索引<strong>不支持范围查找</strong>。</li><li>哈希索引<strong>不支持模糊查询</strong>及多列索引的最左前缀匹配。</li><li>因为哈希表中会<strong>存在哈希冲突</strong>，所以哈希索引的<strong>性能不稳定</strong>，而 B+ 树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。</li></ul><h3 id=为什么-b-树比-b-树更适合实-现数据库索引>为什么 B+ 树比 B 树更适合实 现数据库索引？</h3><ul><li>由于 B+ 树的数据都存储在叶子结点中，叶子结点均为索引，<strong>方便扫库</strong>，只需要扫一遍叶子结点即可，<ul><li>但是 B 树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫</li><li>所以 B+ 树<strong>更加适合在区间查询的情况</strong>，而在数据库中基于范围的查询是非常频繁的，所以通常 B+ 树用于数据库索引。</li></ul></li><li>B+ 树的节点只存储索引 key 值，具体信息的地址存在于叶子节点的地址中。这就使以页为单位的索引中可以存放更多的节点。减少更多的 I/O 支出。</li><li>B+ 树的<strong>查询效率更加稳定</strong>，任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li></ul><h2 id=索引的类型>索引的类型</h2><p><strong>INDEX 普通索引</strong></p><ul><li>允许出现相同的索引内容。</li></ul><p><strong>UNIQUE KEY 唯一索引</strong></p><ul><li>唯一，允许出现空值</li><li>用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ADD</span><span class=w> </span><span class=k>CONSTRAINT</span><span class=w> </span><span class=k>constraint_name</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=n>column_1</span><span class=p>,</span><span class=n>column_2</span><span class=p>,...);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>PRIMARY KEY 主键索引</strong></p><ul><li>唯一，非空</li></ul><p><strong>组合索引</strong></p><ul><li>在表中的多个字段组合上创建的索引</li><li>只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时需遵循<strong>最左前缀原则</strong>。</li></ul><p><strong>fulltext index 全文索引</strong></p><ul><li>上述三种索引都是针对列的值发挥作用，但全文索引，可以针对值中的某个单词，比如一篇文章中的某个词</li><li>只能在<code>CHAR</code>、<code>VARCHAR</code> 和 <code>TEXT</code> 类型字段上使用全文索引</li><li>然而并没有什么卵用，因为只有 MYISAM 以及英文支持，并且效率让人不敢恭维</li></ul><h2 id=索引的设计原则>索引的设计原则</h2><ul><li>索引列的<strong>区分度越高</strong>，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。<ul><li>话句话说，在维度高的列创建索引。</li></ul></li><li>尽量使用<strong>短索引</strong>，因为较小的索引涉及到的磁盘 I/O 较少，查询速度更快。<ul><li>对于较长的字符串进行索引时应该指定一个较短的前缀长度（<strong>前缀索引</strong>）</li></ul></li><li>索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。<ul><li>对 where, on, group by, order by 中频繁出现的列使用索引。</li></ul></li><li>使用组合索引，可以减少文件索引大小，在使用时速度要优于多个单列索引。<ul><li>利用<strong>最左前缀原则</strong>。</li></ul></li></ul><h2 id=索引何时会失效>索引何时会失效</h2><p>导致索引失效的情况：</p><ul><li><p><strong>条件中有 <code>or</code></strong></p><ul><li>例如<code> select * from table_name where a = 1 or b = 3</code></li></ul></li><li><p><strong>在索引上进行计算</strong>会导致索引失效</p><ul><li>例如 <code>select * from table_name where a + 1 = 2</code></li></ul></li><li><p>在索引的类型上进行数据类型的<strong>隐式转换</strong>，会导致索引失效，</p><ul><li>例如字符串一定要加引号，假设 <code>select * from table_name where a = '1'</code> 会使用到索引，如果写成 <code>select * from table_name where a = 1</code> 则会导致索引失效。</li></ul></li><li><p>在索引中使用<strong>函数</strong>会导致索引失效</p><ul><li>例如 <code>select * from table_name where abs(a) = 1</code></li></ul></li><li><p>在使用 like 查询时<strong>以 % 开头</strong>会导致索引失效</p></li><li><p>索引上使用 <strong>!=、&lt;></strong> 进行判断时会导致索引失效</p><ul><li>例如 <code>select * from table_name where a != 1</code></li></ul></li><li><p>索引字段上使用 <strong>is null/is not null</strong> 判断时会导致索引失效</p><ul><li>例如 <code>select * from table_name where a is null</code></li></ul></li></ul><h2 id=索引的相关操作>索引的相关操作</h2><h3 id=索引的创建><strong>索引的创建</strong></h3><h4 id=alter-table><code>ALTER TABLE</code></h4><p>适用于表创建完毕之后再添加。</p><p><code>ALTER TABLE 表名 ADD 索引类型(unique,primary key,fulltext,index) 索引名 (字段名)</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>index_name</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>column_list</span><span class=o>`</span><span class=p>)</span><span class=w> </span><span class=c1>-- 索引名，可要可不要；如果不要，当前的索引名就是该字段名。 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>column_list</span><span class=o>`</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>column_list</span><span class=o>`</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=n>FULLTEXT</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>column_list</span><span class=o>`</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h4 id=create-index><code>CREATE INDEX</code></h4><p>CREATE INDEX 可对表增加<strong>普通</strong>索引或 <strong>UNIQUE</strong> 索引。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=c1>--例：只能添加这两种索引 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=p>(</span><span class=n>column_list</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>index_name</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=p>(</span><span class=n>column_list</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><strong>另外，还可以在建表时添加：</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>test1</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=w> </span><span class=nb>smallint</span><span class=p>(</span><span class=mi>5</span><span class=p>)</span><span class=w> </span><span class=n>UNSIGNED</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=p>,</span><span class=w> </span><span class=c1>-- 注意，下面创建了主键索引，这里就不用创建了 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=o>`</span><span class=n>username</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>64</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;用户名&#39;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>nickname</span><span class=o>`</span><span class=w> </span><span class=nb>varchar</span><span class=p>(</span><span class=mi>50</span><span class=p>)</span><span class=w> </span><span class=k>NOT</span><span class=w> </span><span class=k>NULL</span><span class=w> </span><span class=k>COMMENT</span><span class=w> </span><span class=s1>&#39;昵称/姓名&#39;</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>`</span><span class=n>intro</span><span class=o>`</span><span class=w> </span><span class=nb>text</span><span class=p>,</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>id</span><span class=o>`</span><span class=p>),</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>unique1</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>username</span><span class=o>`</span><span class=p>),</span><span class=w> </span><span class=c1>-- 索引名称，可要可不要，不要就是和列名一样 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>  </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>index1</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>nickname</span><span class=o>`</span><span class=p>),</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>FULLTEXT</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=o>`</span><span class=n>intro</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=o>`</span><span class=n>intro</span><span class=o>`</span><span class=p>)</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>)</span><span class=w> </span><span class=n>ENGINE</span><span class=o>=</span><span class=n>MyISAM</span><span class=w> </span><span class=n>AUTO_INCREMENT</span><span class=o>=</span><span class=mi>4</span><span class=w> </span><span class=k>DEFAULT</span><span class=w> </span><span class=n>CHARSET</span><span class=o>=</span><span class=n>utf8</span><span class=w> </span><span class=k>COMMENT</span><span class=o>=</span><span class=s1>&#39;后台用户表&#39;</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=索引的删除>索引的删除</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>DROP</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>index_name</span><span class=o>`</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=o>`</span><span class=n>talbe_name</span><span class=o>`</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=k>DROP</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>index_name</span><span class=o>`</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>-- 这两句都是等价的,都是删除掉table_name中的索引index_name; 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>table_name</span><span class=o>`</span><span class=w> </span><span class=k>DROP</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=c1>-- 删除主键索引，注意主键索引只能用这种方式删除
</span></span></span></code></pre></td></tr></table></div></div><h3 id=索引的查看>索引的查看</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>show</span><span class=w> </span><span class=k>index</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>tablename</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=索引的更改>索引的更改</h3><p>更改个毛线，删掉重建一个既可</p><h2 id=组合索引>组合索引</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=n>myIndex</span><span class=o>`</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>name_city_age</span><span class=o>`</span><span class=w> </span><span class=p>(</span><span class=n>vc_Name</span><span class=p>(</span><span class=mi>10</span><span class=p>),</span><span class=n>vc_City</span><span class=p>,</span><span class=n>i_Age</span><span class=p>);</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上述的步骤就是将 vc_Name，vc_City，i_Age 建到一个索引里</p><p>这样一来，在执行这条 SQL 查询语句时：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>`</span><span class=n>i_testID</span><span class=o>`</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=o>`</span><span class=n>myIndex</span><span class=o>`</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=o>`</span><span class=n>vc_Name</span><span class=o>`=</span><span class=s1>&#39;erquan&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=o>`</span><span class=n>vc_City</span><span class=o>`=</span><span class=s1>&#39;郑州&#39;</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=o>`</span><span class=n>i_Age</span><span class=o>`=</span><span class=mi>25</span><span class=p>;</span><span class=w> </span><span class=c1>-- 关联搜索;
</span></span></span></code></pre></td></tr></table></div></div><p>查询速度会比只建立某一个字段的单独索引要快得多</p><blockquote><p>如果分别在 vc_Name，vc_City，i_Age 上建立单列索引，让该表有 3 个单列索引，查询的速度将远远低于组合索引。</p><p>虽然此时有了三个索引，但 MySQL 只能用到其中的那个它认为似乎是<strong>最有效率</strong>的单列索引，另外两个是用不到的，也就是说还是一个全表扫描的过程。</p></blockquote><h3 id=最左匹配原则>最左匹配原则</h3><p>建立这样的组合索引，其实是相当于分别建立了：</p><ul><li><code>vc_Name, vc_City, i_Age</code></li><li><code>vc_Name, vc_City</code></li><li><code>vc_Name</code></li></ul><p>为什么没有 <code>vc_City, i_Age</code> 等这样的组合索引呢？这是因为 mysql 组合索引 “最左前缀” 的结果。简单的理解就是<strong>只从最左面的开始组合</strong>。并不是只要包含这三列的查询都会用到该组合索引，下面的几个 T-SQL 会用到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>myIndex</span><span class=w> </span><span class=n>WHREE</span><span class=w> </span><span class=n>vc_Name</span><span class=o>=</span><span class=err>”</span><span class=n>erquan</span><span class=err>”</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>vc_City</span><span class=o>=</span><span class=err>”郑州”</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>myIndex</span><span class=w> </span><span class=n>WHREE</span><span class=w> </span><span class=n>vc_Name</span><span class=o>=</span><span class=err>”</span><span class=n>erquan</span><span class=err>”</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>而下面几个则不会用到：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>myIndex</span><span class=w> </span><span class=n>WHREE</span><span class=w> </span><span class=n>i_Age</span><span class=o>=</span><span class=mi>20</span><span class=w> </span><span class=k>AND</span><span class=w> </span><span class=n>vc_City</span><span class=o>=</span><span class=err>”郑州”</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>myIndex</span><span class=w> </span><span class=n>WHREE</span><span class=w> </span><span class=n>vc_City</span><span class=o>=</span><span class=err>”郑州”</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>也就是，<code>name_city_age(vc_Name(10),vc_City,i_Age)</code> 会<strong>从左到右</strong>进行索引，如果没有左前索引，Mysql 不执行索引查询。</p><h4 id=范围查询后停止匹配>范围查询后停止匹配</h4><p>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。</p><p><strong>当遇到范围查询 (<code>></code>、<code>&lt;</code>、<code>between</code>、<code>like</code>) 后就会停止匹配，后面的字段不会用到索引</strong>。</p><p>例</p><ul><li><p>对<code>(a,b,c)</code>建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。</p></li><li><p>对<code>(a,b,c,d)</code>建立索引，查询条件为<code>a = 1 and b = 2 and c > 3 and d = 4</code>，那么 a、b 和 c 三个字段能用到索引，而 d 无法使用索引。因为遇到了范围查询。</p></li></ul><p>如下图，对 (a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当 a 相等时，会根据 b 进行排序）。直接执行 <code>b = 2</code> 这种查询条件无法使用索引。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-abcd73c11c1b363a704299fb0366a8a8_1440w.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-abcd73c11c1b363a704299fb0366a8a8_1440w.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-abcd73c11c1b363a704299fb0366a8a8_1440w.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-abcd73c11c1b363a704299fb0366a8a8_1440w.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-abcd73c11c1b363a704299fb0366a8a8_1440w.jpg title=img></p><p>当 a 的值确定的时候，b 是有序的。例如 <code>a = 1</code> 时，b 值为 1，2 是有序的状态。当 <code>a = 2</code> 时候，b 的值为 1，4 也是有序状态。 当执行 <code>a = 1 and b = 2</code> 时 a 和 b 字段能用到索引。而执行 <code>a > 1 and b = 2</code> 时，a 字段能用到索引，b 字段用不到索引。因为 a 的值此时是一个范围，不是固定的，在这个范围内 b 值不是有序的，因此 b 字段无法使用索引。</p><h4 id=例>例</h4><p>例如建立索引 (a,b,c)</p><p>第一种</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>3</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>上面两次查询过程中所有值都用到了索引，⭐ <strong>where 后面字段调换不会影响查询结果</strong>，因为 MySQL 中的优化器会自动优化查询顺序。</p><p>第二种</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>3</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>答案是三个查询语句都用到了索引，因为三个语句都是从最左开始匹配的。</p><p>第三种</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w>  </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w>  </span><span class=n>b</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>答案是这两个查询语句都没有用到索引，因为不是从最左边开始匹配的</p><p>第四种</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>2</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个查询语句只有 a 列用到了索引，c 列没有用到索引，因为中间跳过了 b 列，不是从最左开始连续匹配的。</p><p>第五种</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w>  </span><span class=n>a</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=n>b</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>3</span><span class=w> </span><span class=k>and</span><span class=w> </span><span class=k>c</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个查询中只有 a 列和 b 列使用到了索引，而 c 列没有使用索引，因为根据最左匹配查询原则，遇到范围查询会停止。</p><p>第六种</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;ab%&#39;</span><span class=p>;</span><span class=w> 
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w>  </span><span class=n>a</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%ab&#39;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>select</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>where</span><span class=w>  </span><span class=n>a</span><span class=w> </span><span class=k>like</span><span class=w> </span><span class=s1>&#39;%ab%&#39;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>对于列为字符串的情况，只有前缀匹配可以使用索引，中缀匹配和后缀匹配只能进行全表扫描。</p><h2 id=聚集索引>聚集索引</h2><p><strong><code>InnoDB</code> 使用表的主键构造主键索引树，同时叶子节点中存放的即为整张表的记录数据</strong>，这就是聚集索引 / 聚簇索引（Cluster Index）</p><p>聚集索引叶子节点的存储是逻辑上连续的，使用双向链表连接，叶子节点按照主键的顺序排序，因此对于主键的排序查找和范围查找速度比较快。</p><p><strong>聚集索引的叶子节点就是整张表的行记录</strong>。InnoDB 主键使用的就是聚集索引。聚集索引要比非聚集索引查询效率高很多。</p><p>对于 <code>InnoDB</code> 来说，<strong>聚集索引一般是表中的主键索引</strong></p><ul><li>如果表中没有显式地指定主键，则会选择表中的第一个不允许为 <code>NULL</code> 的唯一索引。</li><li>如果没有主键也没有合适的唯一索引，那么 <code>InnoDB</code> 内部会生成一个<strong>隐藏的主键</strong>作为聚集索引，这个隐藏的主键长度为 6 个字节，它的值会随着数据的插入自增。</li></ul><p>除了 Cluster Index 外的索引是 <strong>Secondary Index (辅助索引或二级索引)</strong>。<strong>辅助索引中的叶子节点保存的是主键。</strong></p><h2 id=覆盖索引>覆盖索引</h2><p><strong>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。</strong></p><p>换句话说，<strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。</strong></p><p>对于 <code>innodb</code> 表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。</p><blockquote><p>不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以 MySQL 使用 b+ 树索引做覆盖索引。</p></blockquote><h3 id=语法>语法</h3><p>对于使用了覆盖索引的查询，在查询前面使用 <code>explain</code>，输出的 extra 列会显示为 <code>using index</code>。</p><p>比如 <code>user_like</code> 用户点赞表，组合索引为 <code>(user_id, blog_id)</code>，<code>user_id</code> 和 <code>blog_id</code> 都不为 <code>null</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>explain</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=n>blog_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>user_like</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>13</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>explain</code> 结果的 <code>Extra</code> 列为 <code>Using index</code>，<strong>查询的列被索引覆盖</strong>，并且 where 筛选条件符合最左前缀原则，通过<strong>索引查找</strong>（index seek）就能直接找到符合条件的数据，不需要回表查询数据。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>explain</span><span class=w> </span><span class=k>select</span><span class=w> </span><span class=n>user_id</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>user_like</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>blog_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p><code>explain</code> 结果的 <code>Extra</code> 列为 <code>Using where; Using index</code>， 查询的列被索引覆盖，where 筛选条件不符合最左前缀原则，无法通过索引查找找到符合条件的数据，但可以通过<strong>索引扫描</strong>（index scan）找到符合条件的数据，也不需要回表查询数据。</p><p><img class=lazyload src=/Notes/svg/loading.min.svg data-src=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-7eb2565360584ef8dda13da503f96137_1440w.jpg data-srcset="https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-7eb2565360584ef8dda13da503f96137_1440w.jpg, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-7eb2565360584ef8dda13da503f96137_1440w.jpg 1.5x, https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-7eb2565360584ef8dda13da503f96137_1440w.jpg 2x" data-sizes=auto alt=https://markdown-1303167219.cos.ap-shanghai.myqcloud.com/v2-7eb2565360584ef8dda13da503f96137_1440w.jpg title=img></p><h2 id=前缀索引>前缀索引</h2><p>前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。</p><p>如果索引列长度过长，这种列索引时将会产生很大的索引文件，不便于操作，可以使用前缀索引方式进行索引前缀索引应该控制在一个合适的点，控制在 0.31 黄金值即可（大于这个值就可以创建）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=k>DISTINCT</span><span class=p>(</span><span class=k>LEFT</span><span class=p>(</span><span class=o>`</span><span class=n>title</span><span class=o>`</span><span class=p>,</span><span class=mi>10</span><span class=p>)))</span><span class=o>/</span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>Arctic</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>这个值大于 0.31 就可以创建前缀索引，Distinct 去重复</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=o>`</span><span class=k>user</span><span class=o>`</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=o>`</span><span class=n>uname</span><span class=o>`</span><span class=p>(</span><span class=n>title</span><span class=p>(</span><span class=mi>10</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>增加前缀索引 SQL，将人名的索引建立在 10，这样可以减少索引文件大小，加快索引查询速度。</p><p>建立前缀索引的方式：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=o>#</span><span class=w> </span><span class=n>email</span><span class=err>列创建前缀索引</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>KEY</span><span class=p>(</span><span class=k>column_name</span><span class=p>(</span><span class=n>prefix_length</span><span class=p>));</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=强制索引>强制索引</h2><h3 id=强制索引-mysql-force-index>强制索引 MySQL FORCE INDEX</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=w> </span><span class=k>FORCE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=p>(</span><span class=n>FIELD1</span><span class=p>)</span><span class=w> </span><span class=err>…</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>以上的 SQL 语句只使用建立在 FIELD1 上的索引，而不使用其它字段上的索引。</p><h3 id=忽略索引-ignore-index>忽略索引 IGNORE INDEX</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=w> </span><span class=k>IGNORE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=p>(</span><span class=n>FIELD1</span><span class=p>,</span><span class=w> </span><span class=n>FIELD2</span><span class=p>)</span><span class=w> </span><span class=err>…</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>在上面的 SQL 语句中，TABLE1 表中 FIELD1 和 FIELD2 上的索引不被使用。</p><h3 id=关闭查询缓冲-sql_no_cache>关闭查询缓冲 SQL_NO_CACHE</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_NO_CACHE</span><span class=w> </span><span class=n>field1</span><span class=p>,</span><span class=w> </span><span class=n>field2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>有一些 SQL 语句需要实时地查询数据，或者并不经常使用（可能一天就执行一两次），这样就需要把缓冲关了；不管这条 SQL 语句是否被执行过，服务器都不会在缓冲区中查找，每次都会执行它。</p><h3 id=强制查询缓冲-sql_cache>强制查询缓冲 SQL_CACHE</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_CALHE</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>如果在 my.ini 中的 query_cache_type 设成 2，这样只有在使用了 SQL_CACHE 后，才使用查询缓冲。</p><h3 id=优先操作-high_priority>优先操作 HIGH_PRIORITY</h3><p>HIGH_PRIORITY 可以使用在 select 和 insert 操作中，让 MySQL 知道，这个操作优先进行。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>HIGH_PRIORITY</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><h3 id=滞后操作-low_priority>滞后操作 LOW_PRIORITY</h3><p>LOW_PRIORITY 可以使用在 insert 和 update 操作中，让 MySQL 知道，这个操作滞后。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>update</span><span class=w> </span><span class=n>LOW_PRIORITY</span><span class=w> </span><span class=n>table1</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>field1</span><span class=o>=</span><span class=w> </span><span class=k>where</span><span class=w> </span><span class=n>field1</span><span class=o>=</span><span class=w> </span><span class=err>…</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><h3 id=延时插入-insert-delayed>延时插入 INSERT DELAYED</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>INSERT</span><span class=w> </span><span class=n>DELAYED</span><span class=w> </span><span class=k>INTO</span><span class=w> </span><span class=n>table1</span><span class=w> </span><span class=k>set</span><span class=w> </span><span class=n>field1</span><span class=o>=</span><span class=w> </span><span class=err>…</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>INSERT DELAYED INTO，是客户端提交数据给 MySQL，MySQL 返回 OK 状态给客户端。而此时并不是已经将数据插入表，而是存储在内存里面等待排队，当 MySQL 有空余时，再插入。</p><p>另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。坏处是，不能返回自动递增的 ID，以及系统崩溃时，MySQL 还没有来得及插入数据的话，这些数据将会丢失。</p><h3 id=强制连接顺序-straight_join>强制连接顺序 STRAIGHT_JOIN</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>TABLE1</span><span class=p>.</span><span class=n>FIELD1</span><span class=p>,</span><span class=w> </span><span class=n>TABLE2</span><span class=p>.</span><span class=n>FIELD2</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=w> </span><span class=n>STRAIGHT_JOIN</span><span class=w> </span><span class=n>TABLE2</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=err>…</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>由上面的 SQL 语句可知，通过 STRAIGHT_JOIN 强迫 MySQL 按 TABLE1、TABLE2 的顺序连接表。</p><p>如果你认为按自己的顺序比 MySQL 推荐的顺序进行连接的效率高的话，就可以通过 STRAIGHT_JOIN 来确定连接顺序。</p><h3 id=强制使用临时表-sql_buffer_result>强制使用临时表 SQL_BUFFER_RESULT</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_BUFFER_RESULT</span><span class=w> </span><span class=o>*</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=err>…</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>当我们查询的结果集中的数据比较多时，可以通过 SQL_BUFFER_RESULT 选项强制将结果集放到临时表中，这样就可以很快地释放 MySQL 的表锁（这样其它的 SQL 语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集。</p><h3 id=分组使用临时表-sql_big_result-和-sql_small_result>分组使用临时表 SQL_BIG_RESULT 和 SQL_SMALL_RESULT</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=n>SQL_BUFFER_RESULT</span><span class=w> </span><span class=n>FIELD1</span><span class=p>,</span><span class=w> </span><span class=k>COUNT</span><span class=p>(</span><span class=o>*</span><span class=p>)</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>TABLE1</span><span class=w> </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>FIELD1</span><span class=p>;</span><span class=w> 
</span></span></span></code></pre></td></tr></table></div></div><p>一般用于分组或 DISTINCT 关键字，这个选项通知 MySQL，如果有必要，就将查询结果放到临时表中，甚至在临时表中进行排序。</p><p>SQL_SMALL_RESULT 比起 SQL_BIG_RESULT 差不多，很少使用。</p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="2023-06-14 12:27:03">更新于 2023-06-14</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://trouvaille0198.github.io/Notes/posts/database/mysql/%E7%B4%A2%E5%BC%95/ data-title="MySQL 索引" data-hashtags=数据库,MySQL><i class="fa-brands fa-twitter fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://trouvaille0198.github.io/Notes/posts/database/mysql/%E7%B4%A2%E5%BC%95/ data-hashtag=数据库><i class="fa-brands fa-facebook-square fa-fw"></i></a>
<a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://trouvaille0198.github.io/Notes/posts/database/mysql/%E7%B4%A2%E5%BC%95/ data-title="MySQL 索引"><i class="fa-brands fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fa-solid fa-tags fa-fw"></i>&nbsp;<a href=/Notes/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/>数据库</a>,&nbsp;<a href=/Notes/tags/mysql/>MySQL</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/Notes/>主页</a></span></section></div><div class=post-nav><a href=/Notes/posts/database/mysql/%E4%B8%80%E4%BA%9B%E5%85%AB%E8%82%A1/ class=prev rel=prev title="关于 MySQL 的一些八股"><i class="fa-solid fa-angle-left fa-fw"></i>关于 MySQL 的一些八股</a>
<a href=/Notes/posts/database/mysql/%E4%BA%8B%E5%8A%A1/ class=next rel=next title="MySQL 事务">MySQL 事务<i class="fa-solid fa-angle-right fa-fw"></i></a></div></div></article></main><footer class=footer><div class=footer-container><div class="footer-line custom">酒困路长惟欲睡，日高人渴漫思茶</div><div class="footer-line copyright"><i class="fa-regular fa-copyright fa-fw"></i>
<span itemprop=copyrightYear>2022 - 2023</span><span class="license footer-divider"><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div><div class="footer-line statistics"></div></div></footer></div><div class=widgets><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fa-solid fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fa-solid fa-comment fa-fw"></i></a></div><div id=mask></div></div><link rel=stylesheet href=/Notes/lib/katex/katex.min.css><link rel=stylesheet href=/Notes/lib/katex/copy-tex.min.css><link rel=stylesheet href=/Notes/lib/cookieconsent/cookieconsent.min.css><script type=text/javascript src=/Notes/lib/autocomplete/autocomplete.min.js defer></script><script type=text/javascript src=/Notes/lib/algoliasearch/algoliasearch-lite.umd.min.js defer></script><script type=text/javascript src=/Notes/lib/lazysizes/lazysizes.min.js async defer></script><script type=text/javascript src=/Notes/lib/sharer/sharer.min.js async defer></script><script type=text/javascript src=/Notes/lib/katex/katex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/auto-render.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/copy-tex.min.js defer></script><script type=text/javascript src=/Notes/lib/katex/mhchem.min.js defer></script><script type=text/javascript src=/Notes/lib/cookieconsent/cookieconsent.min.js defer></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",editLockTitle:"锁定可编辑代码块",editUnLockTitle:"解锁可编辑代码块",editable:!0,maxShownLines:45},comment:{},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},enablePWA:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"7I9AMOLA4S",algoliaIndex:"Notes",algoliaSearchKey:"3c1638dfe9f4d49a59d81ff6943416b8",highlightTag:"em",maxResultLength:30,noResultsFound:"没有找到结果",snippetLength:50,type:"algolia"}}</script><script type=text/javascript src=/Notes/js/theme.min.js defer></script><script type=text/javascript src=/Notes/js/_custom.min.js defer></script></body></html>