<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>伤心肠粉的酱油碟子</title><link>https://trouvaille0198.github.io/Notes/</link><description>伤心肠粉的酱油碟子</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trouvaille0198.github.io/Notes/index.xml" rel="self" type="application/rss+xml"/><item><title>channel 用例大全</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/</link><pubDate>Sun, 06 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/channel-%E7%94%A8%E4%BE%8B%E5%A4%A7%E5%85%A8/</guid><description>channel 用例大全 本文摘自 https://gfw.go101.org/article/channel-use-cases.html 本文将展示很多通道用例。 希望这篇文章能够说服你接收下面的观点： 使用通道进行异步和并发编程是简单和惬意的； 通道同步技术比被</description></item><item><title>54. 螺旋矩阵</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link><pubDate>Sat, 05 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/54.-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid><description>54. 螺旋矩阵 mid 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 示例 1： 1 2 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] 输出：[1,2,3,6,</description></item><item><title>283. 移动零</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/283.-%E7%A7%BB%E5%8A%A8%E9%9B%B6/</guid><description>283. 移动零 easy 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 请注意 ，必须在不复制数组的情况下原地对数组</description></item><item><title>367. 有效的完全平方数</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/367.-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid><description>367. 有效的完全平方数 easy 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。 进阶：不要 使用任何内置的库函数，如 sqrt 。 示例</description></item><item><title>69. x 的平方根</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/69.-x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/</guid><description><![CDATA[69. x 的 平方根 easy 二分法 不多 bb 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 func mySqrt(x int) int { low, high := 0, x for low &lt;= high { mid := low + (high-low)&gt;&gt;1 if mid*mid &lt; x { if (mid+1)*(mid+1) &gt; x { // 找到最后一个小于]]></description></item><item><title>977. 有序数组的平方</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</link><pubDate>Fri, 04 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/array/977.-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9/</guid><description>977. 有序数组的平方 easy 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 1 2 3 4 输入：</description></item><item><title>Go runtime/pprof库</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E6%A0%87%E5%87%86%E5%BA%93/pprof/</guid><description>runtime/pprof benchmark(基准测试) 可以度量某个函数或方法的性能，也就是说，如果我们知道性能的瓶颈点在哪里，benchmark 是一个非常好的方式</description></item><item><title>Go 进阶</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E8%BF%9B%E9%98%B6/</guid><description>Go 进阶 内存对齐 引入 1 2 3 4 5 6 7 type Part1 struct { a bool b int32 c int8 d int64 e byte } 在开始之前，希望你计算一下 Part1 共占用的大小是多少呢？ 1 2 3 4 5 6 7 8 func main() { fmt.Printf(&amp;#34;bool size: %d\n&amp;#34;,</description></item><item><title>Go 高性能编程</title><link>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/golang/%E8%BF%9B%E9%98%B6/go-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BC%96%E7%A8%8B/</guid><description>Go 高性能编程 常用数据结构 字符串高效拼接 在 Go 语言中，字符串 (string) 是不可变的，拼接字符串事实上是创建了一个新的字符串对象。 如果代码中存在大量的字符串</description></item><item><title>剑指 Offer 15. 二进制中1的个数</title><link>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><author>作者</author><guid>https://trouvaille0198.github.io/Notes/posts/%E5%88%B7%E9%A2%98/others/%E5%89%91%E6%8C%87-offer-15.-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid><description>剑指 Offer 15. 二进制中1的个数 easy 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &amp;lsquo;1&amp;rsquo; 的个数（也被称为 汉明重量)</description></item></channel></rss>